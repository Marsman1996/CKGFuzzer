{
  "src": {
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-dlpi.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\npcap_read_dlpi(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tint cc;\n\tu_char *bp;\n\tint flags;\n\tbpf_u_int32 ctlbuf[MAXDLBUF];\n\tstruct strbuf ctl = {\n\t\tMAXDLBUF,\n\t\t0,\n\t\t(char *)ctlbuf\n\t};\n\tstruct strbuf data;\n\n\tflags = 0;\n\tcc = p->cc;\n\tif (cc == 0) {\n\t\tdata.buf = (char *)p->buffer + p->offset;\n\t\tdata.maxlen = p->bufsize;\n\t\tdata.len = 0;\n\t\tdo {\n\t\t\t/*\n\t\t\t * Has \"pcap_breakloop()\" been called?\n\t\t\t */\n\t\t\tif (p->break_loop) {\n\t\t\t\t/*\n\t\t\t\t * Yes - clear the flag that indicates\n\t\t\t\t * that it has, and return -2 to\n\t\t\t\t * indicate that we were told to\n\t\t\t\t * break out of the loop.\n\t\t\t\t */\n\t\t\t\tp->break_loop = 0;\n\t\t\t\treturn (-2);\n\t\t\t}\n\t\t\t/*\n\t\t\t * XXX - check for the DLPI primitive, which\n\t\t\t * would be DL_HP_RAWDATA_IND on HP-UX\n\t\t\t * if we're in raw mode?\n\t\t\t */\n\t\t\tctl.buf = (char *)ctlbuf;\n\t\t\tctl.maxlen = MAXDLBUF;\n\t\t\tctl.len = 0;\n\t\t\tif (getmsg(p->fd, &ctl, &data, &flags) < 0) {\n\t\t\t\t/* Don't choke when we get ptraced */\n\t\t\t\tswitch (errno) {\n\n\t\t\t\tcase EINTR:\n\t\t\t\t\tcc = 0;\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcase EAGAIN:\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    sizeof(p->errbuf), errno, \"getmsg\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tcc = data.len;\n\t\t} while (cc == 0);\n\t\tbp = (u_char *)p->buffer + p->offset;\n\t} else\n\t\tbp = p->bp;\n\n\treturn (pcap_process_pkts(p, callback, user, cnt, bp, cc));\n}",
          "fn_code_pos": [
            [
              182,
              0
            ],
            [
              246,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_dlpi",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_inject_dlpi(pcap_t *p, const void *buf, int size)\n{\n#ifdef DL_HP_RAWDLS\n\tstruct pcap_dlpi *pd = p->priv;\n#endif\n\tint ret;\n\n#if defined(DLIOCRAW)\n\tret = write(p->fd, buf, size);\n\tif (ret == -1) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"send\");\n\t\treturn (-1);\n\t}\n#elif defined(DL_HP_RAWDLS)\n\tif (pd->send_fd < 0) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"send: Output FD couldn't be opened\");\n\t\treturn (-1);\n\t}\n\tret = dlrawdatareq(pd->send_fd, buf, size);\n\tif (ret == -1) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"send\");\n\t\treturn (-1);\n\t}\n\t/*\n\t * putmsg() returns either 0 or -1; it doesn't indicate how\n\t * many bytes were written (presumably they were all written\n\t * or none of them were written).  OpenBSD's pcap_inject()\n\t * returns the number of bytes written, so, for API compatibility,\n\t * we return the number of bytes we were told to write.\n\t */\n\tret = size;\n#else /* no raw mode */\n\t/*\n\t * XXX - this is a pain, because you might have to extract\n\t * the address from the packet and use it in a DL_UNITDATA_REQ\n\t * request.  That would be dependent on the link-layer type.\n\t *\n\t * I also don't know what SAP you'd have to bind the descriptor\n\t * to, or whether you'd need separate \"receive\" and \"send\" FDs,\n\t * nor do I know whether you'd need different bindings for\n\t * D/I/X Ethernet and 802.3, or for {FDDI,Token Ring} plus\n\t * 802.2 and {FDDI,Token Ring} plus 802.2 plus SNAP.\n\t *\n\t * So, for now, we just return a \"you can't send\" indication,\n\t * and leave it up to somebody with a DLPI-based system lacking\n\t * both DLIOCRAW and DL_HP_RAWDLS to supply code to implement\n\t * packet transmission on that system.  If they do, they should\n\t * send it to us - but should not send us code that assumes\n\t * Ethernet; if the code doesn't work on non-Ethernet interfaces,\n\t * it should check \"p->linktype\" and reject the send request if\n\t * it's anything other than DLT_EN10MB.\n\t */\n\tpcap_strlcpy(p->errbuf, \"send: Not supported on this version of this OS\",\n\t    PCAP_ERRBUF_SIZE);\n\tret = -1;\n#endif /* raw mode */\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              248,
              0
            ],
            [
              309,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject_dlpi",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\npcap_cleanup_dlpi(pcap_t *p)\n{\n#ifdef DL_HP_RAWDLS\n\tstruct pcap_dlpi *pd = p->priv;\n\n\tif (pd->send_fd >= 0) {\n\t\tclose(pd->send_fd);\n\t\tpd->send_fd = -1;\n\t}\n#endif\n\tpcap_cleanup_live_common(p);\n}",
          "fn_code_pos": [
            [
              327,
              0
            ],
            [
              339,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_cleanup_dlpi",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nopen_dlpi_device(const char *name, u_int *ppa, char *errbuf)\n{\n\tint status;\n\tchar dname[100];\n\tchar *cp;\n\tint fd;\n#ifdef HAVE_DEV_DLPI\n\tu_int unit;\n#else\n\tchar dname2[100];\n#endif\n\n#ifdef HAVE_DEV_DLPI\n\t/*\n\t** Remove any \"/dev/\" on the front of the device.\n\t*/\n\tcp = strrchr(name, '/');\n\tif (cp == NULL)\n\t\tpcap_strlcpy(dname, name, sizeof(dname));\n\telse\n\t\tpcap_strlcpy(dname, cp + 1, sizeof(dname));\n\n\t/*\n\t * Split the device name into a device type name and a unit number;\n\t * chop off the unit number, so \"dname\" is just a device type name.\n\t */\n\tcp = split_dname(dname, &unit, errbuf);\n\tif (cp == NULL)\n\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\t*cp = '\\0';\n\n\t/*\n\t * Use \"/dev/dlpi\" as the device.\n\t *\n\t * XXX - HP's DLPI Programmer's Guide for HP-UX 11.00 says that\n\t * the \"dl_mjr_num\" field is for the \"major number of interface\n\t * driver\"; that's the major of \"/dev/dlpi\" on the system on\n\t * which I tried this, but there may be DLPI devices that\n\t * use a different driver, in which case we may need to\n\t * search \"/dev\" for the appropriate device with that major\n\t * device number, rather than hardwiring \"/dev/dlpi\".\n\t */\n\tcp = \"/dev/dlpi\";\n\tif ((fd = open(cp, O_RDWR)) < 0) {\n\t\tif (errno == EPERM || errno == EACCES)\n\t\t\tstatus = PCAP_ERROR_PERM_DENIED;\n\t\telse\n\t\t\tstatus = PCAP_ERROR;\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"%s\", cp);\n\t\treturn (status);\n\t}\n\n\t/*\n\t * Get a table of all PPAs for that device, and search that\n\t * table for the specified device type name and unit number.\n\t */\n\tstatus = get_dlpi_ppa(fd, dname, unit, ppa, errbuf);\n\tif (status < 0) {\n\t\tclose(fd);\n\t\treturn (status);\n\t}\n#else\n\t/*\n\t * If the device name begins with \"/\", assume it begins with\n\t * the pathname of the directory containing the device to open;\n\t * otherwise, concatenate the device directory name and the\n\t * device name.\n\t */\n\tif (*name == '/')\n\t\tpcap_strlcpy(dname, name, sizeof(dname));\n\telse\n\t\tpcap_snprintf(dname, sizeof(dname), \"%s/%s\", PCAP_DEV_PREFIX,\n\t\t    name);\n\n\t/*\n\t * Get the unit number, and a pointer to the end of the device\n\t * type name.\n\t */\n\tcp = split_dname(dname, ppa, errbuf);\n\tif (cp == NULL)\n\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\n\t/*\n\t * Make a copy of the device pathname, and then remove the unit\n\t * number from the device pathname.\n\t */\n\tpcap_strlcpy(dname2, dname, sizeof(dname));\n\t*cp = '\\0';\n\n\t/* Try device without unit number */\n\tif ((fd = open(dname, O_RDWR)) < 0) {\n\t\tif (errno != ENOENT) {\n\t\t\tif (errno == EPERM || errno == EACCES)\n\t\t\t\tstatus = PCAP_ERROR_PERM_DENIED;\n\t\t\telse\n\t\t\t\tstatus = PCAP_ERROR;\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"%s\", dname);\n\t\t\treturn (status);\n\t\t}\n\n\t\t/* Try again with unit number */\n\t\tif ((fd = open(dname2, O_RDWR)) < 0) {\n\t\t\tif (errno == ENOENT) {\n\t\t\t\tstatus = PCAP_ERROR_NO_SUCH_DEVICE;\n\n\t\t\t\t/*\n\t\t\t\t * We provide an error message even\n\t\t\t\t * for this error, for diagnostic\n\t\t\t\t * purposes (so that, for example,\n\t\t\t\t * the app can show the message if the\n\t\t\t\t * user requests it).\n\t\t\t\t *\n\t\t\t\t * In it, we just report \"No DLPI device\n\t\t\t\t * found\" with the device name, so people\n\t\t\t\t * don't get confused and think, for example,\n\t\t\t\t * that if they can't capture on \"lo0\"\n\t\t\t\t * on Solaris prior to Solaris 11 the fix\n\t\t\t\t * is to change libpcap (or the application\n\t\t\t\t * that uses it) to look for something other\n\t\t\t\t * than \"/dev/lo0\", as the fix is to use\n\t\t\t\t * Solaris 11 or some operating system\n\t\t\t\t * other than Solaris - you just *can't*\n\t\t\t\t * capture on a loopback interface\n\t\t\t\t * on Solaris prior to Solaris 11, the lack\n\t\t\t\t * of a DLPI device for the loopback\n\t\t\t\t * interface is just a symptom of that\n\t\t\t\t * inability.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"%s: No DLPI device found\", name);\n\t\t\t} else {\n\t\t\t\tif (errno == EPERM || errno == EACCES)\n\t\t\t\t\tstatus = PCAP_ERROR_PERM_DENIED;\n\t\t\t\telse\n\t\t\t\t\tstatus = PCAP_ERROR;\n\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"%s\", dname2);\n\t\t\t}\n\t\t\treturn (status);\n\t\t}\n\t\t/* XXX Assume unit zero */\n\t\t*ppa = 0;\n\t}\n#endif\n\treturn (fd);\n}",
          "fn_code_pos": [
            [
              341,
              0
            ],
            [
              489,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "open_dlpi_device",
            "parameters": {
              "name": "char",
              "ppa": "u_int",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static char *\nsplit_dname(char *device, u_int *unitp, char *ebuf)\n{\n\tchar *cp;\n\tchar *eos;\n\tlong unit;\n\n\t/*\n\t * Look for a number at the end of the device name string.\n\t */\n\tcp = device + strlen(device) - 1;\n\tif (*cp < '0' || *cp > '9') {\n\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE, \"%s missing unit number\",\n\t\t    device);\n\t\treturn (NULL);\n\t}\n\n\t/* Digits at end of string are unit number */\n\twhile (cp-1 >= device && *(cp-1) >= '0' && *(cp-1) <= '9')\n\t\tcp--;\n\n\terrno = 0;\n\tunit = strtol(cp, &eos, 10);\n\tif (*eos != '\\0') {\n\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE, \"%s bad unit number\", device);\n\t\treturn (NULL);\n\t}\n\tif (errno == ERANGE || unit > INT_MAX) {\n\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE, \"%s unit number too large\",\n\t\t    device);\n\t\treturn (NULL);\n\t}\n\tif (unit < 0) {\n\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE, \"%s unit number is negative\",\n\t\t    device);\n\t\treturn (NULL);\n\t}\n\t*unitp = (u_int)unit;\n\treturn (cp);\n}",
          "fn_code_pos": [
            [
              865,
              0
            ],
            [
              904,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "split_dname",
            "parameters": {
              "device": "char",
              "unitp": "u_int",
              "ebuf": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static int\ndl_doattach(int fd, int ppa, char *ebuf)\n{\n\tdl_attach_req_t\treq;\n\tbpf_u_int32 buf[MAXDLBUF];\n\tint err;\n\n\treq.dl_primitive = DL_ATTACH_REQ;\n\treq.dl_ppa = ppa;\n\tif (send_request(fd, (char *)&req, sizeof(req), \"attach\", ebuf) < 0)\n\t\treturn (PCAP_ERROR);\n\n\terr = dlokack(fd, \"attach\", (char *)buf, ebuf);\n\tif (err < 0)\n\t\treturn (err);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              906,
              0
            ],
            [
              922,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dl_doattach",
            "parameters": {
              "fd": "int",
              "ppa": "int",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndl_dohpuxbind(int fd, char *ebuf)\n{\n\tint hpsap;\n\tint uerror;\n\tbpf_u_int32 buf[MAXDLBUF];\n\n\t/*\n\t * XXX - we start at 22 because we used to use only 22, but\n\t * that was just because that was the value used in some\n\t * sample code from HP.  With what value *should* we start?\n\t * Does it matter, given that we're enabling SAP promiscuity\n\t * on the input FD?\n\t */\n\thpsap = 22;\n\tfor (;;) {\n\t\tif (dlbindreq(fd, hpsap, ebuf) < 0)\n\t\t\treturn (-1);\n\t\tif (dlbindack(fd, (char *)buf, ebuf, &uerror) >= 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * For any error other than a UNIX EBUSY, give up.\n\t\t */\n\t\tif (uerror != EBUSY) {\n\t\t\t/*\n\t\t\t * dlbindack() has already filled in ebuf for\n\t\t\t * this error.\n\t\t\t */\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * For EBUSY, try the next SAP value; that means that\n\t\t * somebody else is using that SAP.  Clear ebuf so\n\t\t * that application doesn't report the \"Device busy\"\n\t\t * error as a warning.\n\t\t */\n\t\t*ebuf = '\\0';\n\t\thpsap++;\n\t\tif (hpsap > 100) {\n\t\t\tpcap_strlcpy(ebuf,\n\t\t\t    \"All SAPs from 22 through 100 are in use\",\n\t\t\t    PCAP_ERRBUF_SIZE);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              925,
              0
            ],
            [
              972,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dl_dohpuxbind",
            "parameters": {
              "fd": "int",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndlpromiscon(pcap_t *p, bpf_u_int32 level)\n{\n\tdl_promiscon_req_t req;\n\tbpf_u_int32 buf[MAXDLBUF];\n\tint err;\n\n\treq.dl_primitive = DL_PROMISCON_REQ;\n\treq.dl_level = level;\n\tif (send_request(p->fd, (char *)&req, sizeof(req), \"promiscon\",\n\t    p->errbuf) < 0)\n\t\treturn (PCAP_ERROR);\n\terr = dlokack(p->fd, \"promiscon\" STRINGIFY(level), (char *)buf,\n\t    p->errbuf);\n\tif (err < 0)\n\t\treturn (err);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              977,
              0
            ],
            [
              994,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlpromiscon",
            "parameters": {
              "p": "pcap_t",
              "level": "bpf_u_int32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nis_dlpi_interface(const char *name)\n{\n\tint fd;\n\tu_int ppa;\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\n\tfd = open_dlpi_device(name, &ppa, errbuf);\n\tif (fd < 0) {\n\t\t/*\n\t\t * Error - was it PCAP_ERROR_NO_SUCH_DEVICE?\n\t\t */\n\t\tif (fd == PCAP_ERROR_NO_SUCH_DEVICE) {\n\t\t\t/*\n\t\t\t * Yes, so we can't open this because it's\n\t\t\t * not a DLPI interface.\n\t\t\t */\n\t\t\treturn (0);\n\t\t}\n\t\t/*\n\t\t * No, so, in the case where there's a single DLPI\n\t\t * device for all interfaces of this type (\"style\n\t\t * 2\" providers?), we don't know whether it's a DLPI\n\t\t * interface or not, as we didn't try an attach.\n\t\t * Say it is a DLPI device, so that the user can at\n\t\t * least try to open it and report the error (which\n\t\t * is probably \"you don't have permission to open that\n\t\t * DLPI device\"; reporting those interfaces means\n\t\t * users will ask \"why am I getting a permissions error\n\t\t * when I try to capture\" rather than \"why am I not\n\t\t * seeing any interfaces\", making the underlying problem\n\t\t * clearer).\n\t\t */\n\t\treturn (1);\n\t}\n\n\t/*\n\t * Success.\n\t */\n\tclose(fd);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1003,
              0
            ],
            [
              1044,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "is_dlpi_interface",
            "parameters": {
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nget_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)\n{\n\t/*\n\t * Nothing we can do other than mark loopback devices as \"the\n\t * connected/disconnected status doesn't apply\".\n\t *\n\t * XXX - on Solaris, can we do what the dladm command does,\n\t * i.e. get a connected/disconnected indication from a kstat?\n\t * (Note that you can also get the link speed, and possibly\n\t * other information, from a kstat as well.)\n\t */\n\tif (*flags & PCAP_IF_LOOPBACK) {\n\t\t/*\n\t\t * Loopback devices aren't wireless, and \"connected\"/\n\t\t * \"disconnected\" doesn't apply to them.\n\t\t */\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\t\treturn (0);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1046,
              0
            ],
            [
              1067,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_if_flags",
            "parameters": {
              "name": "char",
              "flags": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n#ifdef HAVE_SOLARIS\n\tint fd;\n\tunion {\n\t\tu_int nunits;\n\t\tchar pad[516];\t/* XXX - must be at least 513; is 516\n\t\t\t\t   in \"atmgetunits\" */\n\t} buf;\n\tchar baname[2+1+1];\n\tu_int i;\n#endif\n\n\t/*\n\t * Get the list of regular interfaces first.\n\t */\n\tif (pcap_findalldevs_interfaces(devlistp, errbuf, is_dlpi_interface,\n\t    get_if_flags) == -1)\n\t\treturn (-1);\t/* failure */\n\n#ifdef HAVE_SOLARIS\n\t/*\n\t * We may have to do special magic to get ATM devices.\n\t */\n\tif ((fd = open(\"/dev/ba\", O_RDWR)) < 0) {\n\t\t/*\n\t\t * We couldn't open the \"ba\" device.\n\t\t * For now, just give up; perhaps we should\n\t\t * return an error if the problem is neither\n\t\t * a \"that device doesn't exist\" error (ENOENT,\n\t\t * ENXIO, etc.) or a \"you're not allowed to do\n\t\t * that\" error (EPERM, EACCES).\n\t\t */\n\t\treturn (0);\n\t}\n\n\tif (strioctl(fd, A_GET_UNITS, sizeof(buf), (char *)&buf) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"A_GET_UNITS\");\n\t\treturn (-1);\n\t}\n\tfor (i = 0; i < buf.nunits; i++) {\n\t\tpcap_snprintf(baname, sizeof baname, \"ba%u\", i);\n\t\t/*\n\t\t * XXX - is there a notion of \"up\" and \"running\"?\n\t\t * And is there a way to determine whether the\n\t\t * interface is plugged into a network?\n\t\t */\n\t\tif (add_dev(devlistp, baname, 0, NULL, errbuf) == NULL)\n\t\t\treturn (-1);\n\t}\n#endif\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1069,
              0
            ],
            [
              1124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_platform_finddevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nsend_request(int fd, char *ptr, int len, char *what, char *ebuf)\n{\n\tstruct\tstrbuf\tctl;\n\tint\tflags;\n\n\tctl.maxlen = 0;\n\tctl.len = len;\n\tctl.buf = ptr;\n\n\tflags = 0;\n\tif (putmsg(fd, &ctl, (struct strbuf *) NULL, flags) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"send_request: putmsg \\\"%s\\\"\", what);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1126,
              0
            ],
            [
              1143,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "send_request",
            "parameters": {
              "fd": "int",
              "ptr": "char",
              "len": "int",
              "what": "char",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nrecv_ack(int fd, int size, const char *what, char *bufp, char *ebuf, int *uerror)\n{\n\tunion\tDL_primitives\t*dlp;\n\tstruct\tstrbuf\tctl;\n\tint\tflags;\n\tchar\terrmsgbuf[PCAP_ERRBUF_SIZE];\n\tchar\tdlprimbuf[64];\n\n\t/*\n\t * Clear out \"*uerror\", so it's only set for DL_ERROR_ACK/DL_SYSERR,\n\t * making that the only place where EBUSY is treated specially.\n\t */\n\tif (uerror != NULL)\n\t\t*uerror = 0;\n\n\tctl.maxlen = MAXDLBUF;\n\tctl.len = 0;\n\tctl.buf = bufp;\n\n\tflags = 0;\n\tif (getmsg(fd, &ctl, (struct strbuf*)NULL, &flags) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"recv_ack: %s getmsg\", what);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tdlp = MAKE_DL_PRIMITIVES(ctl.buf);\n\tswitch (dlp->dl_primitive) {\n\n\tcase DL_INFO_ACK:\n\tcase DL_BIND_ACK:\n\tcase DL_OK_ACK:\n#ifdef DL_HP_PPA_ACK\n\tcase DL_HP_PPA_ACK:\n#endif\n\t\t/* These are OK */\n\t\tbreak;\n\n\tcase DL_ERROR_ACK:\n\t\tswitch (dlp->error_ack.dl_errno) {\n\n\t\tcase DL_SYSERR:\n\t\t\tif (uerror != NULL)\n\t\t\t\t*uerror = dlp->error_ack.dl_unix_errno;\n\t\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    dlp->error_ack.dl_unix_errno,\n\t\t\t    \"recv_ack: %s: UNIX error\", what);\n\t\t\tif (dlp->error_ack.dl_unix_errno == EPERM ||\n\t\t\t    dlp->error_ack.dl_unix_errno == EACCES)\n\t\t\t\treturn (PCAP_ERROR_PERM_DENIED);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"recv_ack: %s: %s\", what,\n\t\t\t    dlstrerror(errmsgbuf, sizeof (errmsgbuf), dlp->error_ack.dl_errno));\n\t\t\tif (dlp->error_ack.dl_errno == DL_BADPPA)\n\t\t\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\t\t\telse if (dlp->error_ack.dl_errno == DL_ACCESS)\n\t\t\t\treturn (PCAP_ERROR_PERM_DENIED);\n\t\t\tbreak;\n\t\t}\n\t\treturn (PCAP_ERROR);\n\n\tdefault:\n\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"recv_ack: %s: Unexpected primitive ack %s\",\n\t\t    what, dlprim(dlprimbuf, sizeof (dlprimbuf), dlp->dl_primitive));\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tif (ctl.len < size) {\n\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"recv_ack: %s: Ack too small (%d < %d)\",\n\t\t    what, ctl.len, size);\n\t\treturn (PCAP_ERROR);\n\t}\n\treturn (ctl.len);\n}",
          "fn_code_pos": [
            [
              1145,
              0
            ],
            [
              1224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "recv_ack",
            "parameters": {
              "fd": "int",
              "size": "int",
              "what": "char",
              "bufp": "char",
              "ebuf": "char",
              "uerror": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static char *\ndlstrerror(char *errbuf, size_t errbufsize, bpf_u_int32 dl_errno)\n{\n\tswitch (dl_errno) {\n\n\tcase DL_ACCESS:\n\t\treturn (\"Improper permissions for request\");\n\n\tcase DL_BADADDR:\n\t\treturn (\"DLSAP addr in improper format or invalid\");\n\n\tcase DL_BADCORR:\n\t\treturn (\"Seq number not from outstand DL_CONN_IND\");\n\n\tcase DL_BADDATA:\n\t\treturn (\"User data exceeded provider limit\");\n\n\tcase DL_BADPPA:\n#ifdef HAVE_DEV_DLPI\n\t\t/*\n\t\t * With a single \"/dev/dlpi\" device used for all\n\t\t * DLPI providers, PPAs have nothing to do with\n\t\t * unit numbers.\n\t\t */\n\t\treturn (\"Specified PPA was invalid\");\n#else\n\t\t/*\n\t\t * We have separate devices for separate devices;\n\t\t * the PPA is just the unit number.\n\t\t */\n\t\treturn (\"Specified PPA (device unit) was invalid\");\n#endif\n\n\tcase DL_BADPRIM:\n\t\treturn (\"Primitive received not known by provider\");\n\n\tcase DL_BADQOSPARAM:\n\t\treturn (\"QOS parameters contained invalid values\");\n\n\tcase DL_BADQOSTYPE:\n\t\treturn (\"QOS structure type is unknown/unsupported\");\n\n\tcase DL_BADSAP:\n\t\treturn (\"Bad LSAP selector\");\n\n\tcase DL_BADTOKEN:\n\t\treturn (\"Token used not an active stream\");\n\n\tcase DL_BOUND:\n\t\treturn (\"Attempted second bind with dl_max_conind\");\n\n\tcase DL_INITFAILED:\n\t\treturn (\"Physical link initialization failed\");\n\n\tcase DL_NOADDR:\n\t\treturn (\"Provider couldn't allocate alternate address\");\n\n\tcase DL_NOTINIT:\n\t\treturn (\"Physical link not initialized\");\n\n\tcase DL_OUTSTATE:\n\t\treturn (\"Primitive issued in improper state\");\n\n\tcase DL_SYSERR:\n\t\treturn (\"UNIX system error occurred\");\n\n\tcase DL_UNSUPPORTED:\n\t\treturn (\"Requested service not supplied by provider\");\n\n\tcase DL_UNDELIVERABLE:\n\t\treturn (\"Previous data unit could not be delivered\");\n\n\tcase DL_NOTSUPPORTED:\n\t\treturn (\"Primitive is known but not supported\");\n\n\tcase DL_TOOMANY:\n\t\treturn (\"Limit exceeded\");\n\n\tcase DL_NOTENAB:\n\t\treturn (\"Promiscuous mode not enabled\");\n\n\tcase DL_BUSY:\n\t\treturn (\"Other streams for PPA in post-attached\");\n\n\tcase DL_NOAUTO:\n\t\treturn (\"Automatic handling XID&TEST not supported\");\n\n\tcase DL_NOXIDAUTO:\n\t\treturn (\"Automatic handling of XID not supported\");\n\n\tcase DL_NOTESTAUTO:\n\t\treturn (\"Automatic handling of TEST not supported\");\n\n\tcase DL_XIDAUTO:\n\t\treturn (\"Automatic handling of XID response\");\n\n\tcase DL_TESTAUTO:\n\t\treturn (\"Automatic handling of TEST response\");\n\n\tcase DL_PENDING:\n\t\treturn (\"Pending outstanding connect indications\");\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, errbufsize, \"Error %02x\", dl_errno);\n\t\treturn (errbuf);\n\t}\n}",
          "fn_code_pos": [
            [
              1226,
              0
            ],
            [
              1332,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlstrerror",
            "parameters": {
              "errbuf": "char",
              "errbufsize": "size_t",
              "dl_errno": "bpf_u_int32"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static char *\ndlprim(char *primbuf, size_t primbufsize, bpf_u_int32 prim)\n{\n\tswitch (prim) {\n\n\tcase DL_INFO_REQ:\n\t\treturn (\"DL_INFO_REQ\");\n\n\tcase DL_INFO_ACK:\n\t\treturn (\"DL_INFO_ACK\");\n\n\tcase DL_ATTACH_REQ:\n\t\treturn (\"DL_ATTACH_REQ\");\n\n\tcase DL_DETACH_REQ:\n\t\treturn (\"DL_DETACH_REQ\");\n\n\tcase DL_BIND_REQ:\n\t\treturn (\"DL_BIND_REQ\");\n\n\tcase DL_BIND_ACK:\n\t\treturn (\"DL_BIND_ACK\");\n\n\tcase DL_UNBIND_REQ:\n\t\treturn (\"DL_UNBIND_REQ\");\n\n\tcase DL_OK_ACK:\n\t\treturn (\"DL_OK_ACK\");\n\n\tcase DL_ERROR_ACK:\n\t\treturn (\"DL_ERROR_ACK\");\n\n\tcase DL_SUBS_BIND_REQ:\n\t\treturn (\"DL_SUBS_BIND_REQ\");\n\n\tcase DL_SUBS_BIND_ACK:\n\t\treturn (\"DL_SUBS_BIND_ACK\");\n\n\tcase DL_UNITDATA_REQ:\n\t\treturn (\"DL_UNITDATA_REQ\");\n\n\tcase DL_UNITDATA_IND:\n\t\treturn (\"DL_UNITDATA_IND\");\n\n\tcase DL_UDERROR_IND:\n\t\treturn (\"DL_UDERROR_IND\");\n\n\tcase DL_UDQOS_REQ:\n\t\treturn (\"DL_UDQOS_REQ\");\n\n\tcase DL_CONNECT_REQ:\n\t\treturn (\"DL_CONNECT_REQ\");\n\n\tcase DL_CONNECT_IND:\n\t\treturn (\"DL_CONNECT_IND\");\n\n\tcase DL_CONNECT_RES:\n\t\treturn (\"DL_CONNECT_RES\");\n\n\tcase DL_CONNECT_CON:\n\t\treturn (\"DL_CONNECT_CON\");\n\n\tcase DL_TOKEN_REQ:\n\t\treturn (\"DL_TOKEN_REQ\");\n\n\tcase DL_TOKEN_ACK:\n\t\treturn (\"DL_TOKEN_ACK\");\n\n\tcase DL_DISCONNECT_REQ:\n\t\treturn (\"DL_DISCONNECT_REQ\");\n\n\tcase DL_DISCONNECT_IND:\n\t\treturn (\"DL_DISCONNECT_IND\");\n\n\tcase DL_RESET_REQ:\n\t\treturn (\"DL_RESET_REQ\");\n\n\tcase DL_RESET_IND:\n\t\treturn (\"DL_RESET_IND\");\n\n\tcase DL_RESET_RES:\n\t\treturn (\"DL_RESET_RES\");\n\n\tcase DL_RESET_CON:\n\t\treturn (\"DL_RESET_CON\");\n\n\tdefault:\n\t\tpcap_snprintf(primbuf, primbufsize, \"unknown primitive 0x%x\",\n\t\t    prim);\n\t\treturn (primbuf);\n\t}\n}",
          "fn_code_pos": [
            [
              1334,
              0
            ],
            [
              1425,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlprim",
            "parameters": {
              "primbuf": "char",
              "primbufsize": "size_t",
              "prim": "bpf_u_int32"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static int\ndlbindreq(int fd, bpf_u_int32 sap, char *ebuf)\n{\n\n\tdl_bind_req_t\treq;\n\n\tmemset((char *)&req, 0, sizeof(req));\n\treq.dl_primitive = DL_BIND_REQ;\n\t/* XXX - what if neither of these are defined? */\n#if defined(DL_HP_RAWDLS)\n\treq.dl_max_conind = 1;\t\t\t/* XXX magic number */\n\treq.dl_service_mode = DL_HP_RAWDLS;\n#elif defined(DL_CLDLS)\n\treq.dl_service_mode = DL_CLDLS;\n#endif\n\treq.dl_sap = sap;\n\n\treturn (send_request(fd, (char *)&req, sizeof(req), \"bind\", ebuf));\n}",
          "fn_code_pos": [
            [
              1427,
              0
            ],
            [
              1445,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlbindreq",
            "parameters": {
              "fd": "int",
              "sap": "bpf_u_int32",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndlbindack(int fd, char *bufp, char *ebuf, int *uerror)\n{\n\n\treturn (recv_ack(fd, DL_BIND_ACK_SIZE, \"bind\", bufp, ebuf, uerror));\n}",
          "fn_code_pos": [
            [
              1447,
              0
            ],
            [
              1452,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlbindack",
            "parameters": {
              "fd": "int",
              "bufp": "char",
              "ebuf": "char",
              "uerror": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndlokack(int fd, const char *what, char *bufp, char *ebuf)\n{\n\n\treturn (recv_ack(fd, DL_OK_ACK_SIZE, what, bufp, ebuf, NULL));\n}",
          "fn_code_pos": [
            [
              1454,
              0
            ],
            [
              1459,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlokack",
            "parameters": {
              "fd": "int",
              "what": "char",
              "bufp": "char",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndlinforeq(int fd, char *ebuf)\n{\n\tdl_info_req_t req;\n\n\treq.dl_primitive = DL_INFO_REQ;\n\n\treturn (send_request(fd, (char *)&req, sizeof(req), \"info\", ebuf));\n}",
          "fn_code_pos": [
            [
              1462,
              0
            ],
            [
              1470,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlinforeq",
            "parameters": {
              "fd": "int",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndlinfoack(int fd, char *bufp, char *ebuf)\n{\n\n\treturn (recv_ack(fd, DL_INFO_ACK_SIZE, \"info\", bufp, ebuf, NULL));\n}",
          "fn_code_pos": [
            [
              1472,
              0
            ],
            [
              1477,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlinfoack",
            "parameters": {
              "fd": "int",
              "bufp": "char",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ndlpassive(int fd, char *ebuf)\n{\n\tdl_passive_req_t req;\n\tbpf_u_int32 buf[MAXDLBUF];\n\n\treq.dl_primitive = DL_PASSIVE_REQ;\n\n\tif (send_request(fd, (char *)&req, sizeof(req), \"dlpassive\", ebuf) == 0)\n\t    (void) dlokack(fd, \"dlpassive\", (char *)buf, ebuf);\n}",
          "fn_code_pos": [
            [
              1484,
              0
            ],
            [
              1494,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlpassive",
            "parameters": {
              "fd": "int",
              "ebuf": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ndlrawdatareq(int fd, const u_char *datap, int datalen)\n{\n\tstruct strbuf ctl, data;\n\tlong buf[MAXDLBUF];\t/* XXX - char? */\n\tunion DL_primitives *dlp;\n\tint dlen;\n\n\tdlp = MAKE_DL_PRIMITIVES(buf);\n\n\tdlp->dl_primitive = DL_HP_RAWDATA_REQ;\n\tdlen = DL_HP_RAWDATA_REQ_SIZE;\n\n\t/*\n\t * HP's documentation doesn't appear to show us supplying any\n\t * address pointed to by the control part of the message.\n\t * I think that's what raw mode means - you just send the raw\n\t * packet, you don't specify where to send it to, as that's\n\t * implied by the destination address.\n\t */\n\tctl.maxlen = 0;\n\tctl.len = dlen;\n\tctl.buf = (void *)buf;\n\n\tdata.maxlen = 0;\n\tdata.len = datalen;\n\tdata.buf = (void *)datap;\n\n\treturn (putmsg(fd, &ctl, &data, 0));\n}",
          "fn_code_pos": [
            [
              1501,
              0
            ],
            [
              1530,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlrawdatareq",
            "parameters": {
              "fd": "int",
              "datap": "u_char",
              "datalen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nget_release(char *buf, size_t bufsize, bpf_u_int32 *majorp,\n    bpf_u_int32 *minorp, bpf_u_int32 *microp)\n{\n\tchar *cp;\n\n\t*majorp = 0;\n\t*minorp = 0;\n\t*microp = 0;\n\tif (sysinfo(SI_RELEASE, buf, bufsize) < 0) {\n\t\tpcap_strlcpy(buf, \"?\", bufsize);\n\t\treturn;\n\t}\n\tcp = buf;\n\tif (!isdigit((unsigned char)*cp))\n\t\treturn;\n\t*majorp = strtol(cp, &cp, 10);\n\tif (*cp++ != '.')\n\t\treturn;\n\t*minorp =  strtol(cp, &cp, 10);\n\tif (*cp++ != '.')\n\t\treturn;\n\t*microp =  strtol(cp, &cp, 10);\n}",
          "fn_code_pos": [
            [
              1534,
              0
            ],
            [
              1557,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_release",
            "parameters": {
              "buf": "char",
              "bufsize": "size_t",
              "majorp": "bpf_u_int32",
              "minorp": "bpf_u_int32",
              "microp": "bpf_u_int32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nget_dlpi_ppa(register int fd, register const char *device, register u_int unit,\n    u_int *ppa, register char *ebuf)\n{\n\tregister dl_hp_ppa_ack_t *ap;\n\tregister dl_hp_ppa_info_t *ipstart, *ip;\n\tregister u_int i;\n\tchar dname[100];\n\tregister u_long majdev;\n\tstruct stat statbuf;\n\tdl_hp_ppa_req_t\treq;\n\tchar buf[MAXDLBUF];\n\tchar *ppa_data_buf;\n\tdl_hp_ppa_ack_t\t*dlp;\n\tstruct strbuf ctl;\n\tint flags;\n\n\tmemset((char *)&req, 0, sizeof(req));\n\treq.dl_primitive = DL_HP_PPA_REQ;\n\n\tmemset((char *)buf, 0, sizeof(buf));\n\tif (send_request(fd, (char *)&req, sizeof(req), \"hpppa\", ebuf) < 0)\n\t\treturn (PCAP_ERROR);\n\n\tctl.maxlen = DL_HP_PPA_ACK_SIZE;\n\tctl.len = 0;\n\tctl.buf = (char *)buf;\n\n\tflags = 0;\n\t/*\n\t * DLPI may return a big chunk of data for a DL_HP_PPA_REQ. The normal\n\t * recv_ack will fail because it set the maxlen to MAXDLBUF (8192)\n\t * which is NOT big enough for a DL_HP_PPA_REQ.\n\t *\n\t * This causes libpcap applications to fail on a system with HP-APA\n\t * installed.\n\t *\n\t * To figure out how big the returned data is, we first call getmsg\n\t * to get the small head and peek at the head to get the actual data\n\t * length, and  then issue another getmsg to get the actual PPA data.\n\t */\n\t/* get the head first */\n\tif (getmsg(fd, &ctl, (struct strbuf *)NULL, &flags) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"get_dlpi_ppa: hpppa getmsg\");\n\t\treturn (PCAP_ERROR);\n\t}\n\tif (ctl.len == -1) {\n\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"get_dlpi_ppa: hpppa getmsg: control buffer has no data\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tdlp = (dl_hp_ppa_ack_t *)ctl.buf;\n\tif (dlp->dl_primitive != DL_HP_PPA_ACK) {\n\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"get_dlpi_ppa: hpppa unexpected primitive ack 0x%x\",\n\t\t    (bpf_u_int32)dlp->dl_primitive);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tif ((size_t)ctl.len < DL_HP_PPA_ACK_SIZE) {\n\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"get_dlpi_ppa: hpppa ack too small (%d < %lu)\",\n\t\t     ctl.len, (unsigned long)DL_HP_PPA_ACK_SIZE);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\t/* allocate buffer */\n\tif ((ppa_data_buf = (char *)malloc(dlp->dl_length)) == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"get_dlpi_ppa: hpppa malloc\");\n\t\treturn (PCAP_ERROR);\n\t}\n\tctl.maxlen = dlp->dl_length;\n\tctl.len = 0;\n\tctl.buf = (char *)ppa_data_buf;\n\t/* get the data */\n\tif (getmsg(fd, &ctl, (struct strbuf *)NULL, &flags) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"get_dlpi_ppa: hpppa getmsg\");\n\t\tfree(ppa_data_buf);\n\t\treturn (PCAP_ERROR);\n\t}\n\tif (ctl.len == -1) {\n\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"get_dlpi_ppa: hpppa getmsg: control buffer has no data\");\n\t\treturn (PCAP_ERROR);\n\t}\n\tif ((u_int)ctl.len < dlp->dl_length) {\n\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"get_dlpi_ppa: hpppa ack too small (%d < %lu)\",\n\t\t    ctl.len, (unsigned long)dlp->dl_length);\n\t\tfree(ppa_data_buf);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tap = (dl_hp_ppa_ack_t *)buf;\n\tipstart = (dl_hp_ppa_info_t *)ppa_data_buf;\n\tip = ipstart;\n\n#ifdef HAVE_DL_HP_PPA_INFO_T_DL_MODULE_ID_1\n\t/*\n\t * The \"dl_hp_ppa_info_t\" structure has a \"dl_module_id_1\"\n\t * member that should, in theory, contain the part of the\n\t * name for the device that comes before the unit number,\n\t * and should also have a \"dl_module_id_2\" member that may\n\t * contain an alternate name (e.g., I think Ethernet devices\n\t * have both \"lan\", for \"lanN\", and \"snap\", for \"snapN\", with\n\t * the former being for Ethernet packets and the latter being\n\t * for 802.3/802.2 packets).\n\t *\n\t * Search for the device that has the specified name and\n\t * instance number.\n\t */\n\tfor (i = 0; i < ap->dl_count; i++) {\n\t\tif ((strcmp((const char *)ip->dl_module_id_1, device) == 0 ||\n\t\t     strcmp((const char *)ip->dl_module_id_2, device) == 0) &&\n\t\t    ip->dl_instance_num == unit)\n\t\t\tbreak;\n\n\t\tip = (dl_hp_ppa_info_t *)((u_char *)ipstart + ip->dl_next_offset);\n\t}\n#else\n\t/*\n\t * We don't have that member, so the search is impossible; make it\n\t * look as if the search failed.\n\t */\n\ti = ap->dl_count;\n#endif\n\n\tif (i == ap->dl_count) {\n\t\t/*\n\t\t * Well, we didn't, or can't, find the device by name.\n\t\t *\n\t\t * HP-UX 10.20, whilst it has \"dl_module_id_1\" and\n\t\t * \"dl_module_id_2\" fields in the \"dl_hp_ppa_info_t\",\n\t\t * doesn't seem to fill them in unless the system is\n\t\t * at a reasonably up-to-date patch level.\n\t\t *\n\t\t * Older HP-UX 10.x systems might not have those fields\n\t\t * at all.\n\t\t *\n\t\t * Therefore, we'll search for the entry with the major\n\t\t * device number of a device with the name \"/dev/<dev><unit>\",\n\t\t * if such a device exists, as the old code did.\n\t\t */\n\t\tpcap_snprintf(dname, sizeof(dname), \"/dev/%s%u\", device, unit);\n\t\tif (stat(dname, &statbuf) < 0) {\n\t\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"stat: %s\", dname);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\tmajdev = major(statbuf.st_rdev);\n\n\t\tip = ipstart;\n\n\t\tfor (i = 0; i < ap->dl_count; i++) {\n\t\t\tif (ip->dl_mjr_num == majdev &&\n\t\t\t    ip->dl_instance_num == unit)\n\t\t\t\tbreak;\n\n\t\t\tip = (dl_hp_ppa_info_t *)((u_char *)ipstart + ip->dl_next_offset);\n\t\t}\n\t}\n\tif (i == ap->dl_count) {\n\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"can't find /dev/dlpi PPA for %s%u\", device, unit);\n\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\t}\n\tif (ip->dl_hdw_state == HDW_DEAD) {\n\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s%d: hardware state: DOWN\\n\", device, unit);\n\t\tfree(ppa_data_buf);\n\t\treturn (PCAP_ERROR);\n\t}\n\t*ppa = ip->dl_ppa;\n\tfree(ppa_data_buf);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1600,
              0
            ],
            [
              1779,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_dlpi_ppa",
            "parameters": {
              "fd": "int",
              "device": "char",
              "unit": "u_int",
              "ppa": "u_int",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nget_dlpi_ppa(register int fd, register const char *ifname, register u_int unit,\n    u_int *ppa, register char *ebuf)\n{\n\tregister const char *cp;\n\tregister int kd;\n\tvoid *addr;\n\tstruct ifnet ifnet;\n\tchar if_name[sizeof(ifnet.if_name) + 1];\n\n\tcp = strrchr(ifname, '/');\n\tif (cp != NULL)\n\t\tifname = cp + 1;\n\tif (nlist(path_vmunix, &nl) < 0) {\n\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE, \"nlist %s failed\",\n\t\t    path_vmunix);\n\t\treturn (PCAP_ERROR);\n\t}\n\tif (nl[NL_IFNET].n_value == 0) {\n\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    \"could't find %s kernel symbol\",\n\t\t    nl[NL_IFNET].n_name);\n\t\treturn (PCAP_ERROR);\n\t}\n\tkd = open(\"/dev/kmem\", O_RDONLY);\n\tif (kd < 0) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"kmem open\");\n\t\treturn (PCAP_ERROR);\n\t}\n\tif (dlpi_kread(kd, nl[NL_IFNET].n_value,\n\t    &addr, sizeof(addr), ebuf) < 0) {\n\t\tclose(kd);\n\t\treturn (PCAP_ERROR);\n\t}\n\tfor (; addr != NULL; addr = ifnet.if_next) {\n\t\tif (dlpi_kread(kd, (off_t)addr,\n\t\t    &ifnet, sizeof(ifnet), ebuf) < 0 ||\n\t\t    dlpi_kread(kd, (off_t)ifnet.if_name,\n\t\t    if_name, sizeof(ifnet.if_name), ebuf) < 0) {\n\t\t\t(void)close(kd);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\tif_name[sizeof(ifnet.if_name)] = '\\0';\n\t\tif (strcmp(if_name, ifname) == 0 && ifnet.if_unit == unit) {\n\t\t\t*ppa = ifnet.if_index;\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE, \"Can't find %s\", ifname);\n\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n}",
          "fn_code_pos": [
            [
              1796,
              0
            ],
            [
              1848,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_dlpi_ppa",
            "parameters": {
              "fd": "int",
              "ifname": "char",
              "unit": "u_int",
              "ppa": "u_int",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndlpi_kread(register int fd, register off_t addr,\n    register void *buf, register u_int len, register char *ebuf)\n{\n\tregister int cc;\n\n\tif (lseek(fd, addr, SEEK_SET) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"lseek\");\n\t\treturn (-1);\n\t}\n\tcc = read(fd, buf, len);\n\tif (cc < 0) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"read\");\n\t\treturn (-1);\n\t} else if (cc != len) {\n\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE, \"short read (%d != %d)\", cc,\n\t\t    len);\n\t\treturn (-1);\n\t}\n\treturn (cc);\n}",
          "fn_code_pos": [
            [
              1850,
              0
            ],
            [
              1872,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlpi_kread",
            "parameters": {
              "fd": "int",
              "addr": "off_t",
              "buf": "void",
              "len": "u_int",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_create_interface(const char *device _U_, char *ebuf)\n{\n\tpcap_t *p;\n#ifdef DL_HP_RAWDLS\n\tstruct pcap_dlpi *pd;\n#endif\n\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_dlpi));\n\tif (p == NULL)\n\t\treturn (NULL);\n\n#ifdef DL_HP_RAWDLS\n\tpd = p->priv;\n\tpd->send_fd = -1;\t/* it hasn't been opened yet */\n#endif\n\n\tp->activate_op = pcap_activate_dlpi;\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              1875,
              0
            ],
            [
              1894,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING);\n}",
          "fn_code_pos": [
            [
              1899,
              0
            ],
            [
              1903,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "split_dname(char *, u_int *, char *)",
          "fn_dec_pos": [
            [
              141,
              13
            ],
            [
              141,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "split_dname",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "dl_doattach(int, int, char *)",
          "fn_dec_pos": [
            [
              142,
              11
            ],
            [
              142,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dl_doattach",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dl_dohpuxbind(int, char *)",
          "fn_dec_pos": [
            [
              144,
              11
            ],
            [
              144,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dl_dohpuxbind",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dlpromiscon(pcap_t *, bpf_u_int32)",
          "fn_dec_pos": [
            [
              146,
              11
            ],
            [
              146,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlpromiscon",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dlbindreq(int, bpf_u_int32, char *)",
          "fn_dec_pos": [
            [
              147,
              11
            ],
            [
              147,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlbindreq",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dlbindack(int, char *, char *, int *)",
          "fn_dec_pos": [
            [
              148,
              11
            ],
            [
              148,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlbindack",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dlokack(int, const char *, char *, char *)",
          "fn_dec_pos": [
            [
              149,
              11
            ],
            [
              149,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlokack",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dlinforeq(int, char *)",
          "fn_dec_pos": [
            [
              150,
              11
            ],
            [
              150,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlinforeq",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dlinfoack(int, char *, char *)",
          "fn_dec_pos": [
            [
              151,
              11
            ],
            [
              151,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlinfoack",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dlpassive(int, char *)",
          "fn_dec_pos": [
            [
              154,
              12
            ],
            [
              154,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlpassive",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "dlrawdatareq(int, const u_char *, int)",
          "fn_dec_pos": [
            [
              158,
              11
            ],
            [
              158,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlrawdatareq",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "recv_ack(int, int, const char *, char *, char *, int *)",
          "fn_dec_pos": [
            [
              160,
              11
            ],
            [
              160,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "recv_ack",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dlstrerror(char *, size_t, bpf_u_int32)",
          "fn_dec_pos": [
            [
              161,
              13
            ],
            [
              161,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlstrerror",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "dlprim(char *, size_t, bpf_u_int32)",
          "fn_dec_pos": [
            [
              162,
              13
            ],
            [
              162,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlprim",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "get_release(char *, size_t, bpf_u_int32 *, bpf_u_int32 *,\n    bpf_u_int32 *)",
          "fn_dec_pos": [
            [
              165,
              12
            ],
            [
              166,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_release",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "send_request(int, char *, int, char *, char *)",
          "fn_dec_pos": [
            [
              168,
              11
            ],
            [
              168,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "send_request",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dlpi_kread(int, off_t, void *, u_int, char *)",
          "fn_dec_pos": [
            [
              170,
              11
            ],
            [
              170,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlpi_kread",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "get_dlpi_ppa(int, const char *, u_int, u_int *, char *)",
          "fn_dec_pos": [
            [
              173,
              11
            ],
            [
              173,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_dlpi_ppa",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_activate_dlpi(pcap_t *p)",
          "fn_dec_pos": [
            [
              492,
              0
            ],
            [
              492,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_activate_dlpi",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "split_dname(char *device, u_int *unitp, char *ebuf)",
          "fn_dec_pos": [
            [
              866,
              0
            ],
            [
              866,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "split_dname",
            "parameters": {
              "device": "char",
              "unitp": "u_int",
              "ebuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "dlstrerror(char *errbuf, size_t errbufsize, bpf_u_int32 dl_errno)",
          "fn_dec_pos": [
            [
              1227,
              0
            ],
            [
              1227,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlstrerror",
            "parameters": {
              "errbuf": "char",
              "errbufsize": "size_t",
              "dl_errno": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "dlprim(char *primbuf, size_t primbufsize, bpf_u_int32 prim)",
          "fn_dec_pos": [
            [
              1335,
              0
            ],
            [
              1335,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlprim",
            "parameters": {
              "primbuf": "char",
              "primbufsize": "size_t",
              "prim": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_create_interface(const char *device _U_, char *ebuf)",
          "fn_dec_pos": [
            [
              1876,
              0
            ],
            [
              1876,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              1900,
              0
            ],
            [
              1900,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct strbuf",
          {},
          "",
          [
            189,
            1
          ],
          [
            189,
            14
          ]
        ],
        [
          "struct strbuf",
          {},
          "",
          [
            194,
            1
          ],
          [
            194,
            14
          ]
        ],
        [
          "struct pcap_dlpi",
          {},
          "",
          [
            252,
            1
          ],
          [
            252,
            17
          ]
        ],
        [
          "struct pcap_dlpi",
          {},
          "",
          [
            331,
            1
          ],
          [
            331,
            17
          ]
        ],
        [
          "struct pcap_dlpi",
          {},
          "",
          [
            495,
            1
          ],
          [
            495,
            17
          ]
        ],
        [
          "struct\tstrbuf",
          {},
          "",
          [
            1129,
            1
          ],
          [
            1129,
            14
          ]
        ],
        [
          "struct strbuf",
          {},
          "",
          [
            1137,
            23
          ],
          [
            1137,
            36
          ]
        ],
        [
          "struct\tstrbuf",
          {},
          "",
          [
            1149,
            1
          ],
          [
            1149,
            14
          ]
        ],
        [
          "struct strbuf",
          {},
          "",
          [
            1166,
            23
          ],
          [
            1166,
            36
          ]
        ],
        [
          "struct strbuf",
          {},
          "",
          [
            1504,
            1
          ],
          [
            1504,
            14
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            1609,
            1
          ],
          [
            1609,
            12
          ]
        ],
        [
          "struct strbuf",
          {},
          "",
          [
            1614,
            1
          ],
          [
            1614,
            14
          ]
        ],
        [
          "struct strbuf",
          {},
          "",
          [
            1642,
            23
          ],
          [
            1642,
            36
          ]
        ],
        [
          "struct strbuf",
          {},
          "",
          [
            1678,
            23
          ],
          [
            1678,
            36
          ]
        ],
        [
          "struct nlist",
          {},
          "",
          [
            1787,
            7
          ],
          [
            1787,
            19
          ]
        ],
        [
          "struct ifnet",
          {},
          "",
          [
            1803,
            1
          ],
          [
            1803,
            13
          ]
        ],
        [
          "struct pcap_dlpi",
          {},
          "",
          [
            1880,
            1
          ],
          [
            1880,
            17
          ]
        ],
        [
          "struct pcap_dlpi",
          {},
          "",
          [
            1883,
            38
          ],
          [
            1883,
            54
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            71,
            0
          ],
          [
            72,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            74,
            0
          ],
          [
            75,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            75,
            0
          ],
          [
            76,
            0
          ]
        ],
        [
          "#include <sys/bufmod.h>\n",
          [
            77,
            0
          ],
          [
            78,
            0
          ]
        ],
        [
          "#include <sys/dlpi.h>\n",
          [
            79,
            0
          ],
          [
            80,
            0
          ]
        ],
        [
          "#include <sys/dlpi_ext.h>\n",
          [
            81,
            0
          ],
          [
            82,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            84,
            0
          ],
          [
            85,
            0
          ]
        ],
        [
          "#include <sys/stat.h>\n",
          [
            87,
            0
          ],
          [
            88,
            0
          ]
        ],
        [
          "#include <sys/stream.h>\n",
          [
            89,
            0
          ],
          [
            90,
            0
          ]
        ],
        [
          "#include <sys/systeminfo.h>\n",
          [
            91,
            0
          ],
          [
            92,
            0
          ]
        ],
        [
          "#include <net/if.h>\n",
          [
            95,
            0
          ],
          [
            96,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            98,
            0
          ],
          [
            99,
            0
          ]
        ],
        [
          "#include <nlist.h>\n",
          [
            100,
            0
          ],
          [
            101,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            102,
            0
          ],
          [
            103,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            103,
            0
          ],
          [
            104,
            0
          ]
        ],
        [
          "#include <memory.h>\n",
          [
            104,
            0
          ],
          [
            105,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            105,
            0
          ],
          [
            106,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            106,
            0
          ],
          [
            107,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            107,
            0
          ],
          [
            108,
            0
          ]
        ],
        [
          "#include <stropts.h>\n",
          [
            108,
            0
          ],
          [
            109,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            109,
            0
          ],
          [
            110,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            110,
            0
          ],
          [
            111,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            112,
            0
          ],
          [
            113,
            0
          ]
        ],
        [
          "#include \"dlpisubs.h\"\n",
          [
            113,
            0
          ],
          [
            114,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            116,
            0
          ],
          [
            117,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-snit.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\npcap_stats_snit(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct pcap_snit *psn = p->priv;\n\n\t/*\n\t * \"ps_recv\" counts packets handed to the filter, not packets\n\t * that passed the filter.  As filtering is done in userland,\n\t * this does not include packets dropped because we ran out\n\t * of buffer space.\n\t *\n\t * \"ps_drop\" counts packets dropped inside the \"/dev/nit\"\n\t * device because of flow control requirements or resource\n\t * exhaustion; it doesn't count packets dropped by the\n\t * interface driver, or packets dropped upstream.  As filtering\n\t * is done in userland, it counts packets regardless of whether\n\t * they would've passed the filter.\n\t *\n\t * These statistics don't include packets not yet read from the\n\t * kernel by libpcap or packets not yet read from libpcap by the\n\t * application.\n\t */\n\t*ps = psn->stat;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_snit",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_read_snit(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_snit *psn = p->priv;\n\tregister int cc, n;\n\tregister u_char *bp, *cp, *ep;\n\tregister struct nit_bufhdr *hdrp;\n\tregister struct nit_iftime *ntp;\n\tregister struct nit_iflen *nlp;\n\tregister struct nit_ifdrops *ndp;\n\tregister int caplen;\n\n\tcc = p->cc;\n\tif (cc == 0) {\n\t\tcc = read(p->fd, (char *)p->buffer, p->bufsize);\n\t\tif (cc < 0) {\n\t\t\tif (errno == EWOULDBLOCK)\n\t\t\t\treturn (0);\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t\t    errno, \"pcap_read\");\n\t\t\treturn (-1);\n\t\t}\n\t\tbp = (u_char *)p->buffer;\n\t} else\n\t\tbp = p->bp;\n\n\t/*\n\t * loop through each snapshot in the chunk\n\t */\n\tn = 0;\n\tep = bp + cc;\n\twhile (bp < ep) {\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t * If so, return immediately - if we haven't read any\n\t\t * packets, clear the flag and return -2 to indicate\n\t\t * that we were told to break out of the loop, otherwise\n\t\t * leave the flag set, so that the *next* call will break\n\t\t * out of the loop without having read any packets, and\n\t\t * return the number of packets we've processed so far.\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\tif (n == 0) {\n\t\t\t\tp->break_loop = 0;\n\t\t\t\treturn (-2);\n\t\t\t} else {\n\t\t\t\tp->bp = bp;\n\t\t\t\tp->cc = ep - bp;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t}\n\n\t\t++psn->stat.ps_recv;\n\t\tcp = bp;\n\n\t\t/* get past NIT buffer  */\n\t\thdrp = (struct nit_bufhdr *)cp;\n\t\tcp += sizeof(*hdrp);\n\n\t\t/* get past NIT timer   */\n\t\tntp = (struct nit_iftime *)cp;\n\t\tcp += sizeof(*ntp);\n\n\t\tndp = (struct nit_ifdrops *)cp;\n\t\tpsn->stat.ps_drop = ndp->nh_drops;\n\t\tcp += sizeof *ndp;\n\n\t\t/* get past packet len  */\n\t\tnlp = (struct nit_iflen *)cp;\n\t\tcp += sizeof(*nlp);\n\n\t\t/* next snapshot        */\n\t\tbp += hdrp->nhb_totlen;\n\n\t\tcaplen = nlp->nh_pktlen;\n\t\tif (caplen > p->snapshot)\n\t\t\tcaplen = p->snapshot;\n\n\t\tif (pcap_filter(p->fcode.bf_insns, cp, nlp->nh_pktlen, caplen)) {\n\t\t\tstruct pcap_pkthdr h;\n\t\t\th.ts = ntp->nh_timestamp;\n\t\t\th.len = nlp->nh_pktlen;\n\t\t\th.caplen = caplen;\n\t\t\t(*callback)(user, &h, cp);\n\t\t\tif (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt)) {\n\t\t\t\tp->cc = ep - bp;\n\t\t\t\tp->bp = bp;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t}\n\t}\n\tp->cc = 0;\n\treturn (n);\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_snit",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_inject_snit(pcap_t *p, const void *buf, int size)\n{\n\tstruct strbuf ctl, data;\n\n\t/*\n\t * XXX - can we just do\n\t *\n\tret = write(pd->f, buf, size);\n\t */\n\tctl.len = sizeof(*sa);\t/* XXX - what was this? */\n\tctl.buf = (char *)sa;\n\tdata.buf = buf;\n\tdata.len = size;\n\tret = putmsg(p->fd, &ctl, &data);\n\tif (ret == -1) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"send\");\n\t\treturn (-1);\n\t}\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              209,
              0
            ],
            [
              230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject_snit",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nnit_setflags(pcap_t *p)\n{\n\tbpf_u_int32 flags;\n\tstruct strioctl si;\n\tu_int zero = 0;\n\tstruct timeval timeout;\n\n\tif (p->opt.immediate) {\n\t\t/*\n\t\t * Set the chunk size to zero, so that chunks get sent\n\t\t * up immediately.\n\t\t */\n\t\tsi.ic_cmd = NIOCSCHUNK;\n\t\tsi.ic_len = sizeof(zero);\n\t\tsi.ic_dp = (char *)&zero;\n\t\tif (ioctl(p->fd, I_STR, (char *)&si) < 0) {\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"NIOCSCHUNK\");\n\t\t\treturn (-1);\n\t\t}\n\t}\n\tsi.ic_timout = INFTIM;\n\tif (p->opt.timeout != 0) {\n\t\ttimeout.tv_sec = p->opt.timeout / 1000;\n\t\ttimeout.tv_usec = (p->opt.timeout * 1000) % 1000000;\n\t\tsi.ic_cmd = NIOCSTIME;\n\t\tsi.ic_len = sizeof(timeout);\n\t\tsi.ic_dp = (char *)&timeout;\n\t\tif (ioctl(p->fd, I_STR, (char *)&si) < 0) {\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"NIOCSTIME\");\n\t\t\treturn (-1);\n\t\t}\n\t}\n\tflags = NI_TIMESTAMP | NI_LEN | NI_DROPS;\n\tif (p->opt.promisc)\n\t\tflags |= NI_PROMISC;\n\tsi.ic_cmd = NIOCSFLAGS;\n\tsi.ic_len = sizeof(flags);\n\tsi.ic_dp = (char *)&flags;\n\tif (ioctl(p->fd, I_STR, (char *)&si) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"NIOCSFLAGS\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              232,
              0
            ],
            [
              279,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nit_setflags",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_activate_snit(pcap_t *p)\n{\n\tstruct strioctl si;\t\t/* struct for ioctl() */\n\tstruct ifreq ifr;\t\t/* interface request struct */\n\tint chunksize = CHUNKSIZE;\n\tint fd;\n\tstatic const char dev[] = \"/dev/nit\";\n\tint err;\n\n\tif (p->opt.rfmon) {\n\t\t/*\n\t\t * No monitor mode on SunOS 4.x (no Wi-Fi devices on\n\t\t * hardware supported by SunOS 4.x).\n\t\t */\n\t\treturn (PCAP_ERROR_RFMON_NOTSUP);\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n\tif (p->snapshot < 96)\n\t\t/*\n\t\t * NIT requires a snapshot length of at least 96.\n\t\t */\n\t\tp->snapshot = 96;\n\n\t/*\n\t * Initially try a read/write open (to allow the inject\n\t * method to work).  If that fails due to permission\n\t * issues, fall back to read-only.  This allows a\n\t * non-root user to be granted specific access to pcap\n\t * capabilities via file permissions.\n\t *\n\t * XXX - we should have an API that has a flag that\n\t * controls whether to open read-only or read-write,\n\t * so that denial of permission to send (or inability\n\t * to send, if sending packets isn't supported on\n\t * the device in question) can be indicated at open\n\t * time.\n\t */\n\tp->fd = fd = open(dev, O_RDWR);\n\tif (fd < 0 && errno == EACCES)\n\t\tp->fd = fd = open(dev, O_RDONLY);\n\tif (fd < 0) {\n\t\tif (errno == EACCES)\n\t\t\terr = PCAP_ERROR_PERM_DENIED;\n\t\telse\n\t\t\terr = PCAP_ERROR;\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"%s\", dev);\n\t\tgoto bad;\n\t}\n\n\t/* arrange to get discrete messages from the STREAM and use NIT_BUF */\n\tif (ioctl(fd, I_SRDOPT, (char *)RMSGD) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"I_SRDOPT\");\n\t\terr = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\tif (ioctl(fd, I_PUSH, \"nbuf\") < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"push nbuf\");\n\t\terr = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\t/* set the chunksize */\n\tsi.ic_cmd = NIOCSCHUNK;\n\tsi.ic_timout = INFTIM;\n\tsi.ic_len = sizeof(chunksize);\n\tsi.ic_dp = (char *)&chunksize;\n\tif (ioctl(fd, I_STR, (char *)&si) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"NIOCSCHUNK\");\n\t\terr = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\t/* request the interface */\n\tstrncpy(ifr.ifr_name, p->opt.device, sizeof(ifr.ifr_name));\n\tifr.ifr_name[sizeof(ifr.ifr_name) - 1] = '\\0';\n\tsi.ic_cmd = NIOCBIND;\n\tsi.ic_len = sizeof(ifr);\n\tsi.ic_dp = (char *)&ifr;\n\tif (ioctl(fd, I_STR, (char *)&si) < 0) {\n\t\t/*\n\t\t * XXX - is there an error that means \"no such device\"?\n\t\t * Is there one that means \"that device doesn't support\n\t\t * STREAMS NIT\"?\n\t\t */\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"NIOCBIND: %s\", ifr.ifr_name);\n\t\terr = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\t/* set the snapshot length */\n\tsi.ic_cmd = NIOCSSNAP;\n\tsi.ic_len = sizeof(p->snapshot);\n\tsi.ic_dp = (char *)&p->snapshot;\n\tif (ioctl(fd, I_STR, (char *)&si) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"NIOCSSNAP\");\n\t\terr = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\tif (nit_setflags(p) < 0) {\n\t\terr = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\t(void)ioctl(fd, I_FLUSH, (char *)FLUSHR);\n\t/*\n\t * NIT supports only ethernets.\n\t */\n\tp->linktype = DLT_EN10MB;\n\n\tp->bufsize = BUFSPACE;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\terr = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * \"p->fd\" is an FD for a STREAMS device, so \"select()\" and\n\t * \"poll()\" should work on it.\n\t */\n\tp->selectable_fd = p->fd;\n\n\t/*\n\t * This is (presumably) a real Ethernet capture; give it a\n\t * link-layer-type list with DLT_EN10MB and DLT_DOCSIS, so\n\t * that an application can let you choose it, in case you're\n\t * capturing DOCSIS traffic that a Cisco Cable Modem\n\t * Termination System is putting out onto an Ethernet (it\n\t * doesn't put an Ethernet header onto the wire, it puts raw\n\t * DOCSIS frames out on the wire inside the low-level\n\t * Ethernet framing).\n\t */\n\tp->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);\n\t/*\n\t * If that fails, just leave the list empty.\n\t */\n\tif (p->dlt_list != NULL) {\n\t\tp->dlt_list[0] = DLT_EN10MB;\n\t\tp->dlt_list[1] = DLT_DOCSIS;\n\t\tp->dlt_count = 2;\n\t}\n\n\tp->read_op = pcap_read_snit;\n\tp->inject_op = pcap_inject_snit;\n\tp->setfilter_op = install_bpf_program;\t/* no kernel filtering */\n\tp->setdirection_op = NULL;\t/* Not implemented. */\n\tp->set_datalink_op = NULL;\t/* can't change data link type */\n\tp->getnonblock_op = pcap_getnonblock_fd;\n\tp->setnonblock_op = pcap_setnonblock_fd;\n\tp->stats_op = pcap_stats_snit;\n\n\treturn (0);\n bad:\n\tpcap_cleanup_live_common(p);\n\treturn (err);\n}",
          "fn_code_pos": [
            [
              281,
              0
            ],
            [
              455,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_activate_snit",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_create_interface(const char *device _U_, char *ebuf)\n{\n\tpcap_t *p;\n\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_snit));\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = pcap_activate_snit;\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              457,
              0
            ],
            [
              468,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static int\ncan_be_bound(const char *name _U_)\n{\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              474,
              0
            ],
            [
              478,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "can_be_bound",
            "parameters": {
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nget_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)\n{\n\t/*\n\t * Nothing we can do.\n\t * XXX - is there a way to find out whether an adapter has\n\t * something plugged into it?\n\t */\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              480,
              0
            ],
            [
              489,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_if_flags",
            "parameters": {
              "name": "char",
              "flags": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\treturn (pcap_findalldevs_interfaces(devlistp, errbuf, can_be_bound,\n\t    get_if_flags));\n}",
          "fn_code_pos": [
            [
              491,
              0
            ],
            [
              496,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_platform_finddevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING);\n}",
          "fn_code_pos": [
            [
              501,
              0
            ],
            [
              505,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "nit_setflags(int, int, int, char *)",
          "fn_dec_pos": [
            [
              79,
              11
            ],
            [
              79,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nit_setflags",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_create_interface(const char *device _U_, char *ebuf)",
          "fn_dec_pos": [
            [
              458,
              0
            ],
            [
              458,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              502,
              0
            ],
            [
              502,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_snit {\n\tstruct pcap_stat stat;\n}",
          {
            "stat": "struct pcap_stat"
          },
          "pcap_snit",
          [
            84,
            0
          ],
          [
            86,
            1
          ]
        ],
        [
          "struct pcap_snit {\n\tstruct pcap_stat stat;\n}",
          {
            "stat": "struct pcap_stat"
          },
          "pcap_snit",
          [
            84,
            0
          ],
          [
            86,
            1
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            85,
            1
          ],
          [
            85,
            17
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            89,
            27
          ],
          [
            89,
            43
          ]
        ],
        [
          "struct pcap_snit",
          {},
          "",
          [
            91,
            1
          ],
          [
            91,
            17
          ]
        ],
        [
          "struct pcap_snit",
          {},
          "",
          [
            117,
            1
          ],
          [
            117,
            17
          ]
        ],
        [
          "struct nit_bufhdr",
          {},
          "",
          [
            120,
            10
          ],
          [
            120,
            27
          ]
        ],
        [
          "struct nit_iftime",
          {},
          "",
          [
            121,
            10
          ],
          [
            121,
            27
          ]
        ],
        [
          "struct nit_iflen",
          {},
          "",
          [
            122,
            10
          ],
          [
            122,
            26
          ]
        ],
        [
          "struct nit_ifdrops",
          {},
          "",
          [
            123,
            10
          ],
          [
            123,
            28
          ]
        ],
        [
          "struct nit_bufhdr",
          {},
          "",
          [
            170,
            10
          ],
          [
            170,
            27
          ]
        ],
        [
          "struct nit_iftime",
          {},
          "",
          [
            174,
            9
          ],
          [
            174,
            26
          ]
        ],
        [
          "struct nit_ifdrops",
          {},
          "",
          [
            177,
            9
          ],
          [
            177,
            27
          ]
        ],
        [
          "struct nit_iflen",
          {},
          "",
          [
            182,
            9
          ],
          [
            182,
            25
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            193,
            3
          ],
          [
            193,
            21
          ]
        ],
        [
          "struct strbuf",
          {},
          "",
          [
            212,
            1
          ],
          [
            212,
            14
          ]
        ],
        [
          "struct strioctl",
          {},
          "",
          [
            236,
            1
          ],
          [
            236,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            238,
            1
          ],
          [
            238,
            15
          ]
        ],
        [
          "struct strioctl",
          {},
          "",
          [
            284,
            1
          ],
          [
            284,
            16
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            285,
            1
          ],
          [
            285,
            13
          ]
        ],
        [
          "struct pcap_snit",
          {},
          "",
          [
            462,
            38
          ],
          [
            462,
            54
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <sys/timeb.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <sys/dir.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <sys/fcntlcom.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <sys/file.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <sys/ioctl.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <sys/stropts.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <net/if.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <net/nit.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <net/nit_if.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <net/nit_pf.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <net/nit_buf.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <netinet/in_systm.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <netinet/ip.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <netinet/if_ether.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <netinet/ip_var.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <netinet/udp.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include <netinet/udp_var.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include <netinet/tcp.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <netinet/tcpip.h>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/bpf_image.c": {
      "fn_def_list": [
        {
          "fn_code": "char *\nbpf_image(const struct bpf_insn *p, int n)\n{\n\tconst char *op;\n\tstatic char image[256];\n\tchar operand_buf[64];\n\tconst char *operand;\n\n\tswitch (p->code) {\n\n\tdefault:\n\t\top = \"unimp\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"0x%x\", p->code);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_RET|BPF_K:\n\t\top = \"ret\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#%d\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_RET|BPF_A:\n\t\top = \"ret\";\n\t\toperand = \"\";\n\t\tbreak;\n\n\tcase BPF_LD|BPF_W|BPF_ABS:\n\t\top = \"ld\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"[%d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LD|BPF_H|BPF_ABS:\n\t\top = \"ldh\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"[%d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LD|BPF_B|BPF_ABS:\n\t\top = \"ldb\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"[%d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LD|BPF_W|BPF_LEN:\n\t\top = \"ld\";\n\t\toperand = \"#pktlen\";\n\t\tbreak;\n\n\tcase BPF_LD|BPF_W|BPF_IND:\n\t\top = \"ld\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"[x + %d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LD|BPF_H|BPF_IND:\n\t\top = \"ldh\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"[x + %d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LD|BPF_B|BPF_IND:\n\t\top = \"ldb\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"[x + %d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LD|BPF_IMM:\n\t\top = \"ld\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LDX|BPF_IMM:\n\t\top = \"ldx\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LDX|BPF_MSH|BPF_B:\n\t\top = \"ldxb\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"4*([%d]&0xf)\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LD|BPF_MEM:\n\t\top = \"ld\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"M[%d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_LDX|BPF_MEM:\n\t\top = \"ldx\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"M[%d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ST:\n\t\top = \"st\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"M[%d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_STX:\n\t\top = \"stx\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"M[%d]\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JA:\n\t\top = \"ja\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"%d\", n + 1 + p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JGT|BPF_K:\n\t\top = \"jgt\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JGE|BPF_K:\n\t\top = \"jge\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JEQ|BPF_K:\n\t\top = \"jeq\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JSET|BPF_K:\n\t\top = \"jset\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JGT|BPF_X:\n\t\top = \"jgt\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JGE|BPF_X:\n\t\top = \"jge\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JEQ|BPF_X:\n\t\top = \"jeq\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_JMP|BPF_JSET|BPF_X:\n\t\top = \"jset\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_ADD|BPF_X:\n\t\top = \"add\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_SUB|BPF_X:\n\t\top = \"sub\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_MUL|BPF_X:\n\t\top = \"mul\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_DIV|BPF_X:\n\t\top = \"div\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_MOD|BPF_X:\n\t\top = \"mod\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_AND|BPF_X:\n\t\top = \"and\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_OR|BPF_X:\n\t\top = \"or\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_XOR|BPF_X:\n\t\top = \"xor\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_LSH|BPF_X:\n\t\top = \"lsh\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_RSH|BPF_X:\n\t\top = \"rsh\";\n\t\toperand = \"x\";\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_ADD|BPF_K:\n\t\top = \"add\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#%d\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_SUB|BPF_K:\n\t\top = \"sub\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#%d\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_MUL|BPF_K:\n\t\top = \"mul\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#%d\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_DIV|BPF_K:\n\t\top = \"div\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#%d\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_MOD|BPF_K:\n\t\top = \"mod\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#%d\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_AND|BPF_K:\n\t\top = \"and\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_OR|BPF_K:\n\t\top = \"or\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_XOR|BPF_K:\n\t\top = \"xor\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#0x%x\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_LSH|BPF_K:\n\t\top = \"lsh\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#%d\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_RSH|BPF_K:\n\t\top = \"rsh\";\n\t\t(void)pcap_snprintf(operand_buf, sizeof operand_buf, \"#%d\", p->k);\n\t\toperand = operand_buf;\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_NEG:\n\t\top = \"neg\";\n\t\toperand = \"\";\n\t\tbreak;\n\n\tcase BPF_MISC|BPF_TAX:\n\t\top = \"tax\";\n\t\toperand = \"\";\n\t\tbreak;\n\n\tcase BPF_MISC|BPF_TXA:\n\t\top = \"txa\";\n\t\toperand = \"\";\n\t\tbreak;\n\t}\n\tif (BPF_CLASS(p->code) == BPF_JMP && BPF_OP(p->code) != BPF_JA) {\n\t\t(void)pcap_snprintf(image, sizeof image,\n\t\t\t      \"(%03d) %-8s %-16s jt %d\\tjf %d\",\n\t\t\t      n, op, operand, n + 1 + p->jt, n + 1 + p->jf);\n\t} else {\n\t\t(void)pcap_snprintf(image, sizeof image,\n\t\t\t      \"(%03d) %-8s %s\",\n\t\t\t      n, op, operand);\n\t}\n\treturn image;\n}",
          "fn_code_pos": [
            [
              36,
              0
            ],
            [
              331,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_image",
            "parameters": {
              "p": "struct bpf_insn",
              "n": "int"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "bpf_image(const struct bpf_insn *p, int n)",
          "fn_dec_pos": [
            [
              37,
              0
            ],
            [
              37,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_image",
            "parameters": {
              "p": "struct bpf_insn",
              "n": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct bpf_insn",
          {},
          "",
          [
            37,
            16
          ],
          [
            37,
            31
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <pcap-types.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-tc.c": {
      "fn_def_list": [
        {
          "fn_code": "HMODULE LoadLibrarySafe(LPCTSTR lpFileName)\n{\n  TCHAR path[MAX_PATH];\n  TCHAR fullFileName[MAX_PATH];\n  UINT res;\n  HMODULE hModule = NULL;\n  do\n  {\n\tres = GetSystemDirectory(path, MAX_PATH);\n\n\tif (res == 0)\n\t{\n\t\t//\n\t\t// some bad failure occurred;\n\t\t//\n\t\tbreak;\n\t}\n\n\tif (res > MAX_PATH)\n\t{\n\t\t//\n\t\t// the buffer was not big enough\n\t\t//\n\t\tSetLastError(ERROR_INSUFFICIENT_BUFFER);\n\t\tbreak;\n\t}\n\n\tif (res + 1 + _tcslen(lpFileName) + 1 < MAX_PATH)\n\t{\n\t\tmemcpy(fullFileName, path, res * sizeof(TCHAR));\n\t\tfullFileName[res] = _T('\\\\');\n\t\tmemcpy(&fullFileName[res + 1], lpFileName, (_tcslen(lpFileName) + 1) * sizeof(TCHAR));\n\n\t\thModule = LoadLibrary(fullFileName);\n\t}\n\telse\n\t{\n\t\tSetLastError(ERROR_INSUFFICIENT_BUFFER);\n\t}\n\n  }while(FALSE);\n\n  return hModule;\n}",
          "fn_code_pos": [
            [
              261,
              0
            ],
            [
              304,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LoadLibrarySafe",
            "parameters": {
              "lpFileName": "LPCTSTR"
            },
            "return_type": "HMODULE"
          }
        },
        {
          "fn_code": "TC_API_LOAD_STATUS LoadTcFunctions(void)\n{\n\tTC_API_LOAD_STATUS currentStatus;\n\n\tdo\n\t{\n\t\tcurrentStatus = InterlockedCompareExchange((LONG*)&g_TcFunctions.LoadStatus, TC_API_LOADING, TC_API_UNLOADED);\n\n\t\twhile(currentStatus == TC_API_LOADING)\n\t\t{\n\t\t\tcurrentStatus = InterlockedCompareExchange((LONG*)&g_TcFunctions.LoadStatus, TC_API_LOADING, TC_API_LOADING);\n\t\t\tSleep(10);\n\t\t}\n\n\t\t/*\n\t\t * at this point we are either in the LOADED state, unloaded state (i.e. we are the ones loading everything)\n\t\t * or in cannot load\n\t\t */\n\t\tif(currentStatus  == TC_API_LOADED)\n\t\t{\n\t\t\treturn TC_API_LOADED;\n\t\t}\n\n\t\tif (currentStatus == TC_API_CANNOT_LOAD)\n\t\t{\n\t\t\treturn TC_API_CANNOT_LOAD;\n\t\t}\n\n\t\tcurrentStatus = TC_API_CANNOT_LOAD;\n\n\t\tg_TcFunctions.hTcApiDllHandle = LoadLibrarySafe(\"TcApi.dll\");\n\t\tif (g_TcFunctions.hTcApiDllHandle == NULL)\tbreak;\n\n\t\tg_TcFunctions.QueryPortList\t\t\t\t\t= (TcFcnQueryPortList)\t\t\tGetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcQueryPortList\");\n\t\tg_TcFunctions.FreePortList\t\t\t\t\t= (TcFcnFreePortList)\t\t\tGetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcFreePortList\");\n\n\t\tg_TcFunctions.StatusGetString\t\t\t\t= (TcFcnStatusGetString)\t\tGetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcStatusGetString\");\n\n\t\tg_TcFunctions.PortGetName\t\t\t\t\t= (TcFcnPortGetName)\t\t\tGetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcPortGetName\");\n\t\tg_TcFunctions.PortGetDescription\t\t\t= (TcFcnPortGetDescription)\t\tGetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcPortGetDescription\");\n\n\t\tg_TcFunctions.InstanceOpenByName\t\t\t= (TcFcnInstanceOpenByName)\t\tGetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcInstanceOpenByName\");\n\t\tg_TcFunctions.InstanceClose\t\t\t\t\t= (TcFcnInstanceClose)\t\t\tGetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcInstanceClose\");\n\t\tg_TcFunctions.InstanceSetFeature\t\t\t= (TcFcnInstanceSetFeature)\t\tGetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcInstanceSetFeature\");\n\t\tg_TcFunctions.InstanceQueryFeature\t\t\t= (TcFcnInstanceQueryFeature)\tGetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcInstanceQueryFeature\");\n\t\tg_TcFunctions.InstanceReceivePackets\t\t= (TcFcnInstanceReceivePackets)\tGetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcInstanceReceivePackets\");\n\t\tg_TcFunctions.InstanceGetReceiveWaitHandle\t= (TcFcnInstanceGetReceiveWaitHandle)GetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcInstanceGetReceiveWaitHandle\");\n\t\tg_TcFunctions.InstanceTransmitPackets\t\t= (TcFcnInstanceTransmitPackets)GetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcInstanceTransmitPackets\");\n\t\tg_TcFunctions.InstanceQueryStatistics\t\t= (TcFcnInstanceQueryStatistics)GetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcInstanceQueryStatistics\");\n\n\t\tg_TcFunctions.PacketsBufferCreate\t\t\t= (TcFcnPacketsBufferCreate)\tGetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcPacketsBufferCreate\");\n\t\tg_TcFunctions.PacketsBufferDestroy\t\t\t= (TcFcnPacketsBufferDestroy)\tGetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcPacketsBufferDestroy\");\n\t\tg_TcFunctions.PacketsBufferQueryNextPacket\t= (TcFcnPacketsBufferQueryNextPacket)GetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcPacketsBufferQueryNextPacket\");\n\t\tg_TcFunctions.PacketsBufferCommitNextPacket\t= (TcFcnPacketsBufferCommitNextPacket)GetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcPacketsBufferCommitNextPacket\");\n\n\t\tg_TcFunctions.StatisticsDestroy\t\t\t\t= (TcFcnStatisticsDestroy)\t\tGetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcStatisticsDestroy\");\n\t\tg_TcFunctions.StatisticsUpdate\t\t\t\t= (TcFcnStatisticsUpdate)\t\tGetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcStatisticsUpdate\");\n\t\tg_TcFunctions.StatisticsQueryValue\t\t\t= (TcFcnStatisticsQueryValue)\tGetProcAddress(g_TcFunctions.hTcApiDllHandle, \"TcStatisticsQueryValue\");\n\n\t\tif (   g_TcFunctions.QueryPortList == NULL\n\t\t\t|| g_TcFunctions.FreePortList == NULL\n\t\t\t|| g_TcFunctions.StatusGetString == NULL\n\t\t\t|| g_TcFunctions.PortGetName == NULL\n\t\t\t|| g_TcFunctions.PortGetDescription == NULL\n\t\t\t|| g_TcFunctions.InstanceOpenByName == NULL\n\t\t\t|| g_TcFunctions.InstanceClose == NULL\n\t\t\t|| g_TcFunctions.InstanceSetFeature\t == NULL\n\t\t\t|| g_TcFunctions.InstanceQueryFeature == NULL\n\t\t\t|| g_TcFunctions.InstanceReceivePackets == NULL\n\t\t\t|| g_TcFunctions.InstanceGetReceiveWaitHandle == NULL\n\t\t\t|| g_TcFunctions.InstanceTransmitPackets == NULL\n\t\t\t|| g_TcFunctions.InstanceQueryStatistics == NULL\n\t\t\t|| g_TcFunctions.PacketsBufferCreate == NULL\n\t\t\t|| g_TcFunctions.PacketsBufferDestroy == NULL\n\t\t\t|| g_TcFunctions.PacketsBufferQueryNextPacket == NULL\n\t\t\t|| g_TcFunctions.PacketsBufferCommitNextPacket == NULL\n\t\t\t|| g_TcFunctions.StatisticsDestroy == NULL\n\t\t\t|| g_TcFunctions.StatisticsUpdate == NULL\n\t\t\t|| g_TcFunctions.StatisticsQueryValue == NULL\n\t\t)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * everything got loaded, yay!!\n\t\t */\n\t\tcurrentStatus = TC_API_LOADED;\n\t}while(FALSE);\n\n\tif (currentStatus != TC_API_LOADED)\n\t{\n\t\tif (g_TcFunctions.hTcApiDllHandle != NULL)\n\t\t{\n\t\t\tFreeLibrary(g_TcFunctions.hTcApiDllHandle);\n\t\t\tg_TcFunctions.hTcApiDllHandle = NULL;\n\t\t}\n\t}\n\n\tInterlockedExchange((LONG*)&g_TcFunctions.LoadStatus, currentStatus);\n\n\treturn currentStatus;\n}",
          "fn_code_pos": [
            [
              312,
              0
            ],
            [
              414,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LoadTcFunctions",
            "parameters": {},
            "return_type": "TC_API_LOAD_STATUS"
          }
        },
        {
          "fn_code": "TC_API_LOAD_STATUS LoadTcFunctions(void)\n{\n\treturn TC_API_LOADED;\n}",
          "fn_code_pos": [
            [
              417,
              0
            ],
            [
              420,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LoadTcFunctions",
            "parameters": {},
            "return_type": "TC_API_LOAD_STATUS"
          }
        },
        {
          "fn_code": "int\nTcFindAllDevs(pcap_if_list_t *devlist, char *errbuf)\n{\n\tTC_API_LOAD_STATUS loadStatus;\n\tULONG numPorts;\n\tPTC_PORT pPorts = NULL;\n\tTC_STATUS status;\n\tint result = 0;\n\tpcap_if_t *dev;\n\tULONG i;\n\n\tdo\n\t{\n\t\tloadStatus = LoadTcFunctions();\n\n\t\tif (loadStatus != TC_API_LOADED)\n\t\t{\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * enumerate the ports, and add them to the list\n\t\t */\n\t\tstatus = g_TcFunctions.QueryPortList(&pPorts, &numPorts);\n\n\t\tif (status != TC_SUCCESS)\n\t\t{\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < numPorts; i++)\n\t\t{\n\t\t\t/*\n\t\t\t * transform the port into an entry in the list\n\t\t\t */\n\t\t\tdev = TcCreatePcapIfFromPort(pPorts[i]);\n\n\t\t\tif (dev != NULL)\n\t\t\t\tadd_dev(devlist, dev->name, dev->flags, dev->description, errbuf);\n\t\t}\n\n\t\tif (numPorts > 0)\n\t\t{\n\t\t\t/*\n\t\t\t * ignore the result here\n\t\t\t */\n\t\t\tstatus = g_TcFunctions.FreePortList(pPorts);\n\t\t}\n\n\t}while(FALSE);\n\n\treturn result;\n}",
          "fn_code_pos": [
            [
              433,
              0
            ],
            [
              487,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcFindAllDevs",
            "parameters": {
              "devlist": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static pcap_if_t* TcCreatePcapIfFromPort(TC_PORT port)\n{\n\tCHAR *name;\n\tCHAR *description;\n\tpcap_if_t *newIf = NULL;\n\n\tnewIf = (pcap_if_t*)malloc(sizeof(*newIf));\n\tif (newIf == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\n\tmemset(newIf, 0, sizeof(*newIf));\n\n\tname = g_TcFunctions.PortGetName(port);\n\tdescription = g_TcFunctions.PortGetDescription(port);\n\n\tnewIf->name = (char*)malloc(strlen(name) + 1);\n\tif (newIf->name == NULL)\n\t{\n\t\tfree(newIf);\n\t\treturn NULL;\n\t}\n\n\tnewIf->description = (char*)malloc(strlen(description) + 1);\n\tif (newIf->description == NULL)\n\t{\n\t\tfree(newIf->name);\n\t\tfree(newIf);\n\t\treturn NULL;\n\t}\n\n\tstrcpy(newIf->name, name);\n\tstrcpy(newIf->description, description);\n\n\tnewIf->addresses = NULL;\n\tnewIf->next = NULL;\n\tnewIf->flags = 0;\n\n\treturn newIf;\n\n}",
          "fn_code_pos": [
            [
              489,
              0
            ],
            [
              530,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcCreatePcapIfFromPort",
            "parameters": {
              "port": "TC_PORT"
            },
            "return_type": "pcap_if_t"
          }
        },
        {
          "fn_code": "static int\nTcActivate(pcap_t *p)\n{\n\tstruct pcap_tc *pt = p->priv;\n\tTC_STATUS status;\n\tULONG timeout;\n\tPPPI_HEADER pPpiHeader;\n\n\tif (p->opt.rfmon)\n\t{\n\t\t/*\n\t\t * No monitor mode on Tc cards; they're Ethernet\n\t\t * capture adapters.\n\t\t */\n\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t}\n\n\tpt->PpiPacket = malloc(sizeof(PPI_HEADER) + MAX_TC_PACKET_SIZE);\n\n\tif (pt->PpiPacket == NULL)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"Error allocating memory\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n\t/*\n\t * Initialize the PPI fixed fields\n\t */\n\tpPpiHeader = (PPPI_HEADER)pt->PpiPacket;\n\tpPpiHeader->PacketHeader.PphDlt = DLT_EN10MB;\n\tpPpiHeader->PacketHeader.PphLength = sizeof(PPI_HEADER);\n\tpPpiHeader->PacketHeader.PphFlags = 0;\n\tpPpiHeader->PacketHeader.PphVersion = 0;\n\n\tpPpiHeader->AggregationFieldHeader.PfhLength = sizeof(PPI_FIELD_AGGREGATION_EXTENSION);\n\tpPpiHeader->AggregationFieldHeader.PfhType = PPI_FIELD_TYPE_AGGREGATION_EXTENSION;\n\n\tpPpiHeader->Dot3FieldHeader.PfhLength = sizeof(PPI_FIELD_802_3_EXTENSION);\n\tpPpiHeader->Dot3FieldHeader.PfhType = PPI_FIELD_TYPE_802_3_EXTENSION;\n\n\tstatus = g_TcFunctions.InstanceOpenByName(p->opt.device, &pt->TcInstance);\n\n\tif (status != TC_SUCCESS)\n\t{\n\t\t/* Adapter detected but we are not able to open it. Return failure. */\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"Error opening TurboCap adapter: %s\", g_TcFunctions.StatusGetString(status));\n\t\treturn PCAP_ERROR;\n\t}\n\n\tp->linktype = DLT_EN10MB;\n\tp->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);\n\t/*\n\t * If that fails, just leave the list empty.\n\t */\n\tif (p->dlt_list != NULL) {\n\t\tp->dlt_list[0] = DLT_EN10MB;\n\t\tp->dlt_list[1] = DLT_PPI;\n\t\tp->dlt_count = 2;\n\t}\n\n\t/*\n\t * ignore promiscuous mode\n\t * p->opt.promisc\n\t */\n\n\n\t/*\n\t * ignore all the buffer sizes\n\t */\n\n\t/*\n\t * enable reception\n\t */\n\tstatus = g_TcFunctions.InstanceSetFeature(pt->TcInstance, TC_INST_FT_RX_STATUS, 1);\n\n\tif (status != TC_SUCCESS)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\"Error enabling reception on a TurboCap instance: %s\", g_TcFunctions.StatusGetString(status));\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * enable transmission\n\t */\n\tstatus = g_TcFunctions.InstanceSetFeature(pt->TcInstance, TC_INST_FT_TX_STATUS, 1);\n\t/*\n\t * Ignore the error here.\n\t */\n\n\tp->inject_op = TcInject;\n\t/*\n\t * if the timeout is -1, it means immediate return, no timeout\n\t * if the timeout is 0, it means INFINITE\n\t */\n\n\tif (p->opt.timeout == 0)\n\t{\n\t\ttimeout = 0xFFFFFFFF;\n\t}\n\telse\n\tif (p->opt.timeout < 0)\n\t{\n\t\t/*\n\t\t *  we insert a minimal timeout here\n\t\t */\n\t\ttimeout = 10;\n\t}\n\telse\n\t{\n\t\ttimeout = p->opt.timeout;\n\t}\n\n\tstatus = g_TcFunctions.InstanceSetFeature(pt->TcInstance, TC_INST_FT_READ_TIMEOUT, timeout);\n\n\tif (status != TC_SUCCESS)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\"Error setting the read timeout a TurboCap instance: %s\", g_TcFunctions.StatusGetString(status));\n\t\tgoto bad;\n\t}\n\n\tp->read_op = TcRead;\n\tp->setfilter_op = install_bpf_program;\n\tp->setdirection_op = NULL;\t/* Not implemented. */\n\tp->set_datalink_op = TcSetDatalink;\n\tp->getnonblock_op = TcGetNonBlock;\n\tp->setnonblock_op = TcSetNonBlock;\n\tp->stats_op = TcStats;\n#ifdef _WIN32\n\tp->stats_ex_op = TcStatsEx;\n\tp->setbuff_op = TcSetBuff;\n\tp->setmode_op = TcSetMode;\n\tp->setmintocopy_op = TcSetMinToCopy;\n\tp->getevent_op = TcGetReceiveWaitHandle;\n\tp->oid_get_request_op = TcOidGetRequest;\n\tp->oid_set_request_op = TcOidSetRequest;\n\tp->sendqueue_transmit_op = TcSendqueueTransmit;\n\tp->setuserbuffer_op = TcSetUserBuffer;\n\tp->live_dump_op = TcLiveDump;\n\tp->live_dump_ended_op = TcLiveDumpEnded;\n\tp->get_airpcap_handle_op = TcGetAirPcapHandle;\n#else\n\tp->selectable_fd = -1;\n#endif\n\n\tp->cleanup_op = TcCleanup;\n\n\treturn 0;\nbad:\n\tTcCleanup(p);\n\treturn PCAP_ERROR;\n}",
          "fn_code_pos": [
            [
              532,
              0
            ],
            [
              693,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcActivate",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\nTcCreate(const char *device, char *ebuf, int *is_ours)\n{\n\tULONG numPorts;\n\tPTC_PORT pPorts = NULL;\n\tTC_STATUS status;\n\tint is_tc;\n\tULONG i;\n\tpcap_t *p;\n\n\tif (LoadTcFunctions() != TC_API_LOADED)\n\t{\n\t\t/*\n\t\t * XXX - report this as an error rather than as\n\t\t * \"not a TurboCap device\"?\n\t\t */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * enumerate the ports, and add them to the list\n\t */\n\tstatus = g_TcFunctions.QueryPortList(&pPorts, &numPorts);\n\n\tif (status != TC_SUCCESS)\n\t{\n\t\t/*\n\t\t * XXX - report this as an error rather than as\n\t\t * \"not a TurboCap device\"?\n\t\t */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\tis_tc = FALSE;\n\tfor (i = 0; i < numPorts; i++)\n\t{\n\t\tif (strcmp(g_TcFunctions.PortGetName(pPorts[i]), device) == 0)\n\t\t{\n\t\t\tis_tc = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (numPorts > 0)\n\t{\n\t\t/*\n\t\t * ignore the result here\n\t\t */\n\t\t(void)g_TcFunctions.FreePortList(pPorts);\n\t}\n\n\tif (!is_tc)\n\t{\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\t/* OK, it's probably ours. */\n\t*is_ours = 1;\n\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_tc));\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tp->activate_op = TcActivate;\n\t/*\n\t * Set these up front, so that, even if our client tries\n\t * to set non-blocking mode before we're activated, or\n\t * query the state of non-blocking mode, they get an error,\n\t * rather than having the non-blocking mode option set\n\t * for use later.\n\t */\n\tp->getnonblock_op = TcGetNonBlock;\n\tp->setnonblock_op = TcSetNonBlock;\n\treturn p;\n}",
          "fn_code_pos": [
            [
              695,
              0
            ],
            [
              772,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcCreate",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static int TcSetDatalink(pcap_t *p, int dlt)\n{\n\t/*\n\t * We don't have to do any work here; pcap_set_datalink() checks\n\t * whether the value is in the list of DLT_ values we\n\t * supplied, so we don't have to, and, if it is valid, sets\n\t * p->linktype to the new value; we don't have to do anything\n\t * in hardware, we just use what's in p->linktype.\n\t *\n\t * We do have to have a routine, however, so that pcap_set_datalink()\n\t * doesn't think we don't support setting the link-layer header\n\t * type at all.\n\t */\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              774,
              0
            ],
            [
              788,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcSetDatalink",
            "parameters": {
              "p": "pcap_t",
              "dlt": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int TcGetNonBlock(pcap_t *p)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Non-blocking mode isn't supported for TurboCap ports\");\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              790,
              0
            ],
            [
              795,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcGetNonBlock",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int TcSetNonBlock(pcap_t *p, int nonblock)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Non-blocking mode isn't supported for TurboCap ports\");\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              797,
              0
            ],
            [
              802,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcSetNonBlock",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void TcCleanup(pcap_t *p)\n{\n\tstruct pcap_tc *pt = p->priv;\n\n\tif (pt->TcPacketsBuffer != NULL)\n\t{\n\t\tg_TcFunctions.PacketsBufferDestroy(pt->TcPacketsBuffer);\n\t\tpt->TcPacketsBuffer = NULL;\n\t}\n\tif (pt->TcInstance != NULL)\n\t{\n\t\t/*\n\t\t * here we do not check for the error values\n\t\t */\n\t\tg_TcFunctions.InstanceClose(pt->TcInstance);\n\t\tpt->TcInstance = NULL;\n\t}\n\n\tif (pt->PpiPacket != NULL)\n\t{\n\t\tfree(pt->PpiPacket);\n\t\tpt->PpiPacket = NULL;\n\t}\n\n\tpcap_cleanup_live_common(p);\n}",
          "fn_code_pos": [
            [
              804,
              0
            ],
            [
              829,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcCleanup",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int TcInject(pcap_t *p, const void *buf, int size)\n{\n\tstruct pcap_tc *pt = p->priv;\n\tTC_STATUS status;\n\tTC_PACKETS_BUFFER buffer;\n\tTC_PACKET_HEADER header;\n\n\tif (size >= 0xFFFF)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"send error: the TurboCap API does not support packets larger than 64k\");\n\t\treturn -1;\n\t}\n\n\tstatus = g_TcFunctions.PacketsBufferCreate(sizeof(TC_PACKET_HEADER) + TC_ALIGN_USHORT_TO_64BIT((USHORT)size), &buffer);\n\n\tif (status != TC_SUCCESS)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"send error: TcPacketsBufferCreate failure: %s (%08x)\", g_TcFunctions.StatusGetString(status), status);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * we assume that the packet is without the checksum, as common with WinPcap\n\t */\n\tmemset(&header, 0, sizeof(header));\n\n\theader.Length = (USHORT)size;\n\theader.CapturedLength = header.Length;\n\n\tstatus = g_TcFunctions.PacketsBufferCommitNextPacket(buffer, &header, (PVOID)buf);\n\n\tif (status == TC_SUCCESS)\n\t{\n\t\tstatus = g_TcFunctions.InstanceTransmitPackets(pt->TcInstance, buffer);\n\n\t\tif (status != TC_SUCCESS)\n\t\t{\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"send error: TcInstanceTransmitPackets failure: %s (%08x)\", g_TcFunctions.StatusGetString(status), status);\n\t\t}\n\t}\n\telse\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"send error: TcPacketsBufferCommitNextPacket failure: %s (%08x)\", g_TcFunctions.StatusGetString(status), status);\n\t}\n\n\tg_TcFunctions.PacketsBufferDestroy(buffer);\n\n\tif (status != TC_SUCCESS)\n\t{\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n}",
          "fn_code_pos": [
            [
              832,
              0
            ],
            [
              887,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcInject",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int TcRead(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_tc *pt = p->priv;\n\tTC_STATUS status;\n\tint n = 0;\n\n\t/*\n\t * Has \"pcap_breakloop()\" been called?\n\t */\n\tif (p->break_loop)\n\t{\n\t\t/*\n\t\t * Yes - clear the flag that indicates that it\n\t\t * has, and return -2 to indicate that we were\n\t\t * told to break out of the loop.\n\t\t */\n\t\tp->break_loop = 0;\n\t\treturn -2;\n\t}\n\n\tif (pt->TcPacketsBuffer == NULL)\n\t{\n\t\tstatus = g_TcFunctions.InstanceReceivePackets(pt->TcInstance, &pt->TcPacketsBuffer);\n\t\tif (status != TC_SUCCESS)\n\t\t{\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"read error, TcInstanceReceivePackets failure: %s (%08x)\", g_TcFunctions.StatusGetString(status), status);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\twhile (TRUE)\n\t{\n\t\tstruct pcap_pkthdr hdr;\n\t\tTC_PACKET_HEADER tcHeader;\n\t\tPVOID data;\n\t\tULONG filterResult;\n\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t * If so, return immediately - if we haven't read any\n\t\t * packets, clear the flag and return -2 to indicate\n\t\t * that we were told to break out of the loop, otherwise\n\t\t * leave the flag set, so that the *next* call will break\n\t\t * out of the loop without having read any packets, and\n\t\t * return the number of packets we've processed so far.\n\t\t */\n\t\tif (p->break_loop)\n\t\t{\n\t\t\tif (n == 0)\n\t\t\t{\n\t\t\t\tp->break_loop = 0;\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\tif (pt->TcPacketsBuffer == NULL)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = g_TcFunctions.PacketsBufferQueryNextPacket(pt->TcPacketsBuffer, &tcHeader, &data);\n\n\t\tif (status == TC_ERROR_END_OF_BUFFER)\n\t\t{\n\t\t\tg_TcFunctions.PacketsBufferDestroy(pt->TcPacketsBuffer);\n\t\t\tpt->TcPacketsBuffer = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (status != TC_SUCCESS)\n\t\t{\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"read error, TcPacketsBufferQueryNextPacket failure: %s (%08x)\", g_TcFunctions.StatusGetString(status), status);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* No underlaying filtering system. We need to filter on our own */\n\t\tif (p->fcode.bf_insns)\n\t\t{\n\t\t\tfilterResult = pcap_filter(p->fcode.bf_insns, data, tcHeader.Length, tcHeader.CapturedLength);\n\n\t\t\tif (filterResult == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (filterResult > tcHeader.CapturedLength)\n\t\t\t{\n\t\t\t\tfilterResult = tcHeader.CapturedLength;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfilterResult = tcHeader.CapturedLength;\n\t\t}\n\n\t\tpt->TcAcceptedCount ++;\n\n\t\thdr.ts.tv_sec = (bpf_u_int32)(tcHeader.Timestamp / (ULONGLONG)(1000  * 1000 * 1000));\n\t\thdr.ts.tv_usec = (bpf_u_int32)((tcHeader.Timestamp % (ULONGLONG)(1000  * 1000 * 1000)) / 1000);\n\n\t\tif (p->linktype == DLT_EN10MB)\n\t\t{\n\t\t\thdr.caplen = filterResult;\n\t\t\thdr.len = tcHeader.Length;\n\t\t\t(*callback)(user, &hdr, data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPPPI_HEADER pPpiHeader = (PPPI_HEADER)pt->PpiPacket;\n\t\t\tPVOID data2 = pPpiHeader + 1;\n\n\t\t\tpPpiHeader->AggregationField.InterfaceId = TC_PH_FLAGS_RX_PORT_ID(tcHeader.Flags);\n\t\t\tpPpiHeader->Dot3Field.Errors = tcHeader.Errors;\n\t\t\tif (tcHeader.Flags & TC_PH_FLAGS_CHECKSUM)\n\t\t\t{\n\t\t\t\tpPpiHeader->Dot3Field.Flags = PPI_FLD_802_3_EXT_FLAG_FCS_PRESENT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpPpiHeader->Dot3Field.Flags = 0;\n\t\t\t}\n\n\t\t\tif (filterResult <= MAX_TC_PACKET_SIZE)\n\t\t\t{\n\t\t\t\tmemcpy(data2, data, filterResult);\n\t\t\t\thdr.caplen = sizeof(PPI_HEADER) + filterResult;\n\t\t\t\thdr.len = sizeof(PPI_HEADER) + tcHeader.Length;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(data2, data, MAX_TC_PACKET_SIZE);\n\t\t\t\thdr.caplen = sizeof(PPI_HEADER) + MAX_TC_PACKET_SIZE;\n\t\t\t\thdr.len = sizeof(PPI_HEADER) + tcHeader.Length;\n\t\t\t}\n\n\t\t\t(*callback)(user, &hdr, pt->PpiPacket);\n\n\t\t}\n\n\t\tif (++n >= cnt && cnt > 0)\n\t\t{\n\t\t\treturn n;\n\t\t}\n\t}\n\n\treturn n;\n}",
          "fn_code_pos": [
            [
              889,
              0
            ],
            [
              1039,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcRead",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTcStats(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct pcap_tc *pt = p->priv;\n\tTC_STATISTICS statistics;\n\tTC_STATUS status;\n\tULONGLONG counter;\n\tstruct pcap_stat s;\n\n\tstatus = g_TcFunctions.InstanceQueryStatistics(pt->TcInstance, &statistics);\n\n\tif (status != TC_SUCCESS)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"TurboCap error in TcInstanceQueryStatistics: %s (%08x)\", g_TcFunctions.StatusGetString(status), status);\n\t\treturn -1;\n\t}\n\n\tmemset(&s, 0, sizeof(s));\n\n\tstatus = g_TcFunctions.StatisticsQueryValue(statistics, TC_COUNTER_INSTANCE_TOTAL_RX_PACKETS, &counter);\n\tif (status != TC_SUCCESS)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"TurboCap error in TcStatisticsQueryValue: %s (%08x)\", g_TcFunctions.StatusGetString(status), status);\n\t\treturn -1;\n\t}\n\tif (counter <= (ULONGLONG)0xFFFFFFFF)\n\t{\n\t\ts.ps_recv = (ULONG)counter;\n\t}\n\telse\n\t{\n\t\ts.ps_recv = 0xFFFFFFFF;\n\t}\n\n\tstatus = g_TcFunctions.StatisticsQueryValue(statistics, TC_COUNTER_INSTANCE_RX_DROPPED_PACKETS, &counter);\n\tif (status != TC_SUCCESS)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"TurboCap error in TcStatisticsQueryValue: %s (%08x)\", g_TcFunctions.StatusGetString(status), status);\n\t\treturn -1;\n\t}\n\tif (counter <= (ULONGLONG)0xFFFFFFFF)\n\t{\n\t\ts.ps_ifdrop = (ULONG)counter;\n\t\ts.ps_drop = (ULONG)counter;\n\t}\n\telse\n\t{\n\t\ts.ps_ifdrop = 0xFFFFFFFF;\n\t\ts.ps_drop = 0xFFFFFFFF;\n\t}\n\n#if defined(_WIN32) && defined(ENABLE_REMOTE)\n\ts.ps_capt = pt->TcAcceptedCount;\n#endif\n\t*ps = s;\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1041,
              0
            ],
            [
              1098,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcStats",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static struct pcap_stat *\nTcStatsEx(pcap_t *p, int *pcap_stat_size)\n{\n\tstruct pcap_tc *pt = p->priv;\n\tTC_STATISTICS statistics;\n\tTC_STATUS status;\n\tULONGLONG counter;\n\n\t*pcap_stat_size = sizeof (p->stat);\n\n\tstatus = g_TcFunctions.InstanceQueryStatistics(pt->TcInstance, &statistics);\n\n\tif (status != TC_SUCCESS)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"TurboCap error in TcInstanceQueryStatistics: %s (%08x)\", g_TcFunctions.StatusGetString(status), status);\n\t\treturn NULL;\n\t}\n\n\tmemset(&p->stat, 0, sizeof(p->stat));\n\n\tstatus = g_TcFunctions.StatisticsQueryValue(statistics, TC_COUNTER_INSTANCE_TOTAL_RX_PACKETS, &counter);\n\tif (status != TC_SUCCESS)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"TurboCap error in TcStatisticsQueryValue: %s (%08x)\", g_TcFunctions.StatusGetString(status), status);\n\t\treturn NULL;\n\t}\n\tif (counter <= (ULONGLONG)0xFFFFFFFF)\n\t{\n\t\tp->stat.ps_recv = (ULONG)counter;\n\t}\n\telse\n\t{\n\t\tp->stat.ps_recv = 0xFFFFFFFF;\n\t}\n\n\tstatus = g_TcFunctions.StatisticsQueryValue(statistics, TC_COUNTER_INSTANCE_RX_DROPPED_PACKETS, &counter);\n\tif (status != TC_SUCCESS)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"TurboCap error in TcStatisticsQueryValue: %s (%08x)\", g_TcFunctions.StatusGetString(status), status);\n\t\treturn NULL;\n\t}\n\tif (counter <= (ULONGLONG)0xFFFFFFFF)\n\t{\n\t\tp->stat.ps_ifdrop = (ULONG)counter;\n\t\tp->stat.ps_drop = (ULONG)counter;\n\t}\n\telse\n\t{\n\t\tp->stat.ps_ifdrop = 0xFFFFFFFF;\n\t\tp->stat.ps_drop = 0xFFFFFFFF;\n\t}\n\n#if defined(_WIN32) && defined(ENABLE_REMOTE)\n\tp->stat.ps_capt = pt->TcAcceptedCount;\n#endif\n\n\treturn &p->stat;\n}",
          "fn_code_pos": [
            [
              1102,
              0
            ],
            [
              1159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcStatsEx",
            "parameters": {
              "p": "pcap_t",
              "pcap_stat_size": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static int\nTcSetBuff(pcap_t *p, int dim)\n{\n\t/*\n\t * XXX turbocap has an internal way of managing buffers.\n\t * And at the moment it's not configurable, so we just\n\t * silently ignore the request to set the buffer.\n\t */\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1162,
              0
            ],
            [
              1171,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcSetBuff",
            "parameters": {
              "p": "pcap_t",
              "dim": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTcSetMode(pcap_t *p, int mode)\n{\n\tif (mode != MODE_CAPT)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"Mode %u not supported by TurboCap devices. TurboCap only supports capture.\", mode);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1173,
              0
            ],
            [
              1183,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcSetMode",
            "parameters": {
              "p": "pcap_t",
              "mode": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTcSetMinToCopy(pcap_t *p, int size)\n{\n\tstruct pcap_tc *pt = p->priv;\n\tTC_STATUS status;\n\n\tif (size < 0)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"Mintocopy cannot be less than 0.\");\n\t\treturn -1;\n\t}\n\n\tstatus = g_TcFunctions.InstanceSetFeature(pt->TcInstance, TC_INST_FT_MINTOCOPY, (ULONG)size);\n\n\tif (status != TC_SUCCESS)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"TurboCap error setting the mintocopy: %s (%08x)\", g_TcFunctions.StatusGetString(status), status);\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1185,
              0
            ],
            [
              1205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcSetMinToCopy",
            "parameters": {
              "p": "pcap_t",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static HANDLE\nTcGetReceiveWaitHandle(pcap_t *p)\n{\n\tstruct pcap_tc *pt = p->priv;\n\n\treturn g_TcFunctions.InstanceGetReceiveWaitHandle(pt->TcInstance);\n}",
          "fn_code_pos": [
            [
              1207,
              0
            ],
            [
              1213,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcGetReceiveWaitHandle",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "HANDLE"
          }
        },
        {
          "fn_code": "static int\nTcOidGetRequest(pcap_t *p, bpf_u_int32 oid _U_, void *data _U_, size_t *lenp _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"An OID get request cannot be performed on a TurboCap device\");\n\treturn PCAP_ERROR;\n}",
          "fn_code_pos": [
            [
              1215,
              0
            ],
            [
              1221,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcOidGetRequest",
            "parameters": {
              "p": "pcap_t",
              "oid": "bpf_u_int32",
              "data": "void",
              "lenp": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTcOidSetRequest(pcap_t *p, bpf_u_int32 oid _U_, const void *data _U_,\n    size_t *lenp _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"An OID set request cannot be performed on a TurboCap device\");\n\treturn PCAP_ERROR;\n}",
          "fn_code_pos": [
            [
              1223,
              0
            ],
            [
              1230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcOidSetRequest",
            "parameters": {
              "p": "pcap_t",
              "oid": "bpf_u_int32",
              "data": "void",
              "lenp": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static u_int\nTcSendqueueTransmit(pcap_t *p, pcap_send_queue *queue _U_, int sync _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Packets cannot be bulk transmitted on a TurboCap device\");\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1232,
              0
            ],
            [
              1238,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcSendqueueTransmit",
            "parameters": {
              "p": "pcap_t",
              "queue": "pcap_send_queue",
              "sync": "int"
            },
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "static int\nTcSetUserBuffer(pcap_t *p, int size _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The user buffer cannot be set on a TurboCap device\");\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              1240,
              0
            ],
            [
              1246,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcSetUserBuffer",
            "parameters": {
              "p": "pcap_t",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTcLiveDump(pcap_t *p, char *filename _U_, int maxsize _U_, int maxpacks _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Live packet dumping cannot be performed on a TurboCap device\");\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              1248,
              0
            ],
            [
              1254,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcLiveDump",
            "parameters": {
              "p": "pcap_t",
              "filename": "char",
              "maxsize": "int",
              "maxpacks": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTcLiveDumpEnded(pcap_t *p, int sync _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Live packet dumping cannot be performed on a TurboCap device\");\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              1256,
              0
            ],
            [
              1262,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcLiveDumpEnded",
            "parameters": {
              "p": "pcap_t",
              "sync": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(TC_CALLCONV *TcFcnQueryPortList)\t\t\t(PTC_PORT *ppPorts, PULONG pLength)",
          "fn_dec_pos": [
            [
              49,
              18
            ],
            [
              49,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "ppPorts": "PTC_PORT",
              "pLength": "PULONG"
            },
            "return_type": "TC_STATUS"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnFreePortList)\t\t\t(TC_PORT *pPorts)",
          "fn_dec_pos": [
            [
              50,
              18
            ],
            [
              50,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "pPorts": "TC_PORT"
            },
            "return_type": "TC_STATUS"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnStatusGetString)\t\t\t(TC_STATUS status)",
          "fn_dec_pos": [
            [
              52,
              15
            ],
            [
              52,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "status": "TC_STATUS"
            },
            "return_type": "PCHAR"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnPortGetName)\t\t\t\t(TC_PORT port)",
          "fn_dec_pos": [
            [
              54,
              15
            ],
            [
              54,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "port": "TC_PORT"
            },
            "return_type": "PCHAR"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnPortGetDescription)\t\t(TC_PORT port)",
          "fn_dec_pos": [
            [
              55,
              15
            ],
            [
              55,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "port": "TC_PORT"
            },
            "return_type": "PCHAR"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnInstanceOpenByName)\t\t(PCHAR name, PTC_INSTANCE pInstance)",
          "fn_dec_pos": [
            [
              57,
              18
            ],
            [
              57,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "name": "PCHAR",
              "pInstance": "PTC_INSTANCE"
            },
            "return_type": "TC_STATUS"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnInstanceClose)\t\t\t(TC_INSTANCE instance)",
          "fn_dec_pos": [
            [
              58,
              18
            ],
            [
              58,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "instance": "TC_INSTANCE"
            },
            "return_type": "TC_STATUS"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnInstanceSetFeature)\t\t(TC_INSTANCE instance, ULONG feature, ULONG value)",
          "fn_dec_pos": [
            [
              59,
              18
            ],
            [
              59,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "instance": "TC_INSTANCE",
              "feature": "ULONG",
              "value": "ULONG"
            },
            "return_type": "TC_STATUS"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnInstanceQueryFeature)\t(TC_INSTANCE instance, ULONG feature, PULONG pValue)",
          "fn_dec_pos": [
            [
              60,
              18
            ],
            [
              60,
              111
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "instance": "TC_INSTANCE",
              "feature": "ULONG",
              "pValue": "PULONG"
            },
            "return_type": "TC_STATUS"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnInstanceReceivePackets)\t(TC_INSTANCE instance, PTC_PACKETS_BUFFER pBuffer)",
          "fn_dec_pos": [
            [
              61,
              18
            ],
            [
              61,
              111
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "instance": "TC_INSTANCE",
              "pBuffer": "PTC_PACKETS_BUFFER"
            },
            "return_type": "TC_STATUS"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnInstanceGetReceiveWaitHandle) (TC_INSTANCE instance)",
          "fn_dec_pos": [
            [
              62,
              16
            ],
            [
              62,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "instance": "TC_INSTANCE"
            },
            "return_type": "HANDLE"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnInstanceTransmitPackets)\t(TC_INSTANCE instance, TC_PACKETS_BUFFER pBuffer)",
          "fn_dec_pos": [
            [
              63,
              18
            ],
            [
              63,
              111
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "instance": "TC_INSTANCE",
              "pBuffer": "TC_PACKETS_BUFFER"
            },
            "return_type": "TC_STATUS"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnInstanceQueryStatistics)\t(TC_INSTANCE instance, PTC_STATISTICS pStatistics)",
          "fn_dec_pos": [
            [
              64,
              18
            ],
            [
              64,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "instance": "TC_INSTANCE",
              "pStatistics": "PTC_STATISTICS"
            },
            "return_type": "TC_STATUS"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnPacketsBufferCreate)\t\t(ULONG size, PTC_PACKETS_BUFFER pBuffer)",
          "fn_dec_pos": [
            [
              66,
              18
            ],
            [
              66,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "size": "ULONG",
              "pBuffer": "PTC_PACKETS_BUFFER"
            },
            "return_type": "TC_STATUS"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnPacketsBufferDestroy)\t(TC_PACKETS_BUFFER buffer)",
          "fn_dec_pos": [
            [
              67,
              14
            ],
            [
              67,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "buffer": "TC_PACKETS_BUFFER"
            },
            "return_type": "VOID"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnPacketsBufferQueryNextPacket)(TC_PACKETS_BUFFER buffer, PTC_PACKET_HEADER pHeader, PVOID *ppData)",
          "fn_dec_pos": [
            [
              68,
              18
            ],
            [
              68,
              134
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "buffer": "TC_PACKETS_BUFFER",
              "pHeader": "PTC_PACKET_HEADER",
              "ppData": "PVOID"
            },
            "return_type": "TC_STATUS"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnPacketsBufferCommitNextPacket)(TC_PACKETS_BUFFER buffer, PTC_PACKET_HEADER pHeader, PVOID pData)",
          "fn_dec_pos": [
            [
              69,
              18
            ],
            [
              69,
              133
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "buffer": "TC_PACKETS_BUFFER",
              "pHeader": "PTC_PACKET_HEADER",
              "pData": "PVOID"
            },
            "return_type": "TC_STATUS"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnStatisticsDestroy)\t\t(TC_STATISTICS statistics)",
          "fn_dec_pos": [
            [
              71,
              14
            ],
            [
              71,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "statistics": "TC_STATISTICS"
            },
            "return_type": "VOID"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnStatisticsUpdate)\t\t(TC_STATISTICS statistics)",
          "fn_dec_pos": [
            [
              72,
              18
            ],
            [
              72,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "statistics": "TC_STATISTICS"
            },
            "return_type": "TC_STATUS"
          }
        },
        {
          "fn_code": "(TC_CALLCONV *TcFcnStatisticsQueryValue)\t(TC_STATISTICS statistics, ULONG counterId, PULONGLONG pValue)",
          "fn_dec_pos": [
            [
              73,
              18
            ],
            [
              73,
              121
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "statistics": "TC_STATISTICS",
              "counterId": "ULONG",
              "pValue": "PULONGLONG"
            },
            "return_type": "TC_STATUS"
          }
        },
        {
          "fn_code": "TcCreatePcapIfFromPort(TC_PORT port)",
          "fn_dec_pos": [
            [
              120,
              18
            ],
            [
              120,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcCreatePcapIfFromPort",
            "parameters": {
              "port": "TC_PORT"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TcSetDatalink(pcap_t *p, int dlt)",
          "fn_dec_pos": [
            [
              121,
              11
            ],
            [
              121,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcSetDatalink",
            "parameters": {
              "p": "pcap_t",
              "dlt": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TcGetNonBlock(pcap_t *p)",
          "fn_dec_pos": [
            [
              122,
              11
            ],
            [
              122,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcGetNonBlock",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TcSetNonBlock(pcap_t *p, int nonblock)",
          "fn_dec_pos": [
            [
              123,
              11
            ],
            [
              123,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcSetNonBlock",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TcCleanup(pcap_t *p)",
          "fn_dec_pos": [
            [
              124,
              12
            ],
            [
              124,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcCleanup",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TcInject(pcap_t *p, const void *buf, int size)",
          "fn_dec_pos": [
            [
              125,
              11
            ],
            [
              125,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcInject",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TcRead(pcap_t *p, int cnt, pcap_handler callback, u_char *user)",
          "fn_dec_pos": [
            [
              126,
              11
            ],
            [
              126,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcRead",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TcStats(pcap_t *p, struct pcap_stat *ps)",
          "fn_dec_pos": [
            [
              127,
              11
            ],
            [
              127,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcStats",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TcStatsEx(pcap_t *p, int *pcap_stat_size)",
          "fn_dec_pos": [
            [
              129,
              25
            ],
            [
              129,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcStatsEx",
            "parameters": {
              "p": "pcap_t",
              "pcap_stat_size": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TcSetBuff(pcap_t *p, int dim)",
          "fn_dec_pos": [
            [
              130,
              11
            ],
            [
              130,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcSetBuff",
            "parameters": {
              "p": "pcap_t",
              "dim": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TcSetMode(pcap_t *p, int mode)",
          "fn_dec_pos": [
            [
              131,
              11
            ],
            [
              131,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcSetMode",
            "parameters": {
              "p": "pcap_t",
              "mode": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TcSetMinToCopy(pcap_t *p, int size)",
          "fn_dec_pos": [
            [
              132,
              11
            ],
            [
              132,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcSetMinToCopy",
            "parameters": {
              "p": "pcap_t",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TcGetReceiveWaitHandle(pcap_t *p)",
          "fn_dec_pos": [
            [
              133,
              14
            ],
            [
              133,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcGetReceiveWaitHandle",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "HANDLE"
          }
        },
        {
          "fn_code": "TcOidGetRequest(pcap_t *p, bpf_u_int32 oid, void *data, size_t *lenp)",
          "fn_dec_pos": [
            [
              134,
              11
            ],
            [
              134,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcOidGetRequest",
            "parameters": {
              "p": "pcap_t",
              "oid": "bpf_u_int32",
              "data": "void",
              "lenp": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TcOidSetRequest(pcap_t *p, bpf_u_int32 oid, const void *data, size_t *lenp)",
          "fn_dec_pos": [
            [
              135,
              11
            ],
            [
              135,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcOidSetRequest",
            "parameters": {
              "p": "pcap_t",
              "oid": "bpf_u_int32",
              "data": "void",
              "lenp": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TcSendqueueTransmit(pcap_t *p, pcap_send_queue *queue, int sync)",
          "fn_dec_pos": [
            [
              136,
              13
            ],
            [
              136,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcSendqueueTransmit",
            "parameters": {
              "p": "pcap_t",
              "queue": "pcap_send_queue",
              "sync": "int"
            },
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "TcSetUserBuffer(pcap_t *p, int size)",
          "fn_dec_pos": [
            [
              137,
              11
            ],
            [
              137,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcSetUserBuffer",
            "parameters": {
              "p": "pcap_t",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TcLiveDump(pcap_t *p, char *filename, int maxsize, int maxpacks)",
          "fn_dec_pos": [
            [
              138,
              11
            ],
            [
              138,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcLiveDump",
            "parameters": {
              "p": "pcap_t",
              "filename": "char",
              "maxsize": "int",
              "maxpacks": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TcLiveDumpEnded(pcap_t *p, int sync)",
          "fn_dec_pos": [
            [
              139,
              11
            ],
            [
              139,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcLiveDumpEnded",
            "parameters": {
              "p": "pcap_t",
              "sync": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TcGetAirPcapHandle(pcap_t *p)",
          "fn_dec_pos": [
            [
              140,
              22
            ],
            [
              140,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcGetAirPcapHandle",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "PAirpcapHandle"
          }
        },
        {
          "fn_code": "TcCreatePcapIfFromPort(TC_PORT port)",
          "fn_dec_pos": [
            [
              489,
              18
            ],
            [
              489,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcCreatePcapIfFromPort",
            "parameters": {
              "port": "TC_PORT"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TcCreate(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              696,
              0
            ],
            [
              696,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcCreate",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TcStatsEx(pcap_t *p, int *pcap_stat_size)",
          "fn_dec_pos": [
            [
              1103,
              0
            ],
            [
              1103,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcStatsEx",
            "parameters": {
              "p": "pcap_t",
              "pcap_stat_size": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct _TC_FUNCTIONS\n{\n\tTC_API_LOAD_STATUS\t\t\tLoadStatus;\n#ifdef _WIN32\n\tHMODULE\t\t\t\t\t\thTcApiDllHandle;\n#endif\n\tTcFcnQueryPortList\t\t\tQueryPortList;\n\tTcFcnFreePortList\t\t\tFreePortList;\n\tTcFcnStatusGetString\t\tStatusGetString;\n\n\tTcFcnPortGetName\t\t\tPortGetName;\n\tTcFcnPortGetDescription\t\tPortGetDescription;\n\n\tTcFcnInstanceOpenByName\t\tInstanceOpenByName;\n\tTcFcnInstanceClose\t\t\tInstanceClose;\n\tTcFcnInstanceSetFeature\t\tInstanceSetFeature;\n\tTcFcnInstanceQueryFeature\tInstanceQueryFeature;\n\tTcFcnInstanceReceivePackets\tInstanceReceivePackets;\n#ifdef _WIN32\n\tTcFcnInstanceGetReceiveWaitHandle InstanceGetReceiveWaitHandle;\n#endif\n\tTcFcnInstanceTransmitPackets InstanceTransmitPackets;\n\tTcFcnInstanceQueryStatistics InstanceQueryStatistics;\n\n\tTcFcnPacketsBufferCreate\tPacketsBufferCreate;\n\tTcFcnPacketsBufferDestroy\tPacketsBufferDestroy;\n\tTcFcnPacketsBufferQueryNextPacket\tPacketsBufferQueryNextPacket;\n\tTcFcnPacketsBufferCommitNextPacket  PacketsBufferCommitNextPacket;\n\n\tTcFcnStatisticsDestroy\t\tStatisticsDestroy;\n\tTcFcnStatisticsUpdate\t\tStatisticsUpdate;\n\tTcFcnStatisticsQueryValue\tStatisticsQueryValue;\n}\n\tTC_FUNCTIONS;",
          {
            "LoadStatus": "TC_API_LOAD_STATUS",
            "hTcApiDllHandle": "HMODULE",
            "QueryPortList": "TcFcnQueryPortList",
            "FreePortList": "TcFcnFreePortList",
            "StatusGetString": "TcFcnStatusGetString",
            "PortGetName": "TcFcnPortGetName",
            "PortGetDescription": "TcFcnPortGetDescription",
            "InstanceOpenByName": "TcFcnInstanceOpenByName",
            "InstanceClose": "TcFcnInstanceClose",
            "InstanceSetFeature": "TcFcnInstanceSetFeature",
            "InstanceQueryFeature": "TcFcnInstanceQueryFeature",
            "InstanceReceivePackets": "TcFcnInstanceReceivePackets",
            "InstanceGetReceiveWaitHandle": "TcFcnInstanceGetReceiveWaitHandle",
            "InstanceTransmitPackets": "TcFcnInstanceTransmitPackets",
            "InstanceQueryStatistics": "TcFcnInstanceQueryStatistics",
            "PacketsBufferCreate": "TcFcnPacketsBufferCreate",
            "PacketsBufferDestroy": "TcFcnPacketsBufferDestroy",
            "PacketsBufferQueryNextPacket": "TcFcnPacketsBufferQueryNextPacket",
            "PacketsBufferCommitNextPacket": "TcFcnPacketsBufferCommitNextPacket",
            "StatisticsDestroy": "TcFcnStatisticsDestroy",
            "StatisticsUpdate": "TcFcnStatisticsUpdate",
            "StatisticsQueryValue": "TcFcnStatisticsQueryValue"
          },
          "TC_FUNCTIONS",
          [
            85,
            0
          ],
          [
            118,
            14
          ]
        ],
        [
          "typedef struct _PPI_PACKET_HEADER\n{\n\tUCHAR\tPphVersion;\n\tUCHAR\tPphFlags;\n\tUSHORT\tPphLength;\n\tULONG\tPphDlt;\n}\n\tPPI_PACKET_HEADER, *PPPI_PACKET_HEADER;",
          {
            "PphVersion": "UCHAR",
            "PphFlags": "UCHAR",
            "PphLength": "USHORT",
            "PphDlt": "ULONG"
          },
          "PPI_PACKET_HEADER",
          [
            205,
            0
          ],
          [
            212,
            40
          ]
        ],
        [
          "typedef struct _PPI_PACKET_HEADER\n{\n\tUCHAR\tPphVersion;\n\tUCHAR\tPphFlags;\n\tUSHORT\tPphLength;\n\tULONG\tPphDlt;\n}\n\tPPI_PACKET_HEADER, *PPPI_PACKET_HEADER;",
          {
            "PphVersion": "UCHAR",
            "PphFlags": "UCHAR",
            "PphLength": "USHORT",
            "PphDlt": "ULONG"
          },
          "PPPI_PACKET_HEADER",
          [
            205,
            0
          ],
          [
            212,
            40
          ]
        ],
        [
          "typedef struct _PPI_FIELD_HEADER\n{\n\tUSHORT PfhType;\n\tUSHORT PfhLength;\n}\n\tPPI_FIELD_HEADER, *PPPI_FIELD_HEADER;",
          {
            "PfhType": "USHORT",
            "PfhLength": "USHORT"
          },
          "PPI_FIELD_HEADER",
          [
            214,
            0
          ],
          [
            219,
            38
          ]
        ],
        [
          "typedef struct _PPI_FIELD_HEADER\n{\n\tUSHORT PfhType;\n\tUSHORT PfhLength;\n}\n\tPPI_FIELD_HEADER, *PPPI_FIELD_HEADER;",
          {
            "PfhType": "USHORT",
            "PfhLength": "USHORT"
          },
          "PPPI_FIELD_HEADER",
          [
            214,
            0
          ],
          [
            219,
            38
          ]
        ],
        [
          "typedef struct _PPI_FIELD_AGGREGATION_EXTENSION\n{\n\tULONG\t\tInterfaceId;\n}\n\tPPI_FIELD_AGGREGATION_EXTENSION, *PPPI_FIELD_AGGREGATION_EXTENSION;",
          {
            "InterfaceId": "ULONG"
          },
          "PPI_FIELD_AGGREGATION_EXTENSION",
          [
            224,
            0
          ],
          [
            228,
            68
          ]
        ],
        [
          "typedef struct _PPI_FIELD_AGGREGATION_EXTENSION\n{\n\tULONG\t\tInterfaceId;\n}\n\tPPI_FIELD_AGGREGATION_EXTENSION, *PPPI_FIELD_AGGREGATION_EXTENSION;",
          {
            "InterfaceId": "ULONG"
          },
          "PPPI_FIELD_AGGREGATION_EXTENSION",
          [
            224,
            0
          ],
          [
            228,
            68
          ]
        ],
        [
          "typedef struct _PPI_FIELD_802_3_EXTENSION\n{\n\tULONG\t\tFlags;\n\tULONG\t\tErrors;\n}\n\tPPI_FIELD_802_3_EXTENSION, *PPPI_FIELD_802_3_EXTENSION;",
          {
            "Flags": "ULONG",
            "Errors": "ULONG"
          },
          "PPI_FIELD_802_3_EXTENSION",
          [
            235,
            0
          ],
          [
            240,
            56
          ]
        ],
        [
          "typedef struct _PPI_FIELD_802_3_EXTENSION\n{\n\tULONG\t\tFlags;\n\tULONG\t\tErrors;\n}\n\tPPI_FIELD_802_3_EXTENSION, *PPPI_FIELD_802_3_EXTENSION;",
          {
            "Flags": "ULONG",
            "Errors": "ULONG"
          },
          "PPPI_FIELD_802_3_EXTENSION",
          [
            235,
            0
          ],
          [
            240,
            56
          ]
        ],
        [
          "typedef struct _PPI_HEADER\n{\n\tPPI_PACKET_HEADER PacketHeader;\n\tPPI_FIELD_HEADER  AggregationFieldHeader;\n\tPPI_FIELD_AGGREGATION_EXTENSION AggregationField;\n\tPPI_FIELD_HEADER  Dot3FieldHeader;\n\tPPI_FIELD_802_3_EXTENSION Dot3Field;\n}\n\tPPI_HEADER, *PPPI_HEADER;",
          {
            "PacketHeader": "PPI_PACKET_HEADER",
            "AggregationFieldHeader": "PPI_FIELD_HEADER",
            "AggregationField": "PPI_FIELD_AGGREGATION_EXTENSION",
            "Dot3FieldHeader": "PPI_FIELD_HEADER",
            "Dot3Field": "PPI_FIELD_802_3_EXTENSION"
          },
          "PPI_HEADER",
          [
            242,
            0
          ],
          [
            250,
            26
          ]
        ],
        [
          "typedef struct _PPI_HEADER\n{\n\tPPI_PACKET_HEADER PacketHeader;\n\tPPI_FIELD_HEADER  AggregationFieldHeader;\n\tPPI_FIELD_AGGREGATION_EXTENSION AggregationField;\n\tPPI_FIELD_HEADER  Dot3FieldHeader;\n\tPPI_FIELD_802_3_EXTENSION Dot3Field;\n}\n\tPPI_HEADER, *PPPI_HEADER;",
          {
            "PacketHeader": "PPI_PACKET_HEADER",
            "AggregationFieldHeader": "PPI_FIELD_HEADER",
            "AggregationField": "PPI_FIELD_AGGREGATION_EXTENSION",
            "Dot3FieldHeader": "PPI_FIELD_HEADER",
            "Dot3Field": "PPI_FIELD_802_3_EXTENSION"
          },
          "PPPI_HEADER",
          [
            242,
            0
          ],
          [
            250,
            26
          ]
        ],
        [
          "struct pcap_tc {\n\tTC_INSTANCE TcInstance;\n\tTC_PACKETS_BUFFER TcPacketsBuffer;\n\tULONG TcAcceptedCount;\n\tu_char *PpiPacket;\n}",
          {
            "TcInstance": "TC_INSTANCE",
            "TcPacketsBuffer": "TC_PACKETS_BUFFER",
            "TcAcceptedCount": "ULONG",
            "*PpiPacket": "u_char"
          },
          "pcap_tc",
          [
            426,
            0
          ],
          [
            431,
            1
          ]
        ],
        [
          "typedef struct _TC_FUNCTIONS\n{\n\tTC_API_LOAD_STATUS\t\t\tLoadStatus;\n#ifdef _WIN32\n\tHMODULE\t\t\t\t\t\thTcApiDllHandle;\n#endif\n\tTcFcnQueryPortList\t\t\tQueryPortList;\n\tTcFcnFreePortList\t\t\tFreePortList;\n\tTcFcnStatusGetString\t\tStatusGetString;\n\n\tTcFcnPortGetName\t\t\tPortGetName;\n\tTcFcnPortGetDescription\t\tPortGetDescription;\n\n\tTcFcnInstanceOpenByName\t\tInstanceOpenByName;\n\tTcFcnInstanceClose\t\t\tInstanceClose;\n\tTcFcnInstanceSetFeature\t\tInstanceSetFeature;\n\tTcFcnInstanceQueryFeature\tInstanceQueryFeature;\n\tTcFcnInstanceReceivePackets\tInstanceReceivePackets;\n#ifdef _WIN32\n\tTcFcnInstanceGetReceiveWaitHandle InstanceGetReceiveWaitHandle;\n#endif\n\tTcFcnInstanceTransmitPackets InstanceTransmitPackets;\n\tTcFcnInstanceQueryStatistics InstanceQueryStatistics;\n\n\tTcFcnPacketsBufferCreate\tPacketsBufferCreate;\n\tTcFcnPacketsBufferDestroy\tPacketsBufferDestroy;\n\tTcFcnPacketsBufferQueryNextPacket\tPacketsBufferQueryNextPacket;\n\tTcFcnPacketsBufferCommitNextPacket  PacketsBufferCommitNextPacket;\n\n\tTcFcnStatisticsDestroy\t\tStatisticsDestroy;\n\tTcFcnStatisticsUpdate\t\tStatisticsUpdate;\n\tTcFcnStatisticsQueryValue\tStatisticsQueryValue;\n}\n\tTC_FUNCTIONS;",
          {
            "LoadStatus": "TC_API_LOAD_STATUS",
            "hTcApiDllHandle": "HMODULE",
            "QueryPortList": "TcFcnQueryPortList",
            "FreePortList": "TcFcnFreePortList",
            "StatusGetString": "TcFcnStatusGetString",
            "PortGetName": "TcFcnPortGetName",
            "PortGetDescription": "TcFcnPortGetDescription",
            "InstanceOpenByName": "TcFcnInstanceOpenByName",
            "InstanceClose": "TcFcnInstanceClose",
            "InstanceSetFeature": "TcFcnInstanceSetFeature",
            "InstanceQueryFeature": "TcFcnInstanceQueryFeature",
            "InstanceReceivePackets": "TcFcnInstanceReceivePackets",
            "InstanceGetReceiveWaitHandle": "TcFcnInstanceGetReceiveWaitHandle",
            "InstanceTransmitPackets": "TcFcnInstanceTransmitPackets",
            "InstanceQueryStatistics": "TcFcnInstanceQueryStatistics",
            "PacketsBufferCreate": "TcFcnPacketsBufferCreate",
            "PacketsBufferDestroy": "TcFcnPacketsBufferDestroy",
            "PacketsBufferQueryNextPacket": "TcFcnPacketsBufferQueryNextPacket",
            "PacketsBufferCommitNextPacket": "TcFcnPacketsBufferCommitNextPacket",
            "StatisticsDestroy": "TcFcnStatisticsDestroy",
            "StatisticsUpdate": "TcFcnStatisticsUpdate",
            "StatisticsQueryValue": "TcFcnStatisticsQueryValue"
          },
          "TC_FUNCTIONS",
          [
            85,
            0
          ],
          [
            118,
            14
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            127,
            30
          ],
          [
            127,
            46
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            129,
            7
          ],
          [
            129,
            23
          ]
        ],
        [
          "typedef struct _PPI_PACKET_HEADER\n{\n\tUCHAR\tPphVersion;\n\tUCHAR\tPphFlags;\n\tUSHORT\tPphLength;\n\tULONG\tPphDlt;\n}\n\tPPI_PACKET_HEADER, *PPPI_PACKET_HEADER;",
          {
            "PphVersion": "UCHAR",
            "PphFlags": "UCHAR",
            "PphLength": "USHORT",
            "PphDlt": "ULONG"
          },
          "PPI_PACKET_HEADER",
          [
            205,
            0
          ],
          [
            212,
            40
          ]
        ],
        [
          "typedef struct _PPI_PACKET_HEADER\n{\n\tUCHAR\tPphVersion;\n\tUCHAR\tPphFlags;\n\tUSHORT\tPphLength;\n\tULONG\tPphDlt;\n}\n\tPPI_PACKET_HEADER, *PPPI_PACKET_HEADER;",
          {
            "PphVersion": "UCHAR",
            "PphFlags": "UCHAR",
            "PphLength": "USHORT",
            "PphDlt": "ULONG"
          },
          "PPPI_PACKET_HEADER",
          [
            205,
            0
          ],
          [
            212,
            40
          ]
        ],
        [
          "typedef struct _PPI_FIELD_HEADER\n{\n\tUSHORT PfhType;\n\tUSHORT PfhLength;\n}\n\tPPI_FIELD_HEADER, *PPPI_FIELD_HEADER;",
          {
            "PfhType": "USHORT",
            "PfhLength": "USHORT"
          },
          "PPI_FIELD_HEADER",
          [
            214,
            0
          ],
          [
            219,
            38
          ]
        ],
        [
          "typedef struct _PPI_FIELD_HEADER\n{\n\tUSHORT PfhType;\n\tUSHORT PfhLength;\n}\n\tPPI_FIELD_HEADER, *PPPI_FIELD_HEADER;",
          {
            "PfhType": "USHORT",
            "PfhLength": "USHORT"
          },
          "PPPI_FIELD_HEADER",
          [
            214,
            0
          ],
          [
            219,
            38
          ]
        ],
        [
          "typedef struct _PPI_FIELD_AGGREGATION_EXTENSION\n{\n\tULONG\t\tInterfaceId;\n}\n\tPPI_FIELD_AGGREGATION_EXTENSION, *PPPI_FIELD_AGGREGATION_EXTENSION;",
          {
            "InterfaceId": "ULONG"
          },
          "PPI_FIELD_AGGREGATION_EXTENSION",
          [
            224,
            0
          ],
          [
            228,
            68
          ]
        ],
        [
          "typedef struct _PPI_FIELD_AGGREGATION_EXTENSION\n{\n\tULONG\t\tInterfaceId;\n}\n\tPPI_FIELD_AGGREGATION_EXTENSION, *PPPI_FIELD_AGGREGATION_EXTENSION;",
          {
            "InterfaceId": "ULONG"
          },
          "PPPI_FIELD_AGGREGATION_EXTENSION",
          [
            224,
            0
          ],
          [
            228,
            68
          ]
        ],
        [
          "typedef struct _PPI_FIELD_802_3_EXTENSION\n{\n\tULONG\t\tFlags;\n\tULONG\t\tErrors;\n}\n\tPPI_FIELD_802_3_EXTENSION, *PPPI_FIELD_802_3_EXTENSION;",
          {
            "Flags": "ULONG",
            "Errors": "ULONG"
          },
          "PPI_FIELD_802_3_EXTENSION",
          [
            235,
            0
          ],
          [
            240,
            56
          ]
        ],
        [
          "typedef struct _PPI_FIELD_802_3_EXTENSION\n{\n\tULONG\t\tFlags;\n\tULONG\t\tErrors;\n}\n\tPPI_FIELD_802_3_EXTENSION, *PPPI_FIELD_802_3_EXTENSION;",
          {
            "Flags": "ULONG",
            "Errors": "ULONG"
          },
          "PPPI_FIELD_802_3_EXTENSION",
          [
            235,
            0
          ],
          [
            240,
            56
          ]
        ],
        [
          "typedef struct _PPI_HEADER\n{\n\tPPI_PACKET_HEADER PacketHeader;\n\tPPI_FIELD_HEADER  AggregationFieldHeader;\n\tPPI_FIELD_AGGREGATION_EXTENSION AggregationField;\n\tPPI_FIELD_HEADER  Dot3FieldHeader;\n\tPPI_FIELD_802_3_EXTENSION Dot3Field;\n}\n\tPPI_HEADER, *PPPI_HEADER;",
          {
            "PacketHeader": "PPI_PACKET_HEADER",
            "AggregationFieldHeader": "PPI_FIELD_HEADER",
            "AggregationField": "PPI_FIELD_AGGREGATION_EXTENSION",
            "Dot3FieldHeader": "PPI_FIELD_HEADER",
            "Dot3Field": "PPI_FIELD_802_3_EXTENSION"
          },
          "PPI_HEADER",
          [
            242,
            0
          ],
          [
            250,
            26
          ]
        ],
        [
          "typedef struct _PPI_HEADER\n{\n\tPPI_PACKET_HEADER PacketHeader;\n\tPPI_FIELD_HEADER  AggregationFieldHeader;\n\tPPI_FIELD_AGGREGATION_EXTENSION AggregationField;\n\tPPI_FIELD_HEADER  Dot3FieldHeader;\n\tPPI_FIELD_802_3_EXTENSION Dot3Field;\n}\n\tPPI_HEADER, *PPPI_HEADER;",
          {
            "PacketHeader": "PPI_PACKET_HEADER",
            "AggregationFieldHeader": "PPI_FIELD_HEADER",
            "AggregationField": "PPI_FIELD_AGGREGATION_EXTENSION",
            "Dot3FieldHeader": "PPI_FIELD_HEADER",
            "Dot3Field": "PPI_FIELD_802_3_EXTENSION"
          },
          "PPPI_HEADER",
          [
            242,
            0
          ],
          [
            250,
            26
          ]
        ],
        [
          "struct pcap_tc {\n\tTC_INSTANCE TcInstance;\n\tTC_PACKETS_BUFFER TcPacketsBuffer;\n\tULONG TcAcceptedCount;\n\tu_char *PpiPacket;\n}",
          {
            "TcInstance": "TC_INSTANCE",
            "TcPacketsBuffer": "TC_PACKETS_BUFFER",
            "TcAcceptedCount": "ULONG",
            "*PpiPacket": "u_char"
          },
          "pcap_tc",
          [
            426,
            0
          ],
          [
            431,
            1
          ]
        ],
        [
          "struct pcap_tc",
          {},
          "",
          [
            535,
            1
          ],
          [
            535,
            15
          ]
        ],
        [
          "struct pcap_tc",
          {},
          "",
          [
            757,
            38
          ],
          [
            757,
            52
          ]
        ],
        [
          "struct pcap_tc",
          {},
          "",
          [
            806,
            1
          ],
          [
            806,
            15
          ]
        ],
        [
          "struct pcap_tc",
          {},
          "",
          [
            834,
            1
          ],
          [
            834,
            15
          ]
        ],
        [
          "struct pcap_tc",
          {},
          "",
          [
            891,
            1
          ],
          [
            891,
            15
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            921,
            2
          ],
          [
            921,
            20
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            1042,
            19
          ],
          [
            1042,
            35
          ]
        ],
        [
          "struct pcap_tc",
          {},
          "",
          [
            1044,
            1
          ],
          [
            1044,
            15
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            1048,
            1
          ],
          [
            1048,
            17
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            1102,
            7
          ],
          [
            1102,
            23
          ]
        ],
        [
          "struct pcap_tc",
          {},
          "",
          [
            1105,
            1
          ],
          [
            1105,
            15
          ]
        ],
        [
          "struct pcap_tc",
          {},
          "",
          [
            1188,
            1
          ],
          [
            1188,
            15
          ]
        ],
        [
          "struct pcap_tc",
          {},
          "",
          [
            1210,
            1
          ],
          [
            1210,
            15
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <pcap.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <pcap-int.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"pcap-tc.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <malloc.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <memory.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <tchar.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum LONG\n{\n\tTC_API_UNLOADED = 0,\n\tTC_API_LOADED,\n\tTC_API_CANNOT_LOAD,\n\tTC_API_LOADING\n}\n\tTC_API_LOAD_STATUS;",
          {
            "TC_API_UNLOADED": "",
            "TC_API_LOADED": "",
            "TC_API_CANNOT_LOAD": "",
            "TC_API_LOADING": ""
          },
          "TC_API_LOAD_STATUS",
          [
            75,
            0
          ],
          [
            82,
            20
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-septel.c": {
      "fn_def_list": [
        {
          "fn_code": "struct pcap_septel {\n\tstruct pcap_stat stat;\n}\n\n/*\n *  Read at most max_packets from the capture queue and call the callback\n *  for each of them. Returns the number of packets handled, -1 if an\n *  error occured, or -2 if we were told to break out of the loop.\n */\nstatic int septel_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user) {\n\n  struct pcap_septel *ps = p->priv;\n  HDR *h;\n  MSG *m;\n  int processed = 0 ;\n  int t = 0 ;\n\n  /* identifier for the message queue of the module(upe) from which we are capturing\n   * packets.These IDs are defined in system.txt . By default it is set to 0x2d\n   * so change it to 0xdd for technical reason and therefore the module id for upe becomes:\n   * LOCAL        0xdd           * upe - Example user part task */\n  unsigned int id = 0xdd;\n\n  /* process the packets */\n  do  {\n\n    unsigned short packet_len = 0;\n    int caplen = 0;\n    int counter = 0;\n    struct pcap_pkthdr   pcap_header;\n    u_char *dp ;\n\n    /*\n     * Has \"pcap_breakloop()\" been called?\n     */\nloop:\n    if (p->break_loop) {\n      /*\n       * Yes - clear the flag that indicates that\n       * it has, and return -2 to indicate that\n       * we were told to break out of the loop.\n       */\n      p->break_loop = 0;\n      return -2;\n    }\n\n    /*repeat until a packet is read\n     *a NULL message means :\n     * when no packet is in queue or all packets in queue already read */\n    do  {\n      /* receive packet in non-blocking mode\n       * GCT_grab is defined in the septel library software */\n      h = GCT_grab(id);\n\n      m = (MSG*)h;\n      /* a couter is added here to avoid an infinite loop\n       * that will cause our capture program GUI to freeze while waiting\n       * for a packet*/\n      counter++ ;\n\n    }\n    while  ((m == NULL)&& (counter< 100)) ;\n\n    if (m != NULL) {\n\n      t = h->type ;\n\n      /* catch only messages with type = 0xcf00 or 0x8f01 corrsponding to ss7 messages*/\n      /* XXX = why not use API_MSG_TX_REQ for 0xcf00 and API_MSG_RX_IND\n       * for 0x8f01? */\n      if ((t != 0xcf00) && (t != 0x8f01)) {\n        relm(h);\n        goto loop ;\n      }\n\n      /* XXX - is API_MSG_RX_IND for an MTP2 or MTP3 message? */\n      dp = get_param(m);/* get pointer to MSG parameter area (m->param) */\n      packet_len = m->len;\n      caplen =  p->snapshot ;\n\n\n      if (caplen > packet_len) {\n\n        caplen = packet_len;\n      }\n      /* Run the packet filter if there is one. */\n      if ((p->fcode.bf_insns == NULL) || pcap_filter(p->fcode.bf_insns, dp, packet_len, caplen)) {\n\n\n        /*  get a time stamp , consisting of :\n         *\n         *  pcap_header.ts.tv_sec:\n         *  ----------------------\n         *   a UNIX format time-in-seconds when he packet was captured,\n         *   i.e. the number of seconds since Epoch time (January 1,1970, 00:00:00 GMT)\n         *\n         *  pcap_header.ts.tv_usec :\n         *  ------------------------\n         *   the number of microseconds since that second\n         *   when the packet was captured\n         */\n\n        (void)gettimeofday(&pcap_header.ts, NULL);\n\n        /* Fill in our own header data */\n        pcap_header.caplen = caplen;\n        pcap_header.len = packet_len;\n\n        /* Count the packet. */\n        ps->stat.ps_recv++;\n\n        /* Call the user supplied callback function */\n        callback(user, &pcap_header, dp);\n\n        processed++ ;\n\n      }\n      /* after being processed the packet must be\n       *released in order to receive another one */\n      relm(h);\n    }else\n      processed++;\n\n  }\n  while (processed < cnt) ;\n\n  return processed ;\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "septel_read",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static int\nseptel_inject(pcap_t *handle, const void *buf _U_, int size _U_)\n{\n  pcap_strlcpy(handle->errbuf, \"Sending packets isn't supported on Septel cards\",\n          PCAP_ERRBUF_SIZE);\n  return (-1);\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              177,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "septel_inject",
            "parameters": {
              "handle": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static pcap_t *septel_activate(pcap_t* handle) {\n  /* Initialize some components of the pcap structure. */\n  handle->linktype = DLT_MTP2;\n\n  /*\n   * Turn a negative snapshot value (invalid), a snapshot value of\n   * 0 (unspecified), or a value bigger than the normal maximum\n   * value, into the maximum allowed value.\n   *\n   * If some application really *needs* a bigger snapshot\n   * length, we should just increase MAXIMUM_SNAPLEN.\n   */\n  if (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)\n    handle->snapshot = MAXIMUM_SNAPLEN;\n\n  handle->bufsize = 0;\n\n  /*\n   * \"select()\" and \"poll()\" don't work on Septel queues\n   */\n  handle->selectable_fd = -1;\n\n  handle->read_op = septel_read;\n  handle->inject_op = septel_inject;\n  handle->setfilter_op = install_bpf_program;\n  handle->set_datalink_op = NULL; /* can't change data link type */\n  handle->getnonblock_op = septel_getnonblock;\n  handle->setnonblock_op = septel_setnonblock;\n  handle->stats_op = septel_stats;\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              186,
              0
            ],
            [
              217,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "septel_activate",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "pcap_t *septel_create(const char *device, char *ebuf, int *is_ours) {\n\tconst char *cp;\n\tpcap_t *p;\n\n\t/* Does this look like the Septel device? */\n\tcp = strrchr(device, '/');\n\tif (cp == NULL)\n\t\tcp = device;\n\tif (strcmp(cp, \"septel\") != 0) {\n\t\t/* Nope, it's not \"septel\" */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\t/* OK, it's probably ours. */\n\t*is_ours = 1;\n\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_septel));\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tp->activate_op = septel_activate;\n\t/*\n\t * Set these up front, so that, even if our client tries\n\t * to set non-blocking mode before we're activated, or\n\t * query the state of non-blocking mode, they get an error,\n\t * rather than having the non-blocking mode option set\n\t * for use later.\n\t */\n\tp->getnonblock_op = septel_getnonblock;\n\tp->setnonblock_op = septel_setnonblock;\n\treturn p;\n}",
          "fn_code_pos": [
            [
              219,
              0
            ],
            [
              251,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "septel_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static int septel_stats(pcap_t *p, struct pcap_stat *ps) {\n  struct pcap_septel *handlep = p->priv;\n  /*handlep->stat.ps_recv = 0;*/\n  /*handlep->stat.ps_drop = 0;*/\n\n  *ps = handlep->stat;\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              253,
              0
            ],
            [
              261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "septel_stats",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nseptel_findalldevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n  /*\n   * XXX - do the notions of \"up\", \"running\", or \"connected\" apply here?\n   */\n  if (add_dev(devlistp,\"septel\",0,\"Intel/Septel device\",errbuf) == NULL)\n    return -1;\n  return 0;\n}",
          "fn_code_pos": [
            [
              264,
              0
            ],
            [
              273,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "septel_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nseptel_getnonblock(pcap_t *p)\n{\n  fprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"Non-blocking mode not supported on Septel devices\");\n  return (-1);\n}",
          "fn_code_pos": [
            [
              282,
              0
            ],
            [
              287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "septel_getnonblock",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nseptel_setnonblock(pcap_t *p, int nonblock _U_)\n{\n  fprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"Non-blocking mode not supported on Septel devices\");\n  return (-1);\n}",
          "fn_code_pos": [
            [
              289,
              0
            ],
            [
              294,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "septel_setnonblock",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n  return (0);\n}",
          "fn_code_pos": [
            [
              305,
              0
            ],
            [
              309,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_platform_finddevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_create_interface(const char *device, char *errbuf)\n{\n  pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n                \"This version of libpcap only supports Septel cards\");\n  return (NULL);\n}",
          "fn_code_pos": [
            [
              314,
              0
            ],
            [
              320,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "errbuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n  return (PCAP_VERSION_STRING \" (Septel-only)\");\n}",
          "fn_code_pos": [
            [
              325,
              0
            ],
            [
              329,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "septel_stats(pcap_t *p, struct pcap_stat *ps)",
          "fn_dec_pos": [
            [
              34,
              11
            ],
            [
              34,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "septel_stats",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "septel_getnonblock(pcap_t *p)",
          "fn_dec_pos": [
            [
              35,
              11
            ],
            [
              35,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "septel_getnonblock",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "septel_setnonblock(pcap_t *p, int nonblock)",
          "fn_dec_pos": [
            [
              36,
              11
            ],
            [
              36,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "septel_setnonblock",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "septel_activate(pcap_t* handle)",
          "fn_dec_pos": [
            [
              186,
              15
            ],
            [
              186,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "septel_activate",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "septel_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              219,
              8
            ],
            [
              219,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "septel_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_create_interface(const char *device, char *errbuf)",
          "fn_dec_pos": [
            [
              315,
              0
            ],
            [
              315,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              326,
              0
            ],
            [
              326,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_septel {\n\tstruct pcap_stat stat;\n}",
          {
            "stat": "struct pcap_stat"
          },
          "pcap_septel",
          [
            41,
            0
          ],
          [
            43,
            1
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            34,
            35
          ],
          [
            34,
            51
          ]
        ],
        [
          "struct pcap_septel {\n\tstruct pcap_stat stat;\n}",
          {
            "stat": "struct pcap_stat"
          },
          "pcap_septel",
          [
            41,
            0
          ],
          [
            43,
            1
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            42,
            1
          ],
          [
            42,
            17
          ]
        ],
        [
          "struct pcap_septel",
          {},
          "",
          [
            52,
            2
          ],
          [
            52,
            20
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            70,
            4
          ],
          [
            70,
            22
          ]
        ],
        [
          "struct pcap_septel",
          {},
          "",
          [
            236,
            38
          ],
          [
            236,
            56
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            253,
            35
          ],
          [
            253,
            51
          ]
        ],
        [
          "struct pcap_septel",
          {},
          "",
          [
            254,
            2
          ],
          [
            254,
            20
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            8,
            0
          ],
          [
            9,
            0
          ]
        ],
        [
          "#include <sys/param.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include <sys/mman.h>\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <msg.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <ss7_inc.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <sysgct.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <pack.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <system.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"pcap-septel.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-npf.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nPacketIsMonitorModeSupported(PCHAR AdapterName _U_)\n{\n\t/*\n\t * We don't support monitor mode.\n\t */\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              96,
              0
            ],
            [
              103,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PacketIsMonitorModeSupported",
            "parameters": {
              "AdapterName": "PCHAR"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPacketSetMonitorMode(PCHAR AdapterName _U_, int mode _U_)\n{\n\t/*\n\t * This should never be called, as PacketIsMonitorModeSupported()\n\t * will return 0, meaning \"we don't support monitor mode, so\n\t * don't try to turn it on or off\".\n\t */\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              105,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PacketSetMonitorMode",
            "parameters": {
              "AdapterName": "PCHAR",
              "mode": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPacketGetMonitorMode(PCHAR AdapterName _U_)\n{\n\t/*\n\t * This should fail, so that pcap_activate_npf() returns\n\t * PCAP_ERROR_RFMON_NOTSUP if our caller requested monitor\n\t * mode.\n\t */\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              116,
              0
            ],
            [
              125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PacketGetMonitorMode",
            "parameters": {
              "AdapterName": "PCHAR"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\noid_get_request(ADAPTER *adapter, bpf_u_int32 oid, void *data, size_t *lenp,\n    char *errbuf)\n{\n\tPACKET_OID_DATA *oid_data_arg;\n\n\t/*\n\t * Allocate a PACKET_OID_DATA structure to hand to PacketRequest().\n\t * It should be big enough to hold \"*lenp\" bytes of data; it\n\t * will actually be slightly larger, as PACKET_OID_DATA has a\n\t * 1-byte data array at the end, standing in for the variable-length\n\t * data that's actually there.\n\t */\n\toid_data_arg = malloc(sizeof (PACKET_OID_DATA) + *lenp);\n\tif (oid_data_arg == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Couldn't allocate argument buffer for PacketRequest\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\t/*\n\t * No need to copy the data - we're doing a fetch.\n\t */\n\toid_data_arg->Oid = oid;\n\toid_data_arg->Length = (ULONG)(*lenp);\t/* XXX - check for ridiculously large value? */\n\tif (!PacketRequest(adapter, FALSE, oid_data_arg)) {\n\t\tchar errmsgbuf[PCAP_ERRBUF_SIZE+1];\n\n\t\tpcap_win32_err_to_str(GetLastError(), errmsgbuf);\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Error calling PacketRequest: %s\", errmsgbuf);\n\t\tfree(oid_data_arg);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Get the length actually supplied.\n\t */\n\t*lenp = oid_data_arg->Length;\n\n\t/*\n\t * Copy back the data we fetched.\n\t */\n\tmemcpy(data, oid_data_arg->Data, *lenp);\n\tfree(oid_data_arg);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              142,
              0
            ],
            [
              188,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "oid_get_request",
            "parameters": {
              "adapter": "ADAPTER",
              "oid": "bpf_u_int32",
              "data": "void",
              "lenp": "size_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_stats_npf(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct pcap_win *pw = p->priv;\n\tstruct bpf_stat bstats;\n\tchar errbuf[PCAP_ERRBUF_SIZE+1];\n\n\t/*\n\t * Try to get statistics.\n\t *\n\t * (Please note - \"struct pcap_stat\" is *not* the same as\n\t * WinPcap's \"struct bpf_stat\". It might currently have the\n\t * same layout, but let's not cheat.\n\t *\n\t * Note also that we don't fill in ps_capt, as we might have\n\t * been called by code compiled against an earlier version of\n\t * WinPcap that didn't have ps_capt, in which case filling it\n\t * in would stomp on whatever comes after the structure passed\n\t * to us.\n\t */\n\tif (!PacketGetStats(pw->adapter, &bstats)) {\n\t\tpcap_win32_err_to_str(GetLastError(), errbuf);\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"PacketGetStats error: %s\", errbuf);\n\t\treturn (-1);\n\t}\n\tps->ps_recv = bstats.bs_recv;\n\tps->ps_drop = bstats.bs_drop;\n\n\t/*\n\t * XXX - PacketGetStats() doesn't fill this in, so we just\n\t * return 0.\n\t */\n#if 0\n\tps->ps_ifdrop = bstats.ps_ifdrop;\n#else\n\tps->ps_ifdrop = 0;\n#endif\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              190,
              0
            ],
            [
              230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_npf",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "struct pcap_stat *\npcap_stats_ex_npf(pcap_t *p, int *pcap_stat_size)\n{\n\tstruct pcap_win *pw = p->priv;\n\tstruct bpf_stat bstats;\n\tchar errbuf[PCAP_ERRBUF_SIZE+1];\n\n\t*pcap_stat_size = sizeof (p->stat);\n\n\t/*\n\t * Try to get statistics.\n\t *\n\t * (Please note - \"struct pcap_stat\" is *not* the same as\n\t * WinPcap's \"struct bpf_stat\". It might currently have the\n\t * same layout, but let's not cheat.)\n\t */\n\tif (!PacketGetStatsEx(pw->adapter, &bstats)) {\n\t\tpcap_win32_err_to_str(GetLastError(), errbuf);\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"PacketGetStatsEx error: %s\", errbuf);\n\t\treturn (NULL);\n\t}\n\tp->stat.ps_recv = bstats.bs_recv;\n\tp->stat.ps_drop = bstats.bs_drop;\n\tp->stat.ps_ifdrop = bstats.ps_ifdrop;\n#ifdef ENABLE_REMOTE\n\tp->stat.ps_capt = bstats.bs_capt;\n#endif\n\treturn (&p->stat);\n}",
          "fn_code_pos": [
            [
              253,
              0
            ],
            [
              282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_ex_npf",
            "parameters": {
              "p": "pcap_t",
              "pcap_stat_size": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static int\npcap_setbuff_npf(pcap_t *p, int dim)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\tif(PacketSetBuff(pw->adapter,dim)==FALSE)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"driver error: not enough memory to allocate the kernel buffer\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              285,
              0
            ],
            [
              296,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setbuff_npf",
            "parameters": {
              "p": "pcap_t",
              "dim": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setmode_npf(pcap_t *p, int mode)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\tif(PacketSetMode(pw->adapter,mode)==FALSE)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"driver error: working mode not recognized\");\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              299,
              0
            ],
            [
              311,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setmode_npf",
            "parameters": {
              "p": "pcap_t",
              "mode": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setmintocopy_npf(pcap_t *p, int size)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\tif(PacketSetMinToCopy(pw->adapter, size)==FALSE)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"driver error: unable to set the requested mintocopy size\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              314,
              0
            ],
            [
              325,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setmintocopy_npf",
            "parameters": {
              "p": "pcap_t",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static HANDLE\npcap_getevent_npf(pcap_t *p)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\treturn (PacketGetReadEvent(pw->adapter));\n}",
          "fn_code_pos": [
            [
              327,
              0
            ],
            [
              333,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getevent_npf",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "HANDLE"
          }
        },
        {
          "fn_code": "static int\npcap_oid_get_request_npf(pcap_t *p, bpf_u_int32 oid, void *data, size_t *lenp)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\treturn (oid_get_request(pw->adapter, oid, data, lenp, p->errbuf));\n}",
          "fn_code_pos": [
            [
              335,
              0
            ],
            [
              341,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_oid_get_request_npf",
            "parameters": {
              "p": "pcap_t",
              "oid": "bpf_u_int32",
              "data": "void",
              "lenp": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_oid_set_request_npf(pcap_t *p, bpf_u_int32 oid, const void *data,\n    size_t *lenp)\n{\n\tstruct pcap_win *pw = p->priv;\n\tPACKET_OID_DATA *oid_data_arg;\n\tchar errbuf[PCAP_ERRBUF_SIZE+1];\n\n\t/*\n\t * Allocate a PACKET_OID_DATA structure to hand to PacketRequest().\n\t * It should be big enough to hold \"*lenp\" bytes of data; it\n\t * will actually be slightly larger, as PACKET_OID_DATA has a\n\t * 1-byte data array at the end, standing in for the variable-length\n\t * data that's actually there.\n\t */\n\toid_data_arg = malloc(sizeof (PACKET_OID_DATA) + *lenp);\n\tif (oid_data_arg == NULL) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Couldn't allocate argument buffer for PacketRequest\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\toid_data_arg->Oid = oid;\n\toid_data_arg->Length = (ULONG)(*lenp);\t/* XXX - check for ridiculously large value? */\n\tmemcpy(oid_data_arg->Data, data, *lenp);\n\tif (!PacketRequest(pw->adapter, TRUE, oid_data_arg)) {\n\t\tpcap_win32_err_to_str(GetLastError(), errbuf);\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Error calling PacketRequest: %s\", errbuf);\n\t\tfree(oid_data_arg);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\t/*\n\t * Get the length actually copied.\n\t */\n\t*lenp = oid_data_arg->Length;\n\n\t/*\n\t * No need to copy the data - we're doing a set.\n\t */\n\tfree(oid_data_arg);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              343,
              0
            ],
            [
              386,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_oid_set_request_npf",
            "parameters": {
              "p": "pcap_t",
              "oid": "bpf_u_int32",
              "data": "void",
              "lenp": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static u_int\npcap_sendqueue_transmit_npf(pcap_t *p, pcap_send_queue *queue, int sync)\n{\n\tstruct pcap_win *pw = p->priv;\n\tu_int res;\n\tchar errbuf[PCAP_ERRBUF_SIZE+1];\n\n\tif (pw->adapter==NULL) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Cannot transmit a queue to an offline capture or to a TurboCap port\");\n\t\treturn (0);\n\t}\n\n\tres = PacketSendPackets(pw->adapter,\n\t\tqueue->buffer,\n\t\tqueue->len,\n\t\t(BOOLEAN)sync);\n\n\tif(res != queue->len){\n\t\tpcap_win32_err_to_str(GetLastError(), errbuf);\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Error opening adapter: %s\", errbuf);\n\t}\n\n\treturn (res);\n}",
          "fn_code_pos": [
            [
              388,
              0
            ],
            [
              413,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_sendqueue_transmit_npf",
            "parameters": {
              "p": "pcap_t",
              "queue": "pcap_send_queue",
              "sync": "int"
            },
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "static int\npcap_setuserbuffer_npf(pcap_t *p, int size)\n{\n\tunsigned char *new_buff;\n\n\tif (size<=0) {\n\t\t/* Bogus parameter */\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Error: invalid size %d\",size);\n\t\treturn (-1);\n\t}\n\n\t/* Allocate the buffer */\n\tnew_buff=(unsigned char*)malloc(sizeof(char)*size);\n\n\tif (!new_buff) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Error: not enough memory\");\n\t\treturn (-1);\n\t}\n\n\tfree(p->buffer);\n\n\tp->buffer=new_buff;\n\tp->bufsize=size;\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              415,
              0
            ],
            [
              442,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setuserbuffer_npf",
            "parameters": {
              "p": "pcap_t",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_live_dump_npf(pcap_t *p, char *filename, int maxsize, int maxpacks)\n{\n\tstruct pcap_win *pw = p->priv;\n\tBOOLEAN res;\n\n\t/* Set the packet driver in dump mode */\n\tres = PacketSetMode(pw->adapter, PACKET_MODE_DUMP);\n\tif(res == FALSE){\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Error setting dump mode\");\n\t\treturn (-1);\n\t}\n\n\t/* Set the name of the dump file */\n\tres = PacketSetDumpName(pw->adapter, filename, (int)strlen(filename));\n\tif(res == FALSE){\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Error setting kernel dump file name\");\n\t\treturn (-1);\n\t}\n\n\t/* Set the limits of the dump file */\n\tres = PacketSetDumpLimits(pw->adapter, maxsize, maxpacks);\n\tif(res == FALSE) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \t\t\"Error setting dump limit\");\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              444,
              0
            ],
            [
              475,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_live_dump_npf",
            "parameters": {
              "p": "pcap_t",
              "filename": "char",
              "maxsize": "int",
              "maxpacks": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_live_dump_ended_npf(pcap_t *p, int sync)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\treturn (PacketIsDumpEnded(pw->adapter, (BOOLEAN)sync));\n}",
          "fn_code_pos": [
            [
              477,
              0
            ],
            [
              483,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_live_dump_ended_npf",
            "parameters": {
              "p": "pcap_t",
              "sync": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static PAirpcapHandle\npcap_get_airpcap_handle_npf(pcap_t *p)\n{\n#ifdef HAVE_AIRPCAP_API\n\tstruct pcap_win *pw = p->priv;\n\n\treturn (PacketGetAirPcapHandle(pw->adapter));\n#else\n\treturn (NULL);\n#endif /* HAVE_AIRPCAP_API */\n}",
          "fn_code_pos": [
            [
              485,
              0
            ],
            [
              495,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_get_airpcap_handle_npf",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "PAirpcapHandle"
          }
        },
        {
          "fn_code": "static int\npcap_inject_npf(pcap_t *p, const void *buf, int size)\n{\n\tstruct pcap_win *pw = p->priv;\n\tPACKET pkt;\n\n\tPacketInitPacket(&pkt, (PVOID)buf, size);\n\tif(PacketSendPacket(pw->adapter,&pkt,TRUE) == FALSE) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"send error: PacketSendPacket failed\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * We assume it all got sent if \"PacketSendPacket()\" succeeded.\n\t * \"pcap_inject()\" is expected to return the number of bytes\n\t * sent.\n\t */\n\treturn (size);\n}",
          "fn_code_pos": [
            [
              833,
              0
            ],
            [
              851,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject_npf",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\npcap_cleanup_npf(pcap_t *p)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\tif (pw->adapter != NULL) {\n\t\tPacketCloseAdapter(pw->adapter);\n\t\tpw->adapter = NULL;\n\t}\n\tif (pw->rfmon_selfstart)\n\t{\n\t\tPacketSetMonitorMode(p->opt.device, 0);\n\t}\n\tpcap_cleanup_live_common(p);\n}",
          "fn_code_pos": [
            [
              853,
              0
            ],
            [
              867,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_cleanup_npf",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\npcap_breakloop_npf(pcap_t *p)\n{\n\tpcap_breakloop_common(p);\n\tstruct pcap_win *pw = p->priv;\n\n\t/* XXX - what if this fails? */\n\tSetEvent(PacketGetReadEvent(pw->adapter));\n}",
          "fn_code_pos": [
            [
              869,
              0
            ],
            [
              877,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_breakloop_npf",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\npcap_can_set_rfmon_npf(pcap_t *p)\n{\n\treturn (PacketIsMonitorModeSupported(p->opt.device) == 1);\n}",
          "fn_code_pos": [
            [
              1243,
              0
            ],
            [
              1247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_can_set_rfmon_npf",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_create_interface(const char *device _U_, char *ebuf)\n{\n\tpcap_t *p;\n\n\tp = pcap_create_common(ebuf, sizeof(struct pcap_win));\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = pcap_activate_npf;\n\tp->can_set_rfmon_op = pcap_can_set_rfmon_npf;\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              1249,
              0
            ],
            [
              1261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static int\npcap_setfilter_npf(pcap_t *p, struct bpf_program *fp)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\tif(PacketSetBpf(pw->adapter,fp)==FALSE){\n\t\t/*\n\t\t * Kernel filter not installed.\n\t\t *\n\t\t * XXX - we don't know whether this failed because:\n\t\t *\n\t\t *  the kernel rejected the filter program as invalid,\n\t\t *  in which case we should fall back on userland\n\t\t *  filtering;\n\t\t *\n\t\t *  the kernel rejected the filter program as too big,\n\t\t *  in which case we should again fall back on\n\t\t *  userland filtering;\n\t\t *\n\t\t *  there was some other problem, in which case we\n\t\t *  should probably report an error.\n\t\t *\n\t\t * For NPF devices, the Win32 status will be\n\t\t * STATUS_INVALID_DEVICE_REQUEST for invalid\n\t\t * filters, but I don't know what it'd be for\n\t\t * other problems, and for some other devices\n\t\t * it might not be set at all.\n\t\t *\n\t\t * So we just fall back on userland filtering in\n\t\t * all cases.\n\t\t */\n\n\t\t/*\n\t\t * install_bpf_program() validates the program.\n\t\t *\n\t\t * XXX - what if we already have a filter in the kernel?\n\t\t */\n\t\tif (install_bpf_program(p, fp) < 0)\n\t\t\treturn (-1);\n\t\tpw->filtering_in_kernel = 0;\t/* filtering in userland */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * It worked.\n\t */\n\tpw->filtering_in_kernel = 1;\t/* filtering in the kernel */\n\n\t/*\n\t * Discard any previously-received packets, as they might have\n\t * passed whatever filter was formerly in effect, but might\n\t * not pass this filter (BIOCSETF discards packets buffered\n\t * in the kernel, so you can lose packets in any case).\n\t */\n\tp->cc = 0;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1263,
              0
            ],
            [
              1319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_npf",
            "parameters": {
              "p": "pcap_t",
              "fp": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setfilter_win32_dag(pcap_t *p, struct bpf_program *fp) {\n\n\tif(!fp)\n\t{\n\t\tpcap_strlcpy(p->errbuf, \"setfilter: No filter specified\", sizeof(p->errbuf));\n\t\treturn (-1);\n\t}\n\n\t/* Install a user level filter */\n\tif (install_bpf_program(p, fp) < 0)\n\t\treturn (-1);\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1324,
              0
            ],
            [
              1338,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_win32_dag",
            "parameters": {
              "p": "pcap_t",
              "fp": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_getnonblock_npf(pcap_t *p)\n{\n\tstruct pcap_win *pw = p->priv;\n\n\t/*\n\t * XXX - if there were a PacketGetReadTimeout() call, we\n\t * would use it, and return 1 if the timeout is -1\n\t * and 0 otherwise.\n\t */\n\treturn (pw->nonblock);\n}",
          "fn_code_pos": [
            [
              1340,
              0
            ],
            [
              1351,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getnonblock_npf",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setnonblock_npf(pcap_t *p, int nonblock)\n{\n\tstruct pcap_win *pw = p->priv;\n\tint newtimeout;\n\tchar win_errbuf[PCAP_ERRBUF_SIZE+1];\n\n\tif (nonblock) {\n\t\t/*\n\t\t * Set the packet buffer timeout to -1 for non-blocking\n\t\t * mode.\n\t\t */\n\t\tnewtimeout = -1;\n\t} else {\n\t\t/*\n\t\t * Restore the timeout set when the device was opened.\n\t\t * (Note that this may be -1, in which case we're not\n\t\t * really leaving non-blocking mode.  However, although\n\t\t * the timeout argument to pcap_set_timeout() and\n\t\t * pcap_open_live() is an int, you're not supposed to\n\t\t * supply a negative value, so that \"shouldn't happen\".)\n\t\t */\n\t\tnewtimeout = p->opt.timeout;\n\t}\n\tif (!PacketSetReadTimeout(pw->adapter, newtimeout)) {\n\t\tpcap_win32_err_to_str(GetLastError(), win_errbuf);\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"PacketSetReadTimeout: %s\", win_errbuf);\n\t\treturn (-1);\n\t}\n\tpw->nonblock = (newtimeout == -1);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1353,
              0
            ],
            [
              1385,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setnonblock_npf",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_add_if_npf(pcap_if_list_t *devlistp, char *name, bpf_u_int32 flags,\n    const char *description, char *errbuf)\n{\n\tpcap_if_t *curdev;\n\tnpf_if_addr if_addrs[MAX_NETWORK_ADDRESSES];\n\tLONG if_addr_size;\n\tint res = 0;\n\n\tif_addr_size = MAX_NETWORK_ADDRESSES;\n\n\t/*\n\t * Add an entry for this interface, with no addresses.\n\t */\n\tcurdev = add_dev(devlistp, name, flags, description, errbuf);\n\tif (curdev == NULL) {\n\t\t/*\n\t\t * Failure.\n\t\t */\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Get the list of addresses for the interface.\n\t */\n\tif (!PacketGetNetInfoEx((void *)name, if_addrs, &if_addr_size)) {\n\t\t/*\n\t\t * Failure.\n\t\t *\n\t\t * We don't return an error, because this can happen with\n\t\t * NdisWan interfaces, and we want to supply them even\n\t\t * if we can't supply their addresses.\n\t\t *\n\t\t * We return an entry with an empty address list.\n\t\t */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Now add the addresses.\n\t */\n\twhile (if_addr_size-- > 0) {\n\t\t/*\n\t\t * \"curdev\" is an entry for this interface; add an entry for\n\t\t * this address to its list of addresses.\n\t\t */\n\t\tres = add_addr_to_dev(curdev,\n\t\t    (struct sockaddr *)&if_addrs[if_addr_size].IPAddress,\n\t\t    sizeof (struct sockaddr_storage),\n\t\t    (struct sockaddr *)&if_addrs[if_addr_size].SubnetMask,\n\t\t    sizeof (struct sockaddr_storage),\n\t\t    (struct sockaddr *)&if_addrs[if_addr_size].Broadcast,\n\t\t    sizeof (struct sockaddr_storage),\n\t\t    NULL,\n\t\t    0,\n\t\t    errbuf);\n\t\tif (res == -1) {\n\t\t\t/*\n\t\t\t * Failure.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (res);\n}",
          "fn_code_pos": [
            [
              1387,
              0
            ],
            [
              1452,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_add_if_npf",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "name": "char",
              "flags": "bpf_u_int32",
              "description": "char",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\tint ret = 0;\n\tconst char *desc;\n\tchar *AdaptersName;\n\tULONG NameLength;\n\tchar *name;\n\tchar our_errbuf[PCAP_ERRBUF_SIZE+1];\n\n\t/*\n\t * Find out how big a buffer we need.\n\t *\n\t * This call should always return FALSE; if the error is\n\t * ERROR_INSUFFICIENT_BUFFER, NameLength will be set to\n\t * the size of the buffer we need, otherwise there's a\n\t * problem, and NameLength should be set to 0.\n\t *\n\t * It shouldn't require NameLength to be set, but,\n\t * at least as of WinPcap 4.1.3, it checks whether\n\t * NameLength is big enough before it checks for a\n\t * NULL buffer argument, so, while it'll still do\n\t * the right thing if NameLength is uninitialized and\n\t * whatever junk happens to be there is big enough\n\t * (because the pointer argument will be null), it's\n\t * still reading an uninitialized variable.\n\t */\n\tNameLength = 0;\n\tif (!PacketGetAdapterNames(NULL, &NameLength))\n\t{\n\t\tDWORD last_error = GetLastError();\n\n\t\tif (last_error != ERROR_INSUFFICIENT_BUFFER)\n\t\t{\n\t\t\tpcap_win32_err_to_str(last_error, our_errbuf);\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"PacketGetAdapterNames: %s\", our_errbuf);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\tif (NameLength <= 0)\n\t\treturn 0;\n\tAdaptersName = (char*) malloc(NameLength);\n\tif (AdaptersName == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Cannot allocate enough memory to list the adapters.\");\n\t\treturn (-1);\n\t}\n\n\tif (!PacketGetAdapterNames(AdaptersName, &NameLength)) {\n\t\tpcap_win32_err_to_str(GetLastError(), our_errbuf);\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"PacketGetAdapterNames: %s\",\n\t\t    our_errbuf);\n\t\tfree(AdaptersName);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * \"PacketGetAdapterNames()\" returned a list of\n\t * null-terminated ASCII interface name strings,\n\t * terminated by a null string, followed by a list\n\t * of null-terminated ASCII interface description\n\t * strings, terminated by a null string.\n\t * This means there are two ASCII nulls at the end\n\t * of the first list.\n\t *\n\t * Find the end of the first list; that's the\n\t * beginning of the second list.\n\t */\n\tdesc = &AdaptersName[0];\n\twhile (*desc != '\\0' || *(desc + 1) != '\\0')\n\t\tdesc++;\n\n\t/*\n \t * Found it - \"desc\" points to the first of the two\n\t * nulls at the end of the list of names, so the\n\t * first byte of the list of descriptions is two bytes\n\t * after it.\n\t */\n\tdesc += 2;\n\n\t/*\n\t * Loop over the elements in the first list.\n\t */\n\tname = &AdaptersName[0];\n\twhile (*name != '\\0') {\n\t\tbpf_u_int32 flags = 0;\n#ifdef HAVE_PACKET_IS_LOOPBACK_ADAPTER\n\t\t/*\n\t\t * Is this a loopback interface?\n\t\t */\n\t\tif (PacketIsLoopbackAdapter(name)) {\n\t\t\t/* Yes */\n\t\t\tflags |= PCAP_IF_LOOPBACK;\n\t\t}\n#endif\n\t\t/*\n\t\t * Get additional flags.\n\t\t */\n\t\tif (get_if_flags(name, &flags, errbuf) == -1) {\n\t\t\t/*\n\t\t\t * Failure.\n\t\t\t */\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Add an entry for this interface.\n\t\t */\n\t\tif (pcap_add_if_npf(devlistp, name, flags, desc,\n\t\t    errbuf) == -1) {\n\t\t\t/*\n\t\t\t * Failure.\n\t\t\t */\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t\tname += strlen(name) + 1;\n\t\tdesc += strlen(desc) + 1;\n\t}\n\n\tfree(AdaptersName);\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              1689,
              0
            ],
            [
              1814,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_platform_finddevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "char *\npcap_lookupdev(char *errbuf)\n{\n\tDWORD dwVersion;\n\tDWORD dwWindowsMajorVersion;\n\tchar our_errbuf[PCAP_ERRBUF_SIZE+1];\n\n#pragma warning (push)\n#pragma warning (disable: 4996) /* disable MSVC's GetVersion() deprecated warning here */\n\tdwVersion = GetVersion();\t/* get the OS version */\n#pragma warning (pop)\n\tdwWindowsMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));\n\n\tif (dwVersion >= 0x80000000 && dwWindowsMajorVersion >= 4) {\n\t\t/*\n\t\t * Windows 95, 98, ME.\n\t\t */\n\t\tULONG NameLength = ADAPTERSNAME_LEN;\n\t\tstatic char AdaptersName[ADAPTERSNAME_LEN];\n\n\t\tif (PacketGetAdapterNames(AdaptersName,&NameLength) )\n\t\t\treturn (AdaptersName);\n\t\telse\n\t\t\treturn NULL;\n\t} else {\n\t\t/*\n\t\t * Windows NT (NT 4.0 and later).\n\t\t * Convert the names to Unicode for backward compatibility.\n\t\t */\n\t\tULONG NameLength = ADAPTERSNAME_LEN;\n\t\tstatic WCHAR AdaptersName[ADAPTERSNAME_LEN];\n\t\tsize_t BufferSpaceLeft;\n\t\tchar *tAstr;\n\t\tWCHAR *Unameptr;\n\t\tchar *Adescptr;\n\t\tsize_t namelen, i;\n\t\tWCHAR *TAdaptersName = (WCHAR*)malloc(ADAPTERSNAME_LEN * sizeof(WCHAR));\n\t\tint NAdapts = 0;\n\n\t\tif(TAdaptersName == NULL)\n\t\t{\n\t\t\t(void)pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"memory allocation failure\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif ( !PacketGetAdapterNames((PTSTR)TAdaptersName,&NameLength) )\n\t\t{\n\t\t\tpcap_win32_err_to_str(GetLastError(), our_errbuf);\n\t\t\t(void)pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\"PacketGetAdapterNames: %s\", our_errbuf);\n\t\t\tfree(TAdaptersName);\n\t\t\treturn NULL;\n\t\t}\n\n\n\t\tBufferSpaceLeft = ADAPTERSNAME_LEN * sizeof(WCHAR);\n\t\ttAstr = (char*)TAdaptersName;\n\t\tUnameptr = AdaptersName;\n\n\t\t/*\n\t\t * Convert the device names to Unicode into AdapterName.\n\t\t */\n\t\tdo {\n\t\t\t/*\n\t\t\t * Length of the name, including the terminating\n\t\t\t * NUL.\n\t\t\t */\n\t\t\tnamelen = strlen(tAstr) + 1;\n\n\t\t\t/*\n\t\t\t * Do we have room for the name in the Unicode\n\t\t\t * buffer?\n\t\t\t */\n\t\t\tif (BufferSpaceLeft < namelen * sizeof(WCHAR)) {\n\t\t\t\t/*\n\t\t\t\t * No.\n\t\t\t\t */\n\t\t\t\tgoto quit;\n\t\t\t}\n\t\t\tBufferSpaceLeft -= namelen * sizeof(WCHAR);\n\n\t\t\t/*\n\t\t\t * Copy the name, converting ASCII to Unicode.\n\t\t\t * namelen includes the NUL, so we copy it as\n\t\t\t * well.\n\t\t\t */\n\t\t\tfor (i = 0; i < namelen; i++)\n\t\t\t\t*Unameptr++ = *tAstr++;\n\n\t\t\t/*\n\t\t\t * Count this adapter.\n\t\t\t */\n\t\t\tNAdapts++;\n\t\t} while (namelen != 1);\n\n\t\t/*\n\t\t * Copy the descriptions, but don't convert them from\n\t\t * ASCII to Unicode.\n\t\t */\n\t\tAdescptr = (char *)Unameptr;\n\t\twhile(NAdapts--)\n\t\t{\n\t\t\tsize_t desclen;\n\n\t\t\tdesclen = strlen(tAstr) + 1;\n\n\t\t\t/*\n\t\t\t * Do we have room for the name in the Unicode\n\t\t\t * buffer?\n\t\t\t */\n\t\t\tif (BufferSpaceLeft < desclen) {\n\t\t\t\t/*\n\t\t\t\t * No.\n\t\t\t\t */\n\t\t\t\tgoto quit;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Just copy the ASCII string.\n\t\t\t * namelen includes the NUL, so we copy it as\n\t\t\t * well.\n\t\t\t */\n\t\t\tmemcpy(Adescptr, tAstr, desclen);\n\t\t\tAdescptr += desclen;\n\t\t\ttAstr += desclen;\n\t\t\tBufferSpaceLeft -= desclen;\n\t\t}\n\n\tquit:\n\t\tfree(TAdaptersName);\n\t\treturn (char *)(AdaptersName);\n\t}\n}",
          "fn_code_pos": [
            [
              1826,
              0
            ],
            [
              1958,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lookupdev",
            "parameters": {
              "errbuf": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int\npcap_lookupnet(const char *device, bpf_u_int32 *netp, bpf_u_int32 *maskp,\n    char *errbuf)\n{\n\t/*\n\t * We need only the first IPv4 address, so we must scan the array returned by PacketGetNetInfo()\n\t * in order to skip non IPv4 (i.e. IPv6 addresses)\n\t */\n\tnpf_if_addr if_addrs[MAX_NETWORK_ADDRESSES];\n\tLONG if_addr_size = MAX_NETWORK_ADDRESSES;\n\tstruct sockaddr_in *t_addr;\n\tLONG i;\n\n\tif (!PacketGetNetInfoEx((void *)device, if_addrs, &if_addr_size)) {\n\t\t*netp = *maskp = 0;\n\t\treturn (0);\n\t}\n\n\tfor(i = 0; i < if_addr_size; i++)\n\t{\n\t\tif(if_addrs[i].IPAddress.ss_family == AF_INET)\n\t\t{\n\t\t\tt_addr = (struct sockaddr_in *) &(if_addrs[i].IPAddress);\n\t\t\t*netp = t_addr->sin_addr.S_un.S_addr;\n\t\t\tt_addr = (struct sockaddr_in *) &(if_addrs[i].SubnetMask);\n\t\t\t*maskp = t_addr->sin_addr.S_un.S_addr;\n\n\t\t\t*netp &= *maskp;\n\t\t\treturn (0);\n\t\t}\n\n\t}\n\n\t*netp = *maskp = 0;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1968,
              0
            ],
            [
              2003,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lookupnet",
            "parameters": {
              "device": "char",
              "netp": "bpf_u_int32",
              "maskp": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n\tif (pcap_lib_version_string == NULL) {\n\t\t/*\n\t\t * Generate the version string.\n\t\t */\n\t\tchar *packet_version_string = PacketGetVersion();\n\n\t\tif (strcmp(WINPCAP_VER_STRING, packet_version_string) == 0) {\n\t\t\t/*\n\t\t\t * WinPcap version string and packet.dll version\n\t\t\t * string are the same; just report the WinPcap\n\t\t\t * version.\n\t\t\t */\n\t\t\tpcap_lib_version_string = pcap_version_string;\n\t\t} else {\n\t\t\t/*\n\t\t\t * WinPcap version string and packet.dll version\n\t\t\t * string are different; that shouldn't be the\n\t\t\t * case (the two libraries should come from the\n\t\t\t * same version of WinPcap), so we report both\n\t\t\t * versions.\n\t\t\t */\n\t\t\tchar *full_pcap_version_string;\n\n\t\t\tif (pcap_asprintf(&full_pcap_version_string,\n\t\t\t    WINPCAP_PRODUCT_NAME \" version \" WINPCAP_VER_STRING \" (packet.dll version %s), based on \" PCAP_VERSION_STRING,\n\t\t\t    packet_version_string) != -1) {\n\t\t\t\t/* Success */\n\t\t\t\tpcap_lib_version_string = full_pcap_version_string;\n\t\t\t}\n\t\t}\n\t}\n\treturn (pcap_lib_version_string);\n}",
          "fn_code_pos": [
            [
              2022,
              0
            ],
            [
              2057,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n\tif (pcap_lib_version_string == NULL) {\n\t\t/*\n\t\t * Generate the version string.  Report the packet.dll\n\t\t * version.\n\t\t */\n\t\tchar *full_pcap_version_string;\n\n\t\tif (pcap_asprintf(&full_pcap_version_string,\n\t\t    PCAP_VERSION_STRING \" (packet.dll version %s)\",\n\t\t    PacketGetVersion()) != -1) {\n\t\t\t/* Success */\n\t\t\tpcap_lib_version_string = full_pcap_version_string;\n\t\t}\n\t}\n\treturn (pcap_lib_version_string);\n}",
          "fn_code_pos": [
            [
              2065,
              0
            ],
            [
              2083,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "pcap_setfilter_npf(pcap_t *, struct bpf_program *)",
          "fn_dec_pos": [
            [
              57,
              11
            ],
            [
              57,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_npf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_setfilter_win32_dag(pcap_t *, struct bpf_program *)",
          "fn_dec_pos": [
            [
              58,
              11
            ],
            [
              58,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_win32_dag",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_getnonblock_npf(pcap_t *)",
          "fn_dec_pos": [
            [
              59,
              11
            ],
            [
              59,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getnonblock_npf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_setnonblock_npf(pcap_t *, int)",
          "fn_dec_pos": [
            [
              60,
              11
            ],
            [
              60,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setnonblock_npf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_stats_ex_npf(pcap_t *p, int *pcap_stat_size)",
          "fn_dec_pos": [
            [
              254,
              0
            ],
            [
              254,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_ex_npf",
            "parameters": {
              "p": "pcap_t",
              "pcap_stat_size": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_read_npf(pcap_t *p, int cnt, pcap_handler callback, u_char *user)",
          "fn_dec_pos": [
            [
              498,
              0
            ],
            [
              498,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_if_flags",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char",
              "name": "char",
              "flags": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_activate_npf(pcap_t *p)",
          "fn_dec_pos": [
            [
              880,
              0
            ],
            [
              880,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_if_flags",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char",
              "name": "char",
              "flags": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_create_interface(const char *device _U_, char *ebuf)",
          "fn_dec_pos": [
            [
              1250,
              0
            ],
            [
              1250,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "get_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)",
          "fn_dec_pos": [
            [
              1455,
              0
            ],
            [
              1455,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_if_flags",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char",
              "name": "char",
              "flags": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_lookupdev(char *errbuf)",
          "fn_dec_pos": [
            [
              1827,
              0
            ],
            [
              1827,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lookupdev",
            "parameters": {
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              2023,
              0
            ],
            [
              2023,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              2066,
              0
            ],
            [
              2066,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_win {\n\tADAPTER *adapter;\t\t/* the packet32 ADAPTER for the device */\n\tint nonblock;\n\tint rfmon_selfstart;\t\t/* a flag tells whether the monitor mode is set by itself */\n\tint filtering_in_kernel;\t/* using kernel filter */\n\n#ifdef HAVE_DAG_API\n\tint\tdag_fcs_bits;\t\t/* Number of checksum bits from link layer */\n#endif\n\n#ifdef ENABLE_REMOTE\n\tint samp_npkt;\t\t\t/* parameter needed for sampling, with '1 out of N' method has been requested */\n\tstruct timeval samp_time;\t/* parameter needed for sampling, with '1 every N ms' method has been requested */\n#endif\n}",
          {
            "*adapter": "ADAPTER",
            "nonblock": "int",
            "rfmon_selfstart": "int",
            "filtering_in_kernel": "int",
            "dag_fcs_bits": "int",
            "samp_npkt": "int",
            "samp_time": "struct timeval"
          },
          "pcap_win",
          [
            74,
            0
          ],
          [
            88,
            1
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            57,
            40
          ],
          [
            57,
            58
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            58,
            46
          ],
          [
            58,
            64
          ]
        ],
        [
          "struct pcap_win {\n\tADAPTER *adapter;\t\t/* the packet32 ADAPTER for the device */\n\tint nonblock;\n\tint rfmon_selfstart;\t\t/* a flag tells whether the monitor mode is set by itself */\n\tint filtering_in_kernel;\t/* using kernel filter */\n\n#ifdef HAVE_DAG_API\n\tint\tdag_fcs_bits;\t\t/* Number of checksum bits from link layer */\n#endif\n\n#ifdef ENABLE_REMOTE\n\tint samp_npkt;\t\t\t/* parameter needed for sampling, with '1 out of N' method has been requested */\n\tstruct timeval samp_time;\t/* parameter needed for sampling, with '1 every N ms' method has been requested */\n#endif\n}",
          {
            "*adapter": "ADAPTER",
            "nonblock": "int",
            "rfmon_selfstart": "int",
            "filtering_in_kernel": "int",
            "dag_fcs_bits": "int",
            "samp_npkt": "int",
            "samp_time": "struct timeval"
          },
          "pcap_win",
          [
            74,
            0
          ],
          [
            88,
            1
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            86,
            1
          ],
          [
            86,
            15
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            191,
            26
          ],
          [
            191,
            42
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            193,
            1
          ],
          [
            193,
            16
          ]
        ],
        [
          "struct bpf_stat",
          {},
          "",
          [
            194,
            1
          ],
          [
            194,
            16
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            253,
            0
          ],
          [
            253,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            256,
            1
          ],
          [
            256,
            16
          ]
        ],
        [
          "struct bpf_stat",
          {},
          "",
          [
            257,
            1
          ],
          [
            257,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            288,
            1
          ],
          [
            288,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            302,
            1
          ],
          [
            302,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            317,
            1
          ],
          [
            317,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            330,
            1
          ],
          [
            330,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            338,
            1
          ],
          [
            338,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            347,
            1
          ],
          [
            347,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            391,
            1
          ],
          [
            391,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            447,
            1
          ],
          [
            447,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            480,
            1
          ],
          [
            480,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            489,
            1
          ],
          [
            489,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            505,
            1
          ],
          [
            505,
            16
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            609,
            4
          ],
          [
            609,
            22
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            609,
            38
          ],
          [
            609,
            56
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            638,
            22
          ],
          [
            638,
            40
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            836,
            1
          ],
          [
            836,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            856,
            1
          ],
          [
            856,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            873,
            1
          ],
          [
            873,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            882,
            1
          ],
          [
            882,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            1254,
            37
          ],
          [
            1254,
            52
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            1264,
            30
          ],
          [
            1264,
            48
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            1266,
            1
          ],
          [
            1266,
            16
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            1325,
            36
          ],
          [
            1325,
            54
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            1343,
            1
          ],
          [
            1343,
            16
          ]
        ],
        [
          "struct pcap_win",
          {},
          "",
          [
            1356,
            1
          ],
          [
            1356,
            16
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1434,
            7
          ],
          [
            1434,
            22
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1435,
            14
          ],
          [
            1435,
            37
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1436,
            7
          ],
          [
            1436,
            22
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1437,
            14
          ],
          [
            1437,
            37
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1438,
            7
          ],
          [
            1438,
            22
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1439,
            14
          ],
          [
            1439,
            37
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            1978,
            1
          ],
          [
            1978,
            19
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            1990,
            13
          ],
          [
            1990,
            31
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            1992,
            13
          ],
          [
            1992,
            31
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <Packet32.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <pcap-int.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <pcap/dlt.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <ddk/ntddndis.h>\n",
          [
            46,
            2
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <ddk/ndis.h>\n",
          [
            47,
            2
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <ntddndis.h>  /* MSVC/TDM-MinGW/MinGW64 */\n",
          [
            49,
            2
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <dagnew.h>\n",
          [
            53,
            2
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <dagapi.h>\n",
          [
            54,
            2
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include \"../../version.h\"\n",
          [
            2017,
            0
          ],
          [
            2018,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/savefile.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nsf_setnonblock(pcap_t *p, int nonblock _U_)\n{\n\t/*\n\t * This is a savefile, not a live capture file, so reject\n\t * requests to put it in non-blocking mode.  (If it's a\n\t * pipe, it could be put in non-blocking mode, but that\n\t * would significantly complicate the code to read packets,\n\t * as it would have to handle reading partial packets and\n\t * keeping the state of the read.)\n\t */\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Savefiles cannot be put into non-blocking mode\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              95,
              0
            ],
            [
              109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_setnonblock",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nsf_stats(pcap_t *p, struct pcap_stat *ps _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Statistics aren't available from savefiles\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              111,
              0
            ],
            [
              117,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_stats",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static struct pcap_stat *\nsf_stats_ex(pcap_t *p, int *size)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Statistics aren't available from savefiles\");\n\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              126,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_stats_ex",
            "parameters": {
              "p": "pcap_t",
              "size": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static int\nsf_setbuff(pcap_t *p, int dim)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The kernel buffer size cannot be set while reading from a file\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              134,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_setbuff",
            "parameters": {
              "p": "pcap_t",
              "dim": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nsf_setmode(pcap_t *p, int mode)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"impossible to set mode while reading from a file\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              136,
              0
            ],
            [
              142,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_setmode",
            "parameters": {
              "p": "pcap_t",
              "mode": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nsf_setmintocopy(pcap_t *p, int size)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The mintocopy parameter cannot be set while reading from a file\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              144,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_setmintocopy",
            "parameters": {
              "p": "pcap_t",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static HANDLE\nsf_getevent(pcap_t *pcap)\n{\n\t(void)pcap_snprintf(pcap->errbuf, sizeof(pcap->errbuf),\n\t    \"The read event cannot be retrieved while reading from a file\");\n\treturn (INVALID_HANDLE_VALUE);\n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_getevent",
            "parameters": {
              "pcap": "pcap_t"
            },
            "return_type": "HANDLE"
          }
        },
        {
          "fn_code": "static int\nsf_oid_get_request(pcap_t *p, bpf_u_int32 oid _U_, void *data _U_,\n    size_t *lenp _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"An OID get request cannot be performed on a file\");\n\treturn (PCAP_ERROR);\n}",
          "fn_code_pos": [
            [
              160,
              0
            ],
            [
              167,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_oid_get_request",
            "parameters": {
              "p": "pcap_t",
              "oid": "bpf_u_int32",
              "data": "void",
              "lenp": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nsf_oid_set_request(pcap_t *p, bpf_u_int32 oid _U_, const void *data _U_,\n    size_t *lenp _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"An OID set request cannot be performed on a file\");\n\treturn (PCAP_ERROR);\n}",
          "fn_code_pos": [
            [
              169,
              0
            ],
            [
              176,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_oid_set_request",
            "parameters": {
              "p": "pcap_t",
              "oid": "bpf_u_int32",
              "data": "void",
              "lenp": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static u_int\nsf_sendqueue_transmit(pcap_t *p, pcap_send_queue *queue, int sync)\n{\n\tpcap_strlcpy(p->errbuf, \"Sending packets isn't supported on savefiles\",\n\t    PCAP_ERRBUF_SIZE);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              178,
              0
            ],
            [
              184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_sendqueue_transmit",
            "parameters": {
              "p": "pcap_t",
              "queue": "pcap_send_queue",
              "sync": "int"
            },
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "static int\nsf_setuserbuffer(pcap_t *p, int size)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The user buffer cannot be set when reading from a file\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              186,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_setuserbuffer",
            "parameters": {
              "p": "pcap_t",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nsf_live_dump(pcap_t *p, char *filename, int maxsize, int maxpacks)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Live packet dumping cannot be performed when reading from a file\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              194,
              0
            ],
            [
              200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_live_dump",
            "parameters": {
              "p": "pcap_t",
              "filename": "char",
              "maxsize": "int",
              "maxpacks": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nsf_live_dump_ended(pcap_t *p, int sync)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Live packet dumping cannot be performed on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              202,
              0
            ],
            [
              208,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_live_dump_ended",
            "parameters": {
              "p": "pcap_t",
              "sync": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static PAirpcapHandle\nsf_get_airpcap_handle(pcap_t *pcap)\n{\n\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              210,
              0
            ],
            [
              214,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_get_airpcap_handle",
            "parameters": {
              "pcap": "pcap_t"
            },
            "return_type": "PAirpcapHandle"
          }
        },
        {
          "fn_code": "static int\nsf_inject(pcap_t *p, const void *buf _U_, int size _U_)\n{\n\tpcap_strlcpy(p->errbuf, \"Sending packets isn't supported on savefiles\",\n\t    PCAP_ERRBUF_SIZE);\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              217,
              0
            ],
            [
              223,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_inject",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nsf_setdirection(pcap_t *p, pcap_direction_t d _U_)\n{\n\tpcap_snprintf(p->errbuf, sizeof(p->errbuf),\n\t    \"Setting direction is not supported on savefiles\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              229,
              0
            ],
            [
              235,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_setdirection",
            "parameters": {
              "p": "pcap_t",
              "d": "pcap_direction_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\nsf_cleanup(pcap_t *p)\n{\n\tif (p->rfile != stdin)\n\t\t(void)fclose(p->rfile);\n\tif (p->buffer != NULL)\n\t\tfree(p->buffer);\n\tpcap_freecode(&p->fcode);\n}",
          "fn_code_pos": [
            [
              237,
              0
            ],
            [
              245,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_cleanup",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_open_offline_with_tstamp_precision(const char *fname, u_int precision,\n\t\t\t\t\tchar *errbuf)\n{\n\tFILE *fp;\n\tpcap_t *p;\n\n\tif (fname == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"A null pointer was supplied as the file name\");\n\t\treturn (NULL);\n\t}\n\tif (fname[0] == '-' && fname[1] == '\\0')\n\t{\n\t\tfp = stdin;\n#if defined(_WIN32) || defined(MSDOS)\n\t\t/*\n\t\t * We're reading from the standard input, so put it in binary\n\t\t * mode, as savefiles are binary files.\n\t\t */\n\t\tSET_BINMODE(fp);\n#endif\n\t}\n\telse {\n\t\t/*\n\t\t * \"b\" is supported as of C90, so *all* UN*Xes should\n\t\t * support it, even though it does nothing.  It's\n\t\t * required on Windows, as the file is a binary file\n\t\t * and must be read in binary mode.\n\t\t */\n\t\tfp = fopen(fname, \"rb\");\n\t\tif (fp == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"%s\", fname);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tp = pcap_fopen_offline_with_tstamp_precision(fp, precision, errbuf);\n\tif (p == NULL) {\n\t\tif (fp != stdin)\n\t\t\tfclose(fp);\n\t}\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              247,
              0
            ],
            [
              290,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_offline_with_tstamp_precision",
            "parameters": {
              "fname": "char",
              "precision": "u_int",
              "errbuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_open_offline(const char *fname, char *errbuf)\n{\n\treturn (pcap_open_offline_with_tstamp_precision(fname,\n\t    PCAP_TSTAMP_PRECISION_MICRO, errbuf));\n}",
          "fn_code_pos": [
            [
              292,
              0
            ],
            [
              297,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_offline",
            "parameters": {
              "fname": "char",
              "errbuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "pcap_t* pcap_hopen_offline_with_tstamp_precision(intptr_t osfd, u_int precision,\n    char *errbuf)\n{\n\tint fd;\n\tFILE *file;\n\n\tfd = _open_osfhandle(osfd, _O_RDONLY);\n\tif ( fd < 0 )\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"_open_osfhandle\");\n\t\treturn NULL;\n\t}\n\n\tfile = _fdopen(fd, \"rb\");\n\tif ( file == NULL )\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"_fdopen\");\n\t\t_close(fd);\n\t\treturn NULL;\n\t}\n\n\treturn pcap_fopen_offline_with_tstamp_precision(file, precision,\n\t    errbuf);\n}",
          "fn_code_pos": [
            [
              300,
              0
            ],
            [
              325,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_hopen_offline_with_tstamp_precision",
            "parameters": {
              "osfd": "intptr_t",
              "precision": "u_int",
              "errbuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "pcap_t* pcap_hopen_offline(intptr_t osfd, char *errbuf)\n{\n\treturn pcap_hopen_offline_with_tstamp_precision(osfd,\n\t    PCAP_TSTAMP_PRECISION_MICRO, errbuf);\n}",
          "fn_code_pos": [
            [
              327,
              0
            ],
            [
              331,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_hopen_offline",
            "parameters": {
              "osfd": "intptr_t",
              "errbuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static\n#endif\npcap_t *\npcap_fopen_offline_with_tstamp_precision(FILE *fp, u_int precision,\n    char *errbuf)\n{\n\tregister pcap_t *p;\n\tbpf_u_int32 magic;\n\tsize_t amt_read;\n\tu_int i;\n\tint err;\n\n\t/*\n\t * Read the first 4 bytes of the file; the network analyzer dump\n\t * file formats we support (pcap and pcapng), and several other\n\t * formats we might support in the future (such as snoop, DOS and\n\t * Windows Sniffer, and Microsoft Network Monitor) all have magic\n\t * numbers that are unique in their first 4 bytes.\n\t */\n\tamt_read = fread((char *)&magic, 1, sizeof(magic), fp);\n\tif (amt_read != sizeof(magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t} else {\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"truncated dump file; tried to read %\" PRIsize \" file header bytes, only got %\" PRIsize,\n\t\t\t    sizeof(magic), amt_read);\n\t\t}\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Try all file types.\n\t */\n\tfor (i = 0; i < N_FILE_TYPES; i++) {\n\t\tp = (*check_headers[i])(magic, fp, precision, errbuf, &err);\n\t\tif (p != NULL) {\n\t\t\t/* Yup, that's it. */\n\t\t\tgoto found;\n\t\t}\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * Error trying to read the header.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\t/*\n\t * Well, who knows what this mess is....\n\t */\n\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"unknown file format\");\n\treturn (NULL);\n\nfound:\n\tp->rfile = fp;\n\n\t/* Padding only needed for live capture fcode */\n\tp->fddipad = 0;\n\n#if !defined(_WIN32) && !defined(MSDOS)\n\t/*\n\t * You can do \"select()\" and \"poll()\" on plain files on most\n\t * platforms, and should be able to do so on pipes.\n\t *\n\t * You can't do \"select()\" on anything other than sockets in\n\t * Windows, so, on Win32 systems, we don't have \"selectable_fd\".\n\t */\n\tp->selectable_fd = fileno(fp);\n#endif\n\n\tp->read_op = pcap_offline_read;\n\tp->inject_op = sf_inject;\n\tp->setfilter_op = install_bpf_program;\n\tp->setdirection_op = sf_setdirection;\n\tp->set_datalink_op = NULL;\t/* we don't support munging link-layer headers */\n\tp->getnonblock_op = sf_getnonblock;\n\tp->setnonblock_op = sf_setnonblock;\n\tp->stats_op = sf_stats;\n#ifdef _WIN32\n\tp->stats_ex_op = sf_stats_ex;\n\tp->setbuff_op = sf_setbuff;\n\tp->setmode_op = sf_setmode;\n\tp->setmintocopy_op = sf_setmintocopy;\n\tp->getevent_op = sf_getevent;\n\tp->oid_get_request_op = sf_oid_get_request;\n\tp->oid_set_request_op = sf_oid_set_request;\n\tp->sendqueue_transmit_op = sf_sendqueue_transmit;\n\tp->setuserbuffer_op = sf_setuserbuffer;\n\tp->live_dump_op = sf_live_dump;\n\tp->live_dump_ended_op = sf_live_dump_ended;\n\tp->get_airpcap_handle_op = sf_get_airpcap_handle;\n#endif\n\n\t/*\n\t * For offline captures, the standard one-shot callback can\n\t * be used for pcap_next()/pcap_next_ex().\n\t */\n\tp->oneshot_callback = pcap_oneshot;\n\n\t/*\n\t * Savefiles never require special BPF code generation.\n\t */\n\tp->bpf_codegen_flags = 0;\n\n\tp->activated = 1;\n\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              342,
              0
            ],
            [
              451,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_fopen_offline_with_tstamp_precision",
            "parameters": {
              "fp": "FILE",
              "precision": "u_int",
              "errbuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_fopen_offline(FILE *fp, char *errbuf)\n{\n\treturn (pcap_fopen_offline_with_tstamp_precision(fp,\n\t    PCAP_TSTAMP_PRECISION_MICRO, errbuf));\n}",
          "fn_code_pos": [
            [
              456,
              0
            ],
            [
              461,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_fopen_offline",
            "parameters": {
              "fp": "FILE",
              "errbuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "int\npcap_offline_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tstruct bpf_insn *fcode;\n\tint status = 0;\n\tint n = 0;\n\tu_char *data;\n\n\twhile (status == 0) {\n\t\tstruct pcap_pkthdr h;\n\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t * If so, return immediately - if we haven't read any\n\t\t * packets, clear the flag and return -2 to indicate\n\t\t * that we were told to break out of the loop, otherwise\n\t\t * leave the flag set, so that the *next* call will break\n\t\t * out of the loop without having read any packets, and\n\t\t * return the number of packets we've processed so far.\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\tif (n == 0) {\n\t\t\t\tp->break_loop = 0;\n\t\t\t\treturn (-2);\n\t\t\t} else\n\t\t\t\treturn (n);\n\t\t}\n\n\t\tstatus = p->next_packet_op(p, &h, &data);\n\t\tif (status) {\n\t\t\tif (status == 1)\n\t\t\t\treturn (0);\n\t\t\treturn (status);\n\t\t}\n\n\t\tif ((fcode = p->fcode.bf_insns) == NULL ||\n\t\t    pcap_filter(fcode, data, h.len, h.caplen)) {\n\t\t\t(*callback)(user, &h, data);\n\t\t\tif (++n >= cnt && cnt > 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/*XXX this breaks semantics tcpslice expects */\n\treturn (n);\n}",
          "fn_code_pos": [
            [
              468,
              0
            ],
            [
              512,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_offline_read",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "pcap_fopen_offline_with_tstamp_precision(FILE *, u_int, char *)",
          "fn_dec_pos": [
            [
              68,
              15
            ],
            [
              68,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_fopen_offline_with_tstamp_precision",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_fopen_offline(FILE *, char *)",
          "fn_dec_pos": [
            [
              69,
              15
            ],
            [
              69,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_fopen_offline",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "sf_stats_ex(pcap_t *p, int *size)",
          "fn_dec_pos": [
            [
              121,
              0
            ],
            [
              121,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_stats_ex",
            "parameters": {
              "p": "pcap_t",
              "size": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_open_offline_with_tstamp_precision(const char *fname, u_int precision,\n\t\t\t\t\tchar *errbuf)",
          "fn_dec_pos": [
            [
              248,
              0
            ],
            [
              249,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_offline_with_tstamp_precision",
            "parameters": {
              "fname": "char",
              "precision": "u_int",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_open_offline(const char *fname, char *errbuf)",
          "fn_dec_pos": [
            [
              293,
              0
            ],
            [
              293,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_offline",
            "parameters": {
              "fname": "char",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_hopen_offline_with_tstamp_precision(intptr_t osfd, u_int precision,\n    char *errbuf)",
          "fn_dec_pos": [
            [
              300,
              8
            ],
            [
              301,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_hopen_offline_with_tstamp_precision",
            "parameters": {
              "osfd": "intptr_t",
              "precision": "u_int",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_hopen_offline(intptr_t osfd, char *errbuf)",
          "fn_dec_pos": [
            [
              327,
              8
            ],
            [
              327,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_hopen_offline",
            "parameters": {
              "osfd": "intptr_t",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*check_headers[])(bpf_u_int32, FILE *, u_int, char *, int *)",
          "fn_dec_pos": [
            [
              334,
              15
            ],
            [
              334,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_fopen_offline_with_tstamp_precision(FILE *fp, u_int precision,\n    char *errbuf)",
          "fn_dec_pos": [
            [
              345,
              0
            ],
            [
              346,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_fopen_offline_with_tstamp_precision",
            "parameters": {
              "fp": "FILE",
              "precision": "u_int",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_fopen_offline(FILE *fp, char *errbuf)",
          "fn_dec_pos": [
            [
              457,
              0
            ],
            [
              457,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_fopen_offline",
            "parameters": {
              "fp": "FILE",
              "errbuf": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_stat",
          {},
          "",
          [
            112,
            20
          ],
          [
            112,
            36
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            120,
            7
          ],
          [
            120,
            23
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            471,
            1
          ],
          [
            471,
            16
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            477,
            2
          ],
          [
            477,
            20
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <pcap-types.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <io.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <memory.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include \"sf-pcap.h\"\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include \"sf-pcapng.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-dos.c": {
      "fn_def_list": [
        {
          "fn_code": "static struct device *get_device (int fd)\n{\n  if (fd <= 0 || fd >= sizeof(handle_to_device)/sizeof(handle_to_device[0]))\n     return (NULL);\n  return handle_to_device [fd-1];\n}",
          "fn_code_pos": [
            [
              136,
              0
            ],
            [
              141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_device",
            "parameters": {
              "fd": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_t *pcap_create_interface (const char *device _U_, char *ebuf)\n{\n\tpcap_t *p;\n\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_dos));\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = pcap_activate_dos;\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              151,
              0
            ],
            [
              161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static int pcap_activate_dos (pcap_t *pcap)\n{\n  if (pcap->opt.rfmon) {\n    /*\n     * No monitor mode on DOS.\n     */\n    return (PCAP_ERROR_RFMON_NOTSUP);\n  }\n\n  /*\n   * Turn a negative snapshot value (invalid), a snapshot value of\n   * 0 (unspecified), or a value bigger than the normal maximum\n   * value, into the maximum allowed value.\n   *\n   * If some application really *needs* a bigger snapshot\n   * length, we should just increase MAXIMUM_SNAPLEN.\n   */\n  if (pcap->snapshot <= 0 || pcap->snapshot > MAXIMUM_SNAPLEN)\n    pcap->snapshot = MAXIMUM_SNAPLEN;\n\n  if (pcap->snapshot < ETH_MIN+8)\n      pcap->snapshot = ETH_MIN+8;\n\n  if (pcap->snapshot > ETH_MAX)   /* silently accept and truncate large MTUs */\n      pcap->snapshot = ETH_MAX;\n\n  pcap->linktype          = DLT_EN10MB;  /* !! */\n  pcap->cleanup_op        = pcap_cleanup_dos;\n  pcap->read_op           = pcap_read_dos;\n  pcap->stats_op          = pcap_stats_dos;\n  pcap->inject_op         = pcap_sendpacket_dos;\n  pcap->setfilter_op      = pcap_setfilter_dos;\n  pcap->setdirection_op   = NULL;  /* Not implemented.*/\n  pcap->fd                = ++ref_count;\n\n  pcap->bufsize = ETH_MAX+100;     /* add some margin */\n  pcap->buffer = calloc (pcap->bufsize, 1);\n\n  if (pcap->fd == 1)  /* first time we're called */\n  {\n    if (!init_watt32(pcap, pcap->opt.device, pcap->errbuf) ||\n        !first_init(pcap->opt.device, pcap->errbuf, pcap->opt.promisc))\n    {\n      /* XXX - free pcap->buffer? */\n      return (PCAP_ERROR);\n    }\n    atexit (close_driver);\n  }\n  else if (stricmp(active_dev->name,pcap->opt.device))\n  {\n    pcap_snprintf (pcap->errbuf, PCAP_ERRBUF_SIZE,\n                   \"Cannot use different devices simultaneously \"\n                   \"(`%s' vs. `%s')\", active_dev->name, pcap->opt.device);\n    /* XXX - free pcap->buffer? */\n    return (PCAP_ERROR);\n  }\n  handle_to_device [pcap->fd-1] = active_dev;\n  return (0);\n}",
          "fn_code_pos": [
            [
              167,
              0
            ],
            [
              225,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_activate_dos",
            "parameters": {
              "pcap": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_read_one (pcap_t *p, pcap_handler callback, u_char *data)\n{\n  struct pcap_dos *pd = p->priv;\n  struct pcap_pkthdr pcap;\n  struct timeval     now, expiry = { 0,0 };\n  int    rx_len = 0;\n\n  if (p->opt.timeout > 0)\n  {\n    gettimeofday2 (&now, NULL);\n    expiry.tv_usec = now.tv_usec + 1000UL * p->opt.timeout;\n    expiry.tv_sec  = now.tv_sec;\n    while (expiry.tv_usec >= 1000000L)\n    {\n      expiry.tv_usec -= 1000000L;\n      expiry.tv_sec++;\n    }\n  }\n\n  while (!exc_occured)\n  {\n    volatile struct device *dev; /* might be reset by sig_handler */\n\n    dev = get_device (p->fd);\n    if (!dev)\n       break;\n\n    PCAP_ASSERT (dev->copy_rx_buf || dev->peek_rx_buf);\n    FLUSHK();\n\n    /* If driver has a zero-copy receive facility, peek at the queue,\n     * filter it, do the callback and release the buffer.\n     */\n    if (dev->peek_rx_buf)\n    {\n      PCAP_ASSERT (dev->release_rx_buf);\n      rx_len = (*dev->peek_rx_buf) (&p->buffer);\n    }\n    else\n    {\n      rx_len = (*dev->copy_rx_buf) (p->buffer, p->snapshot);\n    }\n\n    if (rx_len > 0)  /* got a packet */\n    {\n      mac_count++;\n\n      FLUSHK();\n\n      pcap.caplen = min (rx_len, p->snapshot);\n      pcap.len    = rx_len;\n\n      if (callback &&\n          (!p->fcode.bf_insns || pcap_filter(p->fcode.bf_insns, p->buffer, pcap.len, pcap.caplen)))\n      {\n        filter_count++;\n\n        /* Fix-me!! Should be time of arrival. Not time of\n         * capture.\n         */\n        gettimeofday2 (&pcap.ts, NULL);\n        (*callback) (data, &pcap, p->buffer);\n      }\n\n      if (dev->release_rx_buf)\n        (*dev->release_rx_buf) (p->buffer);\n\n      if (pcap_pkt_debug > 0)\n      {\n        if (callback == watt32_recv_hook)\n             dbug_write (\"pcap_recv_hook\\n\");\n        else dbug_write (\"pcap_read_op\\n\");\n      }\n      FLUSHK();\n      return (1);\n    }\n\n    /* Has \"pcap_breakloop()\" been called?\n     */\n    if (p->break_loop) {\n      /*\n       * Yes - clear the flag that indicates that it\n       * has, and return -2 to indicate that we were\n       * told to break out of the loop.\n       */\n      p->break_loop = 0;\n      return (-2);\n    }\n\n    /* If not to wait for a packet or pcap_cleanup_dos() called from\n     * e.g. SIGINT handler, exit loop now.\n     */\n    if (p->opt.timeout <= 0 || (volatile int)p->fd <= 0)\n       break;\n\n    gettimeofday2 (&now, NULL);\n\n    if (timercmp(&now, &expiry, >))\n       break;\n\n#ifndef DJGPP\n    kbhit();    /* a real CPU hog */\n#endif\n\n    if (pd->wait_proc)\n      (*pd->wait_proc)();     /* call yield func */\n  }\n\n  if (rx_len < 0)            /* receive error */\n  {\n    pd->stat.ps_drop++;\n#ifdef USE_32BIT_DRIVERS\n    if (pcap_pkt_debug > 1)\n       printk (\"pkt-err %s\\n\", pktInfo.error);\n#endif\n    return (-1);\n  }\n  return (0);\n}",
          "fn_code_pos": [
            [
              231,
              0
            ],
            [
              350,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_one",
            "parameters": {
              "p": "pcap_t",
              "callback": "pcap_handler",
              "data": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_read_dos (pcap_t *p, int cnt, pcap_handler callback, u_char *data)\n{\n  int rc, num = 0;\n\n  while (num <= cnt || PACKET_COUNT_IS_UNLIMITED(cnt))\n  {\n    if (p->fd <= 0)\n       return (-1);\n    rc = pcap_read_one (p, callback, data);\n    if (rc > 0)\n       num++;\n    if (rc < 0)\n       break;\n    _w32_os_yield();  /* allow SIGINT generation, yield to Win95/NT */\n  }\n  return (num);\n}",
          "fn_code_pos": [
            [
              352,
              0
            ],
            [
              369,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_dos",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "data": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_stats_dos (pcap_t *p, struct pcap_stat *ps)\n{\n  struct net_device_stats *stats;\n  struct pcap_dos         *pd;\n  struct device           *dev = p ? get_device(p->fd) : NULL;\n\n  if (!dev)\n  {\n    strcpy (p->errbuf, \"illegal pcap handle\");\n    return (-1);\n  }\n\n  if (!dev->get_stats || (stats = (*dev->get_stats)(dev)) == NULL)\n  {\n    strcpy (p->errbuf, \"device statistics not available\");\n    return (-1);\n  }\n\n  FLUSHK();\n\n  pd = p->priv;\n  pd->stat.ps_recv   = stats->rx_packets;\n  pd->stat.ps_drop  += stats->rx_missed_errors;\n  pd->stat.ps_ifdrop = stats->rx_dropped +  /* queue full */\n                         stats->rx_errors;    /* HW errors */\n  if (ps)\n     *ps = pd->stat;\n\n  return (0);\n}",
          "fn_code_pos": [
            [
              374,
              0
            ],
            [
              403,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_dos",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int pcap_stats_ex (pcap_t *p, struct pcap_stat_ex *se)\n{\n  struct device *dev = p ? get_device (p->fd) : NULL;\n\n  if (!dev || !dev->get_stats)\n  {\n    pcap_strlcpy (p->errbuf, \"detailed device statistics not available\",\n             PCAP_ERRBUF_SIZE);\n    return (-1);\n  }\n\n  if (!strnicmp(dev->name,\"pkt\",3))\n  {\n    pcap_strlcpy (p->errbuf, \"pktdrvr doesn't have detailed statistics\",\n             PCAP_ERRBUF_SIZE);\n    return (-1);\n  }\n  memcpy (se, (*dev->get_stats)(dev), sizeof(*se));\n  return (0);\n}",
          "fn_code_pos": [
            [
              409,
              0
            ],
            [
              428,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_ex",
            "parameters": {
              "p": "pcap_t",
              "se": "struct pcap_stat_ex"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_setfilter_dos (pcap_t *p, struct bpf_program *fp)\n{\n  if (!p)\n     return (-1);\n  p->fcode = *fp;\n  return (0);\n}",
          "fn_code_pos": [
            [
              435,
              0
            ],
            [
              441,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_dos",
            "parameters": {
              "p": "pcap_t",
              "fp": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "u_long pcap_mac_packets (void)\n{\n  return (mac_count);\n}",
          "fn_code_pos": [
            [
              446,
              0
            ],
            [
              449,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_mac_packets",
            "parameters": {},
            "return_type": "u_long"
          }
        },
        {
          "fn_code": "u_long pcap_filter_packets (void)\n{\n  return (filter_count);\n}",
          "fn_code_pos": [
            [
              454,
              0
            ],
            [
              457,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_filter_packets",
            "parameters": {},
            "return_type": "u_long"
          }
        },
        {
          "fn_code": "static void pcap_cleanup_dos (pcap_t *p)\n{\n  struct pcap_dos *pd;\n\n  if (!exc_occured)\n  {\n    pd = p->priv;\n    if (pcap_stats(p,NULL) < 0)\n       pd->stat.ps_drop = 0;\n    if (!get_device(p->fd))\n       return;\n\n    handle_to_device [p->fd-1] = NULL;\n    p->fd = 0;\n    if (ref_count > 0)\n        ref_count--;\n    if (ref_count > 0)\n       return;\n  }\n  close_driver();\n  /* XXX - call pcap_cleanup_live_common? */\n}",
          "fn_code_pos": [
            [
              462,
              0
            ],
            [
              483,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_cleanup_dos",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "char *pcap_lookupdev (char *ebuf)\n{\n  struct device *dev;\n\n#ifdef USE_32BIT_DRIVERS\n  init_32bit();\n#endif\n\n  for (dev = (struct device*)dev_base; dev; dev = dev->next)\n  {\n    PCAP_ASSERT (dev->probe);\n\n    if ((*dev->probe)(dev))\n    {\n      FLUSHK();\n      probed_dev = (struct device*) dev; /* remember last probed device */\n      return (char*) dev->name;\n    }\n  }\n\n  if (ebuf)\n     strcpy (ebuf, \"No driver found\");\n  return (NULL);\n}",
          "fn_code_pos": [
            [
              489,
              0
            ],
            [
              512,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lookupdev",
            "parameters": {
              "ebuf": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int pcap_lookupnet (const char *device, bpf_u_int32 *localnet,\n                    bpf_u_int32 *netmask, char *errbuf)\n{\n  DWORD mask, net;\n\n  if (!_watt_is_init)\n  {\n    strcpy (errbuf, \"pcap_open_offline() or pcap_activate() must be \"\n                    \"called first\");\n    return (-1);\n  }\n\n  mask  = _w32_sin_mask;\n  net = my_ip_addr & mask;\n  if (net == 0)\n  {\n    if (IN_CLASSA(*netmask))\n       net = IN_CLASSA_NET;\n    else if (IN_CLASSB(*netmask))\n       net = IN_CLASSB_NET;\n    else if (IN_CLASSC(*netmask))\n       net = IN_CLASSC_NET;\n    else\n    {\n      pcap_snprintf (errbuf, PCAP_ERRBUF_SIZE, \"inet class for 0x%lx unknown\", mask);\n      return (-1);\n    }\n  }\n  *localnet = htonl (net);\n  *netmask = htonl (mask);\n\n  ARGSUSED (device);\n  return (0);\n}",
          "fn_code_pos": [
            [
              517,
              0
            ],
            [
              550,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lookupnet",
            "parameters": {
              "device": "char",
              "localnet": "bpf_u_int32",
              "netmask": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int pcap_platform_finddevs  (pcap_if_list_t *devlistp, char *errbuf)\n{\n  struct device     *dev;\n  pcap_if_t *curdev;\n#if 0   /* Pkt drivers should have no addresses */\n  struct sockaddr_in sa_ll_1, sa_ll_2;\n  struct sockaddr   *addr, *netmask, *broadaddr, *dstaddr;\n#endif\n  int       ret = 0;\n  int       found = 0;\n\n  for (dev = (struct device*)dev_base; dev; dev = dev->next)\n  {\n    PCAP_ASSERT (dev->probe);\n\n    if (!(*dev->probe)(dev))\n       continue;\n\n    PCAP_ASSERT (dev->close);  /* set by probe routine */\n    FLUSHK();\n    (*dev->close) (dev);\n\n    /*\n     * XXX - find out whether it's up or running?  Does that apply here?\n     * Can we find out if anything's plugged into the adapter, if it's\n     * a wired device, and set PCAP_IF_CONNECTION_STATUS_CONNECTED\n     * or PCAP_IF_CONNECTION_STATUS_DISCONNECTED?\n     */\n    if ((curdev = add_dev(devlistp, dev->name, 0,\n                dev->long_name, errbuf)) == NULL)\n    {\n      ret = -1;\n      break;\n    }\n    found = 1;\n#if 0   /* Pkt drivers should have no addresses */\n    memset (&sa_ll_1, 0, sizeof(sa_ll_1));\n    memset (&sa_ll_2, 0, sizeof(sa_ll_2));\n    sa_ll_1.sin_family = AF_INET;\n    sa_ll_2.sin_family = AF_INET;\n\n    addr      = (struct sockaddr*) &sa_ll_1;\n    netmask   = (struct sockaddr*) &sa_ll_1;\n    dstaddr   = (struct sockaddr*) &sa_ll_1;\n    broadaddr = (struct sockaddr*) &sa_ll_2;\n    memset (&sa_ll_2.sin_addr, 0xFF, sizeof(sa_ll_2.sin_addr));\n\n    if (add_addr_to_dev(curdev, addr, sizeof(*addr),\n                        netmask, sizeof(*netmask),\n                        broadaddr, sizeof(*broadaddr),\n                        dstaddr, sizeof(*dstaddr), errbuf) < 0)\n    {\n      ret = -1;\n      break;\n    }\n#endif\n  }\n\n  if (ret == 0 && !found)\n     strcpy (errbuf, \"No drivers found\");\n\n  return (ret);\n}",
          "fn_code_pos": [
            [
              557,
              0
            ],
            [
              619,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_platform_finddevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void pcap_assert (const char *what, const char *file, unsigned line)\n{\n  FLUSHK();\n  fprintf (stderr, \"%s (%u): Assertion \\\"%s\\\" failed\\n\",\n           file, line, what);\n  close_driver();\n  _exit (-1);\n}",
          "fn_code_pos": [
            [
              624,
              0
            ],
            [
              631,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_assert",
            "parameters": {
              "what": "char",
              "file": "char",
              "line": "unsigned"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void pcap_set_wait (pcap_t *p, void (*yield)(void), int wait)\n{\n  if (p)\n  {\n    struct pcap_dos *pd = p->priv;\n\n    pd->wait_proc  = yield;\n    p->opt.timeout = wait;\n  }\n}",
          "fn_code_pos": [
            [
              637,
              0
            ],
            [
              646,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_wait",
            "parameters": {
              "p": "pcap_t",
              "yield": "void",
              "wait": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static struct device *\nopen_driver (const char *dev_name, char *ebuf, int promisc)\n{\n  struct device *dev;\n\n  for (dev = (struct device*)dev_base; dev; dev = dev->next)\n  {\n    PCAP_ASSERT (dev->name);\n\n    if (strcmp (dev_name,dev->name))\n       continue;\n\n    if (!probed_dev)   /* user didn't call pcap_lookupdev() first */\n    {\n      PCAP_ASSERT (dev->probe);\n\n      if (!(*dev->probe)(dev))    /* call the xx_probe() function */\n      {\n        pcap_snprintf (ebuf, PCAP_ERRBUF_SIZE, \"failed to detect device `%s'\", dev_name);\n        return (NULL);\n      }\n      probed_dev = dev;  /* device is probed okay and may be used */\n    }\n    else if (dev != probed_dev)\n    {\n      goto not_probed;\n    }\n\n    FLUSHK();\n\n    /* Select what traffic to receive\n     */\n    if (promisc)\n         dev->flags |=  (IFF_ALLMULTI | IFF_PROMISC);\n    else dev->flags &= ~(IFF_ALLMULTI | IFF_PROMISC);\n\n    PCAP_ASSERT (dev->open);\n\n    if (!(*dev->open)(dev))\n    {\n      pcap_snprintf (ebuf, PCAP_ERRBUF_SIZE, \"failed to activate device `%s'\", dev_name);\n      if (pktInfo.error && !strncmp(dev->name,\"pkt\",3))\n      {\n        strcat (ebuf, \": \");\n        strcat (ebuf, pktInfo.error);\n      }\n      return (NULL);\n    }\n\n    /* Some devices need this to operate in promiscous mode\n     */\n    if (promisc && dev->set_multicast_list)\n       (*dev->set_multicast_list) (dev);\n\n    active_dev = dev;   /* remember our active device */\n    break;\n  }\n\n  /* 'dev_name' not matched in 'dev_base' list.\n   */\n  if (!dev)\n  {\n    pcap_snprintf (ebuf, PCAP_ERRBUF_SIZE, \"device `%s' not supported\", dev_name);\n    return (NULL);\n  }\n\nnot_probed:\n  if (!probed_dev)\n  {\n    pcap_snprintf (ebuf, PCAP_ERRBUF_SIZE, \"device `%s' not probed\", dev_name);\n    return (NULL);\n  }\n  return (dev);\n}",
          "fn_code_pos": [
            [
              651,
              0
            ],
            [
              724,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "open_driver",
            "parameters": {
              "dev_name": "char",
              "ebuf": "char",
              "promisc": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void close_driver (void)\n{\n  /* !!todo: loop over all 'handle_to_device[]' ? */\n  struct device *dev = active_dev;\n\n  if (dev && dev->close)\n  {\n    (*dev->close) (dev);\n    FLUSHK();\n  }\n\n  active_dev = NULL;\n\n#ifdef USE_32BIT_DRIVERS\n  if (rx_pool)\n  {\n    k_free (rx_pool);\n    rx_pool = NULL;\n  }\n  if (dev)\n     pcibios_exit();\n#endif\n}",
          "fn_code_pos": [
            [
              730,
              0
            ],
            [
              752,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "close_driver",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void setup_signals (void (*handler)(int))\n{\n  signal (SIGSEGV,handler);\n  signal (SIGILL, handler);\n  signal (SIGFPE, handler);\n}",
          "fn_code_pos": [
            [
              756,
              0
            ],
            [
              761,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setup_signals",
            "parameters": {
              "handler": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void exc_handler (int sig)\n{\n#ifdef USE_32BIT_DRIVERS\n  if (active_dev->irq > 0)    /* excludes IRQ 0 */\n  {\n    disable_irq (active_dev->irq);\n    irq_eoi_cmd (active_dev->irq);\n    _printk_safe = 1;\n  }\n#endif\n\n  switch (sig)\n  {\n    case SIGSEGV:\n         fputs (\"Catching SIGSEGV.\\n\", stderr);\n         break;\n    case SIGILL:\n         fputs (\"Catching SIGILL.\\n\", stderr);\n         break;\n    case SIGFPE:\n         _fpreset();\n         fputs (\"Catching SIGFPE.\\n\", stderr);\n         break;\n    default:\n         fprintf (stderr, \"Catching signal %d.\\n\", sig);\n  }\n  exc_occured = 1;\n  close_driver();\n}",
          "fn_code_pos": [
            [
              763,
              0
            ],
            [
              791,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "exc_handler",
            "parameters": {
              "sig": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int first_init (const char *name, char *ebuf, int promisc)\n{\n  struct device *dev;\n\n#ifdef USE_32BIT_DRIVERS\n  rx_pool = k_calloc (RECEIVE_BUF_SIZE, RECEIVE_QUEUE_SIZE);\n  if (!rx_pool)\n  {\n    strcpy (ebuf, \"Not enough memory (Rx pool)\");\n    return (0);\n  }\n#endif\n\n#ifdef __DJGPP__\n  setup_signals (exc_handler);\n#endif\n\n#ifdef USE_32BIT_DRIVERS\n  init_32bit();\n#endif\n\n  dev = open_driver (name, ebuf, promisc);\n  if (!dev)\n  {\n#ifdef USE_32BIT_DRIVERS\n    k_free (rx_pool);\n    rx_pool = NULL;\n#endif\n\n#ifdef __DJGPP__\n    setup_signals (SIG_DFL);\n#endif\n    return (0);\n  }\n\n#ifdef USE_32BIT_DRIVERS\n  /*\n   * If driver is NOT a 16-bit \"pkt/ndis\" driver (having a 'copy_rx_buf'\n   * set in it's probe handler), initialise near-memory ring-buffer for\n   * the 32-bit device.\n   */\n  if (dev->copy_rx_buf == NULL)\n  {\n    dev->get_rx_buf     = get_rxbuf;\n    dev->peek_rx_buf    = peek_rxbuf;\n    dev->release_rx_buf = release_rxbuf;\n    pktq_init (&dev->queue, RECEIVE_BUF_SIZE, RECEIVE_QUEUE_SIZE, rx_pool);\n  }\n#endif\n  return (1);\n}",
          "fn_code_pos": [
            [
              798,
              0
            ],
            [
              848,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "first_init",
            "parameters": {
              "name": "char",
              "ebuf": "char",
              "promisc": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void init_32bit (void)\n{\n  static int init_pci = 0;\n\n  if (!_printk_file)\n     _printk_init (64*1024, NULL); /* calls atexit(printk_exit) */\n\n  if (!init_pci)\n     (void)pci_init();             /* init BIOS32+PCI interface */\n  init_pci = 1;\n}",
          "fn_code_pos": [
            [
              851,
              0
            ],
            [
              861,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "init_32bit",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void watt32_recv_hook (u_char *dummy, const struct pcap_pkthdr *pcap,\n                              const u_char *buf)\n{\n  /* Fix me: assumes Ethernet II only */\n  struct ether_header *ep = (struct ether_header*) buf;\n\n  memcpy (rxbuf, buf, pcap->caplen);\n  etype = ep->ether_type;\n  ARGSUSED (dummy);\n}",
          "fn_code_pos": [
            [
              872,
              0
            ],
            [
              881,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "watt32_recv_hook",
            "parameters": {
              "dummy": "u_char",
              "pcap": "struct pcap_pkthdr",
              "buf": "u_char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void *pcap_recv_hook (WORD *type)\n{\n  int len = pcap_read_dos (&pcap_save, 1, watt32_recv_hook, NULL);\n\n  if (len < 0)\n     return (NULL);\n\n  *type = etype;\n  return (void*) &rxbuf;\n}",
          "fn_code_pos": [
            [
              888,
              0
            ],
            [
              897,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_recv_hook",
            "parameters": {
              "type": "WORD"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int pcap_xmit_hook (const void *buf, unsigned len)\n{\n  int rc = 0;\n\n  if (pcap_pkt_debug > 0)\n     dbug_write (\"pcap_xmit_hook: \");\n\n  if (active_dev && active_dev->xmit)\n     if ((*active_dev->xmit) (active_dev, buf, len) > 0)\n        rc = len;\n\n  if (pcap_pkt_debug > 0)\n     dbug_write (rc ? \"ok\\n\" : \"fail\\n\");\n  return (rc);\n}",
          "fn_code_pos": [
            [
              903,
              0
            ],
            [
              917,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_xmit_hook",
            "parameters": {
              "buf": "void",
              "len": "unsigned"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_sendpacket_dos (pcap_t *p, const void *buf, size_t len)\n{\n  struct device *dev = p ? get_device(p->fd) : NULL;\n\n  if (!dev || !dev->xmit)\n     return (-1);\n  return (*dev->xmit) (dev, buf, len);\n}",
          "fn_code_pos": [
            [
              920,
              0
            ],
            [
              927,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_sendpacket_dos",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "len": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void pcap_init_hook (void)\n{\n  _w32__bootp_on = _w32__dhcp_on = _w32__rarp_on = 0;\n  _w32__do_mask_req = 0;\n  _w32_dynamic_host = 0;\n  if (prev_post_hook)\n    (*prev_post_hook)();\n}",
          "fn_code_pos": [
            [
              935,
              0
            ],
            [
              942,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_init_hook",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void null_print (void) {}",
          "fn_code_pos": [
            [
              947,
              0
            ],
            [
              947,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "null_print",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int init_watt32 (struct pcap *pcap, const char *dev_name, char *err_buf)\n{\n  char *env;\n  int   rc, MTU, has_ip_addr;\n  int   using_pktdrv = 1;\n\n  /* If user called sock_init() first, we need to reinit in\n   * order to open debug/trace-file properly\n   */\n  if (_watt_is_init)\n     sock_exit();\n\n  env = getenv (\"PCAP_TRACE\");\n  if (env && atoi(env) > 0 &&\n      pcap_pkt_debug < 0)   /* if not already set */\n  {\n    dbug_init();\n    pcap_pkt_debug = atoi (env);\n  }\n\n  _watt_do_exit      = 0;    /* prevent sock_init() calling exit() */\n  prev_post_hook     = _w32_usr_post_init;\n  _w32_usr_post_init = pcap_init_hook;\n  _w32_print_hook    = null_print;\n\n  if (dev_name && strncmp(dev_name,\"pkt\",3))\n     using_pktdrv = FALSE;\n\n  rc = sock_init();\n  has_ip_addr = (rc != 8);  /* IP-address assignment failed */\n\n  /* if pcap is using a 32-bit driver w/o a pktdrvr loaded, we\n   * just pretend Watt-32 is initialised okay.\n   *\n   * !! fix-me: The Watt-32 config isn't done if no pktdrvr\n   *            was found. In that case my_ip_addr + sin_mask\n   *            have default values. Should be taken from another\n   *            ini-file/environment in any case (ref. tcpdump.ini)\n   */\n  _watt_is_init = 1;\n\n  if (!using_pktdrv || !has_ip_addr)  /* for now .... */\n  {\n    static const char myip[] = \"192.168.0.1\";\n    static const char mask[] = \"255.255.255.0\";\n\n    printf (\"Just guessing, using IP %s and netmask %s\\n\", myip, mask);\n    my_ip_addr    = aton (myip);\n    _w32_sin_mask = aton (mask);\n  }\n  else if (rc && using_pktdrv)\n  {\n    pcap_snprintf (err_buf, PCAP_ERRBUF_SIZE, \"sock_init() failed, code %d\", rc);\n    return (0);\n  }\n\n  /* Set recv-hook for peeking in _eth_arrived().\n   */\n#if (WATTCP_VER >= 0x0224)\n  _eth_recv_hook = pcap_recv_hook;\n  _eth_xmit_hook = pcap_xmit_hook;\n#endif\n\n  /* Free the pkt-drvr handle allocated in pkt_init().\n   * The above hooks should thus use the handle reopened in open_driver()\n   */\n  if (using_pktdrv)\n  {\n    _eth_release();\n/*  _eth_is_init = 1; */  /* hack to get Rx/Tx-hooks in Watt-32 working */\n  }\n\n  memcpy (&pcap_save, pcap, sizeof(pcap_save));\n  MTU = pkt_get_mtu();\n  pcap_save.fcode.bf_insns = NULL;\n  pcap_save.linktype       = _eth_get_hwtype (NULL, NULL);\n  pcap_save.snapshot       = MTU > 0 ? MTU : ETH_MAX; /* assume 1514 */\n\n#if 1\n  /* prevent use of resolve() and resolve_ip()\n   */\n  last_nameserver = 0;\n#endif\n  return (1);\n}",
          "fn_code_pos": [
            [
              955,
              0
            ],
            [
              1039,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "init_watt32",
            "parameters": {
              "pcap": "struct pcap",
              "dev_name": "char",
              "err_buf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int pcap_config_hook (const char *keyword, const char *value)\n{\n  return parse_config_table (debug_tab, NULL, keyword, value);\n}",
          "fn_code_pos": [
            [
              1087,
              0
            ],
            [
              1090,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_config_hook",
            "parameters": {
              "keyword": "char",
              "value": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void pkt_close (struct device *dev)\n{\n  BOOL okay = PktExitDriver();\n\n  if (pcap_pkt_debug > 1)\n     fprintf (stderr, \"pkt_close(): %d\\n\", okay);\n\n  if (dev->priv)\n     free (dev->priv);\n  dev->priv = NULL;\n}",
          "fn_code_pos": [
            [
              1104,
              0
            ],
            [
              1114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pkt_close",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int pkt_open (struct device *dev)\n{\n  PKT_RX_MODE mode;\n\n  if (dev->flags & IFF_PROMISC)\n       mode = PDRX_ALL_PACKETS;\n  else mode = PDRX_BROADCAST;\n\n  if (!PktInitDriver(mode))\n     return (0);\n\n  PktResetStatistics (pktInfo.handle);\n  PktQueueBusy (FALSE);\n  return (1);\n}",
          "fn_code_pos": [
            [
              1116,
              0
            ],
            [
              1130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pkt_open",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pkt_xmit (struct device *dev, const void *buf, int len)\n{\n  struct net_device_stats *stats = (struct net_device_stats*) dev->priv;\n\n  if (pcap_pkt_debug > 0)\n     dbug_write (\"pcap_xmit\\n\");\n\n  if (!PktTransmit(buf,len))\n  {\n    stats->tx_errors++;\n    return (0);\n  }\n  return (len);\n}",
          "fn_code_pos": [
            [
              1132,
              0
            ],
            [
              1145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pkt_xmit",
            "parameters": {
              "dev": "struct device",
              "buf": "void",
              "len": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void *pkt_stats (struct device *dev)\n{\n  struct net_device_stats *stats = (struct net_device_stats*) dev->priv;\n\n  if (!stats || !PktSessStatistics(pktInfo.handle))\n     return (NULL);\n\n  stats->rx_packets       = pktStat.inPackets;\n  stats->rx_errors        = pktStat.lost;\n  stats->rx_missed_errors = PktRxDropped();\n  return (stats);\n}",
          "fn_code_pos": [
            [
              1147,
              0
            ],
            [
              1158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pkt_stats",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int pkt_probe (struct device *dev)\n{\n  if (!PktSearchDriver())\n     return (0);\n\n  dev->open           = pkt_open;\n  dev->xmit           = pkt_xmit;\n  dev->close          = pkt_close;\n  dev->get_stats      = pkt_stats;\n  dev->copy_rx_buf    = PktReceive;  /* farmem peek and copy routine */\n  dev->get_rx_buf     = NULL;\n  dev->peek_rx_buf    = NULL;\n  dev->release_rx_buf = NULL;\n  dev->priv           = calloc (sizeof(struct net_device_stats), 1);\n  if (!dev->priv)\n     return (0);\n  return (1);\n}",
          "fn_code_pos": [
            [
              1160,
              0
            ],
            [
              1177,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pkt_probe",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void ndis_close (struct device *dev)\n{\n#ifdef USE_NDIS2\n  NdisShutdown();\n#endif\n  ARGSUSED (dev);\n}",
          "fn_code_pos": [
            [
              1182,
              0
            ],
            [
              1188,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ndis_close",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int ndis_open (struct device *dev)\n{\n  int promis = (dev->flags & IFF_PROMISC);\n\n#ifdef USE_NDIS2\n  if (!NdisInit(promis))\n     return (0);\n  return (1);\n#else\n  ARGSUSED (promis);\n  return (0);\n#endif\n}",
          "fn_code_pos": [
            [
              1190,
              0
            ],
            [
              1202,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ndis_open",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void *ndis_stats (struct device *dev)\n{\n  static struct net_device_stats stats;\n\n  /* to-do */\n  ARGSUSED (dev);\n  return (&stats);\n}",
          "fn_code_pos": [
            [
              1204,
              0
            ],
            [
              1211,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ndis_stats",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int ndis_probe (struct device *dev)\n{\n#ifdef USE_NDIS2\n  if (!NdisOpen())\n     return (0);\n#endif\n\n  dev->open           = ndis_open;\n  dev->xmit           = NULL;\n  dev->close          = ndis_close;\n  dev->get_stats      = ndis_stats;\n  dev->copy_rx_buf    = NULL;       /* to-do */\n  dev->get_rx_buf     = NULL;       /* upcall is from rmode driver */\n  dev->peek_rx_buf    = NULL;\n  dev->release_rx_buf = NULL;\n  return (0);\n}",
          "fn_code_pos": [
            [
              1213,
              0
            ],
            [
              1229,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ndis_probe",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int peek_rxbuf (BYTE **buf)\n{\n  struct rx_elem *tail, *head;\n\n  PCAP_ASSERT (pktq_check (&active_dev->queue));\n\n  DISABLE();\n  tail = pktq_out_elem (&active_dev->queue);\n  head = pktq_in_elem (&active_dev->queue);\n  ENABLE();\n\n  if (head != tail)\n  {\n    PCAP_ASSERT (tail->size < active_dev->queue.elem_size-4-2);\n\n    *buf = &tail->data[0];\n    return (tail->size);\n  }\n  *buf = NULL;\n  return (0);\n}",
          "fn_code_pos": [
            [
              1331,
              0
            ],
            [
              1351,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "peek_rxbuf",
            "parameters": {
              "buf": "BYTE"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int release_rxbuf (BYTE *buf)\n{\n#ifndef NDEBUG\n  struct rx_elem *tail = pktq_out_elem (&active_dev->queue);\n\n  PCAP_ASSERT (&tail->data[0] == buf);\n#else\n  ARGSUSED (buf);\n#endif\n  pktq_inc_out (&active_dev->queue);\n  return (1);\n}",
          "fn_code_pos": [
            [
              1356,
              0
            ],
            [
              1367,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "release_rxbuf",
            "parameters": {
              "buf": "BYTE"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "BYTE *get_rxbuf (int len)\n{\n  int idx;\n\n  if (len < ETH_MIN || len > ETH_MAX)\n     return (NULL);\n\n  idx = pktq_in_index (&active_dev->queue);\n\n#ifdef DEBUG\n  {\n    static int fan_idx LOCKED_VAR = 0;\n    writew (\"-\\\\|/\"[fan_idx++] | (15 << 8),      /* white on black colour */\n            0xB8000 + 2*79);  /* upper-right corner, 80-col colour screen */\n    fan_idx &= 3;\n  }\n/* writew (idx + '0' + 0x0F00, 0xB8000 + 2*78); */\n#endif\n\n  if (idx != active_dev->queue.out_index)\n  {\n    struct rx_elem *head = pktq_in_elem (&active_dev->queue);\n\n    head->size = len;\n    active_dev->queue.in_index = idx;\n    return (&head->data[0]);\n  }\n\n  /* !!to-do: drop 25% of the oldest element\n   */\n  pktq_clear (&active_dev->queue);\n  return (NULL);\n}",
          "fn_code_pos": [
            [
              1373,
              0
            ],
            [
              1405,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_rxbuf",
            "parameters": {
              "len": "int"
            },
            "return_type": "BYTE"
          }
        },
        {
          "fn_code": "static int pktq_check (struct rx_ringbuf *q)\n{\n#ifndef NDEBUG\n  int   i;\n  char *buf;\n#endif\n\n  if (!q || !q->num_elem || !q->buf_start)\n     return (0);\n\n#ifndef NDEBUG\n  buf = q->buf_start;\n\n  for (i = 0; i < q->num_elem; i++)\n  {\n    buf += q->elem_size;\n    if (*(DWORD*)(buf - sizeof(DWORD)) != PKTQ_MARKER)\n       return (0);\n  }\n#endif\n  return (1);\n}",
          "fn_code_pos": [
            [
              1413,
              0
            ],
            [
              1434,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pktq_check",
            "parameters": {
              "q": "struct rx_ringbuf"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pktq_init (struct rx_ringbuf *q, int size, int num, char *pool)\n{\n  int i;\n\n  q->elem_size = size;\n  q->num_elem  = num;\n  q->buf_start = pool;\n  q->in_index  = 0;\n  q->out_index = 0;\n\n  PCAP_ASSERT (size >= sizeof(struct rx_elem) + sizeof(DWORD));\n  PCAP_ASSERT (num);\n  PCAP_ASSERT (pool);\n\n  for (i = 0; i < num; i++)\n  {\n#if 0\n    struct rx_elem *elem = (struct rx_elem*) pool;\n\n    /* assert dword aligned elements\n     */\n    PCAP_ASSERT (((unsigned)(&elem->data[0]) & 3) == 0);\n#endif\n    pool += size;\n    *(DWORD*) (pool - sizeof(DWORD)) = PKTQ_MARKER;\n  }\n  return (1);\n}",
          "fn_code_pos": [
            [
              1436,
              0
            ],
            [
              1463,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pktq_init",
            "parameters": {
              "q": "struct rx_ringbuf",
              "size": "int",
              "num": "int",
              "pool": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pktq_inc_out (struct rx_ringbuf *q)\n{\n  q->out_index++;\n  if (q->out_index >= q->num_elem)\n      q->out_index = 0;\n  return (q->out_index);\n}",
          "fn_code_pos": [
            [
              1469,
              0
            ],
            [
              1475,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pktq_inc_out",
            "parameters": {
              "q": "struct rx_ringbuf"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pktq_in_index (struct rx_ringbuf *q)\n{\n  volatile int index = q->in_index + 1;\n\n  if (index >= q->num_elem)\n      index = 0;\n  return (index);\n}",
          "fn_code_pos": [
            [
              1481,
              0
            ],
            [
              1488,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pktq_in_index",
            "parameters": {
              "q": "struct rx_ringbuf"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static struct rx_elem *pktq_in_elem (struct rx_ringbuf *q)\n{\n  return (struct rx_elem*) (q->buf_start + (q->elem_size * q->in_index));\n}",
          "fn_code_pos": [
            [
              1493,
              0
            ],
            [
              1496,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pktq_in_elem",
            "parameters": {
              "q": "struct rx_ringbuf"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct rx_elem *pktq_out_elem (struct rx_ringbuf *q)\n{\n  return (struct rx_elem*) (q->buf_start + (q->elem_size * q->out_index));\n}",
          "fn_code_pos": [
            [
              1501,
              0
            ],
            [
              1504,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pktq_out_elem",
            "parameters": {
              "q": "struct rx_ringbuf"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void pktq_clear (struct rx_ringbuf *q)\n{\n  q->in_index = q->out_index;\n}",
          "fn_code_pos": [
            [
              1509,
              0
            ],
            [
              1512,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pktq_clear",
            "parameters": {
              "q": "struct rx_ringbuf"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n  return (\"DOS-\" PCAP_VERSION_STRING);\n}",
          "fn_code_pos": [
            [
              1531,
              0
            ],
            [
              1535,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "init_32bit (void)",
          "fn_dec_pos": [
            [
              57,
              14
            ],
            [
              57,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "init_32bit",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pktq_init     (struct rx_ringbuf *q, int size, int num, char *pool)",
          "fn_dec_pos": [
            [
              59,
              14
            ],
            [
              59,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pktq_init",
            "parameters": {
              "q": "struct rx_ringbuf",
              "size": "int",
              "num": "int",
              "pool": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pktq_check    (struct rx_ringbuf *q)",
          "fn_dec_pos": [
            [
              60,
              14
            ],
            [
              60,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pktq_check",
            "parameters": {
              "q": "struct rx_ringbuf"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pktq_inc_out  (struct rx_ringbuf *q)",
          "fn_dec_pos": [
            [
              61,
              14
            ],
            [
              61,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pktq_inc_out",
            "parameters": {
              "q": "struct rx_ringbuf"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pktq_in_index (struct rx_ringbuf *q)",
          "fn_dec_pos": [
            [
              62,
              14
            ],
            [
              62,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pktq_in_index",
            "parameters": {
              "q": "struct rx_ringbuf"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pktq_clear    (struct rx_ringbuf *q)",
          "fn_dec_pos": [
            [
              63,
              14
            ],
            [
              63,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pktq_clear",
            "parameters": {
              "q": "struct rx_ringbuf"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "pktq_in_elem  (struct rx_ringbuf *q)",
          "fn_dec_pos": [
            [
              65,
              25
            ],
            [
              65,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pktq_in_elem",
            "parameters": {
              "q": "struct rx_ringbuf"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pktq_out_elem (struct rx_ringbuf *q)",
          "fn_dec_pos": [
            [
              66,
              25
            ],
            [
              66,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pktq_out_elem",
            "parameters": {
              "q": "struct rx_ringbuf"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*_w32_usr_post_init) (void)",
          "fn_dec_pos": [
            [
              82,
              12
            ],
            [
              82,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*_w32_print_hook)()",
          "fn_dec_pos": [
            [
              83,
              12
            ],
            [
              83,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "dbug_write (const char *)",
          "fn_dec_pos": [
            [
              85,
              12
            ],
            [
              85,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dbug_write",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pkt_get_mtu (void)",
          "fn_dec_pos": [
            [
              86,
              12
            ],
            [
              86,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pkt_get_mtu",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_activate_dos (pcap_t *p)",
          "fn_dec_pos": [
            [
              97,
              12
            ],
            [
              97,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_activate_dos",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_read_dos (pcap_t *p, int cnt, pcap_handler callback,\n                           u_char *data)",
          "fn_dec_pos": [
            [
              98,
              12
            ],
            [
              99,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_dos",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "data": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_cleanup_dos (pcap_t *p)",
          "fn_dec_pos": [
            [
              100,
              12
            ],
            [
              100,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_cleanup_dos",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_stats_dos (pcap_t *p, struct pcap_stat *ps)",
          "fn_dec_pos": [
            [
              101,
              12
            ],
            [
              101,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_dos",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_sendpacket_dos (pcap_t *p, const void *buf, size_t len)",
          "fn_dec_pos": [
            [
              102,
              12
            ],
            [
              102,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_sendpacket_dos",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "len": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_setfilter_dos (pcap_t *p, struct bpf_program *fp)",
          "fn_dec_pos": [
            [
              103,
              12
            ],
            [
              103,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_dos",
            "parameters": {
              "p": "pcap_t",
              "fp": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ndis_probe (struct device *dev)",
          "fn_dec_pos": [
            [
              105,
              12
            ],
            [
              105,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ndis_probe",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pkt_probe  (struct device *dev)",
          "fn_dec_pos": [
            [
              106,
              12
            ],
            [
              106,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pkt_probe",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "close_driver (void)",
          "fn_dec_pos": [
            [
              108,
              12
            ],
            [
              108,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "close_driver",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "init_watt32 (struct pcap *pcap, const char *dev_name, char *err_buf)",
          "fn_dec_pos": [
            [
              109,
              12
            ],
            [
              109,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "init_watt32",
            "parameters": {
              "pcap": "struct pcap",
              "dev_name": "char",
              "err_buf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "first_init (const char *name, char *ebuf, int promisc)",
          "fn_dec_pos": [
            [
              110,
              12
            ],
            [
              110,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "first_init",
            "parameters": {
              "name": "char",
              "ebuf": "char",
              "promisc": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "watt32_recv_hook (u_char *dummy, const struct pcap_pkthdr *pcap,\n                              const u_char *buf)",
          "fn_dec_pos": [
            [
              112,
              12
            ],
            [
              113,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "watt32_recv_hook",
            "parameters": {
              "dummy": "u_char",
              "pcap": "struct pcap_pkthdr",
              "buf": "u_char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "get_device (int fd)",
          "fn_dec_pos": [
            [
              136,
              22
            ],
            [
              136,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_device",
            "parameters": {
              "fd": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*wait_proc)(void)",
          "fn_dec_pos": [
            [
              147,
              6
            ],
            [
              147,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_create_interface (const char *device _U_, char *ebuf)",
          "fn_dec_pos": [
            [
              151,
              8
            ],
            [
              151,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lookupdev (char *ebuf)",
          "fn_dec_pos": [
            [
              489,
              6
            ],
            [
              489,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lookupdev",
            "parameters": {
              "ebuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*yield)(void)",
          "fn_dec_pos": [
            [
              637,
              36
            ],
            [
              637,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "open_driver (const char *dev_name, char *ebuf, int promisc)",
          "fn_dec_pos": [
            [
              652,
              0
            ],
            [
              652,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "open_driver",
            "parameters": {
              "dev_name": "char",
              "ebuf": "char",
              "promisc": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*handler)(int)",
          "fn_dec_pos": [
            [
              756,
              32
            ],
            [
              756,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_recv_hook (WORD *type)",
          "fn_dec_pos": [
            [
              888,
              13
            ],
            [
              888,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_recv_hook",
            "parameters": {
              "type": "WORD"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*prev_post_hook) (void)",
          "fn_dec_pos": [
            [
              933,
              12
            ],
            [
              933,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pkt_stats (struct device *dev)",
          "fn_dec_pos": [
            [
              1147,
              13
            ],
            [
              1147,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pkt_stats",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ndis_stats (struct device *dev)",
          "fn_dec_pos": [
            [
              1204,
              13
            ],
            [
              1204,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ndis_stats",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "get_rxbuf (int len)",
          "fn_dec_pos": [
            [
              1373,
              6
            ],
            [
              1373,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_rxbuf",
            "parameters": {
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pktq_in_elem (struct rx_ringbuf *q)",
          "fn_dec_pos": [
            [
              1493,
              23
            ],
            [
              1493,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pktq_in_elem",
            "parameters": {
              "q": "struct rx_ringbuf"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pktq_out_elem (struct rx_ringbuf *q)",
          "fn_dec_pos": [
            [
              1501,
              23
            ],
            [
              1501,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pktq_out_elem",
            "parameters": {
              "q": "struct rx_ringbuf"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              1532,
              0
            ],
            [
              1532,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_dos {\n\tvoid (*wait_proc)(void); /* call proc while waiting */\n\tstruct pcap_stat stat;\n}",
          {
            "(*wait_proc)(void)": "void",
            "stat": "struct pcap_stat"
          },
          "pcap_dos",
          [
            146,
            0
          ],
          [
            149,
            1
          ]
        ],
        [
          "struct rx_ringbuf",
          {},
          "",
          [
            59,
            29
          ],
          [
            59,
            46
          ]
        ],
        [
          "struct rx_ringbuf",
          {},
          "",
          [
            60,
            29
          ],
          [
            60,
            46
          ]
        ],
        [
          "struct rx_ringbuf",
          {},
          "",
          [
            61,
            29
          ],
          [
            61,
            46
          ]
        ],
        [
          "struct rx_ringbuf",
          {},
          "",
          [
            62,
            29
          ],
          [
            62,
            46
          ]
        ],
        [
          "struct rx_ringbuf",
          {},
          "",
          [
            63,
            29
          ],
          [
            63,
            46
          ]
        ],
        [
          "struct rx_elem",
          {},
          "",
          [
            65,
            9
          ],
          [
            65,
            23
          ]
        ],
        [
          "struct rx_ringbuf",
          {},
          "",
          [
            65,
            40
          ],
          [
            65,
            57
          ]
        ],
        [
          "struct rx_elem",
          {},
          "",
          [
            66,
            9
          ],
          [
            66,
            23
          ]
        ],
        [
          "struct rx_ringbuf",
          {},
          "",
          [
            66,
            40
          ],
          [
            66,
            57
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            95,
            7
          ],
          [
            95,
            20
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            101,
            39
          ],
          [
            101,
            55
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            103,
            43
          ],
          [
            103,
            61
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            105,
            24
          ],
          [
            105,
            37
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            106,
            24
          ],
          [
            106,
            37
          ]
        ],
        [
          "struct pcap",
          {},
          "",
          [
            109,
            25
          ],
          [
            109,
            36
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            112,
            51
          ],
          [
            112,
            69
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            118,
            7
          ],
          [
            118,
            20
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            127,
            7
          ],
          [
            127,
            20
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            136,
            7
          ],
          [
            136,
            20
          ]
        ],
        [
          "struct pcap_dos {\n\tvoid (*wait_proc)(void); /* call proc while waiting */\n\tstruct pcap_stat stat;\n}",
          {
            "(*wait_proc)(void)": "void",
            "stat": "struct pcap_stat"
          },
          "pcap_dos",
          [
            146,
            0
          ],
          [
            149,
            1
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            148,
            1
          ],
          [
            148,
            17
          ]
        ],
        [
          "struct pcap_dos",
          {},
          "",
          [
            155,
            38
          ],
          [
            155,
            53
          ]
        ],
        [
          "struct pcap_dos",
          {},
          "",
          [
            234,
            2
          ],
          [
            234,
            17
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            235,
            2
          ],
          [
            235,
            20
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            236,
            2
          ],
          [
            236,
            16
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            253,
            13
          ],
          [
            253,
            26
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            374,
            38
          ],
          [
            374,
            54
          ]
        ],
        [
          "struct net_device_stats",
          {},
          "",
          [
            376,
            2
          ],
          [
            376,
            25
          ]
        ],
        [
          "struct pcap_dos",
          {},
          "",
          [
            377,
            2
          ],
          [
            377,
            17
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            378,
            2
          ],
          [
            378,
            15
          ]
        ],
        [
          "struct pcap_stat_ex",
          {},
          "",
          [
            409,
            30
          ],
          [
            409,
            49
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            411,
            2
          ],
          [
            411,
            15
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            435,
            42
          ],
          [
            435,
            60
          ]
        ],
        [
          "struct pcap_dos",
          {},
          "",
          [
            464,
            2
          ],
          [
            464,
            17
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            491,
            2
          ],
          [
            491,
            15
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            497,
            14
          ],
          [
            497,
            27
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            504,
            20
          ],
          [
            504,
            33
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            559,
            2
          ],
          [
            559,
            15
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            562,
            2
          ],
          [
            562,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            563,
            2
          ],
          [
            563,
            17
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            568,
            14
          ],
          [
            568,
            27
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            598,
            17
          ],
          [
            598,
            32
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            599,
            17
          ],
          [
            599,
            32
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            600,
            17
          ],
          [
            600,
            32
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            601,
            17
          ],
          [
            601,
            32
          ]
        ],
        [
          "struct pcap_dos",
          {},
          "",
          [
            641,
            4
          ],
          [
            641,
            19
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            651,
            7
          ],
          [
            651,
            20
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            654,
            2
          ],
          [
            654,
            15
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            656,
            14
          ],
          [
            656,
            27
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            733,
            2
          ],
          [
            733,
            15
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            800,
            2
          ],
          [
            800,
            15
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            872,
            51
          ],
          [
            872,
            69
          ]
        ],
        [
          "struct ether_header",
          {},
          "",
          [
            876,
            2
          ],
          [
            876,
            21
          ]
        ],
        [
          "struct ether_header",
          {},
          "",
          [
            876,
            29
          ],
          [
            876,
            48
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            922,
            2
          ],
          [
            922,
            15
          ]
        ],
        [
          "struct pcap",
          {},
          "",
          [
            955,
            24
          ],
          [
            955,
            35
          ]
        ],
        [
          "struct config_table",
          {},
          "",
          [
            1047,
            13
          ],
          [
            1047,
            32
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1095,
            0
          ],
          [
            1095,
            13
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1096,
            0
          ],
          [
            1096,
            13
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1097,
            6
          ],
          [
            1097,
            19
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1104,
            23
          ],
          [
            1104,
            36
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1116,
            21
          ],
          [
            1116,
            34
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1132,
            21
          ],
          [
            1132,
            34
          ]
        ],
        [
          "struct net_device_stats",
          {},
          "",
          [
            1134,
            2
          ],
          [
            1134,
            25
          ]
        ],
        [
          "struct net_device_stats",
          {},
          "",
          [
            1134,
            36
          ],
          [
            1134,
            59
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1147,
            24
          ],
          [
            1147,
            37
          ]
        ],
        [
          "struct net_device_stats",
          {},
          "",
          [
            1149,
            2
          ],
          [
            1149,
            25
          ]
        ],
        [
          "struct net_device_stats",
          {},
          "",
          [
            1149,
            36
          ],
          [
            1149,
            59
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1160,
            22
          ],
          [
            1160,
            35
          ]
        ],
        [
          "struct net_device_stats",
          {},
          "",
          [
            1173,
            39
          ],
          [
            1173,
            62
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1182,
            24
          ],
          [
            1182,
            37
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1190,
            22
          ],
          [
            1190,
            35
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1204,
            25
          ],
          [
            1204,
            38
          ]
        ],
        [
          "struct net_device_stats",
          {},
          "",
          [
            1206,
            9
          ],
          [
            1206,
            32
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1213,
            23
          ],
          [
            1213,
            36
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1236,
            0
          ],
          [
            1236,
            13
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1245,
            0
          ],
          [
            1245,
            13
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1254,
            0
          ],
          [
            1254,
            13
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1263,
            0
          ],
          [
            1263,
            13
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1272,
            0
          ],
          [
            1272,
            13
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1281,
            0
          ],
          [
            1281,
            13
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1290,
            0
          ],
          [
            1290,
            13
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1299,
            0
          ],
          [
            1299,
            13
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1308,
            0
          ],
          [
            1308,
            13
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            1317,
            0
          ],
          [
            1317,
            13
          ]
        ],
        [
          "struct rx_elem",
          {},
          "",
          [
            1333,
            2
          ],
          [
            1333,
            16
          ]
        ],
        [
          "struct rx_elem",
          {},
          "",
          [
            1359,
            2
          ],
          [
            1359,
            16
          ]
        ],
        [
          "struct rx_elem",
          {},
          "",
          [
            1394,
            4
          ],
          [
            1394,
            18
          ]
        ],
        [
          "struct rx_ringbuf",
          {},
          "",
          [
            1413,
            23
          ],
          [
            1413,
            40
          ]
        ],
        [
          "struct rx_ringbuf",
          {},
          "",
          [
            1436,
            22
          ],
          [
            1436,
            39
          ]
        ],
        [
          "struct rx_elem",
          {},
          "",
          [
            1446,
            30
          ],
          [
            1446,
            44
          ]
        ],
        [
          "struct rx_elem",
          {},
          "",
          [
            1453,
            4
          ],
          [
            1453,
            18
          ]
        ],
        [
          "struct rx_elem",
          {},
          "",
          [
            1453,
            28
          ],
          [
            1453,
            42
          ]
        ],
        [
          "struct rx_ringbuf",
          {},
          "",
          [
            1469,
            25
          ],
          [
            1469,
            42
          ]
        ],
        [
          "struct rx_ringbuf",
          {},
          "",
          [
            1481,
            26
          ],
          [
            1481,
            43
          ]
        ],
        [
          "struct rx_elem",
          {},
          "",
          [
            1493,
            7
          ],
          [
            1493,
            21
          ]
        ],
        [
          "struct rx_ringbuf",
          {},
          "",
          [
            1493,
            37
          ],
          [
            1493,
            54
          ]
        ],
        [
          "struct rx_elem",
          {},
          "",
          [
            1495,
            10
          ],
          [
            1495,
            24
          ]
        ],
        [
          "struct rx_elem",
          {},
          "",
          [
            1501,
            7
          ],
          [
            1501,
            21
          ]
        ],
        [
          "struct rx_ringbuf",
          {},
          "",
          [
            1501,
            38
          ],
          [
            1501,
            55
          ]
        ],
        [
          "struct rx_elem",
          {},
          "",
          [
            1503,
            10
          ],
          [
            1503,
            24
          ]
        ],
        [
          "struct rx_ringbuf",
          {},
          "",
          [
            1509,
            24
          ],
          [
            1509,
            41
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            8,
            0
          ],
          [
            9,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <signal.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <float.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <io.h>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/pmdrvr.h\"\n",
          [
            17,
            2
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/pci.h\"\n",
          [
            18,
            2
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/bios32.h\"\n",
          [
            19,
            2
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/module.h\"\n",
          [
            20,
            2
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/3c501.h\"\n",
          [
            21,
            2
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/3c503.h\"\n",
          [
            22,
            2
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/3c509.h\"\n",
          [
            23,
            2
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/3c59x.h\"\n",
          [
            24,
            2
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/3c515.h\"\n",
          [
            25,
            2
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/3c90x.h\"\n",
          [
            26,
            2
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/3c575_cb.h\"\n",
          [
            27,
            2
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/ne.h\"\n",
          [
            28,
            2
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/wd.h\"\n",
          [
            29,
            2
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/accton.h\"\n",
          [
            30,
            2
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/cs89x0.h\"\n",
          [
            31,
            2
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/rtl8139.h\"\n",
          [
            32,
            2
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/ne2k-pci.h\"\n",
          [
            33,
            2
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"pcap.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"pcap-dos.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include \"msdos/pktdrvr.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include \"msdos/ndis2.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <arpa/inet.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <net/if.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <net/if_arp.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <net/if_ether.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <net/if_packe.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <tcp.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/ioport.h\"\n",
          [
            1523,
            0
          ],
          [
            1524,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/dma.h\"\n",
          [
            1524,
            0
          ],
          [
            1525,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-snf.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nsnf_set_datalink(pcap_t *p, int dlt)\n{\n\tp->linktype = dlt;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              47,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "snf_set_datalink",
            "parameters": {
              "p": "pcap_t",
              "dlt": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nsnf_pcap_stats(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct snf_ring_stats stats;\n\tstruct pcap_snf *snfps = p->priv;\n\tint rc;\n\n\tif ((rc = snf_ring_getstats(snfps->snf_ring, &stats))) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    rc, \"snf_get_stats\");\n\t\treturn -1;\n\t}\n\tps->ps_recv = stats.ring_pkt_recv + stats.ring_pkt_overflow;\n\tps->ps_drop = stats.ring_pkt_overflow;\n\tps->ps_ifdrop = stats.nic_pkt_overflow + stats.nic_pkt_bad;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "snf_pcap_stats",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nsnf_platform_cleanup(pcap_t *p)\n{\n\tstruct pcap_snf *ps = p->priv;\n\n#ifdef SNF_HAVE_INJECT_API\n\tif (ps->snf_inj)\n\t\tsnf_inject_close(ps->snf_inj);\n#endif\n\tsnf_ring_close(ps->snf_ring);\n\tsnf_close(ps->snf_handle);\n\tpcap_cleanup_live_common(p);\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "snf_platform_cleanup",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nsnf_getnonblock(pcap_t *p)\n{\n\tstruct pcap_snf *ps = p->priv;\n\n\treturn (ps->snf_timeout == 0);\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "snf_getnonblock",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nsnf_setnonblock(pcap_t *p, int nonblock)\n{\n\tstruct pcap_snf *ps = p->priv;\n\n\tif (nonblock)\n\t\tps->snf_timeout = 0;\n\telse {\n\t\tif (p->opt.timeout <= 0)\n\t\t\tps->snf_timeout = -1; /* forever */\n\t\telse\n\t\t\tps->snf_timeout = p->opt.timeout;\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              103,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "snf_setnonblock",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static inline\nstruct timeval\nsnf_timestamp_to_timeval(const int64_t ts_nanosec, const int tstamp_precision)\n{\n\tstruct timeval tv;\n\tlong tv_nsec;\n        const static struct timeval zero_timeval;\n\n        if (ts_nanosec == 0)\n                return zero_timeval;\n\n\ttv.tv_sec = ts_nanosec / _NSEC_PER_SEC;\n\ttv_nsec = (ts_nanosec % _NSEC_PER_SEC);\n\n\t/* libpcap expects tv_usec to be nanos if using nanosecond precision. */\n\tif (tstamp_precision == PCAP_TSTAMP_PRECISION_NANO)\n\t\ttv.tv_usec = tv_nsec;\n\telse\n\t\ttv.tv_usec = tv_nsec / 1000;\n\n\treturn tv;\n}",
          "fn_code_pos": [
            [
              107,
              0
            ],
            [
              128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "snf_timestamp_to_timeval",
            "parameters": {
              "ts_nanosec": "int64_t",
              "tstamp_precision": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static int\nsnf_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_snf *ps = p->priv;\n\tstruct pcap_pkthdr hdr;\n\tint i, flags, err, caplen, n;\n\tstruct snf_recv_req req;\n\tint nonblock, timeout;\n\n\tif (!p)\n\t\treturn -1;\n\n\tn = 0;\n\ttimeout = ps->snf_timeout;\n\twhile (n < cnt || PACKET_COUNT_IS_UNLIMITED(cnt)) {\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\tif (n == 0) {\n\t\t\t\tp->break_loop = 0;\n\t\t\t\treturn (-2);\n\t\t\t} else {\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t}\n\n\t\terr = snf_ring_recv(ps->snf_ring, timeout, &req);\n\n\t\tif (err) {\n\t\t\tif (err == EBUSY || err == EAGAIN) {\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t\telse if (err == EINTR) {\n\t\t\t\ttimeout = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, err, \"snf_read\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tcaplen = req.length;\n\t\tif (caplen > p->snapshot)\n\t\t\tcaplen = p->snapshot;\n\n\t\tif ((p->fcode.bf_insns == NULL) ||\n\t\t     pcap_filter(p->fcode.bf_insns, req.pkt_addr, req.length, caplen)) {\n\t\t\thdr.ts = snf_timestamp_to_timeval(req.timestamp, p->opt.tstamp_precision);\n\t\t\thdr.caplen = caplen;\n\t\t\thdr.len = req.length;\n\t\t\tcallback(user, &hdr, req.pkt_addr);\n\t\t\tn++;\n\t\t}\n\n\t\t/* After one successful packet is received, we won't block\n\t\t* again for that timeout. */\n\t\tif (timeout != 0)\n\t\t\ttimeout = 0;\n\t}\n\treturn (n);\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              193,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "snf_read",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nsnf_inject(pcap_t *p, const void *buf _U_, int size _U_)\n{\n#ifdef SNF_HAVE_INJECT_API\n\tstruct pcap_snf *ps = p->priv;\n\tint rc;\n\tif (ps->snf_inj == NULL) {\n\t\trc = snf_inject_open(ps->snf_boardnum, 0, &ps->snf_inj);\n\t\tif (rc) {\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    rc, \"snf_inject_open\");\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\trc = snf_inject_send(ps->snf_inj, -1, 0, buf, size);\n\tif (!rc) {\n\t\treturn (size);\n\t}\n\telse {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    rc, \"snf_inject_send\");\n\t\treturn (-1);\n\t}\n#else\n\tpcap_strlcpy(p->errbuf, \"Sending packets isn't supported with this snf version\",\n\t    PCAP_ERRBUF_SIZE);\n\treturn (-1);\n#endif\n}",
          "fn_code_pos": [
            [
              195,
              0
            ],
            [
              224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "snf_inject",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nsnf_activate(pcap_t* p)\n{\n\tstruct pcap_snf *ps = p->priv;\n\tchar *device = p->opt.device;\n\tconst char *nr = NULL;\n\tint err;\n\tint flags = -1, ring_id = -1;\n\n\tif (device == NULL) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"device is NULL\");\n\t\treturn -1;\n\t}\n\n\t/* In Libpcap, we set pshared by default if NUM_RINGS is set to > 1.\n\t * Since libpcap isn't thread-safe */\n\tif ((nr = getenv(\"SNF_FLAGS\")) && *nr)\n\t\tflags = strtol(nr, NULL, 0);\n\telse if ((nr = getenv(\"SNF_NUM_RINGS\")) && *nr && atoi(nr) > 1)\n\t\tflags = SNF_F_PSHARED;\n\telse\n\t\tnr = NULL;\n\n\n        /* Allow pcap_set_buffer_size() to set dataring_size.\n         * Default is zero which allows setting from env SNF_DATARING_SIZE.\n         * pcap_set_buffer_size() is in bytes while snf_open() accepts values\n         * between 0 and 1048576 in Megabytes. Values in this range are\n         * mapped to 1MB.\n         */\n\terr = snf_open(ps->snf_boardnum,\n\t\t\t0, /* let SNF API parse SNF_NUM_RINGS, if set */\n\t\t\tNULL, /* default RSS, or use SNF_RSS_FLAGS env */\n                        (p->opt.buffer_size > 0 && p->opt.buffer_size < 1048576) ? 1048576 : p->opt.buffer_size, /* default to SNF_DATARING_SIZE from env */\n\t\t\tflags, /* may want pshared */\n\t\t\t&ps->snf_handle);\n\tif (err != 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    err, \"snf_open failed\");\n\t\treturn -1;\n\t}\n\n\tif ((nr = getenv(\"SNF_PCAP_RING_ID\")) && *nr) {\n\t\tring_id = (int) strtol(nr, NULL, 0);\n\t}\n\terr = snf_ring_open_id(ps->snf_handle, ring_id, &ps->snf_ring);\n\tif (err != 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    err, \"snf_ring_open_id(ring=%d) failed\", ring_id);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n\tif (p->opt.timeout <= 0)\n\t\tps->snf_timeout = -1;\n\telse\n\t\tps->snf_timeout = p->opt.timeout;\n\n\terr = snf_start(ps->snf_handle);\n\tif (err != 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    err, \"snf_start failed\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * \"select()\" and \"poll()\" don't work on snf descriptors.\n\t */\n#ifndef _WIN32\n\tp->selectable_fd = -1;\n#endif /* !_WIN32 */\n\tp->linktype = DLT_EN10MB;\n\tp->read_op = snf_read;\n\tp->inject_op = snf_inject;\n\tp->setfilter_op = install_bpf_program;\n\tp->setdirection_op = NULL; /* Not implemented.*/\n\tp->set_datalink_op = snf_set_datalink;\n\tp->getnonblock_op = snf_getnonblock;\n\tp->setnonblock_op = snf_setnonblock;\n\tp->stats_op = snf_pcap_stats;\n\tp->cleanup_op = snf_platform_cleanup;\n#ifdef SNF_HAVE_INJECT_API\n\tps->snf_inj = NULL;\n#endif\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              226,
              0
            ],
            [
              321,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "snf_activate",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nsnf_findalldevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\tpcap_if_t *dev;\n#ifdef _WIN32\n\tstruct sockaddr_in addr;\n#endif\n\tstruct snf_ifaddrs *ifaddrs, *ifa;\n\tchar name[MAX_DESC_LENGTH];\n\tchar desc[MAX_DESC_LENGTH];\n\tint ret, allports = 0, merge = 0;\n\tconst char *nr = NULL;\n\n\tif (snf_init(SNF_VERSION_API)) {\n\t\t(void)pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"snf_getifaddrs: snf_init failed\");\n\t\treturn (-1);\n\t}\n\n\tif (snf_getifaddrs(&ifaddrs) || ifaddrs == NULL)\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"snf_getifaddrs\");\n\t\treturn (-1);\n\t}\n\tif ((nr = getenv(\"SNF_FLAGS\")) && *nr) {\n\t\terrno = 0;\n\t\tmerge = strtol(nr, NULL, 0);\n\t\tif (errno) {\n\t\t\t(void)pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\"snf_getifaddrs: SNF_FLAGS is not a valid number\");\n\t\t\treturn (-1);\n\t\t}\n\t\tmerge = merge & SNF_F_AGGREGATE_PORTMASK;\n\t}\n\n\tfor (ifa = ifaddrs; ifa != NULL; ifa = ifa->snf_ifa_next) {\n\t\t/*\n\t\t * Myricom SNF adapter ports may appear as regular\n\t\t * network interfaces, which would already have been\n\t\t * added to the list of adapters by pcap_platform_finddevs()\n\t\t * if this isn't an SNF-only version of libpcap.\n\t\t *\n\t\t * Our create routine intercepts pcap_create() calls for\n\t\t * those interfaces and arranges that they will be\n\t\t * opened using the SNF API instead.\n\t\t *\n\t\t * So if we already have an entry for the device, we\n\t\t * don't add an additional entry for it, we just\n\t\t * update the description for it, if any, to indicate\n\t\t * which snfN device it is.  Otherwise, we add an entry\n\t\t * for it.\n\t\t *\n\t\t * In either case, if SNF_F_AGGREGATE_PORTMASK is set\n\t\t * in SNF_FLAGS, we add this port to the bitmask\n\t\t * of ports, which we use to generate a device\n\t\t * we can use to capture on all ports.\n\t\t *\n\t\t * Generate the description string.  If port aggregation\n\t\t * is set, use 2^{port number} as the unit number,\n\t\t * rather than {port number}.\n\t\t *\n\t\t * XXX - do entries in this list have IP addresses for\n\t\t * the port?  If so, should we add them to the\n\t\t * entry for the device, if they're not already in the\n\t\t * list of IP addresses for the device?\n \t\t */\n\t\t(void)pcap_snprintf(desc,MAX_DESC_LENGTH,\"Myricom %ssnf%d\",\n\t\t\tmerge ? \"Merge Bitmask Port \" : \"\",\n\t\t\tmerge ? 1 << ifa->snf_ifa_portnum : ifa->snf_ifa_portnum);\n\t\t/*\n\t\t * Add the port to the bitmask.\n\t\t */\n\t\tif (merge)\n\t\t\tallports |= 1 << ifa->snf_ifa_portnum;\n\t\t/*\n\t\t * See if there's already an entry for the device\n\t\t * with the name ifa->snf_ifa_name.\n\t\t */\n\t\tdev = find_dev(devlistp, ifa->snf_ifa_name);\n\t\tif (dev != NULL) {\n\t\t\t/*\n\t\t\t * Yes.  Update its description.\n\t\t\t */\n\t\t\tchar *desc_str;\n\n\t\t\tdesc_str = strdup(desc);\n\t\t\tif (desc_str == NULL) {\n\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"snf_findalldevs strdup\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfree(dev->description);\n\t\t\tdev->description = desc_str;\n\t\t} else {\n\t\t\t/*\n\t\t\t * No.  Add an entry for it.\n\t\t\t *\n\t\t\t * XXX - is there a notion of \"up\" or \"running\",\n\t\t\t * and can we determine whether something's\n\t\t\t * plugged into the adapter and set\n\t\t\t * PCAP_IF_CONNECTION_STATUS_CONNECTED or\n\t\t\t * PCAP_IF_CONNECTION_STATUS_DISCONNECTED?\n\t\t\t */\n\t\t\tdev = add_dev(devlistp, ifa->snf_ifa_name, 0, desc,\n\t\t\t    errbuf);\n\t\t\tif (dev == NULL)\n\t\t\t\treturn -1;\n#ifdef _WIN32\n\t\t\t/*\n\t\t\t * On Windows, fill in IP# from device name\n\t\t\t */\n                        ret = inet_pton(AF_INET, dev->name, &addr.sin_addr);\n                        if (ret == 1) {\n                        \t/*\n                        \t * Successful conversion of device name\n                        \t * to IPv4 address.\n                        \t */\n\t                        addr.sin_family = AF_INET;\n        \t                if (add_addr_to_dev(dev, &addr, sizeof(addr),\n                \t            NULL, 0, NULL, 0, NULL, 0, errbuf) == -1)\n                        \t\treturn -1;\n                        } else if (ret == -1) {\n\t\t\t\t/*\n\t\t\t\t * Error.\n\t\t\t\t */\n\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"sinf_findalldevs inet_pton\");\n                                return -1;\n                        }\n#endif _WIN32\n\t\t}\n\t}\n\tsnf_freeifaddrs(ifaddrs);\n\t/*\n\t * Create a snfX entry if port aggregation is enabled\n       \t */\n\tif (merge) {\n\t\t/*\n\t\t * Add a new entry with all ports bitmask\n\t\t */\n\t\t(void)pcap_snprintf(name,MAX_DESC_LENGTH,\"snf%d\",allports);\n\t\t(void)pcap_snprintf(desc,MAX_DESC_LENGTH,\"Myricom Merge Bitmask All Ports snf%d\",\n\t\t\tallports);\n\t\t/*\n\t\t * XXX - is there any notion of \"up\" and \"running\" that\n\t\t * would apply to this device, given that it handles\n\t\t * multiple ports?\n\t\t *\n\t\t * Presumably, there's no notion of \"connected\" vs.\n\t\t * \"disconnected\", as \"is this plugged into a network?\"\n\t\t * would be a per-port property.\n\t\t */\n\t\tif (add_dev(devlistp, name,\n\t\t    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE, desc,\n\t\t    errbuf) == NULL)\n\t\t\treturn (-1);\n\t\t/*\n\t\t * XXX - should we give it a list of addresses with all\n\t\t * the addresses for all the ports?\n\t\t */\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              324,
              0
            ],
            [
              490,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "snf_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\nsnf_create(const char *device, char *ebuf, int *is_ours)\n{\n\tpcap_t *p;\n\tint boardnum = -1;\n\tstruct snf_ifaddrs *ifaddrs, *ifa;\n\tsize_t devlen;\n\tstruct pcap_snf *ps;\n\n\tif (snf_init(SNF_VERSION_API)) {\n\t\t/* Can't initialize the API, so no SNF devices */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Match a given interface name to our list of interface names, from\n\t * which we can obtain the intended board number\n\t */\n\tif (snf_getifaddrs(&ifaddrs) || ifaddrs == NULL) {\n\t\t/* Can't get SNF addresses */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\tdevlen = strlen(device) + 1;\n\tifa = ifaddrs;\n\twhile (ifa) {\n\t\tif (strncmp(device, ifa->snf_ifa_name, devlen) == 0) {\n\t\t\tboardnum = ifa->snf_ifa_boardnum;\n\t\t\tbreak;\n\t\t}\n\t\tifa = ifa->snf_ifa_next;\n\t}\n\tsnf_freeifaddrs(ifaddrs);\n\n\tif (ifa == NULL) {\n\t\t/*\n\t\t * If we can't find the device by name, support the name \"snfX\"\n\t\t * and \"snf10gX\" where X is the board number.\n\t\t */\n\t\tif (sscanf(device, \"snf10g%d\", &boardnum) != 1 &&\n\t\t    sscanf(device, \"snf%d\", &boardnum) != 1) {\n\t\t\t/* Nope, not a supported name */\n\t\t\t*is_ours = 0;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* OK, it's probably ours. */\n\t*is_ours = 1;\n\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_snf));\n\tif (p == NULL)\n\t\treturn NULL;\n\tps = p->priv;\n\n\t/*\n\t * We support microsecond and nanosecond time stamps.\n\t */\n\tp->tstamp_precision_count = 2;\n\tp->tstamp_precision_list = malloc(2 * sizeof(u_int));\n\tif (p->tstamp_precision_list == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno,\n\t\t    \"malloc\");\n\t\tpcap_close(p);\n\t\treturn NULL;\n\t}\n\tp->tstamp_precision_list[0] = PCAP_TSTAMP_PRECISION_MICRO;\n\tp->tstamp_precision_list[1] = PCAP_TSTAMP_PRECISION_NANO;\n\n\tp->activate_op = snf_activate;\n\tps->snf_boardnum = boardnum;\n\treturn p;\n}",
          "fn_code_pos": [
            [
              492,
              0
            ],
            [
              565,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "snf_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "int\npcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              576,
              0
            ],
            [
              580,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_platform_finddevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_create_interface(const char *device, char *errbuf)\n{\n\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t    \"This version of libpcap only supports SNF cards\");\n\treturn NULL;\n}",
          "fn_code_pos": [
            [
              585,
              0
            ],
            [
              591,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "errbuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING \" (SNF-only)\");\n}",
          "fn_code_pos": [
            [
              596,
              0
            ],
            [
              600,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "snf_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              493,
              0
            ],
            [
              493,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "snf_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_create_interface(const char *device, char *errbuf)",
          "fn_dec_pos": [
            [
              586,
              0
            ],
            [
              586,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              597,
              0
            ],
            [
              597,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_snf {\n\tsnf_handle_t snf_handle; /* opaque device handle */\n\tsnf_ring_t   snf_ring;   /* opaque device ring handle */\n#ifdef SNF_HAVE_INJECT_API\n\tsnf_inject_t snf_inj;    /* inject handle, if inject is used */\n#endif\n\tint          snf_timeout;\n\tint          snf_boardnum;\n}",
          {
            "snf_handle": "snf_handle_t",
            "snf_ring": "snf_ring_t",
            "snf_inj": "snf_inject_t",
            "snf_timeout": "int",
            "snf_boardnum": "int"
          },
          "pcap_snf",
          [
            32,
            0
          ],
          [
            40,
            1
          ]
        ],
        [
          "struct pcap_snf {\n\tsnf_handle_t snf_handle; /* opaque device handle */\n\tsnf_ring_t   snf_ring;   /* opaque device ring handle */\n#ifdef SNF_HAVE_INJECT_API\n\tsnf_inject_t snf_inj;    /* inject handle, if inject is used */\n#endif\n\tint          snf_timeout;\n\tint          snf_boardnum;\n}",
          {
            "snf_handle": "snf_handle_t",
            "snf_ring": "snf_ring_t",
            "snf_inj": "snf_inject_t",
            "snf_timeout": "int",
            "snf_boardnum": "int"
          },
          "pcap_snf",
          [
            32,
            0
          ],
          [
            40,
            1
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            50,
            26
          ],
          [
            50,
            42
          ]
        ],
        [
          "struct snf_ring_stats",
          {},
          "",
          [
            52,
            1
          ],
          [
            52,
            22
          ]
        ],
        [
          "struct pcap_snf",
          {},
          "",
          [
            53,
            1
          ],
          [
            53,
            16
          ]
        ],
        [
          "struct pcap_snf",
          {},
          "",
          [
            70,
            1
          ],
          [
            70,
            16
          ]
        ],
        [
          "struct pcap_snf",
          {},
          "",
          [
            84,
            1
          ],
          [
            84,
            16
          ]
        ],
        [
          "struct pcap_snf",
          {},
          "",
          [
            92,
            1
          ],
          [
            92,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            108,
            0
          ],
          [
            108,
            14
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            111,
            1
          ],
          [
            111,
            15
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            113,
            21
          ],
          [
            113,
            35
          ]
        ],
        [
          "struct pcap_snf",
          {},
          "",
          [
            133,
            1
          ],
          [
            133,
            16
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            134,
            1
          ],
          [
            134,
            19
          ]
        ],
        [
          "struct snf_recv_req",
          {},
          "",
          [
            136,
            1
          ],
          [
            136,
            20
          ]
        ],
        [
          "struct pcap_snf",
          {},
          "",
          [
            199,
            1
          ],
          [
            199,
            16
          ]
        ],
        [
          "struct pcap_snf",
          {},
          "",
          [
            229,
            1
          ],
          [
            229,
            16
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            329,
            1
          ],
          [
            329,
            19
          ]
        ],
        [
          "struct snf_ifaddrs",
          {},
          "",
          [
            331,
            1
          ],
          [
            331,
            19
          ]
        ],
        [
          "struct snf_ifaddrs",
          {},
          "",
          [
            497,
            1
          ],
          [
            497,
            19
          ]
        ],
        [
          "struct pcap_snf",
          {},
          "",
          [
            499,
            1
          ],
          [
            499,
            16
          ]
        ],
        [
          "struct pcap_snf",
          {},
          "",
          [
            543,
            38
          ],
          [
            543,
            53
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include <sys/param.h>\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            8,
            0
          ],
          [
            9,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include <sys/mman.h>\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include <snf.h>\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"pcap-snf.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/fad-gifc.c": {
      "fn_def_list": [
        {
          "fn_code": "int\npcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,\n    int (*check_usable)(const char *), get_if_flags_func get_flags_func)\n{\n\tregister int fd;\n\tregister struct ifreq *ifrp, *ifend, *ifnext;\n\tsize_t n;\n\tstruct ifconf ifc;\n\tchar *buf = NULL;\n\tunsigned buf_size;\n#if defined (HAVE_SOLARIS) || defined (HAVE_HPUX10_20_OR_LATER)\n\tchar *p, *q;\n#endif\n\tstruct ifreq ifrflags, ifrnetmask, ifrbroadaddr, ifrdstaddr;\n\tstruct sockaddr *netmask, *broadaddr, *dstaddr;\n\tsize_t netmask_size, broadaddr_size, dstaddr_size;\n\tint ret = 0;\n\n\t/*\n\t * Create a socket from which to fetch the list of interfaces.\n\t */\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd < 0) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"socket\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Start with an 8K buffer, and keep growing the buffer until\n\t * we have more than \"sizeof(ifrp->ifr_name) + MAX_SA_LEN\"\n\t * bytes left over in the buffer or we fail to get the\n\t * interface list for some reason other than EINVAL (which is\n\t * presumed here to mean \"buffer is too small\").\n\t */\n\tbuf_size = 8192;\n\tfor (;;) {\n\t\t/*\n\t\t * Don't let the buffer size get bigger than INT_MAX.\n\t\t */\n\t\tif (buf_size > INT_MAX) {\n\t\t\t(void)pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"interface information requires more than %u bytes\",\n\t\t\t    INT_MAX);\n\t\t\t(void)close(fd);\n\t\t\treturn (-1);\n\t\t}\n\t\tbuf = malloc(buf_size);\n\t\tif (buf == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\t(void)close(fd);\n\t\t\treturn (-1);\n\t\t}\n\n\t\tifc.ifc_len = buf_size;\n\t\tifc.ifc_buf = buf;\n\t\tmemset(buf, 0, buf_size);\n\t\tif (ioctl(fd, SIOCGIFCONF, (char *)&ifc) < 0\n\t\t    && errno != EINVAL) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"SIOCGIFCONF\");\n\t\t\t(void)close(fd);\n\t\t\tfree(buf);\n\t\t\treturn (-1);\n\t\t}\n\t\tif (ifc.ifc_len < (int)buf_size &&\n\t\t    (buf_size - ifc.ifc_len) > sizeof(ifrp->ifr_name) + MAX_SA_LEN)\n\t\t\tbreak;\n\t\tfree(buf);\n\t\tbuf_size *= 2;\n\t}\n\n\tifrp = (struct ifreq *)buf;\n\tifend = (struct ifreq *)(buf + ifc.ifc_len);\n\n\tfor (; ifrp < ifend; ifrp = ifnext) {\n\t\t/*\n\t\t * XXX - what if this isn't an IPv4 address?  Can\n\t\t * we still get the netmask, etc. with ioctls on\n\t\t * an IPv4 socket?\n\t\t *\n\t\t * The answer is probably platform-dependent, and\n\t\t * if the answer is \"no\" on more than one platform,\n\t\t * the way you work around it is probably platform-\n\t\t * dependent as well.\n\t\t */\n\t\tn = SA_LEN(&ifrp->ifr_addr) + sizeof(ifrp->ifr_name);\n\t\tif (n < sizeof(*ifrp))\n\t\t\tifnext = ifrp + 1;\n\t\telse\n\t\t\tifnext = (struct ifreq *)((char *)ifrp + n);\n\n\t\t/*\n\t\t * XXX - The 32-bit compatibility layer for Linux on IA-64\n\t\t * is slightly broken. It correctly converts the structures\n\t\t * to and from kernel land from 64 bit to 32 bit but\n\t\t * doesn't update ifc.ifc_len, leaving it larger than the\n\t\t * amount really used. This means we read off the end\n\t\t * of the buffer and encounter an interface with an\n\t\t * \"empty\" name. Since this is highly unlikely to ever\n\t\t * occur in a valid case we can just finish looking for\n\t\t * interfaces if we see an empty name.\n\t\t */\n\t\tif (!(*ifrp->ifr_name))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Skip entries that begin with \"dummy\".\n\t\t * XXX - what are these?  Is this Linux-specific?\n\t\t * Are there platforms on which we shouldn't do this?\n\t\t */\n\t\tif (strncmp(ifrp->ifr_name, \"dummy\", 5) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Can we capture on this device?\n\t\t */\n\t\tif (!(*check_usable)(ifrp->ifr_name)) {\n\t\t\t/*\n\t\t\t * No.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Get the flags for this interface.\n\t\t */\n\t\tstrncpy(ifrflags.ifr_name, ifrp->ifr_name,\n\t\t    sizeof(ifrflags.ifr_name));\n\t\tif (ioctl(fd, SIOCGIFFLAGS, (char *)&ifrflags) < 0) {\n\t\t\tif (errno == ENXIO)\n\t\t\t\tcontinue;\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"SIOCGIFFLAGS: %.*s\",\n\t\t\t    (int)sizeof(ifrflags.ifr_name),\n\t\t\t    ifrflags.ifr_name);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Get the netmask for this address on this interface.\n\t\t */\n\t\tstrncpy(ifrnetmask.ifr_name, ifrp->ifr_name,\n\t\t    sizeof(ifrnetmask.ifr_name));\n\t\tmemcpy(&ifrnetmask.ifr_addr, &ifrp->ifr_addr,\n\t\t    sizeof(ifrnetmask.ifr_addr));\n\t\tif (ioctl(fd, SIOCGIFNETMASK, (char *)&ifrnetmask) < 0) {\n\t\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\t\t/*\n\t\t\t\t * Not available.\n\t\t\t\t */\n\t\t\t\tnetmask = NULL;\n\t\t\t\tnetmask_size = 0;\n\t\t\t} else {\n\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"SIOCGIFNETMASK: %.*s\",\n\t\t\t\t    (int)sizeof(ifrnetmask.ifr_name),\n\t\t\t\t    ifrnetmask.ifr_name);\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tnetmask = &ifrnetmask.ifr_addr;\n\t\t\tnetmask_size = SA_LEN(netmask);\n\t\t}\n\n\t\t/*\n\t\t * Get the broadcast address for this address on this\n\t\t * interface (if any).\n\t\t */\n\t\tif (ifrflags.ifr_flags & IFF_BROADCAST) {\n\t\t\tstrncpy(ifrbroadaddr.ifr_name, ifrp->ifr_name,\n\t\t\t    sizeof(ifrbroadaddr.ifr_name));\n\t\t\tmemcpy(&ifrbroadaddr.ifr_addr, &ifrp->ifr_addr,\n\t\t\t    sizeof(ifrbroadaddr.ifr_addr));\n\t\t\tif (ioctl(fd, SIOCGIFBRDADDR,\n\t\t\t    (char *)&ifrbroadaddr) < 0) {\n\t\t\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Not available.\n\t\t\t\t\t */\n\t\t\t\t\tbroadaddr = NULL;\n\t\t\t\t\tbroadaddr_size = 0;\n\t\t\t\t} else {\n\t\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"SIOCGIFBRDADDR: %.*s\",\n\t\t\t\t\t    (int)sizeof(ifrbroadaddr.ifr_name),\n\t\t\t\t\t    ifrbroadaddr.ifr_name);\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbroadaddr = &ifrbroadaddr.ifr_broadaddr;\n\t\t\t\tbroadaddr_size = SA_LEN(broadaddr);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Not a broadcast interface, so no broadcast\n\t\t\t * address.\n\t\t\t */\n\t\t\tbroadaddr = NULL;\n\t\t\tbroadaddr_size = 0;\n\t\t}\n\n\t\t/*\n\t\t * Get the destination address for this address on this\n\t\t * interface (if any).\n\t\t */\n\t\tif (ifrflags.ifr_flags & IFF_POINTOPOINT) {\n\t\t\tstrncpy(ifrdstaddr.ifr_name, ifrp->ifr_name,\n\t\t\t    sizeof(ifrdstaddr.ifr_name));\n\t\t\tmemcpy(&ifrdstaddr.ifr_addr, &ifrp->ifr_addr,\n\t\t\t    sizeof(ifrdstaddr.ifr_addr));\n\t\t\tif (ioctl(fd, SIOCGIFDSTADDR,\n\t\t\t    (char *)&ifrdstaddr) < 0) {\n\t\t\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Not available.\n\t\t\t\t\t */\n\t\t\t\t\tdstaddr = NULL;\n\t\t\t\t\tdstaddr_size = 0;\n\t\t\t\t} else {\n\t\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"SIOCGIFDSTADDR: %.*s\",\n\t\t\t\t\t    (int)sizeof(ifrdstaddr.ifr_name),\n\t\t\t\t\t    ifrdstaddr.ifr_name);\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdstaddr = &ifrdstaddr.ifr_dstaddr;\n\t\t\t\tdstaddr_size = SA_LEN(dstaddr);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Not a point-to-point interface, so no destination\n\t\t\t * address.\n\t\t\t */\n\t\t\tdstaddr = NULL;\n\t\t\tdstaddr_size = 0;\n\t\t}\n\n#if defined (HAVE_SOLARIS) || defined (HAVE_HPUX10_20_OR_LATER)\n\t\t/*\n\t\t * If this entry has a colon followed by a number at\n\t\t * the end, it's a logical interface.  Those are just\n\t\t * the way you assign multiple IP addresses to a real\n\t\t * interface, so an entry for a logical interface should\n\t\t * be treated like the entry for the real interface;\n\t\t * we do that by stripping off the \":\" and the number.\n\t\t */\n\t\tp = strchr(ifrp->ifr_name, ':');\n\t\tif (p != NULL) {\n\t\t\t/*\n\t\t\t * We have a \":\"; is it followed by a number?\n\t\t\t */\n\t\t\tq = p + 1;\n\t\t\twhile (isdigit((unsigned char)*q))\n\t\t\t\tq++;\n\t\t\tif (*q == '\\0') {\n\t\t\t\t/*\n\t\t\t\t * All digits after the \":\" until the end.\n\t\t\t\t * Strip off the \":\" and everything after\n\t\t\t\t * it.\n\t\t\t\t */\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Add information for this address to the list.\n\t\t */\n\t\tif (add_addr_to_if(devlistp, ifrp->ifr_name,\n\t\t    ifrflags.ifr_flags, get_flags_func,\n\t\t    &ifrp->ifr_addr, SA_LEN(&ifrp->ifr_addr),\n\t\t    netmask, netmask_size, broadaddr, broadaddr_size,\n\t\t    dstaddr, dstaddr_size, errbuf) < 0) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(buf);\n\t(void)close(fd);\n\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              134,
              0
            ],
            [
              425,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_findalldevs_interfaces",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char",
              "check_usable": "int",
              "get_flags_func": "get_if_flags_func"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*check_usable)(const char *)",
          "fn_dec_pos": [
            [
              136,
              8
            ],
            [
              136,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct mbuf",
          {},
          "",
          [
            46,
            0
          ],
          [
            46,
            11
          ]
        ],
        [
          "struct rtentry",
          {},
          "",
          [
            47,
            0
          ],
          [
            47,
            14
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            139,
            10
          ],
          [
            139,
            22
          ]
        ],
        [
          "struct ifconf",
          {},
          "",
          [
            141,
            1
          ],
          [
            141,
            14
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            147,
            1
          ],
          [
            147,
            13
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            148,
            1
          ],
          [
            148,
            16
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            207,
            9
          ],
          [
            207,
            21
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            208,
            10
          ],
          [
            208,
            22
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            225,
            13
          ],
          [
            225,
            25
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <sys/param.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <sys/ioctl.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <sys/sockio.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <sys/time.h>\t\t\t\t/* concession to AIX */\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <net/if.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <memory.h>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-linux.c": {
      "fn_def_list": [
        {
          "fn_code": "pcap_t *\npcap_create_interface(const char *device, char *ebuf)\n{\n\tpcap_t *handle;\n\n\thandle = pcap_create_common(ebuf, sizeof (struct pcap_linux));\n\tif (handle == NULL)\n\t\treturn NULL;\n\n\thandle->activate_op = pcap_activate_linux;\n\thandle->can_set_rfmon_op = pcap_can_set_rfmon_linux;\n\n#if defined(HAVE_LINUX_NET_TSTAMP_H) && defined(PACKET_TIMESTAMP)\n\t/*\n\t * See what time stamp types we support.\n\t */\n\tif (iface_ethtool_get_ts_info(device, handle, ebuf) == -1) {\n\t\tpcap_close(handle);\n\t\treturn NULL;\n\t}\n#endif\n\n#if defined(SIOCGSTAMPNS) && defined(SO_TIMESTAMPNS)\n\t/*\n\t * We claim that we support microsecond and nanosecond time\n\t * stamps.\n\t *\n\t * XXX - with adapter-supplied time stamps, can we choose\n\t * microsecond or nanosecond time stamps on arbitrary\n\t * adapters?\n\t */\n\thandle->tstamp_precision_count = 2;\n\thandle->tstamp_precision_list = malloc(2 * sizeof(u_int));\n\tif (handle->tstamp_precision_list == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tpcap_close(handle);\n\t\treturn NULL;\n\t}\n\thandle->tstamp_precision_list[0] = PCAP_TSTAMP_PRECISION_MICRO;\n\thandle->tstamp_precision_list[1] = PCAP_TSTAMP_PRECISION_NANO;\n#endif /* defined(SIOCGSTAMPNS) && defined(SO_TIMESTAMPNS) */\n\n#ifdef HAVE_SYS_EVENTFD_H\n\tstruct pcap_linux *handlep = handle->priv;\n\thandlep->poll_breakloop_fd = eventfd(0, EFD_NONBLOCK);\n#endif\n\n\treturn handle;\n}",
          "fn_code_pos": [
            [
              509,
              0
            ],
            [
              558,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static int\nget_mac80211_phydev(pcap_t *handle, const char *device, char *phydev_path,\n    size_t phydev_max_pathlen)\n{\n\tchar *pathstr;\n\tssize_t bytes_read;\n\n\t/*\n\t * Generate the path string for the symlink to the physical device.\n\t */\n\tif (asprintf(&pathstr, \"/sys/class/net/%s/phy80211\", device) == -1) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: Can't generate path name string for /sys/class/net device\",\n\t\t    device);\n\t\treturn PCAP_ERROR;\n\t}\n\tbytes_read = readlink(pathstr, phydev_path, phydev_max_pathlen);\n\tif (bytes_read == -1) {\n\t\tif (errno == ENOENT || errno == EINVAL) {\n\t\t\t/*\n\t\t\t * Doesn't exist, or not a symlink; assume that\n\t\t\t * means it's not a mac80211 device.\n\t\t\t */\n\t\t\tfree(pathstr);\n\t\t\treturn 0;\n\t\t}\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"%s: Can't readlink %s\", device, pathstr);\n\t\tfree(pathstr);\n\t\treturn PCAP_ERROR;\n\t}\n\tfree(pathstr);\n\tphydev_path[bytes_read] = '\\0';\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              609,
              0
            ],
            [
              643,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_mac80211_phydev",
            "parameters": {
              "handle": "pcap_t",
              "device": "char",
              "phydev_path": "char",
              "phydev_max_pathlen": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static inline struct nl_handle *\nnl_socket_alloc(void)\n{\n\treturn nl_handle_alloc();\n}",
          "fn_code_pos": [
            [
              652,
              0
            ],
            [
              656,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nl_socket_alloc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static inline void\nnl_socket_free(struct nl_handle *h)\n{\n\tnl_handle_destroy(h);\n}",
          "fn_code_pos": [
            [
              658,
              0
            ],
            [
              662,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nl_socket_free",
            "parameters": {
              "h": "struct nl_handle"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static inline int\n__genl_ctrl_alloc_cache(struct nl_handle *h, struct nl_cache **cache)\n{\n\tstruct nl_cache *tmp = genl_ctrl_alloc_cache(h);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\t*cache = tmp;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              666,
              0
            ],
            [
              674,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "__genl_ctrl_alloc_cache",
            "parameters": {
              "h": "struct nl_handle",
              "cache": "struct nl_cache"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nnl80211_init(pcap_t *handle, struct nl80211_state *state, const char *device)\n{\n\tint err;\n\n\tstate->nl_sock = nl_socket_alloc();\n\tif (!state->nl_sock) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: failed to allocate netlink handle\", device);\n\t\treturn PCAP_ERROR;\n\t}\n\n\tif (genl_connect(state->nl_sock)) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: failed to connect to generic netlink\", device);\n\t\tgoto out_handle_destroy;\n\t}\n\n\terr = genl_ctrl_alloc_cache(state->nl_sock, &state->nl_cache);\n\tif (err < 0) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: failed to allocate generic netlink cache: %s\",\n\t\t    device, get_nl_errmsg(-err));\n\t\tgoto out_handle_destroy;\n\t}\n\n\tstate->nl80211 = genl_ctrl_search_by_name(state->nl_cache, \"nl80211\");\n\tif (!state->nl80211) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: nl80211 not found\", device);\n\t\tgoto out_cache_free;\n\t}\n\n\treturn 0;\n\nout_cache_free:\n\tnl_cache_free(state->nl_cache);\nout_handle_destroy:\n\tnl_socket_free(state->nl_sock);\n\treturn PCAP_ERROR;\n}",
          "fn_code_pos": [
            [
              684,
              0
            ],
            [
              724,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nl80211_init",
            "parameters": {
              "handle": "pcap_t",
              "state": "struct nl80211_state",
              "device": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nnl80211_cleanup(struct nl80211_state *state)\n{\n\tgenl_family_put(state->nl80211);\n\tnl_cache_free(state->nl_cache);\n\tnl_socket_free(state->nl_sock);\n}",
          "fn_code_pos": [
            [
              726,
              0
            ],
            [
              732,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nl80211_cleanup",
            "parameters": {
              "state": "struct nl80211_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ndel_mon_if(pcap_t *handle, int sock_fd, struct nl80211_state *state,\n    const char *device, const char *mondevice)\n{\n\tint ifindex;\n\tstruct nl_msg *msg;\n\tint err;\n\n\tifindex = iface_get_id(sock_fd, mondevice, handle->errbuf);\n\tif (ifindex == -1)\n\t\treturn PCAP_ERROR;\n\n\tmsg = nlmsg_alloc();\n\tif (!msg) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: failed to allocate netlink msg\", device);\n\t\treturn PCAP_ERROR;\n\t}\n\n\tgenlmsg_put(msg, 0, 0, genl_family_get_id(state->nl80211), 0,\n\t\t    0, NL80211_CMD_DEL_INTERFACE, 0);\n\tNLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, ifindex);\n\n\terr = nl_send_auto_complete(state->nl_sock, msg);\n\tif (err < 0) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: nl_send_auto_complete failed deleting %s interface: %s\",\n\t\t    device, mondevice, get_nl_errmsg(-err));\n\t\tnlmsg_free(msg);\n\t\treturn PCAP_ERROR;\n\t}\n\terr = nl_wait_for_ack(state->nl_sock);\n\tif (err < 0) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: nl_wait_for_ack failed adding %s interface: %s\",\n\t\t    device, mondevice, get_nl_errmsg(-err));\n\t\tnlmsg_free(msg);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * Success.\n\t */\n\tnlmsg_free(msg);\n\treturn 1;\n\nnla_put_failure:\n\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"%s: nl_put failed deleting %s interface\",\n\t    device, mondevice);\n\tnlmsg_free(msg);\n\treturn PCAP_ERROR;\n}",
          "fn_code_pos": [
            [
              851,
              0
            ],
            [
              903,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "del_mon_if",
            "parameters": {
              "handle": "pcap_t",
              "sock_fd": "int",
              "state": "struct nl80211_state",
              "device": "char",
              "mondevice": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nenter_rfmon_mode_mac80211(pcap_t *handle, int sock_fd, const char *device)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tint ret;\n\tchar phydev_path[PATH_MAX+1];\n\tstruct nl80211_state nlstate;\n\tstruct ifreq ifr;\n\tu_int n;\n\n\t/*\n\t * Is this a mac80211 device?\n\t */\n\tret = get_mac80211_phydev(handle, device, phydev_path, PATH_MAX);\n\tif (ret < 0)\n\t\treturn ret;\t/* error */\n\tif (ret == 0)\n\t\treturn 0;\t/* no error, but not mac80211 device */\n\n\t/*\n\t * XXX - is this already a monN device?\n\t * If so, we're done.\n\t * Is that determined by old Wireless Extensions ioctls?\n\t */\n\n\t/*\n\t * OK, it's apparently a mac80211 device.\n\t * Try to find an unused monN device for it.\n\t */\n\tret = nl80211_init(handle, &nlstate, device);\n\tif (ret != 0)\n\t\treturn ret;\n\tfor (n = 0; n < UINT_MAX; n++) {\n\t\t/*\n\t\t * Try mon{n}.\n\t\t */\n\t\tchar mondevice[3+10+1];\t/* mon{UINT_MAX}\\0 */\n\n\t\tpcap_snprintf(mondevice, sizeof mondevice, \"mon%u\", n);\n\t\tret = add_mon_if(handle, sock_fd, &nlstate, device, mondevice);\n\t\tif (ret == 1) {\n\t\t\t/*\n\t\t\t * Success.  We don't clean up the libnl state\n\t\t\t * yet, as we'll be using it later.\n\t\t\t */\n\t\t\tgoto added;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\t/*\n\t\t\t * Hard failure.  Just return ret; handle->errbuf\n\t\t\t * has already been set.\n\t\t\t */\n\t\t\tnl80211_cleanup(&nlstate);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"%s: No free monN interfaces\", device);\n\tnl80211_cleanup(&nlstate);\n\treturn PCAP_ERROR;\n\nadded:\n\n#if 0\n\t/*\n\t * Sleep for .1 seconds.\n\t */\n\tdelay.tv_sec = 0;\n\tdelay.tv_nsec = 500000000;\n\tnanosleep(&delay, NULL);\n#endif\n\n\t/*\n\t * If we haven't already done so, arrange to have\n\t * \"pcap_close_all()\" called when we exit.\n\t */\n\tif (!pcap_do_addexit(handle)) {\n\t\t/*\n\t\t * \"atexit()\" failed; don't put the interface\n\t\t * in rfmon mode, just give up.\n\t\t */\n\t\tdel_mon_if(handle, sock_fd, &nlstate, device,\n\t\t    handlep->mondevice);\n\t\tnl80211_cleanup(&nlstate);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * Now configure the monitor interface up.\n\t */\n\tmemset(&ifr, 0, sizeof(ifr));\n\tpcap_strlcpy(ifr.ifr_name, handlep->mondevice, sizeof(ifr.ifr_name));\n\tif (ioctl(sock_fd, SIOCGIFFLAGS, &ifr) == -1) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"%s: Can't get flags for %s\", device,\n\t\t    handlep->mondevice);\n\t\tdel_mon_if(handle, sock_fd, &nlstate, device,\n\t\t    handlep->mondevice);\n\t\tnl80211_cleanup(&nlstate);\n\t\treturn PCAP_ERROR;\n\t}\n\tifr.ifr_flags |= IFF_UP|IFF_RUNNING;\n\tif (ioctl(sock_fd, SIOCSIFFLAGS, &ifr) == -1) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"%s: Can't set flags for %s\", device,\n\t\t    handlep->mondevice);\n\t\tdel_mon_if(handle, sock_fd, &nlstate, device,\n\t\t    handlep->mondevice);\n\t\tnl80211_cleanup(&nlstate);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * Success.  Clean up the libnl state.\n\t */\n\tnl80211_cleanup(&nlstate);\n\n\t/*\n\t * Note that we have to delete the monitor device when we close\n\t * the handle.\n\t */\n\thandlep->must_do_on_close |= MUST_DELETE_MONIF;\n\n\t/*\n\t * Add this to the list of pcaps to close when we exit.\n\t */\n\tpcap_add_to_pcaps_to_close(handle);\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              905,
              0
            ],
            [
              1035,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "enter_rfmon_mode_mac80211",
            "parameters": {
              "handle": "pcap_t",
              "sock_fd": "int",
              "device": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nis_bonding_device(int fd, const char *device)\n{\n#ifdef BOND_INFO_QUERY_IOCTL\n\tstruct ifreq ifr;\n\tifbond ifb;\n\n\tmemset(&ifr, 0, sizeof ifr);\n\tpcap_strlcpy(ifr.ifr_name, device, sizeof ifr.ifr_name);\n\tmemset(&ifb, 0, sizeof ifb);\n\tifr.ifr_data = (caddr_t)&ifb;\n\tif (ioctl(fd, BOND_INFO_QUERY_IOCTL, &ifr) == 0)\n\t\treturn 1;\t/* success, so it's a bonding device */\n#endif /* BOND_INFO_QUERY_IOCTL */\n\n\treturn 0;\t/* no, it's not a bonding device */\n}",
          "fn_code_pos": [
            [
              1050,
              0
            ],
            [
              1066,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "is_bonding_device",
            "parameters": {
              "fd": "int",
              "device": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_protocol(pcap_t *handle)\n{\n\tint protocol;\n\n\tprotocol = handle->opt.protocol;\n\tif (protocol == 0)\n\t\tprotocol = ETH_P_ALL;\n\n\treturn htons(protocol);\n}",
          "fn_code_pos": [
            [
              1069,
              0
            ],
            [
              1078,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_protocol",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_can_set_rfmon_linux(pcap_t *handle)\n{\n#ifdef HAVE_LIBNL\n\tchar phydev_path[PATH_MAX+1];\n\tint ret;\n#endif\n#ifdef IW_MODE_MONITOR\n\tint sock_fd;\n\tstruct iwreq ireq;\n#endif\n\n\tif (strcmp(handle->opt.device, \"any\") == 0) {\n\t\t/*\n\t\t * Monitor mode makes no sense on the \"any\" device.\n\t\t */\n\t\treturn 0;\n\t}\n\n#ifdef HAVE_LIBNL\n\t/*\n\t * Bleah.  There doesn't seem to be a way to ask a mac80211\n\t * device, through libnl, whether it supports monitor mode;\n\t * we'll just check whether the device appears to be a\n\t * mac80211 device and, if so, assume the device supports\n\t * monitor mode.\n\t *\n\t * wmaster devices don't appear to support the Wireless\n\t * Extensions, but we can create a mon device for a\n\t * wmaster device, so we don't bother checking whether\n\t * a mac80211 device supports the Wireless Extensions.\n\t */\n\tret = get_mac80211_phydev(handle, handle->opt.device, phydev_path,\n\t    PATH_MAX);\n\tif (ret < 0)\n\t\treturn ret;\t/* error */\n\tif (ret == 1)\n\t\treturn 1;\t/* mac80211 device */\n#endif\n\n#ifdef IW_MODE_MONITOR\n\t/*\n\t * Bleah.  There doesn't appear to be an ioctl to use to ask\n\t * whether a device supports monitor mode; we'll just do\n\t * SIOCGIWMODE and, if it succeeds, assume the device supports\n\t * monitor mode.\n\t *\n\t * Open a socket on which to attempt to get the mode.\n\t * (We assume that if we have Wireless Extensions support\n\t * we also have PF_PACKET support.)\n\t */\n\tsock_fd = socket(PF_PACKET, SOCK_RAW, pcap_protocol(handle));\n\tif (sock_fd == -1) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"socket\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tif (is_bonding_device(sock_fd, handle->opt.device)) {\n\t\t/* It's a bonding device, so don't even try. */\n\t\tclose(sock_fd);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Attempt to get the current mode.\n\t */\n\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, handle->opt.device,\n\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\tif (ioctl(sock_fd, SIOCGIWMODE, &ireq) != -1) {\n\t\t/*\n\t\t * Well, we got the mode; assume we can set it.\n\t\t */\n\t\tclose(sock_fd);\n\t\treturn 1;\n\t}\n\tif (errno == ENODEV) {\n\t\t/* The device doesn't even exist. */\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCGIWMODE failed\");\n\t\tclose(sock_fd);\n\t\treturn PCAP_ERROR_NO_SUCH_DEVICE;\n\t}\n\tclose(sock_fd);\n#endif\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1080,
              0
            ],
            [
              1166,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_can_set_rfmon_linux",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static long int\nlinux_if_drops(const char * if_name)\n{\n\tchar buffer[512];\n\tchar * bufptr;\n\tFILE * file;\n\tint field_to_convert = 3;\n\tsize_t if_name_sz = strlen(if_name);\n\tlong int dropped_pkts = 0;\n\n\tfile = fopen(\"/proc/net/dev\", \"r\");\n\tif (!file)\n\t\treturn 0;\n\n\twhile (!dropped_pkts && fgets( buffer, sizeof(buffer), file ))\n\t{\n\t\t/* \tsearch for 'bytes' -- if its in there, then\n\t\t\tthat means we need to grab the fourth field. otherwise\n\t\t\tgrab the third field. */\n\t\tif (field_to_convert != 4 && strstr(buffer, \"bytes\"))\n\t\t{\n\t\t\tfield_to_convert = 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* find iface and make sure it actually matches -- space before the name and : after it */\n\t\tif ((bufptr = strstr(buffer, if_name)) &&\n\t\t\t(bufptr == buffer || *(bufptr-1) == ' ') &&\n\t\t\t*(bufptr + if_name_sz) == ':')\n\t\t{\n\t\t\tbufptr = bufptr + if_name_sz + 1;\n\n\t\t\t/* grab the nth field from it */\n\t\t\twhile( --field_to_convert && *bufptr != '\\0')\n\t\t\t{\n\t\t\t\twhile (*bufptr != '\\0' && *(bufptr++) == ' ');\n\t\t\t\twhile (*bufptr != '\\0' && *(bufptr++) != ' ');\n\t\t\t}\n\n\t\t\t/* get rid of any final spaces */\n\t\t\twhile (*bufptr != '\\0' && *bufptr == ' ') bufptr++;\n\n\t\t\tif (*bufptr != '\\0')\n\t\t\t\tdropped_pkts = strtol(bufptr, NULL, 10);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(file);\n\treturn dropped_pkts;\n}",
          "fn_code_pos": [
            [
              1176,
              0
            ],
            [
              1227,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "linux_if_drops",
            "parameters": {
              "if_name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void\tpcap_cleanup_linux( pcap_t *handle )\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tstruct ifreq\tifr;\n#ifdef HAVE_LIBNL\n\tstruct nl80211_state nlstate;\n\tint ret;\n#endif /* HAVE_LIBNL */\n#ifdef IW_MODE_MONITOR\n\tint oldflags;\n\tstruct iwreq ireq;\n#endif /* IW_MODE_MONITOR */\n\n\tif (handlep->must_do_on_close != 0) {\n\t\t/*\n\t\t * There's something we have to do when closing this\n\t\t * pcap_t.\n\t\t */\n\t\tif (handlep->must_do_on_close & MUST_CLEAR_PROMISC) {\n\t\t\t/*\n\t\t\t * We put the interface into promiscuous mode;\n\t\t\t * take it out of promiscuous mode.\n\t\t\t *\n\t\t\t * XXX - if somebody else wants it in promiscuous\n\t\t\t * mode, this code cannot know that, so it'll take\n\t\t\t * it out of promiscuous mode.  That's not fixable\n\t\t\t * in 2.0[.x] kernels.\n\t\t\t */\n\t\t\tmemset(&ifr, 0, sizeof(ifr));\n\t\t\tpcap_strlcpy(ifr.ifr_name, handlep->device,\n\t\t\t    sizeof(ifr.ifr_name));\n\t\t\tif (ioctl(handle->fd, SIOCGIFFLAGS, &ifr) == -1) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Can't restore interface %s flags (SIOCGIFFLAGS failed: %s).\\n\"\n\t\t\t\t    \"Please adjust manually.\\n\"\n\t\t\t\t    \"Hint: This can't happen with Linux >= 2.2.0.\\n\",\n\t\t\t\t    handlep->device, strerror(errno));\n\t\t\t} else {\n\t\t\t\tif (ifr.ifr_flags & IFF_PROMISC) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Promiscuous mode is currently on;\n\t\t\t\t\t * turn it off.\n\t\t\t\t\t */\n\t\t\t\t\tifr.ifr_flags &= ~IFF_PROMISC;\n\t\t\t\t\tif (ioctl(handle->fd, SIOCSIFFLAGS,\n\t\t\t\t\t    &ifr) == -1) {\n\t\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t    \"Can't restore interface %s flags (SIOCSIFFLAGS failed: %s).\\n\"\n\t\t\t\t\t\t    \"Please adjust manually.\\n\"\n\t\t\t\t\t\t    \"Hint: This can't happen with Linux >= 2.2.0.\\n\",\n\t\t\t\t\t\t    handlep->device,\n\t\t\t\t\t\t    strerror(errno));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef HAVE_LIBNL\n\t\tif (handlep->must_do_on_close & MUST_DELETE_MONIF) {\n\t\t\tret = nl80211_init(handle, &nlstate, handlep->device);\n\t\t\tif (ret >= 0) {\n\t\t\t\tret = del_mon_if(handle, handle->fd, &nlstate,\n\t\t\t\t    handlep->device, handlep->mondevice);\n\t\t\t\tnl80211_cleanup(&nlstate);\n\t\t\t}\n\t\t\tif (ret < 0) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Can't delete monitor interface %s (%s).\\n\"\n\t\t\t\t    \"Please delete manually.\\n\",\n\t\t\t\t    handlep->mondevice, handle->errbuf);\n\t\t\t}\n\t\t}\n#endif /* HAVE_LIBNL */\n\n#ifdef IW_MODE_MONITOR\n\t\tif (handlep->must_do_on_close & MUST_CLEAR_RFMON) {\n\t\t\t/*\n\t\t\t * We put the interface into rfmon mode;\n\t\t\t * take it out of rfmon mode.\n\t\t\t *\n\t\t\t * XXX - if somebody else wants it in rfmon\n\t\t\t * mode, this code cannot know that, so it'll take\n\t\t\t * it out of rfmon mode.\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * First, take the interface down if it's up;\n\t\t\t * otherwise, we might get EBUSY.\n\t\t\t * If we get errors, just drive on and print\n\t\t\t * a warning if we can't restore the mode.\n\t\t\t */\n\t\t\toldflags = 0;\n\t\t\tmemset(&ifr, 0, sizeof(ifr));\n\t\t\tpcap_strlcpy(ifr.ifr_name, handlep->device,\n\t\t\t    sizeof(ifr.ifr_name));\n\t\t\tif (ioctl(handle->fd, SIOCGIFFLAGS, &ifr) != -1) {\n\t\t\t\tif (ifr.ifr_flags & IFF_UP) {\n\t\t\t\t\toldflags = ifr.ifr_flags;\n\t\t\t\t\tifr.ifr_flags &= ~IFF_UP;\n\t\t\t\t\tif (ioctl(handle->fd, SIOCSIFFLAGS, &ifr) == -1)\n\t\t\t\t\t\toldflags = 0;\t/* didn't set, don't restore */\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now restore the mode.\n\t\t\t */\n\t\t\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, handlep->device,\n\t\t\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\t\t\tireq.u.mode = handlep->oldmode;\n\t\t\tif (ioctl(handle->fd, SIOCSIWMODE, &ireq) == -1) {\n\t\t\t\t/*\n\t\t\t\t * Scientist, you've failed.\n\t\t\t\t */\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Can't restore interface %s wireless mode (SIOCSIWMODE failed: %s).\\n\"\n\t\t\t\t    \"Please adjust manually.\\n\",\n\t\t\t\t    handlep->device, strerror(errno));\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Now bring the interface back up if we brought\n\t\t\t * it down.\n\t\t\t */\n\t\t\tif (oldflags != 0) {\n\t\t\t\tifr.ifr_flags = oldflags;\n\t\t\t\tif (ioctl(handle->fd, SIOCSIFFLAGS, &ifr) == -1) {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"Can't bring interface %s back up (SIOCSIFFLAGS failed: %s).\\n\"\n\t\t\t\t\t    \"Please adjust manually.\\n\",\n\t\t\t\t\t    handlep->device, strerror(errno));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif /* IW_MODE_MONITOR */\n\n\t\t/*\n\t\t * Take this pcap out of the list of pcaps for which we\n\t\t * have to take the interface out of some mode.\n\t\t */\n\t\tpcap_remove_from_pcaps_to_close(handle);\n\t}\n\n\tif (handlep->mondevice != NULL) {\n\t\tfree(handlep->mondevice);\n\t\thandlep->mondevice = NULL;\n\t}\n\tif (handlep->device != NULL) {\n\t\tfree(handlep->device);\n\t\thandlep->device = NULL;\n\t}\n\n#ifdef HAVE_SYS_EVENTFD_H\n\tclose(handlep->poll_breakloop_fd);\n#endif\n\tpcap_cleanup_live_common(handle);\n}",
          "fn_code_pos": [
            [
              1242,
              0
            ],
            [
              1398,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_cleanup_linux",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nset_poll_timeout(struct pcap_linux *handlep)\n{\n#ifdef HAVE_TPACKET3\n\tstruct utsname utsname;\n\tchar *version_component, *endp;\n\tlong major, minor;\n\tint broken_tpacket_v3 = 1;\n\n\t/*\n\t * Some versions of TPACKET_V3 have annoying bugs/misfeatures\n\t * around which we have to work.  Determine if we have those\n\t * problems or not.\n\t */\n\tif (uname(&utsname) == 0) {\n\t\t/*\n\t\t * 3.19 is the first release with a fixed version of\n\t\t * TPACKET_V3.  We treat anything before that as\n\t\t * not haveing a fixed version; that may really mean\n\t\t * it has *no* version.\n\t\t */\n\t\tversion_component = utsname.release;\n\t\tmajor = strtol(version_component, &endp, 10);\n\t\tif (endp != version_component && *endp == '.') {\n\t\t\t/*\n\t\t\t * OK, that was a valid major version.\n\t\t\t * Get the minor version.\n\t\t\t */\n\t\t\tversion_component = endp + 1;\n\t\t\tminor = strtol(version_component, &endp, 10);\n\t\t\tif (endp != version_component &&\n\t\t\t    (*endp == '.' || *endp == '\\0')) {\n\t\t\t\t/*\n\t\t\t\t * OK, that was a valid minor version.\n\t\t\t\t * Is this 3.19 or newer?\n\t\t\t\t */\n\t\t\t\tif (major >= 4 || (major == 3 && minor >= 19)) {\n\t\t\t\t\t/* Yes. TPACKET_V3 works correctly. */\n\t\t\t\t\tbroken_tpacket_v3 = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tif (handlep->timeout == 0) {\n#ifdef HAVE_TPACKET3\n\t\t/*\n\t\t * XXX - due to a set of (mis)features in the TPACKET_V3\n\t\t * kernel code prior to the 3.19 kernel, blocking forever\n\t\t * with a TPACKET_V3 socket can, if few packets are\n\t\t * arriving and passing the socket filter, cause most\n\t\t * packets to be dropped.  See libpcap issue #335 for the\n\t\t * full painful story.\n\t\t *\n\t\t * The workaround is to have poll() time out very quickly,\n\t\t * so we grab the frames handed to us, and return them to\n\t\t * the kernel, ASAP.\n\t\t */\n\t\tif (handlep->tp_version == TPACKET_V3 && broken_tpacket_v3)\n\t\t\thandlep->poll_timeout = 1;\t/* don't block for very long */\n\t\telse\n#endif\n\t\t\thandlep->poll_timeout = -1;\t/* block forever */\n\t} else if (handlep->timeout > 0) {\n#ifdef HAVE_TPACKET3\n\t\t/*\n\t\t * For TPACKET_V3, the timeout is handled by the kernel,\n\t\t * so block forever; that way, we don't get extra timeouts.\n\t\t * Don't do that if we have a broken TPACKET_V3, though.\n\t\t */\n\t\tif (handlep->tp_version == TPACKET_V3 && !broken_tpacket_v3)\n\t\t\thandlep->poll_timeout = -1;\t/* block forever, let TPACKET_V3 wake us up */\n\t\telse\n#endif\n\t\t\thandlep->poll_timeout = handlep->timeout;\t/* block for that amount of time */\n\t} else {\n\t\t/*\n\t\t * Non-blocking mode; we call poll() to pick up error\n\t\t * indications, but we don't want it to wait for\n\t\t * anything.\n\t\t */\n\t\thandlep->poll_timeout = 0;\n\t}\n}",
          "fn_code_pos": [
            [
              1403,
              0
            ],
            [
              1486,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_poll_timeout",
            "parameters": {
              "handlep": "struct pcap_linux"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void pcap_breakloop_linux(pcap_t *handle)\n{\n\tpcap_breakloop_common(handle);\n\tstruct pcap_linux *handlep = handle->priv;\n\n\tuint64_t value = 1;\n\t/* XXX - what if this fails? */\n\t(void)write(handlep->poll_breakloop_fd, &value, sizeof(value));\n}",
          "fn_code_pos": [
            [
              1489,
              0
            ],
            [
              1497,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_breakloop_linux",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nopen_pf_packet_socket(pcap_t *handle, int cooked)\n{\n\tint\tprotocol = pcap_protocol(handle);\n\tint\tsock_fd, ret;\n\n\t/*\n\t * Open a socket with protocol family packet. If cooked is true,\n\t * we open a SOCK_DGRAM socket for the cooked interface, otherwise\n\t * we open a SOCK_RAW socket for the raw interface.\n\t */\n\tsock_fd = cooked ?\n\t\tsocket(PF_PACKET, SOCK_DGRAM, protocol) :\n\t\tsocket(PF_PACKET, SOCK_RAW, protocol);\n\n\tif (sock_fd == -1) {\n\t\tif (errno == EINVAL || errno == EAFNOSUPPORT) {\n\t\t\t/*\n\t\t\t * PF_PACKET sockets aren't supported.\n\t\t\t *\n\t\t\t * If this is the first attempt to open a PF_PACKET\n\t\t\t * socket, our caller will just want to try a\n\t\t\t * PF_INET/SOCK_PACKET socket; in other cases, we\n\t\t\t * already succeeded opening a PF_PACKET socket,\n\t\t\t * but are just switching to cooked from raw, in\n\t\t\t * which case this is a fatal error (and \"can't\n\t\t\t * happen\", because the kernel isn't going to\n\t\t\t * spontaneously drop its support for PF_PACKET\n\t\t\t * sockets).\n\t\t\t */\n\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"PF_PACKET sockets not supported (this \\\"can't happen\\\"!\");\n\t\t\treturn PCAP_ERROR_NO_PF_PACKET_SOCKETS;\n\t\t}\n\t\tif (errno == EPERM || errno == EACCES) {\n\t\t\t/*\n\t\t\t * You don't have permission to open the\n\t\t\t * socket.\n\t\t\t */\n\t\t\tret = PCAP_ERROR_PERM_DENIED;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Other error.\n\t\t\t */\n\t\t\tret = PCAP_ERROR;\n\t\t}\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"socket\");\n\t\treturn ret;\n\t}\n\treturn sock_fd;\n}",
          "fn_code_pos": [
            [
              1517,
              0
            ],
            [
              1568,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "open_pf_packet_socket",
            "parameters": {
              "handle": "pcap_t",
              "cooked": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_activate_linux(pcap_t *handle)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tconst char\t*device;\n\tint\t\tis_any_device;\n\tstruct ifreq\tifr;\n\tint\t\tstatus = 0;\n\tint\t\tret;\n\n\tdevice = handle->opt.device;\n\n\t/*\n\t * Make sure the name we were handed will fit into the ioctls we\n\t * might perform on the device; if not, return a \"No such device\"\n\t * indication, as the Linux kernel shouldn't support creating\n\t * a device whose name won't fit into those ioctls.\n\t *\n\t * \"Will fit\" means \"will fit, complete with a null terminator\",\n\t * so if the length, which does *not* include the null terminator,\n\t * is greater than *or equal to* the size of the field into which\n\t * we'll be copying it, that won't fit.\n\t */\n\tif (strlen(device) >= sizeof(ifr.ifr_name)) {\n\t\tstatus = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)\n\t\thandle->snapshot = MAXIMUM_SNAPLEN;\n\n\thandle->inject_op = pcap_inject_linux;\n\thandle->setfilter_op = pcap_setfilter_linux;\n\thandle->setdirection_op = pcap_setdirection_linux;\n\thandle->set_datalink_op = pcap_set_datalink_linux;\n\thandle->getnonblock_op = pcap_getnonblock_fd;\n\thandle->setnonblock_op = pcap_setnonblock_fd;\n\thandle->cleanup_op = pcap_cleanup_linux;\n\thandle->read_op = pcap_read_linux;\n\thandle->stats_op = pcap_stats_linux;\n#ifdef HAVE_SYS_EVENTFD_H\n\thandle->breakloop_op = pcap_breakloop_linux;\n#endif\n\n\thandlep->device\t= strdup(device);\n\tif (handlep->device == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"strdup\");\n\t\tstatus = PCAP_ERROR;\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * The \"any\" device is a special device which causes us not\n\t * to bind to a particular device and thus to look at all\n\t * devices.\n\t */\n\tis_any_device = (strcmp(device, \"any\") == 0);\n\tif (is_any_device) {\n\t\tif (handle->opt.promisc) {\n\t\t\thandle->opt.promisc = 0;\n\t\t\t/* Just a warning. */\n\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Promiscuous mode not supported on the \\\"any\\\" device\");\n\t\t\tstatus = PCAP_WARNING_PROMISC_NOTSUP;\n\t\t}\n\t}\n\n\t/* copy timeout value */\n\thandlep->timeout = handle->opt.timeout;\n\n\t/*\n\t * If we're in promiscuous mode, then we probably want\n\t * to see when the interface drops packets too, so get an\n\t * initial count from /proc/net/dev\n\t */\n\tif (handle->opt.promisc)\n\t\thandlep->proc_dropped = linux_if_drops(handlep->device);\n\n#ifdef HAVE_PF_PACKET_SOCKETS\n\t/*\n\t * Current Linux kernels use the protocol family PF_PACKET to\n\t * allow direct access to all packets on the network while\n\t * older kernels had a special socket type SOCK_PACKET to\n\t * implement this feature.\n\t * While this old implementation is kind of obsolete we need\n\t * to be compatible with older kernels for a while so we are\n\t * trying both methods with the newer method preferred.\n\t *\n\t * Try to activate with a PF_PACKET socket. If the \"any\" device\n\t * was specified, we open a SOCK_DGRAM socket for the cooked\n\t * interface, otherwise we first try a SOCK_RAW socket for\n\t * the raw interface.\n\t */\n\tret = activate_new(handle, is_any_device);\n\tif (ret < 0) {\n\t\tif (ret != PCAP_ERROR_NO_PF_PACKET_SOCKETS) {\n\t\t\t/*\n\t\t\t * Fatal error; the return value is the error code,\n\t\t\t * and handle->errbuf has been set to an appropriate\n\t\t\t * error message.\n\t\t\t */\n\t\t\treturn ret;\n\t\t}\n\n\t\t/*\n\t\t * We don't support PF_PACKET/SOCK_whatever\n\t\t * sockets; try the old mechanism.\n\t\t */\n\t\tret = activate_old(handle, is_any_device);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * Both methods to open the packet socket\n\t\t\t * failed.\n\t\t\t *\n\t\t\t * Tidy up and report our failure\n\t\t\t * (handle->errbuf is expected to be set\n\t\t\t * by the functions above).\n\t\t\t */\n\t\t\tstatus = ret;\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n#ifdef HAVE_PACKET_RING\n\t\t/*\n\t\t * Success.\n\t\t * Try to use memory-mapped access.\n\t\t */\n\t\tswitch (activate_mmap(handle, &status)) {\n\n\t\tcase 1:\n\t\t\t/*\n\t\t\t * We succeeded.  status has been\n\t\t\t * set to the status to return,\n\t\t\t * which might be 0, or might be\n\t\t\t * a PCAP_WARNING_ value.\n\t\t\t *\n\t\t\t * Set the timeout to use in poll() before\n\t\t\t * returning.\n\t\t\t */\n\t\t\tset_poll_timeout(handlep);\n\t\t\treturn status;\n\n\t\tcase 0:\n\t\t\t/*\n\t\t\t * Kernel doesn't support it - just continue\n\t\t\t * with non-memory-mapped access.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tcase -1:\n\t\t\t/*\n\t\t\t * We failed to set up to use it, or the\n\t\t\t * kernel supports it, but we failed to\n\t\t\t * enable it.  status has been set to the\n\t\t\t * error status to return and, if it's\n\t\t\t * PCAP_ERROR, handle->errbuf contains\n\t\t\t * the error message.\n\t\t\t */\n\t\t\tgoto fail;\n\t\t}\n#endif /* HAVE_PACKET_RING */\n\t}\n#else /* HAVE_PF_PACKET_SOCKETS */\n\t/*\n\t * We don't support PF_PACKET/SOCK_whatever sockets, so we must\n\t * try the old mechanism.\n\t */\n\tret = activate_old(handle, is_any_device);\n\tif (ret != 0) {\n\t\t/*\n\t\t * That failed.\n\t\t *\n\t\t * Tidy up and report our failure\n\t\t * (handle->errbuf is expected to be set\n\t\t * by the functions above).\n\t\t */\n\t\tstatus = ret;\n\t\tgoto fail;\n\t}\n#endif /* HAVE_PF_PACKET_SOCKETS */\n\n\t/*\n\t * We set up the socket, but not with memory-mapped access.\n\t */\n\tif (handle->opt.buffer_size != 0) {\n\t\t/*\n\t\t * Set the socket buffer size to the specified value.\n\t\t */\n\t\tif (setsockopt(handle->fd, SOL_SOCKET, SO_RCVBUF,\n\t\t    &handle->opt.buffer_size,\n\t\t    sizeof(handle->opt.buffer_size)) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"SO_RCVBUF\");\n\t\t\tstatus = PCAP_ERROR;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t/* Allocate the buffer */\n\n\thandle->buffer\t = malloc(handle->bufsize + handle->offset);\n\tif (!handle->buffer) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tstatus = PCAP_ERROR;\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * \"handle->fd\" is a socket, so \"select()\" and \"poll()\"\n\t * should work on it.\n\t */\n\thandle->selectable_fd = handle->fd;\n\n\treturn status;\n\nfail:\n\tpcap_cleanup_linux(handle);\n\treturn status;\n}",
          "fn_code_pos": [
            [
              1579,
              0
            ],
            [
              1807,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_activate_linux",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_read_linux(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char *user)\n{\n\t/*\n\t * Currently, on Linux only one packet is delivered per read,\n\t * so we don't loop.\n\t */\n\treturn pcap_read_packet(handle, callback, user);\n}",
          "fn_code_pos": [
            [
              1814,
              0
            ],
            [
              1822,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_linux",
            "parameters": {
              "handle": "pcap_t",
              "max_packets": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_set_datalink_linux(pcap_t *handle, int dlt)\n{\n\thandle->linktype = dlt;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1824,
              0
            ],
            [
              1829,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_datalink_linux",
            "parameters": {
              "handle": "pcap_t",
              "dlt": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static inline int\nlinux_check_direction(const pcap_t *handle, const struct sockaddr_ll *sll)\n{\n\tstruct pcap_linux\t*handlep = handle->priv;\n\n\tif (sll->sll_pkttype == PACKET_OUTGOING) {\n\t\t/*\n\t\t * Outgoing packet.\n\t\t * If this is from the loopback device, reject it;\n\t\t * we'll see the packet as an incoming packet as well,\n\t\t * and we don't want to see it twice.\n\t\t */\n\t\tif (sll->sll_ifindex == handlep->lo_ifindex)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If this is an outgoing CAN or CAN FD frame, and\n\t\t * the user doesn't only want outgoing packets,\n\t\t * reject it; CAN devices and drivers, and the CAN\n\t\t * stack, always arrange to loop back transmitted\n\t\t * packets, so they also appear as incoming packets.\n\t\t * We don't want duplicate packets, and we can't\n\t\t * easily distinguish packets looped back by the CAN\n\t\t * layer than those received by the CAN layer, so we\n\t\t * eliminate this packet instead.\n\t\t */\n\t\tif ((sll->sll_protocol == LINUX_SLL_P_CAN ||\n\t\t     sll->sll_protocol == LINUX_SLL_P_CANFD) &&\n\t\t     handle->direction != PCAP_D_OUT)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * If the user only wants incoming packets, reject it.\n\t\t */\n\t\tif (handle->direction == PCAP_D_IN)\n\t\t\treturn 0;\n\t} else {\n\t\t/*\n\t\t * Incoming packet.\n\t\t * If the user only wants outgoing packets, reject it.\n\t\t */\n\t\tif (handle->direction == PCAP_D_OUT)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              1836,
              0
            ],
            [
              1881,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "linux_check_direction",
            "parameters": {
              "handle": "pcap_t",
              "sll": "struct sockaddr_ll"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_read_packet(pcap_t *handle, pcap_handler callback, u_char *userdata)\n{\n\tstruct pcap_linux\t*handlep = handle->priv;\n\tu_char\t\t\t*bp;\n\tint\t\t\toffset;\n#ifdef HAVE_PF_PACKET_SOCKETS\n\tstruct sockaddr_ll\tfrom;\n#else\n\tstruct sockaddr\t\tfrom;\n#endif\n#if defined(HAVE_PACKET_AUXDATA) && defined(HAVE_STRUCT_TPACKET_AUXDATA_TP_VLAN_TCI)\n\tstruct iovec\t\tiov;\n\tstruct msghdr\t\tmsg;\n\tstruct cmsghdr\t\t*cmsg;\n\tunion {\n\t\tstruct cmsghdr\tcmsg;\n\t\tchar\t\tbuf[CMSG_SPACE(sizeof(struct tpacket_auxdata))];\n\t} cmsg_buf;\n#else /* defined(HAVE_PACKET_AUXDATA) && defined(HAVE_STRUCT_TPACKET_AUXDATA_TP_VLAN_TCI) */\n\tsocklen_t\t\tfromlen;\n#endif /* defined(HAVE_PACKET_AUXDATA) && defined(HAVE_STRUCT_TPACKET_AUXDATA_TP_VLAN_TCI) */\n\tssize_t\t\t\tpacket_len;\n\tint\t\t\tcaplen;\n\tstruct pcap_pkthdr\tpcap_header;\n\n        struct bpf_aux_data     aux_data;\n#ifdef HAVE_PF_PACKET_SOCKETS\n\t/*\n\t * If this is a cooked device, leave extra room for a\n\t * fake packet header.\n\t */\n\tif (handlep->cooked) {\n\t\tif (handle->linktype == DLT_LINUX_SLL2)\n\t\t\toffset = SLL2_HDR_LEN;\n\t\telse\n\t\t\toffset = SLL_HDR_LEN;\n\t} else\n\t\toffset = 0;\n#else\n\t/*\n\t * This system doesn't have PF_PACKET sockets, so it doesn't\n\t * support cooked devices.\n\t */\n\toffset = 0;\n#endif\n\n\t/*\n\t * Receive a single packet from the kernel.\n\t * We ignore EINTR, as that might just be due to a signal\n\t * being delivered - if the signal should interrupt the\n\t * loop, the signal handler should call pcap_breakloop()\n\t * to set handle->break_loop (we ignore it on other\n\t * platforms as well).\n\t * We also ignore ENETDOWN, so that we can continue to\n\t * capture traffic if the interface goes down and comes\n\t * back up again; comments in the kernel indicate that\n\t * we'll just block waiting for packets if we try to\n\t * receive from a socket that delivered ENETDOWN, and,\n\t * if we're using a memory-mapped buffer, we won't even\n\t * get notified of \"network down\" events.\n\t */\n\tbp = (u_char *)handle->buffer + handle->offset;\n\n#if defined(HAVE_PACKET_AUXDATA) && defined(HAVE_STRUCT_TPACKET_AUXDATA_TP_VLAN_TCI)\n\tmsg.msg_name\t\t= &from;\n\tmsg.msg_namelen\t\t= sizeof(from);\n\tmsg.msg_iov\t\t= &iov;\n\tmsg.msg_iovlen\t\t= 1;\n\tmsg.msg_control\t\t= &cmsg_buf;\n\tmsg.msg_controllen\t= sizeof(cmsg_buf);\n\tmsg.msg_flags\t\t= 0;\n\n\tiov.iov_len\t\t= handle->bufsize - offset;\n\tiov.iov_base\t\t= bp + offset;\n#endif /* defined(HAVE_PACKET_AUXDATA) && defined(HAVE_STRUCT_TPACKET_AUXDATA_TP_VLAN_TCI) */\n\n\tdo {\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t */\n\t\tif (handle->break_loop) {\n\t\t\t/*\n\t\t\t * Yes - clear the flag that indicates that it has,\n\t\t\t * and return PCAP_ERROR_BREAK as an indication that\n\t\t\t * we were told to break out of the loop.\n\t\t\t */\n\t\t\thandle->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\n#if defined(HAVE_PACKET_AUXDATA) && defined(HAVE_STRUCT_TPACKET_AUXDATA_TP_VLAN_TCI)\n\t\tpacket_len = recvmsg(handle->fd, &msg, MSG_TRUNC);\n#else /* defined(HAVE_PACKET_AUXDATA) && defined(HAVE_STRUCT_TPACKET_AUXDATA_TP_VLAN_TCI) */\n\t\tfromlen = sizeof(from);\n\t\tpacket_len = recvfrom(\n\t\t\thandle->fd, bp + offset,\n\t\t\thandle->bufsize - offset, MSG_TRUNC,\n\t\t\t(struct sockaddr *) &from, &fromlen);\n#endif /* defined(HAVE_PACKET_AUXDATA) && defined(HAVE_STRUCT_TPACKET_AUXDATA_TP_VLAN_TCI) */\n\t} while (packet_len == -1 && errno == EINTR);\n\n\t/* Check if an error occured */\n\n\tif (packet_len == -1) {\n\t\tswitch (errno) {\n\n\t\tcase EAGAIN:\n\t\t\treturn 0;\t/* no packet there */\n\n\t\tcase ENETDOWN:\n\t\t\t/*\n\t\t\t * The device on which we're capturing went away.\n\t\t\t *\n\t\t\t * XXX - we should really return\n\t\t\t * PCAP_ERROR_IFACE_NOT_UP, but pcap_dispatch()\n\t\t\t * etc. aren't defined to return that.\n\t\t\t */\n\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\"The interface went down\");\n\t\t\treturn PCAP_ERROR;\n\n\t\tdefault:\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"recvfrom\");\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t}\n\n#ifdef HAVE_PF_PACKET_SOCKETS\n\tif (!handlep->sock_packet) {\n\t\t/*\n\t\t * Unfortunately, there is a window between socket() and\n\t\t * bind() where the kernel may queue packets from any\n\t\t * interface.  If we're bound to a particular interface,\n\t\t * discard packets not from that interface.\n\t\t *\n\t\t * (If socket filters are supported, we could do the\n\t\t * same thing we do when changing the filter; however,\n\t\t * that won't handle packet sockets without socket\n\t\t * filter support, and it's a bit more complicated.\n\t\t * It would save some instructions per packet, however.)\n\t\t */\n\t\tif (handlep->ifindex != -1 &&\n\t\t    from.sll_ifindex != handlep->ifindex)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Do checks based on packet direction.\n\t\t * We can only do this if we're using PF_PACKET; the\n\t\t * address returned for SOCK_PACKET is a \"sockaddr_pkt\"\n\t\t * which lacks the relevant packet type information.\n\t\t */\n\t\tif (!linux_check_direction(handle, &from))\n\t\t\treturn 0;\n\t}\n#endif\n\n#ifdef HAVE_PF_PACKET_SOCKETS\n\t/*\n\t * If this is a cooked device, fill in the fake packet header.\n\t */\n\tif (handlep->cooked) {\n\t\t/*\n\t\t * Add the length of the fake header to the length\n\t\t * of packet data we read.\n\t\t */\n\t\tif (handle->linktype == DLT_LINUX_SLL2) {\n\t\t\tstruct sll2_header\t*hdrp;\n\n\t\t\tpacket_len += SLL2_HDR_LEN;\n\n\t\t\thdrp = (struct sll2_header *)bp;\n\t\t\thdrp->sll2_protocol = from.sll_protocol;\n\t\t\thdrp->sll2_reserved_mbz = 0;\n\t\t\thdrp->sll2_if_index = htonl(from.sll_ifindex);\n\t\t\thdrp->sll2_hatype = htons(from.sll_hatype);\n\t\t\thdrp->sll2_pkttype = from.sll_pkttype;\n\t\t\thdrp->sll2_halen = from.sll_halen;\n\t\t\tmemcpy(hdrp->sll2_addr, from.sll_addr,\n\t\t\t    (from.sll_halen > SLL_ADDRLEN) ?\n\t\t\t      SLL_ADDRLEN :\n\t\t\t      from.sll_halen);\n\t\t} else {\n\t\t\tstruct sll_header\t*hdrp;\n\n\t\t\tpacket_len += SLL_HDR_LEN;\n\n\t\t\thdrp = (struct sll_header *)bp;\n\t\t\thdrp->sll_pkttype = htons(from.sll_pkttype);\n\t\t\thdrp->sll_hatype = htons(from.sll_hatype);\n\t\t\thdrp->sll_halen = htons(from.sll_halen);\n\t\t\tmemcpy(hdrp->sll_addr, from.sll_addr,\n\t\t\t    (from.sll_halen > SLL_ADDRLEN) ?\n\t\t\t      SLL_ADDRLEN :\n\t\t\t      from.sll_halen);\n\t\t\thdrp->sll_protocol = from.sll_protocol;\n\t\t}\n\t}\n\n\t/*\n\t * Start out with no VLAN information.\n\t */\n\taux_data.vlan_tag_present = 0;\n\taux_data.vlan_tag = 0;\n#if defined(HAVE_PACKET_AUXDATA) && defined(HAVE_STRUCT_TPACKET_AUXDATA_TP_VLAN_TCI)\n\tif (handlep->vlan_offset != -1) {\n\t\tfor (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\t\t\tstruct tpacket_auxdata *aux;\n\t\t\tsize_t len;\n\t\t\tstruct vlan_tag *tag;\n\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct tpacket_auxdata)) ||\n\t\t\t    cmsg->cmsg_level != SOL_PACKET ||\n\t\t\t    cmsg->cmsg_type != PACKET_AUXDATA) {\n\t\t\t\t/*\n\t\t\t\t * This isn't a PACKET_AUXDATA auxiliary\n\t\t\t\t * data item.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\taux = (struct tpacket_auxdata *)CMSG_DATA(cmsg);\n\t\t\tif (!VLAN_VALID(aux, aux)) {\n\t\t\t\t/*\n\t\t\t\t * There is no VLAN information in the\n\t\t\t\t * auxiliary data.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlen = (size_t)packet_len > iov.iov_len ? iov.iov_len : (u_int)packet_len;\n\t\t\tif (len < (size_t)handlep->vlan_offset)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Move everything in the header, except the\n\t\t\t * type field, down VLAN_TAG_LEN bytes, to\n\t\t\t * allow us to insert the VLAN tag between\n\t\t\t * that stuff and the type field.\n\t\t\t */\n\t\t\tbp -= VLAN_TAG_LEN;\n\t\t\tmemmove(bp, bp + VLAN_TAG_LEN, handlep->vlan_offset);\n\n\t\t\t/*\n\t\t\t * Now insert the tag.\n\t\t\t */\n\t\t\ttag = (struct vlan_tag *)(bp + handlep->vlan_offset);\n\t\t\ttag->vlan_tpid = htons(VLAN_TPID(aux, aux));\n\t\t\ttag->vlan_tci = htons(aux->tp_vlan_tci);\n\n\t\t\t/*\n\t\t\t * Save a flag indicating that we have a VLAN tag,\n\t\t\t * and the VLAN TCI, to bpf_aux_data struct for\n\t\t\t * use by the BPF filter if we're doing the\n\t\t\t * filtering in userland.\n\t\t\t */\n\t\t\taux_data.vlan_tag_present = 1;\n\t\t\taux_data.vlan_tag = htons(aux->tp_vlan_tci) & 0x0fff;\n\n\t\t\t/*\n\t\t\t * Add the tag to the packet lengths.\n\t\t\t */\n\t\t\tpacket_len += VLAN_TAG_LEN;\n\t\t}\n\t}\n#endif /* defined(HAVE_PACKET_AUXDATA) && defined(HAVE_STRUCT_TPACKET_AUXDATA_TP_VLAN_TCI) */\n#endif /* HAVE_PF_PACKET_SOCKETS */\n\n\t/*\n\t * XXX: According to the kernel source we should get the real\n\t * packet len if calling recvfrom with MSG_TRUNC set. It does\n\t * not seem to work here :(, but it is supported by this code\n\t * anyway.\n\t * To be honest the code RELIES on that feature so this is really\n\t * broken with 2.2.x kernels.\n\t * I spend a day to figure out what's going on and I found out\n\t * that the following is happening:\n\t *\n\t * The packet comes from a random interface and the packet_rcv\n\t * hook is called with a clone of the packet. That code inserts\n\t * the packet into the receive queue of the packet socket.\n\t * If a filter is attached to that socket that filter is run\n\t * first - and there lies the problem. The default filter always\n\t * cuts the packet at the snaplen:\n\t *\n\t * # tcpdump -d\n\t * (000) ret      #68\n\t *\n\t * So the packet filter cuts down the packet. The recvfrom call\n\t * says \"hey, it's only 68 bytes, it fits into the buffer\" with\n\t * the result that we don't get the real packet length. This\n\t * is valid at least until kernel 2.2.17pre6.\n\t *\n\t * We currently handle this by making a copy of the filter\n\t * program, fixing all \"ret\" instructions with non-zero\n\t * operands to have an operand of MAXIMUM_SNAPLEN so that the\n\t * filter doesn't truncate the packet, and supplying that modified\n\t * filter to the kernel.\n\t */\n\n\tcaplen = (int)packet_len;\n\tif (caplen > handle->snapshot)\n\t\tcaplen = handle->snapshot;\n\n\t/* Run the packet filter if not using kernel filter */\n\tif (handlep->filter_in_userland && handle->fcode.bf_insns) {\n\t\tif (pcap_filter_with_aux_data(handle->fcode.bf_insns, bp,\n\t\t    (int)packet_len, caplen, &aux_data) == 0) {\n\t\t\t/* rejected by filter */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Fill in our own header data */\n\n\t/* get timestamp for this packet */\n#if defined(SIOCGSTAMPNS) && defined(SO_TIMESTAMPNS)\n\tif (handle->opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO) {\n\t\tif (ioctl(handle->fd, SIOCGSTAMPNS, &pcap_header.ts) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"SIOCGSTAMPNS\");\n\t\t\treturn PCAP_ERROR;\n\t\t}\n        } else\n#endif\n\t{\n\t\tif (ioctl(handle->fd, SIOCGSTAMP, &pcap_header.ts) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"SIOCGSTAMP\");\n\t\t\treturn PCAP_ERROR;\n\t\t}\n        }\n\n\tpcap_header.caplen\t= caplen;\n\tpcap_header.len\t\t= (bpf_u_int32)packet_len;\n\n\t/*\n\t * Count the packet.\n\t *\n\t * Arguably, we should count them before we check the filter,\n\t * as on many other platforms \"ps_recv\" counts packets\n\t * handed to the filter rather than packets that passed\n\t * the filter, but if filtering is done in the kernel, we\n\t * can't get a count of packets that passed the filter,\n\t * and that would mean the meaning of \"ps_recv\" wouldn't\n\t * be the same on all Linux systems.\n\t *\n\t * XXX - it's not the same on all systems in any case;\n\t * ideally, we should have a \"get the statistics\" call\n\t * that supplies more counts and indicates which of them\n\t * it supplies, so that we supply a count of packets\n\t * handed to the filter only on platforms where that\n\t * information is available.\n\t *\n\t * We count them here even if we can get the packet count\n\t * from the kernel, as we can only determine at run time\n\t * whether we'll be able to get it from the kernel (if\n\t * HAVE_STRUCT_TPACKET_STATS isn't defined, we can't get it from\n\t * the kernel, but if it is defined, the library might\n\t * have been built with a 2.4 or later kernel, but we\n\t * might be running on a 2.2[.x] kernel without Alexey\n\t * Kuznetzov's turbopacket patches, and thus the kernel\n\t * might not be able to supply those statistics).  We\n\t * could, I guess, try, when opening the socket, to get\n\t * the statistics, and if we can not increment the count\n\t * here, but it's not clear that always incrementing\n\t * the count is more expensive than always testing a flag\n\t * in memory.\n\t *\n\t * We keep the count in \"handlep->packets_read\", and use that\n\t * for \"ps_recv\" if we can't get the statistics from the kernel.\n\t * We do that because, if we *can* get the statistics from\n\t * the kernel, we use \"handlep->stat.ps_recv\" and\n\t * \"handlep->stat.ps_drop\" as running counts, as reading the\n\t * statistics from the kernel resets the kernel statistics,\n\t * and if we directly increment \"handlep->stat.ps_recv\" here,\n\t * that means it will count packets *twice* on systems where\n\t * we can get kernel statistics - once here, and once in\n\t * pcap_stats_linux().\n\t */\n\thandlep->packets_read++;\n\n\t/* Call the user supplied callback function */\n\tcallback(userdata, &pcap_header, bp);\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              1888,
              0
            ],
            [
              2275,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_packet",
            "parameters": {
              "handle": "pcap_t",
              "callback": "pcap_handler",
              "userdata": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_inject_linux(pcap_t *handle, const void *buf, int size)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tint ret;\n\n#ifdef HAVE_PF_PACKET_SOCKETS\n\tif (!handlep->sock_packet) {\n\t\t/* PF_PACKET socket */\n\t\tif (handlep->ifindex == -1) {\n\t\t\t/*\n\t\t\t * We don't support sending on the \"any\" device.\n\t\t\t */\n\t\t\tpcap_strlcpy(handle->errbuf,\n\t\t\t    \"Sending packets isn't supported on the \\\"any\\\" device\",\n\t\t\t    PCAP_ERRBUF_SIZE);\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif (handlep->cooked) {\n\t\t\t/*\n\t\t\t * We don't support sending on cooked-mode sockets.\n\t\t\t *\n\t\t\t * XXX - how do you send on a bound cooked-mode\n\t\t\t * socket?\n\t\t\t * Is a \"sendto()\" required there?\n\t\t\t */\n\t\t\tpcap_strlcpy(handle->errbuf,\n\t\t\t    \"Sending packets isn't supported in cooked mode\",\n\t\t\t    PCAP_ERRBUF_SIZE);\n\t\t\treturn (-1);\n\t\t}\n\t}\n#endif\n\n\tret = (int)send(handle->fd, buf, size, 0);\n\tif (ret == -1) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"send\");\n\t\treturn (-1);\n\t}\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              2277,
              0
            ],
            [
              2319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject_linux",
            "parameters": {
              "handle": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_stats_linux(pcap_t *handle, struct pcap_stat *stats)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n#ifdef HAVE_STRUCT_TPACKET_STATS\n#ifdef HAVE_TPACKET3\n\t/*\n\t * For sockets using TPACKET_V1 or TPACKET_V2, the extra\n\t * stuff at the end of a struct tpacket_stats_v3 will not\n\t * be filled in, and we don't look at it so this is OK even\n\t * for those sockets.  In addition, the PF_PACKET socket\n\t * code in the kernel only uses the length parameter to\n\t * compute how much data to copy out and to indicate how\n\t * much data was copied out, so it's OK to base it on the\n\t * size of a struct tpacket_stats.\n\t *\n\t * XXX - it's probably OK, in fact, to just use a\n\t * struct tpacket_stats for V3 sockets, as we don't\n\t * care about the tp_freeze_q_cnt stat.\n\t */\n\tstruct tpacket_stats_v3 kstats;\n#else /* HAVE_TPACKET3 */\n\tstruct tpacket_stats kstats;\n#endif /* HAVE_TPACKET3 */\n\tsocklen_t len = sizeof (struct tpacket_stats);\n#endif /* HAVE_STRUCT_TPACKET_STATS */\n\n\tlong if_dropped = 0;\n\n\t/*\n\t *\tTo fill in ps_ifdrop, we parse /proc/net/dev for the number\n\t */\n\tif (handle->opt.promisc)\n\t{\n\t\tif_dropped = handlep->proc_dropped;\n\t\thandlep->proc_dropped = linux_if_drops(handlep->device);\n\t\thandlep->stat.ps_ifdrop += (handlep->proc_dropped - if_dropped);\n\t}\n\n#ifdef HAVE_STRUCT_TPACKET_STATS\n\t/*\n\t * Try to get the packet counts from the kernel.\n\t */\n\tif (getsockopt(handle->fd, SOL_PACKET, PACKET_STATISTICS,\n\t\t\t&kstats, &len) > -1) {\n\t\t/*\n\t\t * On systems where the PACKET_STATISTICS \"getsockopt()\"\n\t\t * argument is supported on PF_PACKET sockets:\n\t\t *\n\t\t *\t\"ps_recv\" counts only packets that *passed* the\n\t\t *\tfilter, not packets that didn't pass the filter.\n\t\t *\tThis includes packets later dropped because we\n\t\t *\tran out of buffer space.\n\t\t *\n\t\t *\t\"ps_drop\" counts packets dropped because we ran\n\t\t *\tout of buffer space.  It doesn't count packets\n\t\t *\tdropped by the interface driver.  It counts only\n\t\t *\tpackets that passed the filter.\n\t\t *\n\t\t *\tSee above for ps_ifdrop.\n\t\t *\n\t\t *\tBoth statistics include packets not yet read from\n\t\t *\tthe kernel by libpcap, and thus not yet seen by\n\t\t *\tthe application.\n\t\t *\n\t\t * In \"linux/net/packet/af_packet.c\", at least in the\n\t\t * 2.4.9 kernel, \"tp_packets\" is incremented for every\n\t\t * packet that passes the packet filter *and* is\n\t\t * successfully queued on the socket; \"tp_drops\" is\n\t\t * incremented for every packet dropped because there's\n\t\t * not enough free space in the socket buffer.\n\t\t *\n\t\t * When the statistics are returned for a PACKET_STATISTICS\n\t\t * \"getsockopt()\" call, \"tp_drops\" is added to \"tp_packets\",\n\t\t * so that \"tp_packets\" counts all packets handed to\n\t\t * the PF_PACKET socket, including packets dropped because\n\t\t * there wasn't room on the socket buffer - but not\n\t\t * including packets that didn't pass the filter.\n\t\t *\n\t\t * In the BSD BPF, the count of received packets is\n\t\t * incremented for every packet handed to BPF, regardless\n\t\t * of whether it passed the filter.\n\t\t *\n\t\t * We can't make \"pcap_stats()\" work the same on both\n\t\t * platforms, but the best approximation is to return\n\t\t * \"tp_packets\" as the count of packets and \"tp_drops\"\n\t\t * as the count of drops.\n\t\t *\n\t\t * Keep a running total because each call to\n\t\t *    getsockopt(handle->fd, SOL_PACKET, PACKET_STATISTICS, ....\n\t\t * resets the counters to zero.\n\t\t */\n\t\thandlep->stat.ps_recv += kstats.tp_packets;\n\t\thandlep->stat.ps_drop += kstats.tp_drops;\n\t\t*stats = handlep->stat;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If the error was EOPNOTSUPP, fall through, so that\n\t\t * if you build the library on a system with\n\t\t * \"struct tpacket_stats\" and run it on a system\n\t\t * that doesn't, it works as it does if the library\n\t\t * is built on a system without \"struct tpacket_stats\".\n\t\t */\n\t\tif (errno != EOPNOTSUPP) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"pcap_stats\");\n\t\t\treturn -1;\n\t\t}\n\t}\n#endif\n\t/*\n\t * On systems where the PACKET_STATISTICS \"getsockopt()\" argument\n\t * is not supported on PF_PACKET sockets:\n\t *\n\t *\t\"ps_recv\" counts only packets that *passed* the filter,\n\t *\tnot packets that didn't pass the filter.  It does not\n\t *\tcount packets dropped because we ran out of buffer\n\t *\tspace.\n\t *\n\t *\t\"ps_drop\" is not supported.\n\t *\n\t *\t\"ps_ifdrop\" is supported. It will return the number\n\t *\tof drops the interface reports in /proc/net/dev,\n\t *\tif that is available.\n\t *\n\t *\t\"ps_recv\" doesn't include packets not yet read from\n\t *\tthe kernel by libpcap.\n\t *\n\t * We maintain the count of packets processed by libpcap in\n\t * \"handlep->packets_read\", for reasons described in the comment\n\t * at the end of pcap_read_packet().  We have no idea how many\n\t * packets were dropped by the kernel buffers -- but we know\n\t * how many the interface dropped, so we can return that.\n\t */\n\n\tstats->ps_recv = handlep->packets_read;\n\tstats->ps_drop = 0;\n\tstats->ps_ifdrop = handlep->stat.ps_ifdrop;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              2329,
              0
            ],
            [
              2471,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_linux",
            "parameters": {
              "handle": "pcap_t",
              "stats": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nadd_linux_if(pcap_if_list_t *devlistp, const char *ifname, int fd, char *errbuf)\n{\n\tconst char *p;\n\tchar name[512];\t/* XXX - pick a size */\n\tchar *q, *saveq;\n\tstruct ifreq ifrflags;\n\n\t/*\n\t * Get the interface name.\n\t */\n\tp = ifname;\n\tq = &name[0];\n\twhile (*p != '\\0' && isascii(*p) && !isspace(*p)) {\n\t\tif (*p == ':') {\n\t\t\t/*\n\t\t\t * This could be the separator between a\n\t\t\t * name and an alias number, or it could be\n\t\t\t * the separator between a name with no\n\t\t\t * alias number and the next field.\n\t\t\t *\n\t\t\t * If there's a colon after digits, it\n\t\t\t * separates the name and the alias number,\n\t\t\t * otherwise it separates the name and the\n\t\t\t * next field.\n\t\t\t */\n\t\t\tsaveq = q;\n\t\t\twhile (isascii(*p) && isdigit(*p))\n\t\t\t\t*q++ = *p++;\n\t\t\tif (*p != ':') {\n\t\t\t\t/*\n\t\t\t\t * That was the next field,\n\t\t\t\t * not the alias number.\n\t\t\t\t */\n\t\t\t\tq = saveq;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else\n\t\t\t*q++ = *p++;\n\t}\n\t*q = '\\0';\n\n\t/*\n\t * Get the flags for this interface.\n\t */\n\tpcap_strlcpy(ifrflags.ifr_name, name, sizeof(ifrflags.ifr_name));\n\tif (ioctl(fd, SIOCGIFFLAGS, (char *)&ifrflags) < 0) {\n\t\tif (errno == ENXIO || errno == ENODEV)\n\t\t\treturn (0);\t/* device doesn't actually exist - ignore it */\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCGIFFLAGS: %.*s\",\n\t\t    (int)sizeof(ifrflags.ifr_name),\n\t\t    ifrflags.ifr_name);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Add an entry for this interface, with no addresses, if it's\n\t * not already in the list.\n\t */\n\tif (find_or_add_if(devlistp, name, ifrflags.ifr_flags,\n\t    get_if_flags, errbuf) == NULL) {\n\t\t/*\n\t\t * Failure.\n\t\t */\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2473,
              0
            ],
            [
              2542,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_linux_if",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "ifname": "char",
              "fd": "int",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nscan_sys_class_net(pcap_if_list_t *devlistp, char *errbuf)\n{\n\tDIR *sys_class_net_d;\n\tint fd;\n\tstruct dirent *ent;\n\tchar subsystem_path[PATH_MAX+1];\n\tstruct stat statb;\n\tint ret = 1;\n\n\tsys_class_net_d = opendir(\"/sys/class/net\");\n\tif (sys_class_net_d == NULL) {\n\t\t/*\n\t\t * Don't fail if it doesn't exist at all.\n\t\t */\n\t\tif (errno == ENOENT)\n\t\t\treturn (0);\n\n\t\t/*\n\t\t * Fail if we got some other error.\n\t\t */\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't open /sys/class/net\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Create a socket from which to fetch interface information.\n\t */\n\tfd = socket(PF_UNIX, SOCK_RAW, 0);\n\tif (fd < 0) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"socket\");\n\t\t(void)closedir(sys_class_net_d);\n\t\treturn (-1);\n\t}\n\n\tfor (;;) {\n\t\terrno = 0;\n\t\tent = readdir(sys_class_net_d);\n\t\tif (ent == NULL) {\n\t\t\t/*\n\t\t\t * Error or EOF; if errno != 0, it's an error.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Ignore \".\" and \"..\".\n\t\t */\n\t\tif (strcmp(ent->d_name, \".\") == 0 ||\n\t\t    strcmp(ent->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Ignore plain files; they do not have subdirectories\n\t\t * and thus have no attributes.\n\t\t */\n\t\tif (ent->d_type == DT_REG)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Is there an \"ifindex\" file under that name?\n\t\t * (We don't care whether it's a directory or\n\t\t * a symlink; older kernels have directories\n\t\t * for devices, newer kernels have symlinks to\n\t\t * directories.)\n\t\t */\n\t\tpcap_snprintf(subsystem_path, sizeof subsystem_path,\n\t\t    \"/sys/class/net/%s/ifindex\", ent->d_name);\n\t\tif (lstat(subsystem_path, &statb) != 0) {\n\t\t\t/*\n\t\t\t * Stat failed.  Either there was an error\n\t\t\t * other than ENOENT, and we don't know if\n\t\t\t * this is an interface, or it's ENOENT,\n\t\t\t * and either some part of \"/sys/class/net/{if}\"\n\t\t\t * disappeared, in which case it probably means\n\t\t\t * the interface disappeared, or there's no\n\t\t\t * \"ifindex\" file, which means it's not a\n\t\t\t * network interface.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Attempt to add the interface.\n\t\t */\n\t\tif (add_linux_if(devlistp, &ent->d_name[0], fd, errbuf) == -1) {\n\t\t\t/* Fail. */\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret != -1) {\n\t\t/*\n\t\t * Well, we didn't fail for any other reason; did we\n\t\t * fail due to an error reading the directory?\n\t\t */\n\t\tif (errno != 0) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"Error reading /sys/class/net\");\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\t(void)close(fd);\n\t(void)closedir(sys_class_net_d);\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              2560,
              0
            ],
            [
              2668,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "scan_sys_class_net",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nscan_proc_net_dev(pcap_if_list_t *devlistp, char *errbuf)\n{\n\tFILE *proc_net_f;\n\tint fd;\n\tchar linebuf[512];\n\tint linenum;\n\tchar *p;\n\tint ret = 0;\n\n\tproc_net_f = fopen(\"/proc/net/dev\", \"r\");\n\tif (proc_net_f == NULL) {\n\t\t/*\n\t\t * Don't fail if it doesn't exist at all.\n\t\t */\n\t\tif (errno == ENOENT)\n\t\t\treturn (0);\n\n\t\t/*\n\t\t * Fail if we got some other error.\n\t\t */\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't open /proc/net/dev\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Create a socket from which to fetch interface information.\n\t */\n\tfd = socket(PF_UNIX, SOCK_RAW, 0);\n\tif (fd < 0) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"socket\");\n\t\t(void)fclose(proc_net_f);\n\t\treturn (-1);\n\t}\n\n\tfor (linenum = 1;\n\t    fgets(linebuf, sizeof linebuf, proc_net_f) != NULL; linenum++) {\n\t\t/*\n\t\t * Skip the first two lines - they're headers.\n\t\t */\n\t\tif (linenum <= 2)\n\t\t\tcontinue;\n\n\t\tp = &linebuf[0];\n\n\t\t/*\n\t\t * Skip leading white space.\n\t\t */\n\t\twhile (*p != '\\0' && isascii(*p) && isspace(*p))\n\t\t\tp++;\n\t\tif (*p == '\\0' || *p == '\\n')\n\t\t\tcontinue;\t/* blank line */\n\n\t\t/*\n\t\t * Attempt to add the interface.\n\t\t */\n\t\tif (add_linux_if(devlistp, p, fd, errbuf) == -1) {\n\t\t\t/* Fail. */\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret != -1) {\n\t\t/*\n\t\t * Well, we didn't fail for any other reason; did we\n\t\t * fail due to an error reading the file?\n\t\t */\n\t\tif (ferror(proc_net_f)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"Error reading /proc/net/dev\");\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\t(void)close(fd);\n\t(void)fclose(proc_net_f);\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              2677,
              0
            ],
            [
              2756,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "scan_proc_net_dev",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncan_be_bound(const char *name _U_)\n{\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              2766,
              0
            ],
            [
              2770,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "can_be_bound",
            "parameters": {
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nget_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)\n{\n\tint sock;\n\tFILE *fh;\n\tunsigned int arptype;\n\tstruct ifreq ifr;\n\tstruct ethtool_value info;\n\n\tif (*flags & PCAP_IF_LOOPBACK) {\n\t\t/*\n\t\t * Loopback devices aren't wireless, and \"connected\"/\n\t\t * \"disconnected\" doesn't apply to them.\n\t\t */\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\t\treturn 0;\n\t}\n\n\tsock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sock == -1) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,\n\t\t    \"Can't create socket to get ethtool information for %s\",\n\t\t    name);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * OK, what type of network is this?\n\t * In particular, is it wired or wireless?\n\t */\n\tif (is_wifi(sock, name)) {\n\t\t/*\n\t\t * Wi-Fi, hence wireless.\n\t\t */\n\t\t*flags |= PCAP_IF_WIRELESS;\n\t} else {\n\t\t/*\n\t\t * OK, what does /sys/class/net/{if}/type contain?\n\t\t * (We don't use that for Wi-Fi, as it'll report\n\t\t * \"Ethernet\", i.e. ARPHRD_ETHER, for non-monitor-\n\t\t * mode devices.)\n\t\t */\n\t\tchar *pathstr;\n\n\t\tif (asprintf(&pathstr, \"/sys/class/net/%s/type\", name) == -1) {\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: Can't generate path name string for /sys/class/net device\",\n\t\t\t    name);\n\t\t\tclose(sock);\n\t\t\treturn -1;\n\t\t}\n\t\tfh = fopen(pathstr, \"r\");\n\t\tif (fh != NULL) {\n\t\t\tif (fscanf(fh, \"%u\", &arptype) == 1) {\n\t\t\t\t/*\n\t\t\t\t * OK, we got an ARPHRD_ type; what is it?\n\t\t\t\t */\n\t\t\t\tswitch (arptype) {\n\n#ifdef ARPHRD_LOOPBACK\n\t\t\t\tcase ARPHRD_LOOPBACK:\n\t\t\t\t\t/*\n\t\t\t\t\t * These are types to which\n\t\t\t\t\t * \"connected\" and \"disconnected\"\n\t\t\t\t\t * don't apply, so don't bother\n\t\t\t\t\t * asking about it.\n\t\t\t\t\t *\n\t\t\t\t\t * XXX - add other types?\n\t\t\t\t\t */\n\t\t\t\t\tclose(sock);\n\t\t\t\t\tfclose(fh);\n\t\t\t\t\tfree(pathstr);\n\t\t\t\t\treturn 0;\n#endif\n\n\t\t\t\tcase ARPHRD_IRDA:\n\t\t\t\tcase ARPHRD_IEEE80211:\n\t\t\t\tcase ARPHRD_IEEE80211_PRISM:\n\t\t\t\tcase ARPHRD_IEEE80211_RADIOTAP:\n#ifdef ARPHRD_IEEE802154\n\t\t\t\tcase ARPHRD_IEEE802154:\n#endif\n#ifdef ARPHRD_IEEE802154_MONITOR\n\t\t\t\tcase ARPHRD_IEEE802154_MONITOR:\n#endif\n#ifdef ARPHRD_6LOWPAN\n\t\t\t\tcase ARPHRD_6LOWPAN:\n#endif\n\t\t\t\t\t/*\n\t\t\t\t\t * Various wireless types.\n\t\t\t\t\t */\n\t\t\t\t\t*flags |= PCAP_IF_WIRELESS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(fh);\n\t\t\tfree(pathstr);\n\t\t}\n\t}\n\n#ifdef ETHTOOL_GLINK\n\tmemset(&ifr, 0, sizeof(ifr));\n\tpcap_strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));\n\tinfo.cmd = ETHTOOL_GLINK;\n\tifr.ifr_data = (caddr_t)&info;\n\tif (ioctl(sock, SIOCETHTOOL, &ifr) == -1) {\n\t\tint save_errno = errno;\n\n\t\tswitch (save_errno) {\n\n\t\tcase EOPNOTSUPP:\n\t\tcase EINVAL:\n\t\t\t/*\n\t\t\t * OK, this OS version or driver doesn't support\n\t\t\t * asking for this information.\n\t\t\t * XXX - distinguish between \"this doesn't\n\t\t\t * support ethtool at all because it's not\n\t\t\t * that type of device\" vs. \"this doesn't\n\t\t\t * support ethtool even though it's that\n\t\t\t * type of device\", and return \"unknown\".\n\t\t\t */\n\t\t\t*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\t\t\tclose(sock);\n\t\t\treturn 0;\n\n\t\tcase ENODEV:\n\t\t\t/*\n\t\t\t * OK, no such device.\n\t\t\t * The user will find that out when they try to\n\t\t\t * activate the device; just say \"OK\" and\n\t\t\t * don't set anything.\n\t\t\t */\n\t\t\tclose(sock);\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Other error.\n\t\t\t */\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    save_errno,\n\t\t\t    \"%s: SIOCETHTOOL(ETHTOOL_GLINK) ioctl failed\",\n\t\t\t    name);\n\t\t\tclose(sock);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/*\n\t * Is it connected?\n\t */\n\tif (info.data) {\n\t\t/*\n\t\t * It's connected.\n\t\t */\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_CONNECTED;\n\t} else {\n\t\t/*\n\t\t * It's disconnected.\n\t\t */\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_DISCONNECTED;\n\t}\n#endif\n\n\tclose(sock);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              2775,
              0
            ],
            [
              2941,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_if_flags",
            "parameters": {
              "name": "char",
              "flags": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\tint ret;\n\n\t/*\n\t * Get the list of regular interfaces first.\n\t */\n\tif (pcap_findalldevs_interfaces(devlistp, errbuf, can_be_bound,\n\t    get_if_flags) == -1)\n\t\treturn (-1);\t/* failure */\n\n\t/*\n\t * Read \"/sys/class/net\", and add to the list of interfaces all\n\t * interfaces listed there that we don't already have, because,\n\t * on Linux, SIOCGIFCONF reports only interfaces with IPv4 addresses,\n\t * and even getifaddrs() won't return information about\n\t * interfaces with no addresses, so you need to read \"/sys/class/net\"\n\t * to get the names of the rest of the interfaces.\n\t */\n\tret = scan_sys_class_net(devlistp, errbuf);\n\tif (ret == -1)\n\t\treturn (-1);\t/* failed */\n\tif (ret == 0) {\n\t\t/*\n\t\t * No /sys/class/net; try reading /proc/net/dev instead.\n\t\t */\n\t\tif (scan_proc_net_dev(devlistp, errbuf) == -1)\n\t\t\treturn (-1);\n\t}\n\n\t/*\n\t * Add the \"any\" device.\n\t * As it refers to all network devices, not to any particular\n\t * network device, the notion of \"connected\" vs. \"disconnected\"\n\t * doesn't apply.\n\t */\n\tif (add_dev(devlistp, \"any\",\n\t    PCAP_IF_UP|PCAP_IF_RUNNING|PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,\n\t    any_descr, errbuf) == NULL)\n\t\treturn (-1);\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2943,
              0
            ],
            [
              2986,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_platform_finddevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setfilter_linux_common(pcap_t *handle, struct bpf_program *filter,\n    int is_mmapped)\n{\n\tstruct pcap_linux *handlep;\n#ifdef SO_ATTACH_FILTER\n\tstruct sock_fprog\tfcode;\n\tint\t\t\tcan_filter_in_kernel;\n\tint\t\t\terr = 0;\n#endif\n\n\tif (!handle)\n\t\treturn -1;\n\tif (!filter) {\n\t        pcap_strlcpy(handle->errbuf, \"setfilter: No filter specified\",\n\t\t\tPCAP_ERRBUF_SIZE);\n\t\treturn -1;\n\t}\n\n\thandlep = handle->priv;\n\n\t/* Make our private copy of the filter */\n\n\tif (install_bpf_program(handle, filter) < 0)\n\t\t/* install_bpf_program() filled in errbuf */\n\t\treturn -1;\n\n\t/*\n\t * Run user level packet filter by default. Will be overriden if\n\t * installing a kernel filter succeeds.\n\t */\n\thandlep->filter_in_userland = 1;\n\n\t/* Install kernel level filter if possible */\n\n#ifdef SO_ATTACH_FILTER\n#ifdef USHRT_MAX\n\tif (handle->fcode.bf_len > USHRT_MAX) {\n\t\t/*\n\t\t * fcode.len is an unsigned short for current kernel.\n\t\t * I have yet to see BPF-Code with that much\n\t\t * instructions but still it is possible. So for the\n\t\t * sake of correctness I added this check.\n\t\t */\n\t\tfprintf(stderr, \"Warning: Filter too complex for kernel\\n\");\n\t\tfcode.len = 0;\n\t\tfcode.filter = NULL;\n\t\tcan_filter_in_kernel = 0;\n\t} else\n#endif /* USHRT_MAX */\n\t{\n\t\t/*\n\t\t * Oh joy, the Linux kernel uses struct sock_fprog instead\n\t\t * of struct bpf_program and of course the length field is\n\t\t * of different size. Pointed out by Sebastian\n\t\t *\n\t\t * Oh, and we also need to fix it up so that all \"ret\"\n\t\t * instructions with non-zero operands have MAXIMUM_SNAPLEN\n\t\t * as the operand if we're not capturing in memory-mapped\n\t\t * mode, and so that, if we're in cooked mode, all memory-\n\t\t * reference instructions use special magic offsets in\n\t\t * references to the link-layer header and assume that the\n\t\t * link-layer payload begins at 0; \"fix_program()\" will do\n\t\t * that.\n\t\t */\n\t\tswitch (fix_program(handle, &fcode, is_mmapped)) {\n\n\t\tcase -1:\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Fatal error; just quit.\n\t\t\t * (The \"default\" case shouldn't happen; we\n\t\t\t * return -1 for that reason.)\n\t\t\t */\n\t\t\treturn -1;\n\n\t\tcase 0:\n\t\t\t/*\n\t\t\t * The program performed checks that we can't make\n\t\t\t * work in the kernel.\n\t\t\t */\n\t\t\tcan_filter_in_kernel = 0;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t/*\n\t\t\t * We have a filter that'll work in the kernel.\n\t\t\t */\n\t\t\tcan_filter_in_kernel = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * NOTE: at this point, we've set both the \"len\" and \"filter\"\n\t * fields of \"fcode\".  As of the 2.6.32.4 kernel, at least,\n\t * those are the only members of the \"sock_fprog\" structure,\n\t * so we initialize every member of that structure.\n\t *\n\t * If there is anything in \"fcode\" that is not initialized,\n\t * it is either a field added in a later kernel, or it's\n\t * padding.\n\t *\n\t * If a new field is added, this code needs to be updated\n\t * to set it correctly.\n\t *\n\t * If there are no other fields, then:\n\t *\n\t *\tif the Linux kernel looks at the padding, it's\n\t *\tbuggy;\n\t *\n\t *\tif the Linux kernel doesn't look at the padding,\n\t *\tthen if some tool complains that we're passing\n\t *\tuninitialized data to the kernel, then the tool\n\t *\tis buggy and needs to understand that it's just\n\t *\tpadding.\n\t */\n\tif (can_filter_in_kernel) {\n\t\tif ((err = set_kernel_filter(handle, &fcode)) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Installation succeded - using kernel filter,\n\t\t\t * so userland filtering not needed.\n\t\t\t */\n\t\t\thandlep->filter_in_userland = 0;\n\t\t}\n\t\telse if (err == -1)\t/* Non-fatal error */\n\t\t{\n\t\t\t/*\n\t\t\t * Print a warning if we weren't able to install\n\t\t\t * the filter for a reason other than \"this kernel\n\t\t\t * isn't configured to support socket filters.\n\t\t\t */\n\t\t\tif (errno != ENOPROTOOPT && errno != EOPNOTSUPP) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Warning: Kernel filter failed: %s\\n\",\n\t\t\t\t\tpcap_strerror(errno));\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If we're not using the kernel filter, get rid of any kernel\n\t * filter that might've been there before, e.g. because the\n\t * previous filter could work in the kernel, or because some other\n\t * code attached a filter to the socket by some means other than\n\t * calling \"pcap_setfilter()\".  Otherwise, the kernel filter may\n\t * filter out packets that would pass the new userland filter.\n\t */\n\tif (handlep->filter_in_userland) {\n\t\tif (reset_kernel_filter(handle) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"can't remove kernel filter\");\n\t\t\terr = -2;\t/* fatal error */\n\t\t}\n\t}\n\n\t/*\n\t * Free up the copy of the filter that was made by \"fix_program()\".\n\t */\n\tif (fcode.filter != NULL)\n\t\tfree(fcode.filter);\n\n\tif (err == -2)\n\t\t/* Fatal error */\n\t\treturn -1;\n#endif /* SO_ATTACH_FILTER */\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              2991,
              0
            ],
            [
              3161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_linux_common",
            "parameters": {
              "handle": "pcap_t",
              "filter": "struct bpf_program",
              "is_mmapped": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setfilter_linux(pcap_t *handle, struct bpf_program *filter)\n{\n\treturn pcap_setfilter_linux_common(handle, filter, 0);\n}",
          "fn_code_pos": [
            [
              3163,
              0
            ],
            [
              3167,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_linux",
            "parameters": {
              "handle": "pcap_t",
              "filter": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setdirection_linux(pcap_t *handle, pcap_direction_t d)\n{\n#ifdef HAVE_PF_PACKET_SOCKETS\n\tstruct pcap_linux *handlep = handle->priv;\n\n\tif (!handlep->sock_packet) {\n\t\thandle->direction = d;\n\t\treturn 0;\n\t}\n#endif\n\t/*\n\t * We're not using PF_PACKET sockets, so we can't determine\n\t * the direction of the packet.\n\t */\n\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Setting direction is not supported on SOCK_PACKET sockets\");\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              3174,
              0
            ],
            [
              3192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setdirection_linux",
            "parameters": {
              "handle": "pcap_t",
              "d": "pcap_direction_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nis_wifi(int sock_fd\n#ifndef IW_MODE_MONITOR\n_U_\n#endif\n, const char *device)\n{\n\tchar *pathstr;\n\tstruct stat statb;\n#ifdef IW_MODE_MONITOR\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n#endif\n\n\t/*\n\t * See if there's a sysfs wireless directory for it.\n\t * If so, it's a wireless interface.\n\t */\n\tif (asprintf(&pathstr, \"/sys/class/net/%s/wireless\", device) == -1) {\n\t\t/*\n\t\t * Just give up here.\n\t\t */\n\t\treturn 0;\n\t}\n\tif (stat(pathstr, &statb) == 0) {\n\t\tfree(pathstr);\n\t\treturn 1;\n\t}\n\tfree(pathstr);\n\n#ifdef IW_MODE_MONITOR\n\t/*\n\t * OK, maybe it's not wireless, or maybe this kernel doesn't\n\t * support sysfs.  Try the wireless extensions.\n\t */\n\tif (has_wext(sock_fd, device, errbuf) == 1) {\n\t\t/*\n\t\t * It supports the wireless extensions, so it's a Wi-Fi\n\t\t * device.\n\t\t */\n\t\treturn 1;\n\t}\n#endif\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              3194,
              0
            ],
            [
              3237,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "is_wifi",
            "parameters": {
              "sock_fd": "int",
              "device": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void map_arphrd_to_dlt(pcap_t *handle, int sock_fd, int arptype,\n\t\t\t      const char *device, int cooked_ok)\n{\n\tstatic const char cdma_rmnet[] = \"cdma_rmnet\";\n\n\tswitch (arptype) {\n\n\tcase ARPHRD_ETHER:\n\t\t/*\n\t\t * For various annoying reasons having to do with DHCP\n\t\t * software, some versions of Android give the mobile-\n\t\t * phone-network interface an ARPHRD_ value of\n\t\t * ARPHRD_ETHER, even though the packets supplied by\n\t\t * that interface have no link-layer header, and begin\n\t\t * with an IP header, so that the ARPHRD_ value should\n\t\t * be ARPHRD_NONE.\n\t\t *\n\t\t * Detect those devices by checking the device name, and\n\t\t * use DLT_RAW for them.\n\t\t */\n\t\tif (strncmp(device, cdma_rmnet, sizeof cdma_rmnet - 1) == 0) {\n\t\t\thandle->linktype = DLT_RAW;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Is this a real Ethernet device?  If so, give it a\n\t\t * link-layer-type list with DLT_EN10MB and DLT_DOCSIS, so\n\t\t * that an application can let you choose it, in case you're\n\t\t * capturing DOCSIS traffic that a Cisco Cable Modem\n\t\t * Termination System is putting out onto an Ethernet (it\n\t\t * doesn't put an Ethernet header onto the wire, it puts raw\n\t\t * DOCSIS frames out on the wire inside the low-level\n\t\t * Ethernet framing).\n\t\t *\n\t\t * XXX - are there any other sorts of \"fake Ethernet\" that\n\t\t * have ARPHRD_ETHER but that shouldn't offer DLT_DOCSIS as\n\t\t * a Cisco CMTS won't put traffic onto it or get traffic\n\t\t * bridged onto it?  ISDN is handled in \"activate_new()\",\n\t\t * as we fall back on cooked mode there, and we use\n\t\t * is_wifi() to check for 802.11 devices; are there any\n\t\t * others?\n\t\t */\n\t\tif (!is_wifi(sock_fd, device)) {\n\t\t\tint ret;\n\n\t\t\t/*\n\t\t\t * This is not a Wi-Fi device but it could be\n\t\t\t * a DSA master/management network device.\n\t\t\t */\n\t\t\tret = iface_dsa_get_proto_info(device, handle);\n\t\t\tif (ret < 0)\n\t\t\t\treturn;\n\n\t\t\tif (ret == 1) {\n\t\t\t\t/*\n\t\t\t\t * This is a DSA master/management network\n\t\t\t\t * device linktype is already set by\n\t\t\t\t * iface_dsa_get_proto_info() set an\n\t\t\t\t * appropriate offset here.\n\t\t\t\t */\n\t\t\t\thandle->offset = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * It's not a Wi-Fi device; offer DOCSIS.\n\t\t\t */\n\t\t\thandle->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);\n\t\t\t/*\n\t\t\t * If that fails, just leave the list empty.\n\t\t\t */\n\t\t\tif (handle->dlt_list != NULL) {\n\t\t\t\thandle->dlt_list[0] = DLT_EN10MB;\n\t\t\t\thandle->dlt_list[1] = DLT_DOCSIS;\n\t\t\t\thandle->dlt_count = 2;\n\t\t\t}\n\t\t}\n\t\t/* FALLTHROUGH */\n\n\tcase ARPHRD_METRICOM:\n\tcase ARPHRD_LOOPBACK:\n\t\thandle->linktype = DLT_EN10MB;\n\t\thandle->offset = 2;\n\t\tbreak;\n\n\tcase ARPHRD_EETHER:\n\t\thandle->linktype = DLT_EN3MB;\n\t\tbreak;\n\n\tcase ARPHRD_AX25:\n\t\thandle->linktype = DLT_AX25_KISS;\n\t\tbreak;\n\n\tcase ARPHRD_PRONET:\n\t\thandle->linktype = DLT_PRONET;\n\t\tbreak;\n\n\tcase ARPHRD_CHAOS:\n\t\thandle->linktype = DLT_CHAOS;\n\t\tbreak;\n#ifndef ARPHRD_CAN\n#define ARPHRD_CAN 280\n#endif\n\tcase ARPHRD_CAN:\n\t\t/*\n\t\t * Map this to DLT_LINUX_SLL; that way, CAN frames will\n\t\t * have ETH_P_CAN/LINUX_SLL_P_CAN as the protocol and\n\t\t * CAN FD frames will have ETH_P_CANFD/LINUX_SLL_P_CANFD\n\t\t * as the protocol, so they can be distinguished by the\n\t\t * protocol in the SLL header.\n\t\t */\n\t\thandle->linktype = DLT_LINUX_SLL;\n\t\tbreak;\n\n#ifndef ARPHRD_IEEE802_TR\n#define ARPHRD_IEEE802_TR 800\t/* From Linux 2.4 */\n#endif\n\tcase ARPHRD_IEEE802_TR:\n\tcase ARPHRD_IEEE802:\n\t\thandle->linktype = DLT_IEEE802;\n\t\thandle->offset = 2;\n\t\tbreak;\n\n\tcase ARPHRD_ARCNET:\n\t\thandle->linktype = DLT_ARCNET_LINUX;\n\t\tbreak;\n\n#ifndef ARPHRD_FDDI\t/* From Linux 2.2.13 */\n#define ARPHRD_FDDI\t774\n#endif\n\tcase ARPHRD_FDDI:\n\t\thandle->linktype = DLT_FDDI;\n\t\thandle->offset = 3;\n\t\tbreak;\n\n#ifndef ARPHRD_ATM  /* FIXME: How to #include this? */\n#define ARPHRD_ATM 19\n#endif\n\tcase ARPHRD_ATM:\n\t\t/*\n\t\t * The Classical IP implementation in ATM for Linux\n\t\t * supports both what RFC 1483 calls \"LLC Encapsulation\",\n\t\t * in which each packet has an LLC header, possibly\n\t\t * with a SNAP header as well, prepended to it, and\n\t\t * what RFC 1483 calls \"VC Based Multiplexing\", in which\n\t\t * different virtual circuits carry different network\n\t\t * layer protocols, and no header is prepended to packets.\n\t\t *\n\t\t * They both have an ARPHRD_ type of ARPHRD_ATM, so\n\t\t * you can't use the ARPHRD_ type to find out whether\n\t\t * captured packets will have an LLC header, and,\n\t\t * while there's a socket ioctl to *set* the encapsulation\n\t\t * type, there's no ioctl to *get* the encapsulation type.\n\t\t *\n\t\t * This means that\n\t\t *\n\t\t *\tprograms that dissect Linux Classical IP frames\n\t\t *\twould have to check for an LLC header and,\n\t\t *\tdepending on whether they see one or not, dissect\n\t\t *\tthe frame as LLC-encapsulated or as raw IP (I\n\t\t *\tdon't know whether there's any traffic other than\n\t\t *\tIP that would show up on the socket, or whether\n\t\t *\tthere's any support for IPv6 in the Linux\n\t\t *\tClassical IP code);\n\t\t *\n\t\t *\tfilter expressions would have to compile into\n\t\t *\tcode that checks for an LLC header and does\n\t\t *\tthe right thing.\n\t\t *\n\t\t * Both of those are a nuisance - and, at least on systems\n\t\t * that support PF_PACKET sockets, we don't have to put\n\t\t * up with those nuisances; instead, we can just capture\n\t\t * in cooked mode.  That's what we'll do, if we can.\n\t\t * Otherwise, we'll just fail.\n\t\t */\n\t\tif (cooked_ok)\n\t\t\thandle->linktype = DLT_LINUX_SLL;\n\t\telse\n\t\t\thandle->linktype = -1;\n\t\tbreak;\n\n#ifndef ARPHRD_IEEE80211  /* From Linux 2.4.6 */\n#define ARPHRD_IEEE80211 801\n#endif\n\tcase ARPHRD_IEEE80211:\n\t\thandle->linktype = DLT_IEEE802_11;\n\t\tbreak;\n\n#ifndef ARPHRD_IEEE80211_PRISM  /* From Linux 2.4.18 */\n#define ARPHRD_IEEE80211_PRISM 802\n#endif\n\tcase ARPHRD_IEEE80211_PRISM:\n\t\thandle->linktype = DLT_PRISM_HEADER;\n\t\tbreak;\n\n#ifndef ARPHRD_IEEE80211_RADIOTAP /* new */\n#define ARPHRD_IEEE80211_RADIOTAP 803\n#endif\n\tcase ARPHRD_IEEE80211_RADIOTAP:\n\t\thandle->linktype = DLT_IEEE802_11_RADIO;\n\t\tbreak;\n\n\tcase ARPHRD_PPP:\n\t\t/*\n\t\t * Some PPP code in the kernel supplies no link-layer\n\t\t * header whatsoever to PF_PACKET sockets; other PPP\n\t\t * code supplies PPP link-layer headers (\"syncppp.c\");\n\t\t * some PPP code might supply random link-layer\n\t\t * headers (PPP over ISDN - there's code in Ethereal,\n\t\t * for example, to cope with PPP-over-ISDN captures\n\t\t * with which the Ethereal developers have had to cope,\n\t\t * heuristically trying to determine which of the\n\t\t * oddball link-layer headers particular packets have).\n\t\t *\n\t\t * As such, we just punt, and run all PPP interfaces\n\t\t * in cooked mode, if we can; otherwise, we just treat\n\t\t * it as DLT_RAW, for now - if somebody needs to capture,\n\t\t * on a 2.0[.x] kernel, on PPP devices that supply a\n\t\t * link-layer header, they'll have to add code here to\n\t\t * map to the appropriate DLT_ type (possibly adding a\n\t\t * new DLT_ type, if necessary).\n\t\t */\n\t\tif (cooked_ok)\n\t\t\thandle->linktype = DLT_LINUX_SLL;\n\t\telse {\n\t\t\t/*\n\t\t\t * XXX - handle ISDN types here?  We can't fall\n\t\t\t * back on cooked sockets, so we'd have to\n\t\t\t * figure out from the device name what type of\n\t\t\t * link-layer encapsulation it's using, and map\n\t\t\t * that to an appropriate DLT_ value, meaning\n\t\t\t * we'd map \"isdnN\" devices to DLT_RAW (they\n\t\t\t * supply raw IP packets with no link-layer\n\t\t\t * header) and \"isdY\" devices to a new DLT_I4L_IP\n\t\t\t * type that has only an Ethernet packet type as\n\t\t\t * a link-layer header.\n\t\t\t *\n\t\t\t * But sometimes we seem to get random crap\n\t\t\t * in the link-layer header when capturing on\n\t\t\t * ISDN devices....\n\t\t\t */\n\t\t\thandle->linktype = DLT_RAW;\n\t\t}\n\t\tbreak;\n\n#ifndef ARPHRD_CISCO\n#define ARPHRD_CISCO 513 /* previously ARPHRD_HDLC */\n#endif\n\tcase ARPHRD_CISCO:\n\t\thandle->linktype = DLT_C_HDLC;\n\t\tbreak;\n\n\t/* Not sure if this is correct for all tunnels, but it\n\t * works for CIPE */\n\tcase ARPHRD_TUNNEL:\n#ifndef ARPHRD_SIT\n#define ARPHRD_SIT 776\t/* From Linux 2.2.13 */\n#endif\n\tcase ARPHRD_SIT:\n\tcase ARPHRD_CSLIP:\n\tcase ARPHRD_SLIP6:\n\tcase ARPHRD_CSLIP6:\n\tcase ARPHRD_ADAPT:\n\tcase ARPHRD_SLIP:\n#ifndef ARPHRD_RAWHDLC\n#define ARPHRD_RAWHDLC 518\n#endif\n\tcase ARPHRD_RAWHDLC:\n#ifndef ARPHRD_DLCI\n#define ARPHRD_DLCI 15\n#endif\n\tcase ARPHRD_DLCI:\n\t\t/*\n\t\t * XXX - should some of those be mapped to DLT_LINUX_SLL\n\t\t * instead?  Should we just map all of them to DLT_LINUX_SLL?\n\t\t */\n\t\thandle->linktype = DLT_RAW;\n\t\tbreak;\n\n#ifndef ARPHRD_FRAD\n#define ARPHRD_FRAD 770\n#endif\n\tcase ARPHRD_FRAD:\n\t\thandle->linktype = DLT_FRELAY;\n\t\tbreak;\n\n\tcase ARPHRD_LOCALTLK:\n\t\thandle->linktype = DLT_LTALK;\n\t\tbreak;\n\n\tcase 18:\n\t\t/*\n\t\t * RFC 4338 defines an encapsulation for IP and ARP\n\t\t * packets that's compatible with the RFC 2625\n\t\t * encapsulation, but that uses a different ARP\n\t\t * hardware type and hardware addresses.  That\n\t\t * ARP hardware type is 18; Linux doesn't define\n\t\t * any ARPHRD_ value as 18, but if it ever officially\n\t\t * supports RFC 4338-style IP-over-FC, it should define\n\t\t * one.\n\t\t *\n\t\t * For now, we map it to DLT_IP_OVER_FC, in the hopes\n\t\t * that this will encourage its use in the future,\n\t\t * should Linux ever officially support RFC 4338-style\n\t\t * IP-over-FC.\n\t\t */\n\t\thandle->linktype = DLT_IP_OVER_FC;\n\t\tbreak;\n\n#ifndef ARPHRD_FCPP\n#define ARPHRD_FCPP\t784\n#endif\n\tcase ARPHRD_FCPP:\n#ifndef ARPHRD_FCAL\n#define ARPHRD_FCAL\t785\n#endif\n\tcase ARPHRD_FCAL:\n#ifndef ARPHRD_FCPL\n#define ARPHRD_FCPL\t786\n#endif\n\tcase ARPHRD_FCPL:\n#ifndef ARPHRD_FCFABRIC\n#define ARPHRD_FCFABRIC\t787\n#endif\n\tcase ARPHRD_FCFABRIC:\n\t\t/*\n\t\t * Back in 2002, Donald Lee at Cray wanted a DLT_ for\n\t\t * IP-over-FC:\n\t\t *\n\t\t *\thttp://www.mail-archive.com/tcpdump-workers@sandelman.ottawa.on.ca/msg01043.html\n\t\t *\n\t\t * and one was assigned.\n\t\t *\n\t\t * In a later private discussion (spun off from a message\n\t\t * on the ethereal-users list) on how to get that DLT_\n\t\t * value in libpcap on Linux, I ended up deciding that\n\t\t * the best thing to do would be to have him tweak the\n\t\t * driver to set the ARPHRD_ value to some ARPHRD_FCxx\n\t\t * type, and map all those types to DLT_IP_OVER_FC:\n\t\t *\n\t\t *\tI've checked into the libpcap and tcpdump CVS tree\n\t\t *\tsupport for DLT_IP_OVER_FC.  In order to use that,\n\t\t *\tyou'd have to modify your modified driver to return\n\t\t *\tone of the ARPHRD_FCxxx types, in \"fcLINUXfcp.c\" -\n\t\t *\tchange it to set \"dev->type\" to ARPHRD_FCFABRIC, for\n\t\t *\texample (the exact value doesn't matter, it can be\n\t\t *\tany of ARPHRD_FCPP, ARPHRD_FCAL, ARPHRD_FCPL, or\n\t\t *\tARPHRD_FCFABRIC).\n\t\t *\n\t\t * 11 years later, Christian Svensson wanted to map\n\t\t * various ARPHRD_ values to DLT_FC_2 and\n\t\t * DLT_FC_2_WITH_FRAME_DELIMS for raw Fibre Channel\n\t\t * frames:\n\t\t *\n\t\t *\thttps://github.com/mcr/libpcap/pull/29\n\t\t *\n\t\t * There doesn't seem to be any network drivers that uses\n\t\t * any of the ARPHRD_FC* values for IP-over-FC, and\n\t\t * it's not exactly clear what the \"Dummy types for non\n\t\t * ARP hardware\" are supposed to mean (link-layer\n\t\t * header type?  Physical network type?), so it's\n\t\t * not exactly clear why the ARPHRD_FC* types exist\n\t\t * in the first place.\n\t\t *\n\t\t * For now, we map them to DLT_FC_2, and provide an\n\t\t * option of DLT_FC_2_WITH_FRAME_DELIMS, as well as\n\t\t * DLT_IP_OVER_FC just in case there's some old\n\t\t * driver out there that uses one of those types for\n\t\t * IP-over-FC on which somebody wants to capture\n\t\t * packets.\n\t\t */\n\t\thandle->dlt_list = (u_int *) malloc(sizeof(u_int) * 3);\n\t\t/*\n\t\t * If that fails, just leave the list empty.\n\t\t */\n\t\tif (handle->dlt_list != NULL) {\n\t\t\thandle->dlt_list[0] = DLT_FC_2;\n\t\t\thandle->dlt_list[1] = DLT_FC_2_WITH_FRAME_DELIMS;\n\t\t\thandle->dlt_list[2] = DLT_IP_OVER_FC;\n\t\t\thandle->dlt_count = 3;\n\t\t}\n\t\thandle->linktype = DLT_FC_2;\n\t\tbreak;\n\n#ifndef ARPHRD_IRDA\n#define ARPHRD_IRDA\t783\n#endif\n\tcase ARPHRD_IRDA:\n\t\t/* Don't expect IP packet out of this interfaces... */\n\t\thandle->linktype = DLT_LINUX_IRDA;\n\t\t/* We need to save packet direction for IrDA decoding,\n\t\t * so let's use \"Linux-cooked\" mode. Jean II\n\t\t *\n\t\t * XXX - this is handled in activate_new(). */\n\t\t/* handlep->cooked = 1; */\n\t\tbreak;\n\n\t/* ARPHRD_LAPD is unofficial and randomly allocated, if reallocation\n\t * is needed, please report it to <daniele@orlandi.com> */\n#ifndef ARPHRD_LAPD\n#define ARPHRD_LAPD\t8445\n#endif\n\tcase ARPHRD_LAPD:\n\t\t/* Don't expect IP packet out of this interfaces... */\n\t\thandle->linktype = DLT_LINUX_LAPD;\n\t\tbreak;\n\n#ifndef ARPHRD_NONE\n#define ARPHRD_NONE\t0xFFFE\n#endif\n\tcase ARPHRD_NONE:\n\t\t/*\n\t\t * No link-layer header; packets are just IP\n\t\t * packets, so use DLT_RAW.\n\t\t */\n\t\thandle->linktype = DLT_RAW;\n\t\tbreak;\n\n#ifndef ARPHRD_IEEE802154\n#define ARPHRD_IEEE802154      804\n#endif\n       case ARPHRD_IEEE802154:\n               handle->linktype =  DLT_IEEE802_15_4_NOFCS;\n               break;\n\n#ifndef ARPHRD_NETLINK\n#define ARPHRD_NETLINK\t824\n#endif\n\tcase ARPHRD_NETLINK:\n\t\thandle->linktype = DLT_NETLINK;\n\t\t/*\n\t\t * We need to use cooked mode, so that in sll_protocol we\n\t\t * pick up the netlink protocol type such as NETLINK_ROUTE,\n\t\t * NETLINK_GENERIC, NETLINK_FIB_LOOKUP, etc.\n\t\t *\n\t\t * XXX - this is handled in activate_new().\n\t\t */\n\t\t/* handlep->cooked = 1; */\n\t\tbreak;\n\n#ifndef ARPHRD_VSOCKMON\n#define ARPHRD_VSOCKMON\t826\n#endif\n\tcase ARPHRD_VSOCKMON:\n\t\thandle->linktype = DLT_VSOCK;\n\t\tbreak;\n\n\tdefault:\n\t\thandle->linktype = -1;\n\t\tbreak;\n\t}\n}",
          "fn_code_pos": [
            [
              3257,
              0
            ],
            [
              3709,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "map_arphrd_to_dlt",
            "parameters": {
              "handle": "pcap_t",
              "sock_fd": "int",
              "arptype": "int",
              "device": "char",
              "cooked_ok": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nset_dlt_list_cooked(pcap_t *handle, int sock_fd)\n{\n\tsocklen_t\t\tlen;\n\tunsigned int\t\ttp_reserve;\n\n\t/*\n\t * If we can't do PACKET_RESERVE, we can't reserve extra space\n\t * for a DLL_LINUX_SLL2 header, so we can't support DLT_LINUX_SLL2.\n\t */\n\tlen = sizeof(tp_reserve);\n\tif (getsockopt(sock_fd, SOL_PACKET, PACKET_RESERVE, &tp_reserve,\n\t    &len) == 0) {\n\t    \t/*\n\t    \t * Yes, we can do DLL_LINUX_SLL2.\n\t    \t */\n\t\thandle->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);\n\t\t/*\n\t\t * If that fails, just leave the list empty.\n\t\t */\n\t\tif (handle->dlt_list != NULL) {\n\t\t\thandle->dlt_list[0] = DLT_LINUX_SLL;\n\t\t\thandle->dlt_list[1] = DLT_LINUX_SLL2;\n\t\t\thandle->dlt_count = 2;\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              3715,
              0
            ],
            [
              3741,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_dlt_list_cooked",
            "parameters": {
              "handle": "pcap_t",
              "sock_fd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nactivate_new(pcap_t *handle, int is_any_device)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tconst char\t\t*device = handle->opt.device;\n\tint\t\t\tsock_fd, arptype;\n#ifdef HAVE_PACKET_AUXDATA\n\tint\t\t\tval;\n#endif\n\tint\t\t\terr = 0;\n\tstruct packet_mreq\tmr;\n#if defined(SO_BPF_EXTENSIONS) && defined(SKF_AD_VLAN_TAG_PRESENT)\n\tint\t\t\tbpf_extensions;\n\tsocklen_t\t\tlen = sizeof(bpf_extensions);\n#endif\n\n\tsock_fd = open_pf_packet_socket(handle, is_any_device);\n\tif (sock_fd < 0) {\n\t\t/*\n\t\t * Failed; return its return value.\n\t\t */\n\t\treturn sock_fd;\n\t}\n\n\t/* It seems the kernel supports the new interface. */\n\thandlep->sock_packet = 0;\n\n\t/*\n\t * Get the interface index of the loopback device.\n\t * If the attempt fails, don't fail, just set the\n\t * \"handlep->lo_ifindex\" to -1.\n\t *\n\t * XXX - can there be more than one device that loops\n\t * packets back, i.e. devices other than \"lo\"?  If so,\n\t * we'd need to find them all, and have an array of\n\t * indices for them, and check all of them in\n\t * \"pcap_read_packet()\".\n\t */\n\thandlep->lo_ifindex = iface_get_id(sock_fd, \"lo\", handle->errbuf);\n\n\t/*\n\t * Default value for offset to align link-layer payload\n\t * on a 4-byte boundary.\n\t */\n\thandle->offset\t = 0;\n\n\t/*\n\t * What kind of frames do we have to deal with? Fall back\n\t * to cooked mode if we have an unknown interface type\n\t * or a type we know doesn't work well in raw mode.\n\t */\n\tif (!is_any_device) {\n\t\t/* Assume for now we don't need cooked mode. */\n\t\thandlep->cooked = 0;\n\n\t\tif (handle->opt.rfmon) {\n\t\t\t/*\n\t\t\t * We were asked to turn on monitor mode.\n\t\t\t * Do so before we get the link-layer type,\n\t\t\t * because entering monitor mode could change\n\t\t\t * the link-layer type.\n\t\t\t */\n\t\t\terr = enter_rfmon_mode(handle, sock_fd, device);\n\t\t\tif (err < 0) {\n\t\t\t\t/* Hard failure */\n\t\t\t\tclose(sock_fd);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (err == 0) {\n\t\t\t\t/*\n\t\t\t\t * Nothing worked for turning monitor mode\n\t\t\t\t * on.\n\t\t\t\t */\n\t\t\t\tclose(sock_fd);\n\t\t\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Either monitor mode has been turned on for\n\t\t\t * the device, or we've been given a different\n\t\t\t * device to open for monitor mode.  If we've\n\t\t\t * been given a different device, use it.\n\t\t\t */\n\t\t\tif (handlep->mondevice != NULL)\n\t\t\t\tdevice = handlep->mondevice;\n\t\t}\n\t\tarptype\t= iface_get_arptype(sock_fd, device, handle->errbuf);\n\t\tif (arptype < 0) {\n\t\t\tclose(sock_fd);\n\t\t\treturn arptype;\n\t\t}\n\t\tmap_arphrd_to_dlt(handle, sock_fd, arptype, device, 1);\n\t\tif (handle->linktype == -1 ||\n\t\t    handle->linktype == DLT_LINUX_SLL ||\n\t\t    handle->linktype == DLT_LINUX_IRDA ||\n\t\t    handle->linktype == DLT_LINUX_LAPD ||\n\t\t    handle->linktype == DLT_NETLINK ||\n\t\t    (handle->linktype == DLT_EN10MB &&\n\t\t     (strncmp(\"isdn\", device, 4) == 0 ||\n\t\t      strncmp(\"isdY\", device, 4) == 0))) {\n\t\t\t/*\n\t\t\t * Unknown interface type (-1), or a\n\t\t\t * device we explicitly chose to run\n\t\t\t * in cooked mode (e.g., PPP devices),\n\t\t\t * or an ISDN device (whose link-layer\n\t\t\t * type we can only determine by using\n\t\t\t * APIs that may be different on different\n\t\t\t * kernels) - reopen in cooked mode.\n\t\t\t */\n\t\t\tif (close(sock_fd) == -1) {\n\t\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"close\");\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t\tsock_fd = open_pf_packet_socket(handle, 1);\n\t\t\tif (sock_fd < 0) {\n\t\t\t\tif (sock_fd == PCAP_ERROR_NO_PF_PACKET_SOCKETS) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We don't support PF_PACKET/SOCK_whatever\n\t\t\t\t\t * sockets.  This should never happen,\n\t\t\t\t\t * because we don't support cooked mode\n\t\t\t\t\t * without those sockets, so we\n\t\t\t\t\t * shouldn't get called if we're\n\t\t\t\t\t * running on a kernel old enough\n\t\t\t\t\t * not to support them.\n\t\t\t\t\t *\n\t\t\t\t\t * The error message has already been\n\t\t\t\t\t * filled in appropriately.\n\t\t\t\t\t */\n\t\t\t\t\tsock_fd = PCAP_ERROR;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Fatal error; the return value is the\n\t\t\t\t * error code, and handle->errbuf has\n\t\t\t\t * been set to an appropriate error\n\t\t\t\t * message.\n\t\t\t\t */\n\t\t\t\treturn sock_fd;\n\t\t\t}\n\t\t\thandlep->cooked = 1;\n\n\t\t\t/*\n\t\t\t * Get rid of any link-layer type list\n\t\t\t * we allocated - this only supports cooked\n\t\t\t * capture.\n\t\t\t */\n\t\t\tif (handle->dlt_list != NULL) {\n\t\t\t\tfree(handle->dlt_list);\n\t\t\t\thandle->dlt_list = NULL;\n\t\t\t\thandle->dlt_count = 0;\n\t\t\t\tset_dlt_list_cooked(handle, sock_fd);\n\t\t\t}\n\n\t\t\tif (handle->linktype == -1) {\n\t\t\t\t/*\n\t\t\t\t * Warn that we're falling back on\n\t\t\t\t * cooked mode; we may want to\n\t\t\t\t * update \"map_arphrd_to_dlt()\"\n\t\t\t\t * to handle the new type.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\"arptype %d not \"\n\t\t\t\t\t\"supported by libpcap - \"\n\t\t\t\t\t\"falling back to cooked \"\n\t\t\t\t\t\"socket\",\n\t\t\t\t\tarptype);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * IrDA capture is not a real \"cooked\" capture,\n\t\t\t * it's IrLAP frames, not IP packets.  The\n\t\t\t * same applies to LAPD capture.\n\t\t\t */\n\t\t\tif (handle->linktype != DLT_LINUX_IRDA &&\n\t\t\t    handle->linktype != DLT_LINUX_LAPD &&\n\t\t\t    handle->linktype != DLT_NETLINK)\n\t\t\t\thandle->linktype = DLT_LINUX_SLL;\n\t\t}\n\n\t\thandlep->ifindex = iface_get_id(sock_fd, device,\n\t\t    handle->errbuf);\n\t\tif (handlep->ifindex == -1) {\n\t\t\tclose(sock_fd);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\n\t\tif ((err = iface_bind(sock_fd, handlep->ifindex,\n\t\t    handle->errbuf, pcap_protocol(handle))) != 0) {\n\t\t    \tclose(sock_fd);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * The \"any\" device.\n\t\t */\n\t\tif (handle->opt.rfmon) {\n\t\t\t/*\n\t\t\t * It doesn't support monitor mode.\n\t\t\t */\n\t\t\tclose(sock_fd);\n\t\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t\t}\n\n\t\t/*\n\t\t * It uses cooked mode.\n\t\t */\n\t\thandlep->cooked = 1;\n\t\thandle->linktype = DLT_LINUX_SLL;\n\t\thandle->dlt_list = NULL;\n\t\thandle->dlt_count = 0;\n\t\tset_dlt_list_cooked(handle, sock_fd);\n\n\t\t/*\n\t\t * We're not bound to a device.\n\t\t * For now, we're using this as an indication\n\t\t * that we can't transmit; stop doing that only\n\t\t * if we figure out how to transmit in cooked\n\t\t * mode.\n\t\t */\n\t\thandlep->ifindex = -1;\n\t}\n\n\t/*\n\t * Select promiscuous mode on if \"promisc\" is set.\n\t *\n\t * Do not turn allmulti mode on if we don't select\n\t * promiscuous mode - on some devices (e.g., Orinoco\n\t * wireless interfaces), allmulti mode isn't supported\n\t * and the driver implements it by turning promiscuous\n\t * mode on, and that screws up the operation of the\n\t * card as a normal networking interface, and on no\n\t * other platform I know of does starting a non-\n\t * promiscuous capture affect which multicast packets\n\t * are received by the interface.\n\t */\n\n\t/*\n\t * Hmm, how can we set promiscuous mode on all interfaces?\n\t * I am not sure if that is possible at all.  For now, we\n\t * silently ignore attempts to turn promiscuous mode on\n\t * for the \"any\" device (so you don't have to explicitly\n\t * disable it in programs such as tcpdump).\n\t */\n\n\tif (!is_any_device && handle->opt.promisc) {\n\t\tmemset(&mr, 0, sizeof(mr));\n\t\tmr.mr_ifindex = handlep->ifindex;\n\t\tmr.mr_type    = PACKET_MR_PROMISC;\n\t\tif (setsockopt(sock_fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,\n\t\t    &mr, sizeof(mr)) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"setsockopt (PACKET_ADD_MEMBERSHIP)\");\n\t\t\tclose(sock_fd);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t}\n\n\t/* Enable auxillary data if supported and reserve room for\n\t * reconstructing VLAN headers. */\n#ifdef HAVE_PACKET_AUXDATA\n\tval = 1;\n\tif (setsockopt(sock_fd, SOL_PACKET, PACKET_AUXDATA, &val,\n\t\t       sizeof(val)) == -1 && errno != ENOPROTOOPT) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setsockopt (PACKET_AUXDATA)\");\n\t\tclose(sock_fd);\n\t\treturn PCAP_ERROR;\n\t}\n\thandle->offset += VLAN_TAG_LEN;\n#endif /* HAVE_PACKET_AUXDATA */\n\n\t/*\n\t * This is a 2.2[.x] or later kernel (we know that\n\t * because we're not using a SOCK_PACKET socket -\n\t * PF_PACKET is supported only in 2.2 and later\n\t * kernels).\n\t *\n\t * We can safely pass \"recvfrom()\" a byte count\n\t * based on the snapshot length.\n\t *\n\t * If we're in cooked mode, make the snapshot length\n\t * large enough to hold a \"cooked mode\" header plus\n\t * 1 byte of packet data (so we don't pass a byte\n\t * count of 0 to \"recvfrom()\").\n\t * XXX - we don't know whether this will be DLT_LINUX_SLL\n\t * or DLT_LINUX_SLL2, so make sure it's big enough for\n\t * a DLT_LINUX_SLL2 \"cooked mode\" header; a snapshot length\n\t * that small is silly anyway.\n\t */\n\tif (handlep->cooked) {\n\t\tif (handle->snapshot < SLL2_HDR_LEN + 1)\n\t\t\thandle->snapshot = SLL2_HDR_LEN + 1;\n\t}\n\thandle->bufsize = handle->snapshot;\n\n\t/*\n\t * Set the offset at which to insert VLAN tags.\n\t * That should be the offset of the type field.\n\t */\n\tswitch (handle->linktype) {\n\n\tcase DLT_EN10MB:\n\t\t/*\n\t\t * The type field is after the destination and source\n\t\t * MAC address.\n\t\t */\n\t\thandlep->vlan_offset = 2 * ETH_ALEN;\n\t\tbreak;\n\n\tcase DLT_LINUX_SLL:\n\t\t/*\n\t\t * The type field is in the last 2 bytes of the\n\t\t * DLT_LINUX_SLL header.\n\t\t */\n\t\thandlep->vlan_offset = SLL_HDR_LEN - 2;\n\t\tbreak;\n\n\tdefault:\n\t\thandlep->vlan_offset = -1; /* unknown */\n\t\tbreak;\n\t}\n\n#if defined(SIOCGSTAMPNS) && defined(SO_TIMESTAMPNS)\n\tif (handle->opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO) {\n\t\tint nsec_tstamps = 1;\n\n\t\tif (setsockopt(sock_fd, SOL_SOCKET, SO_TIMESTAMPNS, &nsec_tstamps, sizeof(nsec_tstamps)) < 0) {\n\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"setsockopt: unable to set SO_TIMESTAMPNS\");\n\t\t\tclose(sock_fd);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t}\n#endif /* defined(SIOCGSTAMPNS) && defined(SO_TIMESTAMPNS) */\n\n\t/*\n\t * We've succeeded. Save the socket FD in the pcap structure.\n\t */\n\thandle->fd = sock_fd;\n\n#if defined(SO_BPF_EXTENSIONS) && defined(SKF_AD_VLAN_TAG_PRESENT)\n\t/*\n\t * Can we generate special code for VLAN checks?\n\t * (XXX - what if we need the special code but it's not supported\n\t * by the OS?  Is that possible?)\n\t */\n\tif (getsockopt(sock_fd, SOL_SOCKET, SO_BPF_EXTENSIONS,\n\t    &bpf_extensions, &len) == 0) {\n\t\tif (bpf_extensions >= SKF_AD_VLAN_TAG_PRESENT) {\n\t\t\t/*\n\t\t\t * Yes, we can.  Request that we do so.\n\t\t\t */\n\t\t\thandle->bpf_codegen_flags |= BPF_SPECIAL_VLAN_HANDLING;\n\t\t}\n\t}\n#endif /* defined(SO_BPF_EXTENSIONS) && defined(SKF_AD_VLAN_TAG_PRESENT) */\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              3757,
              0
            ],
            [
              4114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "activate_new",
            "parameters": {
              "handle": "pcap_t",
              "is_any_device": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nactivate_mmap(pcap_t *handle, int *status)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tint ret;\n\n\t/*\n\t * Attempt to allocate a buffer to hold the contents of one\n\t * packet, for use by the oneshot callback.\n\t */\n\thandlep->oneshot_buffer = malloc(handle->snapshot);\n\tif (handlep->oneshot_buffer == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"can't allocate oneshot buffer\");\n\t\t*status = PCAP_ERROR;\n\t\treturn -1;\n\t}\n\n\tif (handle->opt.buffer_size == 0) {\n\t\t/* by default request 2M for the ring buffer */\n\t\thandle->opt.buffer_size = 2*1024*1024;\n\t}\n\tret = prepare_tpacket_socket(handle);\n\tif (ret == -1) {\n\t\tfree(handlep->oneshot_buffer);\n\t\t*status = PCAP_ERROR;\n\t\treturn ret;\n\t}\n\tret = create_ring(handle, status);\n\tif (ret == 0) {\n\t\t/*\n\t\t * We don't support memory-mapped capture; our caller\n\t\t * will fall back on reading from the socket.\n\t\t */\n\t\tfree(handlep->oneshot_buffer);\n\t\treturn 0;\n\t}\n\tif (ret == -1) {\n\t\t/*\n\t\t * Error attempting to enable memory-mapped capture;\n\t\t * fail.  create_ring() has set *status.\n\t\t */\n\t\tfree(handlep->oneshot_buffer);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Success.  *status has been set either to 0 if there are no\n\t * warnings or to a PCAP_WARNING_ value if there is a warning.\n\t *\n\t * Override some defaults and inherit the other fields from\n\t * activate_new.\n\t * handle->offset is used to get the current position into the rx ring.\n\t * handle->cc is used to store the ring size.\n\t */\n\n\tswitch (handlep->tp_version) {\n\tcase TPACKET_V1:\n\t\thandle->read_op = pcap_read_linux_mmap_v1;\n\t\tbreak;\n\tcase TPACKET_V1_64:\n\t\thandle->read_op = pcap_read_linux_mmap_v1_64;\n\t\tbreak;\n#ifdef HAVE_TPACKET2\n\tcase TPACKET_V2:\n\t\thandle->read_op = pcap_read_linux_mmap_v2;\n\t\tbreak;\n#endif\n#ifdef HAVE_TPACKET3\n\tcase TPACKET_V3:\n\t\thandle->read_op = pcap_read_linux_mmap_v3;\n\t\tbreak;\n#endif\n\t}\n\thandle->cleanup_op = pcap_cleanup_linux_mmap;\n\thandle->setfilter_op = pcap_setfilter_linux_mmap;\n\thandle->setnonblock_op = pcap_setnonblock_mmap;\n\thandle->getnonblock_op = pcap_getnonblock_mmap;\n\thandle->oneshot_callback = pcap_oneshot_mmap;\n\thandle->selectable_fd = handle->fd;\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              4129,
              0
            ],
            [
              4210,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "activate_mmap",
            "parameters": {
              "handle": "pcap_t",
              "status": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ninit_tpacket(pcap_t *handle, int version, const char *version_str)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tint val = version;\n\tsocklen_t len = sizeof(val);\n\n\t/*\n\t * Probe whether kernel supports the specified TPACKET version;\n\t * this also gets the length of the header for that version.\n\t *\n\t * This socket option was introduced in 2.6.27, which was\n\t * also the first release with TPACKET_V2 support.\n\t */\n\tif (getsockopt(handle->fd, SOL_PACKET, PACKET_HDRLEN, &val, &len) < 0) {\n\t\tif (errno == ENOPROTOOPT || errno == EINVAL) {\n\t\t\t/*\n\t\t\t * ENOPROTOOPT means the kernel is too old to\n\t\t\t * support PACKET_HDRLEN at all, which means\n\t\t\t * it either doesn't support TPACKET at all\n\t\t\t * or supports  only TPACKET_V1.\n\t\t\t */\n\t\t\treturn 1;\t/* no */\n\t\t}\n\n\t\t/* Failed to even find out; this is a fatal error. */\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"can't get %s header len on packet socket\",\n\t\t    version_str);\n\t\treturn -1;\n\t}\n\thandlep->tp_hdrlen = val;\n\n\tval = version;\n\tif (setsockopt(handle->fd, SOL_PACKET, PACKET_VERSION, &val,\n\t\t\t   sizeof(val)) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"can't activate %s on packet socket\", version_str);\n\t\treturn -1;\n\t}\n\thandlep->tp_version = version;\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              4220,
              0
            ],
            [
              4263,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "init_tpacket",
            "parameters": {
              "handle": "pcap_t",
              "version": "int",
              "version_str": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nprepare_tpacket_socket(pcap_t *handle)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n#if defined(HAVE_TPACKET2) || defined(HAVE_TPACKET3)\n\tint ret;\n#endif\n\n#ifdef HAVE_TPACKET3\n\t/*\n\t * Try setting the version to TPACKET_V3.\n\t *\n\t * The only mode in which buffering is done on PF_PACKET\n\t * sockets, so that packets might not be delivered\n\t * immediately, is TPACKET_V3 mode.\n\t *\n\t * The buffering cannot be disabled in that mode, so\n\t * if the user has requested immediate mode, we don't\n\t * use TPACKET_V3.\n\t */\n\tif (!handle->opt.immediate) {\n\t\tret = init_tpacket(handle, TPACKET_V3, \"TPACKET_V3\");\n\t\tif (ret == 0) {\n\t\t\t/*\n\t\t\t * Success.\n\t\t\t */\n\t\t\treturn 1;\n\t\t}\n\t\tif (ret == -1) {\n\t\t\t/*\n\t\t\t * We failed for some reason other than \"the\n\t\t\t * kernel doesn't support TPACKET_V3\".\n\t\t\t */\n\t\t\treturn -1;\n\t\t}\n\t}\n#endif /* HAVE_TPACKET3 */\n\n#ifdef HAVE_TPACKET2\n\t/*\n\t * Try setting the version to TPACKET_V2.\n\t */\n\tret = init_tpacket(handle, TPACKET_V2, \"TPACKET_V2\");\n\tif (ret == 0) {\n\t\t/*\n\t\t * Success.\n\t\t */\n\t\treturn 1;\n\t}\n\tif (ret == -1) {\n\t\t/*\n\t\t * We failed for some reason other than \"the\n\t\t * kernel doesn't support TPACKET_V2\".\n\t\t */\n\t\treturn -1;\n\t}\n#endif /* HAVE_TPACKET2 */\n\n\t/*\n\t * OK, we're using TPACKET_V1, as either that's all the kernel\n\t * supports or it doesn't support TPACKET at all.  In the latter\n\t * case, create_ring() will fail, and we'll fall back on non-\n\t * memory-mapped capture.\n\t */\n\thandlep->tp_version = TPACKET_V1;\n\thandlep->tp_hdrlen = sizeof(struct tpacket_hdr);\n\n#ifdef ISA_64_BIT\n\t/*\n\t * 32-bit userspace + 64-bit kernel + TPACKET_V1 are not compatible with\n\t * each other due to platform-dependent data type size differences.\n\t *\n\t * If we have a 32-bit userland and a 64-bit kernel, use an\n\t * internally-defined TPACKET_V1_64, with which we use a 64-bit\n\t * version of the data structures.\n\t */\n\tif (sizeof(long) == 4) {\n\t\t/*\n\t\t * This is 32-bit code.\n\t\t */\n\t\tstruct utsname utsname;\n\n\t\tif (uname(&utsname) == -1) {\n\t\t\t/*\n\t\t\t * Failed.\n\t\t\t */\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"uname failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (strcmp(utsname.machine, ISA_64_BIT) == 0) {\n\t\t\t/*\n\t\t\t * uname() tells us the machine is 64-bit,\n\t\t\t * so we presumably have a 64-bit kernel.\n\t\t\t *\n\t\t\t * XXX - this presumes that uname() won't lie\n\t\t\t * in 32-bit code and claim that the machine\n\t\t\t * has the 32-bit version of the ISA.\n\t\t\t */\n\t\t\thandlep->tp_version = TPACKET_V1_64;\n\t\t\thandlep->tp_hdrlen = sizeof(struct tpacket_hdr_64);\n\t\t}\n\t}\n#endif\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              4305,
              0
            ],
            [
              4411,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "prepare_tpacket_socket",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncreate_ring(pcap_t *handle, int *status)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tunsigned i, j, frames_per_block;\n#ifdef HAVE_TPACKET3\n\t/*\n\t * For sockets using TPACKET_V1 or TPACKET_V2, the extra\n\t * stuff at the end of a struct tpacket_req3 will be\n\t * ignored, so this is OK even for those sockets.\n\t */\n\tstruct tpacket_req3 req;\n#else\n\tstruct tpacket_req req;\n#endif\n\tsocklen_t len;\n\tunsigned int sk_type, tp_reserve, maclen, tp_hdrlen, netoff, macoff;\n\tunsigned int frame_size;\n\n\t/*\n\t * Start out assuming no warnings or errors.\n\t */\n\t*status = 0;\n\n#ifdef TPACKET_RESERVE\n\t/*\n\t * TPACKET_V2 and PACKET_RESERVE were both introduced in\n\t * 2.6.27.  If tp_version is for TPACKET_V1, that means\n\t * the kernel doesn't support TPACKET_V2, so it won't\n\t * support PACKET_RESERVE, either.\n\t */\n\tif (handle->tp_version != TPACKET_V1 &&\n\t    handle->tp_version != TPACKET_V1_64) {\n\t\t/*\n\t\t * Reserve space for VLAN tag reconstruction.\n\t\t */\n\t\ttp_reserve = VLAN_TAG_LEN;\n\n\t\t/*\n\t\t * If we're using DLT_LINUX_SLL2, reserve space for a\n\t\t * DLT_LINUX_SLL2 header.\n\t\t *\n\t\t * XXX - we assume that the kernel is still adding\n\t\t * 16 bytes of extra space; that happens to\n\t\t * correspond to SLL_HDR_LEN (whether intentionally\n\t\t * or not - the kernel code has a raw \"16\" in\n\t\t * the expression), so we subtract SLL_HDR_LEN\n\t\t * from SLL2_HDR_LEN to get the additional space\n\t\t * needed.  That also means we don't bother reserving\n\t\t * any additional space if we're using DLT_LINUX_SLL.\n\t\t *\n\t\t * XXX - should we use TPACKET_ALIGN(SLL2_HDR_LEN - SLL_HDR_LEN)?\n\t\t */\n\t\tif (handle->linktype == DLT_LINUX_SLL2)\n\t\t\ttp_reserve += SLL2_HDR_LEN - SLL_HDR_LEN;\n\n\t\t/*\n\t\t * Try to request that amount of reserve space.\n\t\t * This must be done before creating the ring buffer.\n\t\t * If PACKET_RESERVE is supported, creating the ring\n\t\t * buffer should be, although if creating the ring\n\t\t * buffer fails, the PACKET_RESERVE call has no effect,\n\t\t * so falling back on read-from-the-socket capturing\n\t\t * won't be affected.\n\t\t */\n\t\tlen = sizeof(tp_reserve);\n\t\tif (setsockopt(handle->fd, SOL_PACKET, PACKET_RESERVE,\n\t\t    &tp_reserve, len) < 0) {\n\t\t\t/*\n\t\t\t * We treat ENOPROTOOPT as an error, as we\n\t\t\t * already determined that we support\n\t\t\t * TPACKET_V2 and later; see above.\n\t\t\t */\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"setsockopt (PACKET_RESERVE)\");\n\t\t\t*status = PCAP_ERROR;\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Older kernel, so we can't use PACKET_RESERVE;\n\t\t * this means we can't reserver extra space\n\t\t * for a DLT_LINUX_SLL2 header.\n\t\t *\n\t\t * Those kernels don't supply the information\n\t\t * necessary to reconstruct the VLAN tag, so\n\t\t * that's not an issue here, and we don't allow\n\t\t * DLT_LINUX_SLL2 if we can't use PACKET_RESERVE,\n\t\t * so that shouldn't be an issue.\n\t\t */\n\t\ttp_reserve = 0;\t/* nothing reserved */\n\t}\n#else\n\t/*\n\t * Build environment for an older kernel, so we can't use\n\t * PACKET_RESERVE.\n\t *\n\t * Those kernels don't supply the information necessary\n\t * to reconstruct the VLAN tag, so that's not an issue\n\t * here, and we don't allow DLT_LINUX_SLL2 if we can't\n\t * use PACKET_RESERVE, so that shouldn't be an issue.\n\t */\n\ttp_reserve = 0;\t/* nothing reserved */\n#endif\n\n\tswitch (handlep->tp_version) {\n\n\tcase TPACKET_V1:\n\tcase TPACKET_V1_64:\n#ifdef HAVE_TPACKET2\n\tcase TPACKET_V2:\n#endif\n\t\t/* Note that with large snapshot length (say 256K, which is\n\t\t * the default for recent versions of tcpdump, Wireshark,\n\t\t * TShark, dumpcap or 64K, the value that \"-s 0\" has given for\n\t\t * a long time with tcpdump), if we use the snapshot\n\t\t * length to calculate the frame length, only a few frames\n\t\t * will be available in the ring even with pretty\n\t\t * large ring size (and a lot of memory will be unused).\n\t\t *\n\t\t * Ideally, we should choose a frame length based on the\n\t\t * minimum of the specified snapshot length and the maximum\n\t\t * packet size.  That's not as easy as it sounds; consider,\n\t\t * for example, an 802.11 interface in monitor mode, where\n\t\t * the frame would include a radiotap header, where the\n\t\t * maximum radiotap header length is device-dependent.\n\t\t *\n\t\t * So, for now, we just do this for Ethernet devices, where\n\t\t * there's no metadata header, and the link-layer header is\n\t\t * fixed length.  We can get the maximum packet size by\n\t\t * adding 18, the Ethernet header length plus the CRC length\n\t\t * (just in case we happen to get the CRC in the packet), to\n\t\t * the MTU of the interface; we fetch the MTU in the hopes\n\t\t * that it reflects support for jumbo frames.  (Even if the\n\t\t * interface is just being used for passive snooping, the\n\t\t * driver might set the size of buffers in the receive ring\n\t\t * based on the MTU, so that the MTU limits the maximum size\n\t\t * of packets that we can receive.)\n\t\t *\n\t\t * If segmentation/fragmentation or receive offload are\n\t\t * enabled, we can get reassembled/aggregated packets larger\n\t\t * than MTU, but bounded to 65535 plus the Ethernet overhead,\n\t\t * due to kernel and protocol constraints */\n\t\tframe_size = handle->snapshot;\n\t\tif (handle->linktype == DLT_EN10MB) {\n\t\t\tunsigned int max_frame_len;\n\t\t\tint mtu;\n\t\t\tint offload;\n\n\t\t\tmtu = iface_get_mtu(handle->fd, handle->opt.device,\n\t\t\t    handle->errbuf);\n\t\t\tif (mtu == -1) {\n\t\t\t\t*status = PCAP_ERROR;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\toffload = iface_get_offload(handle);\n\t\t\tif (offload == -1) {\n\t\t\t\t*status = PCAP_ERROR;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (offload)\n\t\t\t\tmax_frame_len = MAX(mtu, 65535);\n\t\t\telse\n\t\t\t\tmax_frame_len = mtu;\n\t\t\tmax_frame_len += 18;\n\n\t\t\tif (frame_size > max_frame_len)\n\t\t\t\tframe_size = max_frame_len;\n\t\t}\n\n\t\t/* NOTE: calculus matching those in tpacket_rcv()\n\t\t * in linux-2.6/net/packet/af_packet.c\n\t\t */\n\t\tlen = sizeof(sk_type);\n\t\tif (getsockopt(handle->fd, SOL_SOCKET, SO_TYPE, &sk_type,\n\t\t    &len) < 0) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"getsockopt (SO_TYPE)\");\n\t\t\t*status = PCAP_ERROR;\n\t\t\treturn -1;\n\t\t}\n\t\tmaclen = (sk_type == SOCK_DGRAM) ? 0 : MAX_LINKHEADER_SIZE;\n\t\t\t/* XXX: in the kernel maclen is calculated from\n\t\t\t * LL_ALLOCATED_SPACE(dev) and vnet_hdr.hdr_len\n\t\t\t * in:  packet_snd()           in linux-2.6/net/packet/af_packet.c\n\t\t\t * then packet_alloc_skb()     in linux-2.6/net/packet/af_packet.c\n\t\t\t * then sock_alloc_send_pskb() in linux-2.6/net/core/sock.c\n\t\t\t * but I see no way to get those sizes in userspace,\n\t\t\t * like for instance with an ifreq ioctl();\n\t\t\t * the best thing I've found so far is MAX_HEADER in\n\t\t\t * the kernel part of linux-2.6/include/linux/netdevice.h\n\t\t\t * which goes up to 128+48=176; since pcap-linux.c\n\t\t\t * defines a MAX_LINKHEADER_SIZE of 256 which is\n\t\t\t * greater than that, let's use it.. maybe is it even\n\t\t\t * large enough to directly replace macoff..\n\t\t\t */\n\t\ttp_hdrlen = TPACKET_ALIGN(handlep->tp_hdrlen) + sizeof(struct sockaddr_ll) ;\n\t\tnetoff = TPACKET_ALIGN(tp_hdrlen + (maclen < 16 ? 16 : maclen)) + tp_reserve;\n\t\t\t/* NOTE: AFAICS tp_reserve may break the TPACKET_ALIGN\n\t\t\t * of netoff, which contradicts\n\t\t\t * linux-2.6/Documentation/networking/packet_mmap.txt\n\t\t\t * documenting that:\n\t\t\t * \"- Gap, chosen so that packet data (Start+tp_net)\n\t\t\t * aligns to TPACKET_ALIGNMENT=16\"\n\t\t\t */\n\t\t\t/* NOTE: in linux-2.6/include/linux/skbuff.h:\n\t\t\t * \"CPUs often take a performance hit\n\t\t\t *  when accessing unaligned memory locations\"\n\t\t\t */\n\t\tmacoff = netoff - maclen;\n\t\treq.tp_frame_size = TPACKET_ALIGN(macoff + frame_size);\n\t\t/*\n\t\t * Round the buffer size up to a multiple of the\n\t\t * frame size (rather than rounding down, which\n\t\t * would give a buffer smaller than our caller asked\n\t\t * for, and possibly give zero frames if the requested\n\t\t * buffer size is too small for one frame).\n\t\t */\n\t\treq.tp_frame_nr = (handle->opt.buffer_size + req.tp_frame_size - 1)/req.tp_frame_size;\n\t\tbreak;\n\n#ifdef HAVE_TPACKET3\n\tcase TPACKET_V3:\n\t\t/* The \"frames\" for this are actually buffers that\n\t\t * contain multiple variable-sized frames.\n\t\t *\n\t\t * We pick a \"frame\" size of MAXIMUM_SNAPLEN to leave\n\t\t * enough room for at least one reasonably-sized packet\n\t\t * in the \"frame\". */\n\t\treq.tp_frame_size = MAXIMUM_SNAPLEN;\n\t\t/*\n\t\t * Round the buffer size up to a multiple of the\n\t\t * \"frame\" size (rather than rounding down, which\n\t\t * would give a buffer smaller than our caller asked\n\t\t * for, and possibly give zero \"frames\" if the requested\n\t\t * buffer size is too small for one \"frame\").\n\t\t */\n\t\treq.tp_frame_nr = (handle->opt.buffer_size + req.tp_frame_size - 1)/req.tp_frame_size;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Internal error: unknown TPACKET_ value %u\",\n\t\t    handlep->tp_version);\n\t\t*status = PCAP_ERROR;\n\t\treturn -1;\n\t}\n\n\t/* compute the minumum block size that will handle this frame.\n\t * The block has to be page size aligned.\n\t * The max block size allowed by the kernel is arch-dependent and\n\t * it's not explicitly checked here. */\n\treq.tp_block_size = getpagesize();\n\twhile (req.tp_block_size < req.tp_frame_size)\n\t\treq.tp_block_size <<= 1;\n\n\tframes_per_block = req.tp_block_size/req.tp_frame_size;\n\n\t/*\n\t * PACKET_TIMESTAMP was added after linux/net_tstamp.h was,\n\t * so we check for PACKET_TIMESTAMP.  We check for\n\t * linux/net_tstamp.h just in case a system somehow has\n\t * PACKET_TIMESTAMP but not linux/net_tstamp.h; that might\n\t * be unnecessary.\n\t *\n\t * SIOCSHWTSTAMP was introduced in the patch that introduced\n\t * linux/net_tstamp.h, so we don't bother checking whether\n\t * SIOCSHWTSTAMP is defined (if your Linux system has\n\t * linux/net_tstamp.h but doesn't define SIOCSHWTSTAMP, your\n\t * Linux system is badly broken).\n\t */\n#if defined(HAVE_LINUX_NET_TSTAMP_H) && defined(PACKET_TIMESTAMP)\n\t/*\n\t * If we were told to do so, ask the kernel and the driver\n\t * to use hardware timestamps.\n\t *\n\t * Hardware timestamps are only supported with mmapped\n\t * captures.\n\t */\n\tif (handle->opt.tstamp_type == PCAP_TSTAMP_ADAPTER ||\n\t    handle->opt.tstamp_type == PCAP_TSTAMP_ADAPTER_UNSYNCED) {\n\t\tstruct hwtstamp_config hwconfig;\n\t\tstruct ifreq ifr;\n\t\tint timesource;\n\n\t\t/*\n\t\t * Ask for hardware time stamps on all packets,\n\t\t * including transmitted packets.\n\t\t */\n\t\tmemset(&hwconfig, 0, sizeof(hwconfig));\n\t\thwconfig.tx_type = HWTSTAMP_TX_ON;\n\t\thwconfig.rx_filter = HWTSTAMP_FILTER_ALL;\n\n\t\tmemset(&ifr, 0, sizeof(ifr));\n\t\tpcap_strlcpy(ifr.ifr_name, handle->opt.device, sizeof(ifr.ifr_name));\n\t\tifr.ifr_data = (void *)&hwconfig;\n\n\t\tif (ioctl(handle->fd, SIOCSHWTSTAMP, &ifr) < 0) {\n\t\t\tswitch (errno) {\n\n\t\t\tcase EPERM:\n\t\t\t\t/*\n\t\t\t\t * Treat this as an error, as the\n\t\t\t\t * user should try to run this\n\t\t\t\t * with the appropriate privileges -\n\t\t\t\t * and, if they can't, shouldn't\n\t\t\t\t * try requesting hardware time stamps.\n\t\t\t\t */\n\t\t\t\t*status = PCAP_ERROR_PERM_DENIED;\n\t\t\t\treturn -1;\n\n\t\t\tcase EOPNOTSUPP:\n\t\t\tcase ERANGE:\n\t\t\t\t/*\n\t\t\t\t * Treat this as a warning, as the\n\t\t\t\t * only way to fix the warning is to\n\t\t\t\t * get an adapter that supports hardware\n\t\t\t\t * time stamps for *all* packets.\n\t\t\t\t * (ERANGE means \"we support hardware\n\t\t\t\t * time stamps, but for packets matching\n\t\t\t\t * that particular filter\", so it means\n\t\t\t\t * \"we don't support hardware time stamps\n\t\t\t\t * for all incoming packets\" here.)\n\t\t\t\t *\n\t\t\t\t * We'll just fall back on the standard\n\t\t\t\t * host time stamps.\n\t\t\t\t */\n\t\t\t\t*status = PCAP_WARNING_TSTAMP_TYPE_NOTSUP;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"SIOCSHWTSTAMP failed\");\n\t\t\t\t*status = PCAP_ERROR;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Well, that worked.  Now specify the type of\n\t\t\t * hardware time stamp we want for this\n\t\t\t * socket.\n\t\t\t */\n\t\t\tif (handle->opt.tstamp_type == PCAP_TSTAMP_ADAPTER) {\n\t\t\t\t/*\n\t\t\t\t * Hardware timestamp, synchronized\n\t\t\t\t * with the system clock.\n\t\t\t\t */\n\t\t\t\ttimesource = SOF_TIMESTAMPING_SYS_HARDWARE;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * PCAP_TSTAMP_ADAPTER_UNSYNCED - hardware\n\t\t\t\t * timestamp, not synchronized with the\n\t\t\t\t * system clock.\n\t\t\t\t */\n\t\t\t\ttimesource = SOF_TIMESTAMPING_RAW_HARDWARE;\n\t\t\t}\n\t\t\tif (setsockopt(handle->fd, SOL_PACKET, PACKET_TIMESTAMP,\n\t\t\t\t(void *)&timesource, sizeof(timesource))) {\n\t\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"can't set PACKET_TIMESTAMP\");\n\t\t\t\t*status = PCAP_ERROR;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n#endif /* HAVE_LINUX_NET_TSTAMP_H && PACKET_TIMESTAMP */\n\n\t/* ask the kernel to create the ring */\nretry:\n\treq.tp_block_nr = req.tp_frame_nr / frames_per_block;\n\n\t/* req.tp_frame_nr is requested to match frames_per_block*req.tp_block_nr */\n\treq.tp_frame_nr = req.tp_block_nr * frames_per_block;\n\n#ifdef HAVE_TPACKET3\n\t/* timeout value to retire block - use the configured buffering timeout, or default if <0. */\n\treq.tp_retire_blk_tov = (handlep->timeout>=0)?handlep->timeout:0;\n\t/* private data not used */\n\treq.tp_sizeof_priv = 0;\n\t/* Rx ring - feature request bits - none (rxhash will not be filled) */\n\treq.tp_feature_req_word = 0;\n#endif\n\n\tif (setsockopt(handle->fd, SOL_PACKET, PACKET_RX_RING,\n\t\t\t\t\t(void *) &req, sizeof(req))) {\n\t\tif ((errno == ENOMEM) && (req.tp_block_nr > 1)) {\n\t\t\t/*\n\t\t\t * Memory failure; try to reduce the requested ring\n\t\t\t * size.\n\t\t\t *\n\t\t\t * We used to reduce this by half -- do 5% instead.\n\t\t\t * That may result in more iterations and a longer\n\t\t\t * startup, but the user will be much happier with\n\t\t\t * the resulting buffer size.\n\t\t\t */\n\t\t\tif (req.tp_frame_nr < 20)\n\t\t\t\treq.tp_frame_nr -= 1;\n\t\t\telse\n\t\t\t\treq.tp_frame_nr -= req.tp_frame_nr/20;\n\t\t\tgoto retry;\n\t\t}\n\t\tif (errno == ENOPROTOOPT) {\n\t\t\t/*\n\t\t\t * We don't have ring buffer support in this kernel.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"can't create rx ring on packet socket\");\n\t\t*status = PCAP_ERROR;\n\t\treturn -1;\n\t}\n\n\t/* memory map the rx ring */\n\thandlep->mmapbuflen = req.tp_block_nr * req.tp_block_size;\n\thandlep->mmapbuf = mmap(0, handlep->mmapbuflen,\n\t    PROT_READ|PROT_WRITE, MAP_SHARED, handle->fd, 0);\n\tif (handlep->mmapbuf == MAP_FAILED) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"can't mmap rx ring\");\n\n\t\t/* clear the allocated ring on error*/\n\t\tdestroy_ring(handle);\n\t\t*status = PCAP_ERROR;\n\t\treturn -1;\n\t}\n\n\t/* allocate a ring for each frame header pointer*/\n\thandle->cc = req.tp_frame_nr;\n\thandle->buffer = malloc(handle->cc * sizeof(union thdr *));\n\tif (!handle->buffer) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"can't allocate ring of frame headers\");\n\n\t\tdestroy_ring(handle);\n\t\t*status = PCAP_ERROR;\n\t\treturn -1;\n\t}\n\n\t/* fill the header ring with proper frame ptr*/\n\thandle->offset = 0;\n\tfor (i=0; i<req.tp_block_nr; ++i) {\n\t\tvoid *base = &handlep->mmapbuf[i*req.tp_block_size];\n\t\tfor (j=0; j<frames_per_block; ++j, ++handle->offset) {\n\t\t\tRING_GET_CURRENT_FRAME(handle) = base;\n\t\t\tbase += req.tp_frame_size;\n\t\t}\n\t}\n\n\thandle->bufsize = req.tp_frame_size;\n\thandle->offset = 0;\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              4427,
              0
            ],
            [
              4882,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "create_ring",
            "parameters": {
              "handle": "pcap_t",
              "status": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ndestroy_ring(pcap_t *handle)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\n\t/* tell the kernel to destroy the ring*/\n\tstruct tpacket_req req;\n\tmemset(&req, 0, sizeof(req));\n\t/* do not test for setsockopt failure, as we can't recover from any error */\n\t(void)setsockopt(handle->fd, SOL_PACKET, PACKET_RX_RING,\n\t\t\t\t(void *) &req, sizeof(req));\n\n\t/* if ring is mapped, unmap it*/\n\tif (handlep->mmapbuf) {\n\t\t/* do not test for mmap failure, as we can't recover from any error */\n\t\t(void)munmap(handlep->mmapbuf, handlep->mmapbuflen);\n\t\thandlep->mmapbuf = NULL;\n\t}\n}",
          "fn_code_pos": [
            [
              4885,
              0
            ],
            [
              4903,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "destroy_ring",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\npcap_oneshot_mmap(u_char *user, const struct pcap_pkthdr *h,\n    const u_char *bytes)\n{\n\tstruct oneshot_userdata *sp = (struct oneshot_userdata *)user;\n\tpcap_t *handle = sp->pd;\n\tstruct pcap_linux *handlep = handle->priv;\n\n\t*sp->hdr = *h;\n\tmemcpy(handlep->oneshot_buffer, bytes, h->caplen);\n\t*sp->pkt = handlep->oneshot_buffer;\n}",
          "fn_code_pos": [
            [
              4922,
              0
            ],
            [
              4933,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_oneshot_mmap",
            "parameters": {
              "user": "u_char",
              "h": "struct pcap_pkthdr",
              "bytes": "u_char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\npcap_cleanup_linux_mmap( pcap_t *handle )\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\n\tdestroy_ring(handle);\n\tif (handlep->oneshot_buffer != NULL) {\n\t\tfree(handlep->oneshot_buffer);\n\t\thandlep->oneshot_buffer = NULL;\n\t}\n\tpcap_cleanup_linux(handle);\n}",
          "fn_code_pos": [
            [
              4935,
              0
            ],
            [
              4946,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_cleanup_linux_mmap",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\npcap_getnonblock_mmap(pcap_t *handle)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\n\t/* use negative value of timeout to indicate non blocking ops */\n\treturn (handlep->timeout<0);\n}",
          "fn_code_pos": [
            [
              4949,
              0
            ],
            [
              4956,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getnonblock_mmap",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setnonblock_mmap(pcap_t *handle, int nonblock)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\n\t/*\n\t * Set the file descriptor to non-blocking mode, as we use\n\t * it for sending packets.\n\t */\n\tif (pcap_setnonblock_fd(handle, nonblock) == -1)\n\t\treturn -1;\n\n\t/*\n\t * Map each value to their corresponding negation to\n\t * preserve the timeout value provided with pcap_set_timeout.\n\t */\n\tif (nonblock) {\n\t\tif (handlep->timeout >= 0) {\n\t\t\t/*\n\t\t\t * Indicate that we're switching to\n\t\t\t * non-blocking mode.\n\t\t\t */\n\t\t\thandlep->timeout = ~handlep->timeout;\n\t\t}\n\t} else {\n\t\tif (handlep->timeout < 0) {\n\t\t\thandlep->timeout = ~handlep->timeout;\n\t\t}\n\t}\n\t/* Update the timeout to use in poll(). */\n\tset_poll_timeout(handlep);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              4958,
              0
            ],
            [
              4990,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setnonblock_mmap",
            "parameters": {
              "handle": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static inline u_int\npcap_get_ring_frame_status(pcap_t *handle, int offset)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tunion thdr h;\n\n\th.raw = RING_GET_FRAME_AT(handle, offset);\n\tswitch (handlep->tp_version) {\n\tcase TPACKET_V1:\n\t\t/*\n\t\t * This is an unsigned long, but only the lower 32\n\t\t * bits are used.\n\t\t */\n\t\treturn (u_int)(h.h1->tp_status);\n\t\tbreak;\n\tcase TPACKET_V1_64:\n\t\t/*\n\t\t * This is an unsigned long in the kernel, which is 64-bit,\n\t\t * but only the lower 32 bits are used.\n\t\t */\n\t\treturn (u_int)(h.h1_64->tp_status);\n\t\tbreak;\n#ifdef HAVE_TPACKET2\n\tcase TPACKET_V2:\n\t\treturn (h.h2->tp_status);\n\t\tbreak;\n#endif\n#ifdef HAVE_TPACKET3\n\tcase TPACKET_V3:\n\t\treturn (h.h3->hdr.bh1.block_status);\n\t\tbreak;\n#endif\n\t}\n\t/* This should not happen. */\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              4995,
              0
            ],
            [
              5030,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_get_ring_frame_status",
            "parameters": {
              "handle": "pcap_t",
              "offset": "int"
            },
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "static int pcap_wait_for_frames_mmap(pcap_t *handle)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tchar c;\n\tint ret;\n#ifdef HAVE_SYS_EVENTFD_H\n\tstruct pollfd pollinfo[2];\n\tpollinfo[1].fd = handlep->poll_breakloop_fd;\n\tpollinfo[1].events = POLLIN;\n#else\n\tstruct pollfd pollinfo[1];\n#endif\n\tpollinfo[0].fd = handle->fd;\n\tpollinfo[0].events = POLLIN;\n\n\tdo {\n\t\t/*\n\t\t * Yes, we do this even in non-blocking mode, as it's\n\t\t * the only way to get error indications from a\n\t\t * tpacket socket.\n\t\t *\n\t\t * The timeout is 0 in non-blocking mode, so poll()\n\t\t * returns immediately.\n\t\t */\n\n#ifdef HAVE_SYS_EVENTFD_H\n\t\tret = poll(pollinfo, 2, handlep->poll_timeout);\n#else\n\t\tret = poll(pollinfo, 1, handlep->poll_timeout);\n#endif\n\t\tif (ret < 0 && errno != EINTR) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"can't poll on packet socket\");\n\t\t\treturn PCAP_ERROR;\n\t\t} else if (ret > 0 && pollinfo[0].revents &&\n\t\t\t(pollinfo[0].revents & (POLLHUP|POLLRDHUP|POLLERR|POLLNVAL))) {\n\t\t\t/*\n\t\t\t * There's some indication other than\n\t\t\t * \"you can read on this descriptor\" on\n\t\t\t * the descriptor.\n\t\t\t */\n\t\t\tif (pollinfo[0].revents & (POLLHUP | POLLRDHUP)) {\n\t\t\t\tpcap_snprintf(handle->errbuf,\n\t\t\t\t\tPCAP_ERRBUF_SIZE,\n\t\t\t\t\t\"Hangup on packet socket\");\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t\tif (pollinfo[0].revents & POLLERR) {\n\t\t\t\t/*\n\t\t\t\t * A recv() will give us the actual error code.\n\t\t\t\t *\n\t\t\t\t * XXX - make the socket non-blocking?\n\t\t\t\t */\n\t\t\t\tif (recv(handle->fd, &c, sizeof c,\n\t\t\t\t\tMSG_PEEK) != -1)\n\t\t\t\t\tcontinue;\t/* what, no error? */\n\t\t\t\tif (errno == ENETDOWN) {\n\t\t\t\t\t/*\n\t\t\t\t\t * The device on which we're\n\t\t\t\t\t * capturing went away.\n\t\t\t\t\t *\n\t\t\t\t\t * XXX - we should really return\n\t\t\t\t\t * PCAP_ERROR_IFACE_NOT_UP, but\n\t\t\t\t\t * pcap_dispatch() etc. aren't\n\t\t\t\t\t * defined to return that.\n\t\t\t\t\t */\n\t\t\t\t\tpcap_snprintf(handle->errbuf,\n\t\t\t\t\t\tPCAP_ERRBUF_SIZE,\n\t\t\t\t\t\t\"The interface went down\");\n\t\t\t\t} else {\n\t\t\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"Error condition on packet socket\");\n\t\t\t\t}\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t\tif (pollinfo[0].revents & POLLNVAL) {\n\t\t\t\tpcap_snprintf(handle->errbuf,\n\t\t\t\t\tPCAP_ERRBUF_SIZE,\n\t\t\t\t\t\"Invalid polling request on packet socket\");\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t}\n\n#ifdef HAVE_SYS_EVENTFD_H\n\t\tif (pollinfo[1].revents & POLLIN) {\n\t\t\tuint64_t value;\n\t\t\t(void)read(handlep->poll_breakloop_fd, &value, sizeof(value));\n\t\t}\n#endif\n\n\t\t/* check for break loop condition on interrupted syscall*/\n\t\tif (handle->break_loop) {\n\t\t\thandle->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\t} while (ret < 0);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              5039,
              0
            ],
            [
              5138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_wait_for_frames_mmap",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_handle_packet_mmap(\n\t\tpcap_t *handle,\n\t\tpcap_handler callback,\n\t\tu_char *user,\n\t\tunsigned char *frame,\n\t\tunsigned int tp_len,\n\t\tunsigned int tp_mac,\n\t\tunsigned int tp_snaplen,\n\t\tunsigned int tp_sec,\n\t\tunsigned int tp_usec,\n\t\tint tp_vlan_tci_valid,\n\t\t__u16 tp_vlan_tci,\n\t\t__u16 tp_vlan_tpid)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tunsigned char *bp;\n\tstruct sockaddr_ll *sll;\n\tstruct pcap_pkthdr pcaphdr;\n\tunsigned int snaplen = tp_snaplen;\n\tstruct utsname utsname;\n\n\t/* perform sanity check on internal offset. */\n\tif (tp_mac + tp_snaplen > handle->bufsize) {\n\t\t/*\n\t\t * Report some system information as a debugging aid.\n\t\t */\n\t\tif (uname(&utsname) != -1) {\n\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\"corrupted frame on kernel ring mac \"\n\t\t\t\t\"offset %u + caplen %u > frame len %d \"\n\t\t\t\t\"(kernel %.32s version %s, machine %.16s)\",\n\t\t\t\ttp_mac, tp_snaplen, handle->bufsize,\n\t\t\t\tutsname.release, utsname.version,\n\t\t\t\tutsname.machine);\n\t\t} else {\n\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\"corrupted frame on kernel ring mac \"\n\t\t\t\t\"offset %u + caplen %u > frame len %d\",\n\t\t\t\ttp_mac, tp_snaplen, handle->bufsize);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* run filter on received packet\n\t * If the kernel filtering is enabled we need to run the\n\t * filter until all the frames present into the ring\n\t * at filter creation time are processed.\n\t * In this case, blocks_to_filter_in_userland is used\n\t * as a counter for the packet we need to filter.\n\t * Note: alternatively it could be possible to stop applying\n\t * the filter when the ring became empty, but it can possibly\n\t * happen a lot later... */\n\tbp = frame + tp_mac;\n\n\t/* if required build in place the sll header*/\n\tsll = (void *)frame + TPACKET_ALIGN(handlep->tp_hdrlen);\n\tif (handlep->cooked) {\n\t\tif (handle->linktype == DLT_LINUX_SLL2) {\n\t\t\tstruct sll2_header *hdrp;\n\n\t\t\t/*\n\t\t\t * The kernel should have left us with enough\n\t\t\t * space for an sll header; back up the packet\n\t\t\t * data pointer into that space, as that'll be\n\t\t\t * the beginning of the packet we pass to the\n\t\t\t * callback.\n\t\t\t */\n\t\t\tbp -= SLL2_HDR_LEN;\n\n\t\t\t/*\n\t\t\t * Let's make sure that's past the end of\n\t\t\t * the tpacket header, i.e. >=\n\t\t\t * ((u_char *)thdr + TPACKET_HDRLEN), so we\n\t\t\t * don't step on the header when we construct\n\t\t\t * the sll header.\n\t\t\t */\n\t\t\tif (bp < (u_char *)frame +\n\t\t\t\t\t   TPACKET_ALIGN(handlep->tp_hdrlen) +\n\t\t\t\t\t   sizeof(struct sockaddr_ll)) {\n\t\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\"cooked-mode frame doesn't have room for sll header\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * OK, that worked; construct the sll header.\n\t\t\t */\n\t\t\thdrp = (struct sll2_header *)bp;\n\t\t\thdrp->sll2_protocol = sll->sll_protocol;\n\t\t\thdrp->sll2_reserved_mbz = 0;\n\t\t\thdrp->sll2_if_index = htonl(sll->sll_ifindex);\n\t\t\thdrp->sll2_hatype = htons(sll->sll_hatype);\n\t\t\thdrp->sll2_pkttype = sll->sll_pkttype;\n\t\t\thdrp->sll2_halen = sll->sll_halen;\n\t\t\tmemcpy(hdrp->sll2_addr, sll->sll_addr, SLL_ADDRLEN);\n\n\t\t\tsnaplen += sizeof(struct sll2_header);\n\t\t} else {\n\t\t\tstruct sll_header *hdrp;\n\n\t\t\t/*\n\t\t\t * The kernel should have left us with enough\n\t\t\t * space for an sll header; back up the packet\n\t\t\t * data pointer into that space, as that'll be\n\t\t\t * the beginning of the packet we pass to the\n\t\t\t * callback.\n\t\t\t */\n\t\t\tbp -= SLL_HDR_LEN;\n\n\t\t\t/*\n\t\t\t * Let's make sure that's past the end of\n\t\t\t * the tpacket header, i.e. >=\n\t\t\t * ((u_char *)thdr + TPACKET_HDRLEN), so we\n\t\t\t * don't step on the header when we construct\n\t\t\t * the sll header.\n\t\t\t */\n\t\t\tif (bp < (u_char *)frame +\n\t\t\t\t\t   TPACKET_ALIGN(handlep->tp_hdrlen) +\n\t\t\t\t\t   sizeof(struct sockaddr_ll)) {\n\t\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\"cooked-mode frame doesn't have room for sll header\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * OK, that worked; construct the sll header.\n\t\t\t */\n\t\t\thdrp = (struct sll_header *)bp;\n\t\t\thdrp->sll_pkttype = htons(sll->sll_pkttype);\n\t\t\thdrp->sll_hatype = htons(sll->sll_hatype);\n\t\t\thdrp->sll_halen = htons(sll->sll_halen);\n\t\t\tmemcpy(hdrp->sll_addr, sll->sll_addr, SLL_ADDRLEN);\n\t\t\thdrp->sll_protocol = sll->sll_protocol;\n\n\t\t\tsnaplen += sizeof(struct sll_header);\n\t\t}\n\t}\n\n\tif (handlep->filter_in_userland && handle->fcode.bf_insns) {\n\t\tstruct bpf_aux_data aux_data;\n\n\t\taux_data.vlan_tag_present = tp_vlan_tci_valid;\n\t\taux_data.vlan_tag = tp_vlan_tci & 0x0fff;\n\n\t\tif (pcap_filter_with_aux_data(handle->fcode.bf_insns,\n\t\t\t\t\t      bp,\n\t\t\t\t\t      tp_len,\n\t\t\t\t\t      snaplen,\n\t\t\t\t\t      &aux_data) == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (!linux_check_direction(handle, sll))\n\t\treturn 0;\n\n\t/* get required packet info from ring header */\n\tpcaphdr.ts.tv_sec = tp_sec;\n\tpcaphdr.ts.tv_usec = tp_usec;\n\tpcaphdr.caplen = tp_snaplen;\n\tpcaphdr.len = tp_len;\n\n\t/* if required build in place the sll header*/\n\tif (handlep->cooked) {\n\t\t/* update packet len */\n\t\tif (handle->linktype == DLT_LINUX_SLL2) {\n\t\t\tpcaphdr.caplen += SLL2_HDR_LEN;\n\t\t\tpcaphdr.len += SLL2_HDR_LEN;\n\t\t} else {\n\t\t\tpcaphdr.caplen += SLL_HDR_LEN;\n\t\t\tpcaphdr.len += SLL_HDR_LEN;\n\t\t}\n\t}\n\n#if defined(HAVE_TPACKET2) || defined(HAVE_TPACKET3)\n\tif (tp_vlan_tci_valid &&\n\t\thandlep->vlan_offset != -1 &&\n\t\ttp_snaplen >= (unsigned int) handlep->vlan_offset)\n\t{\n\t\tstruct vlan_tag *tag;\n\n\t\t/*\n\t\t * Move everything in the header, except the type field,\n\t\t * down VLAN_TAG_LEN bytes, to allow us to insert the\n\t\t * VLAN tag between that stuff and the type field.\n\t\t */\n\t\tbp -= VLAN_TAG_LEN;\n\t\tmemmove(bp, bp + VLAN_TAG_LEN, handlep->vlan_offset);\n\n\t\t/*\n\t\t * Now insert the tag.\n\t\t */\n\t\ttag = (struct vlan_tag *)(bp + handlep->vlan_offset);\n\t\ttag->vlan_tpid = htons(tp_vlan_tpid);\n\t\ttag->vlan_tci = htons(tp_vlan_tci);\n\n\t\t/*\n\t\t * Add the tag to the packet lengths.\n\t\t */\n\t\tpcaphdr.caplen += VLAN_TAG_LEN;\n\t\tpcaphdr.len += VLAN_TAG_LEN;\n\t}\n#endif\n\n\t/*\n\t * The only way to tell the kernel to cut off the\n\t * packet at a snapshot length is with a filter program;\n\t * if there's no filter program, the kernel won't cut\n\t * the packet off.\n\t *\n\t * Trim the snapshot length to be no longer than the\n\t * specified snapshot length.\n\t */\n\tif (pcaphdr.caplen > (bpf_u_int32)handle->snapshot)\n\t\tpcaphdr.caplen = handle->snapshot;\n\n\t/* pass the packet to the user */\n\tcallback(user, &pcaphdr, bp);\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              5141,
              0
            ],
            [
              5360,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_handle_packet_mmap",
            "parameters": {
              "handle": "pcap_t",
              "callback": "pcap_handler",
              "user": "u_char",
              "frame": "unsigned char",
              "tp_len": "unsigned int",
              "tp_mac": "unsigned int",
              "tp_snaplen": "unsigned int",
              "tp_sec": "unsigned int",
              "tp_usec": "unsigned int",
              "tp_vlan_tci_valid": "int",
              "tp_vlan_tci": "__u16",
              "tp_vlan_tpid": "__u16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_read_linux_mmap_v1(pcap_t *handle, int max_packets, pcap_handler callback,\n\t\tu_char *user)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tunion thdr h;\n\tint pkts = 0;\n\tint ret;\n\n\t/* wait for frames availability.*/\n\th.raw = RING_GET_CURRENT_FRAME(handle);\n\tif (h.h1->tp_status == TP_STATUS_KERNEL) {\n\t\t/*\n\t\t * The current frame is owned by the kernel; wait for\n\t\t * a frame to be handed to us.\n\t\t */\n\t\tret = pcap_wait_for_frames_mmap(handle);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* non-positive values of max_packets are used to require all\n\t * packets currently available in the ring */\n\twhile ((pkts < max_packets) || PACKET_COUNT_IS_UNLIMITED(max_packets)) {\n\t\t/*\n\t\t * Get the current ring buffer frame, and break if\n\t\t * it's still owned by the kernel.\n\t\t */\n\t\th.raw = RING_GET_CURRENT_FRAME(handle);\n\t\tif (h.h1->tp_status == TP_STATUS_KERNEL)\n\t\t\tbreak;\n\n\t\tret = pcap_handle_packet_mmap(\n\t\t\t\thandle,\n\t\t\t\tcallback,\n\t\t\t\tuser,\n\t\t\t\th.raw,\n\t\t\t\th.h1->tp_len,\n\t\t\t\th.h1->tp_mac,\n\t\t\t\th.h1->tp_snaplen,\n\t\t\t\th.h1->tp_sec,\n\t\t\t\th.h1->tp_usec,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0);\n\t\tif (ret == 1) {\n\t\t\tpkts++;\n\t\t\thandlep->packets_read++;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t/*\n\t\t * Hand this block back to the kernel, and, if we're\n\t\t * counting blocks that need to be filtered in userland\n\t\t * after having been filtered by the kernel, count\n\t\t * the one we've just processed.\n\t\t */\n\t\th.h1->tp_status = TP_STATUS_KERNEL;\n\t\tif (handlep->blocks_to_filter_in_userland > 0) {\n\t\t\thandlep->blocks_to_filter_in_userland--;\n\t\t\tif (handlep->blocks_to_filter_in_userland == 0) {\n\t\t\t\t/*\n\t\t\t\t * No more blocks need to be filtered\n\t\t\t\t * in userland.\n\t\t\t\t */\n\t\t\t\thandlep->filter_in_userland = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* next block */\n\t\tif (++handle->offset >= handle->cc)\n\t\t\thandle->offset = 0;\n\n\t\t/* check for break loop condition*/\n\t\tif (handle->break_loop) {\n\t\t\thandle->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\t}\n\treturn pkts;\n}",
          "fn_code_pos": [
            [
              5362,
              0
            ],
            [
              5444,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_linux_mmap_v1",
            "parameters": {
              "handle": "pcap_t",
              "max_packets": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_read_linux_mmap_v1_64(pcap_t *handle, int max_packets, pcap_handler callback,\n\t\tu_char *user)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tunion thdr h;\n\tint pkts = 0;\n\tint ret;\n\n\t/* wait for frames availability.*/\n\th.raw = RING_GET_CURRENT_FRAME(handle);\n\tif (h.h1_64->tp_status == TP_STATUS_KERNEL) {\n\t\t/*\n\t\t * The current frame is owned by the kernel; wait for\n\t\t * a frame to be handed to us.\n\t\t */\n\t\tret = pcap_wait_for_frames_mmap(handle);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* non-positive values of max_packets are used to require all\n\t * packets currently available in the ring */\n\twhile ((pkts < max_packets) || PACKET_COUNT_IS_UNLIMITED(max_packets)) {\n\t\t/*\n\t\t * Get the current ring buffer frame, and break if\n\t\t * it's still owned by the kernel.\n\t\t */\n\t\th.raw = RING_GET_CURRENT_FRAME(handle);\n\t\tif (h.h1_64->tp_status == TP_STATUS_KERNEL)\n\t\t\tbreak;\n\n\t\tret = pcap_handle_packet_mmap(\n\t\t\t\thandle,\n\t\t\t\tcallback,\n\t\t\t\tuser,\n\t\t\t\th.raw,\n\t\t\t\th.h1_64->tp_len,\n\t\t\t\th.h1_64->tp_mac,\n\t\t\t\th.h1_64->tp_snaplen,\n\t\t\t\th.h1_64->tp_sec,\n\t\t\t\th.h1_64->tp_usec,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0);\n\t\tif (ret == 1) {\n\t\t\tpkts++;\n\t\t\thandlep->packets_read++;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t/*\n\t\t * Hand this block back to the kernel, and, if we're\n\t\t * counting blocks that need to be filtered in userland\n\t\t * after having been filtered by the kernel, count\n\t\t * the one we've just processed.\n\t\t */\n\t\th.h1_64->tp_status = TP_STATUS_KERNEL;\n\t\tif (handlep->blocks_to_filter_in_userland > 0) {\n\t\t\thandlep->blocks_to_filter_in_userland--;\n\t\t\tif (handlep->blocks_to_filter_in_userland == 0) {\n\t\t\t\t/*\n\t\t\t\t * No more blocks need to be filtered\n\t\t\t\t * in userland.\n\t\t\t\t */\n\t\t\t\thandlep->filter_in_userland = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* next block */\n\t\tif (++handle->offset >= handle->cc)\n\t\t\thandle->offset = 0;\n\n\t\t/* check for break loop condition*/\n\t\tif (handle->break_loop) {\n\t\t\thandle->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\t}\n\treturn pkts;\n}",
          "fn_code_pos": [
            [
              5446,
              0
            ],
            [
              5528,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_linux_mmap_v1_64",
            "parameters": {
              "handle": "pcap_t",
              "max_packets": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_read_linux_mmap_v2(pcap_t *handle, int max_packets, pcap_handler callback,\n\t\tu_char *user)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tunion thdr h;\n\tint pkts = 0;\n\tint ret;\n\n\t/* wait for frames availability.*/\n\th.raw = RING_GET_CURRENT_FRAME(handle);\n\tif (h.h2->tp_status == TP_STATUS_KERNEL) {\n\t\t/*\n\t\t * The current frame is owned by the kernel; wait for\n\t\t * a frame to be handed to us.\n\t\t */\n\t\tret = pcap_wait_for_frames_mmap(handle);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* non-positive values of max_packets are used to require all\n\t * packets currently available in the ring */\n\twhile ((pkts < max_packets) || PACKET_COUNT_IS_UNLIMITED(max_packets)) {\n\t\t/*\n\t\t * Get the current ring buffer frame, and break if\n\t\t * it's still owned by the kernel.\n\t\t */\n\t\th.raw = RING_GET_CURRENT_FRAME(handle);\n\t\tif (h.h2->tp_status == TP_STATUS_KERNEL)\n\t\t\tbreak;\n\n\t\tret = pcap_handle_packet_mmap(\n\t\t\t\thandle,\n\t\t\t\tcallback,\n\t\t\t\tuser,\n\t\t\t\th.raw,\n\t\t\t\th.h2->tp_len,\n\t\t\t\th.h2->tp_mac,\n\t\t\t\th.h2->tp_snaplen,\n\t\t\t\th.h2->tp_sec,\n\t\t\t\thandle->opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO ? h.h2->tp_nsec : h.h2->tp_nsec / 1000,\n\t\t\t\tVLAN_VALID(h.h2, h.h2),\n\t\t\t\th.h2->tp_vlan_tci,\n\t\t\t\tVLAN_TPID(h.h2, h.h2));\n\t\tif (ret == 1) {\n\t\t\tpkts++;\n\t\t\thandlep->packets_read++;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t}\n\n\t\t/*\n\t\t * Hand this block back to the kernel, and, if we're\n\t\t * counting blocks that need to be filtered in userland\n\t\t * after having been filtered by the kernel, count\n\t\t * the one we've just processed.\n\t\t */\n\t\th.h2->tp_status = TP_STATUS_KERNEL;\n\t\tif (handlep->blocks_to_filter_in_userland > 0) {\n\t\t\thandlep->blocks_to_filter_in_userland--;\n\t\t\tif (handlep->blocks_to_filter_in_userland == 0) {\n\t\t\t\t/*\n\t\t\t\t * No more blocks need to be filtered\n\t\t\t\t * in userland.\n\t\t\t\t */\n\t\t\t\thandlep->filter_in_userland = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* next block */\n\t\tif (++handle->offset >= handle->cc)\n\t\t\thandle->offset = 0;\n\n\t\t/* check for break loop condition*/\n\t\tif (handle->break_loop) {\n\t\t\thandle->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\t}\n\treturn pkts;\n}",
          "fn_code_pos": [
            [
              5531,
              0
            ],
            [
              5613,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_linux_mmap_v2",
            "parameters": {
              "handle": "pcap_t",
              "max_packets": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_read_linux_mmap_v3(pcap_t *handle, int max_packets, pcap_handler callback,\n\t\tu_char *user)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tunion thdr h;\n\tint pkts = 0;\n\tint ret;\n\nagain:\n\tif (handlep->current_packet == NULL) {\n\t\t/* wait for frames availability.*/\n\t\th.raw = RING_GET_CURRENT_FRAME(handle);\n\t\tif (h.h3->hdr.bh1.block_status == TP_STATUS_KERNEL) {\n\t\t\t/*\n\t\t\t * The current frame is owned by the kernel; wait\n\t\t\t * for a frame to be handed to us.\n\t\t\t */\n\t\t\tret = pcap_wait_for_frames_mmap(handle);\n\t\t\tif (ret) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\th.raw = RING_GET_CURRENT_FRAME(handle);\n\tif (h.h3->hdr.bh1.block_status == TP_STATUS_KERNEL) {\n\t\tif (pkts == 0 && handlep->timeout == 0) {\n\t\t\t/* Block until we see a packet. */\n\t\t\tgoto again;\n\t\t}\n\t\treturn pkts;\n\t}\n\n\t/* non-positive values of max_packets are used to require all\n\t * packets currently available in the ring */\n\twhile ((pkts < max_packets) || PACKET_COUNT_IS_UNLIMITED(max_packets)) {\n\t\tint packets_to_read;\n\n\t\tif (handlep->current_packet == NULL) {\n\t\t\th.raw = RING_GET_CURRENT_FRAME(handle);\n\t\t\tif (h.h3->hdr.bh1.block_status == TP_STATUS_KERNEL)\n\t\t\t\tbreak;\n\n\t\t\thandlep->current_packet = h.raw + h.h3->hdr.bh1.offset_to_first_pkt;\n\t\t\thandlep->packets_left = h.h3->hdr.bh1.num_pkts;\n\t\t}\n\t\tpackets_to_read = handlep->packets_left;\n\n\t\tif (!PACKET_COUNT_IS_UNLIMITED(max_packets) &&\n\t\t    packets_to_read > (max_packets - pkts)) {\n\t\t\t/*\n\t\t\t * We've been given a maximum number of packets\n\t\t\t * to process, and there are more packets in\n\t\t\t * this buffer than that.  Only process enough\n\t\t\t * of them to get us up to that maximum.\n\t\t\t */\n\t\t\tpackets_to_read = max_packets - pkts;\n\t\t}\n\n\t\twhile (packets_to_read-- && !handle->break_loop) {\n\t\t\tstruct tpacket3_hdr* tp3_hdr = (struct tpacket3_hdr*) handlep->current_packet;\n\t\t\tret = pcap_handle_packet_mmap(\n\t\t\t\t\thandle,\n\t\t\t\t\tcallback,\n\t\t\t\t\tuser,\n\t\t\t\t\thandlep->current_packet,\n\t\t\t\t\ttp3_hdr->tp_len,\n\t\t\t\t\ttp3_hdr->tp_mac,\n\t\t\t\t\ttp3_hdr->tp_snaplen,\n\t\t\t\t\ttp3_hdr->tp_sec,\n\t\t\t\t\thandle->opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO ? tp3_hdr->tp_nsec : tp3_hdr->tp_nsec / 1000,\n\t\t\t\t\tVLAN_VALID(tp3_hdr, &tp3_hdr->hv1),\n\t\t\t\t\ttp3_hdr->hv1.tp_vlan_tci,\n\t\t\t\t\tVLAN_TPID(tp3_hdr, &tp3_hdr->hv1));\n\t\t\tif (ret == 1) {\n\t\t\t\tpkts++;\n\t\t\t\thandlep->packets_read++;\n\t\t\t} else if (ret < 0) {\n\t\t\t\thandlep->current_packet = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\thandlep->current_packet += tp3_hdr->tp_next_offset;\n\t\t\thandlep->packets_left--;\n\t\t}\n\n\t\tif (handlep->packets_left <= 0) {\n\t\t\t/*\n\t\t\t * Hand this block back to the kernel, and, if\n\t\t\t * we're counting blocks that need to be\n\t\t\t * filtered in userland after having been\n\t\t\t * filtered by the kernel, count the one we've\n\t\t\t * just processed.\n\t\t\t */\n\t\t\th.h3->hdr.bh1.block_status = TP_STATUS_KERNEL;\n\t\t\tif (handlep->blocks_to_filter_in_userland > 0) {\n\t\t\t\thandlep->blocks_to_filter_in_userland--;\n\t\t\t\tif (handlep->blocks_to_filter_in_userland == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * No more blocks need to be filtered\n\t\t\t\t\t * in userland.\n\t\t\t\t\t */\n\t\t\t\t\thandlep->filter_in_userland = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* next block */\n\t\t\tif (++handle->offset >= handle->cc)\n\t\t\t\thandle->offset = 0;\n\n\t\t\thandlep->current_packet = NULL;\n\t\t}\n\n\t\t/* check for break loop condition*/\n\t\tif (handle->break_loop) {\n\t\t\thandle->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\t}\n\tif (pkts == 0 && handlep->timeout == 0) {\n\t\t/* Block until we see a packet. */\n\t\tgoto again;\n\t}\n\treturn pkts;\n}",
          "fn_code_pos": [
            [
              5617,
              0
            ],
            [
              5740,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_linux_mmap_v3",
            "parameters": {
              "handle": "pcap_t",
              "max_packets": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setfilter_linux_mmap(pcap_t *handle, struct bpf_program *filter)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tint n, offset;\n\tint ret;\n\n\t/*\n\t * Don't rewrite \"ret\" instructions; we don't need to, as\n\t * we're not reading packets with recvmsg(), and we don't\n\t * want to, as, by not rewriting them, the kernel can avoid\n\t * copying extra data.\n\t */\n\tret = pcap_setfilter_linux_common(handle, filter, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/*\n\t * If we're filtering in userland, there's nothing to do;\n\t * the new filter will be used for the next packet.\n\t */\n\tif (handlep->filter_in_userland)\n\t\treturn ret;\n\n\t/*\n\t * We're filtering in the kernel; the packets present in\n\t * all blocks currently in the ring were already filtered\n\t * by the old filter, and so will need to be filtered in\n\t * userland by the new filter.\n\t *\n\t * Get an upper bound for the number of such blocks; first,\n\t * walk the ring backward and count the free blocks.\n\t */\n\toffset = handle->offset;\n\tif (--offset < 0)\n\t\toffset = handle->cc - 1;\n\tfor (n=0; n < handle->cc; ++n) {\n\t\tif (--offset < 0)\n\t\t\toffset = handle->cc - 1;\n\t\tif (pcap_get_ring_frame_status(handle, offset) != TP_STATUS_KERNEL)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we found free blocks, decrement the count of free\n\t * blocks by 1, just in case we lost a race with another\n\t * thread of control that was adding a packet while\n\t * we were counting and that had run the filter before\n\t * we changed it.\n\t *\n\t * XXX - could there be more than one block added in\n\t * this fashion?\n\t *\n\t * XXX - is there a way to avoid that race, e.g. somehow\n\t * wait for all packets that passed the old filter to\n\t * be added to the ring?\n\t */\n\tif (n != 0)\n\t\tn--;\n\n\t/*\n\t * Set the count of blocks worth of packets to filter\n\t * in userland to the total number of blocks in the\n\t * ring minus the number of free blocks we found, and\n\t * turn on userland filtering.  (The count of blocks\n\t * worth of packets to filter in userland is guaranteed\n\t * not to be zero - n, above, couldn't be set to a\n\t * value > handle->cc, and if it were equal to\n\t * handle->cc, it wouldn't be zero, and thus would\n\t * be decremented to handle->cc - 1.)\n\t */\n\thandlep->blocks_to_filter_in_userland = handle->cc - n;\n\thandlep->filter_in_userland = 1;\n\treturn ret;\n}",
          "fn_code_pos": [
            [
              5743,
              0
            ],
            [
              5817,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_linux_mmap",
            "parameters": {
              "handle": "pcap_t",
              "filter": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\niface_get_id(int fd, const char *device, char *ebuf)\n{\n\tstruct ifreq\tifr;\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tpcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));\n\n\tif (ioctl(fd, SIOCGIFINDEX, &ifr) == -1) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCGIFINDEX\");\n\t\treturn -1;\n\t}\n\n\treturn ifr.ifr_ifindex;\n}",
          "fn_code_pos": [
            [
              5824,
              0
            ],
            [
              5839,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_get_id",
            "parameters": {
              "fd": "int",
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\niface_bind(int fd, int ifindex, char *ebuf, int protocol)\n{\n\tstruct sockaddr_ll\tsll;\n\tint\t\t\tret, err;\n\tsocklen_t\t\terrlen = sizeof(err);\n\n\tmemset(&sll, 0, sizeof(sll));\n\tsll.sll_family\t\t= AF_PACKET;\n\tsll.sll_ifindex\t\t= ifindex;\n\tsll.sll_protocol\t= protocol;\n\n\tif (bind(fd, (struct sockaddr *) &sll, sizeof(sll)) == -1) {\n\t\tif (errno == ENETDOWN) {\n\t\t\t/*\n\t\t\t * Return a \"network down\" indication, so that\n\t\t\t * the application can report that rather than\n\t\t\t * saying we had a mysterious failure and\n\t\t\t * suggest that they report a problem to the\n\t\t\t * libpcap developers.\n\t\t\t */\n\t\t\treturn PCAP_ERROR_IFACE_NOT_UP;\n\t\t}\n\t\tif (errno == ENODEV)\n\t\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\telse\n\t\t\tret = PCAP_ERROR;\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"bind\");\n\t\treturn ret;\n\t}\n\n\t/* Any pending errors, e.g., network is down? */\n\n\tif (getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &errlen) == -1) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"getsockopt (SO_ERROR)\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tif (err == ENETDOWN) {\n\t\t/*\n\t\t * Return a \"network down\" indication, so that\n\t\t * the application can report that rather than\n\t\t * saying we had a mysterious failure and\n\t\t * suggest that they report a problem to the\n\t\t * libpcap developers.\n\t\t */\n\t\treturn PCAP_ERROR_IFACE_NOT_UP;\n\t} else if (err > 0) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    err, \"bind\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              5845,
              0
            ],
            [
              5901,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_bind",
            "parameters": {
              "fd": "int",
              "ifindex": "int",
              "ebuf": "char",
              "protocol": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nhas_wext(int sock_fd, const char *device, char *ebuf)\n{\n\tstruct iwreq ireq;\n\tint ret;\n\n\tif (is_bonding_device(sock_fd, device))\n\t\treturn 0;\t/* bonding device, so don't even try */\n\n\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, device,\n\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\tif (ioctl(sock_fd, SIOCGIWNAME, &ireq) >= 0)\n\t\treturn 1;\t/* yes */\n\tif (errno == ENODEV)\n\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\telse\n\t\tret = 0;\n\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno,\n\t    \"%s: SIOCGIWNAME\", device);\n\treturn ret;\n}",
          "fn_code_pos": [
            [
              5909,
              0
            ],
            [
              5929,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "has_wext",
            "parameters": {
              "sock_fd": "int",
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nenter_rfmon_mode_wext(pcap_t *handle, int sock_fd, const char *device)\n{\n\t/*\n\t * XXX - at least some adapters require non-Wireless Extensions\n\t * mechanisms to turn monitor mode on.\n\t *\n\t * Atheros cards might require that a separate \"monitor virtual access\n\t * point\" be created, with later versions of the madwifi driver.\n\t * airmon-ng does \"wlanconfig ath create wlandev {if} wlanmode\n\t * monitor -bssid\", which apparently spits out a line \"athN\"\n\t * where \"athN\" is the monitor mode device.  To leave monitor\n\t * mode, it destroys the monitor mode device.\n\t *\n\t * Some Intel Centrino adapters might require private ioctls to get\n\t * radio headers; the ipw2200 and ipw3945 drivers allow you to\n\t * configure a separate \"rtapN\" interface to capture in monitor\n\t * mode without preventing the adapter from operating normally.\n\t * (airmon-ng doesn't appear to use that, though.)\n\t *\n\t * It would be Truly Wonderful if mac80211 and nl80211 cleaned this\n\t * up, and if all drivers were converted to mac80211 drivers.\n\t *\n\t * If interface {if} is a mac80211 driver, the file\n\t * /sys/class/net/{if}/phy80211 is a symlink to\n\t * /sys/class/ieee80211/{phydev}, for some {phydev}.\n\t *\n\t * On Fedora 9, with a 2.6.26.3-29 kernel, my Zydas stick, at\n\t * least, has a \"wmaster0\" device and a \"wlan0\" device; the\n\t * latter is the one with the IP address.  Both show up in\n\t * \"tcpdump -D\" output.  Capturing on the wmaster0 device\n\t * captures with 802.11 headers.\n\t *\n\t * airmon-ng searches through /sys/class/net for devices named\n\t * monN, starting with mon0; as soon as one *doesn't* exist,\n\t * it chooses that as the monitor device name.  If the \"iw\"\n\t * command exists, it does \"iw dev {if} interface add {monif}\n\t * type monitor\", where {monif} is the monitor device.  It\n\t * then (sigh) sleeps .1 second, and then configures the\n\t * device up.  Otherwise, if /sys/class/ieee80211/{phydev}/add_iface\n\t * is a file, it writes {mondev}, without a newline, to that file,\n\t * and again (sigh) sleeps .1 second, and then iwconfig's that\n\t * device into monitor mode and configures it up.  Otherwise,\n\t * you can't do monitor mode.\n\t *\n\t * All these devices are \"glued\" together by having the\n\t * /sys/class/net/{device}/phy80211 links pointing to the same\n\t * place, so, given a wmaster, wlan, or mon device, you can\n\t * find the other devices by looking for devices with\n\t * the same phy80211 link.\n\t *\n\t * To turn monitor mode off, delete the monitor interface,\n\t * either with \"iw dev {monif} interface del\" or by sending\n\t * {monif}, with no NL, down /sys/class/ieee80211/{phydev}/remove_iface\n\t *\n\t * Note: if you try to create a monitor device named \"monN\", and\n\t * there's already a \"monN\" device, it fails, as least with\n\t * the netlink interface (which is what iw uses), with a return\n\t * value of -ENFILE.  (Return values are negative errnos.)  We\n\t * could probably use that to find an unused device.\n\t */\n\tstruct pcap_linux *handlep = handle->priv;\n\tint err;\n\tstruct iwreq ireq;\n\tstruct iw_priv_args *priv;\n\tmonitor_type montype;\n\tint i;\n\t__u32 cmd;\n\tstruct ifreq ifr;\n\tint oldflags;\n\tint args[2];\n\tint channel;\n\n\t/*\n\t * Does this device *support* the Wireless Extensions?\n\t */\n\terr = has_wext(sock_fd, device, handle->errbuf);\n\tif (err <= 0)\n\t\treturn err;\t/* either it doesn't or the device doesn't even exist */\n\t/*\n\t * Start out assuming we have no private extensions to control\n\t * radio metadata.\n\t */\n\tmontype = MONITOR_WEXT;\n\tcmd = 0;\n\n\t/*\n\t * Try to get all the Wireless Extensions private ioctls\n\t * supported by this device.\n\t *\n\t * First, get the size of the buffer we need, by supplying no\n\t * buffer and a length of 0.  If the device supports private\n\t * ioctls, it should return E2BIG, with ireq.u.data.length set\n\t * to the length we need.  If it doesn't support them, it should\n\t * return EOPNOTSUPP.\n\t */\n\tmemset(&ireq, 0, sizeof ireq);\n\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, device,\n\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\tireq.u.data.pointer = (void *)args;\n\tireq.u.data.length = 0;\n\tireq.u.data.flags = 0;\n\tif (ioctl(sock_fd, SIOCGIWPRIV, &ireq) != -1) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: SIOCGIWPRIV with a zero-length buffer didn't fail!\",\n\t\t    device);\n\t\treturn PCAP_ERROR;\n\t}\n\tif (errno != EOPNOTSUPP) {\n\t\t/*\n\t\t * OK, it's not as if there are no private ioctls.\n\t\t */\n\t\tif (errno != E2BIG) {\n\t\t\t/*\n\t\t\t * Failed.\n\t\t\t */\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"%s: SIOCGIWPRIV\", device);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\n\t\t/*\n\t\t * OK, try to get the list of private ioctls.\n\t\t */\n\t\tpriv = malloc(ireq.u.data.length * sizeof (struct iw_priv_args));\n\t\tif (priv == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc\");\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t\tireq.u.data.pointer = (void *)priv;\n\t\tif (ioctl(sock_fd, SIOCGIWPRIV, &ireq) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"%s: SIOCGIWPRIV\", device);\n\t\t\tfree(priv);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\n\t\t/*\n\t\t * Look for private ioctls to turn monitor mode on or, if\n\t\t * monitor mode is on, to set the header type.\n\t\t */\n\t\tfor (i = 0; i < ireq.u.data.length; i++) {\n\t\t\tif (strcmp(priv[i].name, \"monitor_type\") == 0) {\n\t\t\t\t/*\n\t\t\t\t * Hostap driver, use this one.\n\t\t\t\t * Set monitor mode first.\n\t\t\t\t * You can set it to 0 to get DLT_IEEE80211,\n\t\t\t\t * 1 to get DLT_PRISM, 2 to get\n\t\t\t\t * DLT_IEEE80211_RADIO_AVS, and, with more\n\t\t\t\t * recent versions of the driver, 3 to get\n\t\t\t\t * DLT_IEEE80211_RADIO.\n\t\t\t\t */\n\t\t\t\tif ((priv[i].set_args & IW_PRIV_TYPE_MASK) != IW_PRIV_TYPE_INT)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(priv[i].set_args & IW_PRIV_SIZE_FIXED))\n\t\t\t\t\tbreak;\n\t\t\t\tif ((priv[i].set_args & IW_PRIV_SIZE_MASK) != 1)\n\t\t\t\t\tbreak;\n\t\t\t\tmontype = MONITOR_HOSTAP;\n\t\t\t\tcmd = priv[i].cmd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strcmp(priv[i].name, \"set_prismhdr\") == 0) {\n\t\t\t\t/*\n\t\t\t\t * Prism54 driver, use this one.\n\t\t\t\t * Set monitor mode first.\n\t\t\t\t * You can set it to 2 to get DLT_IEEE80211\n\t\t\t\t * or 3 or get DLT_PRISM.\n\t\t\t\t */\n\t\t\t\tif ((priv[i].set_args & IW_PRIV_TYPE_MASK) != IW_PRIV_TYPE_INT)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(priv[i].set_args & IW_PRIV_SIZE_FIXED))\n\t\t\t\t\tbreak;\n\t\t\t\tif ((priv[i].set_args & IW_PRIV_SIZE_MASK) != 1)\n\t\t\t\t\tbreak;\n\t\t\t\tmontype = MONITOR_PRISM54;\n\t\t\t\tcmd = priv[i].cmd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strcmp(priv[i].name, \"forceprismheader\") == 0) {\n\t\t\t\t/*\n\t\t\t\t * RT2570 driver, use this one.\n\t\t\t\t * Do this after turning monitor mode on.\n\t\t\t\t * You can set it to 1 to get DLT_PRISM or 2\n\t\t\t\t * to get DLT_IEEE80211.\n\t\t\t\t */\n\t\t\t\tif ((priv[i].set_args & IW_PRIV_TYPE_MASK) != IW_PRIV_TYPE_INT)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(priv[i].set_args & IW_PRIV_SIZE_FIXED))\n\t\t\t\t\tbreak;\n\t\t\t\tif ((priv[i].set_args & IW_PRIV_SIZE_MASK) != 1)\n\t\t\t\t\tbreak;\n\t\t\t\tmontype = MONITOR_RT2570;\n\t\t\t\tcmd = priv[i].cmd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strcmp(priv[i].name, \"forceprism\") == 0) {\n\t\t\t\t/*\n\t\t\t\t * RT73 driver, use this one.\n\t\t\t\t * Do this after turning monitor mode on.\n\t\t\t\t * Its argument is a *string*; you can\n\t\t\t\t * set it to \"1\" to get DLT_PRISM or \"2\"\n\t\t\t\t * to get DLT_IEEE80211.\n\t\t\t\t */\n\t\t\t\tif ((priv[i].set_args & IW_PRIV_TYPE_MASK) != IW_PRIV_TYPE_CHAR)\n\t\t\t\t\tbreak;\n\t\t\t\tif (priv[i].set_args & IW_PRIV_SIZE_FIXED)\n\t\t\t\t\tbreak;\n\t\t\t\tmontype = MONITOR_RT73;\n\t\t\t\tcmd = priv[i].cmd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strcmp(priv[i].name, \"prismhdr\") == 0) {\n\t\t\t\t/*\n\t\t\t\t * One of the RTL8xxx drivers, use this one.\n\t\t\t\t * It can only be done after monitor mode\n\t\t\t\t * has been turned on.  You can set it to 1\n\t\t\t\t * to get DLT_PRISM or 0 to get DLT_IEEE80211.\n\t\t\t\t */\n\t\t\t\tif ((priv[i].set_args & IW_PRIV_TYPE_MASK) != IW_PRIV_TYPE_INT)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(priv[i].set_args & IW_PRIV_SIZE_FIXED))\n\t\t\t\t\tbreak;\n\t\t\t\tif ((priv[i].set_args & IW_PRIV_SIZE_MASK) != 1)\n\t\t\t\t\tbreak;\n\t\t\t\tmontype = MONITOR_RTL8XXX;\n\t\t\t\tcmd = priv[i].cmd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strcmp(priv[i].name, \"rfmontx\") == 0) {\n\t\t\t\t/*\n\t\t\t\t * RT2500 or RT61 driver, use this one.\n\t\t\t\t * It has one one-byte parameter; set\n\t\t\t\t * u.data.length to 1 and u.data.pointer to\n\t\t\t\t * point to the parameter.\n\t\t\t\t * It doesn't itself turn monitor mode on.\n\t\t\t\t * You can set it to 1 to allow transmitting\n\t\t\t\t * in monitor mode(?) and get DLT_IEEE80211,\n\t\t\t\t * or set it to 0 to disallow transmitting in\n\t\t\t\t * monitor mode(?) and get DLT_PRISM.\n\t\t\t\t */\n\t\t\t\tif ((priv[i].set_args & IW_PRIV_TYPE_MASK) != IW_PRIV_TYPE_INT)\n\t\t\t\t\tbreak;\n\t\t\t\tif ((priv[i].set_args & IW_PRIV_SIZE_MASK) != 2)\n\t\t\t\t\tbreak;\n\t\t\t\tmontype = MONITOR_RT2500;\n\t\t\t\tcmd = priv[i].cmd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (strcmp(priv[i].name, \"monitor\") == 0) {\n\t\t\t\t/*\n\t\t\t\t * Either ACX100 or hostap, use this one.\n\t\t\t\t * It turns monitor mode on.\n\t\t\t\t * If it takes two arguments, it's ACX100;\n\t\t\t\t * the first argument is 1 for DLT_PRISM\n\t\t\t\t * or 2 for DLT_IEEE80211, and the second\n\t\t\t\t * argument is the channel on which to\n\t\t\t\t * run.  If it takes one argument, it's\n\t\t\t\t * HostAP, and the argument is 2 for\n\t\t\t\t * DLT_IEEE80211 and 3 for DLT_PRISM.\n\t\t\t\t *\n\t\t\t\t * If we see this, we don't quit, as this\n\t\t\t\t * might be a version of the hostap driver\n\t\t\t\t * that also supports \"monitor_type\".\n\t\t\t\t */\n\t\t\t\tif ((priv[i].set_args & IW_PRIV_TYPE_MASK) != IW_PRIV_TYPE_INT)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(priv[i].set_args & IW_PRIV_SIZE_FIXED))\n\t\t\t\t\tbreak;\n\t\t\t\tswitch (priv[i].set_args & IW_PRIV_SIZE_MASK) {\n\n\t\t\t\tcase 1:\n\t\t\t\t\tmontype = MONITOR_PRISM;\n\t\t\t\t\tcmd = priv[i].cmd;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tmontype = MONITOR_ACX100;\n\t\t\t\t\tcmd = priv[i].cmd;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(priv);\n\t}\n\n\t/*\n\t * XXX - ipw3945?  islism?\n\t */\n\n\t/*\n\t * Get the old mode.\n\t */\n\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, device,\n\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\tif (ioctl(sock_fd, SIOCGIWMODE, &ireq) == -1) {\n\t\t/*\n\t\t * We probably won't be able to set the mode, either.\n\t\t */\n\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t}\n\n\t/*\n\t * Is it currently in monitor mode?\n\t */\n\tif (ireq.u.mode == IW_MODE_MONITOR) {\n\t\t/*\n\t\t * Yes.  Just leave things as they are.\n\t\t * We don't offer multiple link-layer types, as\n\t\t * changing the link-layer type out from under\n\t\t * somebody else capturing in monitor mode would\n\t\t * be considered rude.\n\t\t */\n\t\treturn 1;\n\t}\n\t/*\n\t * No.  We have to put the adapter into rfmon mode.\n\t */\n\n\t/*\n\t * If we haven't already done so, arrange to have\n\t * \"pcap_close_all()\" called when we exit.\n\t */\n\tif (!pcap_do_addexit(handle)) {\n\t\t/*\n\t\t * \"atexit()\" failed; don't put the interface\n\t\t * in rfmon mode, just give up.\n\t\t */\n\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t}\n\n\t/*\n\t * Save the old mode.\n\t */\n\thandlep->oldmode = ireq.u.mode;\n\n\t/*\n\t * Put the adapter in rfmon mode.  How we do this depends\n\t * on whether we have a special private ioctl or not.\n\t */\n\tif (montype == MONITOR_PRISM) {\n\t\t/*\n\t\t * We have the \"monitor\" private ioctl, but none of\n\t\t * the other private ioctls.  Use this, and select\n\t\t * the Prism header.\n\t\t *\n\t\t * If it fails, just fall back on SIOCSIWMODE.\n\t\t */\n\t\tmemset(&ireq, 0, sizeof ireq);\n\t\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, device,\n\t\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\t\tireq.u.data.length = 1;\t/* 1 argument */\n\t\targs[0] = 3;\t/* request Prism header */\n\t\tmemcpy(ireq.u.name, args, sizeof (int));\n\t\tif (ioctl(sock_fd, cmd, &ireq) != -1) {\n\t\t\t/*\n\t\t\t * Success.\n\t\t\t * Note that we have to put the old mode back\n\t\t\t * when we close the device.\n\t\t\t */\n\t\t\thandlep->must_do_on_close |= MUST_CLEAR_RFMON;\n\n\t\t\t/*\n\t\t\t * Add this to the list of pcaps to close\n\t\t\t * when we exit.\n\t\t\t */\n\t\t\tpcap_add_to_pcaps_to_close(handle);\n\n\t\t\treturn 1;\n\t\t}\n\n\t\t/*\n\t\t * Failure.  Fall back on SIOCSIWMODE.\n\t\t */\n\t}\n\n\t/*\n\t * First, take the interface down if it's up; otherwise, we\n\t * might get EBUSY.\n\t */\n\tmemset(&ifr, 0, sizeof(ifr));\n\tpcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));\n\tif (ioctl(sock_fd, SIOCGIFFLAGS, &ifr) == -1) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"%s: Can't get flags\", device);\n\t\treturn PCAP_ERROR;\n\t}\n\toldflags = 0;\n\tif (ifr.ifr_flags & IFF_UP) {\n\t\toldflags = ifr.ifr_flags;\n\t\tifr.ifr_flags &= ~IFF_UP;\n\t\tif (ioctl(sock_fd, SIOCSIFFLAGS, &ifr) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"%s: Can't set flags\",\n\t\t\t    device);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t}\n\n\t/*\n\t * Then turn monitor mode on.\n\t */\n\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, device,\n\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\tireq.u.mode = IW_MODE_MONITOR;\n\tif (ioctl(sock_fd, SIOCSIWMODE, &ireq) == -1) {\n\t\t/*\n\t\t * Scientist, you've failed.\n\t\t * Bring the interface back up if we shut it down.\n\t\t */\n\t\tifr.ifr_flags = oldflags;\n\t\tif (ioctl(sock_fd, SIOCSIFFLAGS, &ifr) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"%s: Can't set flags\",\n\t\t\t    device);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t}\n\n\t/*\n\t * XXX - airmon-ng does \"iwconfig {if} key off\" after setting\n\t * monitor mode and setting the channel, and then does\n\t * \"iwconfig up\".\n\t */\n\n\t/*\n\t * Now select the appropriate radio header.\n\t */\n\tswitch (montype) {\n\n\tcase MONITOR_WEXT:\n\t\t/*\n\t\t * We don't have any private ioctl to set the header.\n\t\t */\n\t\tbreak;\n\n\tcase MONITOR_HOSTAP:\n\t\t/*\n\t\t * Try to select the radiotap header.\n\t\t */\n\t\tmemset(&ireq, 0, sizeof ireq);\n\t\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, device,\n\t\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\t\targs[0] = 3;\t/* request radiotap header */\n\t\tmemcpy(ireq.u.name, args, sizeof (int));\n\t\tif (ioctl(sock_fd, cmd, &ireq) != -1)\n\t\t\tbreak;\t/* success */\n\n\t\t/*\n\t\t * That failed.  Try to select the AVS header.\n\t\t */\n\t\tmemset(&ireq, 0, sizeof ireq);\n\t\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, device,\n\t\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\t\targs[0] = 2;\t/* request AVS header */\n\t\tmemcpy(ireq.u.name, args, sizeof (int));\n\t\tif (ioctl(sock_fd, cmd, &ireq) != -1)\n\t\t\tbreak;\t/* success */\n\n\t\t/*\n\t\t * That failed.  Try to select the Prism header.\n\t\t */\n\t\tmemset(&ireq, 0, sizeof ireq);\n\t\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, device,\n\t\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\t\targs[0] = 1;\t/* request Prism header */\n\t\tmemcpy(ireq.u.name, args, sizeof (int));\n\t\tioctl(sock_fd, cmd, &ireq);\n\t\tbreak;\n\n\tcase MONITOR_PRISM:\n\t\t/*\n\t\t * The private ioctl failed.\n\t\t */\n\t\tbreak;\n\n\tcase MONITOR_PRISM54:\n\t\t/*\n\t\t * Select the Prism header.\n\t\t */\n\t\tmemset(&ireq, 0, sizeof ireq);\n\t\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, device,\n\t\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\t\targs[0] = 3;\t/* request Prism header */\n\t\tmemcpy(ireq.u.name, args, sizeof (int));\n\t\tioctl(sock_fd, cmd, &ireq);\n\t\tbreak;\n\n\tcase MONITOR_ACX100:\n\t\t/*\n\t\t * Get the current channel.\n\t\t */\n\t\tmemset(&ireq, 0, sizeof ireq);\n\t\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, device,\n\t\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\t\tif (ioctl(sock_fd, SIOCGIWFREQ, &ireq) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"%s: SIOCGIWFREQ\", device);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t\tchannel = ireq.u.freq.m;\n\n\t\t/*\n\t\t * Select the Prism header, and set the channel to the\n\t\t * current value.\n\t\t */\n\t\tmemset(&ireq, 0, sizeof ireq);\n\t\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, device,\n\t\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\t\targs[0] = 1;\t\t/* request Prism header */\n\t\targs[1] = channel;\t/* set channel */\n\t\tmemcpy(ireq.u.name, args, 2*sizeof (int));\n\t\tioctl(sock_fd, cmd, &ireq);\n\t\tbreak;\n\n\tcase MONITOR_RT2500:\n\t\t/*\n\t\t * Disallow transmission - that turns on the\n\t\t * Prism header.\n\t\t */\n\t\tmemset(&ireq, 0, sizeof ireq);\n\t\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, device,\n\t\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\t\targs[0] = 0;\t/* disallow transmitting */\n\t\tmemcpy(ireq.u.name, args, sizeof (int));\n\t\tioctl(sock_fd, cmd, &ireq);\n\t\tbreak;\n\n\tcase MONITOR_RT2570:\n\t\t/*\n\t\t * Force the Prism header.\n\t\t */\n\t\tmemset(&ireq, 0, sizeof ireq);\n\t\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, device,\n\t\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\t\targs[0] = 1;\t/* request Prism header */\n\t\tmemcpy(ireq.u.name, args, sizeof (int));\n\t\tioctl(sock_fd, cmd, &ireq);\n\t\tbreak;\n\n\tcase MONITOR_RT73:\n\t\t/*\n\t\t * Force the Prism header.\n\t\t */\n\t\tmemset(&ireq, 0, sizeof ireq);\n\t\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, device,\n\t\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\t\tireq.u.data.length = 1;\t/* 1 argument */\n\t\tireq.u.data.pointer = \"1\";\n\t\tireq.u.data.flags = 0;\n\t\tioctl(sock_fd, cmd, &ireq);\n\t\tbreak;\n\n\tcase MONITOR_RTL8XXX:\n\t\t/*\n\t\t * Force the Prism header.\n\t\t */\n\t\tmemset(&ireq, 0, sizeof ireq);\n\t\tpcap_strlcpy(ireq.ifr_ifrn.ifrn_name, device,\n\t\t    sizeof ireq.ifr_ifrn.ifrn_name);\n\t\targs[0] = 1;\t/* request Prism header */\n\t\tmemcpy(ireq.u.name, args, sizeof (int));\n\t\tioctl(sock_fd, cmd, &ireq);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Now bring the interface back up if we brought it down.\n\t */\n\tif (oldflags != 0) {\n\t\tifr.ifr_flags = oldflags;\n\t\tif (ioctl(sock_fd, SIOCSIFFLAGS, &ifr) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"%s: Can't set flags\",\n\t\t\t    device);\n\n\t\t\t/*\n\t\t\t * At least try to restore the old mode on the\n\t\t\t * interface.\n\t\t\t */\n\t\t\tif (ioctl(handle->fd, SIOCSIWMODE, &ireq) == -1) {\n\t\t\t\t/*\n\t\t\t\t * Scientist, you've failed.\n\t\t\t\t */\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Can't restore interface wireless mode (SIOCSIWMODE failed: %s).\\n\"\n\t\t\t\t    \"Please adjust manually.\\n\",\n\t\t\t\t    strerror(errno));\n\t\t\t}\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t}\n\n\t/*\n\t * Note that we have to put the old mode back when we\n\t * close the device.\n\t */\n\thandlep->must_do_on_close |= MUST_CLEAR_RFMON;\n\n\t/*\n\t * Add this to the list of pcaps to close when we exit.\n\t */\n\tpcap_add_to_pcaps_to_close(handle);\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              5960,
              0
            ],
            [
              6570,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "enter_rfmon_mode_wext",
            "parameters": {
              "handle": "pcap_t",
              "sock_fd": "int",
              "device": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nenter_rfmon_mode(pcap_t *handle, int sock_fd, const char *device)\n{\n#if defined(HAVE_LIBNL) || defined(IW_MODE_MONITOR)\n\tint ret;\n#endif\n\n#ifdef HAVE_LIBNL\n\tret = enter_rfmon_mode_mac80211(handle, sock_fd, device);\n\tif (ret < 0)\n\t\treturn ret;\t/* error attempting to do so */\n\tif (ret == 1)\n\t\treturn 1;\t/* success */\n#endif /* HAVE_LIBNL */\n\n#ifdef IW_MODE_MONITOR\n\tret = enter_rfmon_mode_wext(handle, sock_fd, device);\n\tif (ret < 0)\n\t\treturn ret;\t/* error attempting to do so */\n\tif (ret == 1)\n\t\treturn 1;\t/* success */\n#endif /* IW_MODE_MONITOR */\n\n\t/*\n\t * Either none of the mechanisms we know about work or none\n\t * of those mechanisms are available, so we can't do monitor\n\t * mode.\n\t */\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              6576,
              0
            ],
            [
              6605,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "enter_rfmon_mode",
            "parameters": {
              "handle": "pcap_t",
              "sock_fd": "int",
              "device": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\niface_set_all_ts_types(pcap_t *handle)\n{\n\tu_int i;\n\n\thandle->tstamp_type_count = NUM_SOF_TIMESTAMPING_TYPES;\n\thandle->tstamp_type_list = malloc(NUM_SOF_TIMESTAMPING_TYPES * sizeof(u_int));\n\tfor (i = 0; i < NUM_SOF_TIMESTAMPING_TYPES; i++)\n\t\thandle->tstamp_type_list[i] = sof_ts_type_map[i].pcap_tstamp_val;\n}",
          "fn_code_pos": [
            [
              6624,
              0
            ],
            [
              6633,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_set_all_ts_types",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\niface_ethtool_get_ts_info(const char *device, pcap_t *handle, char *ebuf)\n{\n\tint fd;\n\tstruct ifreq ifr;\n\tstruct ethtool_ts_info info;\n\tint num_ts_types;\n\tu_int i, j;\n\n\t/*\n\t * This doesn't apply to the \"any\" device; you can't say \"turn on\n\t * hardware time stamping for all devices that exist now and arrange\n\t * that it be turned on for any device that appears in the future\",\n\t * and not all devices even necessarily *support* hardware time\n\t * stamping, so don't report any time stamp types.\n\t */\n\tif (strcmp(device, \"any\") == 0) {\n\t\thandle->tstamp_type_list = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Create a socket from which to fetch time stamping capabilities.\n\t */\n\tfd = socket(PF_UNIX, SOCK_RAW, 0);\n\tif (fd < 0) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"socket for SIOCETHTOOL(ETHTOOL_GET_TS_INFO)\");\n\t\treturn -1;\n\t}\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tpcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));\n\tmemset(&info, 0, sizeof(info));\n\tinfo.cmd = ETHTOOL_GET_TS_INFO;\n\tifr.ifr_data = (caddr_t)&info;\n\tif (ioctl(fd, SIOCETHTOOL, &ifr) == -1) {\n\t\tint save_errno = errno;\n\n\t\tclose(fd);\n\t\tswitch (save_errno) {\n\n\t\tcase EOPNOTSUPP:\n\t\tcase EINVAL:\n\t\t\t/*\n\t\t\t * OK, this OS version or driver doesn't support\n\t\t\t * asking for the time stamping types, so let's\n\t\t\t * just return all the possible types.\n\t\t\t */\n\t\t\tiface_set_all_ts_types(handle);\n\t\t\treturn 0;\n\n\t\tcase ENODEV:\n\t\t\t/*\n\t\t\t * OK, no such device.\n\t\t\t * The user will find that out when they try to\n\t\t\t * activate the device; just return an empty\n\t\t\t * list of time stamp types.\n\t\t\t */\n\t\t\thandle->tstamp_type_list = NULL;\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Other error.\n\t\t\t */\n\t\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    save_errno,\n\t\t\t    \"%s: SIOCETHTOOL(ETHTOOL_GET_TS_INFO) ioctl failed\",\n\t\t\t    device);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tclose(fd);\n\n\t/*\n\t * Do we support hardware time stamping of *all* packets?\n\t */\n\tif (!(info.rx_filters & (1 << HWTSTAMP_FILTER_ALL))) {\n\t\t/*\n\t\t * No, so don't report any time stamp types.\n\t\t *\n\t\t * XXX - some devices either don't report\n\t\t * HWTSTAMP_FILTER_ALL when they do support it, or\n\t\t * report HWTSTAMP_FILTER_ALL but map it to only\n\t\t * time stamping a few PTP packets.  See\n\t\t * http://marc.info/?l=linux-netdev&m=146318183529571&w=2\n\t\t */\n\t\thandle->tstamp_type_list = NULL;\n\t\treturn 0;\n\t}\n\n\tnum_ts_types = 0;\n\tfor (i = 0; i < NUM_SOF_TIMESTAMPING_TYPES; i++) {\n\t\tif (info.so_timestamping & sof_ts_type_map[i].soft_timestamping_val)\n\t\t\tnum_ts_types++;\n\t}\n\thandle->tstamp_type_count = num_ts_types;\n\tif (num_ts_types != 0) {\n\t\thandle->tstamp_type_list = malloc(num_ts_types * sizeof(u_int));\n\t\tfor (i = 0, j = 0; i < NUM_SOF_TIMESTAMPING_TYPES; i++) {\n\t\t\tif (info.so_timestamping & sof_ts_type_map[i].soft_timestamping_val) {\n\t\t\t\thandle->tstamp_type_list[j] = sof_ts_type_map[i].pcap_tstamp_val;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t} else\n\t\thandle->tstamp_type_list = NULL;\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              6639,
              0
            ],
            [
              6749,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_ethtool_get_ts_info",
            "parameters": {
              "device": "char",
              "handle": "pcap_t",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\niface_ethtool_get_ts_info(const char *device, pcap_t *handle, char *ebuf _U_)\n{\n\t/*\n\t * This doesn't apply to the \"any\" device; you can't say \"turn on\n\t * hardware time stamping for all devices that exist now and arrange\n\t * that it be turned on for any device that appears in the future\",\n\t * and not all devices even necessarily *support* hardware time\n\t * stamping, so don't report any time stamp types.\n\t */\n\tif (strcmp(device, \"any\") == 0) {\n\t\thandle->tstamp_type_list = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We don't have an ioctl to use to ask what's supported,\n\t * so say we support everything.\n\t */\n\tiface_set_all_ts_types(handle);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              6751,
              0
            ],
            [
              6772,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_ethtool_get_ts_info",
            "parameters": {
              "device": "char",
              "handle": "pcap_t",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\niface_ethtool_flag_ioctl(pcap_t *handle, int cmd, const char *cmdname,\n    int eperm_ok)\n{\n\tstruct ifreq\tifr;\n\tstruct ethtool_value eval;\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tpcap_strlcpy(ifr.ifr_name, handle->opt.device, sizeof(ifr.ifr_name));\n\teval.cmd = cmd;\n\teval.data = 0;\n\tifr.ifr_data = (caddr_t)&eval;\n\tif (ioctl(handle->fd, SIOCETHTOOL, &ifr) == -1) {\n\t\tif (errno == EOPNOTSUPP || errno == EINVAL ||\n\t\t    (errno == EPERM && eperm_ok)) {\n\t\t\t/*\n\t\t\t * OK, let's just return 0, which, in our\n\t\t\t * case, either means \"no, what we're asking\n\t\t\t * about is not enabled\" or \"all the flags\n\t\t\t * are clear (i.e., nothing is enabled)\".\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"%s: SIOCETHTOOL(%s) ioctl failed\",\n\t\t    handle->opt.device, cmdname);\n\t\treturn -1;\n\t}\n\treturn eval.data;\n}",
          "fn_code_pos": [
            [
              6799,
              0
            ],
            [
              6828,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_ethtool_flag_ioctl",
            "parameters": {
              "handle": "pcap_t",
              "cmd": "int",
              "cmdname": "char",
              "eperm_ok": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\niface_get_offload(pcap_t *handle)\n{\n\tint ret;\n\n#ifdef ETHTOOL_GTSO\n\tret = iface_ethtool_flag_ioctl(handle, ETHTOOL_GTSO, \"ETHTOOL_GTSO\", 0);\n\tif (ret == -1)\n\t\treturn -1;\n\tif (ret)\n\t\treturn 1;\t/* TCP segmentation offloading on */\n#endif\n\n#ifdef ETHTOOL_GGSO\n\t/*\n\t * XXX - will this cause large unsegmented packets to be\n\t * handed to PF_PACKET sockets on transmission?  If not,\n\t * this need not be checked.\n\t */\n\tret = iface_ethtool_flag_ioctl(handle, ETHTOOL_GGSO, \"ETHTOOL_GGSO\", 0);\n\tif (ret == -1)\n\t\treturn -1;\n\tif (ret)\n\t\treturn 1;\t/* generic segmentation offloading on */\n#endif\n\n#ifdef ETHTOOL_GFLAGS\n\tret = iface_ethtool_flag_ioctl(handle, ETHTOOL_GFLAGS, \"ETHTOOL_GFLAGS\", 0);\n\tif (ret == -1)\n\t\treturn -1;\n\tif (ret & ETH_FLAG_LRO)\n\t\treturn 1;\t/* large receive offloading on */\n#endif\n\n#ifdef ETHTOOL_GGRO\n\t/*\n\t * XXX - will this cause large reassembled packets to be\n\t * handed to PF_PACKET sockets on receipt?  If not,\n\t * this need not be checked.\n\t */\n\tret = iface_ethtool_flag_ioctl(handle, ETHTOOL_GGRO, \"ETHTOOL_GGRO\", 0);\n\tif (ret == -1)\n\t\treturn -1;\n\tif (ret)\n\t\treturn 1;\t/* generic (large) receive offloading on */\n#endif\n\n#ifdef ETHTOOL_GUFO\n\t/*\n\t * Do this one last, as support for it was removed in later\n\t * kernels, and it fails with EPERM on those kernels rather\n\t * than with EOPNOTSUPP (see explanation in comment for\n\t * iface_ethtool_flag_ioctl()).\n\t */\n\tret = iface_ethtool_flag_ioctl(handle, ETHTOOL_GUFO, \"ETHTOOL_GUFO\", 1);\n\tif (ret == -1)\n\t\treturn -1;\n\tif (ret)\n\t\treturn 1;\t/* UDP fragmentation offloading on */\n#endif\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              6845,
              0
            ],
            [
              6907,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_get_offload",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\niface_dsa_get_proto_info(const char *device, pcap_t *handle)\n{\n\tchar *pathstr;\n\tunsigned int i;\n\t/*\n\t * Make this significantly smaller than PCAP_ERRBUF_SIZE;\n\t * the tag *shouldn't* have some huge long name, and making\n\t * it smaller keeps newer versions of GCC from whining that\n\t * the error message if we don't support the tag could\n\t * overflow the error message buffer.\n\t */\n\tchar buf[128];\n\tssize_t r;\n\tint fd;\n\n\tfd = asprintf(&pathstr, \"/sys/class/net/%s/dsa/tagging\", device);\n\tif (fd < 0) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t  fd, \"asprintf\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tfd = open(pathstr, O_RDONLY);\n\tfree(pathstr);\n\t/*\n\t * This is not fatal, kernel >= 4.20 *might* expose this attribute\n\t */\n\tif (fd < 0)\n\t\treturn 0;\n\n\tr = read(fd, buf, sizeof(buf) - 1);\n\tif (r <= 0) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t  errno, \"read\");\n\t\tclose(fd);\n\t\treturn PCAP_ERROR;\n\t}\n\tclose(fd);\n\n\t/*\n\t * Buffer should be LF terminated.\n\t */\n\tif (buf[r - 1] == '\\n')\n\t\tr--;\n\tbuf[r] = '\\0';\n\n\tfor (i = 0; i < sizeof(dsa_protos) / sizeof(dsa_protos[0]); i++) {\n\t\tif (strlen(dsa_protos[i].name) == (size_t)r &&\n\t\t    strcmp(buf, dsa_protos[i].name) == 0) {\n\t\t\thandle->linktype = dsa_protos[i].linktype;\n\t\t\tswitch (dsa_protos[i].linktype) {\n\t\t\tcase DLT_EN10MB:\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t      \"unsupported DSA tag: %s\", buf);\n\n\treturn PCAP_ERROR;\n}",
          "fn_code_pos": [
            [
              6938,
              0
            ],
            [
              7002,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_dsa_get_proto_info",
            "parameters": {
              "device": "char",
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nactivate_old(pcap_t *handle, int is_any_device)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tint\t\terr;\n\tint\t\tarptype;\n\tstruct ifreq\tifr;\n\tconst char\t*device = handle->opt.device;\n\tstruct utsname\tutsname;\n\tint\t\tmtu;\n\n\t/*\n\t * PF_INET/SOCK_PACKET sockets must be bound to a device, so we\n\t * can't support the \"any\" device.\n\t */\n\tif (is_any_device) {\n\t\tpcap_strlcpy(handle->errbuf, \"pcap_activate: The \\\"any\\\" device isn't supported on 2.0[.x]-kernel systems\",\n\t\t\tPCAP_ERRBUF_SIZE);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/* Open the socket */\n\thandle->fd = socket(PF_INET, SOCK_PACKET, htons(ETH_P_ALL));\n\tif (handle->fd == -1) {\n\t\terr = errno;\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    err, \"socket\");\n\t\tif (err == EPERM || err == EACCES) {\n\t\t\t/*\n\t\t\t * You don't have permission to open the\n\t\t\t * socket.\n\t\t\t */\n\t\t\treturn PCAP_ERROR_PERM_DENIED;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Other error.\n\t\t\t */\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t}\n\n\t/* It worked - we are using the old interface */\n\thandlep->sock_packet = 1;\n\n\t/* ...which means we get the link-layer header. */\n\thandlep->cooked = 0;\n\n\t/* Bind to the given device */\n\tif (iface_bind_old(handle->fd, device, handle->errbuf) == -1) {\n\t\tclose(handle->fd);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * Try to get the link-layer type.\n\t */\n\tarptype = iface_get_arptype(handle->fd, device, handle->errbuf);\n\tif (arptype < 0) {\n\t\tclose(handle->fd);\n\t\treturn arptype;\n\t}\n\n\t/*\n\t * Try to find the DLT_ type corresponding to that\n\t * link-layer type.\n\t */\n\tmap_arphrd_to_dlt(handle, handle->fd, arptype, device, 0);\n\tif (handle->linktype == -1) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t \"unknown arptype %d\", arptype);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/* Go to promisc mode if requested */\n\n\tif (handle->opt.promisc) {\n\t\tmemset(&ifr, 0, sizeof(ifr));\n\t\tpcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));\n\t\tif (ioctl(handle->fd, SIOCGIFFLAGS, &ifr) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"SIOCGIFFLAGS\");\n\t\t\tclose(handle->fd);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t\tif ((ifr.ifr_flags & IFF_PROMISC) == 0) {\n\t\t\t/*\n\t\t\t * Promiscuous mode isn't currently on,\n\t\t\t * so turn it on, and remember that\n\t\t\t * we should turn it off when the\n\t\t\t * pcap_t is closed.\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * If we haven't already done so, arrange\n\t\t\t * to have \"pcap_close_all()\" called when\n\t\t\t * we exit.\n\t\t\t */\n\t\t\tif (!pcap_do_addexit(handle)) {\n\t\t\t\t/*\n\t\t\t\t * \"atexit()\" failed; don't put\n\t\t\t\t * the interface in promiscuous\n\t\t\t\t * mode, just give up.\n\t\t\t\t */\n\t\t\t\tclose(handle->fd);\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\n\t\t\tifr.ifr_flags |= IFF_PROMISC;\n\t\t\tif (ioctl(handle->fd, SIOCSIFFLAGS, &ifr) == -1) {\n\t\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"SIOCSIFFLAGS\");\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t\thandlep->must_do_on_close |= MUST_CLEAR_PROMISC;\n\n\t\t\t/*\n\t\t\t * Add this to the list of pcaps\n\t\t\t * to close when we exit.\n\t\t\t */\n\t\t\tpcap_add_to_pcaps_to_close(handle);\n\t\t}\n\t}\n\n\t/*\n\t * Compute the buffer size.\n\t *\n\t * We're using SOCK_PACKET, so this might be a 2.0[.x]\n\t * kernel, and might require special handling - check.\n\t */\n\tif (uname(&utsname) < 0 ||\n\t    strncmp(utsname.release, \"2.0\", 3) == 0) {\n\t\t/*\n\t\t * Either we couldn't find out what kernel release\n\t\t * this is, or it's a 2.0[.x] kernel.\n\t\t *\n\t\t * In the 2.0[.x] kernel, a \"recvfrom()\" on\n\t\t * a SOCK_PACKET socket, with MSG_TRUNC set, will\n\t\t * return the number of bytes read, so if we pass\n\t\t * a length based on the snapshot length, it'll\n\t\t * return the number of bytes from the packet\n\t\t * copied to userland, not the actual length\n\t\t * of the packet.\n\t\t *\n\t\t * This means that, for example, the IP dissector\n\t\t * in tcpdump will get handed a packet length less\n\t\t * than the length in the IP header, and will\n\t\t * complain about \"truncated-ip\".\n\t\t *\n\t\t * So we don't bother trying to copy from the\n\t\t * kernel only the bytes in which we're interested,\n\t\t * but instead copy them all, just as the older\n\t\t * versions of libpcap for Linux did.\n\t\t *\n\t\t * The buffer therefore needs to be big enough to\n\t\t * hold the largest packet we can get from this\n\t\t * device.  Unfortunately, we can't get the MRU\n\t\t * of the network; we can only get the MTU.  The\n\t\t * MTU may be too small, in which case a packet larger\n\t\t * than the buffer size will be truncated *and* we\n\t\t * won't get the actual packet size.\n\t\t *\n\t\t * However, if the snapshot length is larger than\n\t\t * the buffer size based on the MTU, we use the\n\t\t * snapshot length as the buffer size, instead;\n\t\t * this means that with a sufficiently large snapshot\n\t\t * length we won't artificially truncate packets\n\t\t * to the MTU-based size.\n\t\t *\n\t\t * This mess just one of many problems with packet\n\t\t * capture on 2.0[.x] kernels; you really want a\n\t\t * 2.2[.x] or later kernel if you want packet capture\n\t\t * to work well.\n\t\t */\n\t\tmtu = iface_get_mtu(handle->fd, device, handle->errbuf);\n\t\tif (mtu == -1) {\n\t\t\tclose(handle->fd);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\t\thandle->bufsize = MAX_LINKHEADER_SIZE + mtu;\n\t\tif (handle->bufsize < (u_int)handle->snapshot)\n\t\t\thandle->bufsize = (u_int)handle->snapshot;\n\t} else {\n\t\t/*\n\t\t * This is a 2.2[.x] or later kernel.\n\t\t *\n\t\t * We can safely pass \"recvfrom()\" a byte count\n\t\t * based on the snapshot length.\n\t\t *\n\t\t * XXX - this \"should not happen\", as 2.2[.x]\n\t\t * kernels all have PF_PACKET sockets, and there's\n\t\t * no configuration option to disable them without\n\t\t * disabling SOCK_PACKET sockets, because\n\t\t * SOCK_PACKET sockets are implemented in the same\n\t\t * source file, net/packet/af_packet.c.  There *is*\n\t\t * an option to disable SOCK_PACKET sockets so that\n\t\t * you only have PF_PACKET sockets, and the kernel\n\t\t * will log warning messages for code that uses\n\t\t * \"obsolete (PF_INET,SOCK_PACKET)\".\n\t\t */\n\t\thandle->bufsize = (u_int)handle->snapshot;\n\t}\n\n\t/*\n\t * Default value for offset to align link-layer payload\n\t * on a 4-byte boundary.\n\t */\n\thandle->offset\t = 0;\n\n\t/*\n\t * SOCK_PACKET sockets don't supply information from\n\t * stripped VLAN tags.\n\t */\n\thandlep->vlan_offset = -1; /* unknown */\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              7010,
              0
            ],
            [
              7225,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "activate_old",
            "parameters": {
              "handle": "pcap_t",
              "is_any_device": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\niface_bind_old(int fd, const char *device, char *ebuf)\n{\n\tstruct sockaddr\tsaddr;\n\tint\t\terr;\n\tsocklen_t\terrlen = sizeof(err);\n\n\tmemset(&saddr, 0, sizeof(saddr));\n\tpcap_strlcpy(saddr.sa_data, device, sizeof(saddr.sa_data));\n\tif (bind(fd, &saddr, sizeof(saddr)) == -1) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"bind\");\n\t\treturn -1;\n\t}\n\n\t/* Any pending errors, e.g., network is down? */\n\n\tif (getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &errlen) == -1) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"getsockopt (SO_ERROR)\");\n\t\treturn -1;\n\t}\n\n\tif (err > 0) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    err, \"bind\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              7231,
              0
            ],
            [
              7261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_bind_old",
            "parameters": {
              "fd": "int",
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\niface_get_mtu(int fd, const char *device, char *ebuf)\n{\n\tstruct ifreq\tifr;\n\n\tif (!device)\n\t\treturn BIGGER_THAN_ALL_MTUS;\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tpcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));\n\n\tif (ioctl(fd, SIOCGIFMTU, &ifr) == -1) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCGIFMTU\");\n\t\treturn -1;\n\t}\n\n\treturn ifr.ifr_mtu;\n}",
          "fn_code_pos": [
            [
              7269,
              0
            ],
            [
              7287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_get_mtu",
            "parameters": {
              "fd": "int",
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\niface_get_arptype(int fd, const char *device, char *ebuf)\n{\n\tstruct ifreq\tifr;\n\tint\t\tret;\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tpcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));\n\n\tif (ioctl(fd, SIOCGIFHWADDR, &ifr) == -1) {\n\t\tif (errno == ENODEV) {\n\t\t\t/*\n\t\t\t * No such device.\n\t\t\t */\n\t\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t} else\n\t\t\tret = PCAP_ERROR;\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCGIFHWADDR\");\n\t\treturn ret;\n\t}\n\n\treturn ifr.ifr_hwaddr.sa_family;\n}",
          "fn_code_pos": [
            [
              7292,
              0
            ],
            [
              7315,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_get_arptype",
            "parameters": {
              "fd": "int",
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nfix_program(pcap_t *handle, struct sock_fprog *fcode, int is_mmapped)\n{\n\tstruct pcap_linux *handlep = handle->priv;\n\tsize_t prog_size;\n\tregister int i;\n\tregister struct bpf_insn *p;\n\tstruct bpf_insn *f;\n\tint len;\n\n\t/*\n\t * Make a copy of the filter, and modify that copy if\n\t * necessary.\n\t */\n\tprog_size = sizeof(*handle->fcode.bf_insns) * handle->fcode.bf_len;\n\tlen = handle->fcode.bf_len;\n\tf = (struct bpf_insn *)malloc(prog_size);\n\tif (f == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn -1;\n\t}\n\tmemcpy(f, handle->fcode.bf_insns, prog_size);\n\tfcode->len = len;\n\tfcode->filter = (struct sock_filter *) f;\n\n\tfor (i = 0; i < len; ++i) {\n\t\tp = &f[i];\n\t\t/*\n\t\t * What type of instruction is this?\n\t\t */\n\t\tswitch (BPF_CLASS(p->code)) {\n\n\t\tcase BPF_RET:\n\t\t\t/*\n\t\t\t * It's a return instruction; are we capturing\n\t\t\t * in memory-mapped mode?\n\t\t\t */\n\t\t\tif (!is_mmapped) {\n\t\t\t\t/*\n\t\t\t\t * No; is the snapshot length a constant,\n\t\t\t\t * rather than the contents of the\n\t\t\t\t * accumulator?\n\t\t\t\t */\n\t\t\t\tif (BPF_MODE(p->code) == BPF_K) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Yes - if the value to be returned,\n\t\t\t\t\t * i.e. the snapshot length, is\n\t\t\t\t\t * anything other than 0, make it\n\t\t\t\t\t * MAXIMUM_SNAPLEN, so that the packet\n\t\t\t\t\t * is truncated by \"recvfrom()\",\n\t\t\t\t\t * not by the filter.\n\t\t\t\t\t *\n\t\t\t\t\t * XXX - there's nothing we can\n\t\t\t\t\t * easily do if it's getting the\n\t\t\t\t\t * value from the accumulator; we'd\n\t\t\t\t\t * have to insert code to force\n\t\t\t\t\t * non-zero values to be\n\t\t\t\t\t * MAXIMUM_SNAPLEN.\n\t\t\t\t\t */\n\t\t\t\t\tif (p->k != 0)\n\t\t\t\t\t\tp->k = MAXIMUM_SNAPLEN;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase BPF_LD:\n\t\tcase BPF_LDX:\n\t\t\t/*\n\t\t\t * It's a load instruction; is it loading\n\t\t\t * from the packet?\n\t\t\t */\n\t\t\tswitch (BPF_MODE(p->code)) {\n\n\t\t\tcase BPF_ABS:\n\t\t\tcase BPF_IND:\n\t\t\tcase BPF_MSH:\n\t\t\t\t/*\n\t\t\t\t * Yes; are we in cooked mode?\n\t\t\t\t */\n\t\t\t\tif (handlep->cooked) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Yes, so we need to fix this\n\t\t\t\t\t * instruction.\n\t\t\t\t\t */\n\t\t\t\t\tif (fix_offset(handle, p) < 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We failed to do so.\n\t\t\t\t\t\t * Return 0, so our caller\n\t\t\t\t\t\t * knows to punt to userland.\n\t\t\t\t\t\t */\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 1;\t/* we succeeded */\n}",
          "fn_code_pos": [
            [
              7318,
              0
            ],
            [
              7418,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fix_program",
            "parameters": {
              "handle": "pcap_t",
              "fcode": "struct sock_fprog",
              "is_mmapped": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nfix_offset(pcap_t *handle, struct bpf_insn *p)\n{\n\tif (handle->linktype == DLT_LINUX_SLL2) {\n\t\t/*\n\t\t * What's the offset?\n\t\t */\n\t\tif (p->k >= SLL2_HDR_LEN) {\n\t\t\t/*\n\t\t\t * It's within the link-layer payload; that starts\n\t\t\t * at an offset of 0, as far as the kernel packet\n\t\t\t * filter is concerned, so subtract the length of\n\t\t\t * the link-layer header.\n\t\t\t */\n\t\t\tp->k -= SLL2_HDR_LEN;\n\t\t} else if (p->k == 0) {\n\t\t\t/*\n\t\t\t * It's the protocol field; map it to the\n\t\t\t * special magic kernel offset for that field.\n\t\t\t */\n\t\t\tp->k = SKF_AD_OFF + SKF_AD_PROTOCOL;\n\t\t} else if (p->k == 10) {\n\t\t\t/*\n\t\t\t * It's the packet type field; map it to the\n\t\t\t * special magic kernel offset for that field.\n\t\t\t */\n\t\t\tp->k = SKF_AD_OFF + SKF_AD_PKTTYPE;\n\t\t} else if ((bpf_int32)(p->k) > 0) {\n\t\t\t/*\n\t\t\t * It's within the header, but it's not one of\n\t\t\t * those fields; we can't do that in the kernel,\n\t\t\t * so punt to userland.\n\t\t\t */\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * What's the offset?\n\t\t */\n\t\tif (p->k >= SLL_HDR_LEN) {\n\t\t\t/*\n\t\t\t * It's within the link-layer payload; that starts\n\t\t\t * at an offset of 0, as far as the kernel packet\n\t\t\t * filter is concerned, so subtract the length of\n\t\t\t * the link-layer header.\n\t\t\t */\n\t\t\tp->k -= SLL_HDR_LEN;\n\t\t} else if (p->k == 0) {\n\t\t\t/*\n\t\t\t * It's the packet type field; map it to the\n\t\t\t * special magic kernel offset for that field.\n\t\t\t */\n\t\t\tp->k = SKF_AD_OFF + SKF_AD_PKTTYPE;\n\t\t} else if (p->k == 14) {\n\t\t\t/*\n\t\t\t * It's the protocol field; map it to the\n\t\t\t * special magic kernel offset for that field.\n\t\t\t */\n\t\t\tp->k = SKF_AD_OFF + SKF_AD_PROTOCOL;\n\t\t} else if ((bpf_int32)(p->k) > 0) {\n\t\t\t/*\n\t\t\t * It's within the header, but it's not one of\n\t\t\t * those fields; we can't do that in the kernel,\n\t\t\t * so punt to userland.\n\t\t\t */\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              7420,
              0
            ],
            [
              7489,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fix_offset",
            "parameters": {
              "handle": "pcap_t",
              "p": "struct bpf_insn"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nset_kernel_filter(pcap_t *handle, struct sock_fprog *fcode)\n{\n\tint total_filter_on = 0;\n\tint save_mode;\n\tint ret;\n\tint save_errno;\n\n\t/*\n\t * The socket filter code doesn't discard all packets queued\n\t * up on the socket when the filter is changed; this means\n\t * that packets that don't match the new filter may show up\n\t * after the new filter is put onto the socket, if those\n\t * packets haven't yet been read.\n\t *\n\t * This means, for example, that if you do a tcpdump capture\n\t * with a filter, the first few packets in the capture might\n\t * be packets that wouldn't have passed the filter.\n\t *\n\t * We therefore discard all packets queued up on the socket\n\t * when setting a kernel filter.  (This isn't an issue for\n\t * userland filters, as the userland filtering is done after\n\t * packets are queued up.)\n\t *\n\t * To flush those packets, we put the socket in read-only mode,\n\t * and read packets from the socket until there are no more to\n\t * read.\n\t *\n\t * In order to keep that from being an infinite loop - i.e.,\n\t * to keep more packets from arriving while we're draining\n\t * the queue - we put the \"total filter\", which is a filter\n\t * that rejects all packets, onto the socket before draining\n\t * the queue.\n\t *\n\t * This code deliberately ignores any errors, so that you may\n\t * get bogus packets if an error occurs, rather than having\n\t * the filtering done in userland even if it could have been\n\t * done in the kernel.\n\t */\n\tif (setsockopt(handle->fd, SOL_SOCKET, SO_ATTACH_FILTER,\n\t\t       &total_fcode, sizeof(total_fcode)) == 0) {\n\t\tchar drain[1];\n\n\t\t/*\n\t\t * Note that we've put the total filter onto the socket.\n\t\t */\n\t\ttotal_filter_on = 1;\n\n\t\t/*\n\t\t * Save the socket's current mode, and put it in\n\t\t * non-blocking mode; we drain it by reading packets\n\t\t * until we get an error (which is normally a\n\t\t * \"nothing more to be read\" error).\n\t\t */\n\t\tsave_mode = fcntl(handle->fd, F_GETFL, 0);\n\t\tif (save_mode == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"can't get FD flags when changing filter\");\n\t\t\treturn -2;\n\t\t}\n\t\tif (fcntl(handle->fd, F_SETFL, save_mode | O_NONBLOCK) < 0) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"can't set nonblocking mode when changing filter\");\n\t\t\treturn -2;\n\t\t}\n\t\twhile (recv(handle->fd, &drain, sizeof drain, MSG_TRUNC) >= 0)\n\t\t\t;\n\t\tsave_errno = errno;\n\t\tif (save_errno != EAGAIN) {\n\t\t\t/*\n\t\t\t * Fatal error.\n\t\t\t *\n\t\t\t * If we can't restore the mode or reset the\n\t\t\t * kernel filter, there's nothing we can do.\n\t\t\t */\n\t\t\t(void)fcntl(handle->fd, F_SETFL, save_mode);\n\t\t\t(void)reset_kernel_filter(handle);\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, save_errno,\n\t\t\t    \"recv failed when changing filter\");\n\t\t\treturn -2;\n\t\t}\n\t\tif (fcntl(handle->fd, F_SETFL, save_mode) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"can't restore FD flags when changing filter\");\n\t\t\treturn -2;\n\t\t}\n\t}\n\n\t/*\n\t * Now attach the new filter.\n\t */\n\tret = setsockopt(handle->fd, SOL_SOCKET, SO_ATTACH_FILTER,\n\t\t\t fcode, sizeof(*fcode));\n\tif (ret == -1 && total_filter_on) {\n\t\t/*\n\t\t * Well, we couldn't set that filter on the socket,\n\t\t * but we could set the total filter on the socket.\n\t\t *\n\t\t * This could, for example, mean that the filter was\n\t\t * too big to put into the kernel, so we'll have to\n\t\t * filter in userland; in any case, we'll be doing\n\t\t * filtering in userland, so we need to remove the\n\t\t * total filter so we see packets.\n\t\t */\n\t\tsave_errno = errno;\n\n\t\t/*\n\t\t * If this fails, we're really screwed; we have the\n\t\t * total filter on the socket, and it won't come off.\n\t\t * Report it as a fatal error.\n\t\t */\n\t\tif (reset_kernel_filter(handle) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"can't remove kernel total filter\");\n\t\t\treturn -2;\t/* fatal error */\n\t\t}\n\n\t\terrno = save_errno;\n\t}\n\treturn ret;\n}",
          "fn_code_pos": [
            [
              7491,
              0
            ],
            [
              7616,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_kernel_filter",
            "parameters": {
              "handle": "pcap_t",
              "fcode": "struct sock_fprog"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nreset_kernel_filter(pcap_t *handle)\n{\n\tint ret;\n\t/*\n\t * setsockopt() barfs unless it get a dummy parameter.\n\t * valgrind whines unless the value is initialized,\n\t * as it has no idea that setsockopt() ignores its\n\t * parameter.\n\t */\n\tint dummy = 0;\n\n\tret = setsockopt(handle->fd, SOL_SOCKET, SO_DETACH_FILTER,\n\t\t\t\t   &dummy, sizeof(dummy));\n\t/*\n\t * Ignore ENOENT - it means \"we don't have a filter\", so there\n\t * was no filter to remove, and there's still no filter.\n\t *\n\t * Also ignore ENONET, as a lot of kernel versions had a\n\t * typo where ENONET, rather than ENOENT, was returned.\n\t */\n\tif (ret == -1 && errno != ENOENT && errno != ENONET)\n\t\treturn -1;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              7618,
              0
            ],
            [
              7642,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reset_kernel_filter",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_set_protocol_linux(pcap_t *p, int protocol)\n{\n\tif (pcap_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\tp->opt.protocol = protocol;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              7645,
              0
            ],
            [
              7652,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_protocol_linux",
            "parameters": {
              "p": "pcap_t",
              "protocol": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n#ifdef HAVE_PACKET_RING\n #if defined(HAVE_TPACKET3)\n\treturn (PCAP_VERSION_STRING \" (with TPACKET_V3)\");\n #elif defined(HAVE_TPACKET2)\n\treturn (PCAP_VERSION_STRING \" (with TPACKET_V2)\");\n #else\n\treturn (PCAP_VERSION_STRING \" (with TPACKET_V1)\");\n #endif\n#else\n\treturn (PCAP_VERSION_STRING \" (without TPACKET)\");\n#endif\n}",
          "fn_code_pos": [
            [
              7657,
              0
            ],
            [
              7671,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "get_if_flags(const char *, bpf_u_int32 *, char *)",
          "fn_dec_pos": [
            [
              346,
              11
            ],
            [
              346,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_if_flags",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "is_wifi(int, const char *)",
          "fn_dec_pos": [
            [
              347,
              11
            ],
            [
              347,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "is_wifi",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "map_arphrd_to_dlt(pcap_t *, int, int, const char *, int)",
          "fn_dec_pos": [
            [
              348,
              12
            ],
            [
              348,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "map_arphrd_to_dlt",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_activate_linux(pcap_t *)",
          "fn_dec_pos": [
            [
              349,
              11
            ],
            [
              349,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_activate_linux",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "activate_old(pcap_t *, int)",
          "fn_dec_pos": [
            [
              350,
              11
            ],
            [
              350,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "activate_old",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "activate_new(pcap_t *, int)",
          "fn_dec_pos": [
            [
              352,
              11
            ],
            [
              352,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "activate_new",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "activate_mmap(pcap_t *, int *)",
          "fn_dec_pos": [
            [
              354,
              11
            ],
            [
              354,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "activate_mmap",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_can_set_rfmon_linux(pcap_t *)",
          "fn_dec_pos": [
            [
              357,
              11
            ],
            [
              357,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_can_set_rfmon_linux",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_read_linux(pcap_t *, int, pcap_handler, u_char *)",
          "fn_dec_pos": [
            [
              358,
              11
            ],
            [
              358,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_linux",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_read_packet(pcap_t *, pcap_handler, u_char *)",
          "fn_dec_pos": [
            [
              359,
              11
            ],
            [
              359,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_packet",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_inject_linux(pcap_t *, const void *, int)",
          "fn_dec_pos": [
            [
              360,
              11
            ],
            [
              360,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject_linux",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_stats_linux(pcap_t *, struct pcap_stat *)",
          "fn_dec_pos": [
            [
              361,
              11
            ],
            [
              361,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_linux",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_setfilter_linux(pcap_t *, struct bpf_program *)",
          "fn_dec_pos": [
            [
              362,
              11
            ],
            [
              362,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_linux",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_setdirection_linux(pcap_t *, pcap_direction_t)",
          "fn_dec_pos": [
            [
              363,
              11
            ],
            [
              363,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setdirection_linux",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_set_datalink_linux(pcap_t *, int)",
          "fn_dec_pos": [
            [
              364,
              11
            ],
            [
              364,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_datalink_linux",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_cleanup_linux(pcap_t *)",
          "fn_dec_pos": [
            [
              365,
              12
            ],
            [
              365,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_cleanup_linux",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "destroy_ring(pcap_t *handle)",
          "fn_dec_pos": [
            [
              404,
              12
            ],
            [
              404,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "destroy_ring",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "create_ring(pcap_t *handle, int *status)",
          "fn_dec_pos": [
            [
              405,
              11
            ],
            [
              405,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "create_ring",
            "parameters": {
              "handle": "pcap_t",
              "status": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "prepare_tpacket_socket(pcap_t *handle)",
          "fn_dec_pos": [
            [
              406,
              11
            ],
            [
              406,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "prepare_tpacket_socket",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_cleanup_linux_mmap(pcap_t *)",
          "fn_dec_pos": [
            [
              407,
              12
            ],
            [
              407,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_cleanup_linux_mmap",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_read_linux_mmap_v1(pcap_t *, int, pcap_handler , u_char *)",
          "fn_dec_pos": [
            [
              408,
              11
            ],
            [
              408,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_linux_mmap_v1",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_read_linux_mmap_v1_64(pcap_t *, int, pcap_handler , u_char *)",
          "fn_dec_pos": [
            [
              409,
              11
            ],
            [
              409,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_linux_mmap_v1_64",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_read_linux_mmap_v2(pcap_t *, int, pcap_handler , u_char *)",
          "fn_dec_pos": [
            [
              411,
              11
            ],
            [
              411,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_linux_mmap_v2",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_read_linux_mmap_v3(pcap_t *, int, pcap_handler , u_char *)",
          "fn_dec_pos": [
            [
              414,
              11
            ],
            [
              414,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_linux_mmap_v3",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_setfilter_linux_mmap(pcap_t *, struct bpf_program *)",
          "fn_dec_pos": [
            [
              416,
              11
            ],
            [
              416,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_linux_mmap",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_setnonblock_mmap(pcap_t *p, int nonblock)",
          "fn_dec_pos": [
            [
              417,
              11
            ],
            [
              417,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setnonblock_mmap",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_getnonblock_mmap(pcap_t *p)",
          "fn_dec_pos": [
            [
              418,
              11
            ],
            [
              418,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getnonblock_mmap",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_oneshot_mmap(u_char *user, const struct pcap_pkthdr *h,\n    const u_char *bytes)",
          "fn_dec_pos": [
            [
              419,
              12
            ],
            [
              420,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_oneshot_mmap",
            "parameters": {
              "user": "u_char",
              "h": "struct pcap_pkthdr",
              "bytes": "u_char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "iface_get_id(int fd, const char *device, char *ebuf)",
          "fn_dec_pos": [
            [
              473,
              11
            ],
            [
              473,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_get_id",
            "parameters": {
              "fd": "int",
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "iface_get_mtu(int fd, const char *device, char *ebuf)",
          "fn_dec_pos": [
            [
              475,
              11
            ],
            [
              475,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_get_mtu",
            "parameters": {
              "fd": "int",
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "iface_get_arptype(int fd, const char *device, char *ebuf)",
          "fn_dec_pos": [
            [
              476,
              12
            ],
            [
              476,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_get_arptype",
            "parameters": {
              "fd": "int",
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "iface_bind(int fd, int ifindex, char *ebuf, int protocol)",
          "fn_dec_pos": [
            [
              478,
              12
            ],
            [
              478,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_bind",
            "parameters": {
              "fd": "int",
              "ifindex": "int",
              "ebuf": "char",
              "protocol": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "has_wext(int sock_fd, const char *device, char *ebuf)",
          "fn_dec_pos": [
            [
              480,
              11
            ],
            [
              480,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "has_wext",
            "parameters": {
              "sock_fd": "int",
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "enter_rfmon_mode(pcap_t *handle, int sock_fd,\n    const char *device)",
          "fn_dec_pos": [
            [
              482,
              11
            ],
            [
              483,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "enter_rfmon_mode",
            "parameters": {
              "handle": "pcap_t",
              "sock_fd": "int",
              "device": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "iface_ethtool_get_ts_info(const char *device, pcap_t *handle,\n    char *ebuf)",
          "fn_dec_pos": [
            [
              486,
              11
            ],
            [
              487,
              15
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_ethtool_get_ts_info",
            "parameters": {
              "device": "char",
              "handle": "pcap_t",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "iface_get_offload(pcap_t *handle)",
          "fn_dec_pos": [
            [
              490,
              11
            ],
            [
              490,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_get_offload",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "iface_bind_old(int fd, const char *device, char *ebuf)",
          "fn_dec_pos": [
            [
              492,
              12
            ],
            [
              492,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_bind_old",
            "parameters": {
              "fd": "int",
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "fix_program(pcap_t *handle, struct sock_fprog *fcode,\n    int is_mapped)",
          "fn_dec_pos": [
            [
              495,
              11
            ],
            [
              496,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fix_program",
            "parameters": {
              "handle": "pcap_t",
              "fcode": "struct sock_fprog",
              "is_mapped": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "fix_offset(pcap_t *handle, struct bpf_insn *p)",
          "fn_dec_pos": [
            [
              497,
              11
            ],
            [
              497,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fix_offset",
            "parameters": {
              "handle": "pcap_t",
              "p": "struct bpf_insn"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "set_kernel_filter(pcap_t *handle, struct sock_fprog *fcode)",
          "fn_dec_pos": [
            [
              498,
              11
            ],
            [
              498,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_kernel_filter",
            "parameters": {
              "handle": "pcap_t",
              "fcode": "struct sock_fprog"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "reset_kernel_filter(pcap_t *handle)",
          "fn_dec_pos": [
            [
              499,
              11
            ],
            [
              499,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reset_kernel_filter",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "iface_dsa_get_proto_info(const char *device, pcap_t *handle)",
          "fn_dec_pos": [
            [
              507,
              11
            ],
            [
              507,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iface_dsa_get_proto_info",
            "parameters": {
              "device": "char",
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_create_interface(const char *device, char *ebuf)",
          "fn_dec_pos": [
            [
              510,
              0
            ],
            [
              510,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "nl_socket_alloc(void)",
          "fn_dec_pos": [
            [
              653,
              0
            ],
            [
              653,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nl_socket_alloc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "del_mon_if(pcap_t *handle, int sock_fd, struct nl80211_state *state,\n    const char *device, const char *mondevice)",
          "fn_dec_pos": [
            [
              735,
              0
            ],
            [
              736,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "del_mon_if",
            "parameters": {
              "handle": "pcap_t",
              "sock_fd": "int",
              "state": "struct nl80211_state",
              "device": "char",
              "mondevice": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "add_mon_if(pcap_t *handle, int sock_fd, struct nl80211_state *state,\n    const char *device, const char *mondevice)",
          "fn_dec_pos": [
            [
              739,
              0
            ],
            [
              740,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_mon_if",
            "parameters": {
              "handle": "pcap_t",
              "sock_fd": "int",
              "state": "struct nl80211_state",
              "device": "char",
              "mondevice": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "NLA_PUT_STRING(msg, NL80211_ATTR_IFNAME, mondevice)",
          "fn_dec_pos": [
            [
              762,
              1
            ],
            [
              762,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NLA_PUT_STRING",
            "parameters": {},
            "return_type": "DIAG_OFF_NARROWING"
          }
        },
        {
          "fn_code": "NLA_PUT_U32(msg, NL80211_ATTR_IFTYPE, NL80211_IFTYPE_MONITOR)",
          "fn_dec_pos": [
            [
              764,
              1
            ],
            [
              764,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NLA_PUT_U32",
            "parameters": {},
            "return_type": "DIAG_ON_NARROWING"
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              7658,
              0
            ],
            [
              7658,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_linux {\n\tu_int\tpackets_read;\t/* count of packets read with recvfrom() */\n\tlong\tproc_dropped;\t/* packets reported dropped by /proc/net/dev */\n\tstruct pcap_stat stat;\n\n\tchar\t*device;\t/* device name */\n\tint\tfilter_in_userland; /* must filter in userland */\n\tint\tblocks_to_filter_in_userland;\n\tint\tmust_do_on_close; /* stuff we must do when we close */\n\tint\ttimeout;\t/* timeout for buffering */\n\tint\tsock_packet;\t/* using Linux 2.0 compatible interface */\n\tint\tcooked;\t\t/* using SOCK_DGRAM rather than SOCK_RAW */\n\tint\tifindex;\t/* interface index of device we're bound to */\n\tint\tlo_ifindex;\t/* interface index of the loopback device */\n\tbpf_u_int32 oldmode;\t/* mode to restore when turning monitor mode off */\n\tchar\t*mondevice;\t/* mac80211 monitor device we created */\n\tu_char\t*mmapbuf;\t/* memory-mapped region pointer */\n\tsize_t\tmmapbuflen;\t/* size of region */\n\tint\tvlan_offset;\t/* offset at which to insert vlan tags; if -1, don't insert */\n\tu_int\ttp_version;\t/* version of tpacket_hdr for mmaped ring */\n\tu_int\ttp_hdrlen;\t/* hdrlen of tpacket_hdr for mmaped ring */\n\tu_char\t*oneshot_buffer; /* buffer for copy of packet */\n\tint\tpoll_timeout;\t/* timeout to use in poll() */\n#ifdef HAVE_TPACKET3\n\tunsigned char *current_packet; /* Current packet within the TPACKET_V3 block. Move to next block if NULL. */\n\tint packets_left; /* Unhandled packets left within the block from previous call to pcap_read_linux_mmap_v3 in case of TPACKET_V3. */\n#endif\n#ifdef HAVE_SYS_EVENTFD_H\n\tint poll_breakloop_fd; /* fd to an eventfd to break from blocking operations */\n#endif\n}",
          {
            "packets_read": "u_int",
            "proc_dropped": "long",
            "stat": "struct pcap_stat",
            "*device": "char",
            "filter_in_userland": "int",
            "blocks_to_filter_in_userland": "int",
            "must_do_on_close": "int",
            "timeout": "int",
            "sock_packet": "int",
            "cooked": "int",
            "ifindex": "int",
            "lo_ifindex": "int",
            "oldmode": "bpf_u_int32",
            "*mondevice": "char",
            "*mmapbuf": "u_char",
            "mmapbuflen": "size_t",
            "vlan_offset": "int",
            "tp_version": "u_int",
            "tp_hdrlen": "u_int",
            "*oneshot_buffer": "u_char",
            "poll_timeout": "int",
            "*current_packet": "unsigned char",
            "packets_left": "int",
            "poll_breakloop_fd": "int"
          },
          "pcap_linux",
          [
            304,
            0
          ],
          [
            334,
            1
          ]
        ],
        [
          "struct tpacket_hdr_64 {\n\tuint64_t\ttp_status;\n\tunsigned int\ttp_len;\n\tunsigned int\ttp_snaplen;\n\tunsigned short\ttp_mac;\n\tunsigned short\ttp_net;\n\tunsigned int\ttp_sec;\n\tunsigned int\ttp_usec;\n}",
          {
            "tp_status": "uint64_t",
            "tp_len": "unsigned int",
            "tp_snaplen": "unsigned int",
            "tp_mac": "unsigned short",
            "tp_net": "unsigned short",
            "tp_sec": "unsigned int",
            "tp_usec": "unsigned int"
          },
          "tpacket_hdr_64",
          [
            372,
            0
          ],
          [
            380,
            1
          ]
        ],
        [
          "struct nl80211_state {\n\tstruct nl_sock *nl_sock;\n\tstruct nl_cache *nl_cache;\n\tstruct genl_family *nl80211;\n}",
          {
            "*nl_sock": "struct nl_sock",
            "*nl_cache": "struct nl_cache",
            "*nl80211": "struct genl_family"
          },
          "nl80211_state",
          [
            678,
            0
          ],
          [
            682,
            1
          ]
        ],
        [
          "struct {\n\tint soft_timestamping_val;\n\tint pcap_tstamp_val;\n}",
          {
            "soft_timestamping_val": "int",
            "pcap_tstamp_val": "int"
          },
          "",
          [
            6611,
            13
          ],
          [
            6614,
            1
          ]
        ],
        [
          "struct dsa_proto {\n\tconst char *name;\n\tbpf_u_int32 linktype;\n}",
          {
            "char": "const",
            "linktype": "bpf_u_int32"
          },
          "dsa_proto",
          [
            6924,
            7
          ],
          [
            6927,
            1
          ]
        ],
        [
          "struct pcap_linux {\n\tu_int\tpackets_read;\t/* count of packets read with recvfrom() */\n\tlong\tproc_dropped;\t/* packets reported dropped by /proc/net/dev */\n\tstruct pcap_stat stat;\n\n\tchar\t*device;\t/* device name */\n\tint\tfilter_in_userland; /* must filter in userland */\n\tint\tblocks_to_filter_in_userland;\n\tint\tmust_do_on_close; /* stuff we must do when we close */\n\tint\ttimeout;\t/* timeout for buffering */\n\tint\tsock_packet;\t/* using Linux 2.0 compatible interface */\n\tint\tcooked;\t\t/* using SOCK_DGRAM rather than SOCK_RAW */\n\tint\tifindex;\t/* interface index of device we're bound to */\n\tint\tlo_ifindex;\t/* interface index of the loopback device */\n\tbpf_u_int32 oldmode;\t/* mode to restore when turning monitor mode off */\n\tchar\t*mondevice;\t/* mac80211 monitor device we created */\n\tu_char\t*mmapbuf;\t/* memory-mapped region pointer */\n\tsize_t\tmmapbuflen;\t/* size of region */\n\tint\tvlan_offset;\t/* offset at which to insert vlan tags; if -1, don't insert */\n\tu_int\ttp_version;\t/* version of tpacket_hdr for mmaped ring */\n\tu_int\ttp_hdrlen;\t/* hdrlen of tpacket_hdr for mmaped ring */\n\tu_char\t*oneshot_buffer; /* buffer for copy of packet */\n\tint\tpoll_timeout;\t/* timeout to use in poll() */\n#ifdef HAVE_TPACKET3\n\tunsigned char *current_packet; /* Current packet within the TPACKET_V3 block. Move to next block if NULL. */\n\tint packets_left; /* Unhandled packets left within the block from previous call to pcap_read_linux_mmap_v3 in case of TPACKET_V3. */\n#endif\n#ifdef HAVE_SYS_EVENTFD_H\n\tint poll_breakloop_fd; /* fd to an eventfd to break from blocking operations */\n#endif\n}",
          {
            "packets_read": "u_int",
            "proc_dropped": "long",
            "stat": "struct pcap_stat",
            "*device": "char",
            "filter_in_userland": "int",
            "blocks_to_filter_in_userland": "int",
            "must_do_on_close": "int",
            "timeout": "int",
            "sock_packet": "int",
            "cooked": "int",
            "ifindex": "int",
            "lo_ifindex": "int",
            "oldmode": "bpf_u_int32",
            "*mondevice": "char",
            "*mmapbuf": "u_char",
            "mmapbuflen": "size_t",
            "vlan_offset": "int",
            "tp_version": "u_int",
            "tp_hdrlen": "u_int",
            "*oneshot_buffer": "u_char",
            "poll_timeout": "int",
            "*current_packet": "unsigned char",
            "packets_left": "int",
            "poll_breakloop_fd": "int"
          },
          "pcap_linux",
          [
            304,
            0
          ],
          [
            334,
            1
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            307,
            1
          ],
          [
            307,
            17
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            361,
            38
          ],
          [
            361,
            54
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            362,
            42
          ],
          [
            362,
            60
          ]
        ],
        [
          "struct tpacket_hdr_64 {\n\tuint64_t\ttp_status;\n\tunsigned int\ttp_len;\n\tunsigned int\ttp_snaplen;\n\tunsigned short\ttp_mac;\n\tunsigned short\ttp_net;\n\tunsigned int\ttp_sec;\n\tunsigned int\ttp_usec;\n}",
          {
            "tp_status": "uint64_t",
            "tp_len": "unsigned int",
            "tp_snaplen": "unsigned int",
            "tp_mac": "unsigned short",
            "tp_net": "unsigned short",
            "tp_sec": "unsigned int",
            "tp_usec": "unsigned int"
          },
          "tpacket_hdr_64",
          [
            372,
            0
          ],
          [
            380,
            1
          ]
        ],
        [
          "struct tpacket_hdr",
          {},
          "",
          [
            389,
            1
          ],
          [
            389,
            19
          ]
        ],
        [
          "struct tpacket_hdr_64",
          {},
          "",
          [
            390,
            1
          ],
          [
            390,
            22
          ]
        ],
        [
          "struct tpacket2_hdr",
          {},
          "",
          [
            392,
            1
          ],
          [
            392,
            20
          ]
        ],
        [
          "struct tpacket_block_desc",
          {},
          "",
          [
            395,
            1
          ],
          [
            395,
            26
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            416,
            47
          ],
          [
            416,
            65
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            419,
            50
          ],
          [
            419,
            68
          ]
        ],
        [
          "struct sock_fprog",
          {},
          "",
          [
            495,
            39
          ],
          [
            495,
            56
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            497,
            38
          ],
          [
            497,
            53
          ]
        ],
        [
          "struct sock_fprog",
          {},
          "",
          [
            498,
            45
          ],
          [
            498,
            62
          ]
        ],
        [
          "struct sock_filter",
          {},
          "",
          [
            501,
            7
          ],
          [
            501,
            25
          ]
        ],
        [
          "struct sock_fprog",
          {},
          "",
          [
            503,
            7
          ],
          [
            503,
            24
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            514,
            43
          ],
          [
            514,
            60
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            553,
            1
          ],
          [
            553,
            18
          ]
        ],
        [
          "struct nl_handle",
          {},
          "",
          [
            652,
            14
          ],
          [
            652,
            30
          ]
        ],
        [
          "struct nl_handle",
          {},
          "",
          [
            659,
            15
          ],
          [
            659,
            31
          ]
        ],
        [
          "struct nl_handle",
          {},
          "",
          [
            667,
            24
          ],
          [
            667,
            40
          ]
        ],
        [
          "struct nl_cache",
          {},
          "",
          [
            667,
            45
          ],
          [
            667,
            60
          ]
        ],
        [
          "struct nl_cache",
          {},
          "",
          [
            669,
            1
          ],
          [
            669,
            16
          ]
        ],
        [
          "struct nl80211_state {\n\tstruct nl_sock *nl_sock;\n\tstruct nl_cache *nl_cache;\n\tstruct genl_family *nl80211;\n}",
          {
            "*nl_sock": "struct nl_sock",
            "*nl_cache": "struct nl_cache",
            "*nl80211": "struct genl_family"
          },
          "nl80211_state",
          [
            678,
            0
          ],
          [
            682,
            1
          ]
        ],
        [
          "struct nl_sock",
          {},
          "",
          [
            679,
            1
          ],
          [
            679,
            15
          ]
        ],
        [
          "struct nl_cache",
          {},
          "",
          [
            680,
            1
          ],
          [
            680,
            16
          ]
        ],
        [
          "struct genl_family",
          {},
          "",
          [
            681,
            1
          ],
          [
            681,
            19
          ]
        ],
        [
          "struct nl80211_state",
          {},
          "",
          [
            685,
            29
          ],
          [
            685,
            49
          ]
        ],
        [
          "struct nl80211_state",
          {},
          "",
          [
            727,
            16
          ],
          [
            727,
            36
          ]
        ],
        [
          "struct nl80211_state",
          {},
          "",
          [
            735,
            40
          ],
          [
            735,
            60
          ]
        ],
        [
          "struct nl80211_state",
          {},
          "",
          [
            739,
            40
          ],
          [
            739,
            60
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            742,
            1
          ],
          [
            742,
            18
          ]
        ],
        [
          "struct nl_msg",
          {},
          "",
          [
            744,
            1
          ],
          [
            744,
            14
          ]
        ],
        [
          "struct nl80211_state",
          {},
          "",
          [
            852,
            40
          ],
          [
            852,
            60
          ]
        ],
        [
          "struct nl_msg",
          {},
          "",
          [
            856,
            1
          ],
          [
            856,
            14
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            908,
            1
          ],
          [
            908,
            18
          ]
        ],
        [
          "struct nl80211_state",
          {},
          "",
          [
            911,
            1
          ],
          [
            911,
            21
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            912,
            1
          ],
          [
            912,
            13
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            1054,
            1
          ],
          [
            1054,
            13
          ]
        ],
        [
          "struct iwreq",
          {},
          "",
          [
            1089,
            1
          ],
          [
            1089,
            13
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            1244,
            1
          ],
          [
            1244,
            18
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            1245,
            1
          ],
          [
            1245,
            13
          ]
        ],
        [
          "struct nl80211_state",
          {},
          "",
          [
            1247,
            1
          ],
          [
            1247,
            21
          ]
        ],
        [
          "struct iwreq",
          {},
          "",
          [
            1252,
            1
          ],
          [
            1252,
            13
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            1404,
            17
          ],
          [
            1404,
            34
          ]
        ],
        [
          "struct utsname",
          {},
          "",
          [
            1407,
            1
          ],
          [
            1407,
            15
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            1492,
            1
          ],
          [
            1492,
            18
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            1582,
            1
          ],
          [
            1582,
            18
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            1585,
            1
          ],
          [
            1585,
            13
          ]
        ],
        [
          "struct sockaddr_ll",
          {},
          "",
          [
            1837,
            50
          ],
          [
            1837,
            68
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            1839,
            1
          ],
          [
            1839,
            18
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            1891,
            1
          ],
          [
            1891,
            18
          ]
        ],
        [
          "struct sockaddr_ll",
          {},
          "",
          [
            1895,
            1
          ],
          [
            1895,
            19
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1897,
            1
          ],
          [
            1897,
            16
          ]
        ],
        [
          "struct iovec",
          {},
          "",
          [
            1900,
            1
          ],
          [
            1900,
            13
          ]
        ],
        [
          "struct msghdr",
          {},
          "",
          [
            1901,
            1
          ],
          [
            1901,
            14
          ]
        ],
        [
          "struct cmsghdr",
          {},
          "",
          [
            1902,
            1
          ],
          [
            1902,
            15
          ]
        ],
        [
          "struct cmsghdr",
          {},
          "",
          [
            1904,
            2
          ],
          [
            1904,
            16
          ]
        ],
        [
          "struct tpacket_auxdata",
          {},
          "",
          [
            1905,
            30
          ],
          [
            1905,
            52
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            1912,
            1
          ],
          [
            1912,
            19
          ]
        ],
        [
          "struct bpf_aux_data",
          {},
          "",
          [
            1914,
            8
          ],
          [
            1914,
            27
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1986,
            4
          ],
          [
            1986,
            19
          ]
        ],
        [
          "struct sll2_header",
          {},
          "",
          [
            2056,
            3
          ],
          [
            2056,
            21
          ]
        ],
        [
          "struct sll2_header",
          {},
          "",
          [
            2060,
            11
          ],
          [
            2060,
            29
          ]
        ],
        [
          "struct sll_header",
          {},
          "",
          [
            2072,
            3
          ],
          [
            2072,
            20
          ]
        ],
        [
          "struct sll_header",
          {},
          "",
          [
            2076,
            11
          ],
          [
            2076,
            28
          ]
        ],
        [
          "struct tpacket_auxdata",
          {},
          "",
          [
            2096,
            3
          ],
          [
            2096,
            25
          ]
        ],
        [
          "struct vlan_tag",
          {},
          "",
          [
            2098,
            3
          ],
          [
            2098,
            18
          ]
        ],
        [
          "struct tpacket_auxdata",
          {},
          "",
          [
            2100,
            40
          ],
          [
            2100,
            62
          ]
        ],
        [
          "struct tpacket_auxdata",
          {},
          "",
          [
            2110,
            10
          ],
          [
            2110,
            32
          ]
        ],
        [
          "struct vlan_tag",
          {},
          "",
          [
            2135,
            10
          ],
          [
            2135,
            25
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            2280,
            1
          ],
          [
            2280,
            18
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            2330,
            33
          ],
          [
            2330,
            49
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            2332,
            1
          ],
          [
            2332,
            18
          ]
        ],
        [
          "struct tpacket_stats_v3",
          {},
          "",
          [
            2349,
            1
          ],
          [
            2349,
            24
          ]
        ],
        [
          "struct tpacket_stats",
          {},
          "",
          [
            2351,
            1
          ],
          [
            2351,
            21
          ]
        ],
        [
          "struct tpacket_stats",
          {},
          "",
          [
            2353,
            25
          ],
          [
            2353,
            45
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            2479,
            1
          ],
          [
            2479,
            13
          ]
        ],
        [
          "struct dirent",
          {},
          "",
          [
            2565,
            1
          ],
          [
            2565,
            14
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            2567,
            1
          ],
          [
            2567,
            12
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            2781,
            1
          ],
          [
            2781,
            13
          ]
        ],
        [
          "struct ethtool_value",
          {},
          "",
          [
            2782,
            1
          ],
          [
            2782,
            21
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            2992,
            44
          ],
          [
            2992,
            62
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            2995,
            1
          ],
          [
            2995,
            18
          ]
        ],
        [
          "struct sock_fprog",
          {},
          "",
          [
            2997,
            1
          ],
          [
            2997,
            18
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            3164,
            37
          ],
          [
            3164,
            55
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            3178,
            1
          ],
          [
            3178,
            18
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            3202,
            1
          ],
          [
            3202,
            12
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            3760,
            1
          ],
          [
            3760,
            18
          ]
        ],
        [
          "struct packet_mreq",
          {},
          "",
          [
            3767,
            1
          ],
          [
            3767,
            19
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            4132,
            1
          ],
          [
            4132,
            18
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            4223,
            1
          ],
          [
            4223,
            18
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            4308,
            1
          ],
          [
            4308,
            18
          ]
        ],
        [
          "struct tpacket_hdr",
          {},
          "",
          [
            4370,
            29
          ],
          [
            4370,
            47
          ]
        ],
        [
          "struct utsname",
          {},
          "",
          [
            4385,
            2
          ],
          [
            4385,
            16
          ]
        ],
        [
          "struct tpacket_hdr_64",
          {},
          "",
          [
            4405,
            31
          ],
          [
            4405,
            52
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            4430,
            1
          ],
          [
            4430,
            18
          ]
        ],
        [
          "struct tpacket_req3",
          {},
          "",
          [
            4438,
            1
          ],
          [
            4438,
            20
          ]
        ],
        [
          "struct tpacket_req",
          {},
          "",
          [
            4440,
            1
          ],
          [
            4440,
            19
          ]
        ],
        [
          "struct sockaddr_ll",
          {},
          "",
          [
            4624,
            57
          ],
          [
            4624,
            75
          ]
        ],
        [
          "struct hwtstamp_config",
          {},
          "",
          [
            4709,
            2
          ],
          [
            4709,
            24
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            4710,
            2
          ],
          [
            4710,
            14
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            4888,
            1
          ],
          [
            4888,
            18
          ]
        ],
        [
          "struct tpacket_req",
          {},
          "",
          [
            4891,
            1
          ],
          [
            4891,
            19
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            4923,
            38
          ],
          [
            4923,
            56
          ]
        ],
        [
          "struct oneshot_userdata",
          {},
          "",
          [
            4926,
            1
          ],
          [
            4926,
            24
          ]
        ],
        [
          "struct oneshot_userdata",
          {},
          "",
          [
            4926,
            32
          ],
          [
            4926,
            55
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            4928,
            1
          ],
          [
            4928,
            18
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            4938,
            1
          ],
          [
            4938,
            18
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            4952,
            1
          ],
          [
            4952,
            18
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            4961,
            1
          ],
          [
            4961,
            18
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            4998,
            1
          ],
          [
            4998,
            18
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            5041,
            1
          ],
          [
            5041,
            18
          ]
        ],
        [
          "struct pollfd",
          {},
          "",
          [
            5045,
            1
          ],
          [
            5045,
            14
          ]
        ],
        [
          "struct pollfd",
          {},
          "",
          [
            5049,
            1
          ],
          [
            5049,
            14
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            5155,
            1
          ],
          [
            5155,
            18
          ]
        ],
        [
          "struct sockaddr_ll",
          {},
          "",
          [
            5157,
            1
          ],
          [
            5157,
            19
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            5158,
            1
          ],
          [
            5158,
            19
          ]
        ],
        [
          "struct utsname",
          {},
          "",
          [
            5160,
            1
          ],
          [
            5160,
            15
          ]
        ],
        [
          "struct sll2_header",
          {},
          "",
          [
            5199,
            3
          ],
          [
            5199,
            21
          ]
        ],
        [
          "struct sockaddr_ll",
          {},
          "",
          [
            5219,
            15
          ],
          [
            5219,
            33
          ]
        ],
        [
          "struct sll2_header",
          {},
          "",
          [
            5228,
            11
          ],
          [
            5228,
            29
          ]
        ],
        [
          "struct sll2_header",
          {},
          "",
          [
            5237,
            21
          ],
          [
            5237,
            39
          ]
        ],
        [
          "struct sll_header",
          {},
          "",
          [
            5239,
            3
          ],
          [
            5239,
            20
          ]
        ],
        [
          "struct sockaddr_ll",
          {},
          "",
          [
            5259,
            15
          ],
          [
            5259,
            33
          ]
        ],
        [
          "struct sll_header",
          {},
          "",
          [
            5268,
            11
          ],
          [
            5268,
            28
          ]
        ],
        [
          "struct sll_header",
          {},
          "",
          [
            5275,
            21
          ],
          [
            5275,
            38
          ]
        ],
        [
          "struct bpf_aux_data",
          {},
          "",
          [
            5280,
            2
          ],
          [
            5280,
            21
          ]
        ],
        [
          "struct vlan_tag",
          {},
          "",
          [
            5319,
            2
          ],
          [
            5319,
            17
          ]
        ],
        [
          "struct vlan_tag",
          {},
          "",
          [
            5332,
            9
          ],
          [
            5332,
            24
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            5366,
            1
          ],
          [
            5366,
            18
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            5450,
            1
          ],
          [
            5450,
            18
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            5535,
            1
          ],
          [
            5535,
            18
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            5621,
            1
          ],
          [
            5621,
            18
          ]
        ],
        [
          "struct tpacket3_hdr",
          {},
          "",
          [
            5677,
            3
          ],
          [
            5677,
            22
          ]
        ],
        [
          "struct tpacket3_hdr",
          {},
          "",
          [
            5677,
            35
          ],
          [
            5677,
            54
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            5744,
            42
          ],
          [
            5744,
            60
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            5746,
            1
          ],
          [
            5746,
            18
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            5827,
            1
          ],
          [
            5827,
            13
          ]
        ],
        [
          "struct sockaddr_ll",
          {},
          "",
          [
            5848,
            1
          ],
          [
            5848,
            19
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            5857,
            15
          ],
          [
            5857,
            30
          ]
        ],
        [
          "struct iwreq",
          {},
          "",
          [
            5912,
            1
          ],
          [
            5912,
            13
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            6021,
            1
          ],
          [
            6021,
            18
          ]
        ],
        [
          "struct iwreq",
          {},
          "",
          [
            6023,
            1
          ],
          [
            6023,
            13
          ]
        ],
        [
          "struct iw_priv_args",
          {},
          "",
          [
            6024,
            1
          ],
          [
            6024,
            20
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            6028,
            1
          ],
          [
            6028,
            13
          ]
        ],
        [
          "struct iw_priv_args",
          {},
          "",
          [
            6084,
            45
          ],
          [
            6084,
            64
          ]
        ],
        [
          "struct {\n\tint soft_timestamping_val;\n\tint pcap_tstamp_val;\n}",
          {
            "soft_timestamping_val": "int",
            "pcap_tstamp_val": "int"
          },
          "",
          [
            6611,
            13
          ],
          [
            6614,
            1
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            6643,
            1
          ],
          [
            6643,
            13
          ]
        ],
        [
          "struct ethtool_ts_info",
          {},
          "",
          [
            6644,
            1
          ],
          [
            6644,
            23
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            6803,
            1
          ],
          [
            6803,
            13
          ]
        ],
        [
          "struct ethtool_value",
          {},
          "",
          [
            6804,
            1
          ],
          [
            6804,
            21
          ]
        ],
        [
          "struct dsa_proto {\n\tconst char *name;\n\tbpf_u_int32 linktype;\n}",
          {
            "char": "const",
            "linktype": "bpf_u_int32"
          },
          "dsa_proto",
          [
            6924,
            7
          ],
          [
            6927,
            1
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            7013,
            1
          ],
          [
            7013,
            18
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            7016,
            1
          ],
          [
            7016,
            13
          ]
        ],
        [
          "struct utsname",
          {},
          "",
          [
            7018,
            1
          ],
          [
            7018,
            15
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            7234,
            1
          ],
          [
            7234,
            16
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            7272,
            1
          ],
          [
            7272,
            13
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            7295,
            1
          ],
          [
            7295,
            13
          ]
        ],
        [
          "struct sock_fprog",
          {},
          "",
          [
            7319,
            28
          ],
          [
            7319,
            45
          ]
        ],
        [
          "struct pcap_linux",
          {},
          "",
          [
            7321,
            1
          ],
          [
            7321,
            18
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            7324,
            10
          ],
          [
            7324,
            25
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            7325,
            1
          ],
          [
            7325,
            16
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            7334,
            6
          ],
          [
            7334,
            21
          ]
        ],
        [
          "struct sock_filter",
          {},
          "",
          [
            7342,
            18
          ],
          [
            7342,
            36
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            7421,
            27
          ],
          [
            7421,
            42
          ]
        ],
        [
          "struct sock_fprog",
          {},
          "",
          [
            7492,
            34
          ],
          [
            7492,
            51
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            115,
            0
          ],
          [
            116,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            118,
            0
          ],
          [
            119,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            119,
            0
          ],
          [
            120,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            120,
            0
          ],
          [
            121,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            121,
            0
          ],
          [
            122,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            122,
            0
          ],
          [
            123,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            123,
            0
          ],
          [
            124,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            124,
            0
          ],
          [
            125,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            125,
            0
          ],
          [
            126,
            0
          ]
        ],
        [
          "#include <sys/stat.h>\n",
          [
            126,
            0
          ],
          [
            127,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            127,
            0
          ],
          [
            128,
            0
          ]
        ],
        [
          "#include <sys/ioctl.h>\n",
          [
            128,
            0
          ],
          [
            129,
            0
          ]
        ],
        [
          "#include <sys/utsname.h>\n",
          [
            129,
            0
          ],
          [
            130,
            0
          ]
        ],
        [
          "#include <sys/mman.h>\n",
          [
            130,
            0
          ],
          [
            131,
            0
          ]
        ],
        [
          "#include <linux/if.h>\n",
          [
            131,
            0
          ],
          [
            132,
            0
          ]
        ],
        [
          "#include <linux/if_packet.h>\n",
          [
            132,
            0
          ],
          [
            133,
            0
          ]
        ],
        [
          "#include <linux/sockios.h>\n",
          [
            133,
            0
          ],
          [
            134,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            134,
            0
          ],
          [
            135,
            0
          ]
        ],
        [
          "#include <linux/if_ether.h>\n",
          [
            135,
            0
          ],
          [
            136,
            0
          ]
        ],
        [
          "#include <net/if_arp.h>\n",
          [
            136,
            0
          ],
          [
            137,
            0
          ]
        ],
        [
          "#include <poll.h>\n",
          [
            137,
            0
          ],
          [
            138,
            0
          ]
        ],
        [
          "#include <dirent.h>\n",
          [
            138,
            0
          ],
          [
            139,
            0
          ]
        ],
        [
          "#include <sys/eventfd.h>\n",
          [
            140,
            0
          ],
          [
            141,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            143,
            0
          ],
          [
            144,
            0
          ]
        ],
        [
          "#include \"pcap/sll.h\"\n",
          [
            144,
            0
          ],
          [
            145,
            0
          ]
        ],
        [
          "#include \"pcap/vlan.h\"\n",
          [
            145,
            0
          ],
          [
            146,
            0
          ]
        ],
        [
          "#include \"diag-control.h\"\n",
          [
            147,
            0
          ],
          [
            148,
            0
          ]
        ],
        [
          "# include <linux/if_packet.h>\n",
          [
            175,
            0
          ],
          [
            176,
            0
          ]
        ],
        [
          "#include <linux/types.h>\n",
          [
            214,
            0
          ],
          [
            215,
            0
          ]
        ],
        [
          "#include <linux/filter.h>\n",
          [
            215,
            0
          ],
          [
            216,
            0
          ]
        ],
        [
          "#include <linux/net_tstamp.h>\n",
          [
            219,
            0
          ],
          [
            220,
            0
          ]
        ],
        [
          "#include <linux/sockios.h>\n",
          [
            223,
            0
          ],
          [
            224,
            0
          ]
        ],
        [
          "#include <linux/if_bonding.h>\n",
          [
            227,
            0
          ],
          [
            228,
            0
          ]
        ],
        [
          "#include <linux/wireless.h>\n",
          [
            243,
            0
          ],
          [
            244,
            0
          ]
        ],
        [
          "#include <linux/nl80211.h>\n",
          [
            250,
            0
          ],
          [
            251,
            0
          ]
        ],
        [
          "#include <netlink/genl/genl.h>\n",
          [
            252,
            0
          ],
          [
            253,
            0
          ]
        ],
        [
          "#include <netlink/genl/family.h>\n",
          [
            253,
            0
          ],
          [
            254,
            0
          ]
        ],
        [
          "#include <netlink/genl/ctrl.h>\n",
          [
            254,
            0
          ],
          [
            255,
            0
          ]
        ],
        [
          "#include <netlink/msg.h>\n",
          [
            255,
            0
          ],
          [
            256,
            0
          ]
        ],
        [
          "#include <netlink/attr.h>\n",
          [
            256,
            0
          ],
          [
            257,
            0
          ]
        ],
        [
          "#include <linux/ethtool.h>\n",
          [
            263,
            0
          ],
          [
            264,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n\tMONITOR_WEXT,\n\tMONITOR_HOSTAP,\n\tMONITOR_PRISM,\n\tMONITOR_PRISM54,\n\tMONITOR_ACX100,\n\tMONITOR_RT2500,\n\tMONITOR_RT2570,\n\tMONITOR_RT73,\n\tMONITOR_RTL8XXX\n} monitor_type;",
          {
            "MONITOR_WEXT": "",
            "MONITOR_HOSTAP": "",
            "MONITOR_PRISM": "",
            "MONITOR_PRISM54": "",
            "MONITOR_ACX100": "",
            "MONITOR_RT2500": "",
            "MONITOR_RT2570": "",
            "MONITOR_RT73": "",
            "MONITOR_RTL8XXX": ""
          },
          "monitor_type",
          [
            5940,
            0
          ],
          [
            5950,
            15
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-bt-linux.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nbt_findalldevs(pcap_if_list_t *devlistp, char *err_str)\n{\n\tstruct hci_dev_list_req *dev_list;\n\tstruct hci_dev_req *dev_req;\n\tint sock;\n\tunsigned i;\n\tint ret = 0;\n\n\tsock  = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);\n\tif (sock < 0)\n\t{\n\t\t/* if bluetooth is not supported this is not fatal*/\n\t\tif (errno == EAFNOSUPPORT)\n\t\t\treturn 0;\n\t\tpcap_fmt_errmsg_for_errno(err_str, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't open raw Bluetooth socket\");\n\t\treturn -1;\n\t}\n\n\tdev_list = malloc(HCI_MAX_DEV * sizeof(*dev_req) + sizeof(*dev_list));\n\tif (!dev_list)\n\t{\n\t\tpcap_snprintf(err_str, PCAP_ERRBUF_SIZE, \"Can't allocate %zu bytes for Bluetooth device list\",\n\t\t\tHCI_MAX_DEV * sizeof(*dev_req) + sizeof(*dev_list));\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\tdev_list->dev_num = HCI_MAX_DEV;\n\n\tif (ioctl(sock, HCIGETDEVLIST, (void *) dev_list) < 0)\n\t{\n\t\tpcap_fmt_errmsg_for_errno(err_str, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't get Bluetooth device list via ioctl\");\n\t\tret = -1;\n\t\tgoto free;\n\t}\n\n\tdev_req = dev_list->dev_req;\n\tfor (i = 0; i < dev_list->dev_num; i++, dev_req++) {\n\t\tchar dev_name[20], dev_descr[40];\n\n\t\tpcap_snprintf(dev_name, sizeof(dev_name), BT_IFACE\"%u\", dev_req->dev_id);\n\t\tpcap_snprintf(dev_descr, sizeof(dev_descr), \"Bluetooth adapter number %u\", i);\n\n\t\t/*\n\t\t * Bluetooth is a wireless technology.\n\t\t * XXX - if there's the notion of associating with a\n\t\t * network, and we can determine whether the interface\n\t\t * is associated with a network, check that and set\n\t\t * the status to PCAP_IF_CONNECTION_STATUS_CONNECTED\n\t\t * or PCAP_IF_CONNECTION_STATUS_DISCONNECTED.\n\t\t */\n\t\tif (add_dev(devlistp, dev_name, PCAP_IF_WIRELESS, dev_descr, err_str)  == NULL)\n\t\t{\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\nfree:\n\tfree(dev_list);\n\ndone:\n\tclose(sock);\n\treturn ret;\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "err_str": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\nbt_create(const char *device, char *ebuf, int *is_ours)\n{\n\tconst char *cp;\n\tchar *cpend;\n\tlong devnum;\n\tpcap_t *p;\n\n\t/* Does this look like a Bluetooth device? */\n\tcp = strrchr(device, '/');\n\tif (cp == NULL)\n\t\tcp = device;\n\t/* Does it begin with BT_IFACE? */\n\tif (strncmp(cp, BT_IFACE, sizeof BT_IFACE - 1) != 0) {\n\t\t/* Nope, doesn't begin with BT_IFACE */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\t/* Yes - is BT_IFACE followed by a number? */\n\tcp += sizeof BT_IFACE - 1;\n\tdevnum = strtol(cp, &cpend, 10);\n\tif (cpend == cp || *cpend != '\\0') {\n\t\t/* Not followed by a number. */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\tif (devnum < 0) {\n\t\t/* Followed by a non-valid number. */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\t/* OK, it's probably ours. */\n\t*is_ours = 1;\n\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_bt));\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = bt_activate;\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              140,
              0
            ],
            [
              181,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static int\nbt_activate(pcap_t* handle)\n{\n\tstruct pcap_bt *handlep = handle->priv;\n\tstruct sockaddr_hci addr;\n\tint opt;\n\tint\t\tdev_id;\n\tstruct hci_filter\tflt;\n\tint err = PCAP_ERROR;\n\n\t/* get bt interface id */\n\tif (sscanf(handle->opt.device, BT_IFACE\"%d\", &dev_id) != 1)\n\t{\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\"Can't get Bluetooth device index from %s\",\n\t\t\t handle->opt.device);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)\n\t\thandle->snapshot = MAXIMUM_SNAPLEN;\n\n\t/* Initialize some components of the pcap structure. */\n\thandle->bufsize = BT_CTRL_SIZE+sizeof(pcap_bluetooth_h4_header)+handle->snapshot;\n\thandle->linktype = DLT_BLUETOOTH_HCI_H4_WITH_PHDR;\n\n\thandle->read_op = bt_read_linux;\n\thandle->inject_op = bt_inject_linux;\n\thandle->setfilter_op = install_bpf_program; /* no kernel filtering */\n\thandle->setdirection_op = bt_setdirection_linux;\n\thandle->set_datalink_op = NULL;\t/* can't change data link type */\n\thandle->getnonblock_op = pcap_getnonblock_fd;\n\thandle->setnonblock_op = pcap_setnonblock_fd;\n\thandle->stats_op = bt_stats_linux;\n\thandlep->dev_id = dev_id;\n\n\t/* Create HCI socket */\n\thandle->fd = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);\n\tif (handle->fd < 0) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't create raw socket\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\thandle->buffer = malloc(handle->bufsize);\n\tif (!handle->buffer) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't allocate dump buffer\");\n\t\tgoto close_fail;\n\t}\n\n\topt = 1;\n\tif (setsockopt(handle->fd, SOL_HCI, HCI_DATA_DIR, &opt, sizeof(opt)) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't enable data direction info\");\n\t\tgoto close_fail;\n\t}\n\n\topt = 1;\n\tif (setsockopt(handle->fd, SOL_HCI, HCI_TIME_STAMP, &opt, sizeof(opt)) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't enable time stamp\");\n\t\tgoto close_fail;\n\t}\n\n\t/* Setup filter, do not call hci function to avoid dependence on\n\t * external libs\t*/\n\tmemset(&flt, 0, sizeof(flt));\n\tmemset((void *) &flt.type_mask, 0xff, sizeof(flt.type_mask));\n\tmemset((void *) &flt.event_mask, 0xff, sizeof(flt.event_mask));\n\tif (setsockopt(handle->fd, SOL_HCI, HCI_FILTER, &flt, sizeof(flt)) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't set filter\");\n\t\tgoto close_fail;\n\t}\n\n\n\t/* Bind socket to the HCI device */\n\taddr.hci_family = AF_BLUETOOTH;\n\taddr.hci_dev = handlep->dev_id;\n#ifdef HAVE_STRUCT_SOCKADDR_HCI_HCI_CHANNEL\n\taddr.hci_channel = HCI_CHANNEL_RAW;\n#endif\n\tif (bind(handle->fd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't attach to device %d\", handlep->dev_id);\n\t\tgoto close_fail;\n\t}\n\n\tif (handle->opt.rfmon) {\n\t\t/*\n\t\t * Monitor mode doesn't apply to Bluetooth devices.\n\t\t */\n\t\terr = PCAP_ERROR_RFMON_NOTSUP;\n\t\tgoto close_fail;\n\t}\n\n\tif (handle->opt.buffer_size != 0) {\n\t\t/*\n\t\t * Set the socket buffer size to the specified value.\n\t\t */\n\t\tif (setsockopt(handle->fd, SOL_SOCKET, SO_RCVBUF,\n\t\t    &handle->opt.buffer_size,\n\t\t    sizeof(handle->opt.buffer_size)) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    errno, PCAP_ERRBUF_SIZE, \"SO_RCVBUF\");\n\t\t\tgoto close_fail;\n\t\t}\n\t}\n\n\thandle->selectable_fd = handle->fd;\n\treturn 0;\n\nclose_fail:\n\tpcap_cleanup_live_common(handle);\n\treturn err;\n}",
          "fn_code_pos": [
            [
              183,
              0
            ],
            [
              307,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_activate",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nbt_read_linux(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char *user)\n{\n\tstruct cmsghdr *cmsg;\n\tstruct msghdr msg;\n\tstruct iovec  iv;\n\tssize_t ret;\n\tstruct pcap_pkthdr pkth;\n\tpcap_bluetooth_h4_header* bthdr;\n\tu_char *pktd;\n\tint in = 0;\n\n\tpktd = (u_char *)handle->buffer + BT_CTRL_SIZE;\n\tbthdr = (pcap_bluetooth_h4_header*)(void *)pktd;\n\tiv.iov_base = pktd + sizeof(pcap_bluetooth_h4_header);\n\tiv.iov_len  = handle->snapshot;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.msg_iov = &iv;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = handle->buffer;\n\tmsg.msg_controllen = BT_CTRL_SIZE;\n\n\t/* ignore interrupt system call error */\n\tdo {\n\t\tret = recvmsg(handle->fd, &msg, 0);\n\t\tif (handle->break_loop)\n\t\t{\n\t\t\thandle->break_loop = 0;\n\t\t\treturn -2;\n\t\t}\n\t} while ((ret == -1) && (errno == EINTR));\n\n\tif (ret < 0) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't receive packet\");\n\t\treturn -1;\n\t}\n\n\tpkth.caplen = (bpf_u_int32)ret;\n\n\t/* get direction and timestamp*/\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\twhile (cmsg) {\n\t\tswitch (cmsg->cmsg_type) {\n\t\t\tcase HCI_CMSG_DIR:\n\t\t\t\tmemcpy(&in, CMSG_DATA(cmsg), sizeof in);\n\t\t\t\tbreak;\n                      \tcase HCI_CMSG_TSTAMP:\n                      \t\tmemcpy(&pkth.ts, CMSG_DATA(cmsg),\n                      \t\t    sizeof pkth.ts);\n\t\t\t\tbreak;\n\t\t}\n\t\tcmsg = CMSG_NXTHDR(&msg, cmsg);\n\t}\n\tif ((in && (handle->direction == PCAP_D_OUT)) ||\n\t\t\t\t((!in) && (handle->direction == PCAP_D_IN)))\n\t\treturn 0;\n\n\tbthdr->direction = htonl(in != 0);\n\tpkth.caplen+=sizeof(pcap_bluetooth_h4_header);\n\tpkth.len = pkth.caplen;\n\tif (handle->fcode.bf_insns == NULL ||\n\t    pcap_filter(handle->fcode.bf_insns, pktd, pkth.len, pkth.caplen)) {\n\t\tcallback(user, &pkth, pktd);\n\t\treturn 1;\n\t}\n\treturn 0;\t/* didn't pass filter */\n}",
          "fn_code_pos": [
            [
              309,
              0
            ],
            [
              377,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_read_linux",
            "parameters": {
              "handle": "pcap_t",
              "max_packets": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nbt_inject_linux(pcap_t *handle, const void *buf _U_, int size _U_)\n{\n\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Packet injection is not supported on Bluetooth devices\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              379,
              0
            ],
            [
              385,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_inject_linux",
            "parameters": {
              "handle": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nbt_stats_linux(pcap_t *handle, struct pcap_stat *stats)\n{\n\tstruct pcap_bt *handlep = handle->priv;\n\tint ret;\n\tstruct hci_dev_info dev_info;\n\tstruct hci_dev_stats * s = &dev_info.stat;\n\tdev_info.dev_id = handlep->dev_id;\n\n\t/* ignore eintr */\n\tdo {\n\t\tret = ioctl(handle->fd, HCIGETDEVINFO, (void *)&dev_info);\n\t} while ((ret == -1) && (errno == EINTR));\n\n\tif (ret < 0) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't get stats via ioctl\");\n\t\treturn (-1);\n\n\t}\n\n\t/* we receive both rx and tx frames, so comulate all stats */\n\tstats->ps_recv = s->evt_rx + s->acl_rx + s->sco_rx + s->cmd_tx +\n\t\ts->acl_tx +s->sco_tx;\n\tstats->ps_drop = s->err_rx + s->err_tx;\n\tstats->ps_ifdrop = 0;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              388,
              0
            ],
            [
              415,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_stats_linux",
            "parameters": {
              "handle": "pcap_t",
              "stats": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nbt_setdirection_linux(pcap_t *p, pcap_direction_t d)\n{\n\tp->direction = d;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              417,
              0
            ],
            [
              422,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_setdirection_linux",
            "parameters": {
              "p": "pcap_t",
              "d": "pcap_direction_t"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "bt_activate(pcap_t *)",
          "fn_dec_pos": [
            [
              58,
              11
            ],
            [
              58,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_activate",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "bt_read_linux(pcap_t *, int , pcap_handler , u_char *)",
          "fn_dec_pos": [
            [
              59,
              11
            ],
            [
              59,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_read_linux",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "bt_inject_linux(pcap_t *, const void *, int)",
          "fn_dec_pos": [
            [
              60,
              11
            ],
            [
              60,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_inject_linux",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "bt_setdirection_linux(pcap_t *, pcap_direction_t)",
          "fn_dec_pos": [
            [
              61,
              11
            ],
            [
              61,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_setdirection_linux",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "bt_stats_linux(pcap_t *, struct pcap_stat *)",
          "fn_dec_pos": [
            [
              62,
              11
            ],
            [
              62,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_stats_linux",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "bt_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              141,
              0
            ],
            [
              141,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_bt {\n\tint dev_id;\t\t/* device ID of device we're bound to */\n}",
          {
            "dev_id": "int"
          },
          "pcap_bt",
          [
            67,
            0
          ],
          [
            69,
            1
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            62,
            36
          ],
          [
            62,
            52
          ]
        ],
        [
          "struct pcap_bt {\n\tint dev_id;\t\t/* device ID of device we're bound to */\n}",
          {
            "dev_id": "int"
          },
          "pcap_bt",
          [
            67,
            0
          ],
          [
            69,
            1
          ]
        ],
        [
          "struct hci_dev_list_req",
          {},
          "",
          [
            74,
            1
          ],
          [
            74,
            24
          ]
        ],
        [
          "struct hci_dev_req",
          {},
          "",
          [
            75,
            1
          ],
          [
            75,
            19
          ]
        ],
        [
          "struct pcap_bt",
          {},
          "",
          [
            175,
            38
          ],
          [
            175,
            52
          ]
        ],
        [
          "struct pcap_bt",
          {},
          "",
          [
            186,
            1
          ],
          [
            186,
            15
          ]
        ],
        [
          "struct sockaddr_hci",
          {},
          "",
          [
            187,
            1
          ],
          [
            187,
            20
          ]
        ],
        [
          "struct hci_filter",
          {},
          "",
          [
            190,
            1
          ],
          [
            190,
            18
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            274,
            23
          ],
          [
            274,
            38
          ]
        ],
        [
          "struct cmsghdr",
          {},
          "",
          [
            312,
            1
          ],
          [
            312,
            15
          ]
        ],
        [
          "struct msghdr",
          {},
          "",
          [
            313,
            1
          ],
          [
            313,
            14
          ]
        ],
        [
          "struct iovec",
          {},
          "",
          [
            314,
            1
          ],
          [
            314,
            13
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            316,
            1
          ],
          [
            316,
            19
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            389,
            31
          ],
          [
            389,
            47
          ]
        ],
        [
          "struct pcap_bt",
          {},
          "",
          [
            391,
            1
          ],
          [
            391,
            15
          ]
        ],
        [
          "struct hci_dev_info",
          {},
          "",
          [
            393,
            1
          ],
          [
            393,
            20
          ]
        ],
        [
          "struct hci_dev_stats",
          {},
          "",
          [
            394,
            1
          ],
          [
            394,
            21
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include \"pcap-bt-linux.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include \"pcap/bluetooth.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <sys/ioctl.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <arpa/inet.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <bluetooth/bluetooth.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include <bluetooth/hci.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/sockutils.c": {
      "fn_def_list": [
        {
          "fn_code": "void sock_fmterror(const char *caller, int errcode, char *errbuf, int errbuflen)\n{\n#ifdef _WIN32\n\tchar message[SOCK_ERRBUF_SIZE];\t/* We're forcing \"ANSI\" */\n\n\tif (errbuf == NULL)\n\t\treturn;\n\n\tpcap_win32_err_to_str(errcode, message);\n\tif ((caller) && (*caller))\n\t\tpcap_snprintf(errbuf, errbuflen, \"%s%s\", caller, message);\n\telse\n\t\tpcap_snprintf(errbuf, errbuflen, \"%s\", message);\n#else\n\tchar *message;\n\n\tif (errbuf == NULL)\n\t\treturn;\n\n\tmessage = strerror(errcode);\n\n\tif ((caller) && (*caller))\n\t\tpcap_snprintf(errbuf, errbuflen, \"%s%s (%d)\", caller, message, errcode);\n\telse\n\t\tpcap_snprintf(errbuf, errbuflen, \"%s (%d)\", message, errcode);\n#endif\n}",
          "fn_code_pos": [
            [
              126,
              0
            ],
            [
              152,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_fmterror",
            "parameters": {
              "caller": "char",
              "errcode": "int",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void sock_geterror(const char *caller, char *errbuf, int errbuflen)\n{\n#ifdef _WIN32\n\tif (errbuf == NULL)\n\t\treturn;\n\tsock_fmterror(caller, GetLastError(), errbuf, errbuflen);\n#else\n\tif (errbuf == NULL)\n\t\treturn;\n\tsock_fmterror(caller, errno, errbuf, errbuflen);\n#endif\n}",
          "fn_code_pos": [
            [
              174,
              0
            ],
            [
              185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_geterror",
            "parameters": {
              "caller": "char",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int sock_init(char *errbuf, int errbuflen)\n{\n\tif (sockcount == 0)\n\t{\n\t\tWSADATA wsaData;\t\t\t/* helper variable needed to initialize Winsock */\n\n\t\tif (WSAStartup(MAKEWORD(WINSOCK_MAJOR_VERSION,\n\t\t    WINSOCK_MINOR_VERSION), &wsaData) != 0)\n\t\t{\n\t\t\tif (errbuf)\n\t\t\t\tpcap_snprintf(errbuf, errbuflen, \"Failed to initialize Winsock\\n\");\n\n\t\t\tWSACleanup();\n\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tsockcount++;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              207,
              0
            ],
            [
              227,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_init",
            "parameters": {
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int sock_init(char *errbuf _U_, int errbuflen _U_)\n{\n\t/*\n\t * Nothing to do on UN*Xes.\n\t */\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              229,
              0
            ],
            [
              235,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_init",
            "parameters": {
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void sock_cleanup(void)\n{\n#ifdef _WIN32\n\tsockcount--;\n\n\tif (sockcount == 0)\n\t\tWSACleanup();\n#endif\n}",
          "fn_code_pos": [
            [
              247,
              0
            ],
            [
              255,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_cleanup",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int sock_ismcastaddr(const struct sockaddr *saddr)\n{\n\tif (saddr->sa_family == PF_INET)\n\t{\n\t\tstruct sockaddr_in *saddr4 = (struct sockaddr_in *) saddr;\n\t\tif (IN_MULTICAST(ntohl(saddr4->sin_addr.s_addr))) return 0;\n\t\telse return -1;\n\t}\n\telse\n\t{\n\t\tstruct sockaddr_in6 *saddr6 = (struct sockaddr_in6 *) saddr;\n\t\tif (IN6_IS_ADDR_MULTICAST(&saddr6->sin6_addr)) return 0;\n\t\telse return -1;\n\t}\n}",
          "fn_code_pos": [
            [
              262,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_ismcastaddr",
            "parameters": {
              "saddr": "struct sockaddr"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "SOCKET sock_open(struct addrinfo *addrinfo, int server, int nconn, char *errbuf, int errbuflen)\n{\n\tSOCKET sock;\n#if defined(SO_NOSIGPIPE) || defined(IPV6_V6ONLY) || defined(IPV6_BINDV6ONLY)\n\tint on = 1;\n#endif\n\n\tsock = socket(addrinfo->ai_family, addrinfo->ai_socktype, addrinfo->ai_protocol);\n\tif (sock == INVALID_SOCKET)\n\t{\n\t\tsock_geterror(\"socket(): \", errbuf, errbuflen);\n\t\treturn INVALID_SOCKET;\n\t}\n\n\t/*\n\t * Disable SIGPIPE, if we have SO_NOSIGPIPE.  We don't want to\n\t * have to deal with signals if the peer closes the connection,\n\t * especially in client programs, which may not even be aware that\n\t * they're sending to sockets.\n\t */\n#ifdef SO_NOSIGPIPE\n\tif (setsockopt(sock, SOL_SOCKET, SO_NOSIGPIPE, (char *)&on,\n\t    sizeof (int)) == -1)\n\t{\n\t\tsock_geterror(\"setsockopt(SO_NOSIGPIPE)\", errbuf, errbuflen);\n\t\tclosesocket(sock);\n\t\treturn INVALID_SOCKET;\n\t}\n#endif\n\n\t/* This is a server socket */\n\tif (server)\n\t{\n#if defined(IPV6_V6ONLY) || defined(IPV6_BINDV6ONLY)\n\t\t/*\n\t\t * Force the use of IPv6-only addresses.\n\t\t *\n\t\t * RFC 3493 indicates that you can support IPv4 on an\n\t\t * IPv6 socket:\n\t\t *\n\t\t *    https://tools.ietf.org/html/rfc3493#section-3.7\n\t\t *\n\t\t * and that this is the default behavior.  This means\n\t\t * that if we first create an IPv6 socket bound to the\n\t\t * \"any\" address, it is, in effect, also bound to the\n\t\t * IPv4 \"any\" address, so when we create an IPv4 socket\n\t\t * and try to bind it to the IPv4 \"any\" address, it gets\n\t\t * EADDRINUSE.\n\t\t *\n\t\t * Not all network stacks support IPv4 on IPv6 sockets;\n\t\t * pre-NT 6 Windows stacks don't support it, and the\n\t\t * OpenBSD stack doesn't support it for security reasons\n\t\t * (see the OpenBSD inet6(4) man page).  Therefore, we\n\t\t * don't want to rely on this behavior.\n\t\t *\n\t\t * So we try to disable it, using either the IPV6_V6ONLY\n\t\t * option from RFC 3493:\n\t\t *\n\t\t *    https://tools.ietf.org/html/rfc3493#section-5.3\n\t\t *\n\t\t * or the IPV6_BINDV6ONLY option from older UN*Xes.\n\t\t */\n#ifndef IPV6_V6ONLY\n  /* For older systems */\n  #define IPV6_V6ONLY IPV6_BINDV6ONLY\n#endif /* IPV6_V6ONLY */\n\t\tif (addrinfo->ai_family == PF_INET6)\n\t\t{\n\t\t\tif (setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY,\n\t\t\t    (char *)&on, sizeof (int)) == -1)\n\t\t\t{\n\t\t\t\tif (errbuf)\n\t\t\t\t\tpcap_snprintf(errbuf, errbuflen, \"setsockopt(IPV6_V6ONLY)\");\n\t\t\t\tclosesocket(sock);\n\t\t\t\treturn INVALID_SOCKET;\n\t\t\t}\n\t\t}\n#endif /* defined(IPV6_V6ONLY) || defined(IPV6_BINDV6ONLY) */\n\n\t\t/* WARNING: if the address is a mcast one, I should place the proper Win32 code here */\n\t\tif (bind(sock, addrinfo->ai_addr, (int) addrinfo->ai_addrlen) != 0)\n\t\t{\n\t\t\tsock_geterror(\"bind(): \", errbuf, errbuflen);\n\t\t\tclosesocket(sock);\n\t\t\treturn INVALID_SOCKET;\n\t\t}\n\n\t\tif (addrinfo->ai_socktype == SOCK_STREAM)\n\t\t\tif (listen(sock, nconn) == -1)\n\t\t\t{\n\t\t\t\tsock_geterror(\"listen(): \", errbuf, errbuflen);\n\t\t\t\tclosesocket(sock);\n\t\t\t\treturn INVALID_SOCKET;\n\t\t\t}\n\n\t\t/* server side ended */\n\t\treturn sock;\n\t}\n\telse\t/* we're the client */\n\t{\n\t\tstruct addrinfo *tempaddrinfo;\n\t\tchar *errbufptr;\n\t\tsize_t bufspaceleft;\n\n\t\ttempaddrinfo = addrinfo;\n\t\terrbufptr = errbuf;\n\t\tbufspaceleft = errbuflen;\n\t\t*errbufptr = 0;\n\n\t\t/*\n\t\t * We have to loop though all the addinfo returned.\n\t\t * For instance, we can have both IPv6 and IPv4 addresses, but the service we're trying\n\t\t * to connect to is unavailable in IPv6, so we have to try in IPv4 as well\n\t\t */\n\t\twhile (tempaddrinfo)\n\t\t{\n\n\t\t\tif (connect(sock, tempaddrinfo->ai_addr, (int) tempaddrinfo->ai_addrlen) == -1)\n\t\t\t{\n\t\t\t\tsize_t msglen;\n\t\t\t\tchar TmpBuffer[100];\n\t\t\t\tchar SocketErrorMessage[SOCK_ERRBUF_SIZE];\n\n\t\t\t\t/*\n\t\t\t\t * We have to retrieve the error message before any other socket call completes, otherwise\n\t\t\t\t * the error message is lost\n\t\t\t\t */\n\t\t\t\tsock_geterror(NULL, SocketErrorMessage, sizeof(SocketErrorMessage));\n\n\t\t\t\t/* Returns the numeric address of the host that triggered the error */\n\t\t\t\tsock_getascii_addrport((struct sockaddr_storage *) tempaddrinfo->ai_addr, TmpBuffer, sizeof(TmpBuffer), NULL, 0, NI_NUMERICHOST, TmpBuffer, sizeof(TmpBuffer));\n\n\t\t\t\tpcap_snprintf(errbufptr, bufspaceleft,\n\t\t\t\t    \"Is the server properly installed on %s?  connect() failed: %s\", TmpBuffer, SocketErrorMessage);\n\n\t\t\t\t/* In case more then one 'connect' fails, we manage to keep all the error messages */\n\t\t\t\tmsglen = strlen(errbufptr);\n\n\t\t\t\terrbufptr[msglen] = ' ';\n\t\t\t\terrbufptr[msglen + 1] = 0;\n\n\t\t\t\tbufspaceleft = bufspaceleft - (msglen + 1);\n\t\t\t\terrbufptr += (msglen + 1);\n\n\t\t\t\ttempaddrinfo = tempaddrinfo->ai_next;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Check how we exit from the previous loop\n\t\t * If tempaddrinfo is equal to NULL, it means that all the connect() failed.\n\t\t */\n\t\tif (tempaddrinfo == NULL)\n\t\t{\n\t\t\tclosesocket(sock);\n\t\t\treturn INVALID_SOCKET;\n\t\t}\n\t\telse\n\t\t\treturn sock;\n\t}\n}",
          "fn_code_pos": [
            [
              309,
              0
            ],
            [
              471,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_open",
            "parameters": {
              "addrinfo": "struct addrinfo",
              "server": "int",
              "nconn": "int",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "SOCKET"
          }
        },
        {
          "fn_code": "int sock_close(SOCKET sock, char *errbuf, int errbuflen)\n{\n\t/*\n\t * SHUT_WR: subsequent calls to the send function are disallowed.\n\t * For TCP sockets, a FIN will be sent after all data is sent and\n\t * acknowledged by the Server.\n\t */\n\tif (shutdown(sock, SHUT_WR))\n\t{\n\t\tsock_geterror(\"shutdown(): \", errbuf, errbuflen);\n\t\t/* close the socket anyway */\n\t\tclosesocket(sock);\n\t\treturn -1;\n\t}\n\n\tclosesocket(sock);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              491,
              0
            ],
            [
              508,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_close",
            "parameters": {
              "sock": "SOCKET",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nget_gai_errstring(char *errbuf, int errbuflen, const char *prefix, int err,\n    const char *hostname, const char *portname)\n{\n\tchar hostport[PCAP_ERRBUF_SIZE];\n\n\tif (hostname != NULL && portname != NULL)\n\t\tpcap_snprintf(hostport, PCAP_ERRBUF_SIZE, \"%s:%s\",\n\t\t    hostname, portname);\n\telse if (hostname != NULL)\n\t\tpcap_snprintf(hostport, PCAP_ERRBUF_SIZE, \"%s\",\n\t\t    hostname);\n\telse if (portname != NULL)\n\t\tpcap_snprintf(hostport, PCAP_ERRBUF_SIZE, \":%s\",\n\t\t    portname);\n\telse\n\t\tpcap_snprintf(hostport, PCAP_ERRBUF_SIZE, \"<no host or port!>\");\n\tswitch (err)\n\t{\n#ifdef EAI_ADDRFAMILY\n\t\tcase EAI_ADDRFAMILY:\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"%sAddress family for %s not supported\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n#endif\n\n\t\tcase EAI_AGAIN:\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"%s%s could not be resolved at this time\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n\n\t\tcase EAI_BADFLAGS:\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"%sThe ai_flags parameter for looking up %s had an invalid value\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n\n\t\tcase EAI_FAIL:\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"%sA non-recoverable error occurred when attempting to resolve %s\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n\n\t\tcase EAI_FAMILY:\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"%sThe address family for looking up %s was not recognized\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n\n\t\tcase EAI_MEMORY:\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"%sOut of memory trying to allocate storage when looking up %s\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n\n\t\t/*\n\t\t * RFC 2553 had both EAI_NODATA and EAI_NONAME.\n\t\t *\n\t\t * RFC 3493 has only EAI_NONAME.\n\t\t *\n\t\t * Some implementations define EAI_NODATA and EAI_NONAME\n\t\t * to the same value, others don't.  If EAI_NODATA is\n\t\t * defined and isn't the same as EAI_NONAME, we handle\n\t\t * EAI_NODATA.\n\t\t */\n#if defined(EAI_NODATA) && EAI_NODATA != EAI_NONAME\n\t\tcase EAI_NODATA:\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"%sNo address associated with %s\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n#endif\n\n\t\tcase EAI_NONAME:\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"%sThe host name %s couldn't be resolved\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n\n\t\tcase EAI_SERVICE:\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"%sThe service value specified when looking up %s as not recognized for the socket type\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n\n\t\tcase EAI_SOCKTYPE:\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"%sThe socket type specified when looking up %s as not recognized\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n\n#ifdef EAI_SYSTEM\n\t\tcase EAI_SYSTEM:\n\t\t\t/*\n\t\t\t * Assumed to be UN*X.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"%sAn error occurred when looking up %s: %s\",\n\t\t\t    prefix, hostport, pcap_strerror(errno));\n\t\t\tbreak;\n#endif\n\n#ifdef EAI_BADHINTS\n\t\tcase EAI_BADHINTS:\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"%sInvalid value for hints when looking up %s\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n#endif\n\n#ifdef EAI_PROTOCOL\n\t\tcase EAI_PROTOCOL:\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"%sResolved protocol when looking up %s is unknown\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n#endif\n\n#ifdef EAI_OVERFLOW\n\t\tcase EAI_OVERFLOW:\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"%sArgument buffer overflow when looking up %s\",\n\t\t\t    prefix, hostport);\n\t\t\tbreak;\n#endif\n\n\t\tdefault:\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"%sgetaddrinfo() error %d when looking up %s\",\n\t\t\t    prefix, err, hostport);\n\t\t\tbreak;\n\t}\n}",
          "fn_code_pos": [
            [
              525,
              0
            ],
            [
              659,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_gai_errstring",
            "parameters": {
              "errbuf": "char",
              "errbuflen": "int",
              "prefix": "char",
              "err": "int",
              "hostname": "char",
              "portname": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int sock_initaddress(const char *host, const char *port,\n    struct addrinfo *hints, struct addrinfo **addrinfo, char *errbuf, int errbuflen)\n{\n\tint retval;\n\n\tretval = getaddrinfo(host, port, hints, addrinfo);\n\tif (retval != 0)\n\t{\n\t\tif (errbuf)\n\t\t{\n\t\t\tget_gai_errstring(errbuf, errbuflen, \"\", retval,\n\t\t\t    host, port);\n\t\t}\n\t\treturn -1;\n\t}\n\t/*\n\t * \\warning SOCKET: I should check all the accept() in order to bind to all addresses in case\n\t * addrinfo has more han one pointers\n\t */\n\n\t/*\n\t * This software only supports PF_INET and PF_INET6.\n\t *\n\t * XXX - should we just check that at least *one* address is\n\t * either PF_INET or PF_INET6, and, when using the list,\n\t * ignore all addresses that are neither?  (What, no IPX\n\t * support? :-))\n\t */\n\tif (((*addrinfo)->ai_family != PF_INET) &&\n\t    ((*addrinfo)->ai_family != PF_INET6))\n\t{\n\t\tif (errbuf)\n\t\t\tpcap_snprintf(errbuf, errbuflen, \"getaddrinfo(): socket type not supported\");\n\t\tfreeaddrinfo(*addrinfo);\n\t\t*addrinfo = NULL;\n\t\treturn -1;\n\t}\n\n\t/*\n\t * You can't do multicast (or broadcast) TCP.\n\t */\n\tif (((*addrinfo)->ai_socktype == SOCK_STREAM) &&\n\t    (sock_ismcastaddr((*addrinfo)->ai_addr) == 0))\n\t{\n\t\tif (errbuf)\n\t\t\tpcap_snprintf(errbuf, errbuflen, \"getaddrinfo(): multicast addresses are not valid when using TCP streams\");\n\t\tfreeaddrinfo(*addrinfo);\n\t\t*addrinfo = NULL;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              699,
              0
            ],
            [
              751,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_initaddress",
            "parameters": {
              "host": "char",
              "port": "char",
              "hints": "struct addrinfo",
              "addrinfo": "struct addrinfo",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int sock_send(SOCKET sock, SSL *ssl _U_NOSSL_, const char *buffer, size_t size,\n    char *errbuf, int errbuflen)\n{\n\tint remaining;\n\tssize_t nsent;\n\n\tif (size > INT_MAX)\n\t{\n\t\tif (errbuf)\n\t\t{\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"Can't send more than %u bytes with sock_send\",\n\t\t\t    INT_MAX);\n\t\t}\n\t\treturn -1;\n\t}\n\tremaining = (int)size;\n\n\tdo {\n#ifdef HAVE_OPENSSL\n\t\tif (ssl) return ssl_send(ssl, buffer, remaining, errbuf, errbuflen);\n#endif\n\n#ifdef MSG_NOSIGNAL\n\t\t/*\n\t\t * Send with MSG_NOSIGNAL, so that we don't get SIGPIPE\n\t\t * on errors on stream-oriented sockets when the other\n\t\t * end breaks the connection.\n\t\t * The EPIPE error is still returned.\n\t\t */\n\t\tnsent = send(sock, buffer, remaining, MSG_NOSIGNAL);\n#else\n\t\tnsent = send(sock, buffer, remaining, 0);\n#endif\n\n\t\tif (nsent == -1)\n\t\t{\n\t\t\t/*\n\t\t\t * If the client closed the connection out from\n\t\t\t * under us, there's no need to log that as an\n\t\t\t * error.\n\t\t\t */\n\t\t\tint errcode;\n\n#ifdef _WIN32\n\t\t\terrcode = GetLastError();\n\t\t\tif (errcode == WSAECONNRESET ||\n\t\t\t    errcode == WSAECONNABORTED)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * WSAECONNABORTED appears to be the error\n\t\t\t\t * returned in Winsock when you try to send\n\t\t\t\t * on a connection where the peer has closed\n\t\t\t\t * the receive side.\n\t\t\t\t */\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\tsock_fmterror(\"send(): \", errcode, errbuf, errbuflen);\n#else\n\t\t\terrcode = errno;\n\t\t\tif (errcode == ECONNRESET || errcode == EPIPE)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * EPIPE is what's returned on UN*X when\n\t\t\t\t * you try to send on a connection when\n\t\t\t\t * the peer has closed the receive side.\n\t\t\t\t */\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\tsock_fmterror(\"send(): \", errcode, errbuf, errbuflen);\n#endif\n\t\t\treturn -1;\n\t\t}\n\n\t\tremaining -= nsent;\n\t\tbuffer += nsent;\n\t} while (remaining != 0);\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              780,
              0
            ],
            [
              859,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_send",
            "parameters": {
              "sock": "SOCKET",
              "ssl": "SSL",
              "buffer": "char",
              "size": "size_t",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int sock_bufferize(const char *buffer, int size, char *tempbuf, int *offset, int totsize, int checkonly, char *errbuf, int errbuflen)\n{\n\tif ((*offset + size) > totsize)\n\t{\n\t\tif (errbuf)\n\t\t\tpcap_snprintf(errbuf, errbuflen, \"Not enough space in the temporary send buffer.\");\n\t\treturn -1;\n\t}\n\n\tif (!checkonly)\n\t\tmemcpy(tempbuf + (*offset), buffer, size);\n\n\t(*offset) += size;\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              916,
              0
            ],
            [
              931,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_bufferize",
            "parameters": {
              "buffer": "char",
              "size": "int",
              "tempbuf": "char",
              "offset": "int",
              "totsize": "int",
              "checkonly": "int",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int sock_recv(SOCKET sock, SSL *ssl _U_NOSSL_, void *buffer, size_t size,\n    int flags, char *errbuf, int errbuflen)\n{\n\tint recv_flags = 0;\n\tchar *bufp = buffer;\n\tint remaining;\n\tssize_t nread;\n\n\tif (size == 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (size > INT_MAX)\n\t{\n\t\tif (errbuf)\n\t\t{\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"Can't read more than %u bytes with sock_recv\",\n\t\t\t    INT_MAX);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif (flags & SOCK_MSG_PEEK)\n\t\trecv_flags |= MSG_PEEK;\n\n\tbufp = (char *) buffer;\n\tremaining = (int) size;\n\n\t/*\n\t * We don't use MSG_WAITALL because it's not supported in\n\t * Win32.\n\t */\n\tfor (;;) {\n#ifdef HAVE_OPENSSL\n\t\tif (ssl)\n\t\t{\n\t\t\t/*\n\t\t\t * XXX - what about MSG_PEEK?\n\t\t\t */\n\t\t\tnread = ssl_recv(ssl, bufp, remaining, errbuf, errbuflen);\n\t\t\tif (nread == -2) return -1;\n\t\t}\n\t\telse\n\t\t\tnread = recv(sock, bufp, remaining, recv_flags);\n#else\n\t\tnread = recv(sock, bufp, remaining, recv_flags);\n#endif\n\n\t\tif (nread == -1)\n\t\t{\n#ifndef _WIN32\n\t\t\tif (errno == EINTR)\n\t\t\t\treturn -3;\n#endif\n\t\t\tsock_geterror(\"recv(): \", errbuf, errbuflen);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (nread == 0)\n\t\t{\n\t\t\tif ((flags & SOCK_EOF_IS_ERROR) ||\n\t\t\t    (remaining != (int) size))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Either we've already read some data,\n\t\t\t\t * or we're always supposed to return\n\t\t\t\t * an error on EOF.\n\t\t\t\t */\n\t\t\t\tif (errbuf)\n\t\t\t\t{\n\t\t\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t\t\t    \"The other host terminated the connection.\");\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * Do we want to read the amount requested, or just return\n\t\t * what we got?\n\t\t */\n\t\tif (!(flags & SOCK_RECEIVEALL_YES))\n\t\t{\n\t\t\t/*\n\t\t\t * Just return what we got.\n\t\t\t */\n\t\t\treturn (int) nread;\n\t\t}\n\n\t\tbufp += nread;\n\t\tremaining -= nread;\n\n\t\tif (remaining == 0)\n\t\t\treturn (int) size;\n\t}\n}",
          "fn_code_pos": [
            [
              979,
              0
            ],
            [
              1077,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_recv",
            "parameters": {
              "sock": "SOCKET",
              "ssl": "SSL",
              "buffer": "void",
              "size": "size_t",
              "flags": "int",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int sock_recv_dgram(SOCKET sock, SSL *ssl _U_NOSSL_, void *buffer, size_t size,\n    char *errbuf, int errbuflen)\n{\n\tssize_t nread;\n#ifndef _WIN32\n\tstruct msghdr message;\n\tstruct iovec iov;\n#endif\n\n\tif (size == 0)\n\t{\n\t\treturn 0;\n\t}\n\tif (size > INT_MAX)\n\t{\n\t\tif (errbuf)\n\t\t{\n\t\t\tpcap_snprintf(errbuf, errbuflen,\n\t\t\t    \"Can't read more than %u bytes with sock_recv_dgram\",\n\t\t\t    INT_MAX);\n\t\t}\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_OPENSSL\n\t// TODO: DTLS\n\tif (ssl)\n\t{\n\t\tpcap_snprintf(errbuf, errbuflen, \"DTLS not implemented yet\");\n\t\treturn -1;\n\t}\n#endif\n\n\t/*\n\t * This should be a datagram socket, so we should get the\n\t * entire datagram in one recv() or recvmsg() call, and\n\t * don't need to loop.\n\t */\n#ifdef _WIN32\n\tnread = recv(sock, buffer, (int)size, 0);\n\tif (nread == SOCKET_ERROR)\n\t{\n\t\t/*\n\t\t * To quote the MSDN documentation for recv(),\n\t\t * \"If the datagram or message is larger than\n\t\t * the buffer specified, the buffer is filled\n\t\t * with the first part of the datagram, and recv\n\t\t * generates the error WSAEMSGSIZE. For unreliable\n\t\t * protocols (for example, UDP) the excess data is\n\t\t * lost...\"\n\t\t *\n\t\t * So if the message is bigger than the buffer\n\t\t * supplied to us, the excess data is discarded,\n\t\t * and we'll report an error.\n\t\t */\n\t\tsock_geterror(\"recv(): \", errbuf, errbuflen);\n\t\treturn -1;\n\t}\n#else /* _WIN32 */\n\t/*\n\t * The Single UNIX Specification says that a recv() on\n\t * a socket for a message-oriented protocol will discard\n\t * the excess data.  It does *not* indicate that the\n\t * receive will fail with, for example, EMSGSIZE.\n\t *\n\t * Therefore, we use recvmsg(), which appears to be\n\t * the only way to get a \"message truncated\" indication\n\t * when receiving a message for a message-oriented\n\t * protocol.\n\t */\n\tmessage.msg_name = NULL;\t/* we don't care who it's from */\n\tmessage.msg_namelen = 0;\n\tiov.iov_base = buffer;\n\tiov.iov_len = size;\n\tmessage.msg_iov = &iov;\n\tmessage.msg_iovlen = 1;\n#ifdef HAVE_STRUCT_MSGHDR_MSG_CONTROL\n\tmessage.msg_control = NULL;\t/* we don't care about control information */\n\tmessage.msg_controllen = 0;\n#endif\n#ifdef HAVE_STRUCT_MSGHDR_MSG_FLAGS\n\tmessage.msg_flags = 0;\n#endif\n\tnread = recvmsg(sock, &message, 0);\n\tif (nread == -1)\n\t{\n\t\tif (errno == EINTR)\n\t\t\treturn -3;\n\t\tsock_geterror(\"recv(): \", errbuf, errbuflen);\n\t\treturn -1;\n\t}\n#ifdef HAVE_STRUCT_MSGHDR_MSG_FLAGS\n\t/*\n\t * XXX - Solaris supports this, but only if you ask for the\n\t * X/Open version of recvmsg(); should we use that, or will\n\t * that cause other problems?\n\t */\n\tif (message.msg_flags & MSG_TRUNC)\n\t{\n\t\t/*\n\t\t * Message was bigger than the specified buffer size.\n\t\t *\n\t\t * Report this as an error, as the Microsoft documentation\n\t\t * implies we'd do in a similar case on Windows.\n\t\t */\n\t\tpcap_snprintf(errbuf, errbuflen, \"recv(): Message too long\");\n\t\treturn -1;\n\t}\n#endif /* HAVE_STRUCT_MSGHDR_MSG_FLAGS */\n#endif /* _WIN32 */\n\n\t/*\n\t * The size we're reading fits in an int, so the return value\n\t * will fit in an int.\n\t */\n\treturn (int)nread;\n}",
          "fn_code_pos": [
            [
              1084,
              0
            ],
            [
              1200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_recv_dgram",
            "parameters": {
              "sock": "SOCKET",
              "ssl": "SSL",
              "buffer": "void",
              "size": "size_t",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int sock_discard(SOCKET sock, SSL *ssl, int size, char *errbuf, int errbuflen)\n{\n#define TEMP_BUF_SIZE 32768\n\n\tchar buffer[TEMP_BUF_SIZE];\t\t/* network buffer, to be used when the message is discarded */\n\n\t/*\n\t * A static allocation avoids the need of a 'malloc()' each time we want to discard a message\n\t * Our feeling is that a buffer if 32KB is enough for most of the application;\n\t * in case this is not enough, the \"while\" loop discards the message by calling the\n\t * sockrecv() several times.\n\t * We do not want to create a bigger variable because this causes the program to exit on\n\t * some platforms (e.g. BSD)\n\t */\n\twhile (size > TEMP_BUF_SIZE)\n\t{\n\t\tif (sock_recv(sock, ssl, buffer, TEMP_BUF_SIZE, SOCK_RECEIVEALL_YES, errbuf, errbuflen) == -1)\n\t\t\treturn -1;\n\n\t\tsize -= TEMP_BUF_SIZE;\n\t}\n\n\t/*\n\t * If there is still data to be discarded\n\t * In this case, the data can fit into the temporary buffer\n\t */\n\tif (size)\n\t{\n\t\tif (sock_recv(sock, ssl, buffer, size, SOCK_RECEIVEALL_YES, errbuf, errbuflen) == -1)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1227,
              0
            ],
            [
              1260,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_discard",
            "parameters": {
              "sock": "SOCKET",
              "ssl": "SSL",
              "size": "int",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int sock_check_hostlist(char *hostlist, const char *sep, struct sockaddr_storage *from, char *errbuf, int errbuflen)\n{\n\t/* checks if the connecting host is among the ones allowed */\n\tif ((hostlist) && (hostlist[0]))\n\t{\n\t\tchar *token;\t\t\t\t\t/* temp, needed to separate items into the hostlist */\n\t\tstruct addrinfo *addrinfo, *ai_next;\n\t\tchar *temphostlist;\n\t\tchar *lasts;\n\t\tint getaddrinfo_failed = 0;\n\n\t\t/*\n\t\t * The problem is that strtok modifies the original variable by putting '0' at the end of each token\n\t\t * So, we have to create a new temporary string in which the original content is kept\n\t\t */\n\t\ttemphostlist = strdup(hostlist);\n\t\tif (temphostlist == NULL)\n\t\t{\n\t\t\tsock_geterror(\"sock_check_hostlist(), malloc() failed\", errbuf, errbuflen);\n\t\t\treturn -2;\n\t\t}\n\n\t\ttoken = pcap_strtok_r(temphostlist, sep, &lasts);\n\n\t\t/* it avoids a warning in the compilation ('addrinfo used but not initialized') */\n\t\taddrinfo = NULL;\n\n\t\twhile (token != NULL)\n\t\t{\n\t\t\tstruct addrinfo hints;\n\t\t\tint retval;\n\n\t\t\taddrinfo = NULL;\n\t\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\t\thints.ai_family = PF_UNSPEC;\n\t\t\thints.ai_socktype = SOCK_STREAM;\n\n\t\t\tretval = getaddrinfo(token, NULL, &hints, &addrinfo);\n\t\t\tif (retval != 0)\n\t\t\t{\n\t\t\t\tif (errbuf)\n\t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n\t\t\t\t\t    \"Allowed host list error: \",\n\t\t\t\t\t    retval, token, NULL);\n\n\t\t\t\t/*\n\t\t\t\t * Note that at least one call to getaddrinfo()\n\t\t\t\t * failed.\n\t\t\t\t */\n\t\t\t\tgetaddrinfo_failed = 1;\n\n\t\t\t\t/* Get next token */\n\t\t\t\ttoken = pcap_strtok_r(NULL, sep, &lasts);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* ai_next is required to preserve the content of addrinfo, in order to deallocate it properly */\n\t\t\tai_next = addrinfo;\n\t\t\twhile (ai_next)\n\t\t\t{\n\t\t\t\tif (sock_cmpaddr(from, (struct sockaddr_storage *) ai_next->ai_addr) == 0)\n\t\t\t\t{\n\t\t\t\t\tfree(temphostlist);\n\t\t\t\t\tfreeaddrinfo(addrinfo);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * If we are here, it means that the current address does not matches\n\t\t\t\t * Let's try with the next one in the header chain\n\t\t\t\t */\n\t\t\t\tai_next = ai_next->ai_next;\n\t\t\t}\n\n\t\t\tfreeaddrinfo(addrinfo);\n\t\t\taddrinfo = NULL;\n\n\t\t\t/* Get next token */\n\t\t\ttoken = pcap_strtok_r(NULL, sep, &lasts);\n\t\t}\n\n\t\tif (addrinfo)\n\t\t{\n\t\t\tfreeaddrinfo(addrinfo);\n\t\t\taddrinfo = NULL;\n\t\t}\n\n\t\tfree(temphostlist);\n\n\t\tif (getaddrinfo_failed) {\n\t\t\t/*\n\t\t\t * At least one getaddrinfo() call failed;\n\t\t\t * treat that as an error, so rpcapd knows\n\t\t\t * that it should log it locally as well\n\t\t\t * as telling the client about it.\n\t\t\t */\n\t\t\treturn -2;\n\t\t} else {\n\t\t\t/*\n\t\t\t * All getaddrinfo() calls succeeded, but\n\t\t\t * the host wasn't in the list.\n\t\t\t */\n\t\t\tif (errbuf)\n\t\t\t\tpcap_snprintf(errbuf, errbuflen, \"The host is not in the allowed host list. Connection refused.\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* No hostlist, so we have to return 'empty list' */\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              1290,
              0
            ],
            [
              1400,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_check_hostlist",
            "parameters": {
              "hostlist": "char",
              "sep": "char",
              "from": "struct sockaddr_storage",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int sock_cmpaddr(struct sockaddr_storage *first, struct sockaddr_storage *second)\n{\n\tif (first->ss_family == second->ss_family)\n\t{\n\t\tif (first->ss_family == AF_INET)\n\t\t{\n\t\t\tif (memcmp(&(((struct sockaddr_in *) first)->sin_addr),\n\t\t\t\t&(((struct sockaddr_in *) second)->sin_addr),\n\t\t\t\tsizeof(struct in_addr)) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\telse /* address family is AF_INET6 */\n\t\t{\n\t\t\tif (memcmp(&(((struct sockaddr_in6 *) first)->sin6_addr),\n\t\t\t\t&(((struct sockaddr_in6 *) second)->sin6_addr),\n\t\t\t\tsizeof(struct in6_addr)) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              1420,
              0
            ],
            [
              1441,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_cmpaddr",
            "parameters": {
              "first": "struct sockaddr_storage",
              "second": "struct sockaddr_storage"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int sock_getmyinfo(SOCKET sock, char *address, int addrlen, char *port, int portlen, int flags, char *errbuf, int errbuflen)\n{\n\tstruct sockaddr_storage mysockaddr;\n\tsocklen_t sockaddrlen;\n\n\n\tsockaddrlen = sizeof(struct sockaddr_storage);\n\n\tif (getsockname(sock, (struct sockaddr *) &mysockaddr, &sockaddrlen) == -1)\n\t{\n\t\tsock_geterror(\"getsockname(): \", errbuf, errbuflen);\n\t\treturn 0;\n\t}\n\n\t/* Returns the numeric address of the host that triggered the error */\n\treturn sock_getascii_addrport(&mysockaddr, address, addrlen, port, portlen, flags, errbuf, errbuflen);\n}",
          "fn_code_pos": [
            [
              1484,
              0
            ],
            [
              1500,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_getmyinfo",
            "parameters": {
              "sock": "SOCKET",
              "address": "char",
              "addrlen": "int",
              "port": "char",
              "portlen": "int",
              "flags": "int",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int sock_getascii_addrport(const struct sockaddr_storage *sockaddr, char *address, int addrlen, char *port, int portlen, int flags, char *errbuf, int errbuflen)\n{\n\tsocklen_t sockaddrlen;\n\tint retval;\t\t\t\t\t/* Variable that keeps the return value; */\n\n\tretval = -1;\n\n#ifdef _WIN32\n\tif (sockaddr->ss_family == AF_INET)\n\t\tsockaddrlen = sizeof(struct sockaddr_in);\n\telse\n\t\tsockaddrlen = sizeof(struct sockaddr_in6);\n#else\n\tsockaddrlen = sizeof(struct sockaddr_storage);\n#endif\n\n\tif ((flags & NI_NUMERICHOST) == 0)\t/* Check that we want literal names */\n\t{\n\t\tif ((sockaddr->ss_family == AF_INET6) &&\n\t\t\t(memcmp(&((struct sockaddr_in6 *) sockaddr)->sin6_addr, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", sizeof(struct in6_addr)) == 0))\n\t\t{\n\t\t\tif (address)\n\t\t\t\tpcap_strlcpy(address, SOCKET_NAME_NULL_DAD, addrlen);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (getnameinfo((struct sockaddr *) sockaddr, sockaddrlen, address, addrlen, port, portlen, flags) != 0)\n\t{\n\t\t/* If the user wants to receive an error message */\n\t\tif (errbuf)\n\t\t{\n\t\t\tsock_geterror(\"getnameinfo(): \", errbuf, errbuflen);\n\t\t\terrbuf[errbuflen - 1] = 0;\n\t\t}\n\n\t\tif (address)\n\t\t{\n\t\t\tpcap_strlcpy(address, SOCKET_NO_NAME_AVAILABLE, addrlen);\n\t\t\taddress[addrlen - 1] = 0;\n\t\t}\n\n\t\tif (port)\n\t\t{\n\t\t\tpcap_strlcpy(port, SOCKET_NO_PORT_AVAILABLE, portlen);\n\t\t\tport[portlen - 1] = 0;\n\t\t}\n\n\t\tretval = 0;\n\t}\n\n\treturn retval;\n}",
          "fn_code_pos": [
            [
              1550,
              0
            ],
            [
              1602,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_getascii_addrport",
            "parameters": {
              "sockaddr": "struct sockaddr_storage",
              "address": "char",
              "addrlen": "int",
              "port": "char",
              "portlen": "int",
              "flags": "int",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int sock_present2network(const char *address, struct sockaddr_storage *sockaddr, int addr_family, char *errbuf, int errbuflen)\n{\n\tint retval;\n\tstruct addrinfo *addrinfo;\n\tstruct addrinfo hints;\n\n\tmemset(&hints, 0, sizeof(hints));\n\n\thints.ai_family = addr_family;\n\n\tif ((retval = sock_initaddress(address, \"22222\" /* fake port */, &hints, &addrinfo, errbuf, errbuflen)) == -1)\n\t\treturn 0;\n\n\tif (addrinfo->ai_family == PF_INET)\n\t\tmemcpy(sockaddr, addrinfo->ai_addr, sizeof(struct sockaddr_in));\n\telse\n\t\tmemcpy(sockaddr, addrinfo->ai_addr, sizeof(struct sockaddr_in6));\n\n\tif (addrinfo->ai_next != NULL)\n\t{\n\t\tfreeaddrinfo(addrinfo);\n\n\t\tif (errbuf)\n\t\t\tpcap_snprintf(errbuf, errbuflen, \"More than one socket requested; using the first one returned\");\n\t\treturn -2;\n\t}\n\n\tfreeaddrinfo(addrinfo);\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              1640,
              0
            ],
            [
              1669,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_present2network",
            "parameters": {
              "address": "char",
              "sockaddr": "struct sockaddr_storage",
              "addr_family": "int",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "sock_ismcastaddr(const struct sockaddr *saddr)",
          "fn_dec_pos": [
            [
              114,
              11
            ],
            [
              114,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_ismcastaddr",
            "parameters": {
              "saddr": "struct sockaddr"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct sockaddr",
          {},
          "",
          [
            114,
            34
          ],
          [
            114,
            49
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            262,
            34
          ],
          [
            262,
            49
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            266,
            2
          ],
          [
            266,
            20
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            266,
            32
          ],
          [
            266,
            50
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            272,
            2
          ],
          [
            272,
            21
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            272,
            33
          ],
          [
            272,
            52
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            309,
            17
          ],
          [
            309,
            32
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            409,
            2
          ],
          [
            409,
            17
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            439,
            28
          ],
          [
            439,
            51
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            700,
            4
          ],
          [
            700,
            19
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            700,
            28
          ],
          [
            700,
            43
          ]
        ],
        [
          "struct msghdr",
          {},
          "",
          [
            1089,
            1
          ],
          [
            1089,
            14
          ]
        ],
        [
          "struct iovec",
          {},
          "",
          [
            1090,
            1
          ],
          [
            1090,
            13
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1290,
            57
          ],
          [
            1290,
            80
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            1296,
            2
          ],
          [
            1296,
            17
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            1319,
            3
          ],
          [
            1319,
            18
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            1323,
            28
          ],
          [
            1323,
            43
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1350,
            28
          ],
          [
            1350,
            51
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1420,
            17
          ],
          [
            1420,
            40
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1420,
            49
          ],
          [
            1420,
            72
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            1426,
            18
          ],
          [
            1426,
            36
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            1427,
            8
          ],
          [
            1427,
            26
          ]
        ],
        [
          "struct in_addr",
          {},
          "",
          [
            1428,
            11
          ],
          [
            1428,
            25
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            1433,
            18
          ],
          [
            1433,
            37
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            1434,
            8
          ],
          [
            1434,
            27
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            1435,
            11
          ],
          [
            1435,
            26
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1486,
            1
          ],
          [
            1486,
            24
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1490,
            22
          ],
          [
            1490,
            45
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1492,
            24
          ],
          [
            1492,
            39
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1550,
            33
          ],
          [
            1550,
            56
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            1559,
            23
          ],
          [
            1559,
            41
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            1561,
            23
          ],
          [
            1561,
            42
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1563,
            22
          ],
          [
            1563,
            45
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            1569,
            14
          ],
          [
            1569,
            33
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            1569,
            102
          ],
          [
            1569,
            117
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1577,
            18
          ],
          [
            1577,
            33
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1640,
            46
          ],
          [
            1640,
            69
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            1643,
            1
          ],
          [
            1643,
            16
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            1644,
            1
          ],
          [
            1644,
            16
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            1654,
            45
          ],
          [
            1654,
            63
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            1656,
            45
          ],
          [
            1656,
            64
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"ftmacros.h\"\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <errno.h>\t/* for the errno variable */\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include <stdio.h>\t/* for the stderr file */\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include <stdlib.h>\t/* for malloc() and free() */\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#include <limits.h>\t/* for INT_MAX */\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include \"sockutils.h\"\n",
          [
            62,
            0
          ],
          [
            63,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-rpcap.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nrpcap_deseraddr(struct rpcap_sockaddr *sockaddrin, struct sockaddr_storage **sockaddrout, char *errbuf)\n{\n\t/* Warning: we support only AF_INET and AF_INET6 */\n\tswitch (ntohs(sockaddrin->family))\n\t{\n\tcase RPCAP_AF_INET:\n\tcase NEW_BSD_AF_INET_BE:\n\tcase NEW_BSD_AF_INET_LE:\n\t\t{\n\t\tstruct rpcap_sockaddr_in *sockaddrin_ipv4;\n\t\tstruct sockaddr_in *sockaddrout_ipv4;\n\n\t\t(*sockaddrout) = (struct sockaddr_storage *) malloc(sizeof(struct sockaddr_in));\n\t\tif ((*sockaddrout) == NULL)\n\t\t{\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc() failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tsockaddrin_ipv4 = (struct rpcap_sockaddr_in *) sockaddrin;\n\t\tsockaddrout_ipv4 = (struct sockaddr_in *) (*sockaddrout);\n\t\tsockaddrout_ipv4->sin_family = AF_INET;\n\t\tsockaddrout_ipv4->sin_port = ntohs(sockaddrin_ipv4->port);\n\t\tmemcpy(&sockaddrout_ipv4->sin_addr, &sockaddrin_ipv4->addr, sizeof(sockaddrout_ipv4->sin_addr));\n\t\tmemset(sockaddrout_ipv4->sin_zero, 0, sizeof(sockaddrout_ipv4->sin_zero));\n\t\tbreak;\n\t\t}\n\n#ifdef AF_INET6\n\tcase RPCAP_AF_INET6:\n\tcase NEW_BSD_AF_INET6_BSD_BE:\n\tcase NEW_BSD_AF_INET6_FREEBSD_BE:\n\tcase NEW_BSD_AF_INET6_DARWIN_BE:\n\tcase NEW_BSD_AF_INET6_LE:\n\tcase LINUX_AF_INET6:\n\tcase HPUX_AF_INET6:\n\tcase AIX_AF_INET6:\n\tcase SOLARIS_AF_INET6:\n\t\t{\n\t\tstruct rpcap_sockaddr_in6 *sockaddrin_ipv6;\n\t\tstruct sockaddr_in6 *sockaddrout_ipv6;\n\n\t\t(*sockaddrout) = (struct sockaddr_storage *) malloc(sizeof(struct sockaddr_in6));\n\t\tif ((*sockaddrout) == NULL)\n\t\t{\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc() failed\");\n\t\t\treturn -1;\n\t\t}\n\t\tsockaddrin_ipv6 = (struct rpcap_sockaddr_in6 *) sockaddrin;\n\t\tsockaddrout_ipv6 = (struct sockaddr_in6 *) (*sockaddrout);\n\t\tsockaddrout_ipv6->sin6_family = AF_INET6;\n\t\tsockaddrout_ipv6->sin6_port = ntohs(sockaddrin_ipv6->port);\n\t\tsockaddrout_ipv6->sin6_flowinfo = ntohl(sockaddrin_ipv6->flowinfo);\n\t\tmemcpy(&sockaddrout_ipv6->sin6_addr, &sockaddrin_ipv6->addr, sizeof(sockaddrout_ipv6->sin6_addr));\n\t\tsockaddrout_ipv6->sin6_scope_id = ntohl(sockaddrin_ipv6->scope_id);\n\t\tbreak;\n\t\t}\n#endif\n\n\tdefault:\n\t\t/*\n\t\t * It is neither AF_INET nor AF_INET6 (or, if the OS doesn't\n\t\t * support AF_INET6, it's not AF_INET).\n\t\t */\n\t\t*sockaddrout = NULL;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              287,
              0
            ],
            [
              357,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_deseraddr",
            "parameters": {
              "sockaddrin": "struct rpcap_sockaddr",
              "sockaddrout": "struct sockaddr_storage",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_read_nocb_remote(pcap_t *p, struct pcap_pkthdr *pkt_header, u_char **pkt_data)\n{\n\tstruct pcap_rpcap *pr = p->priv;\t/* structure used when doing a remote live capture */\n\tstruct rpcap_header *header;\t\t/* general header according to the RPCAP format */\n\tstruct rpcap_pkthdr *net_pkt_header;\t/* header of the packet, from the message */\n\tu_char *net_pkt_data;\t\t\t/* packet data from the message */\n\tuint32 plen;\n\tint retval = 0;\t\t\t\t/* generic return value */\n\tint msglen;\n\n\t/* Structures needed for the select() call */\n\tstruct timeval tv;\t\t\t/* maximum time the select() can block waiting for data */\n\tfd_set rfds;\t\t\t\t/* set of socket descriptors we have to check */\n\n\t/*\n\t * Define the packet buffer timeout, to be used in the select()\n\t * 'timeout', in pcap_t, is in milliseconds; we have to convert it into sec and microsec\n\t */\n\ttv.tv_sec = p->opt.timeout / 1000;\n\ttv.tv_usec = (suseconds_t)((p->opt.timeout - tv.tv_sec * 1000) * 1000);\n\n#ifdef HAVE_OPENSSL\n\t/* Check if we still have bytes available in the last decoded TLS record.\n\t * If that's the case, we know SSL_read will not block. */\n\tretval = pr->data_ssl && SSL_pending(pr->data_ssl) > 0;\n#endif\n\tif (! retval)\n\t{\n\t\t/* Watch out sockdata to see if it has input */\n\t\tFD_ZERO(&rfds);\n\n\t\t/*\n\t\t * 'fp->rmt_sockdata' has always to be set before calling the select(),\n\t\t * since it is cleared by the select()\n\t\t */\n\t\tFD_SET(pr->rmt_sockdata, &rfds);\n\n\t\tretval = select((int) pr->rmt_sockdata + 1, &rfds, NULL, NULL, &tv);\n\n\t\tif (retval == -1)\n\t\t{\n#ifndef _WIN32\n\t\t\tif (errno == EINTR)\n\t\t\t{\n\t\t\t\t/* Interrupted. */\n\t\t\t\treturn 0;\n\t\t\t}\n#endif\n\t\t\tsock_geterror(\"select(): \", p->errbuf, PCAP_ERRBUF_SIZE);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* There is no data waiting, so return '0' */\n\tif (retval == 0)\n\t\treturn 0;\n\n\t/*\n\t * We have to define 'header' as a pointer to a larger buffer,\n\t * because in case of UDP we have to read all the message within a single call\n\t */\n\theader = (struct rpcap_header *) p->buffer;\n\tnet_pkt_header = (struct rpcap_pkthdr *) ((char *)p->buffer + sizeof(struct rpcap_header));\n\tnet_pkt_data = (u_char *)p->buffer + sizeof(struct rpcap_header) + sizeof(struct rpcap_pkthdr);\n\n\tif (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP)\n\t{\n\t\t/* Read the entire message from the network */\n\t\tmsglen = sock_recv_dgram(pr->rmt_sockdata, pr->data_ssl, p->buffer,\n\t\t    p->bufsize, p->errbuf, PCAP_ERRBUF_SIZE);\n\t\tif (msglen == -1)\n\t\t{\n\t\t\t/* Network error. */\n\t\t\treturn -1;\n\t\t}\n\t\tif (msglen == -3)\n\t\t{\n\t\t\t/* Interrupted receive. */\n\t\t\treturn 0;\n\t\t}\n\t\tif ((size_t)msglen < sizeof(struct rpcap_header))\n\t\t{\n\t\t\t/*\n\t\t\t * Message is shorter than an rpcap header.\n\t\t\t */\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"UDP packet message is shorter than an rpcap header\");\n\t\t\treturn -1;\n\t\t}\n\t\tplen = ntohl(header->plen);\n\t\tif ((size_t)msglen < sizeof(struct rpcap_header) + plen)\n\t\t{\n\t\t\t/*\n\t\t\t * Message is shorter than the header claims it\n\t\t\t * is.\n\t\t\t */\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"UDP packet message is shorter than its rpcap header claims\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tint status;\n\n\t\tif ((size_t)p->cc < sizeof(struct rpcap_header))\n\t\t{\n\t\t\t/*\n\t\t\t * We haven't read any of the packet header yet.\n\t\t\t * The size we should get is the size of the\n\t\t\t * packet header.\n\t\t\t */\n\t\t\tstatus = rpcap_read_packet_msg(pr, p, sizeof(struct rpcap_header));\n\t\t\tif (status == -1)\n\t\t\t{\n\t\t\t\t/* Network error. */\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (status == -3)\n\t\t\t{\n\t\t\t\t/* Interrupted receive. */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We have the header, so we know how long the\n\t\t * message payload is.  The size we should get\n\t\t * is the size of the packet header plus the\n\t\t * size of the payload.\n\t\t */\n\t\tplen = ntohl(header->plen);\n\t\tif (plen > p->bufsize - sizeof(struct rpcap_header))\n\t\t{\n\t\t\t/*\n\t\t\t * This is bigger than the largest\n\t\t\t * record we'd expect.  (We do it by\n\t\t\t * subtracting in order to avoid an\n\t\t\t * overflow.)\n\t\t\t */\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Server sent us a message larger than the largest expected packet message\");\n\t\t\treturn -1;\n\t\t}\n\t\tstatus = rpcap_read_packet_msg(pr, p, sizeof(struct rpcap_header) + plen);\n\t\tif (status == -1)\n\t\t{\n\t\t\t/* Network error. */\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == -3)\n\t\t{\n\t\t\t/* Interrupted receive. */\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * We have the entire message; reset the buffer pointer\n\t\t * and count, as the next read should start a new\n\t\t * message.\n\t\t */\n\t\tp->bp = p->buffer;\n\t\tp->cc = 0;\n\t}\n\n\t/*\n\t * We have the entire message.\n\t */\n\theader->plen = plen;\n\n\t/*\n\t * Did the server specify the version we negotiated?\n\t */\n\tif (rpcap_check_msg_ver(pr->rmt_sockdata, pr->data_ssl, pr->protocol_version,\n\t    header, p->errbuf) == -1)\n\t{\n\t\treturn 0;\t/* Return 'no packets received' */\n\t}\n\n\t/*\n\t * Is this a RPCAP_MSG_PACKET message?\n\t */\n\tif (header->type != RPCAP_MSG_PACKET)\n\t{\n\t\treturn 0;\t/* Return 'no packets received' */\n\t}\n\n\tif (ntohl(net_pkt_header->caplen) > plen)\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Packet's captured data goes past the end of the received packet message.\");\n\t\treturn -1;\n\t}\n\n\t/* Fill in packet header */\n\tpkt_header->caplen = ntohl(net_pkt_header->caplen);\n\tpkt_header->len = ntohl(net_pkt_header->len);\n\tpkt_header->ts.tv_sec = ntohl(net_pkt_header->timestamp_sec);\n\tpkt_header->ts.tv_usec = ntohl(net_pkt_header->timestamp_usec);\n\n\t/* Supply a pointer to the beginning of the packet data */\n\t*pkt_data = net_pkt_data;\n\n\t/*\n\t * I don't update the counter of the packets dropped by the network since we're using TCP,\n\t * therefore no packets are dropped. Just update the number of packets received correctly\n\t */\n\tpr->TotCapt++;\n\n\tif (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP)\n\t{\n\t\tunsigned int npkt;\n\n\t\t/* We're using UDP, so we need to update the counter of the packets dropped by the network */\n\t\tnpkt = ntohl(net_pkt_header->npkt);\n\n\t\tif (pr->TotCapt != npkt)\n\t\t{\n\t\t\tpr->TotNetDrops += (npkt - pr->TotCapt);\n\t\t\tpr->TotCapt = npkt;\n\t\t}\n\t}\n\n\t/* Packet read successfully */\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              378,
              0
            ],
            [
              603,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_nocb_remote",
            "parameters": {
              "p": "pcap_t",
              "pkt_header": "struct pcap_pkthdr",
              "pkt_data": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_read_rpcap(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_rpcap *pr = p->priv;\t/* structure used when doing a remote live capture */\n\tstruct pcap_pkthdr pkt_header;\n\tu_char *pkt_data;\n\tint n = 0;\n\tint ret;\n\n\t/*\n\t * If this is client-side, and we haven't already started\n\t * the capture, start it now.\n\t */\n\tif (pr->rmt_clientside)\n\t{\n\t\t/* We are on an remote capture */\n\t\tif (!pr->rmt_capstarted)\n\t\t{\n\t\t\t/*\n\t\t\t * The capture isn't started yet, so try to\n\t\t\t * start it.\n\t\t\t */\n\t\t\tif (pcap_startcapture_remote(p))\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\twhile (n < cnt || PACKET_COUNT_IS_UNLIMITED(cnt))\n\t{\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\t/*\n\t\t\t * Yes - clear the flag that indicates that it\n\t\t\t * has, and return PCAP_ERROR_BREAK to indicate\n\t\t\t * that we were told to break out of the loop.\n\t\t\t */\n\t\t\tp->break_loop = 0;\n\t\t\treturn (PCAP_ERROR_BREAK);\n\t\t}\n\n\t\t/*\n\t\t * Read some packets.\n\t\t */\n\t\tret = pcap_read_nocb_remote(p, &pkt_header, &pkt_data);\n\t\tif (ret == 1)\n\t\t{\n\t\t\t/*\n\t\t\t * We got a packet.  Hand it to the callback\n\t\t\t * and count it so we can return the count.\n\t\t\t */\n\t\t\t(*callback)(user, &pkt_header, pkt_data);\n\t\t\tn++;\n\t\t}\n\t\telse if (ret == -1)\n\t\t{\n\t\t\t/* Error. */\n\t\t\treturn ret;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * No packet; this could mean that we timed\n\t\t\t * out, or that we got interrupted, or that\n\t\t\t * we got a bad packet.\n\t\t\t *\n\t\t\t * Were we told to break out of the loop?\n\t\t\t */\n\t\t\tif (p->break_loop) {\n\t\t\t\t/*\n\t\t\t\t * Yes.\n\t\t\t\t */\n\t\t\t\tp->break_loop = 0;\n\t\t\t\treturn (PCAP_ERROR_BREAK);\n\t\t\t}\n\t\t\t/* No - return the number of packets we've processed. */\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn n;\n}",
          "fn_code_pos": [
            [
              612,
              0
            ],
            [
              692,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_rpcap",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void pcap_cleanup_rpcap(pcap_t *fp)\n{\n\tstruct pcap_rpcap *pr = fp->priv;\t/* structure used when doing a remote live capture */\n\tstruct rpcap_header header;\t\t/* header of the RPCAP packet */\n\tstruct activehosts *temp;\t\t/* temp var needed to scan the host list chain, to detect if we're in active mode */\n\tint active = 0;\t\t\t\t/* active mode or not? */\n\n\t/* detect if we're in active mode */\n\ttemp = activeHosts;\n\twhile (temp)\n\t{\n\t\tif (temp->sockctrl == pr->rmt_sockctrl)\n\t\t{\n\t\t\tactive = 1;\n\t\t\tbreak;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\n\tif (!active)\n\t{\n\t\trpcap_createhdr(&header, pr->protocol_version,\n\t\t    RPCAP_MSG_CLOSE, 0, 0);\n\n\t\t/*\n\t\t * Send the close request; don't report any errors, as\n\t\t * we're closing this pcap_t, and have no place to report\n\t\t * the error.  No reply is sent to this message.\n\t\t */\n\t\t(void)sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, (char *)&header,\n\t\t    sizeof(struct rpcap_header), NULL, 0);\n\t}\n\telse\n\t{\n\t\trpcap_createhdr(&header, pr->protocol_version,\n\t\t    RPCAP_MSG_ENDCAP_REQ, 0, 0);\n\n\t\t/*\n\t\t * Send the end capture request; don't report any errors,\n\t\t * as we're closing this pcap_t, and have no place to\n\t\t * report the error.\n\t\t */\n\t\tif (sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, (char *)&header,\n\t\t    sizeof(struct rpcap_header), NULL, 0) == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * Wait for the answer; don't report any errors,\n\t\t\t * as we're closing this pcap_t, and have no\n\t\t\t * place to report the error.\n\t\t\t */\n\t\t\tif (rpcap_process_msg_header(pr->rmt_sockctrl, pr->ctrl_ssl,\n\t\t\t    pr->protocol_version, RPCAP_MSG_ENDCAP_REQ,\n\t\t\t    &header, NULL) == 0)\n\t\t\t{\n\t\t\t\t(void)rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl,\n\t\t\t\t    header.plen, NULL);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pr->rmt_sockdata)\n\t{\n#ifdef HAVE_OPENSSL\n\t\tif (pr->data_ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the data socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(pr->data_ssl);\n\t\t\tpr->data_ssl = NULL;\n\t\t}\n#endif\n\t\tsock_close(pr->rmt_sockdata, NULL, 0);\n\t\tpr->rmt_sockdata = 0;\n\t}\n\n\tif ((!active) && (pr->rmt_sockctrl))\n\t{\n#ifdef HAVE_OPENSSL\n\t\tif (pr->ctrl_ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the control socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(pr->ctrl_ssl);\n\t\t\tpr->ctrl_ssl = NULL;\n\t\t}\n#endif\n\t\tsock_close(pr->rmt_sockctrl, NULL, 0);\n\t}\n\n\tpr->rmt_sockctrl = 0;\n\tpr->ctrl_ssl = NULL;\n\n\tif (pr->currentfilter)\n\t{\n\t\tfree(pr->currentfilter);\n\t\tpr->currentfilter = NULL;\n\t}\n\n\tpcap_cleanup_live_common(fp);\n\n\t/* To avoid inconsistencies in the number of sock_init() */\n\tsock_cleanup();\n}",
          "fn_code_pos": [
            [
              704,
              0
            ],
            [
              806,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_cleanup_rpcap",
            "parameters": {
              "fp": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int pcap_stats_rpcap(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct pcap_stat *retval;\n\n\tretval = rpcap_stats_rpcap(p, ps, PCAP_STATS_STANDARD);\n\n\tif (retval)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "fn_code_pos": [
            [
              812,
              0
            ],
            [
              822,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_rpcap",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static struct pcap_stat *pcap_stats_ex_rpcap(pcap_t *p, int *pcap_stat_size)\n{\n\t*pcap_stat_size = sizeof (p->stat);\n\n\t/* PCAP_STATS_EX (third param) means 'extended pcap_stats()' */\n\treturn (rpcap_stats_rpcap(p, &(p->stat), PCAP_STATS_EX));\n}",
          "fn_code_pos": [
            [
              829,
              0
            ],
            [
              835,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_ex_rpcap",
            "parameters": {
              "p": "pcap_t",
              "pcap_stat_size": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct pcap_stat *rpcap_stats_rpcap(pcap_t *p, struct pcap_stat *ps, int mode)\n{\n\tstruct pcap_rpcap *pr = p->priv;\t/* structure used when doing a remote live capture */\n\tstruct rpcap_header header;\t\t/* header of the RPCAP packet */\n\tstruct rpcap_stats netstats;\t\t/* statistics sent on the network */\n\tuint32 plen;\t\t\t\t/* data remaining in the message */\n\n#ifdef _WIN32\n\tif (mode != PCAP_STATS_STANDARD && mode != PCAP_STATS_EX)\n#else\n\tif (mode != PCAP_STATS_STANDARD)\n#endif\n\t{\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Invalid stats mode %d\", mode);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * If the capture has not yet started, we cannot request statistics\n\t * for the capture from our peer, so we return 0 for all statistics,\n\t * as nothing's been seen yet.\n\t */\n\tif (!pr->rmt_capstarted)\n\t{\n\t\tps->ps_drop = 0;\n\t\tps->ps_ifdrop = 0;\n\t\tps->ps_recv = 0;\n#ifdef _WIN32\n\t\tif (mode == PCAP_STATS_EX)\n\t\t{\n\t\t\tps->ps_capt = 0;\n\t\t\tps->ps_sent = 0;\n\t\t\tps->ps_netdrop = 0;\n\t\t}\n#endif /* _WIN32 */\n\n\t\treturn ps;\n\t}\n\n\trpcap_createhdr(&header, pr->protocol_version,\n\t    RPCAP_MSG_STATS_REQ, 0, 0);\n\n\t/* Send the PCAP_STATS command */\n\tif (sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, (char *)&header,\n\t    sizeof(struct rpcap_header), p->errbuf, PCAP_ERRBUF_SIZE) < 0)\n\t\treturn NULL;\t\t/* Unrecoverable network error */\n\n\t/* Receive and process the reply message header. */\n\tif (rpcap_process_msg_header(pr->rmt_sockctrl, pr->ctrl_ssl, pr->protocol_version,\n\t    RPCAP_MSG_STATS_REQ, &header, p->errbuf) == -1)\n\t\treturn NULL;\t\t/* Error */\n\n\tplen = header.plen;\n\n\t/* Read the reply body */\n\tif (rpcap_recv(pr->rmt_sockctrl, pr->ctrl_ssl, (char *)&netstats,\n\t    sizeof(struct rpcap_stats), &plen, p->errbuf) == -1)\n\t\tgoto error;\n\n\tps->ps_drop = ntohl(netstats.krnldrop);\n\tps->ps_ifdrop = ntohl(netstats.ifdrop);\n\tps->ps_recv = ntohl(netstats.ifrecv);\n#ifdef _WIN32\n\tif (mode == PCAP_STATS_EX)\n\t{\n\t\tps->ps_capt = pr->TotCapt;\n\t\tps->ps_netdrop = pr->TotNetDrops;\n\t\tps->ps_sent = ntohl(netstats.svrcapt);\n\t}\n#endif /* _WIN32 */\n\n\t/* Discard the rest of the message. */\n\tif (rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, plen, p->errbuf) == -1)\n\t\tgoto error_nodiscard;\n\n\treturn ps;\n\nerror:\n\t/*\n\t * Discard the rest of the message.\n\t * We already reported an error; if this gets an error, just\n\t * drive on.\n\t */\n\t(void)rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, plen, NULL);\n\nerror_nodiscard:\n\treturn NULL;\n}",
          "fn_code_pos": [
            [
              875,
              0
            ],
            [
              963,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_stats_rpcap",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat",
              "mode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct activehosts *\nrpcap_remoteact_getsock(const char *host, int *error, char *errbuf)\n{\n\tstruct activehosts *temp;\t\t\t/* temp var needed to scan the host list chain */\n\tstruct addrinfo hints, *addrinfo, *ai_next;\t/* temp var needed to translate between hostname to its address */\n\tint retval;\n\n\t/* retrieve the network address corresponding to 'host' */\n\taddrinfo = NULL;\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\n\tretval = getaddrinfo(host, \"0\", &hints, &addrinfo);\n\tif (retval != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"getaddrinfo() %s\",\n\t\t    gai_strerror(retval));\n\t\t*error = 1;\n\t\treturn NULL;\n\t}\n\n\ttemp = activeHosts;\n\n\twhile (temp)\n\t{\n\t\tai_next = addrinfo;\n\t\twhile (ai_next)\n\t\t{\n\t\t\tif (sock_cmpaddr(&temp->host, (struct sockaddr_storage *) ai_next->ai_addr) == 0)\n\t\t\t{\n\t\t\t\t*error = 0;\n\t\t\t\tfreeaddrinfo(addrinfo);\n\t\t\t\treturn temp;\n\t\t\t}\n\n\t\t\tai_next = ai_next->ai_next;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\n\tif (addrinfo)\n\t\tfreeaddrinfo(addrinfo);\n\n\t/*\n\t * The host for which you want to get the socket ID does not have an\n\t * active connection.\n\t */\n\t*error = 0;\n\treturn NULL;\n}",
          "fn_code_pos": [
            [
              984,
              0
            ],
            [
              1034,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_remoteact_getsock",
            "parameters": {
              "host": "char",
              "error": "int",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static int pcap_startcapture_remote(pcap_t *fp)\n{\n\tstruct pcap_rpcap *pr = fp->priv;\t/* structure used when doing a remote live capture */\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t/* temporary buffer in which data to be sent is buffered */\n\tint sendbufidx = 0;\t\t\t/* index which keeps the number of bytes currently buffered */\n\tchar portdata[PCAP_BUF_SIZE];\t\t/* temp variable needed to keep the network port for the data connection */\n\tuint32 plen;\n\tint active = 0;\t\t\t\t/* '1' if we're in active mode */\n\tstruct activehosts *temp;\t\t/* temp var needed to scan the host list chain, to detect if we're in active mode */\n\tchar host[INET6_ADDRSTRLEN + 1];\t/* numeric name of the other host */\n\n\t/* socket-related variables*/\n\tstruct addrinfo hints;\t\t\t/* temp, needed to open a socket connection */\n\tstruct addrinfo *addrinfo;\t\t/* temp, needed to open a socket connection */\n\tSOCKET sockdata = 0;\t\t\t/* socket descriptor of the data connection */\n\tstruct sockaddr_storage saddr;\t\t/* temp, needed to retrieve the network data port chosen on the local machine */\n\tsocklen_t saddrlen;\t\t\t/* temp, needed to retrieve the network data port chosen on the local machine */\n\tint ai_family;\t\t\t\t/* temp, keeps the address family used by the control connection */\n\n\t/* RPCAP-related variables*/\n\tstruct rpcap_header header;\t\t\t/* header of the RPCAP packet */\n\tstruct rpcap_startcapreq *startcapreq;\t\t/* start capture request message */\n\tstruct rpcap_startcapreply startcapreply;\t/* start capture reply message */\n\n\t/* Variables related to the buffer setting */\n\tint res;\n\tsocklen_t itemp;\n\tint sockbufsize = 0;\n\tuint32 server_sockbufsize;\n\n\t// Take the opportunity to clear pr->data_ssl before any goto error,\n\t// as it seems pr->priv is not zeroed after its malloced.\n\tpr->data_ssl = NULL;\n\n\t/*\n\t * Let's check if sampling has been required.\n\t * If so, let's set it first\n\t */\n\tif (pcap_setsampling_remote(fp) != 0)\n\t\treturn -1;\n\n\t/* detect if we're in active mode */\n\ttemp = activeHosts;\n\twhile (temp)\n\t{\n\t\tif (temp->sockctrl == pr->rmt_sockctrl)\n\t\t{\n\t\t\tactive = 1;\n\t\t\tbreak;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\n\taddrinfo = NULL;\n\n\t/*\n\t * Gets the complete sockaddr structure used in the ctrl connection\n\t * This is needed to get the address family of the control socket\n\t * Tip: I cannot save the ai_family of the ctrl sock in the pcap_t struct,\n\t * since the ctrl socket can already be open in case of active mode;\n\t * so I would have to call getpeername() anyway\n\t */\n\tsaddrlen = sizeof(struct sockaddr_storage);\n\tif (getpeername(pr->rmt_sockctrl, (struct sockaddr *) &saddr, &saddrlen) == -1)\n\t{\n\t\tsock_geterror(\"getsockname(): \", fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\tgoto error_nodiscard;\n\t}\n\tai_family = ((struct sockaddr_storage *) &saddr)->ss_family;\n\n\t/* Get the numeric address of the remote host we are connected to */\n\tif (getnameinfo((struct sockaddr *) &saddr, saddrlen, host,\n\t\tsizeof(host), NULL, 0, NI_NUMERICHOST))\n\t{\n\t\tsock_geterror(\"getnameinfo(): \", fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\tgoto error_nodiscard;\n\t}\n\n\t/*\n\t * Data connection is opened by the server toward the client if:\n\t * - we're using TCP, and the user wants us to be in active mode\n\t * - we're using UDP\n\t */\n\tif ((active) || (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP))\n\t{\n\t\t/*\n\t\t * We have to create a new socket to receive packets\n\t\t * We have to do that immediately, since we have to tell the other\n\t\t * end which network port we picked up\n\t\t */\n\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\t/* TEMP addrinfo is NULL in case of active */\n\t\thints.ai_family = ai_family;\t/* Use the same address family of the control socket */\n\t\thints.ai_socktype = (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP) ? SOCK_DGRAM : SOCK_STREAM;\n\t\thints.ai_flags = AI_PASSIVE;\t/* Data connection is opened by the server toward the client */\n\n\t\t/* Let's the server pick up a free network port for us */\n\t\tif (sock_initaddress(NULL, \"0\", &hints, &addrinfo, fp->errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error_nodiscard;\n\n\t\tif ((sockdata = sock_open(addrinfo, SOCKOPEN_SERVER,\n\t\t\t1 /* max 1 connection in queue */, fp->errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n\t\t\tgoto error_nodiscard;\n\n\t\t/* addrinfo is no longer used */\n\t\tfreeaddrinfo(addrinfo);\n\t\taddrinfo = NULL;\n\n\t\t/* get the complete sockaddr structure used in the data connection */\n\t\tsaddrlen = sizeof(struct sockaddr_storage);\n\t\tif (getsockname(sockdata, (struct sockaddr *) &saddr, &saddrlen) == -1)\n\t\t{\n\t\t\tsock_geterror(\"getsockname(): \", fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\t\tgoto error_nodiscard;\n\t\t}\n\n\t\t/* Get the local port the system picked up */\n\t\tif (getnameinfo((struct sockaddr *) &saddr, saddrlen, NULL,\n\t\t\t0, portdata, sizeof(portdata), NI_NUMERICSERV))\n\t\t{\n\t\t\tsock_geterror(\"getnameinfo(): \", fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\t\tgoto error_nodiscard;\n\t\t}\n\t}\n\n\t/*\n\t * Now it's time to start playing with the RPCAP protocol\n\t * RPCAP start capture command: create the request message\n\t */\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))\n\t\tgoto error_nodiscard;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf,\n\t    pr->protocol_version, RPCAP_MSG_STARTCAP_REQ, 0,\n\t    sizeof(struct rpcap_startcapreq) + sizeof(struct rpcap_filter) + fp->fcode.bf_len * sizeof(struct rpcap_filterbpf_insn));\n\n\t/* Fill the structure needed to open an adapter remotely */\n\tstartcapreq = (struct rpcap_startcapreq *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_startcapreq), NULL,\n\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))\n\t\tgoto error_nodiscard;\n\n\tmemset(startcapreq, 0, sizeof(struct rpcap_startcapreq));\n\n\t/* By default, apply half the timeout on one side, half of the other */\n\tfp->opt.timeout = fp->opt.timeout / 2;\n\tstartcapreq->read_timeout = htonl(fp->opt.timeout);\n\n\t/* portdata on the openreq is meaningful only if we're in active mode */\n\tif ((active) || (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP))\n\t{\n\t\tsscanf(portdata, \"%d\", (int *)&(startcapreq->portdata));\t/* cast to avoid a compiler warning */\n\t\tstartcapreq->portdata = htons(startcapreq->portdata);\n\t}\n\n\tstartcapreq->snaplen = htonl(fp->snapshot);\n\tstartcapreq->flags = 0;\n\n\tif (pr->rmt_flags & PCAP_OPENFLAG_PROMISCUOUS)\n\t\tstartcapreq->flags |= RPCAP_STARTCAPREQ_FLAG_PROMISC;\n\tif (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP)\n\t\tstartcapreq->flags |= RPCAP_STARTCAPREQ_FLAG_DGRAM;\n\tif (active)\n\t\tstartcapreq->flags |= RPCAP_STARTCAPREQ_FLAG_SERVEROPEN;\n\n\tstartcapreq->flags = htons(startcapreq->flags);\n\n\t/* Pack the capture filter */\n\tif (pcap_pack_bpffilter(fp, &sendbuf[sendbufidx], &sendbufidx, &fp->fcode))\n\t\tgoto error_nodiscard;\n\n\tif (sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, sendbuf, sendbufidx, fp->errbuf,\n\t    PCAP_ERRBUF_SIZE) < 0)\n\t\tgoto error_nodiscard;\n\n\t/* Receive and process the reply message header. */\n\tif (rpcap_process_msg_header(pr->rmt_sockctrl, pr->ctrl_ssl, pr->protocol_version,\n\t    RPCAP_MSG_STARTCAP_REQ, &header, fp->errbuf) == -1)\n\t\tgoto error_nodiscard;\n\n\tplen = header.plen;\n\n\tif (rpcap_recv(pr->rmt_sockctrl, pr->ctrl_ssl, (char *)&startcapreply,\n\t    sizeof(struct rpcap_startcapreply), &plen, fp->errbuf) == -1)\n\t\tgoto error;\n\n\t/*\n\t * In case of UDP data stream, the connection is always opened by the daemon\n\t * So, this case is already covered by the code above.\n\t * Now, we have still to handle TCP connections, because:\n\t * - if we're in active mode, we have to wait for a remote connection\n\t * - if we're in passive more, we have to start a connection\n\t *\n\t * We have to do he job in two steps because in case we're opening a TCP connection, we have\n\t * to tell the port we're using to the remote side; in case we're accepting a TCP\n\t * connection, we have to wait this info from the remote side.\n\t */\n\tif (!(pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP))\n\t{\n\t\tif (!active)\n\t\t{\n\t\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\t\thints.ai_family = ai_family;\t\t/* Use the same address family of the control socket */\n\t\t\thints.ai_socktype = (pr->rmt_flags & PCAP_OPENFLAG_DATATX_UDP) ? SOCK_DGRAM : SOCK_STREAM;\n\t\t\tpcap_snprintf(portdata, PCAP_BUF_SIZE, \"%d\", ntohs(startcapreply.portdata));\n\n\t\t\t/* Let's the server pick up a free network port for us */\n\t\t\tif (sock_initaddress(host, portdata, &hints, &addrinfo, fp->errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\tgoto error;\n\n\t\t\tif ((sockdata = sock_open(addrinfo, SOCKOPEN_CLIENT, 0, fp->errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n\t\t\t\tgoto error;\n\n\t\t\t/* addrinfo is no longer used */\n\t\t\tfreeaddrinfo(addrinfo);\n\t\t\taddrinfo = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSOCKET socktemp;\t/* We need another socket, since we're going to accept() a connection */\n\n\t\t\t/* Connection creation */\n\t\t\tsaddrlen = sizeof(struct sockaddr_storage);\n\n\t\t\tsocktemp = accept(sockdata, (struct sockaddr *) &saddr, &saddrlen);\n\n\t\t\tif (socktemp == INVALID_SOCKET)\n\t\t\t{\n\t\t\t\tsock_geterror(\"accept(): \", fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t/* Now that I accepted the connection, the server socket is no longer needed */\n\t\t\tsock_close(sockdata, fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\t\tsockdata = socktemp;\n\t\t}\n\t}\n\n\t/* Let's save the socket of the data connection */\n\tpr->rmt_sockdata = sockdata;\n\n#ifdef HAVE_OPENSSL\n\tif (pr->uses_ssl)\n\t{\n\t\tpr->data_ssl = ssl_promotion(0, sockdata, fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\tif (! pr->data_ssl) goto error;\n\t}\n#endif\n\n\t/*\n\t * Set the size of the socket buffer for the data socket.\n\t * It has the same size as the local capture buffer used\n\t * on the other side of the connection.\n\t */\n\tserver_sockbufsize = ntohl(startcapreply.bufsize);\n\n\t/* Let's get the actual size of the socket buffer */\n\titemp = sizeof(sockbufsize);\n\n\tres = getsockopt(sockdata, SOL_SOCKET, SO_RCVBUF, (char *)&sockbufsize, &itemp);\n\tif (res == -1)\n\t{\n\t\tsock_geterror(\"pcap_startcapture_remote()\", fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\tgoto error;\n\t}\n\n\t/*\n\t * Warning: on some kernels (e.g. Linux), the size of the user\n\t * buffer does not take into account the pcap_header and such,\n\t * and it is set equal to the snaplen.\n\t *\n\t * In my view, this is wrong (the meaning of the bufsize became\n\t * a bit strange).  So, here bufsize is the whole size of the\n\t * user buffer.  In case the bufsize returned is too small,\n\t * let's adjust it accordingly.\n\t */\n\tif (server_sockbufsize <= (u_int) fp->snapshot)\n\t\tserver_sockbufsize += sizeof(struct pcap_pkthdr);\n\n\t/* if the current socket buffer is smaller than the desired one */\n\tif ((u_int) sockbufsize < server_sockbufsize)\n\t{\n\t\t/*\n\t\t * Loop until the buffer size is OK or the original\n\t\t * socket buffer size is larger than this one.\n\t\t */\n\t\tfor (;;)\n\t\t{\n\t\t\tres = setsockopt(sockdata, SOL_SOCKET, SO_RCVBUF,\n\t\t\t    (char *)&(server_sockbufsize),\n\t\t\t    sizeof(server_sockbufsize));\n\n\t\t\tif (res == 0)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * If something goes wrong, halve the buffer size\n\t\t\t * (checking that it does not become smaller than\n\t\t\t * the current one).\n\t\t\t */\n\t\t\tserver_sockbufsize /= 2;\n\n\t\t\tif ((u_int) sockbufsize >= server_sockbufsize)\n\t\t\t{\n\t\t\t\tserver_sockbufsize = sockbufsize;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Let's allocate the packet; this is required in order to put\n\t * the packet somewhere when extracting data from the socket.\n\t * Since buffering has already been done in the socket buffer,\n\t * here we need just a buffer whose size is equal to the\n\t * largest possible packet message for the snapshot size,\n\t * namely the length of the message header plus the length\n\t * of the packet header plus the snapshot length.\n\t */\n\tfp->bufsize = sizeof(struct rpcap_header) + sizeof(struct rpcap_pkthdr) + fp->snapshot;\n\n\tfp->buffer = (u_char *)malloc(fp->bufsize);\n\tif (fp->buffer == NULL)\n\t{\n\t\tpcap_fmt_errmsg_for_errno(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tgoto error;\n\t}\n\n\t/*\n\t * The buffer is currently empty.\n\t */\n\tfp->bp = fp->buffer;\n\tfp->cc = 0;\n\n\t/* Discard the rest of the message. */\n\tif (rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, plen, fp->errbuf) == -1)\n\t\tgoto error_nodiscard;\n\n\t/*\n\t * In case the user does not want to capture RPCAP packets, let's update the filter\n\t * We have to update it here (instead of sending it into the 'StartCapture' message\n\t * because when we generate the 'start capture' we do not know (yet) all the ports\n\t * we're currently using.\n\t */\n\tif (pr->rmt_flags & PCAP_OPENFLAG_NOCAPTURE_RPCAP)\n\t{\n\t\tstruct bpf_program fcode;\n\n\t\tif (pcap_createfilter_norpcappkt(fp, &fcode) == -1)\n\t\t\tgoto error;\n\n\t\t/* We cannot use 'pcap_setfilter_rpcap' because formally the capture has not been started yet */\n\t\t/* (the 'pr->rmt_capstarted' variable will be updated some lines below) */\n\t\tif (pcap_updatefilter_remote(fp, &fcode) == -1)\n\t\t\tgoto error;\n\n\t\tpcap_freecode(&fcode);\n\t}\n\n\tpr->rmt_capstarted = 1;\n\treturn 0;\n\nerror:\n\t/*\n\t * When the connection has been established, we have to close it. So, at the\n\t * beginning of this function, if an error occur we return immediately with\n\t * a return NULL; when the connection is established, we have to come here\n\t * ('goto error;') in order to close everything properly.\n\t */\n\n\t/*\n\t * Discard the rest of the message.\n\t * We already reported an error; if this gets an error, just\n\t * drive on.\n\t */\n\t(void)rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, plen, NULL);\n\nerror_nodiscard:\n#ifdef HAVE_OPENSSL\n\tif (pr->data_ssl)\n\t{\n\t\t// Finish using the SSL handle for the data socket.\n\t\t// This must be done *before* the socket is closed.\n\t\tssl_finish(pr->data_ssl);\n\t\tpr->data_ssl = NULL;\n\t}\n#endif\n\n\tif ((sockdata) && (sockdata != -1))\t\t/* we can be here because sockdata said 'error' */\n\t\tsock_close(sockdata, NULL, 0);\n\n\tif (!active)\n\t{\n#ifdef HAVE_OPENSSL\n\t\tif (pr->ctrl_ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the control socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(pr->ctrl_ssl);\n\t\t\tpr->ctrl_ssl = NULL;\n\t\t}\n#endif\n\t\tsock_close(pr->rmt_sockctrl, NULL, 0);\n\t}\n\n\tif (addrinfo != NULL)\n\t\tfreeaddrinfo(addrinfo);\n\n\t/*\n\t * We do not have to call pcap_close() here, because this function is always called\n\t * by the user in case something bad happens\n\t */\n#if 0\n\tif (fp)\n\t{\n\t\tpcap_close(fp);\n\t\tfp= NULL;\n\t}\n#endif\n\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              1049,
              0
            ],
            [
              1473,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_startcapture_remote",
            "parameters": {
              "fp": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_pack_bpffilter(pcap_t *fp, char *sendbuf, int *sendbufidx, struct bpf_program *prog)\n{\n\tstruct rpcap_filter *filter;\n\tstruct rpcap_filterbpf_insn *insn;\n\tstruct bpf_insn *bf_insn;\n\tstruct bpf_program fake_prog;\t\t/* To be used just in case the user forgot to set a filter */\n\tunsigned int i;\n\n\tif (prog->bf_len == 0)\t/* No filters have been specified; so, let's apply a \"fake\" filter */\n\t{\n\t\tif (pcap_compile(fp, &fake_prog, NULL /* buffer */, 1, 0) == -1)\n\t\t\treturn -1;\n\n\t\tprog = &fake_prog;\n\t}\n\n\tfilter = (struct rpcap_filter *) sendbuf;\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_filter), NULL, sendbufidx,\n\t\tRPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\tfilter->filtertype = htons(RPCAP_UPDATEFILTER_BPF);\n\tfilter->nitems = htonl((int32)prog->bf_len);\n\n\tif (sock_bufferize(NULL, prog->bf_len * sizeof(struct rpcap_filterbpf_insn),\n\t\tNULL, sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\tinsn = (struct rpcap_filterbpf_insn *) (filter + 1);\n\tbf_insn = prog->bf_insns;\n\n\tfor (i = 0; i < prog->bf_len; i++)\n\t{\n\t\tinsn->code = htons(bf_insn->code);\n\t\tinsn->jf = bf_insn->jf;\n\t\tinsn->jt = bf_insn->jt;\n\t\tinsn->k = htonl(bf_insn->k);\n\n\t\tinsn++;\n\t\tbf_insn++;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1499,
              0
            ],
            [
              1543,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_pack_bpffilter",
            "parameters": {
              "fp": "pcap_t",
              "sendbuf": "char",
              "sendbufidx": "int",
              "prog": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_updatefilter_remote(pcap_t *fp, struct bpf_program *prog)\n{\n\tstruct pcap_rpcap *pr = fp->priv;\t/* structure used when doing a remote live capture */\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t/* temporary buffer in which data to be sent is buffered */\n\tint sendbufidx = 0;\t\t\t/* index which keeps the number of bytes currently buffered */\n\tstruct rpcap_header header;\t\t/* To keep the reply message */\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t\tRPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf,\n\t    pr->protocol_version, RPCAP_MSG_UPDATEFILTER_REQ, 0,\n\t    sizeof(struct rpcap_filter) + prog->bf_len * sizeof(struct rpcap_filterbpf_insn));\n\n\tif (pcap_pack_bpffilter(fp, &sendbuf[sendbufidx], &sendbufidx, prog))\n\t\treturn -1;\n\n\tif (sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, sendbuf, sendbufidx, fp->errbuf,\n\t    PCAP_ERRBUF_SIZE) < 0)\n\t\treturn -1;\n\n\t/* Receive and process the reply message header. */\n\tif (rpcap_process_msg_header(pr->rmt_sockctrl, pr->ctrl_ssl, pr->protocol_version,\n\t    RPCAP_MSG_UPDATEFILTER_REQ, &header, fp->errbuf) == -1)\n\t\treturn -1;\n\n\t/*\n\t * It shouldn't have any contents; discard it if it does.\n\t */\n\tif (rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, header.plen, fp->errbuf) == -1)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1570,
              0
            ],
            [
              1604,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_updatefilter_remote",
            "parameters": {
              "fp": "pcap_t",
              "prog": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\npcap_save_current_filter_rpcap(pcap_t *fp, const char *filter)\n{\n\tstruct pcap_rpcap *pr = fp->priv;\t/* structure used when doing a remote live capture */\n\n\t/*\n\t * Check if:\n\t *  - We are on an remote capture\n\t *  - we do not want to capture RPCAP traffic\n\t *\n\t * If so, we have to save the current filter, because we have to\n\t * add some piece of stuff later\n\t */\n\tif (pr->rmt_clientside &&\n\t    (pr->rmt_flags & PCAP_OPENFLAG_NOCAPTURE_RPCAP))\n\t{\n\t\tif (pr->currentfilter)\n\t\t\tfree(pr->currentfilter);\n\n\t\tif (filter == NULL)\n\t\t\tfilter = \"\";\n\n\t\tpr->currentfilter = strdup(filter);\n\t}\n}",
          "fn_code_pos": [
            [
              1606,
              0
            ],
            [
              1630,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_save_current_filter_rpcap",
            "parameters": {
              "fp": "pcap_t",
              "filter": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int pcap_setfilter_rpcap(pcap_t *fp, struct bpf_program *prog)\n{\n\tstruct pcap_rpcap *pr = fp->priv;\t/* structure used when doing a remote live capture */\n\n\tif (!pr->rmt_capstarted)\n\t{\n\t\t/* copy filter into the pcap_t structure */\n\t\tif (install_bpf_program(fp, prog) == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\t/* we have to update a filter during run-time */\n\tif (pcap_updatefilter_remote(fp, prog))\n\t\treturn -1;\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1641,
              0
            ],
            [
              1658,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_rpcap",
            "parameters": {
              "fp": "pcap_t",
              "prog": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_createfilter_norpcappkt(pcap_t *fp, struct bpf_program *prog)\n{\n\tstruct pcap_rpcap *pr = fp->priv;\t/* structure used when doing a remote live capture */\n\tint RetVal = 0;\n\n\t/* We do not want to capture our RPCAP traffic. So, let's update the filter */\n\tif (pr->rmt_flags & PCAP_OPENFLAG_NOCAPTURE_RPCAP)\n\t{\n\t\tstruct sockaddr_storage saddr;\t\t/* temp, needed to retrieve the network data port chosen on the local machine */\n\t\tsocklen_t saddrlen;\t\t\t\t\t/* temp, needed to retrieve the network data port chosen on the local machine */\n\t\tchar myaddress[128];\n\t\tchar myctrlport[128];\n\t\tchar mydataport[128];\n\t\tchar peeraddress[128];\n\t\tchar peerctrlport[128];\n\t\tchar *newfilter;\n\n\t\t/* Get the name/port of our peer */\n\t\tsaddrlen = sizeof(struct sockaddr_storage);\n\t\tif (getpeername(pr->rmt_sockctrl, (struct sockaddr *) &saddr, &saddrlen) == -1)\n\t\t{\n\t\t\tsock_geterror(\"getpeername(): \", fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (getnameinfo((struct sockaddr *) &saddr, saddrlen, peeraddress,\n\t\t\tsizeof(peeraddress), peerctrlport, sizeof(peerctrlport), NI_NUMERICHOST | NI_NUMERICSERV))\n\t\t{\n\t\t\tsock_geterror(\"getnameinfo(): \", fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* We cannot check the data port, because this is available only in case of TCP sockets */\n\t\t/* Get the name/port of the current host */\n\t\tif (getsockname(pr->rmt_sockctrl, (struct sockaddr *) &saddr, &saddrlen) == -1)\n\t\t{\n\t\t\tsock_geterror(\"getsockname(): \", fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Get the local port the system picked up */\n\t\tif (getnameinfo((struct sockaddr *) &saddr, saddrlen, myaddress,\n\t\t\tsizeof(myaddress), myctrlport, sizeof(myctrlport), NI_NUMERICHOST | NI_NUMERICSERV))\n\t\t{\n\t\t\tsock_geterror(\"getnameinfo(): \", fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Let's now check the data port */\n\t\tif (getsockname(pr->rmt_sockdata, (struct sockaddr *) &saddr, &saddrlen) == -1)\n\t\t{\n\t\t\tsock_geterror(\"getsockname(): \", fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Get the local port the system picked up */\n\t\tif (getnameinfo((struct sockaddr *) &saddr, saddrlen, NULL, 0, mydataport, sizeof(mydataport), NI_NUMERICSERV))\n\t\t{\n\t\t\tsock_geterror(\"getnameinfo(): \", fp->errbuf, PCAP_ERRBUF_SIZE);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pr->currentfilter && pr->currentfilter[0] != '\\0')\n\t\t{\n\t\t\t/*\n\t\t\t * We have a current filter; add items to it to\n\t\t\t * filter out this rpcap session.\n\t\t\t */\n\t\t\tif (pcap_asprintf(&newfilter,\n\t\t\t    \"(%s) and not (host %s and host %s and port %s and port %s) and not (host %s and host %s and port %s)\",\n\t\t\t    pr->currentfilter, myaddress, peeraddress,\n\t\t\t    myctrlport, peerctrlport, myaddress, peeraddress,\n\t\t\t    mydataport) == -1)\n\t\t\t{\n\t\t\t\t/* Failed. */\n\t\t\t\tpcap_snprintf(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Can't allocate memory for new filter\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * We have no current filter; construct a filter to\n\t\t\t * filter out this rpcap session.\n\t\t\t */\n\t\t\tif (pcap_asprintf(&newfilter,\n\t\t\t    \"not (host %s and host %s and port %s and port %s) and not (host %s and host %s and port %s)\",\n\t\t\t    myaddress, peeraddress, myctrlport, peerctrlport,\n\t\t\t    myaddress, peeraddress, mydataport) == -1)\n\t\t\t{\n\t\t\t\t/* Failed. */\n\t\t\t\tpcap_snprintf(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Can't allocate memory for new filter\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * This is only an hack to prevent the save_current_filter\n\t\t * routine, which will be called when we call pcap_compile(),\n\t\t * from saving the modified filter.\n\t\t */\n\t\tpr->rmt_clientside = 0;\n\n\t\tif (pcap_compile(fp, prog, newfilter, 1, 0) == -1)\n\t\t\tRetVal = -1;\n\n\t\t/* Undo the hack. */\n\t\tpr->rmt_clientside = 1;\n\n\t\tfree(newfilter);\n\t}\n\n\treturn RetVal;\n}",
          "fn_code_pos": [
            [
              1670,
              0
            ],
            [
              1785,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_createfilter_norpcappkt",
            "parameters": {
              "fp": "pcap_t",
              "prog": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_setsampling_remote(pcap_t *fp)\n{\n\tstruct pcap_rpcap *pr = fp->priv;\t/* structure used when doing a remote live capture */\n\tchar sendbuf[RPCAP_NETBUF_SIZE];/* temporary buffer in which data to be sent is buffered */\n\tint sendbufidx = 0;\t\t\t/* index which keeps the number of bytes currently buffered */\n\tstruct rpcap_header header;\t\t/* To keep the reply message */\n\tstruct rpcap_sampling *sampling_pars;\t/* Structure that is needed to send sampling parameters to the remote host */\n\n\t/* If no samping is requested, return 'ok' */\n\tif (fp->rmt_samp.method == PCAP_SAMP_NOSAMP)\n\t\treturn 0;\n\n\t/*\n\t * Check for sampling parameters that don't fit in a message.\n\t * We'll let the server complain about invalid parameters\n\t * that do fit into the message.\n\t */\n\tif (fp->rmt_samp.method < 0 || fp->rmt_samp.method > 255) {\n\t\tpcap_snprintf(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Invalid sampling method %d\", fp->rmt_samp.method);\n\t\treturn -1;\n\t}\n\tif (fp->rmt_samp.value < 0 || fp->rmt_samp.value > 65535) {\n\t\tpcap_snprintf(fp->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Invalid sampling value %d\", fp->rmt_samp.value);\n\t\treturn -1;\n\t}\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf,\n\t    pr->protocol_version, RPCAP_MSG_SETSAMPLING_REQ, 0,\n\t    sizeof(struct rpcap_sampling));\n\n\t/* Fill the structure needed to open an adapter remotely */\n\tsampling_pars = (struct rpcap_sampling *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_sampling), NULL,\n\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, fp->errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\tmemset(sampling_pars, 0, sizeof(struct rpcap_sampling));\n\n\tsampling_pars->method = (uint8)fp->rmt_samp.method;\n\tsampling_pars->value = (uint16)htonl(fp->rmt_samp.value);\n\n\tif (sock_send(pr->rmt_sockctrl, pr->ctrl_ssl, sendbuf, sendbufidx, fp->errbuf,\n\t    PCAP_ERRBUF_SIZE) < 0)\n\t\treturn -1;\n\n\t/* Receive and process the reply message header. */\n\tif (rpcap_process_msg_header(pr->rmt_sockctrl, pr->ctrl_ssl, pr->protocol_version,\n\t    RPCAP_MSG_SETSAMPLING_REQ, &header, fp->errbuf) == -1)\n\t\treturn -1;\n\n\t/*\n\t * It shouldn't have any contents; discard it if it does.\n\t */\n\tif (rpcap_discard(pr->rmt_sockctrl, pr->ctrl_ssl, header.plen, fp->errbuf) == -1)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1800,
              0
            ],
            [
              1864,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setsampling_remote",
            "parameters": {
              "fp": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int rpcap_doauth(SOCKET sockctrl, SSL *ssl, uint8 *ver, struct pcap_rmtauth *auth, char *errbuf)\n{\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t/* temporary buffer in which data that has to be sent is buffered */\n\tint sendbufidx = 0;\t\t\t/* index which keeps the number of bytes currently buffered */\n\tuint16 length;\t\t\t\t/* length of the payload of this message */\n\tstruct rpcap_auth *rpauth;\n\tuint16 auth_type;\n\tstruct rpcap_header header;\n\tsize_t str_length;\n\tuint32 plen;\n\tstruct rpcap_authreply authreply;\t/* authentication reply message */\n\tuint8 ourvers;\n\n\tif (auth)\n\t{\n\t\tswitch (auth->type)\n\t\t{\n\t\tcase RPCAP_RMTAUTH_NULL:\n\t\t\tlength = sizeof(struct rpcap_auth);\n\t\t\tbreak;\n\n\t\tcase RPCAP_RMTAUTH_PWD:\n\t\t\tlength = sizeof(struct rpcap_auth);\n\t\t\tif (auth->username)\n\t\t\t{\n\t\t\t\tstr_length = strlen(auth->username);\n\t\t\t\tif (str_length > 65535)\n\t\t\t\t{\n\t\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"User name is too long (> 65535 bytes)\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tlength += (uint16)str_length;\n\t\t\t}\n\t\t\tif (auth->password)\n\t\t\t{\n\t\t\t\tstr_length = strlen(auth->password);\n\t\t\t\tif (str_length > 65535)\n\t\t\t\t{\n\t\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Password is too long (> 65535 bytes)\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tlength += (uint16)str_length;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication type not recognized.\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tauth_type = (uint16)auth->type;\n\t}\n\telse\n\t{\n\t\tauth_type = RPCAP_RMTAUTH_NULL;\n\t\tlength = sizeof(struct rpcap_auth);\n\t}\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, 0,\n\t    RPCAP_MSG_AUTH_REQ, 0, length);\n\n\trpauth = (struct rpcap_auth *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_auth), NULL,\n\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\tmemset(rpauth, 0, sizeof(struct rpcap_auth));\n\n\trpauth->type = htons(auth_type);\n\n\tif (auth_type == RPCAP_RMTAUTH_PWD)\n\t{\n\t\tif (auth->username)\n\t\t\trpauth->slen1 = (uint16)strlen(auth->username);\n\t\telse\n\t\t\trpauth->slen1 = 0;\n\n\t\tif (sock_bufferize(auth->username, rpauth->slen1, sendbuf,\n\t\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf, PCAP_ERRBUF_SIZE))\n\t\t\treturn -1;\n\n\t\tif (auth->password)\n\t\t\trpauth->slen2 = (uint16)strlen(auth->password);\n\t\telse\n\t\t\trpauth->slen2 = 0;\n\n\t\tif (sock_bufferize(auth->password, rpauth->slen2, sendbuf,\n\t\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf, PCAP_ERRBUF_SIZE))\n\t\t\treturn -1;\n\n\t\trpauth->slen1 = htons(rpauth->slen1);\n\t\trpauth->slen2 = htons(rpauth->slen2);\n\t}\n\n\tif (sock_send(sockctrl, ssl, sendbuf, sendbufidx, errbuf,\n\t    PCAP_ERRBUF_SIZE) < 0)\n\t\treturn -1;\n\n\t/* Receive and process the reply message header */\n\tif (rpcap_process_msg_header(sockctrl, ssl, 0, RPCAP_MSG_AUTH_REQ,\n\t    &header, errbuf) == -1)\n\t\treturn -1;\n\n\t/*\n\t * OK, it's an authentication reply, so we're logged in.\n\t *\n\t * Did it send any additional information?\n\t */\n\tplen = header.plen;\n\tif (plen != 0)\n\t{\n\t\t/* Yes - is it big enough to be version information? */\n\t\tif (plen < sizeof(struct rpcap_authreply))\n\t\t{\n\t\t\t/* No - discard it and fail. */\n\t\t\t(void)rpcap_discard(sockctrl, ssl, plen, NULL);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Read the reply body */\n\t\tif (rpcap_recv(sockctrl, ssl, (char *)&authreply,\n\t\t    sizeof(struct rpcap_authreply), &plen, errbuf) == -1)\n\t\t{\n\t\t\t(void)rpcap_discard(sockctrl, ssl, plen, NULL);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Discard the rest of the message, if there is any. */\n\t\tif (rpcap_discard(sockctrl, ssl, plen, errbuf) == -1)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Check the minimum and maximum versions for sanity;\n\t\t * the minimum must be <= the maximum.\n\t\t */\n\t\tif (authreply.minvers > authreply.maxvers)\n\t\t{\n\t\t\t/*\n\t\t\t * Bogus - give up on this server.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"The server's minimum supported protocol version is greater than its maximum supported protocol version\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* No - it supports only version 0. */\n\t\tauthreply.minvers = 0;\n\t\tauthreply.maxvers = 0;\n\t}\n\n\t/*\n\t * OK, let's start with the maximum version the server supports.\n\t */\n\tourvers = authreply.maxvers;\n\n#if RPCAP_MIN_VERSION != 0\n\t/*\n\t * If that's less than the minimum version we support, we\n\t * can't communicate.\n\t */\n\tif (ourvers < RPCAP_MIN_VERSION)\n\t\tgoto novers;\n#endif\n\n\t/*\n\t * If that's greater than the maximum version we support,\n\t * choose the maximum version we support.\n\t */\n\tif (ourvers > RPCAP_MAX_VERSION)\n\t{\n\t\tourvers = RPCAP_MAX_VERSION;\n\n\t\t/*\n\t\t * If that's less than the minimum version they\n\t\t * support, we can't communicate.\n\t\t */\n\t\tif (ourvers < authreply.minvers)\n\t\t\tgoto novers;\n\t}\n\n\t*ver = ourvers;\n\treturn 0;\n\nnovers:\n\t/*\n\t * There is no version we both support; that is a fatal error.\n\t */\n\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The server doesn't support any protocol version that we support\");\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              1904,
              0
            ],
            [
              2101,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_doauth",
            "parameters": {
              "sockctrl": "SOCKET",
              "ssl": "SSL",
              "ver": "uint8",
              "auth": "struct pcap_rmtauth",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_getnonblock_rpcap(pcap_t *p)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Non-blocking mode isn't supported for capturing remotely with rpcap\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              2104,
              0
            ],
            [
              2110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getnonblock_rpcap",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setnonblock_rpcap(pcap_t *p, int nonblock _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Non-blocking mode isn't supported for capturing remotely with rpcap\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              2112,
              0
            ],
            [
              2118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setnonblock_rpcap",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nrpcap_setup_session(const char *source, struct pcap_rmtauth *auth,\n    int *activep, SOCKET *sockctrlp, uint8 *uses_sslp, SSL **sslp,\n    int rmt_flags, uint8 *protocol_versionp, char *host, char *port,\n    char *iface, char *errbuf)\n{\n\tint type;\n\tstruct activehosts *activeconn;\t\t/* active connection, if there is one */\n\tint error;\t\t\t\t/* 1 if rpcap_remoteact_getsock got an error */\n\n\t/*\n\t * Determine the type of the source (NULL, file, local, remote).\n\t * You must have a valid source string even if we're in active mode,\n\t * because otherwise the call to the following function will fail.\n\t */\n\tif (pcap_parsesrcstr_ex(source, &type, host, port, iface, uses_sslp,\n\t    errbuf) == -1)\n\t\treturn -1;\n\n\t/*\n\t * It must be remote.\n\t */\n\tif (type != PCAP_SRC_IFREMOTE)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Non-remote interface passed to remote capture routine\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * We don't yet support DTLS, so if the user asks for a TLS\n\t * connection and asks for data packets to be sent over UDP,\n\t * we have to give up.\n\t */\n\tif (*uses_sslp && (rmt_flags & PCAP_OPENFLAG_DATATX_UDP))\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"TLS not supported with UDP forward of remote packets\");\n\t\treturn -1;\n\t}\n\n\t/* Warning: this call can be the first one called by the user. */\n\t/* For this reason, we have to initialize the WinSock support. */\n\tif (sock_init(errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\treturn -1;\n\n\t/* Check for active mode */\n\tactiveconn = rpcap_remoteact_getsock(host, &error, errbuf);\n\tif (activeconn != NULL)\n\t{\n\t\t*activep = 1;\n\t\t*sockctrlp = activeconn->sockctrl;\n\t\t*sslp = activeconn->ssl;\n\t\t*protocol_versionp = activeconn->protocol_version;\n\t}\n\telse\n\t{\n\t\t*activep = 0;\n\t\tstruct addrinfo hints;\t\t/* temp variable needed to resolve hostnames into to socket representation */\n\t\tstruct addrinfo *addrinfo;\t/* temp variable needed to resolve hostnames into to socket representation */\n\n\t\tif (error)\n\t\t{\n\t\t\t/*\n\t\t\t * Call failed.\n\t\t\t */\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * We're not in active mode; let's try to open a new\n\t\t * control connection.\n\t\t */\n\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\thints.ai_family = PF_UNSPEC;\n\t\thints.ai_socktype = SOCK_STREAM;\n\n\t\tif (port[0] == 0)\n\t\t{\n\t\t\t/* the user chose not to specify the port */\n\t\t\tif (sock_initaddress(host, RPCAP_DEFAULT_NETPORT,\n\t\t\t    &hints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (sock_initaddress(host, port, &hints, &addrinfo,\n\t\t\t    errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif ((*sockctrlp = sock_open(addrinfo, SOCKOPEN_CLIENT, 0,\n\t\t    errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n\t\t{\n\t\t\tfreeaddrinfo(addrinfo);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* addrinfo is no longer used */\n\t\tfreeaddrinfo(addrinfo);\n\t\taddrinfo = NULL;\n\n\t\tif (*uses_sslp)\n\t\t{\n#ifdef HAVE_OPENSSL\n\t\t\t*sslp = ssl_promotion(0, *sockctrlp, errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE);\n\t\t\tif (!*sslp)\n\t\t\t{\n\t\t\t\tsock_close(*sockctrlp, NULL, 0);\n\t\t\t\treturn -1;\n\t\t\t}\n#else\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"No TLS support\");\n\t\t\tsock_close(*sockctrlp, NULL, 0);\n\t\t\treturn -1;\n#endif\n\t\t}\n\n\t\tif (rpcap_doauth(*sockctrlp, *sslp, protocol_versionp, auth,\n\t\t    errbuf) == -1)\n\t\t{\n#ifdef HAVE_OPENSSL\n\t\t\tif (*sslp)\n\t\t\t{\n\t\t\t\t// Finish using the SSL handle for the socket.\n\t\t\t\t// This must be done *before* the socket is\n\t\t\t\t// closed.\n\t\t\t\tssl_finish(*sslp);\n\t\t\t}\n#endif\n\t\t\tsock_close(*sockctrlp, NULL, 0);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              2120,
              0
            ],
            [
              2257,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_setup_session",
            "parameters": {
              "source": "char",
              "auth": "struct pcap_rmtauth",
              "activep": "int",
              "sockctrlp": "SOCKET",
              "uses_sslp": "uint8",
              "sslp": "SSL",
              "rmt_flags": "int",
              "protocol_versionp": "uint8",
              "host": "char",
              "port": "char",
              "iface": "char",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *pcap_open_rpcap(const char *source, int snaplen, int flags, int read_timeout, struct pcap_rmtauth *auth, char *errbuf)\n{\n\tpcap_t *fp;\n\tchar *source_str;\n\tstruct pcap_rpcap *pr;\t\t/* structure used when doing a remote live capture */\n\tchar host[PCAP_BUF_SIZE], ctrlport[PCAP_BUF_SIZE], iface[PCAP_BUF_SIZE];\n\tSOCKET sockctrl;\n\tSSL *ssl = NULL;\n\tuint8 protocol_version;\t\t\t/* negotiated protocol version */\n\tint active;\n\tuint32 plen;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t/* temporary buffer in which data to be sent is buffered */\n\tint sendbufidx = 0;\t\t\t/* index which keeps the number of bytes currently buffered */\n\n\t/* RPCAP-related variables */\n\tstruct rpcap_header header;\t\t/* header of the RPCAP packet */\n\tstruct rpcap_openreply openreply;\t/* open reply message */\n\n\tfp = pcap_create_common(errbuf, sizeof (struct pcap_rpcap));\n\tif (fp == NULL)\n\t{\n\t\treturn NULL;\n\t}\n\tsource_str = strdup(source);\n\tif (source_str == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t *\n\t * XXX - should we leave this up to the remote server to\n\t * do?\n\t */\n\tif (snaplen <= 0 || snaplen > MAXIMUM_SNAPLEN)\n\t\tsnaplen = MAXIMUM_SNAPLEN;\n\n\tfp->opt.device = source_str;\n\tfp->snapshot = snaplen;\n\tfp->opt.timeout = read_timeout;\n\tpr = fp->priv;\n\tpr->rmt_flags = flags;\n\n\t/*\n\t * Attempt to set up the session with the server.\n\t */\n\tif (rpcap_setup_session(fp->opt.device, auth, &active, &sockctrl,\n\t    &pr->uses_ssl, &ssl, flags, &protocol_version, host, ctrlport,\n\t    iface, errbuf) == -1)\n\t{\n\t\t/* Session setup failed. */\n\t\tpcap_close(fp);\n\t\treturn NULL;\n\t}\n\n\t/* All good so far, save the ssl handler */\n\tssl_main = ssl;\n\n\t/*\n\t * Now it's time to start playing with the RPCAP protocol\n\t * RPCAP open command: create the request message\n\t */\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t\t&sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf, PCAP_ERRBUF_SIZE))\n\t\tgoto error_nodiscard;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, protocol_version,\n\t    RPCAP_MSG_OPEN_REQ, 0, (uint32) strlen(iface));\n\n\tif (sock_bufferize(iface, (int) strlen(iface), sendbuf, &sendbufidx,\n\t\tRPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf, PCAP_ERRBUF_SIZE))\n\t\tgoto error_nodiscard;\n\n\tif (sock_send(sockctrl, ssl, sendbuf, sendbufidx, errbuf,\n\t    PCAP_ERRBUF_SIZE) < 0)\n\t\tgoto error_nodiscard;\n\n\t/* Receive and process the reply message header. */\n\tif (rpcap_process_msg_header(sockctrl, ssl, protocol_version,\n\t    RPCAP_MSG_OPEN_REQ, &header, errbuf) == -1)\n\t\tgoto error_nodiscard;\n\tplen = header.plen;\n\n\t/* Read the reply body */\n\tif (rpcap_recv(sockctrl, ssl, (char *)&openreply,\n\t    sizeof(struct rpcap_openreply), &plen, errbuf) == -1)\n\t\tgoto error;\n\n\t/* Discard the rest of the message, if there is any. */\n\tif (rpcap_discard(sockctrl, ssl, plen, errbuf) == -1)\n\t\tgoto error_nodiscard;\n\n\t/* Set proper fields into the pcap_t struct */\n\tfp->linktype = ntohl(openreply.linktype);\n\tpr->rmt_sockctrl = sockctrl;\n\tpr->ctrl_ssl = ssl;\n\tpr->protocol_version = protocol_version;\n\tpr->rmt_clientside = 1;\n\n\t/* This code is duplicated from the end of this function */\n\tfp->read_op = pcap_read_rpcap;\n\tfp->save_current_filter_op = pcap_save_current_filter_rpcap;\n\tfp->setfilter_op = pcap_setfilter_rpcap;\n\tfp->getnonblock_op = pcap_getnonblock_rpcap;\n\tfp->setnonblock_op = pcap_setnonblock_rpcap;\n\tfp->stats_op = pcap_stats_rpcap;\n#ifdef _WIN32\n\tfp->stats_ex_op = pcap_stats_ex_rpcap;\n#endif\n\tfp->cleanup_op = pcap_cleanup_rpcap;\n\n\tfp->activated = 1;\n\treturn fp;\n\nerror:\n\t/*\n\t * When the connection has been established, we have to close it. So, at the\n\t * beginning of this function, if an error occur we return immediately with\n\t * a return NULL; when the connection is established, we have to come here\n\t * ('goto error;') in order to close everything properly.\n\t */\n\n\t/*\n\t * Discard the rest of the message.\n\t * We already reported an error; if this gets an error, just\n\t * drive on.\n\t */\n\t(void)rpcap_discard(sockctrl, pr->ctrl_ssl, plen, NULL);\n\nerror_nodiscard:\n\tif (!active)\n\t{\n#ifdef HAVE_OPENSSL\n\t\tif (ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(ssl);\n\t\t}\n#endif\n\t\tsock_close(sockctrl, NULL, 0);\n\t}\n\n\tpcap_close(fp);\n\treturn NULL;\n}",
          "fn_code_pos": [
            [
              2298,
              0
            ],
            [
              2450,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_rpcap",
            "parameters": {
              "source": "char",
              "snaplen": "int",
              "flags": "int",
              "read_timeout": "int",
              "auth": "struct pcap_rmtauth",
              "errbuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static void\nfreeaddr(struct pcap_addr *addr)\n{\n\tfree(addr->addr);\n\tfree(addr->netmask);\n\tfree(addr->broadaddr);\n\tfree(addr->dstaddr);\n\tfree(addr);\n}",
          "fn_code_pos": [
            [
              2459,
              0
            ],
            [
              2467,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "freeaddr",
            "parameters": {
              "addr": "struct pcap_addr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\npcap_findalldevs_ex_remote(const char *source, struct pcap_rmtauth *auth, pcap_if_t **alldevs, char *errbuf)\n{\n\tuint8 protocol_version;\t\t/* protocol version */\n\tSOCKET sockctrl;\t\t/* socket descriptor of the control connection */\n\tSSL *ssl = NULL;\t\t/* optional SSL handler for sockctrl */\n\tuint32 plen;\n\tstruct rpcap_header header;\t/* structure that keeps the general header of the rpcap protocol */\n\tint i, j;\t\t/* temp variables */\n\tint nif;\t\t/* Number of interfaces listed */\n\tint active;\t\t\t/* 'true' if we the other end-party is in active mode */\n\tuint8 uses_ssl;\n\tchar host[PCAP_BUF_SIZE], port[PCAP_BUF_SIZE];\n\tchar tmpstring[PCAP_BUF_SIZE + 1];\t\t/* Needed to convert names and descriptions from 'old' syntax to the 'new' one */\n\tpcap_if_t *lastdev;\t/* Last device in the pcap_if_t list */\n\tpcap_if_t *dev;\t\t/* Device we're adding to the pcap_if_t list */\n\n\t/* List starts out empty. */\n\t(*alldevs) = NULL;\n\tlastdev = NULL;\n\n\t/*\n\t * Attempt to set up the session with the server.\n\t */\n\tif (rpcap_setup_session(source, auth, &active, &sockctrl, &uses_ssl,\n\t    &ssl, 0, &protocol_version, host, port, NULL, errbuf) == -1)\n\t{\n\t\t/* Session setup failed. */\n\t\treturn -1;\n\t}\n\n\t/* RPCAP findalldevs command */\n\trpcap_createhdr(&header, protocol_version, RPCAP_MSG_FINDALLIF_REQ,\n\t    0, 0);\n\n\tif (sock_send(sockctrl, ssl, (char *)&header, sizeof(struct rpcap_header),\n\t    errbuf, PCAP_ERRBUF_SIZE) < 0)\n\t\tgoto error_nodiscard;\n\n\t/* Receive and process the reply message header. */\n\tif (rpcap_process_msg_header(sockctrl, ssl, protocol_version,\n\t    RPCAP_MSG_FINDALLIF_REQ, &header, errbuf) == -1)\n\t\tgoto error_nodiscard;\n\n\tplen = header.plen;\n\n\t/* read the number of interfaces */\n\tnif = ntohs(header.value);\n\n\t/* loop until all interfaces have been received */\n\tfor (i = 0; i < nif; i++)\n\t{\n\t\tstruct rpcap_findalldevs_if findalldevs_if;\n\t\tchar tmpstring2[PCAP_BUF_SIZE + 1];\t\t/* Needed to convert names and descriptions from 'old' syntax to the 'new' one */\n\t\tstruct pcap_addr *addr, *prevaddr;\n\n\t\ttmpstring2[PCAP_BUF_SIZE] = 0;\n\n\t\t/* receive the findalldevs structure from remote host */\n\t\tif (rpcap_recv(sockctrl, ssl, (char *)&findalldevs_if,\n\t\t    sizeof(struct rpcap_findalldevs_if), &plen, errbuf) == -1)\n\t\t\tgoto error;\n\n\t\tfindalldevs_if.namelen = ntohs(findalldevs_if.namelen);\n\t\tfindalldevs_if.desclen = ntohs(findalldevs_if.desclen);\n\t\tfindalldevs_if.naddr = ntohs(findalldevs_if.naddr);\n\n\t\t/* allocate the main structure */\n\t\tdev = (pcap_if_t *)malloc(sizeof(pcap_if_t));\n\t\tif (dev == NULL)\n\t\t{\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc() failed\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* Initialize the structure to 'zero' */\n\t\tmemset(dev, 0, sizeof(pcap_if_t));\n\n\t\t/* Append it to the list. */\n\t\tif (lastdev == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * List is empty, so it's also the first device.\n\t\t\t */\n\t\t\t*alldevs = dev;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Append after the last device.\n\t\t\t */\n\t\t\tlastdev->next = dev;\n\t\t}\n\t\t/* It's now the last device. */\n\t\tlastdev = dev;\n\n\t\t/* allocate mem for name and description */\n\t\tif (findalldevs_if.namelen)\n\t\t{\n\n\t\t\tif (findalldevs_if.namelen >= sizeof(tmpstring))\n\t\t\t{\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Interface name too long\");\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t/* Retrieve adapter name */\n\t\t\tif (rpcap_recv(sockctrl, ssl, tmpstring,\n\t\t\t    findalldevs_if.namelen, &plen, errbuf) == -1)\n\t\t\t\tgoto error;\n\n\t\t\ttmpstring[findalldevs_if.namelen] = 0;\n\n\t\t\t/* Create the new device identifier */\n\t\t\tif (pcap_createsrcstr_ex(tmpstring2, PCAP_SRC_IFREMOTE,\n\t\t\t    host, port, tmpstring, uses_ssl, errbuf) == -1)\n\t\t\t\tgoto error;\n\n\t\t\tdev->name = strdup(tmpstring2);\n\t\t\tif (dev->name == NULL)\n\t\t\t{\n\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc() failed\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tif (findalldevs_if.desclen)\n\t\t{\n\t\t\tif (findalldevs_if.desclen >= sizeof(tmpstring))\n\t\t\t{\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Interface description too long\");\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t/* Retrieve adapter description */\n\t\t\tif (rpcap_recv(sockctrl, ssl, tmpstring,\n\t\t\t    findalldevs_if.desclen, &plen, errbuf) == -1)\n\t\t\t\tgoto error;\n\n\t\t\ttmpstring[findalldevs_if.desclen] = 0;\n\n\t\t\tif (pcap_asprintf(&dev->description,\n\t\t\t    \"%s '%s' %s %s\", PCAP_TEXT_SOURCE_ADAPTER,\n\t\t\t    tmpstring, PCAP_TEXT_SOURCE_ON_REMOTE_HOST, host) == -1)\n\t\t\t{\n\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc() failed\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tdev->flags = ntohl(findalldevs_if.flags);\n\n\t\tprevaddr = NULL;\n\t\t/* loop until all addresses have been received */\n\t\tfor (j = 0; j < findalldevs_if.naddr; j++)\n\t\t{\n\t\t\tstruct rpcap_findalldevs_ifaddr ifaddr;\n\n\t\t\t/* Retrieve the interface addresses */\n\t\t\tif (rpcap_recv(sockctrl, ssl, (char *)&ifaddr,\n\t\t\t    sizeof(struct rpcap_findalldevs_ifaddr),\n\t\t\t    &plen, errbuf) == -1)\n\t\t\t\tgoto error;\n\n\t\t\t/*\n\t\t\t * Deserialize all the address components.\n\t\t\t */\n\t\t\taddr = (struct pcap_addr *) malloc(sizeof(struct pcap_addr));\n\t\t\tif (addr == NULL)\n\t\t\t{\n\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc() failed\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\taddr->next = NULL;\n\t\t\taddr->addr = NULL;\n\t\t\taddr->netmask = NULL;\n\t\t\taddr->broadaddr = NULL;\n\t\t\taddr->dstaddr = NULL;\n\n\t\t\tif (rpcap_deseraddr(&ifaddr.addr,\n\t\t\t\t(struct sockaddr_storage **) &addr->addr, errbuf) == -1)\n\t\t\t{\n\t\t\t\tfreeaddr(addr);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (rpcap_deseraddr(&ifaddr.netmask,\n\t\t\t\t(struct sockaddr_storage **) &addr->netmask, errbuf) == -1)\n\t\t\t{\n\t\t\t\tfreeaddr(addr);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (rpcap_deseraddr(&ifaddr.broadaddr,\n\t\t\t\t(struct sockaddr_storage **) &addr->broadaddr, errbuf) == -1)\n\t\t\t{\n\t\t\t\tfreeaddr(addr);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (rpcap_deseraddr(&ifaddr.dstaddr,\n\t\t\t\t(struct sockaddr_storage **) &addr->dstaddr, errbuf) == -1)\n\t\t\t{\n\t\t\t\tfreeaddr(addr);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif ((addr->addr == NULL) && (addr->netmask == NULL) &&\n\t\t\t\t(addr->broadaddr == NULL) && (addr->dstaddr == NULL))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * None of the addresses are IPv4 or IPv6\n\t\t\t\t * addresses, so throw this entry away.\n\t\t\t\t */\n\t\t\t\tfree(addr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Add this entry to the list.\n\t\t\t\t */\n\t\t\t\tif (prevaddr == NULL)\n\t\t\t\t{\n\t\t\t\t\tdev->addresses = addr;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tprevaddr->next = addr;\n\t\t\t\t}\n\t\t\t\tprevaddr = addr;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Discard the rest of the message. */\n\tif (rpcap_discard(sockctrl, ssl, plen, errbuf) == 1)\n\t\tgoto error_nodiscard;\n\n\t/* Control connection has to be closed only in case the remote machine is in passive mode */\n\tif (!active)\n\t{\n\t\t/* DO not send RPCAP_CLOSE, since we did not open a pcap_t; no need to free resources */\n#ifdef HAVE_OPENSSL\n\t\tif (ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(ssl);\n\t\t}\n#endif\n\t\tif (sock_close(sockctrl, errbuf, PCAP_ERRBUF_SIZE))\n\t\t\treturn -1;\n\t}\n\n\t/* To avoid inconsistencies in the number of sock_init() */\n\tsock_cleanup();\n\n\treturn 0;\n\nerror:\n\t/*\n\t * In case there has been an error, I don't want to overwrite it with a new one\n\t * if the following call fails. I want to return always the original error.\n\t *\n\t * Take care: this connection can already be closed when we try to close it.\n\t * This happens because a previous error in the rpcapd, which requested to\n\t * closed the connection. In that case, we already recognized that into the\n\t * rpspck_isheaderok() and we already acknowledged the closing.\n\t * In that sense, this call is useless here (however it is needed in case\n\t * the client generates the error).\n\t *\n\t * Checks if all the data has been read; if not, discard the data in excess\n\t */\n\t(void) rpcap_discard(sockctrl, ssl, plen, NULL);\n\nerror_nodiscard:\n\t/* Control connection has to be closed only in case the remote machine is in passive mode */\n\tif (!active)\n\t{\n#ifdef HAVE_OPENSSL\n\t\tif (ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(ssl);\n\t\t}\n#endif\n\t\tsock_close(sockctrl, NULL, 0);\n\t}\n\n\t/* To avoid inconsistencies in the number of sock_init() */\n\tsock_cleanup();\n\n\t/* Free whatever interfaces we've allocated. */\n\tpcap_freealldevs(*alldevs);\n\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              2469,
              0
            ],
            [
              2767,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_findalldevs_ex_remote",
            "parameters": {
              "source": "char",
              "auth": "struct pcap_rmtauth",
              "alldevs": "pcap_if_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "SOCKET pcap_remoteact_accept_ex(const char *address, const char *port, const char *hostlist, char *connectinghost, struct pcap_rmtauth *auth, int uses_ssl, char *errbuf)\n{\n\t/* socket-related variables */\n\tstruct addrinfo hints;\t\t\t/* temporary struct to keep settings needed to open the new socket */\n\tstruct addrinfo *addrinfo;\t\t/* keeps the addrinfo chain; required to open a new socket */\n\tstruct sockaddr_storage from;\t/* generic sockaddr_storage variable */\n\tsocklen_t fromlen;\t\t\t\t/* keeps the length of the sockaddr_storage variable */\n\tSOCKET sockctrl;\t\t\t\t/* keeps the main socket identifier */\n\tSSL *ssl = NULL;\t\t\t\t/* Optional SSL handler for sockctrl */\n\tuint8 protocol_version;\t\t\t/* negotiated protocol version */\n\tstruct activehosts *temp, *prev;\t/* temp var needed to scan he host list chain */\n\n\t*connectinghost = 0;\t\t/* just in case */\n\n\t/* Prepare to open a new server socket */\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t/* WARNING Currently it supports only ONE socket family among ipv4 and IPv6  */\n\thints.ai_family = AF_INET;\t\t/* PF_UNSPEC to have both IPv4 and IPv6 server */\n\thints.ai_flags = AI_PASSIVE;\t/* Ready to a bind() socket */\n\thints.ai_socktype = SOCK_STREAM;\n\n\t/* Warning: this call can be the first one called by the user. */\n\t/* For this reason, we have to initialize the WinSock support. */\n\tif (sock_init(errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\treturn (SOCKET)-1;\n\n\t/* Do the work */\n\tif ((port == NULL) || (port[0] == 0))\n\t{\n\t\tif (sock_initaddress(address, RPCAP_DEFAULT_NETPORT_ACTIVE, &hints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\treturn (SOCKET)-2;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (sock_initaddress(address, port, &hints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\treturn (SOCKET)-2;\n\t\t}\n\t}\n\n\n\tif ((sockmain = sock_open(addrinfo, SOCKOPEN_SERVER, 1, errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n\t{\n\t\tfreeaddrinfo(addrinfo);\n\t\treturn (SOCKET)-2;\n\t}\n\tfreeaddrinfo(addrinfo);\n\n\t/* Connection creation */\n\tfromlen = sizeof(struct sockaddr_storage);\n\n\tsockctrl = accept(sockmain, (struct sockaddr *) &from, &fromlen);\n\n\t/* We're not using sock_close, since we do not want to send a shutdown */\n\t/* (which is not allowed on a non-connected socket) */\n\tclosesocket(sockmain);\n\tsockmain = 0;\n\n\tif (sockctrl == INVALID_SOCKET)\n\t{\n\t\tsock_geterror(\"accept(): \", errbuf, PCAP_ERRBUF_SIZE);\n\t\treturn (SOCKET)-2;\n\t}\n\n\t/* Promote to SSL early before any error message may be sent */\n\tif (uses_ssl)\n\t{\n#ifdef HAVE_OPENSSL\n\t\tssl = ssl_promotion(0, sockctrl, errbuf, PCAP_ERRBUF_SIZE);\n\t\tif (! ssl)\n\t\t{\n\t\t\tsock_close(sockctrl, NULL, 0);\n\t\t\treturn (SOCKET)-1;\n\t\t}\n#else\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"No TLS support\");\n\t\tsock_close(sockctrl, NULL, 0);\n\t\treturn (SOCKET)-1;\n#endif\n\t}\n\n\t/* Get the numeric for of the name of the connecting host */\n\tif (getnameinfo((struct sockaddr *) &from, fromlen, connectinghost, RPCAP_HOSTLIST_SIZE, NULL, 0, NI_NUMERICHOST))\n\t{\n\t\tsock_geterror(\"getnameinfo(): \", errbuf, PCAP_ERRBUF_SIZE);\n\t\trpcap_senderror(sockctrl, ssl, 0, PCAP_ERR_REMOTEACCEPT, errbuf, NULL);\n#ifdef HAVE_OPENSSL\n\t\tif (ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(ssl);\n\t\t}\n#endif\n\t\tsock_close(sockctrl, NULL, 0);\n\t\treturn (SOCKET)-1;\n\t}\n\n\t/* checks if the connecting host is among the ones allowed */\n\tif (sock_check_hostlist((char *)hostlist, RPCAP_HOSTLIST_SEP, &from, errbuf, PCAP_ERRBUF_SIZE) < 0)\n\t{\n\t\trpcap_senderror(sockctrl, ssl, 0, PCAP_ERR_REMOTEACCEPT, errbuf, NULL);\n#ifdef HAVE_OPENSSL\n\t\tif (ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(ssl);\n\t\t}\n#endif\n\t\tsock_close(sockctrl, NULL, 0);\n\t\treturn (SOCKET)-1;\n\t}\n\n\t/*\n\t * Send authentication to the remote machine.\n\t */\n\tif (rpcap_doauth(sockctrl, ssl, &protocol_version, auth, errbuf) == -1)\n\t{\n\t\t/* Unrecoverable error. */\n\t\trpcap_senderror(sockctrl, ssl, 0, PCAP_ERR_REMOTEACCEPT, errbuf, NULL);\n#ifdef HAVE_OPENSSL\n\t\tif (ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(ssl);\n\t\t}\n#endif\n\t\tsock_close(sockctrl, NULL, 0);\n\t\treturn (SOCKET)-3;\n\t}\n\n\t/* Checks that this host does not already have a cntrl connection in place */\n\n\t/* Initialize pointers */\n\ttemp = activeHosts;\n\tprev = NULL;\n\n\twhile (temp)\n\t{\n\t\t/* This host already has an active connection in place, so I don't have to update the host list */\n\t\tif (sock_cmpaddr(&temp->host, &from) == 0)\n\t\t\treturn sockctrl;\n\n\t\tprev = temp;\n\t\ttemp = temp->next;\n\t}\n\n\t/* The host does not exist in the list; so I have to update the list */\n\tif (prev)\n\t{\n\t\tprev->next = (struct activehosts *) malloc(sizeof(struct activehosts));\n\t\ttemp = prev->next;\n\t}\n\telse\n\t{\n\t\tactiveHosts = (struct activehosts *) malloc(sizeof(struct activehosts));\n\t\ttemp = activeHosts;\n\t}\n\n\tif (temp == NULL)\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc() failed\");\n\t\trpcap_senderror(sockctrl, ssl, protocol_version, PCAP_ERR_REMOTEACCEPT, errbuf, NULL);\n#ifdef HAVE_OPENSSL\n\t\tif (ssl)\n\t\t{\n\t\t\t// Finish using the SSL handle for the socket.\n\t\t\t// This must be done *before* the socket is closed.\n\t\t\tssl_finish(ssl);\n\t\t}\n#endif\n\t\tsock_close(sockctrl, NULL, 0);\n\t\treturn (SOCKET)-1;\n\t}\n\n\tmemcpy(&temp->host, &from, fromlen);\n\ttemp->sockctrl = sockctrl;\n\ttemp->ssl = ssl;\n\ttemp->protocol_version = protocol_version;\n\ttemp->next = NULL;\n\n\treturn sockctrl;\n}",
          "fn_code_pos": [
            [
              2776,
              0
            ],
            [
              2963,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_remoteact_accept_ex",
            "parameters": {
              "address": "char",
              "port": "char",
              "hostlist": "char",
              "connectinghost": "char",
              "auth": "struct pcap_rmtauth",
              "uses_ssl": "int",
              "errbuf": "char"
            },
            "return_type": "SOCKET"
          }
        },
        {
          "fn_code": "SOCKET pcap_remoteact_accept(const char *address, const char *port, const char *hostlist, char *connectinghost, struct pcap_rmtauth *auth, char *errbuf)\n{\n\treturn pcap_remoteact_accept_ex(address, port, hostlist, connectinghost, auth, 0, errbuf);\n}",
          "fn_code_pos": [
            [
              2965,
              0
            ],
            [
              2968,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_remoteact_accept",
            "parameters": {
              "address": "char",
              "port": "char",
              "hostlist": "char",
              "connectinghost": "char",
              "auth": "struct pcap_rmtauth",
              "errbuf": "char"
            },
            "return_type": "SOCKET"
          }
        },
        {
          "fn_code": "int pcap_remoteact_close(const char *host, char *errbuf)\n{\n\tstruct activehosts *temp, *prev;\t/* temp var needed to scan the host list chain */\n\tstruct addrinfo hints, *addrinfo, *ai_next;\t/* temp var needed to translate between hostname to its address */\n\tint retval;\n\n\ttemp = activeHosts;\n\tprev = NULL;\n\n\t/* retrieve the network address corresponding to 'host' */\n\taddrinfo = NULL;\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\n\tretval = getaddrinfo(host, \"0\", &hints, &addrinfo);\n\tif (retval != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"getaddrinfo() %s\", gai_strerror(retval));\n\t\treturn -1;\n\t}\n\n\twhile (temp)\n\t{\n\t\tai_next = addrinfo;\n\t\twhile (ai_next)\n\t\t{\n\t\t\tif (sock_cmpaddr(&temp->host, (struct sockaddr_storage *) ai_next->ai_addr) == 0)\n\t\t\t{\n\t\t\t\tstruct rpcap_header header;\n\t\t\t\tint status = 0;\n\n\t\t\t\t/* Close this connection */\n\t\t\t\trpcap_createhdr(&header, temp->protocol_version,\n\t\t\t\t    RPCAP_MSG_CLOSE, 0, 0);\n\n\t\t\t\t/*\n\t\t\t\t * Don't check for errors, since we're\n\t\t\t\t * just cleaning up.\n\t\t\t\t */\n\t\t\t\tif (sock_send(temp->sockctrl, temp->ssl,\n\t\t\t\t    (char *)&header,\n\t\t\t\t    sizeof(struct rpcap_header), errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE) < 0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Let that error be the one we\n\t\t\t\t\t * report.\n\t\t\t\t\t */\n#ifdef HAVE_OPENSSL\n\t\t\t\t\tif (temp->ssl)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Finish using the SSL handle\n\t\t\t\t\t\t// for the socket.\n\t\t\t\t\t\t// This must be done *before*\n\t\t\t\t\t\t// the socket is closed.\n\t\t\t\t\t\tssl_finish(temp->ssl);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\t(void)sock_close(temp->sockctrl, NULL,\n\t\t\t\t\t   0);\n\t\t\t\t\tstatus = -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n#ifdef HAVE_OPENSSL\n\t\t\t\t\tif (temp->ssl)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Finish using the SSL handle\n\t\t\t\t\t\t// for the socket.\n\t\t\t\t\t\t// This must be done *before*\n\t\t\t\t\t\t// the socket is closed.\n\t\t\t\t\t\tssl_finish(temp->ssl);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tif (sock_close(temp->sockctrl, errbuf,\n\t\t\t\t\t   PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\t\tstatus = -1;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Remove the host from the list of active\n\t\t\t\t * hosts.\n\t\t\t\t */\n\t\t\t\tif (prev)\n\t\t\t\t\tprev->next = temp->next;\n\t\t\t\telse\n\t\t\t\t\tactiveHosts = temp->next;\n\n\t\t\t\tfreeaddrinfo(addrinfo);\n\n\t\t\t\tfree(temp);\n\n\t\t\t\t/* To avoid inconsistencies in the number of sock_init() */\n\t\t\t\tsock_cleanup();\n\n\t\t\t\treturn status;\n\t\t\t}\n\n\t\t\tai_next = ai_next->ai_next;\n\t\t}\n\t\tprev = temp;\n\t\ttemp = temp->next;\n\t}\n\n\tif (addrinfo)\n\t\tfreeaddrinfo(addrinfo);\n\n\t/* To avoid inconsistencies in the number of sock_init() */\n\tsock_cleanup();\n\n\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"The host you want to close the active connection is not known\");\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              2970,
              0
            ],
            [
              3083,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_remoteact_close",
            "parameters": {
              "host": "char",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void pcap_remoteact_cleanup(void)\n{\n#\tifdef HAVE_OPENSSL\n\tif (ssl_main)\n\t{\n\t\t// Finish using the SSL handle for the main active socket.\n\t\t// This must be done *before* the socket is closed.\n\t\tssl_finish(ssl_main);\n\t\tssl_main = NULL;\n\t}\n#\tendif\n\n\t/* Very dirty, but it works */\n\tif (sockmain)\n\t{\n\t\tclosesocket(sockmain);\n\n\t\t/* To avoid inconsistencies in the number of sock_init() */\n\t\tsock_cleanup();\n\t}\n}",
          "fn_code_pos": [
            [
              3085,
              0
            ],
            [
              3105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_remoteact_cleanup",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int pcap_remoteact_list(char *hostlist, char sep, int size, char *errbuf)\n{\n\tstruct activehosts *temp;\t/* temp var needed to scan the host list chain */\n\tsize_t len;\n\tchar hoststr[RPCAP_HOSTLIST_SIZE + 1];\n\n\ttemp = activeHosts;\n\n\tlen = 0;\n\t*hostlist = 0;\n\n\twhile (temp)\n\t{\n\t\t/*int sock_getascii_addrport(const struct sockaddr_storage *sockaddr, char *address, int addrlen, char *port, int portlen, int flags, char *errbuf, int errbuflen) */\n\n\t\t/* Get the numeric form of the name of the connecting host */\n\t\tif (sock_getascii_addrport((struct sockaddr_storage *) &temp->host, hoststr,\n\t\t\tRPCAP_HOSTLIST_SIZE, NULL, 0, NI_NUMERICHOST, errbuf, PCAP_ERRBUF_SIZE) != -1)\n\t\t\t/*\tif (getnameinfo( (struct sockaddr *) &temp->host, sizeof (struct sockaddr_storage), hoststr, */\n\t\t\t/*\t\tRPCAP_HOSTLIST_SIZE, NULL, 0, NI_NUMERICHOST) ) */\n\t\t{\n\t\t\t/*\tsock_geterror(\"getnameinfo(): \", errbuf, PCAP_ERRBUF_SIZE); */\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = len + strlen(hoststr) + 1 /* the separator */;\n\n\t\tif ((size < 0) || (len >= (size_t)size))\n\t\t{\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"The string you provided is not able to keep \"\n\t\t\t\t\"the hostnames for all the active connections\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tpcap_strlcat(hostlist, hoststr, PCAP_ERRBUF_SIZE);\n\t\thostlist[len - 1] = sep;\n\t\thostlist[len] = 0;\n\n\t\ttemp = temp->next;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              3107,
              0
            ],
            [
              3149,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_remoteact_list",
            "parameters": {
              "hostlist": "char",
              "sep": "char",
              "size": "int",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int rpcap_recv_msg_header(SOCKET sock, SSL *ssl, struct rpcap_header *header, char *errbuf)\n{\n\tint nrecv;\n\n\tnrecv = sock_recv(sock, ssl, (char *) header, sizeof(struct rpcap_header),\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,\n\t    PCAP_ERRBUF_SIZE);\n\tif (nrecv == -1)\n\t{\n\t\t/* Network error. */\n\t\treturn -1;\n\t}\n\theader->plen = ntohl(header->plen);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              3154,
              0
            ],
            [
              3168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_recv_msg_header",
            "parameters": {
              "sock": "SOCKET",
              "ssl": "SSL",
              "header": "struct rpcap_header",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int rpcap_check_msg_ver(SOCKET sock, SSL *ssl, uint8 expected_ver, struct rpcap_header *header, char *errbuf)\n{\n\t/*\n\t * Did the server specify the version we negotiated?\n\t */\n\tif (header->ver != expected_ver)\n\t{\n\t\t/*\n\t\t * Discard the rest of the message.\n\t\t */\n\t\tif (rpcap_discard(sock, ssl, header->plen, errbuf) == -1)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Tell our caller that it's not the negotiated version.\n\t\t */\n\t\tif (errbuf != NULL)\n\t\t{\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Server sent us a message with version %u when we were expecting %u\",\n\t\t\t    header->ver, expected_ver);\n\t\t}\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              3174,
              0
            ],
            [
              3199,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_check_msg_ver",
            "parameters": {
              "sock": "SOCKET",
              "ssl": "SSL",
              "expected_ver": "uint8",
              "header": "struct rpcap_header",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int rpcap_check_msg_type(SOCKET sock, SSL *ssl, uint8 request_type, struct rpcap_header *header, uint16 *errcode, char *errbuf)\n{\n\tconst char *request_type_string;\n\tconst char *msg_type_string;\n\n\t/*\n\t * What type of message is it?\n\t */\n\tif (header->type == RPCAP_MSG_ERROR)\n\t{\n\t\t/*\n\t\t * The server reported an error.\n\t\t * Hand that error back to our caller.\n\t\t */\n\t\t*errcode = ntohs(header->value);\n\t\trpcap_msg_err(sock, ssl, header->plen, errbuf);\n\t\treturn -1;\n\t}\n\n\t*errcode = 0;\n\n\t/*\n\t * For a given request type value, the expected reply type value\n\t * is the request type value with ORed with RPCAP_MSG_IS_REPLY.\n\t */\n\tif (header->type != (request_type | RPCAP_MSG_IS_REPLY))\n\t{\n\t\t/*\n\t\t * This isn't a reply to the request we sent.\n\t\t */\n\n\t\t/*\n\t\t * Discard the rest of the message.\n\t\t */\n\t\tif (rpcap_discard(sock, ssl, header->plen, errbuf) == -1)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Tell our caller about it.\n\t\t */\n\t\trequest_type_string = rpcap_msg_type_string(request_type);\n\t\tmsg_type_string = rpcap_msg_type_string(header->type);\n\t\tif (errbuf != NULL)\n\t\t{\n\t\t\tif (request_type_string == NULL)\n\t\t\t{\n\t\t\t\t/* This should not happen. */\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"rpcap_check_msg_type called for request message with type %u\",\n\t\t\t\t    request_type);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (msg_type_string != NULL)\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"%s message received in response to a %s message\",\n\t\t\t\t    msg_type_string, request_type_string);\n\t\t\telse\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Message of unknown type %u message received in response to a %s request\",\n\t\t\t\t    header->type, request_type_string);\n\t\t}\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              3205,
              0
            ],
            [
              3270,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_check_msg_type",
            "parameters": {
              "sock": "SOCKET",
              "ssl": "SSL",
              "request_type": "uint8",
              "header": "struct rpcap_header",
              "errcode": "uint16",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int rpcap_process_msg_header(SOCKET sock, SSL *ssl, uint8 expected_ver, uint8 request_type, struct rpcap_header *header, char *errbuf)\n{\n\tuint16 errcode;\n\n\tif (rpcap_recv_msg_header(sock, ssl, header, errbuf) == -1)\n\t{\n\t\t/* Network error. */\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Did the server specify the version we negotiated?\n\t */\n\tif (rpcap_check_msg_ver(sock, ssl, expected_ver, header, errbuf) == -1)\n\t\treturn -1;\n\n\t/*\n\t * Check the message type.\n\t */\n\treturn rpcap_check_msg_type(sock, ssl, request_type, header,\n\t    &errcode, errbuf);\n}",
          "fn_code_pos": [
            [
              3275,
              0
            ],
            [
              3296,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_process_msg_header",
            "parameters": {
              "sock": "SOCKET",
              "ssl": "SSL",
              "expected_ver": "uint8",
              "request_type": "uint8",
              "header": "struct rpcap_header",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int rpcap_recv(SOCKET sock, SSL *ssl, void *buffer, size_t toread, uint32 *plen, char *errbuf)\n{\n\tint nread;\n\n\tif (toread > *plen)\n\t{\n\t\t/* The server sent us a bad message */\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Message payload is too short\");\n\t\treturn -1;\n\t}\n\tnread = sock_recv(sock, ssl, buffer, toread,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\treturn -1;\n\t}\n\t*plen -= nread;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              3307,
              0
            ],
            [
              3325,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_recv",
            "parameters": {
              "sock": "SOCKET",
              "ssl": "SSL",
              "buffer": "void",
              "toread": "size_t",
              "plen": "uint32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void rpcap_msg_err(SOCKET sockctrl, SSL *ssl, uint32 plen, char *remote_errbuf)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\n\tif (plen >= PCAP_ERRBUF_SIZE)\n\t{\n\t\t/*\n\t\t * Message is too long; just read as much of it as we\n\t\t * can into the buffer provided, and discard the rest.\n\t\t */\n\t\tif (sock_recv(sockctrl, ssl, remote_errbuf, PCAP_ERRBUF_SIZE - 1,\n\t\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\tpcap_snprintf(remote_errbuf, PCAP_ERRBUF_SIZE, \"Read of error message from client failed: %s\", errbuf);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Null-terminate it.\n\t\t */\n\t\tremote_errbuf[PCAP_ERRBUF_SIZE - 1] = '\\0';\n\n\t\t/*\n\t\t * Throw away the rest.\n\t\t */\n\t\t(void)rpcap_discard(sockctrl, ssl, plen - (PCAP_ERRBUF_SIZE - 1), remote_errbuf);\n\t}\n\telse if (plen == 0)\n\t{\n\t\t/* Empty error string. */\n\t\tremote_errbuf[0] = '\\0';\n\t}\n\telse\n\t{\n\t\tif (sock_recv(sockctrl, ssl, remote_errbuf, plen,\n\t\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\tpcap_snprintf(remote_errbuf, PCAP_ERRBUF_SIZE, \"Read of error message from client failed: %s\", errbuf);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Null-terminate it.\n\t\t */\n\t\tremote_errbuf[plen] = '\\0';\n\t}\n}",
          "fn_code_pos": [
            [
              3330,
              0
            ],
            [
              3380,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_msg_err",
            "parameters": {
              "sockctrl": "SOCKET",
              "ssl": "SSL",
              "plen": "uint32",
              "remote_errbuf": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int rpcap_discard(SOCKET sock, SSL *ssl, uint32 len, char *errbuf)\n{\n\tif (len != 0)\n\t{\n\t\tif (sock_discard(sock, ssl, len, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              3388,
              0
            ],
            [
              3399,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_discard",
            "parameters": {
              "sock": "SOCKET",
              "ssl": "SSL",
              "len": "uint32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int rpcap_read_packet_msg(struct pcap_rpcap const *rp, pcap_t *p, size_t size)\n{\n\tu_char *bp;\n\tint cc;\n\tint bytes_read;\n\n\tbp = p->bp;\n\tcc = p->cc;\n\n\t/*\n\t * Loop until we have the amount of data requested or we get\n\t * an error or interrupt.\n\t */\n\twhile ((size_t)cc < size)\n\t{\n\t\t/*\n\t\t * We haven't read all of the packet header yet.\n\t\t * Read what remains, which could be all of it.\n\t\t */\n\t\tbytes_read = sock_recv(rp->rmt_sockdata, rp->data_ssl, bp, size - cc,\n\t\t    SOCK_RECEIVEALL_NO|SOCK_EOF_IS_ERROR, p->errbuf,\n\t\t    PCAP_ERRBUF_SIZE);\n\n\t\tif (bytes_read == -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Network error.  Update the read pointer and\n\t\t\t * byte count, and return an error indication.\n\t\t\t */\n\t\t\tp->bp = bp;\n\t\t\tp->cc = cc;\n\t\t\treturn -1;\n\t\t}\n\t\tif (bytes_read == -3)\n\t\t{\n\t\t\t/*\n\t\t\t * Interrupted receive.  Update the read\n\t\t\t * pointer and byte count, and return\n\t\t\t * an interrupted indication.\n\t\t\t */\n\t\t\tp->bp = bp;\n\t\t\tp->cc = cc;\n\t\t\treturn -3;\n\t\t}\n\t\tif (bytes_read == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * EOF - server terminated the connection.\n\t\t\t * Update the read pointer and byte count, and\n\t\t\t * return an error indication.\n\t\t\t */\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"The server terminated the connection.\");\n\t\t\treturn -1;\n\t\t}\n\t\tbp += bytes_read;\n\t\tcc += bytes_read;\n\t}\n\tp->bp = bp;\n\tp->cc = cc;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              3405,
              0
            ],
            [
              3466,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_read_packet_msg",
            "parameters": {
              "rp": "struct pcap_rpcap",
              "p": "pcap_t",
              "size": "size_t"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "rpcap_stats_rpcap(pcap_t *p, struct pcap_stat *ps, int mode)",
          "fn_dec_pos": [
            [
              157,
              25
            ],
            [
              157,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_stats_rpcap",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat",
              "mode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_pack_bpffilter(pcap_t *fp, char *sendbuf, int *sendbufidx, struct bpf_program *prog)",
          "fn_dec_pos": [
            [
              158,
              11
            ],
            [
              158,
              100
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_pack_bpffilter",
            "parameters": {
              "fp": "pcap_t",
              "sendbuf": "char",
              "sendbufidx": "int",
              "prog": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_createfilter_norpcappkt(pcap_t *fp, struct bpf_program *prog)",
          "fn_dec_pos": [
            [
              159,
              11
            ],
            [
              159,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_createfilter_norpcappkt",
            "parameters": {
              "fp": "pcap_t",
              "prog": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_updatefilter_remote(pcap_t *fp, struct bpf_program *prog)",
          "fn_dec_pos": [
            [
              160,
              11
            ],
            [
              160,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_updatefilter_remote",
            "parameters": {
              "fp": "pcap_t",
              "prog": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_save_current_filter_rpcap(pcap_t *fp, const char *filter)",
          "fn_dec_pos": [
            [
              161,
              12
            ],
            [
              161,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_save_current_filter_rpcap",
            "parameters": {
              "fp": "pcap_t",
              "filter": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_setfilter_rpcap(pcap_t *fp, struct bpf_program *prog)",
          "fn_dec_pos": [
            [
              162,
              11
            ],
            [
              162,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_rpcap",
            "parameters": {
              "fp": "pcap_t",
              "prog": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_setsampling_remote(pcap_t *fp)",
          "fn_dec_pos": [
            [
              163,
              11
            ],
            [
              163,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setsampling_remote",
            "parameters": {
              "fp": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_startcapture_remote(pcap_t *fp)",
          "fn_dec_pos": [
            [
              164,
              11
            ],
            [
              164,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_startcapture_remote",
            "parameters": {
              "fp": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "rpcap_recv_msg_header(SOCKET sock, SSL *, struct rpcap_header *header, char *errbuf)",
          "fn_dec_pos": [
            [
              165,
              11
            ],
            [
              165,
              95
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_recv_msg_header",
            "parameters": {
              "sock": "SOCKET",
              "header": "struct rpcap_header",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "rpcap_check_msg_ver(SOCKET sock, SSL *, uint8 expected_ver, struct rpcap_header *header, char *errbuf)",
          "fn_dec_pos": [
            [
              166,
              11
            ],
            [
              166,
              113
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_check_msg_ver",
            "parameters": {
              "sock": "SOCKET",
              "expected_ver": "uint8",
              "header": "struct rpcap_header",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "rpcap_check_msg_type(SOCKET sock, SSL *, uint8 request_type, struct rpcap_header *header, uint16 *errcode, char *errbuf)",
          "fn_dec_pos": [
            [
              167,
              11
            ],
            [
              167,
              131
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_check_msg_type",
            "parameters": {
              "sock": "SOCKET",
              "request_type": "uint8",
              "header": "struct rpcap_header",
              "errcode": "uint16",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "rpcap_process_msg_header(SOCKET sock, SSL *, uint8 ver, uint8 request_type, struct rpcap_header *header, char *errbuf)",
          "fn_dec_pos": [
            [
              168,
              11
            ],
            [
              168,
              129
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_process_msg_header",
            "parameters": {
              "sock": "SOCKET",
              "ver": "uint8",
              "request_type": "uint8",
              "header": "struct rpcap_header",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "rpcap_recv(SOCKET sock, SSL *, void *buffer, size_t toread, uint32 *plen, char *errbuf)",
          "fn_dec_pos": [
            [
              169,
              11
            ],
            [
              169,
              98
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_recv",
            "parameters": {
              "sock": "SOCKET",
              "buffer": "void",
              "toread": "size_t",
              "plen": "uint32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "rpcap_msg_err(SOCKET sockctrl, SSL *, uint32 plen, char *remote_errbuf)",
          "fn_dec_pos": [
            [
              170,
              12
            ],
            [
              170,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_msg_err",
            "parameters": {
              "sockctrl": "SOCKET",
              "plen": "uint32",
              "remote_errbuf": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "rpcap_discard(SOCKET sock, SSL *, uint32 len, char *errbuf)",
          "fn_dec_pos": [
            [
              171,
              11
            ],
            [
              171,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_discard",
            "parameters": {
              "sock": "SOCKET",
              "len": "uint32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "rpcap_read_packet_msg(struct pcap_rpcap const *, pcap_t *p, size_t size)",
          "fn_dec_pos": [
            [
              172,
              11
            ],
            [
              172,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_read_packet_msg",
            "parameters": {
              "p": "pcap_t",
              "size": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_stats_ex_rpcap(pcap_t *p, int *pcap_stat_size)",
          "fn_dec_pos": [
            [
              829,
              25
            ],
            [
              829,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_ex_rpcap",
            "parameters": {
              "p": "pcap_t",
              "pcap_stat_size": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "rpcap_stats_rpcap(pcap_t *p, struct pcap_stat *ps, int mode)",
          "fn_dec_pos": [
            [
              875,
              25
            ],
            [
              875,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_stats_rpcap",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat",
              "mode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "rpcap_remoteact_getsock(const char *host, int *error, char *errbuf)",
          "fn_dec_pos": [
            [
              985,
              0
            ],
            [
              985,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_remoteact_getsock",
            "parameters": {
              "host": "char",
              "error": "int",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_open_rpcap(const char *source, int snaplen, int flags, int read_timeout, struct pcap_rmtauth *auth, char *errbuf)",
          "fn_dec_pos": [
            [
              2298,
              8
            ],
            [
              2298,
              126
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_rpcap",
            "parameters": {
              "source": "char",
              "snaplen": "int",
              "flags": "int",
              "read_timeout": "int",
              "auth": "struct pcap_rmtauth",
              "errbuf": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct activehosts\n{\n\tstruct sockaddr_storage host;\n\tSOCKET sockctrl;\n\tSSL *ssl;\n\tuint8 protocol_version;\n\tstruct activehosts *next;\n}",
          {
            "host": "struct sockaddr_storage",
            "sockctrl": "SOCKET",
            "*ssl": "SSL",
            "protocol_version": "uint8",
            "*next": "struct activehosts"
          },
          "activehosts",
          [
            85,
            0
          ],
          [
            92,
            1
          ]
        ],
        [
          "struct pcap_rpcap {\n\t/*\n\t * This is '1' if we're the network client; it is needed by several\n\t * functions (such as pcap_setfilter()) to know whether they have\n\t * to use the socket or have to open the local adapter.\n\t */\n\tint rmt_clientside;\n\n\tSOCKET rmt_sockctrl;\t\t/* socket ID of the socket used for the control connection */\n\tSOCKET rmt_sockdata;\t\t/* socket ID of the socket used for the data connection */\n\tSSL *ctrl_ssl, *data_ssl;\t/* optional transport of rmt_sockctrl and rmt_sockdata via TLS */\n\tint rmt_flags;\t\t\t/* we have to save flags, since they are passed by the pcap_open_live(), but they are used by the pcap_startcapture() */\n\tint rmt_capstarted;\t\t/* 'true' if the capture is already started (needed to knoe if we have to call the pcap_startcapture() */\n\tchar *currentfilter;\t\t/* Pointer to a buffer (allocated at run-time) that stores the current filter. Needed when flag PCAP_OPENFLAG_NOCAPTURE_RPCAP is turned on. */\n\n\tuint8 protocol_version;\t\t/* negotiated protocol version */\n\tuint8 uses_ssl;\t\t\t\t/* User asked for rpcaps scheme */\n\n\tunsigned int TotNetDrops;\t/* keeps the number of packets that have been dropped by the network */\n\n\t/*\n\t * This keeps the number of packets that have been received by the\n\t * application.\n\t *\n\t * Packets dropped by the kernel buffer are not counted in this\n\t * variable. It is always equal to (TotAccepted - TotDrops),\n\t * except for the case of remote capture, in which we have also\n\t * packets in flight, i.e. that have been transmitted by the remote\n\t * host, but that have not been received (yet) from the client.\n\t * In this case, (TotAccepted - TotDrops - TotNetDrops) gives a\n\t * wrong result, since this number does not corresponds always to\n\t * the number of packet received by the application. For this reason,\n\t * in the remote capture we need another variable that takes into\n\t * account of the number of packets actually received by the\n\t * application.\n\t */\n\tunsigned int TotCapt;\n\n\tstruct pcap_stat stat;\n\t/* XXX */\n\tstruct pcap *next;\t\t/* list of open pcaps that need stuff cleared on close */\n}",
          {
            "rmt_clientside": "int",
            "rmt_sockctrl": "SOCKET",
            "rmt_sockdata": "SOCKET",
            "*ctrl_ssl": "SSL",
            "rmt_flags": "int",
            "rmt_capstarted": "int",
            "*currentfilter": "char",
            "protocol_version": "uint8",
            "uses_ssl": "uint8",
            "TotNetDrops": "unsigned int",
            "TotCapt": "unsigned int",
            "stat": "struct pcap_stat",
            "*next": "struct pcap"
          },
          "pcap_rpcap",
          [
            109,
            0
          ],
          [
            150,
            1
          ]
        ],
        [
          "struct activehosts\n{\n\tstruct sockaddr_storage host;\n\tSOCKET sockctrl;\n\tSSL *ssl;\n\tuint8 protocol_version;\n\tstruct activehosts *next;\n}",
          {
            "host": "struct sockaddr_storage",
            "sockctrl": "SOCKET",
            "*ssl": "SSL",
            "protocol_version": "uint8",
            "*next": "struct activehosts"
          },
          "activehosts",
          [
            85,
            0
          ],
          [
            92,
            1
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            87,
            1
          ],
          [
            87,
            24
          ]
        ],
        [
          "struct activehosts",
          {},
          "",
          [
            91,
            1
          ],
          [
            91,
            19
          ]
        ],
        [
          "struct activehosts",
          {},
          "",
          [
            95,
            7
          ],
          [
            95,
            25
          ]
        ],
        [
          "struct pcap_rpcap {\n\t/*\n\t * This is '1' if we're the network client; it is needed by several\n\t * functions (such as pcap_setfilter()) to know whether they have\n\t * to use the socket or have to open the local adapter.\n\t */\n\tint rmt_clientside;\n\n\tSOCKET rmt_sockctrl;\t\t/* socket ID of the socket used for the control connection */\n\tSOCKET rmt_sockdata;\t\t/* socket ID of the socket used for the data connection */\n\tSSL *ctrl_ssl, *data_ssl;\t/* optional transport of rmt_sockctrl and rmt_sockdata via TLS */\n\tint rmt_flags;\t\t\t/* we have to save flags, since they are passed by the pcap_open_live(), but they are used by the pcap_startcapture() */\n\tint rmt_capstarted;\t\t/* 'true' if the capture is already started (needed to knoe if we have to call the pcap_startcapture() */\n\tchar *currentfilter;\t\t/* Pointer to a buffer (allocated at run-time) that stores the current filter. Needed when flag PCAP_OPENFLAG_NOCAPTURE_RPCAP is turned on. */\n\n\tuint8 protocol_version;\t\t/* negotiated protocol version */\n\tuint8 uses_ssl;\t\t\t\t/* User asked for rpcaps scheme */\n\n\tunsigned int TotNetDrops;\t/* keeps the number of packets that have been dropped by the network */\n\n\t/*\n\t * This keeps the number of packets that have been received by the\n\t * application.\n\t *\n\t * Packets dropped by the kernel buffer are not counted in this\n\t * variable. It is always equal to (TotAccepted - TotDrops),\n\t * except for the case of remote capture, in which we have also\n\t * packets in flight, i.e. that have been transmitted by the remote\n\t * host, but that have not been received (yet) from the client.\n\t * In this case, (TotAccepted - TotDrops - TotNetDrops) gives a\n\t * wrong result, since this number does not corresponds always to\n\t * the number of packet received by the application. For this reason,\n\t * in the remote capture we need another variable that takes into\n\t * account of the number of packets actually received by the\n\t * application.\n\t */\n\tunsigned int TotCapt;\n\n\tstruct pcap_stat stat;\n\t/* XXX */\n\tstruct pcap *next;\t\t/* list of open pcaps that need stuff cleared on close */\n}",
          {
            "rmt_clientside": "int",
            "rmt_sockctrl": "SOCKET",
            "rmt_sockdata": "SOCKET",
            "*ctrl_ssl": "SSL",
            "rmt_flags": "int",
            "rmt_capstarted": "int",
            "*currentfilter": "char",
            "protocol_version": "uint8",
            "uses_ssl": "uint8",
            "TotNetDrops": "unsigned int",
            "TotCapt": "unsigned int",
            "stat": "struct pcap_stat",
            "*next": "struct pcap"
          },
          "pcap_rpcap",
          [
            109,
            0
          ],
          [
            150,
            1
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            147,
            1
          ],
          [
            147,
            17
          ]
        ],
        [
          "struct pcap",
          {},
          "",
          [
            149,
            1
          ],
          [
            149,
            12
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            157,
            7
          ],
          [
            157,
            23
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            157,
            54
          ],
          [
            157,
            70
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            158,
            75
          ],
          [
            158,
            93
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            159,
            52
          ],
          [
            159,
            70
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            160,
            48
          ],
          [
            160,
            66
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            162,
            44
          ],
          [
            162,
            62
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            165,
            53
          ],
          [
            165,
            72
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            166,
            71
          ],
          [
            166,
            90
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            167,
            72
          ],
          [
            167,
            91
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            168,
            87
          ],
          [
            168,
            106
          ]
        ],
        [
          "struct pcap_rpcap",
          {},
          "",
          [
            172,
            33
          ],
          [
            172,
            50
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            288,
            16
          ],
          [
            288,
            37
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            288,
            51
          ],
          [
            288,
            74
          ]
        ],
        [
          "struct rpcap_sockaddr_in",
          {},
          "",
          [
            297,
            2
          ],
          [
            297,
            26
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            298,
            2
          ],
          [
            298,
            20
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            300,
            20
          ],
          [
            300,
            43
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            300,
            61
          ],
          [
            300,
            79
          ]
        ],
        [
          "struct rpcap_sockaddr_in",
          {},
          "",
          [
            307,
            21
          ],
          [
            307,
            45
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            308,
            22
          ],
          [
            308,
            40
          ]
        ],
        [
          "struct rpcap_sockaddr_in6",
          {},
          "",
          [
            327,
            2
          ],
          [
            327,
            27
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            328,
            2
          ],
          [
            328,
            21
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            330,
            20
          ],
          [
            330,
            43
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            330,
            61
          ],
          [
            330,
            80
          ]
        ],
        [
          "struct rpcap_sockaddr_in6",
          {},
          "",
          [
            337,
            21
          ],
          [
            337,
            46
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            338,
            22
          ],
          [
            338,
            41
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            378,
            44
          ],
          [
            378,
            62
          ]
        ],
        [
          "struct pcap_rpcap",
          {},
          "",
          [
            380,
            1
          ],
          [
            380,
            18
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            381,
            1
          ],
          [
            381,
            20
          ]
        ],
        [
          "struct rpcap_pkthdr",
          {},
          "",
          [
            382,
            1
          ],
          [
            382,
            20
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            389,
            1
          ],
          [
            389,
            15
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            439,
            11
          ],
          [
            439,
            30
          ]
        ],
        [
          "struct rpcap_pkthdr",
          {},
          "",
          [
            440,
            19
          ],
          [
            440,
            38
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            440,
            70
          ],
          [
            440,
            89
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            441,
            45
          ],
          [
            441,
            64
          ]
        ],
        [
          "struct rpcap_pkthdr",
          {},
          "",
          [
            441,
            75
          ],
          [
            441,
            94
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            458,
            30
          ],
          [
            458,
            49
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            468,
            30
          ],
          [
            468,
            49
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            483,
            29
          ],
          [
            483,
            48
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            490,
            48
          ],
          [
            490,
            67
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            510,
            33
          ],
          [
            510,
            52
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            522,
            47
          ],
          [
            522,
            66
          ]
        ],
        [
          "struct pcap_rpcap",
          {},
          "",
          [
            614,
            1
          ],
          [
            614,
            18
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            615,
            1
          ],
          [
            615,
            19
          ]
        ],
        [
          "struct pcap_rpcap",
          {},
          "",
          [
            706,
            1
          ],
          [
            706,
            18
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            707,
            1
          ],
          [
            707,
            20
          ]
        ],
        [
          "struct activehosts",
          {},
          "",
          [
            708,
            1
          ],
          [
            708,
            19
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            734,
            13
          ],
          [
            734,
            32
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            747,
            13
          ],
          [
            747,
            32
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            812,
            39
          ],
          [
            812,
            55
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            814,
            1
          ],
          [
            814,
            17
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            829,
            7
          ],
          [
            829,
            23
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            875,
            7
          ],
          [
            875,
            23
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            875,
            54
          ],
          [
            875,
            70
          ]
        ],
        [
          "struct pcap_rpcap",
          {},
          "",
          [
            877,
            1
          ],
          [
            877,
            18
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            878,
            1
          ],
          [
            878,
            20
          ]
        ],
        [
          "struct rpcap_stats",
          {},
          "",
          [
            879,
            1
          ],
          [
            879,
            19
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            920,
            12
          ],
          [
            920,
            31
          ]
        ],
        [
          "struct rpcap_stats",
          {},
          "",
          [
            932,
            12
          ],
          [
            932,
            30
          ]
        ],
        [
          "struct activehosts",
          {},
          "",
          [
            984,
            7
          ],
          [
            984,
            25
          ]
        ],
        [
          "struct activehosts",
          {},
          "",
          [
            987,
            1
          ],
          [
            987,
            19
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            988,
            1
          ],
          [
            988,
            16
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            993,
            26
          ],
          [
            993,
            41
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1013,
            34
          ],
          [
            1013,
            57
          ]
        ],
        [
          "struct pcap_rpcap",
          {},
          "",
          [
            1051,
            1
          ],
          [
            1051,
            18
          ]
        ],
        [
          "struct activehosts",
          {},
          "",
          [
            1057,
            1
          ],
          [
            1057,
            19
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            1061,
            1
          ],
          [
            1061,
            16
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            1062,
            1
          ],
          [
            1062,
            16
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1064,
            1
          ],
          [
            1064,
            24
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1069,
            1
          ],
          [
            1069,
            20
          ]
        ],
        [
          "struct rpcap_startcapreq",
          {},
          "",
          [
            1070,
            1
          ],
          [
            1070,
            25
          ]
        ],
        [
          "struct rpcap_startcapreply",
          {},
          "",
          [
            1071,
            1
          ],
          [
            1071,
            27
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1111,
            19
          ],
          [
            1111,
            42
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1112,
            36
          ],
          [
            1112,
            51
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1117,
            15
          ],
          [
            1117,
            38
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1120,
            18
          ],
          [
            1120,
            33
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            1139,
            27
          ],
          [
            1139,
            42
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1158,
            20
          ],
          [
            1158,
            43
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1159,
            29
          ],
          [
            1159,
            44
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1166,
            19
          ],
          [
            1166,
            34
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1178,
            33
          ],
          [
            1178,
            52
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1182,
            18
          ],
          [
            1182,
            37
          ]
        ],
        [
          "struct rpcap_startcapreq",
          {},
          "",
          [
            1184,
            12
          ],
          [
            1184,
            36
          ]
        ],
        [
          "struct rpcap_filter",
          {},
          "",
          [
            1184,
            47
          ],
          [
            1184,
            66
          ]
        ],
        [
          "struct rpcap_filterbpf_insn",
          {},
          "",
          [
            1184,
            96
          ],
          [
            1184,
            123
          ]
        ],
        [
          "struct rpcap_startcapreq",
          {},
          "",
          [
            1187,
            16
          ],
          [
            1187,
            40
          ]
        ],
        [
          "struct rpcap_startcapreq",
          {},
          "",
          [
            1189,
            33
          ],
          [
            1189,
            57
          ]
        ],
        [
          "struct rpcap_startcapreq",
          {},
          "",
          [
            1193,
            31
          ],
          [
            1193,
            55
          ]
        ],
        [
          "struct rpcap_startcapreply",
          {},
          "",
          [
            1234,
            12
          ],
          [
            1234,
            38
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            1252,
            28
          ],
          [
            1252,
            43
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1273,
            21
          ],
          [
            1273,
            44
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1275,
            32
          ],
          [
            1275,
            47
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            1328,
            31
          ],
          [
            1328,
            49
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1370,
            22
          ],
          [
            1370,
            41
          ]
        ],
        [
          "struct rpcap_pkthdr",
          {},
          "",
          [
            1370,
            52
          ],
          [
            1370,
            71
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            1398,
            2
          ],
          [
            1398,
            20
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            1499,
            75
          ],
          [
            1499,
            93
          ]
        ],
        [
          "struct rpcap_filter",
          {},
          "",
          [
            1501,
            1
          ],
          [
            1501,
            20
          ]
        ],
        [
          "struct rpcap_filterbpf_insn",
          {},
          "",
          [
            1502,
            1
          ],
          [
            1502,
            28
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            1503,
            1
          ],
          [
            1503,
            16
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            1504,
            1
          ],
          [
            1504,
            19
          ]
        ],
        [
          "struct rpcap_filter",
          {},
          "",
          [
            1515,
            11
          ],
          [
            1515,
            30
          ]
        ],
        [
          "struct rpcap_filter",
          {},
          "",
          [
            1517,
            33
          ],
          [
            1517,
            52
          ]
        ],
        [
          "struct rpcap_filterbpf_insn",
          {},
          "",
          [
            1524,
            48
          ],
          [
            1524,
            75
          ]
        ],
        [
          "struct rpcap_filterbpf_insn",
          {},
          "",
          [
            1528,
            9
          ],
          [
            1528,
            36
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            1570,
            48
          ],
          [
            1570,
            66
          ]
        ],
        [
          "struct pcap_rpcap",
          {},
          "",
          [
            1572,
            1
          ],
          [
            1572,
            18
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1575,
            1
          ],
          [
            1575,
            20
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1577,
            33
          ],
          [
            1577,
            52
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1581,
            18
          ],
          [
            1581,
            37
          ]
        ],
        [
          "struct rpcap_filter",
          {},
          "",
          [
            1583,
            12
          ],
          [
            1583,
            31
          ]
        ],
        [
          "struct rpcap_filterbpf_insn",
          {},
          "",
          [
            1583,
            57
          ],
          [
            1583,
            84
          ]
        ],
        [
          "struct pcap_rpcap",
          {},
          "",
          [
            1609,
            1
          ],
          [
            1609,
            18
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            1641,
            44
          ],
          [
            1641,
            62
          ]
        ],
        [
          "struct pcap_rpcap",
          {},
          "",
          [
            1643,
            1
          ],
          [
            1643,
            18
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            1670,
            52
          ],
          [
            1670,
            70
          ]
        ],
        [
          "struct pcap_rpcap",
          {},
          "",
          [
            1672,
            1
          ],
          [
            1672,
            18
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1678,
            2
          ],
          [
            1678,
            25
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1688,
            20
          ],
          [
            1688,
            43
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1689,
            37
          ],
          [
            1689,
            52
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1695,
            19
          ],
          [
            1695,
            34
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1704,
            37
          ],
          [
            1704,
            52
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1711,
            19
          ],
          [
            1711,
            34
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1719,
            37
          ],
          [
            1719,
            52
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1726,
            19
          ],
          [
            1726,
            34
          ]
        ],
        [
          "struct pcap_rpcap",
          {},
          "",
          [
            1802,
            1
          ],
          [
            1802,
            18
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1805,
            1
          ],
          [
            1805,
            20
          ]
        ],
        [
          "struct rpcap_sampling",
          {},
          "",
          [
            1806,
            1
          ],
          [
            1806,
            22
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1828,
            33
          ],
          [
            1828,
            52
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1832,
            18
          ],
          [
            1832,
            37
          ]
        ],
        [
          "struct rpcap_sampling",
          {},
          "",
          [
            1834,
            12
          ],
          [
            1834,
            33
          ]
        ],
        [
          "struct rpcap_sampling",
          {},
          "",
          [
            1837,
            18
          ],
          [
            1837,
            39
          ]
        ],
        [
          "struct rpcap_sampling",
          {},
          "",
          [
            1839,
            33
          ],
          [
            1839,
            54
          ]
        ],
        [
          "struct rpcap_sampling",
          {},
          "",
          [
            1843,
            33
          ],
          [
            1843,
            54
          ]
        ],
        [
          "struct pcap_rmtauth",
          {},
          "",
          [
            1904,
            63
          ],
          [
            1904,
            82
          ]
        ],
        [
          "struct rpcap_auth",
          {},
          "",
          [
            1909,
            1
          ],
          [
            1909,
            18
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1911,
            1
          ],
          [
            1911,
            20
          ]
        ],
        [
          "struct rpcap_authreply",
          {},
          "",
          [
            1914,
            1
          ],
          [
            1914,
            23
          ]
        ],
        [
          "struct rpcap_auth",
          {},
          "",
          [
            1922,
            19
          ],
          [
            1922,
            36
          ]
        ],
        [
          "struct rpcap_auth",
          {},
          "",
          [
            1926,
            19
          ],
          [
            1926,
            36
          ]
        ],
        [
          "struct rpcap_auth",
          {},
          "",
          [
            1959,
            18
          ],
          [
            1959,
            35
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1962,
            33
          ],
          [
            1962,
            52
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1966,
            18
          ],
          [
            1966,
            37
          ]
        ],
        [
          "struct rpcap_auth",
          {},
          "",
          [
            1969,
            11
          ],
          [
            1969,
            28
          ]
        ],
        [
          "struct rpcap_auth",
          {},
          "",
          [
            1971,
            33
          ],
          [
            1971,
            50
          ]
        ],
        [
          "struct rpcap_auth",
          {},
          "",
          [
            1975,
            26
          ],
          [
            1975,
            43
          ]
        ],
        [
          "struct rpcap_authreply",
          {},
          "",
          [
            2021,
            20
          ],
          [
            2021,
            42
          ]
        ],
        [
          "struct rpcap_authreply",
          {},
          "",
          [
            2030,
            13
          ],
          [
            2030,
            35
          ]
        ],
        [
          "struct pcap_rmtauth",
          {},
          "",
          [
            2121,
            40
          ],
          [
            2121,
            59
          ]
        ],
        [
          "struct activehosts",
          {},
          "",
          [
            2127,
            1
          ],
          [
            2127,
            19
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            2178,
            2
          ],
          [
            2178,
            17
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            2179,
            2
          ],
          [
            2179,
            17
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            2193,
            27
          ],
          [
            2193,
            42
          ]
        ],
        [
          "struct pcap_rmtauth",
          {},
          "",
          [
            2298,
            86
          ],
          [
            2298,
            105
          ]
        ],
        [
          "struct pcap_rpcap",
          {},
          "",
          [
            2302,
            1
          ],
          [
            2302,
            18
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2313,
            1
          ],
          [
            2313,
            20
          ]
        ],
        [
          "struct rpcap_openreply",
          {},
          "",
          [
            2314,
            1
          ],
          [
            2314,
            23
          ]
        ],
        [
          "struct pcap_rpcap",
          {},
          "",
          [
            2316,
            41
          ],
          [
            2316,
            58
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2367,
            33
          ],
          [
            2367,
            52
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2371,
            18
          ],
          [
            2371,
            37
          ]
        ],
        [
          "struct rpcap_openreply",
          {},
          "",
          [
            2390,
            12
          ],
          [
            2390,
            34
          ]
        ],
        [
          "struct pcap_addr",
          {},
          "",
          [
            2460,
            9
          ],
          [
            2460,
            25
          ]
        ],
        [
          "struct pcap_rmtauth",
          {},
          "",
          [
            2470,
            47
          ],
          [
            2470,
            66
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2476,
            1
          ],
          [
            2476,
            20
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2504,
            54
          ],
          [
            2504,
            73
          ]
        ],
        [
          "struct rpcap_findalldevs_if",
          {},
          "",
          [
            2521,
            2
          ],
          [
            2521,
            29
          ]
        ],
        [
          "struct pcap_addr",
          {},
          "",
          [
            2523,
            2
          ],
          [
            2523,
            18
          ]
        ],
        [
          "struct rpcap_findalldevs_if",
          {},
          "",
          [
            2529,
            13
          ],
          [
            2529,
            40
          ]
        ],
        [
          "struct rpcap_findalldevs_ifaddr",
          {},
          "",
          [
            2628,
            3
          ],
          [
            2628,
            34
          ]
        ],
        [
          "struct rpcap_findalldevs_ifaddr",
          {},
          "",
          [
            2632,
            14
          ],
          [
            2632,
            45
          ]
        ],
        [
          "struct pcap_addr",
          {},
          "",
          [
            2639,
            11
          ],
          [
            2639,
            27
          ]
        ],
        [
          "struct pcap_addr",
          {},
          "",
          [
            2639,
            45
          ],
          [
            2639,
            61
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            2653,
            5
          ],
          [
            2653,
            28
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            2659,
            5
          ],
          [
            2659,
            28
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            2665,
            5
          ],
          [
            2665,
            28
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            2671,
            5
          ],
          [
            2671,
            28
          ]
        ],
        [
          "struct pcap_rmtauth",
          {},
          "",
          [
            2776,
            115
          ],
          [
            2776,
            134
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            2779,
            1
          ],
          [
            2779,
            16
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            2780,
            1
          ],
          [
            2780,
            16
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            2781,
            1
          ],
          [
            2781,
            24
          ]
        ],
        [
          "struct activehosts",
          {},
          "",
          [
            2786,
            1
          ],
          [
            2786,
            19
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            2791,
            26
          ],
          [
            2791,
            41
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            2827,
            18
          ],
          [
            2827,
            41
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            2829,
            30
          ],
          [
            2829,
            45
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            2860,
            18
          ],
          [
            2860,
            33
          ]
        ],
        [
          "struct activehosts",
          {},
          "",
          [
            2930,
            16
          ],
          [
            2930,
            34
          ]
        ],
        [
          "struct activehosts",
          {},
          "",
          [
            2930,
            52
          ],
          [
            2930,
            70
          ]
        ],
        [
          "struct activehosts",
          {},
          "",
          [
            2935,
            17
          ],
          [
            2935,
            35
          ]
        ],
        [
          "struct activehosts",
          {},
          "",
          [
            2935,
            53
          ],
          [
            2935,
            71
          ]
        ],
        [
          "struct pcap_rmtauth",
          {},
          "",
          [
            2965,
            112
          ],
          [
            2965,
            131
          ]
        ],
        [
          "struct activehosts",
          {},
          "",
          [
            2972,
            1
          ],
          [
            2972,
            19
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            2973,
            1
          ],
          [
            2973,
            16
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            2981,
            26
          ],
          [
            2981,
            41
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            2997,
            34
          ],
          [
            2997,
            57
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2999,
            4
          ],
          [
            2999,
            23
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            3012,
            15
          ],
          [
            3012,
            34
          ]
        ],
        [
          "struct activehosts",
          {},
          "",
          [
            3109,
            1
          ],
          [
            3109,
            19
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            3123,
            30
          ],
          [
            3123,
            53
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            3154,
            56
          ],
          [
            3154,
            75
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            3158,
            54
          ],
          [
            3158,
            73
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            3174,
            74
          ],
          [
            3174,
            93
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            3205,
            75
          ],
          [
            3205,
            94
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            3275,
            99
          ],
          [
            3275,
            118
          ]
        ],
        [
          "struct pcap_rpcap",
          {},
          "",
          [
            3405,
            33
          ],
          [
            3405,
            50
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include \"ftmacros.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <string.h>\t\t/* for strlen(), ... */\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <stdlib.h>\t\t/* for malloc(), free(), ... */\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <stdarg.h>\t\t/* for functions with variable number of arguments */\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <errno.h>\t\t/* for the errno variable */\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"sockutils.h\"\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"rpcap-protocol.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include \"pcap-rpcap.h\"\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include \"sslutils.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-bpf.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\npcap_getnonblock_bpf(pcap_t *p)\n{\n#ifdef HAVE_ZEROCOPY_BPF\n\tstruct pcap_bpf *pb = p->priv;\n\n\tif (pb->zerocopy)\n\t\treturn (pb->nonblock);\n#endif\n\treturn (pcap_getnonblock_fd(p));\n}",
          "fn_code_pos": [
            [
              257,
              0
            ],
            [
              267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getnonblock_bpf",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setnonblock_bpf(pcap_t *p, int nonblock)\n{\n#ifdef HAVE_ZEROCOPY_BPF\n\tstruct pcap_bpf *pb = p->priv;\n\n\tif (pb->zerocopy) {\n\t\tpb->nonblock = nonblock;\n\t\treturn (0);\n\t}\n#endif\n\treturn (pcap_setnonblock_fd(p, nonblock));\n}",
          "fn_code_pos": [
            [
              269,
              0
            ],
            [
              281,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setnonblock_bpf",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_next_zbuf_shm(pcap_t *p, int *cc)\n{\n\tstruct pcap_bpf *pb = p->priv;\n\tstruct bpf_zbuf_header *bzh;\n\n\tif (pb->zbuffer == pb->zbuf2 || pb->zbuffer == NULL) {\n\t\tbzh = (struct bpf_zbuf_header *)pb->zbuf1;\n\t\tif (bzh->bzh_user_gen !=\n\t\t    atomic_load_acq_int(&bzh->bzh_kernel_gen)) {\n\t\t\tpb->bzh = bzh;\n\t\t\tpb->zbuffer = (u_char *)pb->zbuf1;\n\t\t\tp->buffer = pb->zbuffer + sizeof(*bzh);\n\t\t\t*cc = bzh->bzh_kernel_len;\n\t\t\treturn (1);\n\t\t}\n\t} else if (pb->zbuffer == pb->zbuf1) {\n\t\tbzh = (struct bpf_zbuf_header *)pb->zbuf2;\n\t\tif (bzh->bzh_user_gen !=\n\t\t    atomic_load_acq_int(&bzh->bzh_kernel_gen)) {\n\t\t\tpb->bzh = bzh;\n\t\t\tpb->zbuffer = (u_char *)pb->zbuf2;\n  \t\t\tp->buffer = pb->zbuffer + sizeof(*bzh);\n\t\t\t*cc = bzh->bzh_kernel_len;\n\t\t\treturn (1);\n\t\t}\n\t}\n\t*cc = 0;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              293,
              0
            ],
            [
              322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_next_zbuf_shm",
            "parameters": {
              "p": "pcap_t",
              "cc": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_next_zbuf(pcap_t *p, int *cc)\n{\n\tstruct pcap_bpf *pb = p->priv;\n\tstruct bpf_zbuf bz;\n\tstruct timeval tv;\n\tstruct timespec cur;\n\tfd_set r_set;\n\tint data, r;\n\tint expire, tmout;\n\n#define TSTOMILLI(ts) (((ts)->tv_sec * 1000) + ((ts)->tv_nsec / 1000000))\n\t/*\n\t * Start out by seeing whether anything is waiting by checking the\n\t * next shared memory buffer for data.\n\t */\n\tdata = pcap_next_zbuf_shm(p, cc);\n\tif (data)\n\t\treturn (data);\n\t/*\n\t * If a previous sleep was interrupted due to signal delivery, make\n\t * sure that the timeout gets adjusted accordingly.  This requires\n\t * that we analyze when the timeout should be been expired, and\n\t * subtract the current time from that.  If after this operation,\n\t * our timeout is less then or equal to zero, handle it like a\n\t * regular timeout.\n\t */\n\ttmout = p->opt.timeout;\n\tif (tmout)\n\t\t(void) clock_gettime(CLOCK_MONOTONIC, &cur);\n\tif (pb->interrupted && p->opt.timeout) {\n\t\texpire = TSTOMILLI(&pb->firstsel) + p->opt.timeout;\n\t\ttmout = expire - TSTOMILLI(&cur);\n#undef TSTOMILLI\n\t\tif (tmout <= 0) {\n\t\t\tpb->interrupted = 0;\n\t\t\tdata = pcap_next_zbuf_shm(p, cc);\n\t\t\tif (data)\n\t\t\t\treturn (data);\n\t\t\tif (ioctl(p->fd, BIOCROTZBUF, &bz) < 0) {\n\t\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"BIOCROTZBUF\");\n\t\t\t\treturn (PCAP_ERROR);\n\t\t\t}\n\t\t\treturn (pcap_next_zbuf_shm(p, cc));\n\t\t}\n\t}\n\t/*\n\t * No data in the buffer, so must use select() to wait for data or\n\t * the next timeout.  Note that we only call select if the handle\n\t * is in blocking mode.\n\t */\n\tif (!pb->nonblock) {\n\t\tFD_ZERO(&r_set);\n\t\tFD_SET(p->fd, &r_set);\n\t\tif (tmout != 0) {\n\t\t\ttv.tv_sec = tmout / 1000;\n\t\t\ttv.tv_usec = (tmout * 1000) % 1000000;\n\t\t}\n\t\tr = select(p->fd + 1, &r_set, NULL, NULL,\n\t\t    p->opt.timeout != 0 ? &tv : NULL);\n\t\tif (r < 0 && errno == EINTR) {\n\t\t\tif (!pb->interrupted && p->opt.timeout) {\n\t\t\t\tpb->interrupted = 1;\n\t\t\t\tpb->firstsel = cur;\n\t\t\t}\n\t\t\treturn (0);\n\t\t} else if (r < 0) {\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"select\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\tpb->interrupted = 0;\n\t/*\n\t * Check again for data, which may exist now that we've either been\n\t * woken up as a result of data or timed out.  Try the \"there's data\"\n\t * case first since it doesn't require a system call.\n\t */\n\tdata = pcap_next_zbuf_shm(p, cc);\n\tif (data)\n\t\treturn (data);\n\t/*\n\t * Try forcing a buffer rotation to dislodge timed out or immediate\n\t * data.\n\t */\n\tif (ioctl(p->fd, BIOCROTZBUF, &bz) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"BIOCROTZBUF\");\n\t\treturn (PCAP_ERROR);\n\t}\n\treturn (pcap_next_zbuf_shm(p, cc));\n}",
          "fn_code_pos": [
            [
              331,
              0
            ],
            [
              423,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_next_zbuf",
            "parameters": {
              "p": "pcap_t",
              "cc": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_ack_zbuf(pcap_t *p)\n{\n\tstruct pcap_bpf *pb = p->priv;\n\n\tatomic_store_rel_int(&pb->bzh->bzh_user_gen,\n\t    pb->bzh->bzh_kernel_gen);\n\tpb->bzh = NULL;\n\tp->buffer = NULL;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              429,
              0
            ],
            [
              439,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_ack_zbuf",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_create_interface(const char *device _U_, char *ebuf)\n{\n\tpcap_t *p;\n\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_bpf));\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = pcap_activate_bpf;\n\tp->can_set_rfmon_op = pcap_can_set_rfmon_bpf;\n#ifdef BIOCSTSTAMP\n\t/*\n\t * We claim that we support microsecond and nanosecond time\n\t * stamps.\n\t */\n\tp->tstamp_precision_count = 2;\n\tp->tstamp_precision_list = malloc(2 * sizeof(u_int));\n\tif (p->tstamp_precision_list == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno,\n\t\t    \"malloc\");\n\t\tfree(p);\n\t\treturn (NULL);\n\t}\n\tp->tstamp_precision_list[0] = PCAP_TSTAMP_PRECISION_MICRO;\n\tp->tstamp_precision_list[1] = PCAP_TSTAMP_PRECISION_NANO;\n#endif /* BIOCSTSTAMP */\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              442,
              0
            ],
            [
              470,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static int\nbpf_open(char *errbuf)\n{\n\tint fd = -1;\n\tstatic const char cloning_device[] = \"/dev/bpf\";\n\tint n = 0;\n\tchar device[sizeof \"/dev/bpf0000000000\"];\n\tstatic int no_cloning_bpf = 0;\n\n#ifdef _AIX\n\t/*\n\t * Load the bpf driver, if it isn't already loaded,\n\t * and create the BPF device entries, if they don't\n\t * already exist.\n\t */\n\tif (bpf_load(errbuf) == PCAP_ERROR)\n\t\treturn (PCAP_ERROR);\n#endif\n\n\t/*\n\t * First, unless we've already tried opening /dev/bpf and\n\t * gotten ENOENT, try opening /dev/bpf.\n\t * If it fails with ENOENT, remember that, so we don't try\n\t * again, and try /dev/bpfN.\n\t */\n\tif (!no_cloning_bpf &&\n\t    (fd = open(cloning_device, O_RDWR)) == -1 &&\n\t    ((errno != EACCES && errno != ENOENT) ||\n\t     (fd = open(cloning_device, O_RDONLY)) == -1)) {\n\t\tif (errno != ENOENT) {\n\t\t\tif (errno == EACCES)\n\t\t\t\tfd = PCAP_ERROR_PERM_DENIED;\n\t\t\telse\n\t\t\t\tfd = PCAP_ERROR;\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"(cannot open device) %s\", cloning_device);\n\t\t\treturn (fd);\n\t\t}\n\t\tno_cloning_bpf = 1;\n\t}\n\n\tif (no_cloning_bpf) {\n\t\t/*\n\t\t * We don't have /dev/bpf.\n\t\t * Go through all the /dev/bpfN minors and find one\n\t\t * that isn't in use.\n\t\t */\n\t\tdo {\n\t\t\t(void)pcap_snprintf(device, sizeof(device), \"/dev/bpf%d\", n++);\n\t\t\t/*\n\t\t\t * Initially try a read/write open (to allow the inject\n\t\t\t * method to work).  If that fails due to permission\n\t\t\t * issues, fall back to read-only.  This allows a\n\t\t\t * non-root user to be granted specific access to pcap\n\t\t\t * capabilities via file permissions.\n\t\t\t *\n\t\t\t * XXX - we should have an API that has a flag that\n\t\t\t * controls whether to open read-only or read-write,\n\t\t\t * so that denial of permission to send (or inability\n\t\t\t * to send, if sending packets isn't supported on\n\t\t\t * the device in question) can be indicated at open\n\t\t\t * time.\n\t\t\t */\n\t\t\tfd = open(device, O_RDWR);\n\t\t\tif (fd == -1 && errno == EACCES)\n\t\t\t\tfd = open(device, O_RDONLY);\n\t\t} while (fd < 0 && errno == EBUSY);\n\t}\n\n\t/*\n\t * XXX better message for all minors used\n\t */\n\tif (fd < 0) {\n\t\tswitch (errno) {\n\n\t\tcase ENOENT:\n\t\t\tfd = PCAP_ERROR;\n\t\t\tif (n == 1) {\n\t\t\t\t/*\n\t\t\t\t * /dev/bpf0 doesn't exist, which\n\t\t\t\t * means we probably have no BPF\n\t\t\t\t * devices.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"(there are no BPF devices)\");\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We got EBUSY on at least one\n\t\t\t\t * BPF device, so we have BPF\n\t\t\t\t * devices, but all the ones\n\t\t\t\t * that exist are busy.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"(all BPF devices are busy)\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase EACCES:\n\t\t\t/*\n\t\t\t * Got EACCES on the last device we tried,\n\t\t\t * and EBUSY on all devices before that,\n\t\t\t * if any.\n\t\t\t */\n\t\t\tfd = PCAP_ERROR_PERM_DENIED;\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"(cannot open BPF device) %s\", device);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Some other problem.\n\t\t\t */\n\t\t\tfd = PCAP_ERROR;\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"(cannot open BPF device) %s\", device);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (fd);\n}",
          "fn_code_pos": [
            [
              476,
              0
            ],
            [
              596,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_open",
            "parameters": {
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nbpf_open_and_bind(const char *name, char *errbuf)\n{\n\tint fd;\n\tstruct ifreq ifr;\n\n\t/*\n\t * First, open a BPF device.\n\t */\n\tfd = bpf_open(errbuf);\n\tif (fd < 0)\n\t\treturn (fd);\t/* fd is the appropriate error code */\n\n\t/*\n\t * Now bind to the device.\n\t */\n\t(void)strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));\n\tif (ioctl(fd, BIOCSETIF, (caddr_t)&ifr) < 0) {\n\t\tswitch (errno) {\n\n\t\tcase ENXIO:\n\t\t\t/*\n\t\t\t * There's no such device.\n\t\t\t */\n\t\t\tclose(fd);\n\t\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\n\t\tcase ENETDOWN:\n\t\t\t/*\n\t\t\t * Return a \"network down\" indication, so that\n\t\t\t * the application can report that rather than\n\t\t\t * saying we had a mysterious failure and\n\t\t\t * suggest that they report a problem to the\n\t\t\t * libpcap developers.\n\t\t\t */\n\t\t\tclose(fd);\n\t\t\treturn (PCAP_ERROR_IFACE_NOT_UP);\n\n\t\tdefault:\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"BIOCSETIF: %s\", name);\n\t\t\tclose(fd);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\n\t/*\n\t * Success.\n\t */\n\treturn (fd);\n}",
          "fn_code_pos": [
            [
              606,
              0
            ],
            [
              656,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_open_and_bind",
            "parameters": {
              "name": "char",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nget_dlt_list(int fd, int v, struct bpf_dltlist *bdlp, char *ebuf)\n{\n\tmemset(bdlp, 0, sizeof(*bdlp));\n\tif (ioctl(fd, BIOCGDLTLIST, (caddr_t)bdlp) == 0) {\n\t\tu_int i;\n\t\tint is_ethernet;\n\n\t\tbdlp->bfl_list = (u_int *) malloc(sizeof(u_int) * (bdlp->bfl_len + 1));\n\t\tif (bdlp->bfl_list == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\n\t\tif (ioctl(fd, BIOCGDLTLIST, (caddr_t)bdlp) < 0) {\n\t\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"BIOCGDLTLIST\");\n\t\t\tfree(bdlp->bfl_list);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\n\t\t/*\n\t\t * OK, for real Ethernet devices, add DLT_DOCSIS to the\n\t\t * list, so that an application can let you choose it,\n\t\t * in case you're capturing DOCSIS traffic that a Cisco\n\t\t * Cable Modem Termination System is putting out onto\n\t\t * an Ethernet (it doesn't put an Ethernet header onto\n\t\t * the wire, it puts raw DOCSIS frames out on the wire\n\t\t * inside the low-level Ethernet framing).\n\t\t *\n\t\t * A \"real Ethernet device\" is defined here as a device\n\t\t * that has a link-layer type of DLT_EN10MB and that has\n\t\t * no alternate link-layer types; that's done to exclude\n\t\t * 802.11 interfaces (which might or might not be the\n\t\t * right thing to do, but I suspect it is - Ethernet <->\n\t\t * 802.11 bridges would probably badly mishandle frames\n\t\t * that don't have Ethernet headers).\n\t\t *\n\t\t * On Solaris with BPF, Ethernet devices also offer\n\t\t * DLT_IPNET, so we, if DLT_IPNET is defined, we don't\n\t\t * treat it as an indication that the device isn't an\n\t\t * Ethernet.\n\t\t */\n\t\tif (v == DLT_EN10MB) {\n\t\t\tis_ethernet = 1;\n\t\t\tfor (i = 0; i < bdlp->bfl_len; i++) {\n\t\t\t\tif (bdlp->bfl_list[i] != DLT_EN10MB\n#ifdef DLT_IPNET\n\t\t\t\t    && bdlp->bfl_list[i] != DLT_IPNET\n#endif\n\t\t\t\t    ) {\n\t\t\t\t\tis_ethernet = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_ethernet) {\n\t\t\t\t/*\n\t\t\t\t * We reserved one more slot at the end of\n\t\t\t\t * the list.\n\t\t\t\t */\n\t\t\t\tbdlp->bfl_list[bdlp->bfl_len] = DLT_DOCSIS;\n\t\t\t\tbdlp->bfl_len++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/*\n\t\t * EINVAL just means \"we don't support this ioctl on\n\t\t * this device\"; don't treat it as an error.\n\t\t */\n\t\tif (errno != EINVAL) {\n\t\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"BIOCGDLTLIST\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              659,
              0
            ],
            [
              736,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_dlt_list",
            "parameters": {
              "fd": "int",
              "v": "int",
              "bdlp": "struct bpf_dltlist",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_can_set_rfmon_bpf(pcap_t *p)\n{\n\tstruct utsname osinfo;\n\tstruct ifreq ifr;\n\tint fd;\n#ifdef BIOCGDLTLIST\n\tstruct bpf_dltlist bdl;\n#endif\n\n\t/*\n\t * The joys of monitor mode on Mac OS X/OS X/macOS.\n\t *\n\t * Prior to 10.4, it's not supported at all.\n\t *\n\t * In 10.4, if adapter enN supports monitor mode, there's a\n\t * wltN adapter corresponding to it; you open it, instead of\n\t * enN, to get monitor mode.  You get whatever link-layer\n\t * headers it supplies.\n\t *\n\t * In 10.5, and, we assume, later releases, if adapter enN\n\t * supports monitor mode, it offers, among its selectable\n\t * DLT_ values, values that let you get the 802.11 header;\n\t * selecting one of those values puts the adapter into monitor\n\t * mode (i.e., you can't get 802.11 headers except in monitor\n\t * mode, and you can't get Ethernet headers in monitor mode).\n\t */\n\tif (uname(&osinfo) == -1) {\n\t\t/*\n\t\t * Can't get the OS version; just say \"no\".\n\t\t */\n\t\treturn (0);\n\t}\n\t/*\n\t * We assume osinfo.sysname is \"Darwin\", because\n\t * __APPLE__ is defined.  We just check the version.\n\t */\n\tif (osinfo.release[0] < '8' && osinfo.release[1] == '.') {\n\t\t/*\n\t\t * 10.3 (Darwin 7.x) or earlier.\n\t\t * Monitor mode not supported.\n\t\t */\n\t\treturn (0);\n\t}\n\tif (osinfo.release[0] == '8' && osinfo.release[1] == '.') {\n\t\t/*\n\t\t * 10.4 (Darwin 8.x).  s/en/wlt/, and check\n\t\t * whether the device exists.\n\t\t */\n\t\tif (strncmp(p->opt.device, \"en\", 2) != 0) {\n\t\t\t/*\n\t\t\t * Not an enN device; no monitor mode.\n\t\t\t */\n\t\t\treturn (0);\n\t\t}\n\t\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\t\tif (fd == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"socket\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\tpcap_strlcpy(ifr.ifr_name, \"wlt\", sizeof(ifr.ifr_name));\n\t\tpcap_strlcat(ifr.ifr_name, p->opt.device + 2, sizeof(ifr.ifr_name));\n\t\tif (ioctl(fd, SIOCGIFFLAGS, (char *)&ifr) < 0) {\n\t\t\t/*\n\t\t\t * No such device?\n\t\t\t */\n\t\t\tclose(fd);\n\t\t\treturn (0);\n\t\t}\n\t\tclose(fd);\n\t\treturn (1);\n\t}\n\n#ifdef BIOCGDLTLIST\n\t/*\n\t * Everything else is 10.5 or later; for those,\n\t * we just open the enN device, and check whether\n\t * we have any 802.11 devices.\n\t *\n\t * First, open a BPF device.\n\t */\n\tfd = bpf_open(p->errbuf);\n\tif (fd < 0)\n\t\treturn (fd);\t/* fd is the appropriate error code */\n\n\t/*\n\t * Now bind to the device.\n\t */\n\t(void)strncpy(ifr.ifr_name, p->opt.device, sizeof(ifr.ifr_name));\n\tif (ioctl(fd, BIOCSETIF, (caddr_t)&ifr) < 0) {\n\t\tswitch (errno) {\n\n\t\tcase ENXIO:\n\t\t\t/*\n\t\t\t * There's no such device.\n\t\t\t */\n\t\t\tclose(fd);\n\t\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\n\t\tcase ENETDOWN:\n\t\t\t/*\n\t\t\t * Return a \"network down\" indication, so that\n\t\t\t * the application can report that rather than\n\t\t\t * saying we had a mysterious failure and\n\t\t\t * suggest that they report a problem to the\n\t\t\t * libpcap developers.\n\t\t\t */\n\t\t\tclose(fd);\n\t\t\treturn (PCAP_ERROR_IFACE_NOT_UP);\n\n\t\tdefault:\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"BIOCSETIF: %s\", p->opt.device);\n\t\t\tclose(fd);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\n\t/*\n\t * We know the default link type -- now determine all the DLTs\n\t * this interface supports.  If this fails with EINVAL, it's\n\t * not fatal; we just don't get to use the feature later.\n\t * (We don't care about DLT_DOCSIS, so we pass DLT_NULL\n\t * as the default DLT for this adapter.)\n\t */\n\tif (get_dlt_list(fd, DLT_NULL, &bdl, p->errbuf) == PCAP_ERROR) {\n\t\tclose(fd);\n\t\treturn (PCAP_ERROR);\n\t}\n\tif (find_802_11(&bdl) != -1) {\n\t\t/*\n\t\t * We have an 802.11 DLT, so we can set monitor mode.\n\t\t */\n\t\tfree(bdl.bfl_list);\n\t\tclose(fd);\n\t\treturn (1);\n\t}\n\tfree(bdl.bfl_list);\n\tclose(fd);\n#endif /* BIOCGDLTLIST */\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              740,
              0
            ],
            [
              882,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_can_set_rfmon_bpf",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_can_set_rfmon_bpf(pcap_t *p)\n{\n\tint ret;\n\n\tret = monitor_mode(p, 0);\n\tif (ret == PCAP_ERROR_RFMON_NOTSUP)\n\t\treturn (0);\t/* not an error, just a \"can't do\" */\n\tif (ret == 0)\n\t\treturn (1);\t/* success */\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              884,
              0
            ],
            [
              895,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_can_set_rfmon_bpf",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_stats_bpf(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct bpf_stat s;\n\n\t/*\n\t * \"ps_recv\" counts packets handed to the filter, not packets\n\t * that passed the filter.  This includes packets later dropped\n\t * because we ran out of buffer space.\n\t *\n\t * \"ps_drop\" counts packets dropped inside the BPF device\n\t * because we ran out of buffer space.  It doesn't count\n\t * packets dropped by the interface driver.  It counts\n\t * only packets that passed the filter.\n\t *\n\t * Both statistics include packets not yet read from the kernel\n\t * by libpcap, and thus not yet seen by the application.\n\t */\n\tif (ioctl(p->fd, BIOCGSTATS, (caddr_t)&s) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"BIOCGSTATS\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tps->ps_recv = s.bs_recv;\n\tps->ps_drop = s.bs_drop;\n\tps->ps_ifdrop = 0;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              904,
              0
            ],
            [
              932,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_bpf",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_read_bpf(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_bpf *pb = p->priv;\n\tint cc;\n\tint n = 0;\n\tregister u_char *bp, *ep;\n\tu_char *datap;\n#ifdef PCAP_FDDIPAD\n\tregister u_int pad;\n#endif\n#ifdef HAVE_ZEROCOPY_BPF\n\tint i;\n#endif\n\n again:\n\t/*\n\t * Has \"pcap_breakloop()\" been called?\n\t */\n\tif (p->break_loop) {\n\t\t/*\n\t\t * Yes - clear the flag that indicates that it\n\t\t * has, and return PCAP_ERROR_BREAK to indicate\n\t\t * that we were told to break out of the loop.\n\t\t */\n\t\tp->break_loop = 0;\n\t\treturn (PCAP_ERROR_BREAK);\n\t}\n\tcc = p->cc;\n\tif (p->cc == 0) {\n\t\t/*\n\t\t * When reading without zero-copy from a file descriptor, we\n\t\t * use a single buffer and return a length of data in the\n\t\t * buffer.  With zero-copy, we update the p->buffer pointer\n\t\t * to point at whatever underlying buffer contains the next\n\t\t * data and update cc to reflect the data found in the\n\t\t * buffer.\n\t\t */\n#ifdef HAVE_ZEROCOPY_BPF\n\t\tif (pb->zerocopy) {\n\t\t\tif (p->buffer != NULL)\n\t\t\t\tpcap_ack_zbuf(p);\n\t\t\ti = pcap_next_zbuf(p, &cc);\n\t\t\tif (i == 0)\n\t\t\t\tgoto again;\n\t\t\tif (i < 0)\n\t\t\t\treturn (PCAP_ERROR);\n\t\t} else\n#endif\n\t\t{\n\t\t\tcc = (int)read(p->fd, p->buffer, p->bufsize);\n\t\t}\n\t\tif (cc < 0) {\n\t\t\t/* Don't choke when we get ptraced */\n\t\t\tswitch (errno) {\n\n\t\t\tcase EINTR:\n\t\t\t\tgoto again;\n\n#ifdef _AIX\n\t\t\tcase EFAULT:\n\t\t\t\t/*\n\t\t\t\t * Sigh.  More AIX wonderfulness.\n\t\t\t\t *\n\t\t\t\t * For some unknown reason the uiomove()\n\t\t\t\t * operation in the bpf kernel extension\n\t\t\t\t * used to copy the buffer into user\n\t\t\t\t * space sometimes returns EFAULT. I have\n\t\t\t\t * no idea why this is the case given that\n\t\t\t\t * a kernel debugger shows the user buffer\n\t\t\t\t * is correct. This problem appears to\n\t\t\t\t * be mostly mitigated by the memset of\n\t\t\t\t * the buffer before it is first used.\n\t\t\t\t * Very strange.... Shaun Clowes\n\t\t\t\t *\n\t\t\t\t * In any case this means that we shouldn't\n\t\t\t\t * treat EFAULT as a fatal error; as we\n\t\t\t\t * don't have an API for returning\n\t\t\t\t * a \"some packets were dropped since\n\t\t\t\t * the last packet you saw\" indication,\n\t\t\t\t * we just ignore EFAULT and keep reading.\n\t\t\t\t */\n\t\t\t\tgoto again;\n#endif\n\n\t\t\tcase EWOULDBLOCK:\n\t\t\t\treturn (0);\n\n\t\t\tcase ENXIO:\n\t\t\t\t/*\n\t\t\t\t * The device on which we're capturing\n\t\t\t\t * went away.\n\t\t\t\t *\n\t\t\t\t * XXX - we should really return\n\t\t\t\t * PCAP_ERROR_IFACE_NOT_UP, but\n\t\t\t\t * pcap_dispatch() etc. aren't\n\t\t\t\t * defined to retur that.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"The interface went down\");\n\t\t\t\treturn (PCAP_ERROR);\n\n#if defined(sun) && !defined(BSD) && !defined(__svr4__) && !defined(__SVR4)\n\t\t\t/*\n\t\t\t * Due to a SunOS bug, after 2^31 bytes, the kernel\n\t\t\t * file offset overflows and read fails with EINVAL.\n\t\t\t * The lseek() to 0 will fix things.\n\t\t\t */\n\t\t\tcase EINVAL:\n\t\t\t\tif (lseek(p->fd, 0L, SEEK_CUR) +\n\t\t\t\t    p->bufsize < 0) {\n\t\t\t\t\t(void)lseek(p->fd, 0L, SEEK_SET);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\t/* fall through */\n#endif\n\t\t\t}\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"read\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\tbp = (u_char *)p->buffer;\n\t} else\n\t\tbp = p->bp;\n\n\t/*\n\t * Loop through each packet.\n\t */\n#ifdef BIOCSTSTAMP\n#define bhp ((struct bpf_xhdr *)bp)\n#else\n#define bhp ((struct bpf_hdr *)bp)\n#endif\n\tep = bp + cc;\n#ifdef PCAP_FDDIPAD\n\tpad = p->fddipad;\n#endif\n\twhile (bp < ep) {\n\t\tregister u_int caplen, hdrlen;\n\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t * If so, return immediately - if we haven't read any\n\t\t * packets, clear the flag and return PCAP_ERROR_BREAK\n\t\t * to indicate that we were told to break out of the loop,\n\t\t * otherwise leave the flag set, so that the *next* call\n\t\t * will break out of the loop without having read any\n\t\t * packets, and return the number of packets we've\n\t\t * processed so far.\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\tp->bp = bp;\n\t\t\tp->cc = (int)(ep - bp);\n\t\t\t/*\n\t\t\t * ep is set based on the return value of read(),\n\t\t\t * but read() from a BPF device doesn't necessarily\n\t\t\t * return a value that's a multiple of the alignment\n\t\t\t * value for BPF_WORDALIGN().  However, whenever we\n\t\t\t * increment bp, we round up the increment value by\n\t\t\t * a value rounded up by BPF_WORDALIGN(), so we\n\t\t\t * could increment bp past ep after processing the\n\t\t\t * last packet in the buffer.\n\t\t\t *\n\t\t\t * We treat ep < bp as an indication that this\n\t\t\t * happened, and just set p->cc to 0.\n\t\t\t */\n\t\t\tif (p->cc < 0)\n\t\t\t\tp->cc = 0;\n\t\t\tif (n == 0) {\n\t\t\t\tp->break_loop = 0;\n\t\t\t\treturn (PCAP_ERROR_BREAK);\n\t\t\t} else\n\t\t\t\treturn (n);\n\t\t}\n\n\t\tcaplen = bhp->bh_caplen;\n\t\thdrlen = bhp->bh_hdrlen;\n\t\tdatap = bp + hdrlen;\n\t\t/*\n\t\t * Short-circuit evaluation: if using BPF filter\n\t\t * in kernel, no need to do it now - we already know\n\t\t * the packet passed the filter.\n\t\t *\n#ifdef PCAP_FDDIPAD\n\t\t * Note: the filter code was generated assuming\n\t\t * that p->fddipad was the amount of padding\n\t\t * before the header, as that's what's required\n\t\t * in the kernel, so we run the filter before\n\t\t * skipping that padding.\n#endif\n\t\t */\n\t\tif (pb->filtering_in_kernel ||\n\t\t    pcap_filter(p->fcode.bf_insns, datap, bhp->bh_datalen, caplen)) {\n\t\t\tstruct pcap_pkthdr pkthdr;\n#ifdef BIOCSTSTAMP\n\t\t\tstruct bintime bt;\n\n\t\t\tbt.sec = bhp->bh_tstamp.bt_sec;\n\t\t\tbt.frac = bhp->bh_tstamp.bt_frac;\n\t\t\tif (p->opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO) {\n\t\t\t\tstruct timespec ts;\n\n\t\t\t\tbintime2timespec(&bt, &ts);\n\t\t\t\tpkthdr.ts.tv_sec = ts.tv_sec;\n\t\t\t\tpkthdr.ts.tv_usec = ts.tv_nsec;\n\t\t\t} else {\n\t\t\t\tstruct timeval tv;\n\n\t\t\t\tbintime2timeval(&bt, &tv);\n\t\t\t\tpkthdr.ts.tv_sec = tv.tv_sec;\n\t\t\t\tpkthdr.ts.tv_usec = tv.tv_usec;\n\t\t\t}\n#else\n\t\t\tpkthdr.ts.tv_sec = bhp->bh_tstamp.tv_sec;\n#ifdef _AIX\n\t\t\t/*\n\t\t\t * AIX's BPF returns seconds/nanoseconds time\n\t\t\t * stamps, not seconds/microseconds time stamps.\n\t\t\t */\n\t\t\tpkthdr.ts.tv_usec = bhp->bh_tstamp.tv_usec/1000;\n#else\n\t\t\tpkthdr.ts.tv_usec = bhp->bh_tstamp.tv_usec;\n#endif\n#endif /* BIOCSTSTAMP */\n#ifdef PCAP_FDDIPAD\n\t\t\tif (caplen > pad)\n\t\t\t\tpkthdr.caplen = caplen - pad;\n\t\t\telse\n\t\t\t\tpkthdr.caplen = 0;\n\t\t\tif (bhp->bh_datalen > pad)\n\t\t\t\tpkthdr.len = bhp->bh_datalen - pad;\n\t\t\telse\n\t\t\t\tpkthdr.len = 0;\n\t\t\tdatap += pad;\n#else\n\t\t\tpkthdr.caplen = caplen;\n\t\t\tpkthdr.len = bhp->bh_datalen;\n#endif\n\t\t\t(*callback)(user, &pkthdr, datap);\n\t\t\tbp += BPF_WORDALIGN(caplen + hdrlen);\n\t\t\tif (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt)) {\n\t\t\t\tp->bp = bp;\n\t\t\t\tp->cc = (int)(ep - bp);\n\t\t\t\t/*\n\t\t\t\t * See comment above about p->cc < 0.\n\t\t\t\t */\n\t\t\t\tif (p->cc < 0)\n\t\t\t\t\tp->cc = 0;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Skip this packet.\n\t\t\t */\n\t\t\tbp += BPF_WORDALIGN(caplen + hdrlen);\n\t\t}\n\t}\n#undef bhp\n\tp->cc = 0;\n\treturn (n);\n}",
          "fn_code_pos": [
            [
              934,
              0
            ],
            [
              1194,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_bpf",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_inject_bpf(pcap_t *p, const void *buf, int size)\n{\n\tint ret;\n\n\tret = (int)write(p->fd, buf, size);\n#ifdef __APPLE__\n\tif (ret == -1 && errno == EAFNOSUPPORT) {\n\t\t/*\n\t\t * In some versions of macOS, there's a bug wherein setting\n\t\t * the BIOCSHDRCMPLT flag causes writes to fail; see, for\n\t\t * example:\n\t\t *\n\t\t *\thttp://cerberus.sourcefire.com/~jeff/archives/patches/macosx/BIOCSHDRCMPLT-10.3.3.patch\n\t\t *\n\t\t * So, if, on macOS, we get EAFNOSUPPORT from the write, we\n\t\t * assume it's due to that bug, and turn off that flag\n\t\t * and try again.  If we succeed, it either means that\n\t\t * somebody applied the fix from that URL, or other patches\n\t\t * for that bug from\n\t\t *\n\t\t *\thttp://cerberus.sourcefire.com/~jeff/archives/patches/macosx/\n\t\t *\n\t\t * and are running a Darwin kernel with those fixes, or\n\t\t * that Apple fixed the problem in some macOS release.\n\t\t */\n\t\tu_int spoof_eth_src = 0;\n\n\t\tif (ioctl(p->fd, BIOCSHDRCMPLT, &spoof_eth_src) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"send: can't turn off BIOCSHDRCMPLT\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\n\t\t/*\n\t\t * Now try the write again.\n\t\t */\n\t\tret = (int)write(p->fd, buf, size);\n\t}\n#endif /* __APPLE__ */\n\tif (ret == -1) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"send\");\n\t\treturn (PCAP_ERROR);\n\t}\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              1196,
              0
            ],
            [
              1242,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject_bpf",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nbpf_odminit(char *errbuf)\n{\n\tchar *errstr;\n\n\tif (odm_initialize() == -1) {\n\t\tif (odm_err_msg(odmerrno, &errstr) == -1)\n\t\t\terrstr = \"Unknown error\";\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"bpf_load: odm_initialize failed: %s\",\n\t\t    errstr);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tif ((odmlockid = odm_lock(\"/etc/objrepos/config_lock\", ODM_WAIT)) == -1) {\n\t\tif (odm_err_msg(odmerrno, &errstr) == -1)\n\t\t\terrstr = \"Unknown error\";\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"bpf_load: odm_lock of /etc/objrepos/config_lock failed: %s\",\n\t\t    errstr);\n\t\t(void)odm_terminate();\n\t\treturn (PCAP_ERROR);\n\t}\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1245,
              0
            ],
            [
              1270,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_odminit",
            "parameters": {
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nbpf_odmcleanup(char *errbuf)\n{\n\tchar *errstr;\n\n\tif (odm_unlock(odmlockid) == -1) {\n\t\tif (errbuf != NULL) {\n\t\t\tif (odm_err_msg(odmerrno, &errstr) == -1)\n\t\t\t\terrstr = \"Unknown error\";\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"bpf_load: odm_unlock failed: %s\",\n\t\t\t    errstr);\n\t\t}\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tif (odm_terminate() == -1) {\n\t\tif (errbuf != NULL) {\n\t\t\tif (odm_err_msg(odmerrno, &errstr) == -1)\n\t\t\t\terrstr = \"Unknown error\";\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"bpf_load: odm_terminate failed: %s\",\n\t\t\t    errstr);\n\t\t}\n\t\treturn (PCAP_ERROR);\n\t}\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1272,
              0
            ],
            [
              1300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_odmcleanup",
            "parameters": {
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nbpf_load(char *errbuf)\n{\n\tlong major;\n\tint *minors;\n\tint numminors, i, rc;\n\tchar buf[1024];\n\tstruct stat sbuf;\n\tstruct bpf_config cfg_bpf;\n\tstruct cfg_load cfg_ld;\n\tstruct cfg_kmod cfg_km;\n\n\t/*\n\t * This is very very close to what happens in the real implementation\n\t * but I've fixed some (unlikely) bug situations.\n\t */\n\tif (bpfloadedflag)\n\t\treturn (0);\n\n\tif (bpf_odminit(errbuf) == PCAP_ERROR)\n\t\treturn (PCAP_ERROR);\n\n\tmajor = genmajor(BPF_NAME);\n\tif (major == -1) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"bpf_load: genmajor failed\");\n\t\t(void)bpf_odmcleanup(NULL);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tminors = getminor(major, &numminors, BPF_NAME);\n\tif (!minors) {\n\t\tminors = genminor(\"bpf\", major, 0, BPF_MINORS, 1, 1);\n\t\tif (!minors) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"bpf_load: genminor failed\");\n\t\t\t(void)bpf_odmcleanup(NULL);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\n\tif (bpf_odmcleanup(errbuf) == PCAP_ERROR)\n\t\treturn (PCAP_ERROR);\n\n\trc = stat(BPF_NODE \"0\", &sbuf);\n\tif (rc == -1 && errno != ENOENT) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"bpf_load: can't stat %s\", BPF_NODE \"0\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tif (rc == -1 || getmajor(sbuf.st_rdev) != major) {\n\t\tfor (i = 0; i < BPF_MINORS; i++) {\n\t\t\tpcap_snprintf(buf, sizeof(buf), \"%s%d\", BPF_NODE, i);\n\t\t\tunlink(buf);\n\t\t\tif (mknod(buf, S_IRUSR | S_IFCHR, domakedev(major, i)) == -1) {\n\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"bpf_load: can't mknod %s\", buf);\n\t\t\t\treturn (PCAP_ERROR);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check if the driver is loaded */\n\tmemset(&cfg_ld, 0x0, sizeof(cfg_ld));\n\tpcap_snprintf(buf, sizeof(buf), \"%s/%s\", DRIVER_PATH, BPF_NAME);\n\tcfg_ld.path = buf;\n\tif ((sysconfig(SYS_QUERYLOAD, (void *)&cfg_ld, sizeof(cfg_ld)) == -1) ||\n\t    (cfg_ld.kmid == 0)) {\n\t\t/* Driver isn't loaded, load it now */\n\t\tif (sysconfig(SYS_SINGLELOAD, (void *)&cfg_ld, sizeof(cfg_ld)) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"bpf_load: could not load driver\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\n\t/* Configure the driver */\n\tcfg_km.cmd = CFG_INIT;\n\tcfg_km.kmid = cfg_ld.kmid;\n\tcfg_km.mdilen = sizeof(cfg_bpf);\n\tcfg_km.mdiptr = (void *)&cfg_bpf;\n\tfor (i = 0; i < BPF_MINORS; i++) {\n\t\tcfg_bpf.devno = domakedev(major, i);\n\t\tif (sysconfig(SYS_CFGKMOD, (void *)&cfg_km, sizeof(cfg_km)) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"bpf_load: could not configure driver\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\n\tbpfloadedflag = 1;\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1302,
              0
            ],
            [
              1397,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_load",
            "parameters": {
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\npcap_cleanup_bpf(pcap_t *p)\n{\n\tstruct pcap_bpf *pb = p->priv;\n#ifdef HAVE_BSD_IEEE80211\n\tint sock;\n\tstruct ifmediareq req;\n\tstruct ifreq ifr;\n#endif\n\n\tif (pb->must_do_on_close != 0) {\n\t\t/*\n\t\t * There's something we have to do when closing this\n\t\t * pcap_t.\n\t\t */\n#ifdef HAVE_BSD_IEEE80211\n\t\tif (pb->must_do_on_close & MUST_CLEAR_RFMON) {\n\t\t\t/*\n\t\t\t * We put the interface into rfmon mode;\n\t\t\t * take it out of rfmon mode.\n\t\t\t *\n\t\t\t * XXX - if somebody else wants it in rfmon\n\t\t\t * mode, this code cannot know that, so it'll take\n\t\t\t * it out of rfmon mode.\n\t\t\t */\n\t\t\tsock = socket(AF_INET, SOCK_DGRAM, 0);\n\t\t\tif (sock == -1) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"Can't restore interface flags (socket() failed: %s).\\n\"\n\t\t\t\t    \"Please adjust manually.\\n\",\n\t\t\t\t    strerror(errno));\n\t\t\t} else {\n\t\t\t\tmemset(&req, 0, sizeof(req));\n\t\t\t\tstrncpy(req.ifm_name, pb->device,\n\t\t\t\t    sizeof(req.ifm_name));\n\t\t\t\tif (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t    \"Can't restore interface flags (SIOCGIFMEDIA failed: %s).\\n\"\n\t\t\t\t\t    \"Please adjust manually.\\n\",\n\t\t\t\t\t    strerror(errno));\n\t\t\t\t} else {\n\t\t\t\t\tif (req.ifm_current & IFM_IEEE80211_MONITOR) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Rfmon mode is currently on;\n\t\t\t\t\t\t * turn it off.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tmemset(&ifr, 0, sizeof(ifr));\n\t\t\t\t\t\t(void)strncpy(ifr.ifr_name,\n\t\t\t\t\t\t    pb->device,\n\t\t\t\t\t\t    sizeof(ifr.ifr_name));\n\t\t\t\t\t\tifr.ifr_media =\n\t\t\t\t\t\t    req.ifm_current & ~IFM_IEEE80211_MONITOR;\n\t\t\t\t\t\tif (ioctl(sock, SIOCSIFMEDIA,\n\t\t\t\t\t\t    &ifr) == -1) {\n\t\t\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\t    \"Can't restore interface flags (SIOCSIFMEDIA failed: %s).\\n\"\n\t\t\t\t\t\t\t    \"Please adjust manually.\\n\",\n\t\t\t\t\t\t\t    strerror(errno));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclose(sock);\n\t\t\t}\n\t\t}\n#endif /* HAVE_BSD_IEEE80211 */\n\n#if defined(__FreeBSD__) && defined(SIOCIFCREATE2)\n\t\t/*\n\t\t * Attempt to destroy the usbusN interface that we created.\n\t\t */\n\t\tif (pb->must_do_on_close & MUST_DESTROY_USBUS) {\n\t\t\tif (if_nametoindex(pb->device) > 0) {\n\t\t\t\tint s;\n\n\t\t\t\ts = socket(AF_LOCAL, SOCK_DGRAM, 0);\n\t\t\t\tif (s >= 0) {\n\t\t\t\t\tpcap_strlcpy(ifr.ifr_name, pb->device,\n\t\t\t\t\t    sizeof(ifr.ifr_name));\n\t\t\t\t\tioctl(s, SIOCIFDESTROY, &ifr);\n\t\t\t\t\tclose(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif /* defined(__FreeBSD__) && defined(SIOCIFCREATE2) */\n\t\t/*\n\t\t * Take this pcap out of the list of pcaps for which we\n\t\t * have to take the interface out of some mode.\n\t\t */\n\t\tpcap_remove_from_pcaps_to_close(p);\n\t\tpb->must_do_on_close = 0;\n\t}\n\n#ifdef HAVE_ZEROCOPY_BPF\n\tif (pb->zerocopy) {\n\t\t/*\n\t\t * Delete the mappings.  Note that p->buffer gets\n\t\t * initialized to one of the mmapped regions in\n\t\t * this case, so do not try and free it directly;\n\t\t * null it out so that pcap_cleanup_live_common()\n\t\t * doesn't try to free it.\n\t\t */\n\t\tif (pb->zbuf1 != MAP_FAILED && pb->zbuf1 != NULL)\n\t\t\t(void) munmap(pb->zbuf1, pb->zbufsize);\n\t\tif (pb->zbuf2 != MAP_FAILED && pb->zbuf2 != NULL)\n\t\t\t(void) munmap(pb->zbuf2, pb->zbufsize);\n\t\tp->buffer = NULL;\n\t}\n#endif\n\tif (pb->device != NULL) {\n\t\tfree(pb->device);\n\t\tpb->device = NULL;\n\t}\n\tpcap_cleanup_live_common(p);\n}",
          "fn_code_pos": [
            [
              1403,
              0
            ],
            [
              1516,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_cleanup_bpf",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ncheck_setif_failure(pcap_t *p, int error)\n{\n#ifdef __APPLE__\n\tint fd;\n\tstruct ifreq ifr;\n\tint err;\n#endif\n\n\tif (error == ENXIO) {\n\t\t/*\n\t\t * No such device exists.\n\t\t */\n#ifdef __APPLE__\n\t\tif (p->opt.rfmon && strncmp(p->opt.device, \"wlt\", 3) == 0) {\n\t\t\t/*\n\t\t\t * Monitor mode was requested, and we're trying\n\t\t\t * to open a \"wltN\" device.  Assume that this\n\t\t\t * is 10.4 and that we were asked to open an\n\t\t\t * \"enN\" device; if that device exists, return\n\t\t\t * \"monitor mode not supported on the device\".\n\t\t\t */\n\t\t\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\t\t\tif (fd != -1) {\n\t\t\t\tpcap_strlcpy(ifr.ifr_name, \"en\",\n\t\t\t\t    sizeof(ifr.ifr_name));\n\t\t\t\tpcap_strlcat(ifr.ifr_name, p->opt.device + 3,\n\t\t\t\t    sizeof(ifr.ifr_name));\n\t\t\t\tif (ioctl(fd, SIOCGIFFLAGS, (char *)&ifr) < 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We assume this failed because\n\t\t\t\t\t * the underlying device doesn't\n\t\t\t\t\t * exist.\n\t\t\t\t\t */\n\t\t\t\t\terr = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"SIOCGIFFLAGS on %s failed\",\n\t\t\t\t\t    ifr.ifr_name);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * The underlying \"enN\" device\n\t\t\t\t\t * exists, but there's no\n\t\t\t\t\t * corresponding \"wltN\" device;\n\t\t\t\t\t * that means that the \"enN\"\n\t\t\t\t\t * device doesn't support\n\t\t\t\t\t * monitor mode, probably because\n\t\t\t\t\t * it's an Ethernet device rather\n\t\t\t\t\t * than a wireless device.\n\t\t\t\t\t */\n\t\t\t\t\terr = PCAP_ERROR_RFMON_NOTSUP;\n\t\t\t\t}\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We can't find out whether there's\n\t\t\t\t * an underlying \"enN\" device, so\n\t\t\t\t * just report \"no such device\".\n\t\t\t\t */\n\t\t\t\terr = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    errno, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"socket() failed\");\n\t\t\t}\n\t\t\treturn (err);\n\t\t}\n#endif\n\t\t/*\n\t\t * No such device.\n\t\t */\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"BIOCSETIF failed\");\n\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\t} else if (errno == ENETDOWN) {\n\t\t/*\n\t\t * Return a \"network down\" indication, so that\n\t\t * the application can report that rather than\n\t\t * saying we had a mysterious failure and\n\t\t * suggest that they report a problem to the\n\t\t * libpcap developers.\n\t\t */\n\t\treturn (PCAP_ERROR_IFACE_NOT_UP);\n\t} else {\n\t\t/*\n\t\t * Some other error; fill in the error string, and\n\t\t * return PCAP_ERROR.\n\t\t */\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"BIOCSETIF: %s\", p->opt.device);\n\t\treturn (PCAP_ERROR);\n\t}\n}",
          "fn_code_pos": [
            [
              1518,
              0
            ],
            [
              1609,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "check_setif_failure",
            "parameters": {
              "p": "pcap_t",
              "error": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncheck_bpf_bindable(const char *name)\n{\n\tint fd;\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\n\t/*\n\t * On macOS, we don't do this check if the device name begins\n\t * with \"wlt\"; at least some versions of macOS (actually, it\n\t * was called \"Mac OS X\" then...) offer monitor mode capturing\n\t * by having a separate \"monitor mode\" device for each wireless\n\t * adapter, rather than by implementing the ioctls that\n\t * {Free,Net,Open,DragonFly}BSD provide. Opening that device\n\t * puts the adapter into monitor mode, which, at least for\n\t * some adapters, causes them to deassociate from the network\n\t * with which they're associated.\n\t *\n\t * Instead, we try to open the corresponding \"en\" device (so\n\t * that we don't end up with, for users without sufficient\n\t * privilege to open capture devices, a list of adapters that\n\t * only includes the wlt devices).\n\t */\n#ifdef __APPLE__\n\tif (strncmp(name, \"wlt\", 3) == 0) {\n\t\tchar *en_name;\n\t\tsize_t en_name_len;\n\n\t\t/*\n\t\t * Try to allocate a buffer for the \"en\"\n\t\t * device's name.\n\t\t */\n\t\ten_name_len = strlen(name) - 1;\n\t\ten_name = malloc(en_name_len + 1);\n\t\tif (en_name == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (-1);\n\t\t}\n\t\tstrcpy(en_name, \"en\");\n\t\tstrcat(en_name, name + 3);\n\t\tfd = bpf_open_and_bind(en_name, errbuf);\n\t\tfree(en_name);\n\t} else\n#endif /* __APPLE */\n\tfd = bpf_open_and_bind(name, errbuf);\n\tif (fd < 0) {\n\t\t/*\n\t\t * Error - was it PCAP_ERROR_NO_SUCH_DEVICE?\n\t\t */\n\t\tif (fd == PCAP_ERROR_NO_SUCH_DEVICE) {\n\t\t\t/*\n\t\t\t * Yes, so we can't bind to this because it's\n\t\t\t * not something supported by BPF.\n\t\t\t */\n\t\t\treturn (0);\n\t\t}\n\t\t/*\n\t\t * No, so we don't know whether it's supported or not;\n\t\t * say it is, so that the user can at least try to\n\t\t * open it and report the error (which is probably\n\t\t * \"you don't have permission to open BPF devices\";\n\t\t * reporting those interfaces means users will ask\n\t\t * \"why am I getting a permissions error when I try\n\t\t * to capture\" rather than \"why am I not seeing any\n\t\t * interfaces\", making the underlying problem clearer).\n\t\t */\n\t\treturn (1);\n\t}\n\n\t/*\n\t * Success.\n\t */\n\tclose(fd);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              2573,
              0
            ],
            [
              2647,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "check_bpf_bindable",
            "parameters": {
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nget_usb_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)\n{\n\t/*\n\t * XXX - if there's a way to determine whether there's something\n\t * plugged into a given USB bus, use that to determine whether\n\t * this device is \"connected\" or not.\n\t */\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2650,
              0
            ],
            [
              2659,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_usb_if_flags",
            "parameters": {
              "name": "char",
              "flags": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nfinddevs_usb(pcap_if_list_t *devlistp, char *errbuf)\n{\n\tDIR *usbdir;\n\tstruct dirent *usbitem;\n\tsize_t name_max;\n\tchar *name;\n\n\t/*\n\t * We might have USB sniffing support, so try looking for USB\n\t * interfaces.\n\t *\n\t * We want to report a usbusN device for each USB bus, but\n\t * usbusN interfaces might, or might not, exist for them -\n\t * we create one if there isn't already one.\n\t *\n\t * So, instead, we look in /dev/usb for all buses and create\n\t * a \"usbusN\" device for each one.\n\t */\n\tusbdir = opendir(\"/dev/usb\");\n\tif (usbdir == NULL) {\n\t\t/*\n\t\t * Just punt.\n\t\t */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Leave enough room for a 32-bit (10-digit) bus number.\n\t * Yes, that's overkill, but we won't be using\n\t * the buffer very long.\n\t */\n\tname_max = USBUS_PREFIX_LEN + 10 + 1;\n\tname = malloc(name_max);\n\tif (name == NULL) {\n\t\tclosedir(usbdir);\n\t\treturn (0);\n\t}\n\twhile ((usbitem = readdir(usbdir)) != NULL) {\n\t\tchar *p;\n\t\tsize_t busnumlen;\n\n\t\tif (strcmp(usbitem->d_name, \".\") == 0 ||\n\t\t    strcmp(usbitem->d_name, \"..\") == 0) {\n\t\t\t/*\n\t\t\t * Ignore these.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tp = strchr(usbitem->d_name, '.');\n\t\tif (p == NULL)\n\t\t\tcontinue;\n\t\tbusnumlen = p - usbitem->d_name;\n\t\tmemcpy(name, usbus_prefix, USBUS_PREFIX_LEN);\n\t\tmemcpy(name + USBUS_PREFIX_LEN, usbitem->d_name, busnumlen);\n\t\t*(name + USBUS_PREFIX_LEN + busnumlen) = '\\0';\n\t\t/*\n\t\t * There's an entry in this directory for every USB device,\n\t\t * not for every bus; if there's more than one device on\n\t\t * the bus, there'll be more than one entry for that bus,\n\t\t * so we need to avoid adding multiple capture devices\n\t\t * for each bus.\n\t\t */\n\t\tif (find_or_add_dev(devlistp, name, PCAP_IF_UP,\n\t\t    get_usb_if_flags, NULL, errbuf) == NULL) {\n\t\t\tfree(name);\n\t\t\tclosedir(usbdir);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\tfree(name);\n\tclosedir(usbdir);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2661,
              0
            ],
            [
              2734,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "finddevs_usb",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nget_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)\n{\n\tint sock;\n\tstruct ifmediareq req;\n\n\tsock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sock == -1) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,\n\t\t    \"Can't create socket to get media information for %s\",\n\t\t    name);\n\t\treturn (-1);\n\t}\n\tmemset(&req, 0, sizeof(req));\n\tstrncpy(req.ifm_name, name, sizeof(req.ifm_name));\n\tif (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {\n\t\tif (errno == EOPNOTSUPP || errno == EINVAL || errno == ENOTTY ||\n\t\t    errno == ENODEV || errno == EPERM) {\n\t\t\t/*\n\t\t\t * Not supported, so we can't provide any\n\t\t\t * additional information.  Assume that\n\t\t\t * this means that \"connected\" vs.\n\t\t\t * \"disconnected\" doesn't apply.\n\t\t\t *\n\t\t\t * The ioctl routine for Apple's pktap devices,\n\t\t\t * annoyingly, checks for \"are you root?\" before\n\t\t\t * checking whether the ioctl is valid, so it\n\t\t\t * returns EPERM, rather than ENOTSUP, for the\n\t\t\t * invalid SIOCGIFMEDIA, unless you're root.\n\t\t\t * So, just as we do for some ethtool ioctls\n\t\t\t * on Linux, which makes the same mistake, we\n\t\t\t * also treat EPERM as meaning \"not supported\".\n\t\t\t */\n\t\t\t*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\t\t\tclose(sock);\n\t\t\treturn (0);\n\t\t}\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,\n\t\t    \"SIOCGIFMEDIA on %s failed\", name);\n\t\tclose(sock);\n\t\treturn (-1);\n\t}\n\tclose(sock);\n\n\t/*\n\t * OK, what type of network is this?\n\t */\n\tswitch (IFM_TYPE(req.ifm_active)) {\n\n\tcase IFM_IEEE80211:\n\t\t/*\n\t\t * Wireless.\n\t\t */\n\t\t*flags |= PCAP_IF_WIRELESS;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Do we know whether it's connected?\n\t */\n\tif (req.ifm_status & IFM_AVALID) {\n\t\t/*\n\t\t * Yes.\n\t\t */\n\t\tif (req.ifm_status & IFM_ACTIVE) {\n\t\t\t/*\n\t\t\t * It's connected.\n\t\t\t */\n\t\t\t*flags |= PCAP_IF_CONNECTION_STATUS_CONNECTED;\n\t\t} else {\n\t\t\t/*\n\t\t\t * It's disconnected.\n\t\t\t */\n\t\t\t*flags |= PCAP_IF_CONNECTION_STATUS_DISCONNECTED;\n\t\t}\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2741,
              0
            ],
            [
              2818,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_if_flags",
            "parameters": {
              "name": "char",
              "flags": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nget_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)\n{\n\t/*\n\t * Nothing we can do other than mark loopback devices as \"the\n\t * connected/disconnected status doesn't apply\".\n\t *\n\t * XXX - on Solaris, can we do what the dladm command does,\n\t * i.e. get a connected/disconnected indication from a kstat?\n\t * (Note that you can also get the link speed, and possibly\n\t * other information, from a kstat as well.)\n\t */\n\tif (*flags & PCAP_IF_LOOPBACK) {\n\t\t/*\n\t\t * Loopback devices aren't wireless, and \"connected\"/\n\t\t * \"disconnected\" doesn't apply to them.\n\t\t */\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\t\treturn (0);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2820,
              0
            ],
            [
              2841,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_if_flags",
            "parameters": {
              "name": "char",
              "flags": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\t/*\n\t * Get the list of regular interfaces first.\n\t */\n\tif (pcap_findalldevs_interfaces(devlistp, errbuf, check_bpf_bindable,\n\t    get_if_flags) == -1)\n\t\treturn (-1);\t/* failure */\n\n#if defined(__FreeBSD__) && defined(SIOCIFCREATE2)\n\tif (finddevs_usb(devlistp, errbuf) == -1)\n\t\treturn (-1);\n#endif\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2844,
              0
            ],
            [
              2860,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_platform_finddevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nmonitor_mode(pcap_t *p, int set)\n{\n\tstruct pcap_bpf *pb = p->priv;\n\tint sock;\n\tstruct ifmediareq req;\n\tIFM_ULIST_TYPE *media_list;\n\tint i;\n\tint can_do;\n\tstruct ifreq ifr;\n\n\tsock = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sock == -1) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"can't open socket\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tmemset(&req, 0, sizeof req);\n\tstrncpy(req.ifm_name, p->opt.device, sizeof req.ifm_name);\n\n\t/*\n\t * Find out how many media types we have.\n\t */\n\tif (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {\n\t\t/*\n\t\t * Can't get the media types.\n\t\t */\n\t\tswitch (errno) {\n\n\t\tcase ENXIO:\n\t\t\t/*\n\t\t\t * There's no such device.\n\t\t\t */\n\t\t\tclose(sock);\n\t\t\treturn (PCAP_ERROR_NO_SUCH_DEVICE);\n\n\t\tcase EINVAL:\n\t\t\t/*\n\t\t\t * Interface doesn't support SIOC{G,S}IFMEDIA.\n\t\t\t */\n\t\t\tclose(sock);\n\t\t\treturn (PCAP_ERROR_RFMON_NOTSUP);\n\n\t\tdefault:\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"SIOCGIFMEDIA\");\n\t\t\tclose(sock);\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t}\n\tif (req.ifm_count == 0) {\n\t\t/*\n\t\t * No media types.\n\t\t */\n\t\tclose(sock);\n\t\treturn (PCAP_ERROR_RFMON_NOTSUP);\n\t}\n\n\t/*\n\t * Allocate a buffer to hold all the media types, and\n\t * get the media types.\n\t */\n\tmedia_list = malloc(req.ifm_count * sizeof(*media_list));\n\tif (media_list == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tclose(sock);\n\t\treturn (PCAP_ERROR);\n\t}\n\treq.ifm_ulist = media_list;\n\tif (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCGIFMEDIA\");\n\t\tfree(media_list);\n\t\tclose(sock);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\t/*\n\t * Look for an 802.11 \"automatic\" media type.\n\t * We assume that all 802.11 adapters have that media type,\n\t * and that it will carry the monitor mode supported flag.\n\t */\n\tcan_do = 0;\n\tfor (i = 0; i < req.ifm_count; i++) {\n\t\tif (IFM_TYPE(media_list[i]) == IFM_IEEE80211\n\t\t    && IFM_SUBTYPE(media_list[i]) == IFM_AUTO) {\n\t\t\t/* OK, does it do monitor mode? */\n\t\t\tif (media_list[i] & IFM_IEEE80211_MONITOR) {\n\t\t\t\tcan_do = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfree(media_list);\n\tif (!can_do) {\n\t\t/*\n\t\t * This adapter doesn't support monitor mode.\n\t\t */\n\t\tclose(sock);\n\t\treturn (PCAP_ERROR_RFMON_NOTSUP);\n\t}\n\n\tif (set) {\n\t\t/*\n\t\t * Don't just check whether we can enable monitor mode,\n\t\t * do so, if it's not already enabled.\n\t\t */\n\t\tif ((req.ifm_current & IFM_IEEE80211_MONITOR) == 0) {\n\t\t\t/*\n\t\t\t * Monitor mode isn't currently on, so turn it on,\n\t\t\t * and remember that we should turn it off when the\n\t\t\t * pcap_t is closed.\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * If we haven't already done so, arrange to have\n\t\t\t * \"pcap_close_all()\" called when we exit.\n\t\t\t */\n\t\t\tif (!pcap_do_addexit(p)) {\n\t\t\t\t/*\n\t\t\t\t * \"atexit()\" failed; don't put the interface\n\t\t\t\t * in monitor mode, just give up.\n\t\t\t\t */\n\t\t\t\tclose(sock);\n\t\t\t\treturn (PCAP_ERROR);\n\t\t\t}\n\t\t\tmemset(&ifr, 0, sizeof(ifr));\n\t\t\t(void)strncpy(ifr.ifr_name, p->opt.device,\n\t\t\t    sizeof(ifr.ifr_name));\n\t\t\tifr.ifr_media = req.ifm_current | IFM_IEEE80211_MONITOR;\n\t\t\tif (ioctl(sock, SIOCSIFMEDIA, &ifr) == -1) {\n\t\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"SIOCSIFMEDIA\");\n\t\t\t\tclose(sock);\n\t\t\t\treturn (PCAP_ERROR);\n\t\t\t}\n\n\t\t\tpb->must_do_on_close |= MUST_CLEAR_RFMON;\n\n\t\t\t/*\n\t\t\t * Add this to the list of pcaps to close when we exit.\n\t\t\t */\n\t\t\tpcap_add_to_pcaps_to_close(p);\n\t\t}\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2863,
              0
            ],
            [
              3011,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "monitor_mode",
            "parameters": {
              "p": "pcap_t",
              "set": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nfind_802_11(struct bpf_dltlist *bdlp)\n{\n\tint new_dlt;\n\tu_int i;\n\n\t/*\n\t * Scan the list of DLT_ values, looking for 802.11 values,\n\t * and, if we find any, choose the best of them.\n\t */\n\tnew_dlt = -1;\n\tfor (i = 0; i < bdlp->bfl_len; i++) {\n\t\tswitch (bdlp->bfl_list[i]) {\n\n\t\tcase DLT_IEEE802_11:\n\t\t\t/*\n\t\t\t * 802.11, but no radio.\n\t\t\t *\n\t\t\t * Offer this, and select it as the new mode\n\t\t\t * unless we've already found an 802.11\n\t\t\t * header with radio information.\n\t\t\t */\n\t\t\tif (new_dlt == -1)\n\t\t\t\tnew_dlt = bdlp->bfl_list[i];\n\t\t\tbreak;\n\n#ifdef DLT_PRISM_HEADER\n\t\tcase DLT_PRISM_HEADER:\n#endif\n#ifdef DLT_AIRONET_HEADER\n\t\tcase DLT_AIRONET_HEADER:\n#endif\n\t\tcase DLT_IEEE802_11_RADIO_AVS:\n\t\t\t/*\n\t\t\t * 802.11 with radio, but not radiotap.\n\t\t\t *\n\t\t\t * Offer this, and select it as the new mode\n\t\t\t * unless we've already found the radiotap DLT_.\n\t\t\t */\n\t\t\tif (new_dlt != DLT_IEEE802_11_RADIO)\n\t\t\t\tnew_dlt = bdlp->bfl_list[i];\n\t\t\tbreak;\n\n\t\tcase DLT_IEEE802_11_RADIO:\n\t\t\t/*\n\t\t\t * 802.11 with radiotap.\n\t\t\t *\n\t\t\t * Offer this, and select it as the new mode.\n\t\t\t */\n\t\t\tnew_dlt = bdlp->bfl_list[i];\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Not 802.11.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (new_dlt);\n}",
          "fn_code_pos": [
            [
              3025,
              0
            ],
            [
              3086,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_802_11",
            "parameters": {
              "bdlp": "struct bpf_dltlist"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nremove_non_802_11(pcap_t *p)\n{\n\tint i, j;\n\n\t/*\n\t * Scan the list of DLT_ values and discard non-802.11 ones.\n\t */\n\tj = 0;\n\tfor (i = 0; i < p->dlt_count; i++) {\n\t\tswitch (p->dlt_list[i]) {\n\n\t\tcase DLT_EN10MB:\n\t\tcase DLT_RAW:\n\t\t\t/*\n\t\t\t * Not 802.11.  Don't offer this one.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just copy this mode over.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Copy this DLT_ value to its new position.\n\t\t */\n\t\tp->dlt_list[j] = p->dlt_list[i];\n\t\tj++;\n\t}\n\n\t/*\n\t * Set the DLT_ count to the number of entries we copied.\n\t */\n\tp->dlt_count = j;\n}",
          "fn_code_pos": [
            [
              3094,
              0
            ],
            [
              3131,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "remove_non_802_11",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nremove_802_11(pcap_t *p)\n{\n\tint i, j;\n\n\t/*\n\t * Scan the list of DLT_ values and discard 802.11 values.\n\t */\n\tj = 0;\n\tfor (i = 0; i < p->dlt_count; i++) {\n\t\tswitch (p->dlt_list[i]) {\n\n\t\tcase DLT_IEEE802_11:\n#ifdef DLT_PRISM_HEADER\n\t\tcase DLT_PRISM_HEADER:\n#endif\n#ifdef DLT_AIRONET_HEADER\n\t\tcase DLT_AIRONET_HEADER:\n#endif\n\t\tcase DLT_IEEE802_11_RADIO:\n\t\tcase DLT_IEEE802_11_RADIO_AVS:\n#ifdef DLT_PPI\n\t\tcase DLT_PPI:\n#endif\n\t\t\t/*\n\t\t\t * 802.11.  Don't offer this one.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just copy this mode over.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Copy this DLT_ value to its new position.\n\t\t */\n\t\tp->dlt_list[j] = p->dlt_list[i];\n\t\tj++;\n\t}\n\n\t/*\n\t * Set the DLT_ count to the number of entries we copied.\n\t */\n\tp->dlt_count = j;\n}",
          "fn_code_pos": [
            [
              3138,
              0
            ],
            [
              3185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "remove_802_11",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\npcap_setfilter_bpf(pcap_t *p, struct bpf_program *fp)\n{\n\tstruct pcap_bpf *pb = p->priv;\n\n\t/*\n\t * Free any user-mode filter we might happen to have installed.\n\t */\n\tpcap_freecode(&p->fcode);\n\n\t/*\n\t * Try to install the kernel filter.\n\t */\n\tif (ioctl(p->fd, BIOCSETF, (caddr_t)fp) == 0) {\n\t\t/*\n\t\t * It worked.\n\t\t */\n\t\tpb->filtering_in_kernel = 1;\t/* filtering in the kernel */\n\n\t\t/*\n\t\t * Discard any previously-received packets, as they might\n\t\t * have passed whatever filter was formerly in effect, but\n\t\t * might not pass this filter (BIOCSETF discards packets\n\t\t * buffered in the kernel, so you can lose packets in any\n\t\t * case).\n\t\t */\n\t\tp->cc = 0;\n\t\treturn (0);\n\t}\n\n\t/*\n\t * We failed.\n\t *\n\t * If it failed with EINVAL, that's probably because the program\n\t * is invalid or too big.  Validate it ourselves; if we like it\n\t * (we currently allow backward branches, to support protochain),\n\t * run it in userland.  (There's no notion of \"too big\" for\n\t * userland.)\n\t *\n\t * Otherwise, just give up.\n\t * XXX - if the copy of the program into the kernel failed,\n\t * we will get EINVAL rather than, say, EFAULT on at least\n\t * some kernels.\n\t */\n\tif (errno != EINVAL) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"BIOCSETF\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * install_bpf_program() validates the program.\n\t *\n\t * XXX - what if we already have a filter in the kernel?\n\t */\n\tif (install_bpf_program(p, fp) < 0)\n\t\treturn (-1);\n\tpb->filtering_in_kernel = 0;\t/* filtering in userland */\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              3188,
              0
            ],
            [
              3247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_bpf",
            "parameters": {
              "p": "pcap_t",
              "fp": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setdirection_bpf(pcap_t *p, pcap_direction_t d)\n{\n\tu_int direction;\n\n\tdirection = (d == PCAP_D_IN) ? BPF_D_IN :\n\t    ((d == PCAP_D_OUT) ? BPF_D_OUT : BPF_D_INOUT);\n\tif (ioctl(p->fd, BIOCSDIRECTION, &direction) == -1) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t    errno, \"Cannot set direction to %s\",\n\t\t        (d == PCAP_D_IN) ? \"PCAP_D_IN\" :\n\t\t\t((d == PCAP_D_OUT) ? \"PCAP_D_OUT\" : \"PCAP_D_INOUT\"));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              3254,
              0
            ],
            [
              3269,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setdirection_bpf",
            "parameters": {
              "p": "pcap_t",
              "d": "pcap_direction_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setdirection_bpf(pcap_t *p, pcap_direction_t d)\n{\n\tu_int seesent;\n\n\t/*\n\t * We don't support PCAP_D_OUT.\n\t */\n\tif (d == PCAP_D_OUT) {\n\t\tpcap_snprintf(p->errbuf, sizeof(p->errbuf),\n\t\t    \"Setting direction to PCAP_D_OUT is not supported on BPF\");\n\t\treturn -1;\n\t}\n\n\tseesent = (d == PCAP_D_INOUT);\n\tif (ioctl(p->fd, BIOCSSEESENT, &seesent) == -1) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t    errno, \"Cannot set direction to %s\",\n\t\t    (d == PCAP_D_INOUT) ? \"PCAP_D_INOUT\" : \"PCAP_D_IN\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              3271,
              0
            ],
            [
              3293,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setdirection_bpf",
            "parameters": {
              "p": "pcap_t",
              "d": "pcap_direction_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setdirection_bpf(pcap_t *p, pcap_direction_t d _U_)\n{\n\t(void) pcap_snprintf(p->errbuf, sizeof(p->errbuf),\n\t    \"This system doesn't support BIOCSSEESENT, so the direction can't be set\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              3295,
              0
            ],
            [
              3301,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setdirection_bpf",
            "parameters": {
              "p": "pcap_t",
              "d": "pcap_direction_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_set_datalink_bpf(pcap_t *p, int dlt)\n{\n\tif (ioctl(p->fd, BIOCSDLT, &dlt) == -1) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t    errno, \"Cannot set DLT %d\", dlt);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              3305,
              0
            ],
            [
              3314,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_datalink_bpf",
            "parameters": {
              "p": "pcap_t",
              "dlt": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n#ifdef HAVE_ZEROCOPY_BPF\n\treturn (PCAP_VERSION_STRING \" (with zerocopy support)\");\n#else\n\treturn (PCAP_VERSION_STRING);\n#endif\n}",
          "fn_code_pos": [
            [
              3326,
              0
            ],
            [
              3334,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "bpf_load(char *errbuf)",
          "fn_dec_pos": [
            [
              109,
              11
            ],
            [
              109,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_load",
            "parameters": {
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "find_802_11(struct bpf_dltlist *)",
          "fn_dec_pos": [
            [
              201,
              11
            ],
            [
              201,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_802_11",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "monitor_mode(pcap_t *, int)",
          "fn_dec_pos": [
            [
              204,
              11
            ],
            [
              204,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "monitor_mode",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "remove_non_802_11(pcap_t *)",
          "fn_dec_pos": [
            [
              208,
              12
            ],
            [
              208,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "remove_non_802_11",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "remove_802_11(pcap_t *)",
          "fn_dec_pos": [
            [
              209,
              12
            ],
            [
              209,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "remove_802_11",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_can_set_rfmon_bpf(pcap_t *p)",
          "fn_dec_pos": [
            [
              246,
              11
            ],
            [
              246,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_can_set_rfmon_bpf",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_activate_bpf(pcap_t *p)",
          "fn_dec_pos": [
            [
              247,
              11
            ],
            [
              247,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_activate_bpf",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_setfilter_bpf(pcap_t *p, struct bpf_program *fp)",
          "fn_dec_pos": [
            [
              248,
              11
            ],
            [
              248,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_bpf",
            "parameters": {
              "p": "pcap_t",
              "fp": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_setdirection_bpf(pcap_t *, pcap_direction_t)",
          "fn_dec_pos": [
            [
              249,
              11
            ],
            [
              249,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setdirection_bpf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_set_datalink_bpf(pcap_t *p, int dlt)",
          "fn_dec_pos": [
            [
              250,
              11
            ],
            [
              250,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_datalink_bpf",
            "parameters": {
              "p": "pcap_t",
              "dlt": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_create_interface(const char *device _U_, char *ebuf)",
          "fn_dec_pos": [
            [
              443,
              0
            ],
            [
              443,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_activate_bpf(pcap_t *p)",
          "fn_dec_pos": [
            [
              1627,
              0
            ],
            [
              1627,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_activate_bpf",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              3327,
              0
            ],
            [
              3327,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_bpf {\n#ifdef HAVE_ZEROCOPY_BPF\n\t/*\n\t * Zero-copy read buffer -- for zero-copy BPF.  'buffer' above will\n\t * alternative between these two actual mmap'd buffers as required.\n\t * As there is a header on the front size of the mmap'd buffer, only\n\t * some of the buffer is exposed to libpcap as a whole via bufsize;\n\t * zbufsize is the true size.  zbuffer tracks the current zbuf\n\t * assocated with buffer so that it can be used to decide which the\n\t * next buffer to read will be.\n\t */\n\tu_char *zbuf1, *zbuf2, *zbuffer;\n\tu_int zbufsize;\n\tu_int zerocopy;\n\tu_int interrupted;\n\tstruct timespec firstsel;\n\t/*\n\t * If there's currently a buffer being actively processed, then it is\n\t * referenced here; 'buffer' is also pointed at it, but offset by the\n\t * size of the header.\n\t */\n\tstruct bpf_zbuf_header *bzh;\n\tint nonblock;\t\t/* true if in nonblocking mode */\n#endif /* HAVE_ZEROCOPY_BPF */\n\n\tchar *device;\t\t/* device name */\n\tint filtering_in_kernel; /* using kernel filter */\n\tint must_do_on_close;\t/* stuff we must do when we close */\n}",
          {
            "*zbuf1": "u_char",
            "zbufsize": "u_int",
            "zerocopy": "u_int",
            "interrupted": "u_int",
            "firstsel": "struct timespec",
            "*bzh": "struct bpf_zbuf_header",
            "nonblock": "int",
            "*device": "char",
            "filtering_in_kernel": "int",
            "must_do_on_close": "int"
          },
          "pcap_bpf",
          [
            147,
            0
          ],
          [
            175,
            1
          ]
        ],
        [
          "struct pcap_bpf {\n#ifdef HAVE_ZEROCOPY_BPF\n\t/*\n\t * Zero-copy read buffer -- for zero-copy BPF.  'buffer' above will\n\t * alternative between these two actual mmap'd buffers as required.\n\t * As there is a header on the front size of the mmap'd buffer, only\n\t * some of the buffer is exposed to libpcap as a whole via bufsize;\n\t * zbufsize is the true size.  zbuffer tracks the current zbuf\n\t * assocated with buffer so that it can be used to decide which the\n\t * next buffer to read will be.\n\t */\n\tu_char *zbuf1, *zbuf2, *zbuffer;\n\tu_int zbufsize;\n\tu_int zerocopy;\n\tu_int interrupted;\n\tstruct timespec firstsel;\n\t/*\n\t * If there's currently a buffer being actively processed, then it is\n\t * referenced here; 'buffer' is also pointed at it, but offset by the\n\t * size of the header.\n\t */\n\tstruct bpf_zbuf_header *bzh;\n\tint nonblock;\t\t/* true if in nonblocking mode */\n#endif /* HAVE_ZEROCOPY_BPF */\n\n\tchar *device;\t\t/* device name */\n\tint filtering_in_kernel; /* using kernel filter */\n\tint must_do_on_close;\t/* stuff we must do when we close */\n}",
          {
            "*zbuf1": "u_char",
            "zbufsize": "u_int",
            "zerocopy": "u_int",
            "interrupted": "u_int",
            "firstsel": "struct timespec",
            "*bzh": "struct bpf_zbuf_header",
            "nonblock": "int",
            "*device": "char",
            "filtering_in_kernel": "int",
            "must_do_on_close": "int"
          },
          "pcap_bpf",
          [
            147,
            0
          ],
          [
            175,
            1
          ]
        ],
        [
          "struct timespec",
          {},
          "",
          [
            162,
            1
          ],
          [
            162,
            16
          ]
        ],
        [
          "struct bpf_zbuf_header",
          {},
          "",
          [
            168,
            1
          ],
          [
            168,
            23
          ]
        ],
        [
          "struct bpf_dltlist",
          {},
          "",
          [
            201,
            23
          ],
          [
            201,
            41
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            248,
            41
          ],
          [
            248,
            59
          ]
        ],
        [
          "struct pcap_bpf",
          {},
          "",
          [
            261,
            1
          ],
          [
            261,
            16
          ]
        ],
        [
          "struct pcap_bpf",
          {},
          "",
          [
            273,
            1
          ],
          [
            273,
            16
          ]
        ],
        [
          "struct pcap_bpf",
          {},
          "",
          [
            296,
            1
          ],
          [
            296,
            16
          ]
        ],
        [
          "struct bpf_zbuf_header",
          {},
          "",
          [
            297,
            1
          ],
          [
            297,
            23
          ]
        ],
        [
          "struct bpf_zbuf_header",
          {},
          "",
          [
            300,
            9
          ],
          [
            300,
            31
          ]
        ],
        [
          "struct bpf_zbuf_header",
          {},
          "",
          [
            310,
            9
          ],
          [
            310,
            31
          ]
        ],
        [
          "struct pcap_bpf",
          {},
          "",
          [
            334,
            1
          ],
          [
            334,
            16
          ]
        ],
        [
          "struct bpf_zbuf",
          {},
          "",
          [
            335,
            1
          ],
          [
            335,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            336,
            1
          ],
          [
            336,
            15
          ]
        ],
        [
          "struct timespec",
          {},
          "",
          [
            337,
            1
          ],
          [
            337,
            16
          ]
        ],
        [
          "struct pcap_bpf",
          {},
          "",
          [
            432,
            1
          ],
          [
            432,
            16
          ]
        ],
        [
          "struct pcap_bpf",
          {},
          "",
          [
            447,
            38
          ],
          [
            447,
            53
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            610,
            1
          ],
          [
            610,
            13
          ]
        ],
        [
          "struct bpf_dltlist",
          {},
          "",
          [
            660,
            28
          ],
          [
            660,
            46
          ]
        ],
        [
          "struct utsname",
          {},
          "",
          [
            743,
            1
          ],
          [
            743,
            15
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            744,
            1
          ],
          [
            744,
            13
          ]
        ],
        [
          "struct bpf_dltlist",
          {},
          "",
          [
            747,
            1
          ],
          [
            747,
            19
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            905,
            26
          ],
          [
            905,
            42
          ]
        ],
        [
          "struct bpf_stat",
          {},
          "",
          [
            907,
            1
          ],
          [
            907,
            16
          ]
        ],
        [
          "struct pcap_bpf",
          {},
          "",
          [
            937,
            1
          ],
          [
            937,
            16
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            1127,
            3
          ],
          [
            1127,
            21
          ]
        ],
        [
          "struct bintime",
          {},
          "",
          [
            1129,
            3
          ],
          [
            1129,
            17
          ]
        ],
        [
          "struct timespec",
          {},
          "",
          [
            1134,
            4
          ],
          [
            1134,
            19
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            1140,
            4
          ],
          [
            1140,
            18
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            1309,
            1
          ],
          [
            1309,
            12
          ]
        ],
        [
          "struct bpf_config",
          {},
          "",
          [
            1310,
            1
          ],
          [
            1310,
            18
          ]
        ],
        [
          "struct cfg_load",
          {},
          "",
          [
            1311,
            1
          ],
          [
            1311,
            16
          ]
        ],
        [
          "struct cfg_kmod",
          {},
          "",
          [
            1312,
            1
          ],
          [
            1312,
            16
          ]
        ],
        [
          "struct pcap_bpf",
          {},
          "",
          [
            1406,
            1
          ],
          [
            1406,
            16
          ]
        ],
        [
          "struct ifmediareq",
          {},
          "",
          [
            1409,
            1
          ],
          [
            1409,
            18
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            1410,
            1
          ],
          [
            1410,
            13
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            1523,
            1
          ],
          [
            1523,
            13
          ]
        ],
        [
          "struct pcap_bpf",
          {},
          "",
          [
            1629,
            1
          ],
          [
            1629,
            16
          ]
        ],
        [
          "struct lifreq",
          {},
          "",
          [
            1637,
            1
          ],
          [
            1637,
            14
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            1641,
            1
          ],
          [
            1641,
            13
          ]
        ],
        [
          "struct bpf_version",
          {},
          "",
          [
            1645,
            1
          ],
          [
            1645,
            19
          ]
        ],
        [
          "struct bpf_dltlist",
          {},
          "",
          [
            1651,
            1
          ],
          [
            1651,
            19
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            1660,
            1
          ],
          [
            1660,
            16
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            1661,
            1
          ],
          [
            1661,
            19
          ]
        ],
        [
          "struct utsname",
          {},
          "",
          [
            1662,
            1
          ],
          [
            1662,
            15
          ]
        ],
        [
          "struct bpf_zbuf",
          {},
          "",
          [
            1665,
            1
          ],
          [
            1665,
            16
          ]
        ],
        [
          "struct bpf_zbuf_header",
          {},
          "",
          [
            2000,
            28
          ],
          [
            2000,
            50
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            2362,
            2
          ],
          [
            2362,
            16
          ]
        ],
        [
          "struct BPF_TIMEVAL",
          {},
          "",
          [
            2364,
            2
          ],
          [
            2364,
            20
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            2366,
            43
          ],
          [
            2366,
            57
          ]
        ],
        [
          "struct dirent",
          {},
          "",
          [
            2665,
            1
          ],
          [
            2665,
            14
          ]
        ],
        [
          "struct ifmediareq",
          {},
          "",
          [
            2745,
            1
          ],
          [
            2745,
            18
          ]
        ],
        [
          "struct pcap_bpf",
          {},
          "",
          [
            2866,
            1
          ],
          [
            2866,
            16
          ]
        ],
        [
          "struct ifmediareq",
          {},
          "",
          [
            2868,
            1
          ],
          [
            2868,
            18
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            2872,
            1
          ],
          [
            2872,
            13
          ]
        ],
        [
          "struct bpf_dltlist",
          {},
          "",
          [
            3026,
            12
          ],
          [
            3026,
            30
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            3189,
            30
          ],
          [
            3189,
            48
          ]
        ],
        [
          "struct pcap_bpf",
          {},
          "",
          [
            3191,
            1
          ],
          [
            3191,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <sys/param.h>\t\t\t/* optionally get BSD define */\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <time.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <sys/ioctl.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <sys/ioccom.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <sys/utsname.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <dirent.h>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <net/if.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            66,
            0
          ],
          [
            67,
            0
          ]
        ],
        [
          "#include <net/bpf.h>\n",
          [
            74,
            0
          ],
          [
            75,
            0
          ]
        ],
        [
          "#include <sys/mman.h>\n",
          [
            83,
            2
          ],
          [
            84,
            0
          ]
        ],
        [
          "#include <machine/atomic.h>\n",
          [
            84,
            2
          ],
          [
            85,
            0
          ]
        ],
        [
          "#include <net/if_types.h>\t\t/* for IFT_ values */\n",
          [
            87,
            0
          ],
          [
            88,
            0
          ]
        ],
        [
          "#include <sys/sysconfig.h>\n",
          [
            88,
            0
          ],
          [
            89,
            0
          ]
        ],
        [
          "#include <sys/device.h>\n",
          [
            89,
            0
          ],
          [
            90,
            0
          ]
        ],
        [
          "#include <sys/cfgodm.h>\n",
          [
            90,
            0
          ],
          [
            91,
            0
          ]
        ],
        [
          "#include <cf.h>\n",
          [
            91,
            0
          ],
          [
            92,
            0
          ]
        ],
        [
          "#include <net/bpf.h>\n",
          [
            113,
            0
          ],
          [
            114,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            117,
            0
          ],
          [
            118,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            118,
            0
          ],
          [
            119,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            119,
            0
          ],
          [
            120,
            0
          ]
        ],
        [
          "#include <netdb.h>\n",
          [
            120,
            0
          ],
          [
            121,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            121,
            0
          ],
          [
            122,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            122,
            0
          ],
          [
            123,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            123,
            0
          ],
          [
            124,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            124,
            0
          ],
          [
            125,
            0
          ]
        ],
        [
          "# include <net/if_media.h>\n",
          [
            127,
            0
          ],
          [
            128,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            130,
            0
          ],
          [
            131,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            133,
            0
          ],
          [
            134,
            0
          ]
        ],
        [
          "#include <zone.h>\n",
          [
            217,
            0
          ],
          [
            218,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-bt-monitor-linux.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nbt_monitor_findalldevs(pcap_if_list_t *devlistp, char *err_str)\n{\n    int         ret = 0;\n\n    /*\n     * Bluetooth is a wireless technology.\n     *\n     * This is a device to monitor all Bluetooth interfaces, so\n     * there's no notion of \"connected\" or \"disconnected\", any\n     * more than there's a notion of \"connected\" or \"disconnected\"\n     * for the \"any\" device.\n     */\n    if (add_dev(devlistp, INTERFACE_NAME,\n                PCAP_IF_WIRELESS|PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,\n                \"Bluetooth Linux Monitor\", err_str) == NULL)\n    {\n        ret = -1;\n    }\n\n    return ret;\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_monitor_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "err_str": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nbt_monitor_read(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char *user)\n{\n    struct cmsghdr *cmsg;\n    struct msghdr msg;\n    struct iovec  iv[2];\n    ssize_t ret;\n    struct pcap_pkthdr pkth;\n    pcap_bluetooth_linux_monitor_header *bthdr;\n    u_char *pktd;\n    struct hci_mon_hdr hdr;\n\n    pktd = (u_char *)handle->buffer + BT_CONTROL_SIZE;\n    bthdr = (pcap_bluetooth_linux_monitor_header*)(void *)pktd;\n\n    iv[0].iov_base = &hdr;\n    iv[0].iov_len = sizeof(hdr);\n    iv[1].iov_base = pktd + sizeof(pcap_bluetooth_linux_monitor_header);\n    iv[1].iov_len = handle->snapshot;\n\n    memset(&pkth.ts, 0, sizeof(pkth.ts));\n    memset(&msg, 0, sizeof(msg));\n    msg.msg_iov = iv;\n    msg.msg_iovlen = 2;\n    msg.msg_control = handle->buffer;\n    msg.msg_controllen = BT_CONTROL_SIZE;\n\n    do {\n        ret = recvmsg(handle->fd, &msg, 0);\n        if (handle->break_loop)\n        {\n            handle->break_loop = 0;\n            return -2;\n        }\n    } while ((ret == -1) && (errno == EINTR));\n\n    if (ret < 0) {\n        pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n            errno, \"Can't receive packet\");\n        return -1;\n    }\n\n    pkth.caplen = (bpf_u_int32)(ret - sizeof(hdr) + sizeof(pcap_bluetooth_linux_monitor_header));\n    pkth.len = pkth.caplen;\n\n    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n        if (cmsg->cmsg_level != SOL_SOCKET) continue;\n\n        if (cmsg->cmsg_type == SCM_TIMESTAMP) {\n            memcpy(&pkth.ts, CMSG_DATA(cmsg), sizeof(pkth.ts));\n        }\n    }\n\n    bthdr->adapter_id = htons(hdr.index);\n    bthdr->opcode = htons(hdr.opcode);\n\n    if (handle->fcode.bf_insns == NULL ||\n        pcap_filter(handle->fcode.bf_insns, pktd, pkth.len, pkth.caplen)) {\n        callback(user, &pkth, pktd);\n        return 1;\n    }\n    return 0;   /* didn't pass filter */\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              146,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_monitor_read",
            "parameters": {
              "handle": "pcap_t",
              "max_packets": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nbt_monitor_inject(pcap_t *handle, const void *buf _U_, int size _U_)\n{\n    pcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n        \"Packet injection is not supported yet on Bluetooth monitor devices\");\n    return -1;\n}",
          "fn_code_pos": [
            [
              148,
              0
            ],
            [
              154,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_monitor_inject",
            "parameters": {
              "handle": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nbt_monitor_setdirection(pcap_t *p, pcap_direction_t d)\n{\n    p->direction = d;\n    return 0;\n}",
          "fn_code_pos": [
            [
              156,
              0
            ],
            [
              161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_monitor_setdirection",
            "parameters": {
              "p": "pcap_t",
              "d": "pcap_direction_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nbt_monitor_activate(pcap_t* handle)\n{\n    struct sockaddr_hci addr;\n    int err = PCAP_ERROR;\n    int opt;\n\n    if (handle->opt.rfmon) {\n        /* monitor mode doesn't apply here */\n        return PCAP_ERROR_RFMON_NOTSUP;\n    }\n\n    /*\n     * Turn a negative snapshot value (invalid), a snapshot value of\n     * 0 (unspecified), or a value bigger than the normal maximum\n     * value, into the maximum allowed value.\n     *\n     * If some application really *needs* a bigger snapshot\n     * length, we should just increase MAXIMUM_SNAPLEN.\n     */\n    if (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)\n        handle->snapshot = MAXIMUM_SNAPLEN;\n\n    handle->bufsize = BT_CONTROL_SIZE + sizeof(pcap_bluetooth_linux_monitor_header) + handle->snapshot;\n    handle->linktype = DLT_BLUETOOTH_LINUX_MONITOR;\n\n    handle->read_op = bt_monitor_read;\n    handle->inject_op = bt_monitor_inject;\n    handle->setfilter_op = install_bpf_program; /* no kernel filtering */\n    handle->setdirection_op = bt_monitor_setdirection;\n    handle->set_datalink_op = NULL; /* can't change data link type */\n    handle->getnonblock_op = pcap_getnonblock_fd;\n    handle->setnonblock_op = pcap_setnonblock_fd;\n    handle->stats_op = bt_monitor_stats;\n\n    handle->fd = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI);\n    if (handle->fd < 0) {\n        pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n            errno, \"Can't create raw socket\");\n        return PCAP_ERROR;\n    }\n\n    handle->buffer = malloc(handle->bufsize);\n    if (!handle->buffer) {\n        pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n            errno, \"Can't allocate dump buffer\");\n        goto close_fail;\n    }\n\n    /* Bind socket to the HCI device */\n    addr.hci_family = AF_BLUETOOTH;\n    addr.hci_dev = HCI_DEV_NONE;\n    addr.hci_channel = HCI_CHANNEL_MONITOR;\n\n    if (bind(handle->fd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {\n        pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n            errno, \"Can't attach to interface\");\n        goto close_fail;\n    }\n\n    opt = 1;\n    if (setsockopt(handle->fd, SOL_SOCKET, SO_TIMESTAMP, &opt, sizeof(opt)) < 0) {\n        pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n            errno, \"Can't enable time stamp\");\n        goto close_fail;\n    }\n\n    handle->selectable_fd = handle->fd;\n\n    return 0;\n\nclose_fail:\n    pcap_cleanup_live_common(handle);\n    return err;\n}",
          "fn_code_pos": [
            [
              173,
              0
            ],
            [
              247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_monitor_activate",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\nbt_monitor_create(const char *device, char *ebuf, int *is_ours)\n{\n    pcap_t      *p;\n    const char  *cp;\n\n    cp = strrchr(device, '/');\n    if (cp == NULL)\n        cp = device;\n\n    if (strcmp(cp, INTERFACE_NAME) != 0) {\n        *is_ours = 0;\n        return NULL;\n    }\n\n    *is_ours = 1;\n    p = pcap_create_common(ebuf, 0);\n    if (p == NULL)\n        return NULL;\n\n    p->activate_op = bt_monitor_activate;\n\n    return p;\n}",
          "fn_code_pos": [
            [
              249,
              0
            ],
            [
              272,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_monitor_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": "pcap_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "bt_monitor_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              250,
              0
            ],
            [
              250,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_monitor_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct hci_mon_hdr {\n    uint16_t opcode;\n    uint16_t index;\n    uint16_t len;\n} __attribute__((packed))",
          {
            "opcode": "uint16_t",
            "index": "uint16_t",
            "len": "uint16_t"
          },
          "hci_mon_hdr",
          [
            55,
            0
          ],
          [
            59,
            25
          ]
        ],
        [
          "struct hci_mon_hdr {\n    uint16_t opcode;\n    uint16_t index;\n    uint16_t len;\n} __attribute__((packed))",
          {
            "opcode": "uint16_t",
            "index": "uint16_t",
            "len": "uint16_t"
          },
          "hci_mon_hdr",
          [
            55,
            0
          ],
          [
            59,
            25
          ]
        ],
        [
          "struct cmsghdr",
          {},
          "",
          [
            87,
            4
          ],
          [
            87,
            18
          ]
        ],
        [
          "struct msghdr",
          {},
          "",
          [
            88,
            4
          ],
          [
            88,
            17
          ]
        ],
        [
          "struct iovec",
          {},
          "",
          [
            89,
            4
          ],
          [
            89,
            16
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            91,
            4
          ],
          [
            91,
            22
          ]
        ],
        [
          "struct hci_mon_hdr",
          {},
          "",
          [
            94,
            4
          ],
          [
            94,
            22
          ]
        ],
        [
          "struct sockaddr_hci",
          {},
          "",
          [
            176,
            4
          ],
          [
            176,
            23
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            227,
            26
          ],
          [
            227,
            41
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <stdint.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <bluetooth/bluetooth.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <bluetooth/hci.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include \"pcap/bluetooth.h\"\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"pcap-bt-monitor-linux.h\"\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-nit.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\npcap_stats_nit(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct pcap_nit *pn = p->priv;\n\n\t/*\n\t * \"ps_recv\" counts packets handed to the filter, not packets\n\t * that passed the filter.  As filtering is done in userland,\n\t * this does not include packets dropped because we ran out\n\t * of buffer space.\n\t *\n\t * \"ps_drop\" presumably counts packets dropped by the socket\n\t * because of flow control requirements or resource exhaustion;\n\t * it doesn't count packets dropped by the interface driver.\n\t * As filtering is done in userland, it counts packets regardless\n\t * of whether they would've passed the filter.\n\t *\n\t * These statistics don't include packets not yet read from the\n\t * kernel by libpcap or packets not yet read from libpcap by the\n\t * application.\n\t */\n\t*ps = pn->stat;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_nit",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_read_nit(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_nit *pn = p->priv;\n\tregister int cc, n;\n\tregister u_char *bp, *cp, *ep;\n\tregister struct nit_hdr *nh;\n\tregister int caplen;\n\n\tcc = p->cc;\n\tif (cc == 0) {\n\t\tcc = read(p->fd, (char *)p->buffer, p->bufsize);\n\t\tif (cc < 0) {\n\t\t\tif (errno == EWOULDBLOCK)\n\t\t\t\treturn (0);\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t\t    errno, \"pcap_read\");\n\t\t\treturn (-1);\n\t\t}\n\t\tbp = (u_char *)p->buffer;\n\t} else\n\t\tbp = p->bp;\n\n\t/*\n\t * Loop through each packet.  The increment expression\n\t * rounds up to the next int boundary past the end of\n\t * the previous packet.\n\t */\n\tn = 0;\n\tep = bp + cc;\n\twhile (bp < ep) {\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t * If so, return immediately - if we haven't read any\n\t\t * packets, clear the flag and return -2 to indicate\n\t\t * that we were told to break out of the loop, otherwise\n\t\t * leave the flag set, so that the *next* call will break\n\t\t * out of the loop without having read any packets, and\n\t\t * return the number of packets we've processed so far.\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\tif (n == 0) {\n\t\t\t\tp->break_loop = 0;\n\t\t\t\treturn (-2);\n\t\t\t} else {\n\t\t\t\tp->cc = ep - bp;\n\t\t\t\tp->bp = bp;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t}\n\n\t\tnh = (struct nit_hdr *)bp;\n\t\tcp = bp + sizeof(*nh);\n\n\t\tswitch (nh->nh_state) {\n\n\t\tcase NIT_CATCH:\n\t\t\tbreak;\n\n\t\tcase NIT_NOMBUF:\n\t\tcase NIT_NOCLUSTER:\n\t\tcase NIT_NOSPACE:\n\t\t\tpn->stat.ps_drop = nh->nh_dropped;\n\t\t\tcontinue;\n\n\t\tcase NIT_SEQNO:\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tpcap_snprintf(p->errbuf, sizeof(p->errbuf),\n\t\t\t    \"bad nit state %d\", nh->nh_state);\n\t\t\treturn (-1);\n\t\t}\n\t\t++pn->stat.ps_recv;\n\t\tbp += ((sizeof(struct nit_hdr) + nh->nh_datalen +\n\t\t    sizeof(int) - 1) & ~(sizeof(int) - 1));\n\n\t\tcaplen = nh->nh_wirelen;\n\t\tif (caplen > p->snapshot)\n\t\t\tcaplen = p->snapshot;\n\t\tif (pcap_filter(p->fcode.bf_insns, cp, nh->nh_wirelen, caplen)) {\n\t\t\tstruct pcap_pkthdr h;\n\t\t\th.ts = nh->nh_timestamp;\n\t\t\th.len = nh->nh_wirelen;\n\t\t\th.caplen = caplen;\n\t\t\t(*callback)(user, &h, cp);\n\t\t\tif (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt)) {\n\t\t\t\tp->cc = ep - bp;\n\t\t\t\tp->bp = bp;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t}\n\t}\n\tp->cc = 0;\n\treturn (n);\n}",
          "fn_code_pos": [
            [
              101,
              0
            ],
            [
              196,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_nit",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_inject_nit(pcap_t *p, const void *buf, int size)\n{\n\tstruct sockaddr sa;\n\tint ret;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tstrncpy(sa.sa_data, device, sizeof(sa.sa_data));\n\tret = sendto(p->fd, buf, size, 0, &sa, sizeof(sa));\n\tif (ret == -1) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"send\");\n\t\treturn (-1);\n\t}\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              198,
              0
            ],
            [
              213,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject_nit",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nnit_setflags(pcap_t *p)\n{\n\tstruct nit_ioc nioc;\n\n\tmemset(&nioc, 0, sizeof(nioc));\n\tnioc.nioc_typetomatch = NT_ALLTYPES;\n\tnioc.nioc_snaplen = p->snapshot;\n\tnioc.nioc_bufalign = sizeof(int);\n\tnioc.nioc_bufoffset = 0;\n\n\tif (p->opt.buffer_size != 0)\n\t\tnioc.nioc_bufspace = p->opt.buffer_size;\n\telse {\n\t\t/* Default buffer size */\n\t\tnioc.nioc_bufspace = BUFSPACE;\n\t}\n\n\tif (p->opt.immediate) {\n\t\t/*\n\t\t * XXX - will this cause packets to be delivered immediately?\n\t\t * XXX - given that this is for SunOS prior to 4.0, do\n\t\t * we care?\n\t\t */\n\t\tnioc.nioc_chunksize = 0;\n\t} else\n\t\tnioc.nioc_chunksize = CHUNKSIZE;\n\tif (p->opt.timeout != 0) {\n\t\tnioc.nioc_flags |= NF_TIMEOUT;\n\t\tnioc.nioc_timeout.tv_sec = p->opt.timeout / 1000;\n\t\tnioc.nioc_timeout.tv_usec = (p->opt.timeout * 1000) % 1000000;\n\t}\n\tif (p->opt.promisc)\n\t\tnioc.nioc_flags |= NF_PROMISC;\n\n\tif (ioctl(p->fd, SIOCSNIT, &nioc) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCSNIT\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              215,
              0
            ],
            [
              256,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nit_setflags",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_activate_nit(pcap_t *p)\n{\n\tint fd;\n\tstruct sockaddr_nit snit;\n\n\tif (p->opt.rfmon) {\n\t\t/*\n\t\t * No monitor mode on SunOS 3.x or earlier (no\n\t\t * Wi-Fi *devices* for the hardware that supported\n\t\t * them!).\n\t\t */\n\t\treturn (PCAP_ERROR_RFMON_NOTSUP);\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n\tif (p->snapshot < 96)\n\t\t/*\n\t\t * NIT requires a snapshot length of at least 96.\n\t\t */\n\t\tp->snapshot = 96;\n\n\tmemset(p, 0, sizeof(*p));\n\tp->fd = fd = socket(AF_NIT, SOCK_RAW, NITPROTO_RAW);\n\tif (fd < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"socket\");\n\t\tgoto bad;\n\t}\n\tsnit.snit_family = AF_NIT;\n\t(void)strncpy(snit.snit_ifname, p->opt.device, NITIFSIZ);\n\n\tif (bind(fd, (struct sockaddr *)&snit, sizeof(snit))) {\n\t\t/*\n\t\t * XXX - there's probably a particular bind error that\n\t\t * means \"there's no such device\" and a particular bind\n\t\t * error that means \"that device doesn't support NIT\";\n\t\t * they might be the same error, if they both end up\n\t\t * meaning \"NIT doesn't know about that device\".\n\t\t */\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"bind: %s\", snit.snit_ifname);\n\t\tgoto bad;\n\t}\n\tif (nit_setflags(p) < 0)\n\t\tgoto bad;\n\n\t/*\n\t * NIT supports only ethernets.\n\t */\n\tp->linktype = DLT_EN10MB;\n\n\tp->bufsize = BUFSPACE;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * \"p->fd\" is a socket, so \"select()\" should work on it.\n\t */\n\tp->selectable_fd = p->fd;\n\n\t/*\n\t * This is (presumably) a real Ethernet capture; give it a\n\t * link-layer-type list with DLT_EN10MB and DLT_DOCSIS, so\n\t * that an application can let you choose it, in case you're\n\t * capturing DOCSIS traffic that a Cisco Cable Modem\n\t * Termination System is putting out onto an Ethernet (it\n\t * doesn't put an Ethernet header onto the wire, it puts raw\n\t * DOCSIS frames out on the wire inside the low-level\n\t * Ethernet framing).\n\t */\n\tp->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);\n\t/*\n\t * If that fails, just leave the list empty.\n\t */\n\tif (p->dlt_list != NULL) {\n\t\tp->dlt_list[0] = DLT_EN10MB;\n\t\tp->dlt_list[1] = DLT_DOCSIS;\n\t\tp->dlt_count = 2;\n\t}\n\n\tp->read_op = pcap_read_nit;\n\tp->inject_op = pcap_inject_nit;\n\tp->setfilter_op = install_bpf_program;\t/* no kernel filtering */\n\tp->setdirection_op = NULL;\t/* Not implemented. */\n\tp->set_datalink_op = NULL;\t/* can't change data link type */\n\tp->getnonblock_op = pcap_getnonblock_fd;\n\tp->setnonblock_op = pcap_setnonblock_fd;\n\tp->stats_op = pcap_stats_nit;\n\n\treturn (0);\n bad:\n\tpcap_cleanup_live_common(p);\n\treturn (PCAP_ERROR);\n}",
          "fn_code_pos": [
            [
              258,
              0
            ],
            [
              366,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_activate_nit",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_create_interface(const char *device _U_, char *ebuf)\n{\n\tpcap_t *p;\n\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_nit));\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = pcap_activate_nit;\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              368,
              0
            ],
            [
              379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static int\ncan_be_bound(const char *name _U_)\n{\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              385,
              0
            ],
            [
              389,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "can_be_bound",
            "parameters": {
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nget_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)\n{\n\t/*\n\t * Nothing we can do.\n\t * XXX - is there a way to find out whether an adapter has\n\t * something plugged into it?\n\t */\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              391,
              0
            ],
            [
              400,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_if_flags",
            "parameters": {
              "name": "char",
              "flags": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\treturn (pcap_findalldevs_interfaces(devlistp, errbuf, can_be_bound,\n\t    get_if_flags));\n}",
          "fn_code_pos": [
            [
              402,
              0
            ],
            [
              407,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_platform_finddevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING);\n}",
          "fn_code_pos": [
            [
              412,
              0
            ],
            [
              416,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "nit_setflags(int, int, int, char *)",
          "fn_dec_pos": [
            [
              67,
              11
            ],
            [
              67,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nit_setflags",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_create_interface(const char *device _U_, char *ebuf)",
          "fn_dec_pos": [
            [
              369,
              0
            ],
            [
              369,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              413,
              0
            ],
            [
              413,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_nit {\n\tstruct pcap_stat stat;\n}",
          {
            "stat": "struct pcap_stat"
          },
          "pcap_nit",
          [
            72,
            0
          ],
          [
            74,
            1
          ]
        ],
        [
          "struct pcap_nit {\n\tstruct pcap_stat stat;\n}",
          {
            "stat": "struct pcap_stat"
          },
          "pcap_nit",
          [
            72,
            0
          ],
          [
            74,
            1
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            73,
            1
          ],
          [
            73,
            17
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            77,
            26
          ],
          [
            77,
            42
          ]
        ],
        [
          "struct pcap_nit",
          {},
          "",
          [
            79,
            1
          ],
          [
            79,
            16
          ]
        ],
        [
          "struct pcap_nit",
          {},
          "",
          [
            104,
            1
          ],
          [
            104,
            16
          ]
        ],
        [
          "struct nit_hdr",
          {},
          "",
          [
            107,
            10
          ],
          [
            107,
            24
          ]
        ],
        [
          "struct nit_hdr",
          {},
          "",
          [
            152,
            8
          ],
          [
            152,
            22
          ]
        ],
        [
          "struct nit_hdr",
          {},
          "",
          [
            175,
            17
          ],
          [
            175,
            31
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            182,
            3
          ],
          [
            182,
            21
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            201,
            1
          ],
          [
            201,
            16
          ]
        ],
        [
          "struct nit_ioc",
          {},
          "",
          [
            218,
            1
          ],
          [
            218,
            15
          ]
        ],
        [
          "struct sockaddr_nit",
          {},
          "",
          [
            262,
            1
          ],
          [
            262,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            300,
            15
          ],
          [
            300,
            30
          ]
        ],
        [
          "struct pcap_nit",
          {},
          "",
          [
            373,
            38
          ],
          [
            373,
            53
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sys/timeb.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <sys/file.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <sys/ioctl.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <net/if.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <net/nit.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <netinet/in_systm.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <netinet/ip.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <netinet/if_ether.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <netinet/ip_var.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <netinet/udp.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <netinet/udp_var.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <netinet/tcp.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <netinet/tcpip.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/fad-getad.c": {
      "fn_def_list": [
        {
          "fn_code": "static size_t\nget_sa_len(struct sockaddr *addr)\n{\n\tswitch (addr->sa_family) {\n\n#ifdef AF_INET\n\tcase AF_INET:\n\t\treturn (sizeof (struct sockaddr_in));\n#endif\n\n#ifdef AF_INET6\n\tcase AF_INET6:\n\t\treturn (sizeof (struct sockaddr_in6));\n#endif\n\n#if (defined(linux) || defined(__Lynx__)) && defined(AF_PACKET)\n\tcase AF_PACKET:\n\t\treturn (sizeof (struct sockaddr_ll));\n#endif\n\n\tdefault:\n\t\treturn (sizeof (struct sockaddr));\n\t}\n}",
          "fn_code_pos": [
            [
              108,
              0
            ],
            [
              131,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_sa_len",
            "parameters": {
              "addr": "struct sockaddr"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "int\npcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,\n    int (*check_usable)(const char *), get_if_flags_func get_flags_func)\n{\n\tstruct ifaddrs *ifap, *ifa;\n\tstruct sockaddr *addr, *netmask, *broadaddr, *dstaddr;\n\tsize_t addr_size, broadaddr_size, dstaddr_size;\n\tint ret = 0;\n\tchar *p, *q;\n\n\t/*\n\t * Get the list of interface addresses.\n\t *\n\t * Note: this won't return information about interfaces\n\t * with no addresses, so, if a platform has interfaces\n\t * with no interfaces on which traffic can be captured,\n\t * we must check for those interfaces as well (see, for\n\t * example, what's done on Linux).\n\t *\n\t * LAN interfaces will probably have link-layer\n\t * addresses; I don't know whether all implementations\n\t * of \"getifaddrs()\" now, or in the future, will return\n\t * those.\n\t */\n\tif (getifaddrs(&ifap) != 0) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"getifaddrs\");\n\t\treturn (-1);\n\t}\n\tfor (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {\n\t\t/*\n\t\t * If this entry has a colon followed by a number at\n\t\t * the end, we assume it's a logical interface.  Those\n\t\t * are just the way you assign multiple IP addresses to\n\t\t * a real interface on Linux, so an entry for a logical\n\t\t * interface should be treated like the entry for the\n\t\t * real interface; we do that by stripping off the \":\"\n\t\t * and the number.\n\t\t *\n\t\t * XXX - should we do this only on Linux?\n\t\t */\n\t\tp = strchr(ifa->ifa_name, ':');\n\t\tif (p != NULL) {\n\t\t\t/*\n\t\t\t * We have a \":\"; is it followed by a number?\n\t\t\t */\n\t\t\tq = p + 1;\n\t\t\twhile (isdigit((unsigned char)*q))\n\t\t\t\tq++;\n\t\t\tif (*q == '\\0') {\n\t\t\t\t/*\n\t\t\t\t * All digits after the \":\" until the end.\n\t\t\t\t * Strip off the \":\" and everything after\n\t\t\t\t * it.\n\t\t\t\t */\n\t\t\t       *p = '\\0';\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Can we capture on this device?\n\t\t */\n\t\tif (!(*check_usable)(ifa->ifa_name)) {\n\t\t\t/*\n\t\t\t * No.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * \"ifa_addr\" was apparently null on at least one\n\t\t * interface on some system.  Therefore, we supply\n\t\t * the address and netmask only if \"ifa_addr\" is\n\t\t * non-null (if there's no address, there's obviously\n\t\t * no netmask).\n\t\t */\n\t\tif (ifa->ifa_addr != NULL) {\n\t\t\taddr = ifa->ifa_addr;\n\t\t\taddr_size = SA_LEN(addr);\n\t\t\tnetmask = ifa->ifa_netmask;\n\t\t} else {\n\t\t\taddr = NULL;\n\t\t\taddr_size = 0;\n\t\t\tnetmask = NULL;\n\t\t}\n\n\t\t/*\n\t\t * Note that, on some platforms, ifa_broadaddr and\n\t\t * ifa_dstaddr could be the same field (true on at\n\t\t * least some versions of *BSD and macOS), so we\n\t\t * can't just check whether the broadcast address\n\t\t * is null and add it if so and check whether the\n\t\t * destination address is null and add it if so.\n\t\t *\n\t\t * Therefore, we must also check the IFF_BROADCAST\n\t\t * flag, and only add a broadcast address if it's\n\t\t * set, and check the IFF_POINTTOPOINT flag, and\n\t\t * only add a destination address if it's set (as\n\t\t * per man page recommendations on some of those\n\t\t * platforms).\n\t\t */\n\t\tif (ifa->ifa_flags & IFF_BROADCAST &&\n\t\t    ifa->ifa_broadaddr != NULL) {\n\t\t\tbroadaddr = ifa->ifa_broadaddr;\n\t\t\tbroadaddr_size = SA_LEN(broadaddr);\n\t\t} else {\n\t\t\tbroadaddr = NULL;\n\t\t\tbroadaddr_size = 0;\n\t\t}\n\t\tif (ifa->ifa_flags & IFF_POINTOPOINT &&\n\t\t    ifa->ifa_dstaddr != NULL) {\n\t\t\tdstaddr = ifa->ifa_dstaddr;\n\t\t\tdstaddr_size = SA_LEN(ifa->ifa_dstaddr);\n\t\t} else {\n\t\t\tdstaddr = NULL;\n\t\t\tdstaddr_size = 0;\n\t\t}\n\n\t\t/*\n\t\t * Add information for this address to the list.\n\t\t */\n\t\tif (add_addr_to_if(devlistp, ifa->ifa_name, ifa->ifa_flags,\n\t\t    get_flags_func,\n\t\t    addr, addr_size, netmask, addr_size,\n\t\t    broadaddr, broadaddr_size, dstaddr, dstaddr_size,\n\t\t    errbuf) < 0) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfreeifaddrs(ifap);\n\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              145,
              0
            ],
            [
              279,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_findalldevs_interfaces",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char",
              "check_usable": "int",
              "get_flags_func": "get_if_flags_func"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*check_usable)(const char *)",
          "fn_dec_pos": [
            [
              147,
              8
            ],
            [
              147,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct sockaddr",
          {},
          "",
          [
            109,
            11
          ],
          [
            109,
            26
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            115,
            18
          ],
          [
            115,
            36
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            120,
            18
          ],
          [
            120,
            37
          ]
        ],
        [
          "struct sockaddr_ll",
          {},
          "",
          [
            125,
            18
          ],
          [
            125,
            36
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            129,
            18
          ],
          [
            129,
            33
          ]
        ],
        [
          "struct ifaddrs",
          {},
          "",
          [
            149,
            1
          ],
          [
            149,
            15
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            150,
            1
          ],
          [
            150,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <net/if.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <ifaddrs.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#  include <netpacket/packet.h>\n",
          [
            66,
            0
          ],
          [
            67,
            0
          ]
        ],
        [
          "#  include <netpacket/if_packet.h>\n",
          [
            71,
            0
          ],
          [
            72,
            0
          ]
        ],
        [
          "#  include <linux/types.h>\n",
          [
            74,
            0
          ],
          [
            75,
            0
          ]
        ],
        [
          "#  include <linux/if_packet.h>\n",
          [
            75,
            0
          ],
          [
            76,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-common.c": {
      "fn_def_list": [
        {
          "fn_code": "int\ndlt_to_linktype(int dlt)\n{\n\tint i;\n\n\t/*\n\t * DLTs that, on some platforms, have values in the matching range\n\t * but that *don't* have the same value as the corresponding\n\t * LINKTYPE because, for some reason, not all OSes have the\n\t * same value for that DLT (note that the DLT's value might be\n\t * outside the matching range on some of those OSes).\n\t */\n\tif (dlt == DLT_PFSYNC)\n\t\treturn (LINKTYPE_PFSYNC);\n\tif (dlt == DLT_PKTAP)\n\t\treturn (LINKTYPE_PKTAP);\n\n\t/*\n\t * For all other values in the matching range, the DLT\n\t * value is the same as the LINKTYPE value.\n\t */\n\tif (dlt >= DLT_MATCHING_MIN && dlt <= DLT_MATCHING_MAX)\n\t\treturn (dlt);\n\n\t/*\n\t * Map the values outside that range.\n\t */\n\tfor (i = 0; map[i].dlt != -1; i++) {\n\t\tif (map[i].dlt == dlt)\n\t\t\treturn (map[i].linktype);\n\t}\n\n\t/*\n\t * If we don't have a mapping for this DLT, return an\n\t * error; that means that this is a value with no corresponding\n\t * LINKTYPE, and we need to assign one.\n\t */\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              1233,
              0
            ],
            [
              1271,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlt_to_linktype",
            "parameters": {
              "dlt": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nlinktype_to_dlt(int linktype)\n{\n\tint i;\n\n\t/*\n\t * LINKTYPEs in the matching range that *don't*\n\t * have the same value as the corresponding DLTs\n\t * because, for some reason, not all OSes have the\n\t * same value for that DLT.\n\t */\n\tif (linktype == LINKTYPE_PFSYNC)\n\t\treturn (DLT_PFSYNC);\n\tif (linktype == LINKTYPE_PKTAP)\n\t\treturn (DLT_PKTAP);\n\n\t/*\n\t * For all other values in the matching range, the LINKTYPE\n\t * value is the same as the DLT value.\n\t */\n\tif (linktype >= LINKTYPE_MATCHING_MIN &&\n\t    linktype <= LINKTYPE_MATCHING_MAX)\n\t\treturn (linktype);\n\n\t/*\n\t * Map the values outside that range.\n\t */\n\tfor (i = 0; map[i].linktype != -1; i++) {\n\t\tif (map[i].linktype == linktype)\n\t\t\treturn (map[i].dlt);\n\t}\n\n\t/*\n\t * If we don't have an entry for this LINKTYPE, return\n\t * the link type value; it may be a DLT from an older\n\t * version of libpcap.\n\t */\n\treturn linktype;\n}",
          "fn_code_pos": [
            [
              1273,
              0
            ],
            [
              1311,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "linktype_to_dlt",
            "parameters": {
              "linktype": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "u_int\nmax_snaplen_for_dlt(int dlt)\n{\n\tswitch (dlt) {\n\n\tcase DLT_DBUS:\n\t\treturn 134217728;\n\n\tcase DLT_EBHSCR:\n\t\treturn 8*1024*1024;\n\n\tdefault:\n\t\treturn MAXIMUM_SNAPLEN;\n\t}\n}",
          "fn_code_pos": [
            [
              1326,
              0
            ],
            [
              1340,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "max_snaplen_for_dlt",
            "parameters": {
              "dlt": "int"
            },
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "static void\nswap_linux_sll_header(const struct pcap_pkthdr *hdr, u_char *buf)\n{\n\tu_int caplen = hdr->caplen;\n\tu_int length = hdr->len;\n\tstruct sll_header *shdr = (struct sll_header *)buf;\n\tuint16_t protocol;\n\tpcap_can_socketcan_hdr *chdr;\n\n\tif (caplen < (u_int) sizeof(struct sll_header) ||\n\t    length < (u_int) sizeof(struct sll_header)) {\n\t\t/* Not enough data to have the protocol field */\n\t\treturn;\n\t}\n\n\tprotocol = EXTRACT_BE_U_2(&shdr->sll_protocol);\n\tif (protocol != LINUX_SLL_P_CAN && protocol != LINUX_SLL_P_CANFD)\n\t\treturn;\n\n\t/*\n\t * SocketCAN packet; fix up the packet's header.\n\t */\n\tchdr = (pcap_can_socketcan_hdr *)(buf + sizeof(struct sll_header));\n\tif (caplen < (u_int) sizeof(struct sll_header) + sizeof(chdr->can_id) ||\n\t    length < (u_int) sizeof(struct sll_header) + sizeof(chdr->can_id)) {\n\t\t/* Not enough data to have the CAN ID */\n\t\treturn;\n\t}\n\tchdr->can_id = SWAPLONG(chdr->can_id);\n}",
          "fn_code_pos": [
            [
              1351,
              0
            ],
            [
              1380,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "swap_linux_sll_header",
            "parameters": {
              "hdr": "struct pcap_pkthdr",
              "buf": "u_char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nswap_linux_usb_header(const struct pcap_pkthdr *hdr, u_char *buf,\n    int header_len_64_bytes)\n{\n\tpcap_usb_header_mmapped *uhdr = (pcap_usb_header_mmapped *)buf;\n\tbpf_u_int32 offset = 0;\n\n\t/*\n\t * \"offset\" is the offset *past* the field we're swapping;\n\t * we skip the field *before* checking to make sure\n\t * the captured data length includes the entire field.\n\t */\n\n\t/*\n\t * The URB id is a totally opaque value; do we really need to\n\t * convert it to the reading host's byte order???\n\t */\n\toffset += 8;\t\t\t/* skip past id */\n\tif (hdr->caplen < offset)\n\t\treturn;\n\tuhdr->id = SWAPLL(uhdr->id);\n\n\toffset += 4;\t\t\t/* skip past various 1-byte fields */\n\n\toffset += 2;\t\t\t/* skip past bus_id */\n\tif (hdr->caplen < offset)\n\t\treturn;\n\tuhdr->bus_id = SWAPSHORT(uhdr->bus_id);\n\n\toffset += 2;\t\t\t/* skip past various 1-byte fields */\n\n\toffset += 8;\t\t\t/* skip past ts_sec */\n\tif (hdr->caplen < offset)\n\t\treturn;\n\tuhdr->ts_sec = SWAPLL(uhdr->ts_sec);\n\n\toffset += 4;\t\t\t/* skip past ts_usec */\n\tif (hdr->caplen < offset)\n\t\treturn;\n\tuhdr->ts_usec = SWAPLONG(uhdr->ts_usec);\n\n\toffset += 4;\t\t\t/* skip past status */\n\tif (hdr->caplen < offset)\n\t\treturn;\n\tuhdr->status = SWAPLONG(uhdr->status);\n\n\toffset += 4;\t\t\t/* skip past urb_len */\n\tif (hdr->caplen < offset)\n\t\treturn;\n\tuhdr->urb_len = SWAPLONG(uhdr->urb_len);\n\n\toffset += 4;\t\t\t/* skip past data_len */\n\tif (hdr->caplen < offset)\n\t\treturn;\n\tuhdr->data_len = SWAPLONG(uhdr->data_len);\n\n\tif (uhdr->transfer_type == URB_ISOCHRONOUS) {\n\t\toffset += 4;\t\t\t/* skip past s.iso.error_count */\n\t\tif (hdr->caplen < offset)\n\t\t\treturn;\n\t\tuhdr->s.iso.error_count = SWAPLONG(uhdr->s.iso.error_count);\n\n\t\toffset += 4;\t\t\t/* skip past s.iso.numdesc */\n\t\tif (hdr->caplen < offset)\n\t\t\treturn;\n\t\tuhdr->s.iso.numdesc = SWAPLONG(uhdr->s.iso.numdesc);\n\t} else\n\t\toffset += 8;\t\t\t/* skip USB setup header */\n\n\t/*\n\t * With the old header, there are no isochronous descriptors\n\t * after the header.\n\t *\n\t * With the new header, the actual number of descriptors in\n\t * the header is not s.iso.numdesc, it's ndesc - only the\n\t * first N descriptors, for some value of N, are put into\n\t * the header, and ndesc is set to the actual number copied.\n\t * In addition, if s.iso.numdesc is negative, no descriptors\n\t * are captured, and ndesc is set to 0.\n\t */\n\tif (header_len_64_bytes) {\n\t\t/*\n\t\t * This is either the \"version 1\" header, with\n\t\t * 16 bytes of additional fields at the end, or\n\t\t * a \"version 0\" header from a memory-mapped\n\t\t * capture, with 16 bytes of zeroed-out padding\n\t\t * at the end.  Byte swap them as if this were\n\t\t * a \"version 1\" header.\n\t\t */\n\t\toffset += 4;\t\t\t/* skip past interval */\n\t\tif (hdr->caplen < offset)\n\t\t\treturn;\n\t\tuhdr->interval = SWAPLONG(uhdr->interval);\n\n\t\toffset += 4;\t\t\t/* skip past start_frame */\n\t\tif (hdr->caplen < offset)\n\t\t\treturn;\n\t\tuhdr->start_frame = SWAPLONG(uhdr->start_frame);\n\n\t\toffset += 4;\t\t\t/* skip past xfer_flags */\n\t\tif (hdr->caplen < offset)\n\t\t\treturn;\n\t\tuhdr->xfer_flags = SWAPLONG(uhdr->xfer_flags);\n\n\t\toffset += 4;\t\t\t/* skip past ndesc */\n\t\tif (hdr->caplen < offset)\n\t\t\treturn;\n\t\tuhdr->ndesc = SWAPLONG(uhdr->ndesc);\n\n\t\tif (uhdr->transfer_type == URB_ISOCHRONOUS) {\n\t\t\t/* swap the values in struct linux_usb_isodesc */\n\t\t\tusb_isodesc *pisodesc;\n\t\t\tuint32_t i;\n\n\t\t\tpisodesc = (usb_isodesc *)(void *)(buf+offset);\n\t\t\tfor (i = 0; i < uhdr->ndesc; i++) {\n\t\t\t\toffset += 4;\t\t/* skip past status */\n\t\t\t\tif (hdr->caplen < offset)\n\t\t\t\t\treturn;\n\t\t\t\tpisodesc->status = SWAPLONG(pisodesc->status);\n\n\t\t\t\toffset += 4;\t\t/* skip past offset */\n\t\t\t\tif (hdr->caplen < offset)\n\t\t\t\t\treturn;\n\t\t\t\tpisodesc->offset = SWAPLONG(pisodesc->offset);\n\n\t\t\t\toffset += 4;\t\t/* skip past len */\n\t\t\t\tif (hdr->caplen < offset)\n\t\t\t\t\treturn;\n\t\t\t\tpisodesc->len = SWAPLONG(pisodesc->len);\n\n\t\t\t\toffset += 4;\t\t/* skip past padding */\n\n\t\t\t\tpisodesc++;\n\t\t\t}\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              1391,
              0
            ],
            [
              1528,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "swap_linux_usb_header",
            "parameters": {
              "hdr": "struct pcap_pkthdr",
              "buf": "u_char",
              "header_len_64_bytes": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nswap_nflog_header(const struct pcap_pkthdr *hdr, u_char *buf)\n{\n\tu_char *p = buf;\n\tnflog_hdr_t *nfhdr = (nflog_hdr_t *)buf;\n\tnflog_tlv_t *tlv;\n\tu_int caplen = hdr->caplen;\n\tu_int length = hdr->len;\n\tuint16_t size;\n\n\tif (caplen < (u_int) sizeof(nflog_hdr_t) ||\n\t    length < (u_int) sizeof(nflog_hdr_t)) {\n\t\t/* Not enough data to have any TLVs. */\n\t\treturn;\n\t}\n\n\tif (nfhdr->nflog_version != 0) {\n\t\t/* Unknown NFLOG version */\n\t\treturn;\n\t}\n\n\tlength -= sizeof(nflog_hdr_t);\n\tcaplen -= sizeof(nflog_hdr_t);\n\tp += sizeof(nflog_hdr_t);\n\n\twhile (caplen >= sizeof(nflog_tlv_t)) {\n\t\ttlv = (nflog_tlv_t *) p;\n\n\t\t/* Swap the type and length. */\n\t\ttlv->tlv_type = SWAPSHORT(tlv->tlv_type);\n\t\ttlv->tlv_length = SWAPSHORT(tlv->tlv_length);\n\n\t\t/* Get the length of the TLV. */\n\t\tsize = tlv->tlv_length;\n\t\tif (size % 4 != 0)\n\t\t\tsize += 4 - size % 4;\n\n\t\t/* Is the TLV's length less than the minimum? */\n\t\tif (size < sizeof(nflog_tlv_t)) {\n\t\t\t/* Yes. Give up now. */\n\t\t\treturn;\n\t\t}\n\n\t\t/* Do we have enough data for the full TLV? */\n\t\tif (caplen < size || length < size) {\n\t\t\t/* No. */\n\t\t\treturn;\n\t\t}\n\n\t\t/* Skip over the TLV. */\n\t\tlength -= size;\n\t\tcaplen -= size;\n\t\tp += size;\n\t}\n}",
          "fn_code_pos": [
            [
              1541,
              0
            ],
            [
              1595,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "swap_nflog_header",
            "parameters": {
              "hdr": "struct pcap_pkthdr",
              "buf": "u_char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nswap_pseudo_headers(int linktype, struct pcap_pkthdr *hdr, u_char *data)\n{\n\t/*\n\t * Convert pseudo-headers from the byte order of\n\t * the host on which the file was saved to our\n\t * byte order, as necessary.\n\t */\n\tswitch (linktype) {\n\n\tcase DLT_LINUX_SLL:\n\t\tswap_linux_sll_header(hdr, data);\n\t\tbreak;\n\n\tcase DLT_USB_LINUX:\n\t\tswap_linux_usb_header(hdr, data, 0);\n\t\tbreak;\n\n\tcase DLT_USB_LINUX_MMAPPED:\n\t\tswap_linux_usb_header(hdr, data, 1);\n\t\tbreak;\n\n\tcase DLT_NFLOG:\n\t\tswap_nflog_header(hdr, data);\n\t\tbreak;\n\t}\n}",
          "fn_code_pos": [
            [
              1597,
              0
            ],
            [
              1623,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "swap_pseudo_headers",
            "parameters": {
              "linktype": "int",
              "hdr": "struct pcap_pkthdr",
              "data": "u_char"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct linktype_map {\n\tint\tdlt;\n\tint\tlinktype;\n}",
          {
            "dlt": "int",
            "linktype": "int"
          },
          "linktype_map",
          [
            1168,
            7
          ],
          [
            1171,
            1
          ]
        ],
        [
          "struct linktype_map {\n\tint\tdlt;\n\tint\tlinktype;\n}",
          {
            "dlt": "int",
            "linktype": "int"
          },
          "linktype_map",
          [
            1168,
            7
          ],
          [
            1171,
            1
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            1352,
            28
          ],
          [
            1352,
            46
          ]
        ],
        [
          "struct sll_header",
          {},
          "",
          [
            1356,
            1
          ],
          [
            1356,
            18
          ]
        ],
        [
          "struct sll_header",
          {},
          "",
          [
            1356,
            28
          ],
          [
            1356,
            45
          ]
        ],
        [
          "struct sll_header",
          {},
          "",
          [
            1360,
            29
          ],
          [
            1360,
            46
          ]
        ],
        [
          "struct sll_header",
          {},
          "",
          [
            1361,
            29
          ],
          [
            1361,
            46
          ]
        ],
        [
          "struct sll_header",
          {},
          "",
          [
            1373,
            48
          ],
          [
            1373,
            65
          ]
        ],
        [
          "struct sll_header",
          {},
          "",
          [
            1374,
            29
          ],
          [
            1374,
            46
          ]
        ],
        [
          "struct sll_header",
          {},
          "",
          [
            1375,
            29
          ],
          [
            1375,
            46
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            1392,
            28
          ],
          [
            1392,
            46
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            1542,
            24
          ],
          [
            1542,
            42
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            1598,
            34
          ],
          [
            1598,
            52
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <pcap-types.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"extract.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"pcap/sll.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"pcap/usb.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include \"pcap/nflog.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"pcap/can_socketcan.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include \"pcap-common.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-null.c": {
      "fn_def_list": [
        {
          "fn_code": "pcap_t *\npcap_create_interface(const char *device _U_, char *ebuf)\n{\n\t(void)pcap_strlcpy(ebuf, nosup, PCAP_ERRBUF_SIZE);\n\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              36,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "int\npcap_lookupnet(const char *device _U_, bpf_u_int32 *netp _U_,\n    bpf_u_int32 *maskp _U_, char *errbuf)\n{\n\t(void)pcap_strlcpy(errbuf, nosup, PCAP_ERRBUF_SIZE);\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lookupnet",
            "parameters": {
              "device": "char",
              "netp": "bpf_u_int32",
              "maskp": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING);\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              64,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "pcap_create_interface(const char *device _U_, char *ebuf)",
          "fn_dec_pos": [
            [
              32,
              0
            ],
            [
              32,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              61,
              0
            ],
            [
              61,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/etherent.c": {
      "fn_def_list": [
        {
          "fn_code": "static inline u_char\nxdtoi(u_char c)\n{\n\tif (isdigit(c))\n\t\treturn (u_char)(c - '0');\n\telse if (islower(c))\n\t\treturn (u_char)(c - 'a' + 10);\n\telse\n\t\treturn (u_char)(c - 'A' + 10);\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              53,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "xdtoi",
            "parameters": {
              "c": "u_char"
            },
            "return_type": "u_char"
          }
        },
        {
          "fn_code": "static inline int\nskip_space(FILE *f)\n{\n\tint c;\n\n\tdo {\n\t\tc = getc(f);\n\t} while (isspace(c) && c != '\\n');\n\n\treturn c;\n}",
          "fn_code_pos": [
            [
              55,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "skip_space",
            "parameters": {
              "f": "FILE"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static inline int\nskip_line(FILE *f)\n{\n\tint c;\n\n\tdo\n\t\tc = getc(f);\n\twhile (c != '\\n' && c != EOF);\n\n\treturn c;\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "skip_line",
            "parameters": {
              "f": "FILE"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "struct pcap_etherent *\npcap_next_etherent(FILE *fp)\n{\n\tregister int c, i;\n\tu_char d;\n\tchar *bp;\n\tsize_t namesize;\n\tstatic struct pcap_etherent e;\n\n\tmemset((char *)&e, 0, sizeof(e));\n\tfor (;;) {\n\t\t/* Find addr */\n\t\tc = skip_space(fp);\n\t\tif (c == EOF)\n\t\t\treturn (NULL);\n\t\tif (c == '\\n')\n\t\t\tcontinue;\n\n\t\t/* If this is a comment, or first thing on line\n\t\t   cannot be Ethernet address, skip the line. */\n\t\tif (!isxdigit(c)) {\n\t\t\tc = skip_line(fp);\n\t\t\tif (c == EOF)\n\t\t\t\treturn (NULL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* must be the start of an address */\n\t\tfor (i = 0; i < 6; i += 1) {\n\t\t\td = xdtoi((u_char)c);\n\t\t\tc = getc(fp);\n\t\t\tif (c == EOF)\n\t\t\t\treturn (NULL);\n\t\t\tif (isxdigit(c)) {\n\t\t\t\td <<= 4;\n\t\t\t\td |= xdtoi((u_char)c);\n\t\t\t\tc = getc(fp);\n\t\t\t\tif (c == EOF)\n\t\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\te.addr[i] = d;\n\t\t\tif (c != ':')\n\t\t\t\tbreak;\n\t\t\tc = getc(fp);\n\t\t\tif (c == EOF)\n\t\t\t\treturn (NULL);\n\t\t}\n\n\t\t/* Must be whitespace */\n\t\tif (!isspace(c)) {\n\t\t\tc = skip_line(fp);\n\t\t\tif (c == EOF)\n\t\t\t\treturn (NULL);\n\t\t\tcontinue;\n\t\t}\n\t\tc = skip_space(fp);\n\t\tif (c == EOF)\n\t\t\treturn (NULL);\n\n\t\t/* hit end of line... */\n\t\tif (c == '\\n')\n\t\t\tcontinue;\n\n\t\tif (c == '#') {\n\t\t\tc = skip_line(fp);\n\t\t\tif (c == EOF)\n\t\t\t\treturn (NULL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* pick up name */\n\t\tbp = e.name;\n\t\t/* Use 'namesize' to prevent buffer overflow. */\n\t\tnamesize = sizeof(e.name) - 1;\n\t\tdo {\n\t\t\t*bp++ = (u_char)c;\n\t\t\tc = getc(fp);\n\t\t\tif (c == EOF)\n\t\t\t\treturn (NULL);\n\t\t} while (!isspace(c) && --namesize != 0);\n\t\t*bp = '\\0';\n\n\t\t/* Eat trailing junk */\n\t\tif (c != '\\n')\n\t\t\t(void)skip_line(fp);\n\n\t\treturn &e;\n\t}\n}",
          "fn_code_pos": [
            [
              79,
              0
            ],
            [
              167,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_next_etherent",
            "parameters": {
              "fp": "FILE"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "skip_space(FILE *)",
          "fn_dec_pos": [
            [
              40,
              18
            ],
            [
              40,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "skip_space",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "skip_line(FILE *)",
          "fn_dec_pos": [
            [
              41,
              18
            ],
            [
              41,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "skip_line",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_next_etherent(FILE *fp)",
          "fn_dec_pos": [
            [
              80,
              0
            ],
            [
              80,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_next_etherent",
            "parameters": {
              "fp": "FILE"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_etherent",
          {},
          "",
          [
            79,
            0
          ],
          [
            79,
            20
          ]
        ],
        [
          "struct pcap_etherent",
          {},
          "",
          [
            86,
            8
          ],
          [
            86,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <pcap-types.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <memory.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <pcap/namedb.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-netmap.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\npcap_netmap_stats(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct pcap_netmap *pn = p->priv;\n\n\tps->ps_recv = (u_int)pn->rx_pkts;\n\tps->ps_drop = 0;\n\tps->ps_ifdrop = 0;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              73,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_netmap_stats",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\npcap_netmap_filter(u_char *arg, struct pcap_pkthdr *h, const u_char *buf)\n{\n\tpcap_t *p = (pcap_t *)arg;\n\tstruct pcap_netmap *pn = p->priv;\n\tconst struct bpf_insn *pc = p->fcode.bf_insns;\n\n\t++pn->rx_pkts;\n\tif (pc == NULL || pcap_filter(pc, buf, h->len, h->caplen))\n\t\tpn->cb(pn->cb_arg, h, buf);\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_netmap_filter",
            "parameters": {
              "arg": "u_char",
              "h": "struct pcap_pkthdr",
              "buf": "u_char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\npcap_netmap_dispatch(pcap_t *p, int cnt, pcap_handler cb, u_char *user)\n{\n\tint ret;\n\tstruct pcap_netmap *pn = p->priv;\n\tstruct nm_desc *d = pn->d;\n\tstruct pollfd pfd = { .fd = p->fd, .events = POLLIN, .revents = 0 };\n\n\tpn->cb = cb;\n\tpn->cb_arg = user;\n\n\tfor (;;) {\n\t\tif (p->break_loop) {\n\t\t\tp->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\t\t/* nm_dispatch won't run forever */\n\n\t\tret = nm_dispatch((void *)d, cnt, (void *)pcap_netmap_filter, (void *)p);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\terrno = 0;\n\t\tret = poll(&pfd, 1, p->opt.timeout);\n\t}\n\treturn ret;\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_netmap_dispatch",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "cb": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_netmap_inject(pcap_t *p, const void *buf, int size)\n{\n\tstruct pcap_netmap *pn = p->priv;\n\tstruct nm_desc *d = pn->d;\n\n\treturn nm_inject(d, buf, size);\n}",
          "fn_code_pos": [
            [
              118,
              0
            ],
            [
              125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_netmap_inject",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_netmap_ioctl(pcap_t *p, u_long what, uint32_t *if_flags)\n{\n\tstruct pcap_netmap *pn = p->priv;\n\tstruct nm_desc *d = pn->d;\n\tstruct ifreq ifr;\n\tint error, fd = d->fd;\n\n#ifdef linux\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error: cannot get device control socket.\\n\");\n\t\treturn -1;\n\t}\n#endif /* linux */\n\tbzero(&ifr, sizeof(ifr));\n\tstrncpy(ifr.ifr_name, d->req.nr_name, sizeof(ifr.ifr_name));\n\tswitch (what) {\n\tcase SIOCSIFFLAGS:\n\t\t/*\n\t\t * The flags we pass in are 32-bit and unsigned.\n\t\t *\n\t\t * On most if not all UN*Xes, ifr_flags is 16-bit and\n\t\t * signed, and the result of assigning a longer\n\t\t * unsigned value to a shorter signed value is\n\t\t * implementation-defined (even if, in practice, it'll\n\t\t * do what's intended on all platforms we support\n\t\t * result of assigning a 32-bit unsigned value).\n\t\t * So we mask out the upper 16 bits.\n\t\t */\n\t\tifr.ifr_flags = *if_flags & 0xffff;\n#ifdef __FreeBSD__\n\t\t/*\n\t\t * In FreeBSD, we need to set the high-order flags,\n\t\t * as we're using IFF_PPROMISC, which is in those bits.\n\t\t *\n\t\t * XXX - DragonFly BSD?\n\t\t */\n\t\tifr.ifr_flagshigh = *if_flags >> 16;\n#endif /* __FreeBSD__ */\n\t\tbreak;\n\t}\n\terror = ioctl(fd, what, &ifr);\n\tif (!error) {\n\t\tswitch (what) {\n\t\tcase SIOCGIFFLAGS:\n\t\t\t/*\n\t\t\t * The flags we return are 32-bit.\n\t\t\t *\n\t\t\t * On most if not all UN*Xes, ifr_flags is\n\t\t\t * 16-bit and signed, and will get sign-\n\t\t\t * extended, so that the upper 16 bits of\n\t\t\t * those flags will be forced on.  So we\n\t\t\t * mask out the upper 16 bits of the\n\t\t\t * sign-extended value.\n\t\t\t */\n\t\t\t*if_flags = ifr.ifr_flags & 0xffff;\n#ifdef __FreeBSD__\n\t\t\t/*\n\t\t\t * In FreeBSD, we need to return the\n\t\t\t * high-order flags, as we're using\n\t\t\t * IFF_PPROMISC, which is in those bits.\n\t\t\t *\n\t\t\t * XXX - DragonFly BSD?\n\t\t\t */\n\t\t\t*if_flags |= (ifr.ifr_flagshigh << 16);\n#endif /* __FreeBSD__ */\n\t\t}\n\t}\n#ifdef linux\n\tclose(fd);\n#endif /* linux */\n\treturn error ? -1 : 0;\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_netmap_ioctl",
            "parameters": {
              "p": "pcap_t",
              "what": "u_long",
              "if_flags": "uint32_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\npcap_netmap_close(pcap_t *p)\n{\n\tstruct pcap_netmap *pn = p->priv;\n\tstruct nm_desc *d = pn->d;\n\tuint32_t if_flags = 0;\n\n\tif (pn->must_clear_promisc) {\n\t\tpcap_netmap_ioctl(p, SIOCGIFFLAGS, &if_flags); /* fetch flags */\n\t\tif (if_flags & IFF_PPROMISC) {\n\t\t\tif_flags &= ~IFF_PPROMISC;\n\t\t\tpcap_netmap_ioctl(p, SIOCSIFFLAGS, &if_flags);\n\t\t}\n\t}\n\tnm_close(d);\n\tpcap_cleanup_live_common(p);\n}",
          "fn_code_pos": [
            [
              204,
              0
            ],
            [
              220,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_netmap_close",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\npcap_netmap_activate(pcap_t *p)\n{\n\tstruct pcap_netmap *pn = p->priv;\n\tstruct nm_desc *d;\n\tuint32_t if_flags = 0;\n\n\td = nm_open(p->opt.device, NULL, 0, NULL);\n\tif (d == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"netmap open: cannot access %s\",\n\t\t    p->opt.device);\n\t\tpcap_cleanup_live_common(p);\n\t\treturn (PCAP_ERROR);\n\t}\n#if 0\n\tfprintf(stderr, \"%s device %s priv %p fd %d ports %d..%d\\n\",\n\t    __FUNCTION__, p->opt.device, d, d->fd,\n\t    d->first_rx_ring, d->last_rx_ring);\n#endif\n\tpn->d = d;\n\tp->fd = d->fd;\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n\tif (p->opt.promisc && !(d->req.nr_ringid & NETMAP_SW_RING)) {\n\t\tpcap_netmap_ioctl(p, SIOCGIFFLAGS, &if_flags); /* fetch flags */\n\t\tif (!(if_flags & IFF_PPROMISC)) {\n\t\t\tpn->must_clear_promisc = 1;\n\t\t\tif_flags |= IFF_PPROMISC;\n\t\t\tpcap_netmap_ioctl(p, SIOCSIFFLAGS, &if_flags);\n\t\t}\n\t}\n\tp->linktype = DLT_EN10MB;\n\tp->selectable_fd = p->fd;\n\tp->read_op = pcap_netmap_dispatch;\n\tp->inject_op = pcap_netmap_inject;\n\tp->setfilter_op = install_bpf_program;\n\tp->setdirection_op = NULL;\n\tp->set_datalink_op = NULL;\n\tp->getnonblock_op = pcap_getnonblock_fd;\n\tp->setnonblock_op = pcap_setnonblock_fd;\n\tp->stats_op = pcap_netmap_stats;\n\tp->cleanup_op = pcap_netmap_close;\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              223,
              0
            ],
            [
              278,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_netmap_activate",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_netmap_create(const char *device, char *ebuf, int *is_ours)\n{\n\tpcap_t *p;\n\n\t*is_ours = (!strncmp(device, \"netmap:\", 7) || !strncmp(device, \"vale\", 4));\n\tif (! *is_ours)\n\t\treturn NULL;\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_netmap));\n\tif (p == NULL)\n\t\treturn (NULL);\n\tp->activate_op = pcap_netmap_activate;\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              281,
              0
            ],
            [
              294,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_netmap_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": "pcap_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "pcap_netmap_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              282,
              0
            ],
            [
              282,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_netmap_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_netmap {\n\tstruct nm_desc *d;\t/* pointer returned by nm_open() */\n\tpcap_handler cb;\t/* callback and argument */\n\tu_char *cb_arg;\n\tint must_clear_promisc;\t/* flag */\n\tuint64_t rx_pkts;\t/* # of pkts received before the filter */\n}",
          {
            "*d": "struct nm_desc",
            "cb": "pcap_handler",
            "*cb_arg": "u_char",
            "must_clear_promisc": "int",
            "rx_pkts": "uint64_t"
          },
          "pcap_netmap",
          [
            55,
            0
          ],
          [
            61,
            1
          ]
        ],
        [
          "struct pcap_netmap {\n\tstruct nm_desc *d;\t/* pointer returned by nm_open() */\n\tpcap_handler cb;\t/* callback and argument */\n\tu_char *cb_arg;\n\tint must_clear_promisc;\t/* flag */\n\tuint64_t rx_pkts;\t/* # of pkts received before the filter */\n}",
          {
            "*d": "struct nm_desc",
            "cb": "pcap_handler",
            "*cb_arg": "u_char",
            "must_clear_promisc": "int",
            "rx_pkts": "uint64_t"
          },
          "pcap_netmap",
          [
            55,
            0
          ],
          [
            61,
            1
          ]
        ],
        [
          "struct nm_desc",
          {},
          "",
          [
            56,
            1
          ],
          [
            56,
            15
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            65,
            29
          ],
          [
            65,
            45
          ]
        ],
        [
          "struct pcap_netmap",
          {},
          "",
          [
            67,
            1
          ],
          [
            67,
            19
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            77,
            32
          ],
          [
            77,
            50
          ]
        ],
        [
          "struct pcap_netmap",
          {},
          "",
          [
            80,
            1
          ],
          [
            80,
            19
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            81,
            7
          ],
          [
            81,
            22
          ]
        ],
        [
          "struct pcap_netmap",
          {},
          "",
          [
            93,
            1
          ],
          [
            93,
            19
          ]
        ],
        [
          "struct nm_desc",
          {},
          "",
          [
            94,
            1
          ],
          [
            94,
            15
          ]
        ],
        [
          "struct pollfd",
          {},
          "",
          [
            95,
            1
          ],
          [
            95,
            14
          ]
        ],
        [
          "struct pcap_netmap",
          {},
          "",
          [
            121,
            1
          ],
          [
            121,
            19
          ]
        ],
        [
          "struct nm_desc",
          {},
          "",
          [
            122,
            1
          ],
          [
            122,
            15
          ]
        ],
        [
          "struct pcap_netmap",
          {},
          "",
          [
            131,
            1
          ],
          [
            131,
            19
          ]
        ],
        [
          "struct nm_desc",
          {},
          "",
          [
            132,
            1
          ],
          [
            132,
            15
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            133,
            1
          ],
          [
            133,
            13
          ]
        ],
        [
          "struct pcap_netmap",
          {},
          "",
          [
            207,
            1
          ],
          [
            207,
            19
          ]
        ],
        [
          "struct nm_desc",
          {},
          "",
          [
            208,
            1
          ],
          [
            208,
            15
          ]
        ],
        [
          "struct pcap_netmap",
          {},
          "",
          [
            226,
            1
          ],
          [
            226,
            19
          ]
        ],
        [
          "struct nm_desc",
          {},
          "",
          [
            227,
            1
          ],
          [
            227,
            15
          ]
        ],
        [
          "struct pcap_netmap",
          {},
          "",
          [
            289,
            38
          ],
          [
            289,
            56
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <poll.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <netdb.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <net/netmap_user.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"pcap-netmap.h\"\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-sita.c": {
      "fn_def_list": [
        {
          "fn_code": "static void dump_interface_list(void) {\n\tpcap_if_t\t\t*iff;\n\tpcap_addr_t\t\t*addr;\n\tint\t\t\tlongest_name_len = 0;\n\tchar\t\t\t*n, *d, *f;\n\tint\t\t\tif_number = 0;\n\n\tiff = acn_if_list;\n\twhile (iff) {\n\t\tif (iff->name && (strlen(iff->name) > longest_name_len)) longest_name_len = strlen(iff->name);\n\t\tiff = iff->next;\n\t}\n\tiff = acn_if_list;\n\tprintf(\"Interface List:\\n\");\n\twhile (iff) {\n\t\tn = (iff->name)\t\t\t\t\t\t\t? iff->name\t\t\t: \"\";\n\t\td = (iff->description)\t\t\t\t\t? iff->description\t: \"\";\n\t\tf = (iff->flags == PCAP_IF_LOOPBACK)\t? \"L\"\t\t\t\t: \"\";\n\t\tprintf(\"%3d: %*s %s '%s'\\n\", if_number++, longest_name_len, n, f, d);\n\t\taddr = iff->addresses;\n\t\twhile (addr) {\n\t\t\tprintf(\"%*s \", (5 + longest_name_len), \"\");\t\t/* add some indentation */\n\t\t\tprintf(\"%15s  \", (addr->addr)\t\t? inet_ntoa(((struct sockaddr_in *)addr->addr)->sin_addr)\t\t: \"\");\n\t\t\tprintf(\"%15s  \", (addr->netmask)\t? inet_ntoa(((struct sockaddr_in *)addr->netmask)->sin_addr)\t: \"\");\n\t\t\tprintf(\"%15s  \", (addr->broadaddr)\t? inet_ntoa(((struct sockaddr_in *)addr->broadaddr)->sin_addr)\t: \"\");\n\t\t\tprintf(\"%15s  \", (addr->dstaddr)\t? inet_ntoa(((struct sockaddr_in *)addr->dstaddr)->sin_addr)\t: \"\");\n\t\t\tprintf(\"\\n\");\n\t\t\taddr = addr->next;\n\t\t}\n\t\tiff = iff->next;\n\t}\n}",
          "fn_code_pos": [
            [
              80,
              0
            ],
            [
              111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_interface_list",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void dump(unsigned char *ptr, int i, int indent) {\n\tfprintf(stderr, \"%*s\", indent, \" \");\n\tfor (; i > 0; i--) {\n\t\tfprintf(stderr, \"%2.2x \", *ptr++);\n\t}\n\tfprintf(stderr, \"\\n\");\n}",
          "fn_code_pos": [
            [
              113,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump",
            "parameters": {
              "ptr": "unsigned char",
              "i": "int",
              "indent": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void dump_interface_list_p(void) {\n\tpcap_if_t\t\t*iff;\n\tpcap_addr_t\t\t*addr;\n\tint\t\t\t\tif_number = 0;\n\n\tiff = acn_if_list;\n\tprintf(\"Interface Pointer @ %p is %p:\\n\", &acn_if_list, iff);\n\twhile (iff) {\n\t\tprintf(\"%3d: %p %p next: %p\\n\", if_number++, iff->name, iff->description, iff->next);\n\t\tdump((unsigned char *)iff, sizeof(pcap_if_t), 5);\n\t\taddr = iff->addresses;\n\t\twhile (addr) {\n\t\t\tprintf(\"          %p %p %p %p, next: %p\\n\", addr->addr, addr->netmask, addr->broadaddr, addr->dstaddr, addr->next);\n\t\t\tdump((unsigned char *)addr, sizeof(pcap_addr_t), 10);\n\t\t\taddr = addr->next;\n\t\t}\n\t\tiff = iff->next;\n\t}\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              139,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_interface_list_p",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void dump_unit_table(void) {\n\tint\t\tchassis, geoslot;\n\tiface_t\t*p;\n\n\tprintf(\"%c:%c %s %s\\n\", 'C', 'S', \"fd\", \"IP Address\");\n\tfor (chassis = 0; chassis <= MAX_CHASSIS; chassis++) {\n\t\tfor (geoslot = 0; geoslot <= MAX_GEOSLOT; geoslot++) {\n\t\t\tif (units[chassis][geoslot].ip != NULL)\n\t\t\t\tprintf(\"%d:%d %2d %s\\n\", chassis, geoslot, units[chassis][geoslot].fd, units[chassis][geoslot].ip);\n\t\t\tp = units[chassis][geoslot].iface;\n\t\t\twhile (p) {\n\t\t\t\tchar *n = (p->name)\t\t\t? p->name\t\t\t: \"\";\n\t\t\t\tchar *i = (p->IOPname)\t\t? p->IOPname\t\t: \"\";\n\t\t\t\tp = p->next;\n\t\t\t\tprintf(\"   %12s    -> %12s\\n\", i, n);\n\t\t\t}\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              141,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_unit_table",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int find_unit_by_fd(int fd, int *chassis, int *geoslot, unit_t **unit_ptr) {\n\tint\t\tc, s;\n\n\tfor (c = 0; c <= MAX_CHASSIS; c++) {\n\t\tfor (s = 0; s <= MAX_GEOSLOT; s++) {\n\t\t\tif (units[c][s].fd == fd || units[c][s].find_fd == fd) {\n\t\t\t\tif (chassis)\t*chassis = c;\n\t\t\t\tif (geoslot)\t*geoslot = s;\n\t\t\t\tif (unit_ptr)\t*unit_ptr = &units[c][s];\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              161,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_unit_by_fd",
            "parameters": {
              "fd": "int",
              "chassis": "int",
              "geoslot": "int",
              "unit_ptr": "unit_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int read_client_nbytes(int fd, int count, unsigned char *buf) {\n\tunit_t\t\t\t*u;\n\tint\t\t\t\tchassis, geoslot;\n\tint\t\t\t\tlen;\n\n\tfind_unit_by_fd(fd, &chassis, &geoslot, &u);\n\twhile (count) {\n\t\tif ((len = recv(fd, buf, count, 0)) <= 0)\treturn -1;\t/* read in whatever data was sent to us */\n\t\tcount -= len;\n\t\tbuf += len;\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* till we have everything we are looking for */\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_client_nbytes",
            "parameters": {
              "fd": "int",
              "count": "int",
              "buf": "unsigned char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void empty_unit_iface(unit_t *u) {\n\tiface_t\t*p, *cur;\n\n\tcur = u->iface;\n\twhile (cur) {\t\t\t\t\t\t\t\t\t\t\t/* loop over all the interface entries */\n\t\tif (cur->name)\t\t\tfree(cur->name);\t\t\t/* throwing away the contents if they exist */\n\t\tif (cur->IOPname)\t\tfree(cur->IOPname);\n\t\tp = cur->next;\n\t\tfree(cur);\t\t\t\t\t\t\t\t\t\t\t/* then throw away the structure itself */\n\t\tcur = p;\n\t}\n\tu->iface = 0;\t\t\t\t\t\t\t\t\t\t\t/* and finally remember that there are no remaining structure */\n}",
          "fn_code_pos": [
            [
              191,
              0
            ],
            [
              203,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "empty_unit_iface",
            "parameters": {
              "u": "unit_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void empty_unit(int chassis, int geoslot) {\n\tunit_t\t*u = &units[chassis][geoslot];\n\n\tempty_unit_iface(u);\n\tif (u->imsg) {\t\t\t\t\t\t\t\t\t\t\t/* then if an inbound message buffer exists */\n\t\tvoid *bigger_buffer;\n\n\t\tbigger_buffer = (char *)realloc(u->imsg, 1);\t\t\t\t/* and re-allocate the old large buffer into a new small one */\n\t\tif (bigger_buffer == NULL) {\t/* oops, realloc call failed */\n\t\t\tfprintf(stderr, \"Warning...call to realloc() failed, value of errno is %d\\n\", errno);\n\t\t\treturn;\n\t\t}\n\t\tu->imsg = bigger_buffer;\n\t}\n}",
          "fn_code_pos": [
            [
              205,
              0
            ],
            [
              219,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "empty_unit",
            "parameters": {
              "chassis": "int",
              "geoslot": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void empty_unit_table(void) {\n\tint\t\tchassis, geoslot;\n\n\tfor (chassis = 0; chassis <= MAX_CHASSIS; chassis++) {\n\t\tfor (geoslot = 0; geoslot <= MAX_GEOSLOT; geoslot++) {\n\t\t\tif (units[chassis][geoslot].ip != NULL) {\n\t\t\t\tfree(units[chassis][geoslot].ip);\t\t\t/* get rid of the malloc'ed space that holds the IP address */\n\t\t\t\tunits[chassis][geoslot].ip = 0;\t\t\t\t/* then set the pointer to NULL */\n\t\t\t}\n\t\t\tempty_unit(chassis, geoslot);\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              221,
              0
            ],
            [
              233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "empty_unit_table",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static char *find_nth_interface_name(int n) {\n\tint\t\tchassis, geoslot;\n\tiface_t\t*p;\n\tchar\t*last_name = 0;\n\n\tif (n < 0) n = 0;\t\t\t\t\t\t\t\t\t\t\t\t/* ensure we are working with a valid number */\n\tfor (chassis = 0; chassis <= MAX_CHASSIS; chassis++) {\t\t\t/* scan the table... */\n\t\tfor (geoslot = 0; geoslot <= MAX_GEOSLOT; geoslot++) {\n\t\t\tif (units[chassis][geoslot].ip != NULL) {\n\t\t\t\tp = units[chassis][geoslot].iface;\n\t\t\t\twhile (p) {\t\t\t\t\t\t\t\t\t\t\t/* and all interfaces... */\n\t\t\t\t\tif (p->IOPname) last_name = p->name;\t\t\t/* remembering the last name found */\n\t\t\t\t\tif (n-- == 0) return last_name;\t\t\t\t\t/* and if we hit the instance requested */\n\t\t\t\t\tp = p->next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\t\t\t\t\t\t\t\t/* if we couldn't fine the selected entry */\n\tif (last_name)\treturn last_name;\t\t/* ... but we did have at least one entry... return the last entry found */\n\treturn \"\";\t\t\t\t\t\t\t\t/* ... but if there wasn't any entry... return an empty string instead */\n}",
          "fn_code_pos": [
            [
              235,
              0
            ],
            [
              256,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_nth_interface_name",
            "parameters": {
              "n": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int acn_parse_hosts_file(char *errbuf) {\t\t\t\t/* returns: -1 = error, 0 = OK */\n\tFILE\t*fp;\n\tchar\tbuf[MAX_LINE_SIZE];\n\tchar\t*ptr, *ptr2;\n\tint\t\tpos;\n\tint\t\tchassis, geoslot;\n\tunit_t\t*u;\n\n\tempty_unit_table();\n\tif ((fp = fopen(\"/etc/hosts\", \"r\")) == NULL) {\t\t\t\t\t\t\t\t\t\t/* try to open the hosts file and if it fails */\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Cannot open '/etc/hosts' for reading.\");\t/* return the nohostsfile error response */\n\t\treturn -1;\n\t}\n\twhile (fgets(buf, MAX_LINE_SIZE-1, fp)) {\t\t\t/* while looping over the file */\n\n\t\tpos = strcspn(buf, \"#\\n\\r\");\t\t\t\t\t/* find the first comment character or EOL */\n\t\t*(buf + pos) = '\\0';\t\t\t\t\t\t\t/* and clobber it and anything that follows it */\n\n\t\tpos = strspn(buf, \" \\t\");\t\t\t\t\t\t/* then find the first non-white space */\n\t\tif (pos == strlen(buf))\t\t\t\t\t\t\t/* if there is nothing but white space on the line */\n\t\t\tcontinue;\t\t\t\t\t\t\t\t\t/* ignore that empty line */\n\t\tptr = buf + pos;\t\t\t\t\t\t\t\t/* and skip over any of that leading whitespace */\n\n\t\tif ((ptr2 = strstr(ptr, \"_I_\")) == NULL)\t\t/* skip any lines that don't have names that look like they belong to IOPs */\n\t\t\tcontinue;\n\t\tif (*(ptr2 + 4) != '_')\t\t\t\t\t\t\t/* and skip other lines that have names that don't look like ACN components */\n\t\t\tcontinue;\n\t\t*(ptr + strcspn(ptr, \" \\t\")) = '\\0';\t\t\t/* null terminate the IP address so its a standalone string */\n\n\t\tchassis = *(ptr2 + 3) - '0';\t\t\t\t\t/* extract the chassis number */\n\t\tgeoslot = *(ptr2 + 5) - '0';\t\t\t\t\t/* and geo-slot number */\n\t\tif (chassis < 1 || chassis > MAX_CHASSIS ||\n\t\t\tgeoslot < 1 || geoslot > MAX_GEOSLOT) {\t\t/* if the chassis and/or slot numbers appear to be bad... */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Invalid ACN name in '/etc/hosts'.\");\t/* warn the user */\n\t\t\tcontinue;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* and ignore the entry */\n\t\t}\n\t\tif ((ptr2 = (char *)malloc(strlen(ptr) + 1)) == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tcontinue;\n\t\t}\n\t\tstrcpy(ptr2, ptr);\t\t\t\t\t\t\t\t/* copy the IP address into our malloc'ed memory */\n\t\tu = &units[chassis][geoslot];\n\t\tu->ip = ptr2;\t\t\t\t\t\t\t\t\t/* and remember the whole shebang */\n\t\tu->chassis = chassis;\n\t\tu->geoslot = geoslot;\n\t}\n\tfclose(fp);\n\tif (*errbuf)\treturn -1;\n\telse\t\t\treturn 0;\n}",
          "fn_code_pos": [
            [
              258,
              0
            ],
            [
              308,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "acn_parse_hosts_file",
            "parameters": {
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int open_with_IOP(unit_t  *u, int flag) {\n\tint\t\t\t\t\tsockfd;\n\tchar\t\t\t\t*ip;\n\n\tif (u->serv_addr == NULL) {\n\t\tu->serv_addr = malloc(sizeof(struct sockaddr_in));\n\n\t\t/* since we called malloc(), lets check to see if we actually got the memory\t*/\n\t\tif (u->serv_addr == NULL) {\t/* oops, we didn't get the memory requested\t*/\n\t\t\tfprintf(stderr, \"malloc() request for u->serv_addr failed, value of errno is: %d\\n\", errno);\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\tip = u->ip;\n\t/* bzero() is deprecated, replaced with memset()\t*/\n\tmemset((char *)u->serv_addr, 0, sizeof(struct sockaddr_in));\n\tu->serv_addr->sin_family\t\t= AF_INET;\n\tu->serv_addr->sin_addr.s_addr\t= inet_addr(ip);\n\tu->serv_addr->sin_port\t\t\t= htons(IOP_SNIFFER_PORT);\n\n\tif ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n\t\tfprintf(stderr, \"pcap can't open a socket for connecting to IOP at %s\\n\", ip);\n\t\treturn 0;\n\t}\n\tif (connect(sockfd, (struct sockaddr *)u->serv_addr, sizeof(struct sockaddr_in)) < 0) {\n\t\tfprintf(stderr, \"pcap can't connect to IOP at %s\\n\", ip);\n\t\treturn 0;\n\t}\n\tif (flag == LIVE)\tu->fd = sockfd;\n\telse\t\t\t\tu->find_fd = sockfd;\n\tu->first_time = 0;\n\treturn sockfd;\t\t\t/* return the non-zero file descriptor as a 'success' indicator */\n}",
          "fn_code_pos": [
            [
              310,
              0
            ],
            [
              343,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "open_with_IOP",
            "parameters": {
              "u": "unit_t",
              "flag": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void close_with_IOP(int chassis, int geoslot, int flag) {\n\tint\t\t*id;\n\n\tif (flag == LIVE)\tid = &units[chassis][geoslot].fd;\n\telse\t\t\t\tid = &units[chassis][geoslot].find_fd;\n\n\tif (*id) {\t\t\t\t\t\t\t\t\t\t/* this was the last time, so... if we are connected... */\n\t\tclose(*id);\t\t\t\t\t\t\t\t\t/* disconnect us */\n\t\t*id = 0;\t\t\t\t\t\t\t\t\t/* and forget that the descriptor exists because we are not open */\n\t}\n}",
          "fn_code_pos": [
            [
              345,
              0
            ],
            [
              355,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "close_with_IOP",
            "parameters": {
              "chassis": "int",
              "geoslot": "int",
              "flag": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void pcap_cleanup_acn(pcap_t *handle) {\n\tint\t\tchassis, geoslot;\n\tunit_t\t*u;\n\n\tif (find_unit_by_fd(handle->fd, &chassis, &geoslot, &u) == 0)\n\t\treturn;\n\tclose_with_IOP(chassis, geoslot, LIVE);\n\tif (u)\n\t\tu->first_time = 0;\n\tpcap_cleanup_live_common(handle);\n}",
          "fn_code_pos": [
            [
              357,
              0
            ],
            [
              367,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_cleanup_acn",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void send_to_fd(int fd, int len, unsigned char *str) {\n\tint\t\tnwritten;\n\tint\t\tchassis, geoslot;\n\n\twhile (len > 0) {\n\t\tif ((nwritten = write(fd, str, len)) <= 0) {\n\t\t\tfind_unit_by_fd(fd, &chassis, &geoslot, NULL);\n\t\t\tif (units[chassis][geoslot].fd == fd)\t\t\tclose_with_IOP(chassis, geoslot, LIVE);\n\t\t\telse if (units[chassis][geoslot].find_fd == fd)\tclose_with_IOP(chassis, geoslot, FIND);\n\t\t\tempty_unit(chassis, geoslot);\n\t\t\treturn;\n\t\t}\n\t\tlen -= nwritten;\n\t\tstr += nwritten;\n\t}\n}",
          "fn_code_pos": [
            [
              369,
              0
            ],
            [
              384,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "send_to_fd",
            "parameters": {
              "fd": "int",
              "len": "int",
              "str": "unsigned char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void acn_freealldevs(void) {\n\n\tpcap_if_t\t*iff, *next_iff;\n\tpcap_addr_t\t*addr, *next_addr;\n\n\tfor (iff = acn_if_list; iff != NULL; iff = next_iff) {\n\t\tnext_iff = iff->next;\n\t\tfor (addr = iff->addresses; addr != NULL; addr = next_addr) {\n\t\t\tnext_addr = addr->next;\n\t\t\tif (addr->addr)\t\t\tfree(addr->addr);\n\t\t\tif (addr->netmask)\t\tfree(addr->netmask);\n\t\t\tif (addr->broadaddr)\tfree(addr->broadaddr);\n\t\t\tif (addr->dstaddr)\t\tfree(addr->dstaddr);\n\t\t\tfree(addr);\n\t\t}\n\t\tif (iff->name)\t\t\tfree(iff->name);\n\t\tif (iff->description)\tfree(iff->description);\n\t\tfree(iff);\n\t}\n}",
          "fn_code_pos": [
            [
              386,
              0
            ],
            [
              405,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "acn_freealldevs",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void nonUnified_IOP_port_name(char *buf, size_t bufsize, const char *proto, unit_t *u) {\n\n\tpcap_snprintf(buf, bufsize, \"%s_%d_%d\", proto, u->chassis, u->geoslot);\n}",
          "fn_code_pos": [
            [
              407,
              0
            ],
            [
              410,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nonUnified_IOP_port_name",
            "parameters": {
              "buf": "char",
              "bufsize": "size_t",
              "proto": "char",
              "u": "unit_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void unified_IOP_port_name(char *buf, size_t bufsize, const char *proto, unit_t *u, int IOPportnum) {\n\tint\t\t\tportnum;\n\n\tportnum = ((u->chassis - 1) * 64) + ((u->geoslot - 1) * 8) + IOPportnum + 1;\n\tpcap_snprintf(buf, bufsize, \"%s_%d\", proto, portnum);\n}",
          "fn_code_pos": [
            [
              412,
              0
            ],
            [
              417,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unified_IOP_port_name",
            "parameters": {
              "buf": "char",
              "bufsize": "size_t",
              "proto": "char",
              "u": "unit_t",
              "IOPportnum": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static char *translate_IOP_to_pcap_name(unit_t *u, char *IOPname, bpf_u_int32 iftype) {\n\tiface_t\t\t*iface_ptr, *iface;\n\tchar\t\t*name;\n\tchar\t\tbuf[32];\n\tchar\t\t*proto;\n\tchar\t\t*port;\n\tint\t\t\tIOPportnum = 0;\n\n\tiface = malloc(sizeof(iface_t));\t\t/* get memory for a structure */\n\tif (iface == NULL) {\t/* oops, we didn't get the memory requested\t*/\n\t\tfprintf(stderr, \"Error...couldn't allocate memory for interface structure...value of errno is: %d\\n\", errno);\n\t\treturn NULL;\n\t}\n\tmemset((char *)iface, 0, sizeof(iface_t));\t/* bzero is deprecated(), replaced with memset() */\n\n\tiface->iftype = iftype;\t\t\t\t\t/* remember the interface type of this interface */\n\n\tname = malloc(strlen(IOPname) + 1);\t\t/* get memory for the IOP's name */\n        if (name == NULL) {    /* oops, we didn't get the memory requested     */\n                fprintf(stderr, \"Error...couldn't allocate memory for IOPname...value of errno is: %d\\n\", errno);\n                return NULL;\n        }\n\n\tstrcpy(name, IOPname);\t\t\t\t\t/* and copy it in */\n\tiface->IOPname = name;\t\t\t\t\t/* and stick it into the structure */\n\n\tif (strncmp(IOPname, \"lo\", 2) == 0) {\n\t\tIOPportnum = atoi(&IOPname[2]);\n\t\tswitch (iftype) {\n\t\t\tcase DLT_EN10MB:\n\t\t\t\tnonUnified_IOP_port_name(buf, sizeof buf, \"lo\", u);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tunified_IOP_port_name(buf, sizeof buf, \"???\", u, IOPportnum);\n\t\t\t\tbreak;\n\t\t}\n\t} else if (strncmp(IOPname, \"eth\", 3) == 0) {\n\t\tIOPportnum = atoi(&IOPname[3]);\n\t\tswitch (iftype) {\n\t\t\tcase DLT_EN10MB:\n\t\t\t\tnonUnified_IOP_port_name(buf, sizeof buf, \"eth\", u);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tunified_IOP_port_name(buf, sizeof buf, \"???\", u, IOPportnum);\n\t\t\t\tbreak;\n\t\t}\n\t} else if (strncmp(IOPname, \"wan\", 3) == 0) {\n\t\tIOPportnum = atoi(&IOPname[3]);\n\t\tswitch (iftype) {\n\t\t\tcase DLT_SITA:\n\t\t\t\tunified_IOP_port_name(buf, sizeof buf, \"wan\", u, IOPportnum);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tunified_IOP_port_name(buf, sizeof buf, \"???\", u, IOPportnum);\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tfprintf(stderr, \"Error... invalid IOP name %s\\n\", IOPname);\n\t\treturn NULL;\n\t}\n\n\tname = malloc(strlen(buf) + 1);\t\t\t/* get memory for that name */\n        if (name == NULL) {    /* oops, we didn't get the memory requested     */\n                fprintf(stderr, \"Error...couldn't allocate memory for IOP port name...value of errno is: %d\\n\", errno);\n                return NULL;\n        }\n\n\tstrcpy(name, buf);\t\t\t\t\t\t/* and copy it in */\n\tiface->name = name;\t\t\t\t\t\t/* and stick it into the structure */\n\n\tif (u->iface == 0) {\t\t\t\t\t/* if this is the first name */\n\t\tu->iface = iface;\t\t\t\t\t/* stick this entry at the head of the list */\n\t} else {\n\t\tiface_ptr = u->iface;\n\t\twhile (iface_ptr->next) {\t\t\t/* othewise scan the list */\n\t\t\tiface_ptr = iface_ptr->next;\t/* till we're at the last entry */\n\t\t}\n\t\tiface_ptr->next = iface;\t\t\t/* then tack this entry on the end of the list */\n\t}\n\treturn iface->name;\n}",
          "fn_code_pos": [
            [
              419,
              0
            ],
            [
              499,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "translate_IOP_to_pcap_name",
            "parameters": {
              "u": "unit_t",
              "IOPname": "char",
              "iftype": "bpf_u_int32"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static int if_sort(char *s1, char *s2) {\n\tchar\t*s1_p2, *s2_p2;\n\tchar\tstr1[MAX_LINE_SIZE], str2[MAX_LINE_SIZE];\n\tint\t\ts1_p1_len, s2_p1_len;\n\tint\t\tretval;\n\n\tif ((s1_p2 = strchr(s1, '_'))) {\t/* if an underscore is found... */\n\t\ts1_p1_len = s1_p2 - s1;\t\t\t/* the prefix length is the difference in pointers */\n\t\ts1_p2++;\t\t\t\t\t\t/* the suffix actually starts _after_ the underscore */\n\t} else {\t\t\t\t\t\t\t/* otherwise... */\n\t\ts1_p1_len = strlen(s1);\t\t\t/* the prefix length is the length of the string itself */\n\t\ts1_p2 = 0;\t\t\t\t\t\t/* and there is no suffix */\n\t}\n\tif ((s2_p2 = strchr(s2, '_'))) {\t/* now do the same for the second string */\n\t\ts2_p1_len = s2_p2 - s2;\n\t\ts2_p2++;\n\t} else {\n\t\ts2_p1_len = strlen(s2);\n\t\ts2_p2 = 0;\n\t}\n\tstrncpy(str1, s1, (s1_p1_len > sizeof(str1)) ? s1_p1_len : sizeof(str1));   *(str1 + s1_p1_len) = 0;\n\tstrncpy(str2, s2, (s2_p1_len > sizeof(str2)) ? s2_p1_len : sizeof(str2));   *(str2 + s2_p1_len) = 0;\n\tretval = strcmp(str1, str2);\n\tif (retval != 0) return retval;\t\t/* if they are not identical, then we can quit now and return the indication */\n\treturn strcmp(s1_p2, s2_p2);\t\t/* otherwise we return the result of comparing the 2nd half of the string */\n}",
          "fn_code_pos": [
            [
              501,
              0
            ],
            [
              526,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "if_sort",
            "parameters": {
              "s1": "char",
              "s2": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void sort_if_table(void) {\n\tpcap_if_t\t*p1, *p2, *prev, *temp;\n\tint\t\t\thas_swapped;\n\n\tif (!acn_if_list) return;\t\t\t\t/* nothing to do if the list is empty */\n\n\twhile (1) {\n\t\tp1 = acn_if_list;\t\t\t\t\t/* start at the head of the list */\n\t\tprev = 0;\n\t\thas_swapped = 0;\n\t\twhile ((p2 = p1->next)) {\n\t\t\tif (if_sort(p1->name, p2->name) > 0) {\n\t\t\t\tif (prev) {\t\t\t\t\t/* we are swapping things that are _not_ at the head of the list */\n\t\t\t\t\ttemp = p2->next;\n\t\t\t\t\tprev->next = p2;\n\t\t\t\t\tp2->next = p1;\n\t\t\t\t\tp1->next = temp;\n\t\t\t\t} else {\t\t\t\t\t/* special treatment if we are swapping with the head of the list */\n\t\t\t\t\ttemp = p2->next;\n\t\t\t\t\tacn_if_list= p2;\n\t\t\t\t\tp2->next = p1;\n\t\t\t\t\tp1->next = temp;\n\t\t\t\t}\n\t\t\t\tp1 = p2;\n\t\t\t\tprev = p1;\n\t\t\t\thas_swapped = 1;\n\t\t\t}\n\t\t\tprev = p1;\n\t\t\tp1 = p1->next;\n\t\t}\n\t\tif (has_swapped == 0)\n\t\t\treturn;\n\t}\n\treturn;\n}",
          "fn_code_pos": [
            [
              528,
              0
            ],
            [
              562,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sort_if_table",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int process_client_data (char *errbuf) {\t\t\t\t\t\t\t\t/* returns: -1 = error, 0 = OK */\n\tint\t\t\t\t\tchassis, geoslot;\n\tunit_t\t\t\t\t*u;\n\tpcap_if_t\t\t\t*iff, *prev_iff;\n\tpcap_addr_t\t\t\t*addr, *prev_addr;\n\tchar\t\t\t\t*ptr;\n\tint\t\t\t\t\taddress_count;\n\tstruct sockaddr_in\t*s;\n\tchar\t\t\t\t*newname;\n\tbpf_u_int32\t\t\t\tinterfaceType;\n\tunsigned char\t\tflags;\n\tvoid *bigger_buffer;\n\n\tprev_iff = 0;\n\tfor (chassis = 0; chassis <= MAX_CHASSIS; chassis++) {\n\t\tfor (geoslot = 0; geoslot <= MAX_GEOSLOT; geoslot++) {\t\t\t\t/* now loop over all the devices */\n\t\t\tu = &units[chassis][geoslot];\n\t\t\tempty_unit_iface(u);\n\t\t\tptr = u->imsg;\t\t\t\t\t\t\t\t\t\t\t\t\t/* point to the start of the msg for this IOP */\n\t\t\twhile (ptr < (u->imsg + u->len)) {\n\t\t\t\tif ((iff = malloc(sizeof(pcap_if_t))) == NULL) {\n\t\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tmemset((char *)iff, 0, sizeof(pcap_if_t)); /* bzero() is deprecated, replaced with memset() */\n\t\t\t\tif (acn_if_list == 0)\tacn_if_list = iff;\t\t\t\t\t/* remember the head of the list */\n\t\t\t\tif (prev_iff)\t\t\tprev_iff->next = iff;\t\t\t\t/* insert a forward link */\n\n\t\t\t\tif (*ptr) {\t\t\t\t\t\t\t\t\t\t\t\t\t/* if there is a count for the name */\n\t\t\t\t\tif ((iff->name = malloc(*ptr + 1)) == NULL) {\t\t\t/* get that amount of space */\n\t\t\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t\t    \"malloc\");\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(iff->name, (ptr + 1), *ptr);\t\t\t\t\t\t/* copy the name into the malloc'ed space */\n\t\t\t\t\t*(iff->name + *ptr) = 0;\t\t\t\t\t\t\t\t/* and null terminate the string */\n\t\t\t\t\tptr += *ptr;\t\t\t\t\t\t\t\t\t\t\t/* now move the pointer forwards by the length of the count plus the length of the string */\n\t\t\t\t}\n\t\t\t\tptr++;\n\n\t\t\t\tif (*ptr) {\t\t\t\t\t\t\t\t\t\t\t\t\t/* if there is a count for the description */\n\t\t\t\t\tif ((iff->description = malloc(*ptr + 1)) == NULL) {\t/* get that amount of space */\n\t\t\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t\t    \"malloc\");\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(iff->description, (ptr + 1), *ptr);\t\t\t\t/* copy the name into the malloc'ed space */\n\t\t\t\t\t*(iff->description + *ptr) = 0;\t\t\t\t\t\t\t/* and null terminate the string */\n\t\t\t\t\tptr += *ptr;\t\t\t\t\t\t\t\t\t\t\t/* now move the pointer forwards by the length of the count plus the length of the string */\n\t\t\t\t}\n\t\t\t\tptr++;\n\n\t\t\t\tinterfaceType = ntohl(*(bpf_u_int32 *)ptr);\n\t\t\t\tptr += 4;\t\t\t\t\t\t\t\t\t\t\t\t\t/* skip over the interface type */\n\n\t\t\t\tflags = *ptr++;\n\t\t\t\tif (flags) iff->flags = PCAP_IF_LOOPBACK;\t\t\t\t\t/* if this is a loopback style interface, lets mark it as such */\n\n\t\t\t\taddress_count = *ptr++;\n\n\t\t\t\tprev_addr = 0;\n\t\t\t\twhile (address_count--) {\n\t\t\t\t\tif ((addr = malloc(sizeof(pcap_addr_t))) == NULL) {\n\t\t\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t\t    \"malloc\");\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n \t\t\t\t\tmemset((char *)addr, 0, sizeof(pcap_addr_t)); /* bzero() is deprecated, replaced with memset() */\n\t\t\t\t\tif (iff->addresses == 0) iff->addresses = addr;\n\t\t\t\t\tif (prev_addr) prev_addr->next = addr;\t\t\t\t\t\t\t/* insert a forward link */\n\t\t\t\t\tif (*ptr) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* if there is a count for the address */\n\t\t\t\t\t\tif ((s = malloc(sizeof(struct sockaddr_in))) == NULL) {\t\t/* get that amount of space */\n\t\t\t\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t\t\t    PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\t\t    errno, \"malloc\");\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemset((char *)s, 0, sizeof(struct sockaddr_in)); /* bzero() is deprecated, replaced with memset() */\n\t\t\t\t\t\taddr->addr = (struct sockaddr *)s;\n\t\t\t\t\t\ts->sin_family\t\t= AF_INET;\n\t\t\t\t\t\ts->sin_addr.s_addr\t= *(bpf_u_int32 *)(ptr + 1);\t\t\t/* copy the address in */\n\t\t\t\t\t\tptr += *ptr;\t\t\t\t\t\t\t\t\t\t/* now move the pointer forwards according to the specified length of the address */\n\t\t\t\t\t}\n\t\t\t\t\tptr++;\t\t\t\t\t\t\t\t\t\t\t\t\t/* then forwards one more for the 'length of the address' field */\n\t\t\t\t\tif (*ptr) {\t\t\t\t\t\t\t\t\t\t\t\t/* process any netmask */\n\t\t\t\t\t\tif ((s = malloc(sizeof(struct sockaddr_in))) == NULL) {\n\t\t\t\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t\t\t    PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\t\t    errno, \"malloc\");\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* bzero() is deprecated, replaced with memset() */\n\t\t\t\t\t\tmemset((char *)s, 0, sizeof(struct sockaddr_in));\n\n\t\t\t\t\t\taddr->netmask = (struct sockaddr *)s;\n\t\t\t\t\t\ts->sin_family\t\t= AF_INET;\n\t\t\t\t\t\ts->sin_addr.s_addr\t= *(bpf_u_int32*)(ptr + 1);\n\t\t\t\t\t\tptr += *ptr;\n\t\t\t\t\t}\n\t\t\t\t\tptr++;\n\t\t\t\t\tif (*ptr) {\t\t\t\t\t\t\t\t\t\t\t\t/* process any broadcast address */\n\t\t\t\t\t\tif ((s = malloc(sizeof(struct sockaddr_in))) == NULL) {\n\t\t\t\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t\t\t    PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\t\t    errno, \"malloc\");\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* bzero() is deprecated, replaced with memset() */\n\t\t\t\t\t\tmemset((char *)s, 0, sizeof(struct sockaddr_in));\n\n\t\t\t\t\t\taddr->broadaddr = (struct sockaddr *)s;\n\t\t\t\t\t\ts->sin_family\t\t= AF_INET;\n\t\t\t\t\t\ts->sin_addr.s_addr\t= *(bpf_u_int32*)(ptr + 1);\n\t\t\t\t\t\tptr += *ptr;\n\t\t\t\t\t}\n\t\t\t\t\tptr++;\n\t\t\t\t\tif (*ptr) {\t\t\t\t\t\t\t\t\t\t\t\t/* process any destination address */\n\t\t\t\t\t\tif ((s = malloc(sizeof(struct sockaddr_in))) == NULL) {\n\t\t\t\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t\t\t    PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\t\t    errno, \"malloc\");\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* bzero() is deprecated, replaced with memset() */\n\t\t\t\t\t\tmemset((char *)s, 0, sizeof(struct sockaddr_in));\n\n\t\t\t\t\t\taddr->dstaddr = (struct sockaddr *)s;\n\t\t\t\t\t\ts->sin_family\t\t= AF_INET;\n\t\t\t\t\t\ts->sin_addr.s_addr\t= *(bpf_u_int32*)(ptr + 1);\n\t\t\t\t\t\tptr += *ptr;\n\t\t\t\t\t}\n\t\t\t\t\tptr++;\n\t\t\t\t\tprev_addr = addr;\n\t\t\t\t}\n\t\t\t\tprev_iff = iff;\n\n\t\t\t\tnewname = translate_IOP_to_pcap_name(u, iff->name, interfaceType);\t\t/* add a translation entry and get a point to the mangled name */\n\t\t\t\tbigger_buffer = realloc(iff->name, strlen(newname) + 1));\n\t\t\t\tif (bigger_buffer == NULL) {\t/* we now re-write the name stored in the interface list */\n\t\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"realloc\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tiff->name = bigger_buffer;\n\t\t\t\tstrcpy(iff->name, newname);\t\t\t\t\t\t\t\t\t\t\t\t/* to this new name */\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              564,
              0
            ],
            [
              717,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_client_data",
            "parameters": {
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int read_client_data (int fd) {\n\tunsigned char\tbuf[256];\n\tint\t\t\t\tchassis, geoslot;\n\tunit_t\t\t\t*u;\n\tint\t\t\t\tlen;\n\n\tfind_unit_by_fd(fd, &chassis, &geoslot, &u);\n\n\tif ((len = recv(fd, buf, sizeof(buf), 0)) <= 0)\treturn 0;\t/* read in whatever data was sent to us */\n\n\tif ((u->imsg = realloc(u->imsg, (u->len + len))) == NULL)\t/* extend the buffer for the new data */\n\t\treturn 0;\n\tmemcpy((u->imsg + u->len), buf, len);\t\t\t\t\t\t/* append the new data */\n\tu->len += len;\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              719,
              0
            ],
            [
              734,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_client_data",
            "parameters": {
              "fd": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void wait_for_all_answers(void) {\n\tint\t\tretval;\n\tstruct\ttimeval tv;\n\tint\t\tfd;\n\tint\t\tchassis, geoslot;\n\n\ttv.tv_sec = 2;\n\ttv.tv_usec = 0;\n\n\twhile (1) {\n\t\tint flag = 0;\n\t\tfd_set working_set;\n\n\t\tfor (fd = 0; fd <= max_fs; fd++) {\t\t\t\t\t\t\t\t/* scan the list of descriptors we may be listening to */\n\t\t\tif (FD_ISSET(fd, &readfds)) flag = 1;\t\t\t\t\t\t/* and see if there are any still set */\n\t\t}\n\t\tif (flag == 0) return;\t\t\t\t\t\t\t\t\t\t\t/* we are done, when they are all gone */\n\n\t\tmemcpy(&working_set, &readfds, sizeof(readfds));\t\t\t\t/* otherwise, we still have to listen for more stuff, till we timeout */\n\t\tretval = select(max_fs + 1, &working_set, NULL, NULL, &tv);\n\t\tif (retval == -1) {\t\t\t\t\t\t\t\t\t\t\t\t/* an error occured !!!!! */\n\t\t\treturn;\n\t\t} else if (retval == 0) {\t\t\t\t\t\t\t\t\t\t/* timeout occured, so process what we've got sofar and return */\n\t\t\tprintf(\"timeout\\n\");\n\t\t\treturn;\n\t\t} else {\n\t\t\tfor (fd = 0; fd <= max_fs; fd++) {\t\t\t\t\t\t\t/* scan the list of things to do, and do them */\n\t\t\t\tif (FD_ISSET(fd, &working_set)) {\n\t\t\t\t\tif (read_client_data(fd) == 0) {\t\t\t\t\t/* if the socket has closed */\n\t\t\t\t\t\tFD_CLR(fd, &readfds);\t\t\t\t\t\t\t/* and descriptors we listen to for errors */\n\t\t\t\t\t\tfind_unit_by_fd(fd, &chassis, &geoslot, NULL);\n\t\t\t\t\t\tclose_with_IOP(chassis, geoslot, FIND);\t\t\t/* and close out connection to him */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              736,
              0
            ],
            [
              773,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "wait_for_all_answers",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static char *get_error_response(int fd, char *errbuf) {\t\t/* return a pointer on error, NULL on no error */\n\tchar\tbyte;\n\tint\t\tlen = 0;\n\n\twhile (1) {\n\t\trecv(fd, &byte, 1, 0);\t\t\t\t\t\t\t/* read another byte in */\n\t\tif (errbuf && (len++ < PCAP_ERRBUF_SIZE)) {\t\t/* and if there is still room in the buffer */\n\t\t\t*errbuf++ = byte;\t\t\t\t\t\t\t/* stick it in */\n\t\t\t*errbuf = '\\0';\t\t\t\t\t\t\t\t/* ensure the string is null terminated just in case we might exceed the buffer's size */\n\t\t}\n\t\tif (byte == '\\0') {\n\t\t\tif (len > 1)\t{ return errbuf;\t}\n\t\t\telse\t\t\t{ return NULL;\t\t}\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              775,
              0
            ],
            [
              790,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_error_response",
            "parameters": {
              "fd": "int",
              "errbuf": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int acn_findalldevs(char *errbuf) {\t\t\t\t\t\t\t\t/* returns: -1 = error, 0 = OK */\n\tint\t\tchassis, geoslot;\n\tunit_t\t*u;\n\n\tFD_ZERO(&readfds);\n\tmax_fs = 0;\n\tfor (chassis = 0; chassis <= MAX_CHASSIS; chassis++) {\n\t\tfor (geoslot = 0; geoslot <= MAX_GEOSLOT; geoslot++) {\n\t\t\tu = &units[chassis][geoslot];\n\t\t\tif (u->ip && (open_with_IOP(u, FIND))) {\t\t\t/* connect to the remote IOP */\n\t\t\t\tsend_to_fd(u->find_fd, 1, (unsigned char *)\"\\0\");\n\t\t\t\tif (get_error_response(u->find_fd, errbuf))\n\t\t\t\t\tclose_with_IOP(chassis, geoslot, FIND);\n\t\t\t\telse {\n\t\t\t\t\tif (u->find_fd > max_fs)\n\t\t\t\t\t\tmax_fs = u->find_fd;\t\t\t\t\t\t\t\t/* remember the highest number currently in use */\n\t\t\t\t\tFD_SET(u->find_fd, &readfds);\t\t\t\t\t\t/* we are going to want to read this guy's response to */\n\t\t\t\t\tu->len = 0;\n\t\t\t\t\tsend_to_fd(u->find_fd, 1, (unsigned char *)\"Q\");\t\t/* this interface query request */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twait_for_all_answers();\n\tif (process_client_data(errbuf))\n\t\treturn -1;\n\tsort_if_table();\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              792,
              0
            ],
            [
              820,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "acn_findalldevs",
            "parameters": {
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_stats_acn(pcap_t *handle, struct pcap_stat *ps) {\n\tunsigned char\tbuf[12];\n\n\tsend_to_fd(handle->fd, 1, (unsigned char *)\"S\");\t\t\t\t\t\t/* send the get_stats command to the IOP */\n\n\tif (read_client_nbytes(handle->fd, sizeof(buf), buf) == -1) return -1;\t/* try reading the required bytes */\n\n\tps->ps_recv\t\t= ntohl(*(uint32_t *)&buf[0]);\t\t\t\t\t\t\t/* break the buffer into its three 32 bit components */\n\tps->ps_drop\t\t= ntohl(*(uint32_t *)&buf[4]);\n\tps->ps_ifdrop\t= ntohl(*(uint32_t *)&buf[8]);\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              822,
              0
            ],
            [
              834,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_acn",
            "parameters": {
              "handle": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int acn_open_live(const char *name, char *errbuf, int *linktype) {\t\t/* returns 0 on error, else returns the file descriptor */\n\tint\t\t\tchassis, geoslot;\n\tunit_t\t\t*u;\n\tiface_t\t\t*p;\n\tpcap_if_list_t\tdevlist;\n\n\tpcap_platform_finddevs(&devlist, errbuf);\n\tfor (chassis = 0; chassis <= MAX_CHASSIS; chassis++) {\t\t\t\t\t\t\t\t\t\t/* scan the table... */\n\t\tfor (geoslot = 0; geoslot <= MAX_GEOSLOT; geoslot++) {\n\t\t\tu = &units[chassis][geoslot];\n\t\t\tif (u->ip != NULL) {\n\t\t\t\tp = u->iface;\n\t\t\t\twhile (p) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* and all interfaces... */\n\t\t\t\t\tif (p->IOPname && p->name && (strcmp(p->name, name) == 0)) {\t\t\t\t/* and if we found the interface we want... */\n\t\t\t\t\t\t*linktype = p->iftype;\n\t\t\t\t\t\topen_with_IOP(u, LIVE);\t\t\t\t\t\t\t\t\t\t\t\t\t/* start a connection with that IOP */\n\t\t\t\t\t\tsend_to_fd(u->fd, strlen(p->IOPname)+1, (unsigned char *)p->IOPname);\t/* send the IOP's interface name, and a terminating null */\n\t\t\t\t\t\tif (get_error_response(u->fd, errbuf)) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn u->fd;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* and return that open descriptor */\n\t\t\t\t\t}\n\t\t\t\t\tp = p->next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* if the interface wasn't found, return an error */\n}",
          "fn_code_pos": [
            [
              836,
              0
            ],
            [
              864,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "acn_open_live",
            "parameters": {
              "name": "char",
              "errbuf": "char",
              "linktype": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void acn_start_monitor(int fd, int snaplen, int timeout, int promiscuous, int direction) {\n\tunsigned char\tbuf[8];\n\tunit_t\t\t\t*u;\n\n\t//printf(\"acn_start_monitor()\\n\");\t\t\t\t// fulko\n\tfind_unit_by_fd(fd, NULL, NULL, &u);\n\tif (u->first_time == 0) {\n\t\tbuf[0]\t\t\t\t\t= 'M';\n\t\t*(uint32_t *)&buf[1]\t= htonl(snaplen);\n\t\tbuf[5]\t\t\t\t\t= timeout;\n\t\tbuf[6]\t\t\t\t\t= promiscuous;\n\t\tbuf[7]\t\t\t\t\t= direction;\n\t//printf(\"acn_start_monitor() first time\\n\");\t\t\t\t// fulko\n\t\tsend_to_fd(fd, 8, buf);\t\t\t\t\t\t\t\t/* send the start monitor command with its parameters to the IOP */\n\t\tu->first_time = 1;\n\t}\n\t//printf(\"acn_start_monitor() complete\\n\");\t\t\t\t// fulko\n}",
          "fn_code_pos": [
            [
              866,
              0
            ],
            [
              883,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "acn_start_monitor",
            "parameters": {
              "fd": "int",
              "snaplen": "int",
              "timeout": "int",
              "promiscuous": "int",
              "direction": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int pcap_inject_acn(pcap_t *p, const void *buf _U_, int size _U_) {\n\tpcap_strlcpy(p->errbuf, \"Sending packets isn't supported on ACN adapters\",\n\t    PCAP_ERRBUF_SIZE);\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              885,
              0
            ],
            [
              889,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject_acn",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_setfilter_acn(pcap_t *handle, struct bpf_program *bpf) {\n\tint\t\t\t\tfd = handle->fd;\n\tint\t\t\t\tcount;\n\tstruct bpf_insn\t*p;\n\tuint16_t\t\tshortInt;\n\tuint32_t\t\tlongInt;\n\n\tsend_to_fd(fd, 1, (unsigned char *)\"F\");\t\t\t/* BPF filter follows command */\n\tcount = bpf->bf_len;\n\tlongInt = htonl(count);\n\tsend_to_fd(fd, 4, (unsigned char *)&longInt);\t\t/* send the instruction sequence count */\n\tp = bpf->bf_insns;\n\twhile (count--) {\t\t\t\t\t\t\t\t\t/* followed by the list of instructions */\n\t\tshortInt = htons(p->code);\n\t\tlongInt = htonl(p->k);\n\t\tsend_to_fd(fd, 2, (unsigned char *)&shortInt);\n\t\tsend_to_fd(fd, 1, (unsigned char *)&p->jt);\n\t\tsend_to_fd(fd, 1, (unsigned char *)&p->jf);\n\t\tsend_to_fd(fd, 4, (unsigned char *)&longInt);\n\t\tp++;\n\t}\n\tif (get_error_response(fd, NULL))\n\t\treturn -1;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              891,
              0
            ],
            [
              915,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_acn",
            "parameters": {
              "handle": "pcap_t",
              "bpf": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_setdirection_acn(pcap_t *handle, pcap_direction_t d) {\n\tpcap_snprintf(handle->errbuf, sizeof(handle->errbuf),\n\t    \"Setting direction is not supported on ACN adapters\");\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              917,
              0
            ],
            [
              921,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setdirection_acn",
            "parameters": {
              "handle": "pcap_t",
              "d": "pcap_direction_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int acn_read_n_bytes_with_timeout(pcap_t *handle, int count) {\n\tstruct\t\ttimeval tv;\n\tint\t\t\tretval, fd;\n\tfd_set\t\tr_fds;\n\tfd_set\t\tw_fds;\n\tu_char\t\t*bp;\n\tint\t\t\tlen = 0;\n\tint\t\t\toffset = 0;\n\n\ttv.tv_sec = 5;\n\ttv.tv_usec = 0;\n\n\tfd = handle->fd;\n\tFD_ZERO(&r_fds);\n\tFD_SET(fd, &r_fds);\n\tmemcpy(&w_fds, &r_fds, sizeof(r_fds));\n\tbp = handle->bp;\n\twhile (count) {\n\t\tretval = select(fd + 1, &w_fds, NULL, NULL, &tv);\n\t\tif (retval == -1) {\t\t\t\t\t\t\t\t\t\t\t/* an error occured !!!!! */\n//\t\t\tfprintf(stderr, \"error during packet data read\\n\");\n\t\t\treturn -1;\t\t\t\t\t\t\t\t\t\t\t\t/* but we need to return a good indication to prevent unneccessary popups */\n\t\t} else if (retval == 0) {\t\t\t\t\t\t\t\t\t/* timeout occured, so process what we've got sofar and return */\n//\t\t\tfprintf(stderr, \"timeout during packet data read\\n\");\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tif ((len = recv(fd, (bp + offset), count, 0)) <= 0) {\n//\t\t\t\tfprintf(stderr, \"premature exit during packet data rx\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcount -= len;\n\t\t\toffset += len;\n\t\t}\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              923,
              0
            ],
            [
              958,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "acn_read_n_bytes_with_timeout",
            "parameters": {
              "handle": "pcap_t",
              "count": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_read_acn(pcap_t *handle, int max_packets, pcap_handler callback, u_char *user) {\n\t#define HEADER_SIZE (4 * 4)\n\tunsigned char\t\tpacket_header[HEADER_SIZE];\n\tstruct pcap_pkthdr\tpcap_header;\n\n\t//printf(\"pcap_read_acn()\\n\");\t\t\t// fulko\n\tacn_start_monitor(handle->fd, handle->snapshot, handle->opt.timeout, handle->opt.promisc, handle->direction);\t/* maybe tell him to start monitoring */\n\t//printf(\"pcap_read_acn() after start monitor\\n\");\t\t\t// fulko\n\n\thandle->bp = packet_header;\n\tif (acn_read_n_bytes_with_timeout(handle, HEADER_SIZE) == -1) return 0;\t\t\t/* try to read a packet header in so we can get the sizeof the packet data */\n\n\tpcap_header.ts.tv_sec\t= ntohl(*(uint32_t *)&packet_header[0]);\t\t\t\t/* tv_sec */\n\tpcap_header.ts.tv_usec\t= ntohl(*(uint32_t *)&packet_header[4]);\t\t\t\t/* tv_usec */\n\tpcap_header.caplen\t\t= ntohl(*(uint32_t *)&packet_header[8]);\t\t\t\t/* caplen */\n\tpcap_header.len\t\t\t= ntohl(*(uint32_t *)&packet_header[12]);\t\t\t\t/* len */\n\n\thandle->bp = (u_char *)handle->buffer + handle->offset;\t\t\t\t\t\t\t\t\t/* start off the receive pointer at the right spot */\n\tif (acn_read_n_bytes_with_timeout(handle, pcap_header.caplen) == -1) return 0;\t/* then try to read in the rest of the data */\n\n\tcallback(user, &pcap_header, handle->bp);\t\t\t\t\t\t\t\t\t\t/* call the user supplied callback function */\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              960,
              0
            ],
            [
              982,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_acn",
            "parameters": {
              "handle": "pcap_t",
              "max_packets": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_activate_sita(pcap_t *handle) {\n\tint\t\tfd;\n\n\tif (handle->opt.rfmon) {\n\t\t/*\n\t\t * No monitor mode on SITA devices (they're not Wi-Fi\n\t\t * devices).\n\t\t */\n\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t}\n\n\t/* Initialize some components of the pcap structure. */\n\n\thandle->inject_op = pcap_inject_acn;\n\thandle->setfilter_op = pcap_setfilter_acn;\n\thandle->setdirection_op = pcap_setdirection_acn;\n\thandle->set_datalink_op = NULL;\t/* can't change data link type */\n\thandle->getnonblock_op = pcap_getnonblock_fd;\n\thandle->setnonblock_op = pcap_setnonblock_fd;\n\thandle->cleanup_op = pcap_cleanup_acn;\n\thandle->read_op = pcap_read_acn;\n\thandle->stats_op = pcap_stats_acn;\n\n\tfd = acn_open_live(handle->opt.device, handle->errbuf,\n\t    &handle->linktype);\n\tif (fd == -1)\n\t\treturn PCAP_ERROR;\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)\n\t\thandle->snapshot = MAXIMUM_SNAPLEN;\n\n\thandle->fd = fd;\n\thandle->bufsize = handle->snapshot;\n\n\t/* Allocate the buffer */\n\n\thandle->buffer\t = malloc(handle->bufsize + handle->offset);\n\tif (!handle->buffer) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tpcap_cleanup_acn(handle);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/*\n\t * \"handle->fd\" is a socket, so \"select()\" and \"poll()\"\n\t * should work on it.\n\t */\n\thandle->selectable_fd = handle->fd;\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              984,
              0
            ],
            [
              1043,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_activate_sita",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *pcap_create_interface(const char *device _U_, char *ebuf) {\n\tpcap_t *p;\n\n\tp = pcap_create_common(ebuf, 0);\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = pcap_activate_sita;\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              1045,
              0
            ],
            [
              1054,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "int pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf) {\n\n\t//printf(\"pcap_findalldevs()\\n\");\t\t\t\t// fulko\n\n\t*alldevsp = 0;\t\t\t\t\t\t\t\t\t\t\t\t/* initialize the returned variables before we do anything */\n\tstrcpy(errbuf, \"\");\n\tif (acn_parse_hosts_file(errbuf))\t\t\t\t\t\t\t/* scan the hosts file for potential IOPs */\n\t\t{\n\t\t//printf(\"pcap_findalldevs() returning BAD after parsehosts\\n\");\t\t\t\t// fulko\n\t\treturn -1;\n\t\t}\n\t//printf(\"pcap_findalldevs() got hostlist now finding devs\\n\");\t\t\t\t// fulko\n\tif (acn_findalldevs(errbuf))\t\t\t\t\t\t\t\t/* then ask the IOPs for their monitorable devices */\n\t\t{\n\t\t//printf(\"pcap_findalldevs() returning BAD after findalldevs\\n\");\t\t\t\t// fulko\n\t\treturn -1;\n\t\t}\n\tdevlistp->beginning = acn_if_list;\n\tacn_if_list = 0;\t\t\t\t\t\t\t\t\t\t\t/* then forget our list head, because someone will call pcap_freealldevs() to empty the malloc'ed stuff */\n\t//printf(\"pcap_findalldevs() returning ZERO OK\\n\");\t\t\t\t// fulko\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1056,
              0
            ],
            [
              1077,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_platform_finddevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n\treturn PCAP_VERSION_STRING \" (SITA-only)\";\n}",
          "fn_code_pos": [
            [
              1082,
              0
            ],
            [
              1086,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "find_nth_interface_name(int n)",
          "fn_dec_pos": [
            [
              235,
              13
            ],
            [
              235,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_nth_interface_name",
            "parameters": {
              "n": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "translate_IOP_to_pcap_name(unit_t *u, char *IOPname, bpf_u_int32 iftype)",
          "fn_dec_pos": [
            [
              419,
              13
            ],
            [
              419,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "translate_IOP_to_pcap_name",
            "parameters": {
              "u": "unit_t",
              "IOPname": "char",
              "iftype": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "get_error_response(int fd, char *errbuf)",
          "fn_dec_pos": [
            [
              775,
              13
            ],
            [
              775,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_error_response",
            "parameters": {
              "fd": "int",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_create_interface(const char *device _U_, char *ebuf)",
          "fn_dec_pos": [
            [
              1045,
              8
            ],
            [
              1045,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              1083,
              0
            ],
            [
              1083,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct iface {\n\tstruct iface\t*next;\t\t/* a pointer to the next interface */\n\tchar\t\t*name;\t\t/* this interface's name */\n\tchar\t\t*IOPname;\t/* this interface's name on an IOP */\n\tuint32_t\tiftype;\t\t/* the type of interface (DLT values) */\n} iface_t;",
          {
            "*next": "struct iface",
            "*name": "char",
            "*IOPname": "char",
            "iftype": "uint32_t"
          },
          "iface_t",
          [
            54,
            0
          ],
          [
            59,
            10
          ]
        ],
        [
          "typedef struct unit {\n\tchar\t\t\t*ip;\t\t/* this unit's IP address (as extracted from /etc/hosts) */\n\tint\t\t\tfd;\t\t/* the connection to this unit (if it exists) */\n\tint\t\t\tfind_fd;\t/* a big kludge to avoid my programming limitations since I could have this unit open for findalldevs purposes */\n\tint\t\t\tfirst_time;\t/* 0 = just opened via acn_open_live(),  ie. the first time, NZ = nth time */\n\tstruct sockaddr_in\t*serv_addr;\t/* the address control block for comms to this unit */\n\tint\t\t\tchassis;\n\tint\t\t\tgeoslot;\n\tiface_t\t\t\t*iface;\t\t/* a pointer to a linked list of interface structures */\n\tchar\t\t\t*imsg;\t\t/* a pointer to an inbound message */\n\tint\t\t\tlen;\t\t/* the current size of the inbound message */\n} unit_t;",
          {
            "*ip": "char",
            "fd": "int",
            "find_fd": "int",
            "first_time": "int",
            "*serv_addr": "struct sockaddr_in",
            "chassis": "int",
            "geoslot": "int",
            "*iface": "iface_t",
            "*imsg": "char",
            "len": "int"
          },
          "unit_t",
          [
            61,
            0
          ],
          [
            72,
            9
          ]
        ],
        [
          "typedef struct iface {\n\tstruct iface\t*next;\t\t/* a pointer to the next interface */\n\tchar\t\t*name;\t\t/* this interface's name */\n\tchar\t\t*IOPname;\t/* this interface's name on an IOP */\n\tuint32_t\tiftype;\t\t/* the type of interface (DLT values) */\n} iface_t;",
          {
            "*next": "struct iface",
            "*name": "char",
            "*IOPname": "char",
            "iftype": "uint32_t"
          },
          "iface_t",
          [
            54,
            0
          ],
          [
            59,
            10
          ]
        ],
        [
          "struct iface",
          {},
          "",
          [
            55,
            1
          ],
          [
            55,
            13
          ]
        ],
        [
          "typedef struct unit {\n\tchar\t\t\t*ip;\t\t/* this unit's IP address (as extracted from /etc/hosts) */\n\tint\t\t\tfd;\t\t/* the connection to this unit (if it exists) */\n\tint\t\t\tfind_fd;\t/* a big kludge to avoid my programming limitations since I could have this unit open for findalldevs purposes */\n\tint\t\t\tfirst_time;\t/* 0 = just opened via acn_open_live(),  ie. the first time, NZ = nth time */\n\tstruct sockaddr_in\t*serv_addr;\t/* the address control block for comms to this unit */\n\tint\t\t\tchassis;\n\tint\t\t\tgeoslot;\n\tiface_t\t\t\t*iface;\t\t/* a pointer to a linked list of interface structures */\n\tchar\t\t\t*imsg;\t\t/* a pointer to an inbound message */\n\tint\t\t\tlen;\t\t/* the current size of the inbound message */\n} unit_t;",
          {
            "*ip": "char",
            "fd": "int",
            "find_fd": "int",
            "first_time": "int",
            "*serv_addr": "struct sockaddr_in",
            "chassis": "int",
            "geoslot": "int",
            "*iface": "iface_t",
            "*imsg": "char",
            "len": "int"
          },
          "unit_t",
          [
            61,
            0
          ],
          [
            72,
            9
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            66,
            1
          ],
          [
            66,
            19
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            102,
            48
          ],
          [
            102,
            66
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            103,
            50
          ],
          [
            103,
            68
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            104,
            52
          ],
          [
            104,
            70
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            105,
            50
          ],
          [
            105,
            68
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            315,
            31
          ],
          [
            315,
            49
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            326,
            40
          ],
          [
            326,
            58
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            335,
            22
          ],
          [
            335,
            37
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            335,
            61
          ],
          [
            335,
            79
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            571,
            1
          ],
          [
            571,
            19
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            639,
            29
          ],
          [
            639,
            47
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            645,
            34
          ],
          [
            645,
            52
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            646,
            20
          ],
          [
            646,
            35
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            653,
            29
          ],
          [
            653,
            47
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            660,
            34
          ],
          [
            660,
            52
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            662,
            23
          ],
          [
            662,
            38
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            669,
            29
          ],
          [
            669,
            47
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            676,
            34
          ],
          [
            676,
            52
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            678,
            25
          ],
          [
            678,
            40
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            685,
            29
          ],
          [
            685,
            47
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            692,
            34
          ],
          [
            692,
            52
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            694,
            23
          ],
          [
            694,
            38
          ]
        ],
        [
          "struct\ttimeval",
          {},
          "",
          [
            738,
            1
          ],
          [
            738,
            15
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            822,
            42
          ],
          [
            822,
            58
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            891,
            46
          ],
          [
            891,
            64
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            894,
            1
          ],
          [
            894,
            16
          ]
        ],
        [
          "struct\t\ttimeval",
          {},
          "",
          [
            924,
            1
          ],
          [
            924,
            16
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            963,
            1
          ],
          [
            963,
            19
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <arpa/inet.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"pcap-sita.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-dpdk.c": {
      "fn_def_list": [
        {
          "fn_code": "static void dpdk_fmt_errmsg_for_rte_errno(char *errbuf, size_t errbuflen,\n    int errnum, const char *fmt, ...)\n{\n\tva_list ap;\n\tsize_t msglen;\n\tchar *p;\n\tsize_t errbuflen_remaining;\n\n\tva_start(ap, fmt);\n\tpcap_vsnprintf(errbuf, errbuflen, fmt, ap);\n\tva_end(ap);\n\tmsglen = strlen(errbuf);\n\n\t/*\n\t * Do we have enough space to append \": \"?\n\t * Including the terminating '\\0', that's 3 bytes.\n\t */\n\tif (msglen + 3 > errbuflen) {\n\t\t/* No - just give them what we've produced. */\n\t\treturn;\n\t}\n\tp = errbuf + msglen;\n\terrbuflen_remaining = errbuflen - msglen;\n\t*p++ = ':';\n\t*p++ = ' ';\n\t*p = '\\0';\n\tmsglen += 2;\n\terrbuflen_remaining -= 2;\n\n\t/*\n\t * Now append the string for the error code.\n\t * rte_strerror() is thread-safe, at least as of dpdk 18.11,\n\t * unlike strerror() - it uses strerror_r() rather than strerror()\n\t * for UN*X errno values, and prints to what I assume is a per-thread\n\t * buffer (based on the \"PER_LCORE\" in \"RTE_DEFINE_PER_LCORE\" used\n\t * to declare the buffers statically) for DPDK errors.\n\t */\n\tpcap_snprintf(p, errbuflen_remaining, \"%s\", rte_strerror(errnum));\n}",
          "fn_code_pos": [
            [
              201,
              0
            ],
            [
              239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dpdk_fmt_errmsg_for_rte_errno",
            "parameters": {
              "errbuf": "char",
              "errbuflen": "size_t",
              "errnum": "int",
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int dpdk_init_timer(struct pcap_dpdk *pd){\n\tgettimeofday(&(pd->ts_helper.start_time),NULL);\n\tpd->ts_helper.start_cycles = rte_get_timer_cycles();\n\tpd->ts_helper.hz = rte_get_timer_hz();\n\tif (pd->ts_helper.hz == 0){\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              241,
              0
            ],
            [
              249,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dpdk_init_timer",
            "parameters": {
              "pd": "struct pcap_dpdk"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static inline void calculate_timestamp(struct dpdk_ts_helper *helper,struct timeval *ts)\n{\n\tuint64_t cycles;\n\t// delta\n\tstruct timeval cur_time;\n\tcycles = rte_get_timer_cycles() - helper->start_cycles;\n\tcur_time.tv_sec = (time_t)(cycles/helper->hz);\n\tcur_time.tv_usec = (suseconds_t)((cycles%helper->hz)*1e6/helper->hz);\n\ttimeradd(&(helper->start_time), &cur_time, ts);\n}",
          "fn_code_pos": [
            [
              250,
              0
            ],
            [
              259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "calculate_timestamp",
            "parameters": {
              "helper": "struct dpdk_ts_helper",
              "ts": "struct timeval"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static uint32_t dpdk_gather_data(unsigned char *data, int len, struct rte_mbuf *mbuf)\n{\n\tuint32_t total_len = 0;\n\twhile (mbuf && (total_len+mbuf->data_len) < len ){\n\t\trte_memcpy(data+total_len, rte_pktmbuf_mtod(mbuf,void *),mbuf->data_len);\n\t\ttotal_len+=mbuf->data_len;\n\t\tmbuf=mbuf->next;\n\t}\n\treturn total_len;\n}",
          "fn_code_pos": [
            [
              261,
              0
            ],
            [
              270,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dpdk_gather_data",
            "parameters": {
              "data": "unsigned char",
              "len": "int",
              "mbuf": "struct rte_mbuf"
            },
            "return_type": "uint32_t"
          }
        },
        {
          "fn_code": "static int dpdk_read_with_timeout(pcap_t *p, uint16_t portid, struct rte_mbuf **pkts_burst, const uint16_t burst_cnt){\n\tstruct pcap_dpdk *pd = (struct pcap_dpdk*)(p->priv);\n\tint nb_rx = 0;\n\tint timeout_ms = p->opt.timeout;\n\tint sleep_ms = 0;\n\tif (pd->nonblock){\n\t\t// In non-blocking mode, just read once, no matter how many packets are captured.\n\t\tnb_rx = (int)rte_eth_rx_burst(pd->portid, 0, pkts_burst, burst_cnt);\n\t}else{\n\t\t// In blocking mode, read many times until packets are captured or timeout or break_loop is setted.\n\t\t// if timeout_ms == 0, it may be blocked forever.\n\t\twhile (timeout_ms == 0 || sleep_ms < timeout_ms){\n\t\t\tnb_rx = (int)rte_eth_rx_burst(pd->portid, 0, pkts_burst, burst_cnt);\n\t\t\tif (nb_rx){ // got packets within timeout_ms\n\t\t\t\tbreak;\n\t\t\t}else{ // no packet arrives at this round.\n\t\t\t\tif (p->break_loop){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// sleep for a very short while.\n\t\t\t\t// block sleep is the only choice, since usleep() will impact performance dramatically.\n\t\t\t\trte_delay_us_block(DPDK_DEF_MIN_SLEEP_MS*1000);\n\t\t\t\tsleep_ms += DPDK_DEF_MIN_SLEEP_MS;\n\t\t\t}\n\t\t}\n\t}\n\treturn nb_rx;\n}",
          "fn_code_pos": [
            [
              273,
              0
            ],
            [
              300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dpdk_read_with_timeout",
            "parameters": {
              "p": "pcap_t",
              "portid": "uint16_t",
              "pkts_burst": "struct rte_mbuf",
              "burst_cnt": "uint16_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_dpdk_dispatch(pcap_t *p, int max_cnt, pcap_handler cb, u_char *cb_arg)\n{\n\tstruct pcap_dpdk *pd = (struct pcap_dpdk*)(p->priv);\n\tint burst_cnt = 0;\n\tint nb_rx = 0;\n\tstruct rte_mbuf *pkts_burst[MAX_PKT_BURST];\n\tstruct rte_mbuf *m;\n\tstruct pcap_pkthdr pcap_header;\n\tuint16_t portid = pd->portid;\n\t// In DPDK, pkt_len is sum of lengths for all segments. And data_len is for one segment\n\tuint32_t pkt_len = 0;\n\tuint32_t caplen = 0;\n\tu_char *bp = NULL;\n\tint i=0;\n\tunsigned int gather_len =0;\n\tint pkt_cnt = 0;\n\tu_char *large_buffer=NULL;\n\tint timeout_ms = p->opt.timeout;\n\n\tif ( !PACKET_COUNT_IS_UNLIMITED(max_cnt) && max_cnt < MAX_PKT_BURST){\n\t\tburst_cnt = max_cnt;\n\t}else{\n\t\tburst_cnt = MAX_PKT_BURST;\n\t}\n\n\twhile( PACKET_COUNT_IS_UNLIMITED(max_cnt) || pkt_cnt < max_cnt){\n\t\tif (p->break_loop){\n\t\t\tp->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\t\t// read once in non-blocking mode, or try many times waiting for timeout_ms.\n\t\t// if timeout_ms == 0, it will be blocked until one packet arrives or break_loop is setted.\n\t\tnb_rx = dpdk_read_with_timeout(p, portid, pkts_burst, burst_cnt);\n\t\tif (nb_rx == 0){\n\t\t\tif (pd->nonblock){\n\t\t\t\tRTE_LOG(DEBUG, USER1, \"dpdk: no packets available in non-blocking mode.\\n\");\n\t\t\t}else{\n\t\t\t\tif (p->break_loop){\n\t\t\t\t\tRTE_LOG(DEBUG, USER1, \"dpdk: no packets available and break_loop is setted in blocking mode.\\n\");\n\t\t\t\t\tp->break_loop = 0;\n\t\t\t\t\treturn PCAP_ERROR_BREAK;\n\n\t\t\t\t}\n\t\t\t\tRTE_LOG(DEBUG, USER1, \"dpdk: no packets available for timeout %d ms in blocking mode.\\n\", timeout_ms);\n\t\t\t}\n\t\t\t// break if dpdk reads 0 packet, no matter in blocking(timeout) or non-blocking mode.\n\t\t\tbreak;\n\t\t}\n\t\tpkt_cnt += nb_rx;\n\t\tfor ( i = 0; i < nb_rx; i++) {\n\t\t\tm = pkts_burst[i];\n\t\t\tcalculate_timestamp(&(pd->ts_helper),&(pcap_header.ts));\n\t\t\tpkt_len = rte_pktmbuf_pkt_len(m);\n\t\t\t// caplen = min(pkt_len, p->snapshot);\n\t\t\t// caplen will not be changed, no matter how long the rte_pktmbuf\n\t\t\tcaplen = pkt_len < (uint32_t)p->snapshot ? pkt_len: (uint32_t)p->snapshot;\n\t\t\tpcap_header.caplen = caplen;\n\t\t\tpcap_header.len = pkt_len;\n\t\t\t// volatile prefetch\n\t\t\trte_prefetch0(rte_pktmbuf_mtod(m, void *));\n\t\t\tbp = NULL;\n\t\t\tif (m->nb_segs == 1)\n\t\t\t{\n\t\t\t\tbp = rte_pktmbuf_mtod(m, u_char *);\n\t\t\t}else{\n\t\t\t\t// use fast buffer pcap_tmp_buf if pkt_len is small, no need to call malloc and free\n\t\t\t\tif ( pkt_len <= ETHER_MAX_JUMBO_FRAME_LEN)\n\t\t\t\t{\n\t\t\t\t\tgather_len = dpdk_gather_data(pd->pcap_tmp_buf, RTE_ETH_PCAP_SNAPLEN, m);\n\t\t\t\t\tbp = pd->pcap_tmp_buf;\n\t\t\t\t}else{\n\t\t\t\t\t// need call free later\n\t\t\t\t\tlarge_buffer = (u_char *)malloc(caplen*sizeof(u_char));\n\t\t\t\t\tgather_len = dpdk_gather_data(large_buffer, caplen, m);\n\t\t\t\t\tbp = large_buffer;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (bp){\n\t\t\t\tif (p->fcode.bf_insns==NULL || pcap_filter(p->fcode.bf_insns, bp, pcap_header.len, pcap_header.caplen)){\n\t\t\t\t\tcb(cb_arg, &pcap_header, bp);\n\t\t\t\t}else{\n\t\t\t\t\tpd->bpf_drop++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//free all pktmbuf\n\t\t\trte_pktmbuf_free(m);\n\t\t\tif (large_buffer){\n\t\t\t\tfree(large_buffer);\n\t\t\t\tlarge_buffer=NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn pkt_cnt;\n}",
          "fn_code_pos": [
            [
              302,
              0
            ],
            [
              396,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dpdk_dispatch",
            "parameters": {
              "p": "pcap_t",
              "max_cnt": "int",
              "cb": "pcap_handler",
              "cb_arg": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_dpdk_inject(pcap_t *p, const void *buf _U_, int size _U_)\n{\n\t//not implemented yet\n\tpcap_strlcpy(p->errbuf,\n\t    \"dpdk error: Inject function has not been implemented yet\",\n\t    PCAP_ERRBUF_SIZE);\n\treturn PCAP_ERROR;\n}",
          "fn_code_pos": [
            [
              398,
              0
            ],
            [
              405,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dpdk_inject",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void pcap_dpdk_close(pcap_t *p)\n{\n\tstruct pcap_dpdk *pd = p->priv;\n\tif (pd==NULL)\n\t{\n\t\treturn;\n\t}\n\tif (pd->must_clear_promisc)\n\t{\n\t\trte_eth_promiscuous_disable(pd->portid);\n\t}\n\trte_eth_dev_stop(pd->portid);\n\trte_eth_dev_close(pd->portid);\n\tpcap_cleanup_live_common(p);\n}",
          "fn_code_pos": [
            [
              407,
              0
            ],
            [
              421,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dpdk_close",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void nic_stats_display(struct pcap_dpdk *pd)\n{\n\tuint16_t portid = pd->portid;\n\tstruct rte_eth_stats stats;\n\trte_eth_stats_get(portid, &stats);\n\tRTE_LOG(INFO,USER1, \"portid:%d, RX-packets: %-10\"PRIu64\"  RX-errors:  %-10\"PRIu64\n\t       \"  RX-bytes:  %-10\"PRIu64\"  RX-Imissed:  %-10\"PRIu64\"\\n\", portid, stats.ipackets, stats.ierrors,\n\t       stats.ibytes,stats.imissed);\n\tRTE_LOG(INFO,USER1, \"portid:%d, RX-PPS: %-10\"PRIu64\" RX-Mbps: %.2lf\\n\", portid, pd->pps, pd->bps/1e6f );\n}",
          "fn_code_pos": [
            [
              423,
              0
            ],
            [
              432,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nic_stats_display",
            "parameters": {
              "pd": "struct pcap_dpdk"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int pcap_dpdk_stats(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct pcap_dpdk *pd = p->priv;\n\tcalculate_timestamp(&(pd->ts_helper), &(pd->curr_ts));\n\trte_eth_stats_get(pd->portid,&(pd->curr_stats));\n\tif (ps){\n\t\tps->ps_recv = pd->curr_stats.ipackets;\n\t\tps->ps_drop = pd->curr_stats.ierrors;\n\t\tps->ps_drop += pd->bpf_drop;\n\t\tps->ps_ifdrop = pd->curr_stats.imissed;\n\t}\n\tuint64_t delta_pkt = pd->curr_stats.ipackets - pd->prev_stats.ipackets;\n\tstruct timeval delta_tm;\n\ttimersub(&(pd->curr_ts),&(pd->prev_ts), &delta_tm);\n\tuint64_t delta_usec = delta_tm.tv_sec*1e6+delta_tm.tv_usec;\n\tuint64_t delta_bit = (pd->curr_stats.ibytes-pd->prev_stats.ibytes)*8;\n\tRTE_LOG(DEBUG, USER1, \"delta_usec: %-10\"PRIu64\" delta_pkt: %-10\"PRIu64\" delta_bit: %-10\"PRIu64\"\\n\", delta_usec, delta_pkt, delta_bit);\n\tpd->pps = (uint64_t)(delta_pkt*1e6f/delta_usec);\n\tpd->bps = (uint64_t)(delta_bit*1e6f/delta_usec);\n\tnic_stats_display(pd);\n\tpd->prev_stats = pd->curr_stats;\n\tpd->prev_ts = pd->curr_ts;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              434,
              0
            ],
            [
              457,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dpdk_stats",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_dpdk_setnonblock(pcap_t *p, int nonblock){\n\tstruct pcap_dpdk *pd = (struct pcap_dpdk*)(p->priv);\n\tpd->nonblock = nonblock;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              459,
              0
            ],
            [
              463,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dpdk_setnonblock",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_dpdk_getnonblock(pcap_t *p){\n\tstruct pcap_dpdk *pd = (struct pcap_dpdk*)(p->priv);\n\treturn pd->nonblock;\n}",
          "fn_code_pos": [
            [
              465,
              0
            ],
            [
              468,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dpdk_getnonblock",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int check_link_status(uint16_t portid, struct rte_eth_link *plink)\n{\n\t// wait up to 9 seconds to get link status\n\trte_eth_link_get(portid, plink);\n\treturn plink->link_status == ETH_LINK_UP;\n}",
          "fn_code_pos": [
            [
              469,
              0
            ],
            [
              474,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "check_link_status",
            "parameters": {
              "portid": "uint16_t",
              "plink": "struct rte_eth_link"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void eth_addr_str(struct ether_addr *addrp, char* mac_str, int len)\n{\n\tint offset=0;\n\tif (addrp == NULL){\n\t\tpcap_snprintf(mac_str, len-1, DPDK_DEF_MAC_ADDR);\n\t\treturn;\n\t}\n\tfor (int i=0; i<6; i++)\n\t{\n\t\tif (offset >= len)\n\t\t{ // buffer overflow\n\t\t\treturn;\n\t\t}\n\t\tif (i==0)\n\t\t{\n\t\t\tpcap_snprintf(mac_str+offset, len-1-offset, \"%02X\",addrp->addr_bytes[i]);\n\t\t\toffset+=2; // FF\n\t\t}else{\n\t\t\tpcap_snprintf(mac_str+offset, len-1-offset, \":%02X\", addrp->addr_bytes[i]);\n\t\t\toffset+=3; // :FF\n\t\t}\n\t}\n\treturn;\n}",
          "fn_code_pos": [
            [
              475,
              0
            ],
            [
              498,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "eth_addr_str",
            "parameters": {
              "addrp": "struct ether_addr",
              "mac_str": "char",
              "len": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static uint16_t portid_by_device(char * device)\n{\n\tuint16_t ret = DPDK_PORTID_MAX;\n\tint len = strlen(device);\n\tint prefix_len = strlen(DPDK_PREFIX);\n\tunsigned long ret_ul = 0L;\n\tchar *pEnd;\n\tif (len<=prefix_len || strncmp(device, DPDK_PREFIX, prefix_len)) // check prefix dpdk:\n\t{\n\t\treturn ret;\n\t}\n\t//check all chars are digital\n\tfor (int i=prefix_len; device[i]; i++){\n\t\tif (device[i]<'0' || device[i]>'9'){\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret_ul = strtoul(&(device[prefix_len]), &pEnd, 10);\n\tif (pEnd == &(device[prefix_len]) || *pEnd != '\\0'){\n\t\treturn ret;\n\t}\n\t// too large for portid\n\tif (ret_ul >= DPDK_PORTID_MAX){\n\t\treturn ret;\n\t}\n\tret = (uint16_t)ret_ul;\n\treturn ret;\n}",
          "fn_code_pos": [
            [
              500,
              0
            ],
            [
              527,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "portid_by_device",
            "parameters": {
              "device": "char"
            },
            "return_type": "uint16_t"
          }
        },
        {
          "fn_code": "static int parse_dpdk_cfg(char* dpdk_cfg,char** dargv)\n{\n\tint cnt=0;\n\tmemset(dargv,0,sizeof(dargv[0])*DPDK_ARGC_MAX);\n\t//current process name\n\tint skip_space = 1;\n\tint i=0;\n\tRTE_LOG(INFO, USER1,\"dpdk cfg: %s\\n\",dpdk_cfg);\n\t// find first non space char\n\t// The last opt is NULL\n\tfor (i=0;dpdk_cfg[i] && cnt<DPDK_ARGC_MAX-1;i++){\n\t\tif (skip_space && dpdk_cfg[i]!=' '){ // not space\n\t\t\tskip_space=!skip_space; // skip normal char\n\t\t\tdargv[cnt++] = dpdk_cfg+i;\n\t\t}\n\t\tif (!skip_space && dpdk_cfg[i]==' '){ // fint a space\n\t\t\tdpdk_cfg[i]=0x00; // end of this opt\n\t\t\tskip_space=!skip_space; // skip space char\n\t\t}\n\t}\n\tdargv[cnt]=NULL;\n\treturn cnt;\n}",
          "fn_code_pos": [
            [
              529,
              0
            ],
            [
              551,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "parse_dpdk_cfg",
            "parameters": {
              "dpdk_cfg": "char",
              "dargv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int dpdk_pre_init(char * ebuf, int eaccess_not_fatal)\n{\n\tint dargv_cnt=0;\n\tchar *dargv[DPDK_ARGC_MAX];\n\tchar *ptr_dpdk_cfg = NULL;\n\tint ret;\n\t// globale var\n\tif (is_dpdk_pre_inited != 0)\n\t{\n\t\t// already inited; did that succeed?\n\t\tif (is_dpdk_pre_inited < 0)\n\t\t{\n\t\t\t// failed\n\t\t\tgoto error;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// succeeded\n\t\t\treturn 1;\n\t\t}\n\t}\n\t// init EAL\n\tptr_dpdk_cfg = getenv(DPDK_CFG_ENV_NAME);\n\t// set default log level to debug\n\trte_log_set_global_level(DPDK_DEF_LOG_LEV);\n\tif (ptr_dpdk_cfg == NULL)\n\t{\n\t\tRTE_LOG(INFO,USER1,\"env $DPDK_CFG is unset, so using default: %s\\n\",DPDK_DEF_CFG);\n\t\tptr_dpdk_cfg = DPDK_DEF_CFG;\n\t}\n\tmemset(dpdk_cfg_buf,0,sizeof(dpdk_cfg_buf));\n\tsnprintf(dpdk_cfg_buf,DPDK_CFG_MAX_LEN-1,\"%s %s\",DPDK_LIB_NAME,ptr_dpdk_cfg);\n\tdargv_cnt = parse_dpdk_cfg(dpdk_cfg_buf,dargv);\n\tret = rte_eal_init(dargv_cnt,dargv);\n\tif (ret == -1)\n\t{\n\t\t// Indicate that we've called rte_eal_init() by setting\n\t\t// is_dpdk_pre_inited to the negative of the error code,\n\t\t// and process the error.\n\t\tis_dpdk_pre_inited = -rte_errno;\n\t\tgoto error;\n\t}\n\t// init succeeded, so we do not need to do it again later.\n\tis_dpdk_pre_inited = 1;\n\treturn 1;\n\nerror:\n\tswitch (-is_dpdk_pre_inited)\n\t{\n\t\tcase EACCES:\n\t\t\t// This \"indicates a permissions issue.\".\n\t\t\tRTE_LOG(ERR, USER1, \"%s\\n\", DPDK_ERR_PERM_MSG);\n\t\t\t// If we were told to treat this as just meaning\n\t\t\t// DPDK isn't available, do so.\n\t\t\tif (eaccess_not_fatal)\n\t\t\t\treturn 0;\n\t\t\t// Otherwise report a fatal error.\n\t\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"DPDK requires that it run as root\");\n\t\t\treturn PCAP_ERROR_PERM_DENIED;\n\n\t\tcase EAGAIN:\n\t\t\t// This \"indicates either a bus or system\n\t\t\t// resource was not available, setup may\n\t\t\t// be attempted again.\"\n\t\t\t// There's no such error in pcap, so I'm\n\t\t\t// not sure what we should do here.\n\t\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Bus or system resource was not available\");\n\t\t\tbreak;\n\n\t\tcase EALREADY:\n\t\t\t// This \"indicates that the rte_eal_init\n\t\t\t// function has already been called, and\n\t\t\t// cannot be called again.\"\n\t\t\t// That's not an error; set the \"we've\n\t\t\t// been here before\" flag and return\n\t\t\t// success.\n\t\t\tis_dpdk_pre_inited = 1;\n\t\t\treturn 1;\n\n\t\tcase EFAULT:\n\t\t\t// This \"indicates the tailq configuration\n\t\t\t// name was not found in memory configuration.\"\n\t\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"The tailq configuration name was not found in the memory configuration\");\n\t\t\treturn PCAP_ERROR;\n\n\t\tcase EINVAL:\n\t\t\t// This \"indicates invalid parameters were\n\t\t\t// passed as argv/argc.\"  Those came from\n\t\t\t// the configuration file.\n\t\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"The configuration file has invalid parameters\");\n\t\t\tbreak;\n\n\t\tcase ENOMEM:\n\t\t\t// This \"indicates failure likely caused by\n\t\t\t// an out-of-memory condition.\"\n\t\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Out of memory\");\n\t\t\tbreak;\n\n\t\tcase ENODEV:\n\t\t\t// This \"indicates memory setup issues.\"\n\t\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"An error occurred setting up memory\");\n\t\t\tbreak;\n\n\t\tcase ENOTSUP:\n\t\t\t// This \"indicates that the EAL cannot\n\t\t\t// initialize on this system.\"  We treat\n\t\t\t// that as meaning DPDK isn't available\n\t\t\t// on this machine, rather than as a\n\t\t\t// fatal error, and let our caller decide\n\t\t\t// whether that's a fatal error (if trying\n\t\t\t// to activate a DPDK device) or not (if\n\t\t\t// trying to enumerate devices).\n\t\t\treturn 0;\n\n\t\tcase EPROTO:\n\t\t\t// This \"indicates that the PCI bus is\n\t\t\t// either not present, or is not readable\n\t\t\t// by the eal.\"  Does \"the PCI bus is not\n\t\t\t// present\" mean \"this machine has no PCI\n\t\t\t// bus\", which strikes me as a \"not available\"\n\t\t\t// case?  If so, should \"is not readable by\n\t\t\t// the EAL\" also something we should treat\n\t\t\t// as a \"not available\" case?  If not, we\n\t\t\t// can't distinguish between the two, so\n\t\t\t// we're stuck.\n\t\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"PCI bus is not present or not readable by the EAL\");\n\t\t\tbreak;\n\n\t\tcase ENOEXEC:\n\t\t\t// This \"indicates that a service core\n\t\t\t// failed to launch successfully.\"\n\t\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"A service core failed to launch successfully\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t//\n\t\t\t// That's not in the list of errors in\n\t\t\t// the documentation; let it be reported\n\t\t\t// as an error.\n\t\t\t//\n\t\t\tdpdk_fmt_errmsg_for_rte_errno(ebuf,\n\t\t\t    PCAP_ERRBUF_SIZE, -is_dpdk_pre_inited,\n\t\t\t    \"dpdk error: dpdk_pre_init failed\");\n\t\t\tbreak;\n\t}\n\t// Error.\n\treturn PCAP_ERROR;\n}",
          "fn_code_pos": [
            [
              568,
              0
            ],
            [
              723,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dpdk_pre_init",
            "parameters": {
              "ebuf": "char",
              "eaccess_not_fatal": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int pcap_dpdk_activate(pcap_t *p)\n{\n\tstruct pcap_dpdk *pd = p->priv;\n\tpd->orig = p;\n\tint ret = PCAP_ERROR;\n\tuint16_t nb_ports=0;\n\tuint16_t portid= DPDK_PORTID_MAX;\n\tunsigned nb_mbufs = DPDK_NB_MBUFS;\n\tstruct rte_eth_rxconf rxq_conf;\n\tstruct rte_eth_txconf txq_conf;\n\tstruct rte_eth_conf local_port_conf = port_conf;\n\tstruct rte_eth_dev_info dev_info;\n\tint is_port_up = 0;\n\tstruct rte_eth_link link;\n\tdo{\n\t\t//init EAL; fail if we have insufficient permission\n\t\tchar dpdk_pre_init_errbuf[PCAP_ERRBUF_SIZE];\n\t\tret = dpdk_pre_init(dpdk_pre_init_errbuf, 0);\n\t\tif (ret < 0)\n\t\t{\n\t\t\t// This returns a negative value on an error.\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Can't open device %s: %s\",\n\t\t\t    p->opt.device, dpdk_pre_init_errbuf);\n\t\t\t// ret is set to the correct error\n\t\t\tbreak;\n\t\t}\n\t\tif (ret == 0)\n\t\t{\n\t\t\t// This means DPDK isn't available on this machine.\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Can't open device %s: DPDK is not available on this machine\",\n\t\t\t    p->opt.device);\n\t\t\treturn PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t}\n\t\t\t\n\t\tret = dpdk_init_timer(pd);\n\t\tif (ret<0)\n\t\t{\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\"dpdk error: Init timer is zero with device %s\",\n\t\t\t\tp->opt.device);\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tnb_ports = rte_eth_dev_count_avail();\n\t\tif (nb_ports == 0)\n\t\t{\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"dpdk error: No Ethernet ports\");\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tportid = portid_by_device(p->opt.device);\n\t\tif (portid == DPDK_PORTID_MAX){\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"dpdk error: portid is invalid. device %s\",\n\t\t\t    p->opt.device);\n\t\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t\tbreak;\n\t\t}\n\n\t\tpd->portid = portid;\n\n\t\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\t{\n\t\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\t\t}\n\t\t// create the mbuf pool\n\t\tpd->pktmbuf_pool = rte_pktmbuf_pool_create(MBUF_POOL_NAME, nb_mbufs,\n\t\t\tMEMPOOL_CACHE_SIZE, 0, RTE_MBUF_DEFAULT_BUF_SIZE,\n\t\t\trte_socket_id());\n\t\tif (pd->pktmbuf_pool == NULL)\n\t\t{\n\t\t\tdpdk_fmt_errmsg_for_rte_errno(p->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, rte_errno,\n\t\t\t    \"dpdk error: Cannot init mbuf pool\");\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\t// config dev\n\t\trte_eth_dev_info_get(portid, &dev_info);\n\t\tif (dev_info.tx_offload_capa & DEV_TX_OFFLOAD_MBUF_FAST_FREE)\n\t\t{\n\t\t\tlocal_port_conf.txmode.offloads |=DEV_TX_OFFLOAD_MBUF_FAST_FREE;\n\t\t}\n\t\t// only support 1 queue\n\t\tret = rte_eth_dev_configure(portid, 1, 1, &local_port_conf);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tdpdk_fmt_errmsg_for_rte_errno(p->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, -ret,\n\t\t\t    \"dpdk error: Cannot configure device: port=%u\",\n\t\t\t    portid);\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\t// adjust rx tx\n\t\tret = rte_eth_dev_adjust_nb_rx_tx_desc(portid, &nb_rxd, &nb_txd);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tdpdk_fmt_errmsg_for_rte_errno(p->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, -ret,\n\t\t\t    \"dpdk error: Cannot adjust number of descriptors: port=%u\",\n\t\t\t    portid);\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\t// get MAC addr\n\t\trte_eth_macaddr_get(portid, &(pd->eth_addr));\n\t\teth_addr_str(&(pd->eth_addr), pd->mac_addr, DPDK_MAC_ADDR_SIZE-1);\n\n\t\t// init one RX queue\n\t\trxq_conf = dev_info.default_rxconf;\n\t\trxq_conf.offloads = local_port_conf.rxmode.offloads;\n\t\tret = rte_eth_rx_queue_setup(portid, 0, nb_rxd,\n\t\t\t\t\t     rte_eth_dev_socket_id(portid),\n\t\t\t\t\t     &rxq_conf,\n\t\t\t\t\t     pd->pktmbuf_pool);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tdpdk_fmt_errmsg_for_rte_errno(p->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, -ret,\n\t\t\t    \"dpdk error: rte_eth_rx_queue_setup:port=%u\",\n\t\t\t    portid);\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\t// init one TX queue\n\t\ttxq_conf = dev_info.default_txconf;\n\t\ttxq_conf.offloads = local_port_conf.txmode.offloads;\n\t\tret = rte_eth_tx_queue_setup(portid, 0, nb_txd,\n\t\t\t\trte_eth_dev_socket_id(portid),\n\t\t\t\t&txq_conf);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tdpdk_fmt_errmsg_for_rte_errno(p->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, -ret,\n\t\t\t    \"dpdk error: rte_eth_tx_queue_setup:port=%u\",\n\t\t\t    portid);\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\t// Initialize TX buffers\n\t\ttx_buffer = rte_zmalloc_socket(DPDK_TX_BUF_NAME,\n\t\t\t\tRTE_ETH_TX_BUFFER_SIZE(MAX_PKT_BURST), 0,\n\t\t\t\trte_eth_dev_socket_id(portid));\n\t\tif (tx_buffer == NULL)\n\t\t{\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"dpdk error: Cannot allocate buffer for tx on port %u\", portid);\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\trte_eth_tx_buffer_init(tx_buffer, MAX_PKT_BURST);\n\t\t// Start device\n\t\tret = rte_eth_dev_start(portid);\n\t\tif (ret < 0)\n\t\t{\n\t\t\tdpdk_fmt_errmsg_for_rte_errno(p->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, -ret,\n\t\t\t    \"dpdk error: rte_eth_dev_start:port=%u\",\n\t\t\t    portid);\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\t// set promiscuous mode\n\t\tif (p->opt.promisc){\n\t\t\tpd->must_clear_promisc=1;\n\t\t\trte_eth_promiscuous_enable(portid);\n\t\t}\n\t\t// check link status\n\t\tis_port_up = check_link_status(portid, &link);\n\t\tif (!is_port_up){\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"dpdk error: link is down, port=%u\",portid);\n\t\t\tret = PCAP_ERROR_IFACE_NOT_UP;\n\t\t\tbreak;\n\t\t}\n\t\t// reset statistics\n\t\trte_eth_stats_reset(pd->portid);\n\t\tcalculate_timestamp(&(pd->ts_helper), &(pd->prev_ts));\n\t\trte_eth_stats_get(pd->portid,&(pd->prev_stats));\n\t\t// format pcap_t\n\t\tpd->portid = portid;\n\t\tp->fd = pd->portid;\n\t\tif (p->snapshot <=0 || p->snapshot> MAXIMUM_SNAPLEN)\n\t\t{\n\t\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\t\t}\n\t\tp->linktype = DLT_EN10MB; // Ethernet, the 10MB is historical.\n\t\tp->selectable_fd = p->fd;\n\t\tp->read_op = pcap_dpdk_dispatch;\n\t\tp->inject_op = pcap_dpdk_inject;\n\t\t// using pcap_filter currently, though DPDK provides their own BPF function. Because DPDK BPF needs load a ELF file as a filter.\n\t\tp->setfilter_op = install_bpf_program;\n\t\tp->setdirection_op = NULL;\n\t\tp->set_datalink_op = NULL;\n\t\tp->getnonblock_op = pcap_dpdk_getnonblock;\n\t\tp->setnonblock_op = pcap_dpdk_setnonblock;\n\t\tp->stats_op = pcap_dpdk_stats;\n\t\tp->cleanup_op = pcap_dpdk_close;\n\t\tp->breakloop_op = pcap_breakloop_common;\n\t\t// set default timeout\n\t\tpd->required_select_timeout.tv_sec = 0;\n\t\tpd->required_select_timeout.tv_usec = DPDK_DEF_MIN_SLEEP_MS*1000;\n\t\tp->required_select_timeout = &pd->required_select_timeout;\n\t\tret = 0; // OK\n\t}while(0);\n\n\tif (ret <= PCAP_ERROR) // all kinds of error code\n\t{\n\t\tpcap_cleanup_live_common(p);\n\t}else{\n\t\trte_eth_dev_get_name_by_port(portid,pd->pci_addr);\n\t\tRTE_LOG(INFO, USER1,\"Port %d device: %s, MAC:%s, PCI:%s\\n\", portid, p->opt.device, pd->mac_addr, pd->pci_addr);\n\t\tRTE_LOG(INFO, USER1,\"Port %d Link Up. Speed %u Mbps - %s\\n\",\n\t\t\t\t\t\t\tportid, link.link_speed,\n\t\t\t\t\t(link.link_duplex == ETH_LINK_FULL_DUPLEX) ?\n\t\t\t\t\t\t(\"full-duplex\") : (\"half-duplex\\n\"));\n\t}\n\treturn ret;\n}",
          "fn_code_pos": [
            [
              725,
              0
            ],
            [
              950,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dpdk_activate",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t * pcap_dpdk_create(const char *device, char *ebuf, int *is_ours)\n{\n\tpcap_t *p=NULL;\n\t*is_ours = 0;\n\n\t*is_ours = !strncmp(device, \"dpdk:\", 5);\n\tif (! *is_ours)\n\t\treturn NULL;\n\t//memset will happen\n\tp = pcap_create_common(ebuf, sizeof(struct pcap_dpdk));\n\n\tif (p == NULL)\n\t\treturn NULL;\n\tp->activate_op = pcap_dpdk_activate;\n\treturn p;\n}",
          "fn_code_pos": [
            [
              953,
              0
            ],
            [
              968,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dpdk_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "int pcap_dpdk_findalldevs(pcap_if_list_t *devlistp, char *ebuf)\n{\n\tint ret=0;\n\tunsigned int nb_ports = 0;\n\tchar dpdk_name[DPDK_DEV_NAME_MAX];\n\tchar dpdk_desc[DPDK_DEV_DESC_MAX];\n\tstruct ether_addr eth_addr;\n\tchar mac_addr[DPDK_MAC_ADDR_SIZE];\n\tchar pci_addr[DPDK_PCI_ADDR_SIZE];\n\tdo{\n\t\t// init EAL; return \"DPDK not available\" if we\n\t\t// have insufficient permission\n\t\tchar dpdk_pre_init_errbuf[PCAP_ERRBUF_SIZE];\n\t\tret = dpdk_pre_init(dpdk_pre_init_errbuf, 1);\n\t\tif (ret < 0)\n\t\t{\n\t\t\t// This returns a negative value on an error.\n\t\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Can't look for DPDK devices: %s\",\n\t\t\t    dpdk_pre_init_errbuf);\n\t\t\tret = PCAP_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret == 0)\n\t\t{\n\t\t\t// This means DPDK isn't available on this machine.\n\t\t\t// That just means \"don't return any devices\".\n\t\t\tbreak;\n\t\t}\n\t\tnb_ports = rte_eth_dev_count_avail();\n\t\tif (nb_ports == 0)\n\t\t{\n\t\t\t// That just means \"don't return any devices\".\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tfor (unsigned int i=0; i<nb_ports; i++){\n\t\t\tpcap_snprintf(dpdk_name, DPDK_DEV_NAME_MAX-1,\n\t\t\t    \"%s%u\", DPDK_PREFIX, i);\n\t\t\t// mac addr\n\t\t\trte_eth_macaddr_get(i, &eth_addr);\n\t\t\teth_addr_str(&eth_addr,mac_addr,DPDK_MAC_ADDR_SIZE);\n\t\t\t// PCI addr\n\t\t\trte_eth_dev_get_name_by_port(i,pci_addr);\n\t\t\tpcap_snprintf(dpdk_desc,DPDK_DEV_DESC_MAX-1,\"%s %s, MAC:%s, PCI:%s\", DPDK_DESC, dpdk_name, mac_addr, pci_addr);\n\t\t\tif (add_dev(devlistp, dpdk_name, 0, dpdk_desc, ebuf)==NULL){\n\t\t\t\tret = PCAP_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}while(0);\n\treturn ret;\n}",
          "fn_code_pos": [
            [
              970,
              0
            ],
            [
              1022,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dpdk_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_create_interface(const char *device, char *errbuf)\n{\n\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t    \"This version of libpcap only supports DPDK\");\n\treturn NULL;\n}",
          "fn_code_pos": [
            [
              1041,
              0
            ],
            [
              1047,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "errbuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING \" (DPDK-only)\");\n}",
          "fn_code_pos": [
            [
              1052,
              0
            ],
            [
              1056,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "dpdk_fmt_errmsg_for_rte_errno(char *, size_t, int,\n    PCAP_FORMAT_STRING(const char *), ...)",
          "fn_dec_pos": [
            [
              194,
              12
            ],
            [
              195,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dpdk_fmt_errmsg_for_rte_errno",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "rte_pktmbuf_mtod(m, void *)",
          "fn_dec_pos": [
            [
              361,
              17
            ],
            [
              361,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rte_pktmbuf_mtod",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_dpdk_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              953,
              9
            ],
            [
              953,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dpdk_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_create_interface(const char *device, char *errbuf)",
          "fn_dec_pos": [
            [
              1042,
              0
            ],
            [
              1042,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              1053,
              0
            ],
            [
              1053,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct dpdk_ts_helper{\n\tstruct timeval start_time;\n\tuint64_t start_cycles;\n\tuint64_t hz;\n}",
          {
            "start_time": "struct timeval",
            "start_cycles": "uint64_t",
            "hz": "uint64_t"
          },
          "dpdk_ts_helper",
          [
            159,
            0
          ],
          [
            163,
            1
          ]
        ],
        [
          "struct pcap_dpdk{\n\tpcap_t * orig;\n\tuint16_t portid; // portid of DPDK\n\tint must_clear_promisc;\n\tuint64_t bpf_drop;\n\tint nonblock;\n\tstruct timeval required_select_timeout;\n\tstruct timeval prev_ts;\n\tstruct rte_eth_stats prev_stats;\n\tstruct timeval curr_ts;\n\tstruct rte_eth_stats curr_stats;\n\tuint64_t pps;\n\tuint64_t bps;\n\tstruct rte_mempool * pktmbuf_pool;\n\tstruct dpdk_ts_helper ts_helper;\n\tstruct ether_addr eth_addr;\n\tchar mac_addr[DPDK_MAC_ADDR_SIZE];\n\tchar pci_addr[DPDK_PCI_ADDR_SIZE];\n\tunsigned char pcap_tmp_buf[RTE_ETH_PCAP_SNAPLEN];\n}",
          {
            "* orig": "pcap_t",
            "portid": "uint16_t",
            "must_clear_promisc": "int",
            "bpf_drop": "uint64_t",
            "nonblock": "int",
            "required_select_timeout": "struct timeval",
            "prev_ts": "struct timeval",
            "prev_stats": "struct rte_eth_stats",
            "curr_ts": "struct timeval",
            "curr_stats": "struct rte_eth_stats",
            "pps": "uint64_t",
            "bps": "uint64_t",
            "* pktmbuf_pool": "struct rte_mempool",
            "ts_helper": "struct dpdk_ts_helper",
            "eth_addr": "struct ether_addr",
            "mac_addr[DPDK_MAC_ADDR_SIZE]": "char",
            "pci_addr[DPDK_PCI_ADDR_SIZE]": "char",
            "pcap_tmp_buf[RTE_ETH_PCAP_SNAPLEN]": "unsigned char"
          },
          "pcap_dpdk",
          [
            164,
            0
          ],
          [
            183,
            1
          ]
        ],
        [
          "struct rte_eth_dev_tx_buffer",
          {},
          "",
          [
            157,
            7
          ],
          [
            157,
            35
          ]
        ],
        [
          "struct dpdk_ts_helper{\n\tstruct timeval start_time;\n\tuint64_t start_cycles;\n\tuint64_t hz;\n}",
          {
            "start_time": "struct timeval",
            "start_cycles": "uint64_t",
            "hz": "uint64_t"
          },
          "dpdk_ts_helper",
          [
            159,
            0
          ],
          [
            163,
            1
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            160,
            1
          ],
          [
            160,
            15
          ]
        ],
        [
          "struct pcap_dpdk{\n\tpcap_t * orig;\n\tuint16_t portid; // portid of DPDK\n\tint must_clear_promisc;\n\tuint64_t bpf_drop;\n\tint nonblock;\n\tstruct timeval required_select_timeout;\n\tstruct timeval prev_ts;\n\tstruct rte_eth_stats prev_stats;\n\tstruct timeval curr_ts;\n\tstruct rte_eth_stats curr_stats;\n\tuint64_t pps;\n\tuint64_t bps;\n\tstruct rte_mempool * pktmbuf_pool;\n\tstruct dpdk_ts_helper ts_helper;\n\tstruct ether_addr eth_addr;\n\tchar mac_addr[DPDK_MAC_ADDR_SIZE];\n\tchar pci_addr[DPDK_PCI_ADDR_SIZE];\n\tunsigned char pcap_tmp_buf[RTE_ETH_PCAP_SNAPLEN];\n}",
          {
            "* orig": "pcap_t",
            "portid": "uint16_t",
            "must_clear_promisc": "int",
            "bpf_drop": "uint64_t",
            "nonblock": "int",
            "required_select_timeout": "struct timeval",
            "prev_ts": "struct timeval",
            "prev_stats": "struct rte_eth_stats",
            "curr_ts": "struct timeval",
            "curr_stats": "struct rte_eth_stats",
            "pps": "uint64_t",
            "bps": "uint64_t",
            "* pktmbuf_pool": "struct rte_mempool",
            "ts_helper": "struct dpdk_ts_helper",
            "eth_addr": "struct ether_addr",
            "mac_addr[DPDK_MAC_ADDR_SIZE]": "char",
            "pci_addr[DPDK_PCI_ADDR_SIZE]": "char",
            "pcap_tmp_buf[RTE_ETH_PCAP_SNAPLEN]": "unsigned char"
          },
          "pcap_dpdk",
          [
            164,
            0
          ],
          [
            183,
            1
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            170,
            1
          ],
          [
            170,
            15
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            171,
            1
          ],
          [
            171,
            15
          ]
        ],
        [
          "struct rte_eth_stats",
          {},
          "",
          [
            172,
            1
          ],
          [
            172,
            21
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            173,
            1
          ],
          [
            173,
            15
          ]
        ],
        [
          "struct rte_eth_stats",
          {},
          "",
          [
            174,
            1
          ],
          [
            174,
            21
          ]
        ],
        [
          "struct rte_mempool",
          {},
          "",
          [
            177,
            1
          ],
          [
            177,
            19
          ]
        ],
        [
          "struct dpdk_ts_helper",
          {},
          "",
          [
            178,
            1
          ],
          [
            178,
            22
          ]
        ],
        [
          "struct ether_addr",
          {},
          "",
          [
            179,
            1
          ],
          [
            179,
            18
          ]
        ],
        [
          "struct rte_eth_conf",
          {},
          "",
          [
            185,
            7
          ],
          [
            185,
            26
          ]
        ],
        [
          "struct pcap_dpdk",
          {},
          "",
          [
            241,
            27
          ],
          [
            241,
            43
          ]
        ],
        [
          "struct dpdk_ts_helper",
          {},
          "",
          [
            250,
            39
          ],
          [
            250,
            60
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            250,
            69
          ],
          [
            250,
            83
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            254,
            1
          ],
          [
            254,
            15
          ]
        ],
        [
          "struct rte_mbuf",
          {},
          "",
          [
            261,
            63
          ],
          [
            261,
            78
          ]
        ],
        [
          "struct rte_mbuf",
          {},
          "",
          [
            273,
            62
          ],
          [
            273,
            77
          ]
        ],
        [
          "struct pcap_dpdk",
          {},
          "",
          [
            274,
            1
          ],
          [
            274,
            17
          ]
        ],
        [
          "struct pcap_dpdk",
          {},
          "",
          [
            274,
            25
          ],
          [
            274,
            41
          ]
        ],
        [
          "struct pcap_dpdk",
          {},
          "",
          [
            304,
            1
          ],
          [
            304,
            17
          ]
        ],
        [
          "struct pcap_dpdk",
          {},
          "",
          [
            304,
            25
          ],
          [
            304,
            41
          ]
        ],
        [
          "struct rte_mbuf",
          {},
          "",
          [
            307,
            1
          ],
          [
            307,
            16
          ]
        ],
        [
          "struct rte_mbuf",
          {},
          "",
          [
            308,
            1
          ],
          [
            308,
            16
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            309,
            1
          ],
          [
            309,
            19
          ]
        ],
        [
          "struct pcap_dpdk",
          {},
          "",
          [
            409,
            1
          ],
          [
            409,
            17
          ]
        ],
        [
          "struct pcap_dpdk",
          {},
          "",
          [
            423,
            30
          ],
          [
            423,
            46
          ]
        ],
        [
          "struct rte_eth_stats",
          {},
          "",
          [
            426,
            1
          ],
          [
            426,
            21
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            434,
            38
          ],
          [
            434,
            54
          ]
        ],
        [
          "struct pcap_dpdk",
          {},
          "",
          [
            436,
            1
          ],
          [
            436,
            17
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            446,
            1
          ],
          [
            446,
            15
          ]
        ],
        [
          "struct pcap_dpdk",
          {},
          "",
          [
            460,
            1
          ],
          [
            460,
            17
          ]
        ],
        [
          "struct pcap_dpdk",
          {},
          "",
          [
            460,
            25
          ],
          [
            460,
            41
          ]
        ],
        [
          "struct pcap_dpdk",
          {},
          "",
          [
            466,
            1
          ],
          [
            466,
            17
          ]
        ],
        [
          "struct pcap_dpdk",
          {},
          "",
          [
            466,
            25
          ],
          [
            466,
            41
          ]
        ],
        [
          "struct rte_eth_link",
          {},
          "",
          [
            469,
            46
          ],
          [
            469,
            65
          ]
        ],
        [
          "struct ether_addr",
          {},
          "",
          [
            475,
            25
          ],
          [
            475,
            42
          ]
        ],
        [
          "struct pcap_dpdk",
          {},
          "",
          [
            727,
            1
          ],
          [
            727,
            17
          ]
        ],
        [
          "struct rte_eth_rxconf",
          {},
          "",
          [
            733,
            1
          ],
          [
            733,
            22
          ]
        ],
        [
          "struct rte_eth_txconf",
          {},
          "",
          [
            734,
            1
          ],
          [
            734,
            22
          ]
        ],
        [
          "struct rte_eth_conf",
          {},
          "",
          [
            735,
            1
          ],
          [
            735,
            20
          ]
        ],
        [
          "struct rte_eth_dev_info",
          {},
          "",
          [
            736,
            1
          ],
          [
            736,
            24
          ]
        ],
        [
          "struct rte_eth_link",
          {},
          "",
          [
            738,
            1
          ],
          [
            738,
            20
          ]
        ],
        [
          "struct pcap_dpdk",
          {},
          "",
          [
            962,
            37
          ],
          [
            962,
            53
          ]
        ],
        [
          "struct ether_addr",
          {},
          "",
          [
            976,
            1
          ],
          [
            976,
            18
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            78,
            0
          ],
          [
            79,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            81,
            0
          ],
          [
            82,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            82,
            0
          ],
          [
            83,
            0
          ]
        ],
        [
          "#include <netdb.h>\n",
          [
            83,
            0
          ],
          [
            84,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            84,
            0
          ],
          [
            85,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            85,
            0
          ],
          [
            86,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            86,
            0
          ],
          [
            87,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            87,
            0
          ],
          [
            88,
            0
          ]
        ],
        [
          "#include <time.h>\n",
          [
            88,
            0
          ],
          [
            89,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            90,
            0
          ],
          [
            91,
            0
          ]
        ],
        [
          "#include <rte_config.h>\n",
          [
            93,
            0
          ],
          [
            94,
            0
          ]
        ],
        [
          "#include <rte_common.h>\n",
          [
            94,
            0
          ],
          [
            95,
            0
          ]
        ],
        [
          "#include <rte_errno.h>\n",
          [
            95,
            0
          ],
          [
            96,
            0
          ]
        ],
        [
          "#include <rte_log.h>\n",
          [
            96,
            0
          ],
          [
            97,
            0
          ]
        ],
        [
          "#include <rte_malloc.h>\n",
          [
            97,
            0
          ],
          [
            98,
            0
          ]
        ],
        [
          "#include <rte_memory.h>\n",
          [
            98,
            0
          ],
          [
            99,
            0
          ]
        ],
        [
          "#include <rte_eal.h>\n",
          [
            99,
            0
          ],
          [
            100,
            0
          ]
        ],
        [
          "#include <rte_launch.h>\n",
          [
            100,
            0
          ],
          [
            101,
            0
          ]
        ],
        [
          "#include <rte_atomic.h>\n",
          [
            101,
            0
          ],
          [
            102,
            0
          ]
        ],
        [
          "#include <rte_cycles.h>\n",
          [
            102,
            0
          ],
          [
            103,
            0
          ]
        ],
        [
          "#include <rte_lcore.h>\n",
          [
            103,
            0
          ],
          [
            104,
            0
          ]
        ],
        [
          "#include <rte_per_lcore.h>\n",
          [
            104,
            0
          ],
          [
            105,
            0
          ]
        ],
        [
          "#include <rte_branch_prediction.h>\n",
          [
            105,
            0
          ],
          [
            106,
            0
          ]
        ],
        [
          "#include <rte_interrupts.h>\n",
          [
            106,
            0
          ],
          [
            107,
            0
          ]
        ],
        [
          "#include <rte_random.h>\n",
          [
            107,
            0
          ],
          [
            108,
            0
          ]
        ],
        [
          "#include <rte_debug.h>\n",
          [
            108,
            0
          ],
          [
            109,
            0
          ]
        ],
        [
          "#include <rte_ether.h>\n",
          [
            109,
            0
          ],
          [
            110,
            0
          ]
        ],
        [
          "#include <rte_ethdev.h>\n",
          [
            110,
            0
          ],
          [
            111,
            0
          ]
        ],
        [
          "#include <rte_mempool.h>\n",
          [
            111,
            0
          ],
          [
            112,
            0
          ]
        ],
        [
          "#include <rte_mbuf.h>\n",
          [
            112,
            0
          ],
          [
            113,
            0
          ]
        ],
        [
          "#include <rte_bus.h>\n",
          [
            113,
            0
          ],
          [
            114,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            115,
            0
          ],
          [
            116,
            0
          ]
        ],
        [
          "#include \"pcap-dpdk.h\"\n",
          [
            116,
            0
          ],
          [
            117,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-dag.c": {
      "fn_def_list": [
        {
          "fn_code": "static void\ndelete_pcap_dag(pcap_t *p)\n{\n\tpcap_dag_node_t *curr = NULL, *prev = NULL;\n\n\tfor (prev = NULL, curr = pcap_dags; curr != NULL && curr->p != p; prev = curr, curr = curr->next) {\n\t\t/* empty */\n\t}\n\n\tif (curr != NULL && curr->p == p) {\n\t\tif (prev != NULL) {\n\t\t\tprev->next = curr->next;\n\t\t} else {\n\t\t\tpcap_dags = curr->next;\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              215,
              0
            ],
            [
              231,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "delete_pcap_dag",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ndag_platform_cleanup(pcap_t *p)\n{\n\tstruct pcap_dag *pd = p->priv;\n\n\tif(dag_stop_stream(p->fd, pd->dag_stream) < 0)\n\t\tfprintf(stderr,\"dag_stop_stream: %s\\n\", strerror(errno));\n\n\tif(dag_detach_stream(p->fd, pd->dag_stream) < 0)\n\t\tfprintf(stderr,\"dag_detach_stream: %s\\n\", strerror(errno));\n\n\tif(pd->dag_ref != NULL) {\n\t\tdag_config_dispose(pd->dag_ref);\n\t\t/*\n\t\t * Note: we don't need to call close(p->fd) or\n\t\t * dag_close(p->fd), as dag_config_dispose(pd->dag_ref)\n\t\t * does this.\n\t\t *\n\t\t * Set p->fd to -1 to make sure that's not done.\n\t\t */\n\t\tp->fd = -1;\n\t\tpd->dag_ref = NULL;\n\t}\n\tdelete_pcap_dag(p);\n\tpcap_cleanup_live_common(p);\n}",
          "fn_code_pos": [
            [
              238,
              0
            ],
            [
              263,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_platform_cleanup",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\natexit_handler(void)\n{\n\twhile (pcap_dags != NULL) {\n\t\tif (pcap_dags->pid == getpid()) {\n\t\t\tif (pcap_dags->p != NULL)\n\t\t\t\tdag_platform_cleanup(pcap_dags->p);\n\t\t} else {\n\t\t\tdelete_pcap_dag(pcap_dags->p);\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              265,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "atexit_handler",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nnew_pcap_dag(pcap_t *p)\n{\n\tpcap_dag_node_t *node = NULL;\n\n\tif ((node = malloc(sizeof(pcap_dag_node_t))) == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (!atexit_handler_installed) {\n\t\tatexit(atexit_handler);\n\t\tatexit_handler_installed = 1;\n\t}\n\n\tnode->next = pcap_dags;\n\tnode->p = p;\n\tnode->pid = getpid();\n\n\tpcap_dags = node;\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              278,
              0
            ],
            [
              299,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "new_pcap_dag",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static unsigned int\ndag_erf_ext_header_count(uint8_t * erf, size_t len)\n{\n\tuint32_t hdr_num = 0;\n\tuint8_t  hdr_type;\n\n\t/* basic sanity checks */\n\tif ( erf == NULL )\n\t\treturn 0;\n\tif ( len < 16 )\n\t\treturn 0;\n\n\t/* check if we have any extension headers */\n\tif ( (erf[8] & 0x80) == 0x00 )\n\t\treturn 0;\n\n\t/* loop over the extension headers */\n\tdo {\n\n\t\t/* sanity check we have enough bytes */\n\t\tif ( len < (24 + (hdr_num * 8)) )\n\t\t\treturn hdr_num;\n\n\t\t/* get the header type */\n\t\thdr_type = erf[(16 + (hdr_num * 8))];\n\t\thdr_num++;\n\n\t} while ( hdr_type & 0x80 );\n\n\treturn hdr_num;\n}",
          "fn_code_pos": [
            [
              301,
              0
            ],
            [
              331,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_erf_ext_header_count",
            "parameters": {
              "erf": "uint8_t",
              "len": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static int\ndag_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_dag *pd = p->priv;\n\tunsigned int processed = 0;\n\tunsigned int nonblocking = pd->dag_flags & DAGF_NONBLOCK;\n\tunsigned int num_ext_hdr = 0;\n\tunsigned int ticks_per_second;\n\n\t/* Get the next bufferful of packets (if necessary). */\n\twhile (pd->dag_mem_top - pd->dag_mem_bottom < dag_record_size) {\n\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\t/*\n\t\t\t * Yes - clear the flag that indicates that\n\t\t\t * it has, and return -2 to indicate that\n\t\t\t * we were told to break out of the loop.\n\t\t\t */\n\t\t\tp->break_loop = 0;\n\t\t\treturn -2;\n\t\t}\n\n\t\t/* dag_advance_stream() will block (unless nonblock is called)\n\t\t * until 64kB of data has accumulated.\n\t\t * If to_ms is set, it will timeout before 64kB has accumulated.\n\t\t * We wait for 64kB because processing a few packets at a time\n\t\t * can cause problems at high packet rates (>200kpps) due\n\t\t * to inefficiencies.\n\t\t * This does mean if to_ms is not specified the capture may 'hang'\n\t\t * for long periods if the data rate is extremely slow (<64kB/sec)\n\t\t * If non-block is specified it will return immediately. The user\n\t\t * is then responsible for efficiency.\n\t\t */\n\t\tif ( NULL == (pd->dag_mem_top = dag_advance_stream(p->fd, pd->dag_stream, &(pd->dag_mem_bottom))) ) {\n\t\t     return -1;\n\t\t}\n\n\t\tif (nonblocking && (pd->dag_mem_top - pd->dag_mem_bottom < dag_record_size))\n\t\t{\n\t\t\t/* Pcap is configured to process only available packets, and there aren't any, return immediately. */\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(!nonblocking &&\n\t\t   pd->dag_timeout &&\n\t\t   (pd->dag_mem_top - pd->dag_mem_bottom < dag_record_size))\n\t\t{\n\t\t\t/* Blocking mode, but timeout set and no data has arrived, return anyway.*/\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\n\t/* Process the packets. */\n\twhile (pd->dag_mem_top - pd->dag_mem_bottom >= dag_record_size) {\n\n\t\tunsigned short packet_len = 0;\n\t\tint caplen = 0;\n\t\tstruct pcap_pkthdr\tpcap_header;\n\n\t\tdag_record_t *header = (dag_record_t *)(pd->dag_mem_bottom);\n\n\t\tu_char *dp = ((u_char *)header); /* + dag_record_size; */\n\t\tunsigned short rlen;\n\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t */\n\t\tif (p->break_loop) {\n\t\t\t/*\n\t\t\t * Yes - clear the flag that indicates that\n\t\t\t * it has, and return -2 to indicate that\n\t\t\t * we were told to break out of the loop.\n\t\t\t */\n\t\t\tp->break_loop = 0;\n\t\t\treturn -2;\n\t\t}\n\n\t\trlen = ntohs(header->rlen);\n\t\tif (rlen < dag_record_size)\n\t\t{\n\t\t\tstrncpy(p->errbuf, \"dag_read: record too small\", PCAP_ERRBUF_SIZE);\n\t\t\treturn -1;\n\t\t}\n\t\tpd->dag_mem_bottom += rlen;\n\n\t\t/* Count lost packets. */\n\t\tswitch((header->type & 0x7f)) {\n\t\t\t/* in these types the color value overwrites the lctr */\n\t\tcase ERF_TYPE_COLOR_HDLC_POS:\n\t\tcase ERF_TYPE_COLOR_ETH:\n\t\tcase ERF_TYPE_DSM_COLOR_HDLC_POS:\n\t\tcase ERF_TYPE_DSM_COLOR_ETH:\n\t\tcase ERF_TYPE_COLOR_MC_HDLC_POS:\n\t\tcase ERF_TYPE_COLOR_HASH_ETH:\n\t\tcase ERF_TYPE_COLOR_HASH_POS:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif ( (pd->drop_attr == kNullAttributeUuid) && (header->lctr) ) {\n\t\t\t\tpd->stat.ps_drop += ntohs(header->lctr);\n\t\t\t}\n\t\t}\n\n\t\tif ((header->type & 0x7f) == ERF_TYPE_PAD) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tnum_ext_hdr = dag_erf_ext_header_count(dp, rlen);\n\n\t\t/* ERF encapsulation */\n\t\t/* The Extensible Record Format is not dropped for this kind of encapsulation,\n\t\t * and will be handled as a pseudo header by the decoding application.\n\t\t * The information carried in the ERF header and in the optional subheader (if present)\n\t\t * could be merged with the libpcap information, to offer a better decoding.\n\t\t * The packet length is\n\t\t * o the length of the packet on the link (header->wlen),\n\t\t * o plus the length of the ERF header (dag_record_size), as the length of the\n\t\t *   pseudo header will be adjusted during the decoding,\n\t\t * o plus the length of the optional subheader (if present).\n\t\t *\n\t\t * The capture length is header.rlen and the byte stuffing for alignment will be dropped\n\t\t * if the capture length is greater than the packet length.\n\t\t */\n\t\tif (p->linktype == DLT_ERF) {\n\t\t\tpacket_len = ntohs(header->wlen) + dag_record_size;\n\t\t\tcaplen = rlen;\n\t\t\tswitch ((header->type & 0x7f)) {\n\t\t\tcase ERF_TYPE_MC_AAL5:\n\t\t\tcase ERF_TYPE_MC_ATM:\n\t\t\tcase ERF_TYPE_MC_HDLC:\n\t\t\tcase ERF_TYPE_MC_RAW_CHANNEL:\n\t\t\tcase ERF_TYPE_MC_RAW:\n\t\t\tcase ERF_TYPE_MC_AAL2:\n\t\t\tcase ERF_TYPE_COLOR_MC_HDLC_POS:\n\t\t\t\tpacket_len += 4; /* MC header */\n\t\t\t\tbreak;\n\n\t\t\tcase ERF_TYPE_COLOR_HASH_ETH:\n\t\t\tcase ERF_TYPE_DSM_COLOR_ETH:\n\t\t\tcase ERF_TYPE_COLOR_ETH:\n\t\t\tcase ERF_TYPE_ETH:\n\t\t\t\tpacket_len += 2; /* ETH header */\n\t\t\t\tbreak;\n\t\t\t} /* switch type */\n\n\t\t\t/* Include ERF extension headers */\n\t\t\tpacket_len += (8 * num_ext_hdr);\n\n\t\t\tif (caplen > packet_len) {\n\t\t\t\tcaplen = packet_len;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Other kind of encapsulation according to the header Type */\n\n\t\t\t/* Skip over generic ERF header */\n\t\t\tdp += dag_record_size;\n\t\t\t/* Skip over extension headers */\n\t\t\tdp += 8 * num_ext_hdr;\n\n\t\t\tswitch((header->type & 0x7f)) {\n\t\t\tcase ERF_TYPE_ATM:\n\t\t\tcase ERF_TYPE_AAL5:\n\t\t\t\tif ((header->type & 0x7f) == ERF_TYPE_AAL5) {\n\t\t\t\t\tpacket_len = ntohs(header->wlen);\n\t\t\t\t\tcaplen = rlen - dag_record_size;\n\t\t\t\t}\n\t\t\tcase ERF_TYPE_MC_ATM:\n\t\t\t\tif ((header->type & 0x7f) == ERF_TYPE_MC_ATM) {\n\t\t\t\t\tcaplen = packet_len = ATM_CELL_SIZE;\n\t\t\t\t\tdp+=4;\n\t\t\t\t}\n\t\t\tcase ERF_TYPE_MC_AAL5:\n\t\t\t\tif ((header->type & 0x7f) == ERF_TYPE_MC_AAL5) {\n\t\t\t\t\tpacket_len = ntohs(header->wlen);\n\t\t\t\t\tcaplen = rlen - dag_record_size - 4;\n\t\t\t\t\tdp+=4;\n\t\t\t\t}\n\t\t\t\t/* Skip over extension headers */\n\t\t\t\tcaplen -= (8 * num_ext_hdr);\n\n\t\t\t\tif ((header->type & 0x7f) == ERF_TYPE_ATM) {\n\t\t\t\t\tcaplen = packet_len = ATM_CELL_SIZE;\n\t\t\t\t}\n\t\t\t\tif (p->linktype == DLT_SUNATM) {\n\t\t\t\t\tstruct sunatm_hdr *sunatm = (struct sunatm_hdr *)dp;\n\t\t\t\t\tunsigned long rawatm;\n\n\t\t\t\t\trawatm = ntohl(*((unsigned long *)dp));\n\t\t\t\t\tsunatm->vci = htons((rawatm >>  4) & 0xffff);\n\t\t\t\t\tsunatm->vpi = (rawatm >> 20) & 0x00ff;\n\t\t\t\t\tsunatm->flags = ((header->flags.iface & 1) ? 0x80 : 0x00) |\n\t\t\t\t\t\t((sunatm->vpi == 0 && sunatm->vci == htons(5)) ? 6 :\n\t\t\t\t\t\t ((sunatm->vpi == 0 && sunatm->vci == htons(16)) ? 5 :\n\t\t\t\t\t\t  ((dp[ATM_HDR_SIZE] == 0xaa &&\n\t\t\t\t\t\t    dp[ATM_HDR_SIZE+1] == 0xaa &&\n\t\t\t\t\t\t    dp[ATM_HDR_SIZE+2] == 0x03) ? 2 : 1)));\n\n\t\t\t\t} else if (p->linktype == DLT_ATM_RFC1483) {\n\t\t\t\t\tpacket_len -= ATM_HDR_SIZE;\n\t\t\t\t\tcaplen -= ATM_HDR_SIZE;\n\t\t\t\t\tdp += ATM_HDR_SIZE;\n\t\t\t\t} else\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\n\t\t\tcase ERF_TYPE_COLOR_HASH_ETH:\n\t\t\tcase ERF_TYPE_DSM_COLOR_ETH:\n\t\t\tcase ERF_TYPE_COLOR_ETH:\n\t\t\tcase ERF_TYPE_ETH:\n\t\t\t\tif ((p->linktype != DLT_EN10MB) &&\n\t\t\t\t    (p->linktype != DLT_DOCSIS))\n\t\t\t\t\tcontinue;\n\t\t\t\tpacket_len = ntohs(header->wlen);\n\t\t\t\tpacket_len -= (pd->dag_fcs_bits >> 3);\n\t\t\t\tcaplen = rlen - dag_record_size - 2;\n\t\t\t\t/* Skip over extension headers */\n\t\t\t\tcaplen -= (8 * num_ext_hdr);\n\t\t\t\tif (caplen > packet_len) {\n\t\t\t\t\tcaplen = packet_len;\n\t\t\t\t}\n\t\t\t\tdp += 2;\n\t\t\t\tbreak;\n\n\t\t\tcase ERF_TYPE_COLOR_HASH_POS:\n\t\t\tcase ERF_TYPE_DSM_COLOR_HDLC_POS:\n\t\t\tcase ERF_TYPE_COLOR_HDLC_POS:\n\t\t\tcase ERF_TYPE_HDLC_POS:\n\t\t\t\tif ((p->linktype != DLT_CHDLC) &&\n\t\t\t\t    (p->linktype != DLT_PPP_SERIAL) &&\n\t\t\t\t    (p->linktype != DLT_FRELAY))\n\t\t\t\t\tcontinue;\n\t\t\t\tpacket_len = ntohs(header->wlen);\n\t\t\t\tpacket_len -= (pd->dag_fcs_bits >> 3);\n\t\t\t\tcaplen = rlen - dag_record_size;\n\t\t\t\t/* Skip over extension headers */\n\t\t\t\tcaplen -= (8 * num_ext_hdr);\n\t\t\t\tif (caplen > packet_len) {\n\t\t\t\t\tcaplen = packet_len;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ERF_TYPE_COLOR_MC_HDLC_POS:\n\t\t\tcase ERF_TYPE_MC_HDLC:\n\t\t\t\tif ((p->linktype != DLT_CHDLC) &&\n\t\t\t\t    (p->linktype != DLT_PPP_SERIAL) &&\n\t\t\t\t    (p->linktype != DLT_FRELAY) &&\n\t\t\t\t    (p->linktype != DLT_MTP2) &&\n\t\t\t\t    (p->linktype != DLT_MTP2_WITH_PHDR) &&\n\t\t\t\t    (p->linktype != DLT_LAPD))\n\t\t\t\t\tcontinue;\n\t\t\t\tpacket_len = ntohs(header->wlen);\n\t\t\t\tpacket_len -= (pd->dag_fcs_bits >> 3);\n\t\t\t\tcaplen = rlen - dag_record_size - 4;\n\t\t\t\t/* Skip over extension headers */\n\t\t\t\tcaplen -= (8 * num_ext_hdr);\n\t\t\t\tif (caplen > packet_len) {\n\t\t\t\t\tcaplen = packet_len;\n\t\t\t\t}\n\t\t\t\t/* jump the MC_HDLC_HEADER */\n\t\t\t\tdp += 4;\n#ifdef DLT_MTP2_WITH_PHDR\n\t\t\t\tif (p->linktype == DLT_MTP2_WITH_PHDR) {\n\t\t\t\t\t/* Add the MTP2 Pseudo Header */\n\t\t\t\t\tcaplen += MTP2_HDR_LEN;\n\t\t\t\t\tpacket_len += MTP2_HDR_LEN;\n\n\t\t\t\t\tTempPkt[MTP2_SENT_OFFSET] = 0;\n\t\t\t\t\tTempPkt[MTP2_ANNEX_A_USED_OFFSET] = MTP2_ANNEX_A_USED_UNKNOWN;\n\t\t\t\t\t*(TempPkt+MTP2_LINK_NUMBER_OFFSET) = ((header->rec.mc_hdlc.mc_header>>16)&0x01);\n\t\t\t\t\t*(TempPkt+MTP2_LINK_NUMBER_OFFSET+1) = ((header->rec.mc_hdlc.mc_header>>24)&0xff);\n\t\t\t\t\tmemcpy(TempPkt+MTP2_HDR_LEN, dp, caplen);\n\t\t\t\t\tdp = TempPkt;\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n\n\t\t\tcase ERF_TYPE_IPV4:\n\t\t\t\tif ((p->linktype != DLT_RAW) &&\n\t\t\t\t    (p->linktype != DLT_IPV4))\n\t\t\t\t\tcontinue;\n\t\t\t\tpacket_len = ntohs(header->wlen);\n\t\t\t\tcaplen = rlen - dag_record_size;\n\t\t\t\t/* Skip over extension headers */\n\t\t\t\tcaplen -= (8 * num_ext_hdr);\n\t\t\t\tif (caplen > packet_len) {\n\t\t\t\t\tcaplen = packet_len;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ERF_TYPE_IPV6:\n\t\t\t\tif ((p->linktype != DLT_RAW) &&\n\t\t\t\t    (p->linktype != DLT_IPV6))\n\t\t\t\t\tcontinue;\n\t\t\t\tpacket_len = ntohs(header->wlen);\n\t\t\t\tcaplen = rlen - dag_record_size;\n\t\t\t\t/* Skip over extension headers */\n\t\t\t\tcaplen -= (8 * num_ext_hdr);\n\t\t\t\tif (caplen > packet_len) {\n\t\t\t\t\tcaplen = packet_len;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t/* These types have no matching 'native' DLT, but can be used with DLT_ERF above */\n\t\t\tcase ERF_TYPE_MC_RAW:\n\t\t\tcase ERF_TYPE_MC_RAW_CHANNEL:\n\t\t\tcase ERF_TYPE_IP_COUNTER:\n\t\t\tcase ERF_TYPE_TCP_FLOW_COUNTER:\n\t\t\tcase ERF_TYPE_INFINIBAND:\n\t\t\tcase ERF_TYPE_RAW_LINK:\n\t\t\tcase ERF_TYPE_INFINIBAND_LINK:\n\t\t\tdefault:\n\t\t\t\t/* Unhandled ERF type.\n\t\t\t\t * Ignore rather than generating error\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t} /* switch type */\n\n\t\t} /* ERF encapsulation */\n\n\t\tif (caplen > p->snapshot)\n\t\t\tcaplen = p->snapshot;\n\n\t\t/* Run the packet filter if there is one. */\n\t\tif ((p->fcode.bf_insns == NULL) || pcap_filter(p->fcode.bf_insns, dp, packet_len, caplen)) {\n\n\t\t\t/* convert between timestamp formats */\n\t\t\tregister unsigned long long ts;\n\n\t\t\tif (IS_BIGENDIAN()) {\n\t\t\t\tts = SWAPLL(header->ts);\n\t\t\t} else {\n\t\t\t\tts = header->ts;\n\t\t\t}\n\n\t\t\tswitch (p->opt.tstamp_precision) {\n\t\t\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\t\t\tticks_per_second = 1000000000;\n\t\t\t\tbreak;\n\t\t\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\t\tdefault:\n\t\t\t\tticks_per_second = 1000000;\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tpcap_header.ts.tv_sec = ts >> 32;\n\t\t\tts = (ts & 0xffffffffULL) * ticks_per_second;\n\t\t\tts += 0x80000000; /* rounding */\n\t\t\tpcap_header.ts.tv_usec = ts >> 32;\n\t\t\tif (pcap_header.ts.tv_usec >= ticks_per_second) {\n\t\t\t\tpcap_header.ts.tv_usec -= ticks_per_second;\n\t\t\t\tpcap_header.ts.tv_sec++;\n\t\t\t}\n\n\t\t\t/* Fill in our own header data */\n\t\t\tpcap_header.caplen = caplen;\n\t\t\tpcap_header.len = packet_len;\n\n\t\t\t/* Count the packet. */\n\t\t\tpd->stat.ps_recv++;\n\n\t\t\t/* Call the user supplied callback function */\n\t\t\tcallback(user, &pcap_header, dp);\n\n\t\t\t/* Only count packets that pass the filter, for consistency with standard Linux behaviour. */\n\t\t\tprocessed++;\n\t\t\tif (processed == cnt && !PACKET_COUNT_IS_UNLIMITED(cnt))\n\t\t\t{\n\t\t\t\t/* Reached the user-specified limit. */\n\t\t\t\treturn cnt;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn processed;\n}",
          "fn_code_pos": [
            [
              338,
              0
            ],
            [
              716,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_read",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndag_inject(pcap_t *p, const void *buf _U_, int size _U_)\n{\n\tpcap_strlcpy(p->errbuf, \"Sending packets isn't supported on DAG cards\",\n\t    PCAP_ERRBUF_SIZE);\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              718,
              0
            ],
            [
              724,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_inject",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int dag_activate(pcap_t* p)\n{\n\tstruct pcap_dag *pd = p->priv;\n\tchar *s;\n\tint n;\n\tdaginf_t* daginf;\n\tchar * newDev = NULL;\n\tchar * device = p->opt.device;\n\tint ret;\n\tdag_size_t mindata;\n\tstruct timeval maxwait;\n\tstruct timeval poll;\n\n\tif (device == NULL) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"device is NULL\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/* Initialize some components of the pcap structure. */\n\tnewDev = (char *)malloc(strlen(device) + 16);\n\tif (newDev == NULL) {\n\t\tret = PCAP_ERROR;\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't allocate string for device name\");\n\t\tgoto fail;\n\t}\n\n\t/* Parse input name to get dag device and stream number if provided */\n\tif (dag_parse_name(device, newDev, strlen(device) + 16, &pd->dag_stream) < 0) {\n\t\t/*\n\t\t * XXX - it'd be nice if this indicated what was wrong\n\t\t * with the name.  Does this reliably set errno?\n\t\t * Should this return PCAP_ERROR_NO_SUCH_DEVICE in some\n\t\t * cases?\n\t\t */\n\t\tret = PCAP_ERROR;\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_parse_name\");\n\t\tgoto fail;\n\t}\n\tdevice = newDev;\n\n\tif (pd->dag_stream%2) {\n\t\tret = PCAP_ERROR;\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"dag_parse_name: tx (even numbered) streams not supported for capture\");\n\t\tgoto fail;\n\t}\n\n\t/* setup device parameters */\n\tif((pd->dag_ref = dag_config_init((char *)device)) == NULL) {\n\t\t/*\n\t\t * XXX - does this reliably set errno?\n\t\t */\n\t\tif (errno == ENOENT)\n\t\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\telse if (errno == EPERM || errno == EACCES)\n\t\t\tret = PCAP_ERROR_PERM_DENIED;\n\t\telse\n\t\t\tret = PCAP_ERROR;\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_config_init %s\", device);\n\t\tgoto fail;\n\t}\n\n\tif((p->fd = dag_config_get_card_fd(pd->dag_ref)) < 0) {\n\t\t/*\n\t\t * XXX - does this reliably set errno?\n\t\t */\n\t\tret = PCAP_ERROR;\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_config_get_card_fd %s\", device);\n\t\tgoto failclose;\n\t}\n\n\t/* Open requested stream. Can fail if already locked or on error */\n\tif (dag_attach_stream64(p->fd, pd->dag_stream, 0, 0) < 0) {\n\t\tret = PCAP_ERROR;\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_attach_stream\");\n\t\tgoto failclose;\n\t}\n\n\t/* Try to find Stream Drop attribute */\n\tpd->drop_attr = kNullAttributeUuid;\n\tpd->dag_root = dag_config_get_root_component(pd->dag_ref);\n\tif ( dag_component_get_subcomponent(pd->dag_root, kComponentStreamFeatures, 0) )\n\t{\n\t\tpd->drop_attr = dag_config_get_indexed_attribute_uuid(pd->dag_ref, kUint32AttributeStreamDropCount, pd->dag_stream/2);\n\t}\n\n\t/* Set up default poll parameters for stream\n\t * Can be overridden by pcap_set_nonblock()\n\t */\n\tif (dag_get_stream_poll64(p->fd, pd->dag_stream,\n\t\t\t\t&mindata, &maxwait, &poll) < 0) {\n\t\tret = PCAP_ERROR;\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_get_stream_poll\");\n\t\tgoto faildetach;\n\t}\n\n\t/* Use the poll time as the required select timeout for callers\n\t * who are using select()/etc. in an event loop waiting for\n\t * packets to arrive.\n\t */\n\tpd->required_select_timeout = poll;\n\tp->required_select_timeout = &pd->required_select_timeout;\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n\tif (p->opt.immediate) {\n\t\t/* Call callback immediately.\n\t\t * XXX - is this the right way to p this?\n\t\t */\n\t\tmindata = 0;\n\t} else {\n\t\t/* Amount of data to collect in Bytes before calling callbacks.\n\t\t * Important for efficiency, but can introduce latency\n\t\t * at low packet rates if to_ms not set!\n\t\t */\n\t\tmindata = 65536;\n\t}\n\n\t/* Obey opt.timeout (was to_ms) if supplied. This is a good idea!\n\t * Recommend 10-100ms. Calls will time out even if no data arrived.\n\t */\n\tmaxwait.tv_sec = p->opt.timeout/1000;\n\tmaxwait.tv_usec = (p->opt.timeout%1000) * 1000;\n\n\tif (dag_set_stream_poll64(p->fd, pd->dag_stream,\n\t\t\t\tmindata, &maxwait, &poll) < 0) {\n\t\tret = PCAP_ERROR;\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_set_stream_poll\");\n\t\tgoto faildetach;\n\t}\n\n        /* XXX Not calling dag_configure() to set slen; this is unsafe in\n\t * multi-stream environments as the gpp config is global.\n         * Once the firmware provides 'per-stream slen' this can be supported\n\t * again via the Config API without side-effects */\n#if 0\n\t/* set the card snap length to the specified snaplen parameter */\n\t/* This is a really bad idea, as different cards have different\n\t * valid slen ranges. Should fix in Config API. */\n\tif (p->snapshot == 0 || p->snapshot > MAX_DAG_SNAPLEN) {\n\t\tp->snapshot = MAX_DAG_SNAPLEN;\n\t} else if (snaplen < MIN_DAG_SNAPLEN) {\n\t\tp->snapshot = MIN_DAG_SNAPLEN;\n\t}\n\t/* snap len has to be a multiple of 4 */\n#endif\n\n\tif(dag_start_stream(p->fd, pd->dag_stream) < 0) {\n\t\tret = PCAP_ERROR;\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_start_stream %s\", device);\n\t\tgoto faildetach;\n\t}\n\n\t/*\n\t * Important! You have to ensure bottom is properly\n\t * initialized to zero on startup, it won't give you\n\t * a compiler warning if you make this mistake!\n\t */\n\tpd->dag_mem_bottom = 0;\n\tpd->dag_mem_top = 0;\n\n\t/*\n\t * Find out how many FCS bits we should strip.\n\t * First, query the card to see if it strips the FCS.\n\t */\n\tdaginf = dag_info(p->fd);\n\tif ((0x4200 == daginf->device_code) || (0x4230 == daginf->device_code))\t{\n\t\t/* DAG 4.2S and 4.23S already strip the FCS.  Stripping the final word again truncates the packet. */\n\t\tpd->dag_fcs_bits = 0;\n\n\t\t/* Note that no FCS will be supplied. */\n\t\tp->linktype_ext = LT_FCS_DATALINK_EXT(0);\n\t} else {\n\t\t/*\n\t\t * Start out assuming it's 32 bits.\n\t\t */\n\t\tpd->dag_fcs_bits = 32;\n\n\t\t/* Allow an environment variable to override. */\n\t\tif ((s = getenv(\"ERF_FCS_BITS\")) != NULL) {\n\t\t\tif ((n = atoi(s)) == 0 || n == 16 || n == 32) {\n\t\t\t\tpd->dag_fcs_bits = n;\n\t\t\t} else {\n\t\t\t\tret = PCAP_ERROR;\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\"pcap_activate %s: bad ERF_FCS_BITS value (%d) in environment\", device, n);\n\t\t\t\tgoto failstop;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Did the user request that they not be stripped?\n\t\t */\n\t\tif ((s = getenv(\"ERF_DONT_STRIP_FCS\")) != NULL) {\n\t\t\t/* Yes.  Note the number of bytes that will be\n\t\t\t   supplied. */\n\t\t\tp->linktype_ext = LT_FCS_DATALINK_EXT(pd->dag_fcs_bits/16);\n\n\t\t\t/* And don't strip them. */\n\t\t\tpd->dag_fcs_bits = 0;\n\t\t}\n\t}\n\n\tpd->dag_timeout\t= p->opt.timeout;\n\n\tp->linktype = -1;\n\tif (dag_get_datalink(p) < 0) {\n\t\tret = PCAP_ERROR;\n\t\tgoto failstop;\n\t}\n\n\tp->bufsize = 0;\n\n\tif (new_pcap_dag(p) < 0) {\n\t\tret = PCAP_ERROR;\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"new_pcap_dag %s\", device);\n\t\tgoto failstop;\n\t}\n\n\t/*\n\t * \"select()\" and \"poll()\" don't work on DAG device descriptors.\n\t */\n\tp->selectable_fd = -1;\n\n\tif (newDev != NULL) {\n\t\tfree((char *)newDev);\n\t}\n\n\tp->read_op = dag_read;\n\tp->inject_op = dag_inject;\n\tp->setfilter_op = install_bpf_program;\n\tp->setdirection_op = NULL; /* Not implemented.*/\n\tp->set_datalink_op = dag_set_datalink;\n\tp->getnonblock_op = pcap_getnonblock_fd;\n\tp->setnonblock_op = dag_setnonblock;\n\tp->stats_op = dag_stats;\n\tp->cleanup_op = dag_platform_cleanup;\n\tpd->stat.ps_drop = 0;\n\tpd->stat.ps_recv = 0;\n\tpd->stat.ps_ifdrop = 0;\n\treturn 0;\n\nfailstop:\n\tif (dag_stop_stream(p->fd, pd->dag_stream) < 0) {\n\t\tfprintf(stderr,\"dag_stop_stream: %s\\n\", strerror(errno));\n\t}\n\nfaildetach:\n\tif (dag_detach_stream(p->fd, pd->dag_stream) < 0)\n\t\tfprintf(stderr,\"dag_detach_stream: %s\\n\", strerror(errno));\n\nfailclose:\n\tdag_config_dispose(pd->dag_ref);\n\t/*\n\t * Note: we don't need to call close(p->fd) or dag_close(p->fd),\n\t * as dag_config_dispose(pd->dag_ref) does this.\n\t *\n\t * Set p->fd to -1 to make sure that's not done.\n\t */\n\tp->fd = -1;\n\tpd->dag_ref = NULL;\n\tdelete_pcap_dag(p);\n\nfail:\n\tpcap_cleanup_live_common(p);\n\tif (newDev != NULL) {\n\t\tfree((char *)newDev);\n\t}\n\n\treturn ret;\n}",
          "fn_code_pos": [
            [
              737,
              0
            ],
            [
              1024,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_activate",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *dag_create(const char *device, char *ebuf, int *is_ours)\n{\n\tconst char *cp;\n\tchar *cpend;\n\tlong devnum;\n\tpcap_t *p;\n\tlong stream = 0;\n\n\t/* Does this look like a DAG device? */\n\tcp = strrchr(device, '/');\n\tif (cp == NULL)\n\t\tcp = device;\n\t/* Does it begin with \"dag\"? */\n\tif (strncmp(cp, \"dag\", 3) != 0) {\n\t\t/* Nope, doesn't begin with \"dag\" */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\t/* Yes - is \"dag\" followed by a number from 0 to DAG_MAX_BOARDS-1 */\n\tcp += 3;\n\tdevnum = strtol(cp, &cpend, 10);\n\tif (*cpend == ':') {\n\t\t/* Followed by a stream number. */\n\t\tstream = strtol(++cpend, &cpend, 10);\n\t}\n\n\tif (cpend == cp || *cpend != '\\0') {\n\t\t/* Not followed by a number. */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\tif (devnum < 0 || devnum >= DAG_MAX_BOARDS) {\n\t\t/* Followed by a non-valid number. */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\tif (stream <0 || stream >= DAG_STREAM_MAX) {\n\t\t/* Followed by a non-valid stream number. */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\t/* OK, it's probably ours. */\n\t*is_ours = 1;\n\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_dag));\n\tif (p == NULL)\n\t\treturn NULL;\n\n\tp->activate_op = dag_activate;\n\n\t/*\n\t * We claim that we support microsecond and nanosecond time\n\t * stamps.\n\t *\n\t * XXX Our native precision is 2^-32s, but libpcap doesn't support\n\t * power of two precisions yet. We can convert to either MICRO or NANO.\n\t */\n\tp->tstamp_precision_count = 2;\n\tp->tstamp_precision_list = malloc(2 * sizeof(u_int));\n\tif (p->tstamp_precision_list == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tpcap_close(p);\n\t\treturn NULL;\n\t}\n\tp->tstamp_precision_list[0] = PCAP_TSTAMP_PRECISION_MICRO;\n\tp->tstamp_precision_list[1] = PCAP_TSTAMP_PRECISION_NANO;\n\treturn p;\n}",
          "fn_code_pos": [
            [
              1026,
              0
            ],
            [
              1097,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static int\ndag_stats(pcap_t *p, struct pcap_stat *ps) {\n\tstruct pcap_dag *pd = p->priv;\n\tuint32_t stream_drop;\n\tdag_err_t dag_error;\n\n\t/*\n\t * Packet records received (ps_recv) are counted in dag_read().\n\t * Packet records dropped (ps_drop) are read from Stream Drop attribute if present,\n\t * otherwise integrate the ERF Header lctr counts (if available) in dag_read().\n\t * We are reporting that no records are dropped by the card/driver (ps_ifdrop).\n\t */\n\n\tif(pd->drop_attr != kNullAttributeUuid) {\n\t\t/* Note this counter is cleared at start of capture and will wrap at UINT_MAX.\n\t\t * The application is responsible for polling ps_drop frequently enough\n\t\t * to detect each wrap and integrate total drop with a wider counter */\n\t\tif ((dag_error = dag_config_get_uint32_attribute_ex(pd->dag_ref, pd->drop_attr, &stream_drop) == kDagErrNone)) {\n\t\t\tpd->stat.ps_drop = stream_drop;\n\t\t} else {\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"reading stream drop attribute: %s\",\n\t\t\t\t dag_config_strerror(dag_error));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t*ps = pd->stat;\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1099,
              0
            ],
            [
              1128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_stats",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\ndag_findalldevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\tchar name[12];\t/* XXX - pick a size */\n\tint c;\n\tchar dagname[DAGNAME_BUFSIZE];\n\tint dagstream;\n\tint dagfd;\n\tdag_card_inf_t *inf;\n\tchar *description;\n\tint stream, rxstreams;\n\n\t/* Try all the DAGs 0-DAG_MAX_BOARDS */\n\tfor (c = 0; c < DAG_MAX_BOARDS; c++) {\n\t\tpcap_snprintf(name, 12, \"dag%d\", c);\n\t\tif (-1 == dag_parse_name(name, dagname, DAGNAME_BUFSIZE, &dagstream))\n\t\t{\n\t\t\t(void) pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"dag: device name %s can't be parsed\", name);\n\t\t\treturn (-1);\n\t\t}\n\t\tif ( (dagfd = dag_open(dagname)) >= 0 ) {\n\t\t\tdescription = NULL;\n\t\t\tif ((inf = dag_pciinfo(dagfd)))\n\t\t\t\tdescription = dag_device_name(inf->device_code, 1);\n\t\t\t/*\n\t\t\t * XXX - is there a way to determine whether\n\t\t\t * the card is plugged into a network or not?\n\t\t\t * If so, we should check that and set\n\t\t\t * PCAP_IF_CONNECTION_STATUS_CONNECTED or\n\t\t\t * PCAP_IF_CONNECTION_STATUS_DISCONNECTED.\n\t\t\t *\n\t\t\t * Also, are there notions of \"up\" and \"running\"?\n\t\t\t */\n\t\t\tif (add_dev(devlistp, name, 0, description, errbuf) == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Failure.\n\t\t\t\t */\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\trxstreams = dag_rx_get_stream_count(dagfd);\n\t\t\tfor(stream=0;stream<DAG_STREAM_MAX;stream+=2) {\n\t\t\t\tif (0 == dag_attach_stream64(dagfd, stream, 0, 0)) {\n\t\t\t\t\tdag_detach_stream(dagfd, stream);\n\n\t\t\t\t\tpcap_snprintf(name,  10, \"dag%d:%d\", c, stream);\n\t\t\t\t\tif (add_dev(devlistp, name, 0, description, errbuf) == NULL) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Failure.\n\t\t\t\t\t\t */\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\t}\n\n\t\t\t\t\trxstreams--;\n\t\t\t\t\tif(rxstreams <= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdag_close(dagfd);\n\t\t}\n\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1133,
              0
            ],
            [
              1197,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndag_set_datalink(pcap_t *p, int dlt)\n{\n\tp->linktype = dlt;\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1199,
              0
            ],
            [
              1205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_set_datalink",
            "parameters": {
              "p": "pcap_t",
              "dlt": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndag_setnonblock(pcap_t *p, int nonblock)\n{\n\tstruct pcap_dag *pd = p->priv;\n\tdag_size_t mindata;\n\tstruct timeval maxwait;\n\tstruct timeval poll;\n\n\t/*\n\t * Set non-blocking mode on the FD.\n\t * XXX - is that necessary?  If not, don't bother calling it,\n\t * and have a \"dag_getnonblock()\" function that looks at\n\t * \"pd->dag_flags\".\n\t */\n\tif (pcap_setnonblock_fd(p, nonblock) < 0)\n\t\treturn (-1);\n\n\tif (dag_get_stream_poll64(p->fd, pd->dag_stream,\n\t\t\t\t&mindata, &maxwait, &poll) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_get_stream_poll\");\n\t\treturn -1;\n\t}\n\n\t/* Amount of data to collect in Bytes before calling callbacks.\n\t * Important for efficiency, but can introduce latency\n\t * at low packet rates if to_ms not set!\n\t */\n\tif(nonblock)\n\t\tmindata = 0;\n\telse\n\t\tmindata = 65536;\n\n\tif (dag_set_stream_poll64(p->fd, pd->dag_stream,\n\t\t\t\tmindata, &maxwait, &poll) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"dag_set_stream_poll\");\n\t\treturn -1;\n\t}\n\n\tif (nonblock) {\n\t\tpd->dag_flags |= DAGF_NONBLOCK;\n\t} else {\n\t\tpd->dag_flags &= ~DAGF_NONBLOCK;\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1207,
              0
            ],
            [
              1253,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_setnonblock",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_create_interface(const char *device, char *errbuf)\n{\n\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t    \"This version of libpcap only supports DAG cards\");\n\treturn NULL;\n}",
          "fn_code_pos": [
            [
              1425,
              0
            ],
            [
              1431,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "errbuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING \" (DAG-only)\");\n}",
          "fn_code_pos": [
            [
              1436,
              0
            ],
            [
              1440,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "dag_stats(pcap_t *p, struct pcap_stat *ps)",
          "fn_dec_pos": [
            [
              210,
              11
            ],
            [
              210,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_stats",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "dag_set_datalink(pcap_t *p, int dlt)",
          "fn_dec_pos": [
            [
              211,
              11
            ],
            [
              211,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_set_datalink",
            "parameters": {
              "p": "pcap_t",
              "dlt": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "dag_get_datalink(pcap_t *p)",
          "fn_dec_pos": [
            [
              212,
              11
            ],
            [
              212,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_get_datalink",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "dag_setnonblock(pcap_t *p, int nonblock)",
          "fn_dec_pos": [
            [
              213,
              11
            ],
            [
              213,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_setnonblock",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "dag_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              1026,
              8
            ],
            [
              1026,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "dag_get_datalink(pcap_t *p)",
          "fn_dec_pos": [
            [
              1256,
              0
            ],
            [
              1256,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_get_datalink",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_create_interface(const char *device, char *errbuf)",
          "fn_dec_pos": [
            [
              1426,
              0
            ],
            [
              1426,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              1437,
              0
            ],
            [
              1437,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct sunatm_hdr {\n\tunsigned char\tflags;\t\t/* destination and traffic type */\n\tunsigned char\tvpi;\t\t/* VPI */\n\tunsigned short\tvci;\t\t/* VCI */\n}",
          {
            "flags": "unsigned char",
            "vpi": "unsigned char",
            "vci": "unsigned short"
          },
          "sunatm_hdr",
          [
            161,
            0
          ],
          [
            165,
            1
          ]
        ],
        [
          "struct pcap_dag {\n\tstruct pcap_stat stat;\n\tu_char\t*dag_mem_bottom;\t/* DAG card current memory bottom pointer */\n\tu_char\t*dag_mem_top;\t/* DAG card current memory top pointer */\n\tint\tdag_fcs_bits;\t/* Number of checksum bits from link layer */\n\tint\tdag_flags;\t/* Flags */\n\tint\tdag_stream;\t/* DAG stream number */\n\tint\tdag_timeout;\t/* timeout specified to pcap_open_live.\n\t\t\t\t * Same as in linux above, introduce\n\t\t\t\t * generally? */\n\tdag_card_ref_t dag_ref; /* DAG Configuration/Status API card reference */\n\tdag_component_t dag_root;\t/* DAG CSAPI Root component */\n\tattr_uuid_t drop_attr;  /* DAG Stream Drop Attribute handle, if available */\n\tstruct timeval required_select_timeout;\n\t\t\t\t/* Timeout caller must use in event loops */\n}",
          {
            "stat": "struct pcap_stat",
            "*dag_mem_bottom": "u_char",
            "*dag_mem_top": "u_char",
            "dag_fcs_bits": "int",
            "dag_flags": "int",
            "dag_stream": "int",
            "dag_timeout": "int",
            "dag_ref": "dag_card_ref_t",
            "dag_root": "dag_component_t",
            "drop_attr": "attr_uuid_t",
            "required_select_timeout": "struct timeval"
          },
          "pcap_dag",
          [
            170,
            0
          ],
          [
            185,
            1
          ]
        ],
        [
          "typedef struct pcap_dag_node {\n\tstruct pcap_dag_node *next;\n\tpcap_t *p;\n\tpid_t pid;\n} pcap_dag_node_t;",
          {
            "*next": "struct pcap_dag_node",
            "*p": "pcap_t",
            "pid": "pid_t"
          },
          "pcap_dag_node_t",
          [
            187,
            0
          ],
          [
            191,
            18
          ]
        ],
        [
          "struct mbuf",
          {},
          "",
          [
            28,
            0
          ],
          [
            28,
            11
          ]
        ],
        [
          "struct rtentry",
          {},
          "",
          [
            29,
            0
          ],
          [
            29,
            14
          ]
        ],
        [
          "struct sunatm_hdr {\n\tunsigned char\tflags;\t\t/* destination and traffic type */\n\tunsigned char\tvpi;\t\t/* VPI */\n\tunsigned short\tvci;\t\t/* VCI */\n}",
          {
            "flags": "unsigned char",
            "vpi": "unsigned char",
            "vci": "unsigned short"
          },
          "sunatm_hdr",
          [
            161,
            0
          ],
          [
            165,
            1
          ]
        ],
        [
          "struct pcap_dag {\n\tstruct pcap_stat stat;\n\tu_char\t*dag_mem_bottom;\t/* DAG card current memory bottom pointer */\n\tu_char\t*dag_mem_top;\t/* DAG card current memory top pointer */\n\tint\tdag_fcs_bits;\t/* Number of checksum bits from link layer */\n\tint\tdag_flags;\t/* Flags */\n\tint\tdag_stream;\t/* DAG stream number */\n\tint\tdag_timeout;\t/* timeout specified to pcap_open_live.\n\t\t\t\t * Same as in linux above, introduce\n\t\t\t\t * generally? */\n\tdag_card_ref_t dag_ref; /* DAG Configuration/Status API card reference */\n\tdag_component_t dag_root;\t/* DAG CSAPI Root component */\n\tattr_uuid_t drop_attr;  /* DAG Stream Drop Attribute handle, if available */\n\tstruct timeval required_select_timeout;\n\t\t\t\t/* Timeout caller must use in event loops */\n}",
          {
            "stat": "struct pcap_stat",
            "*dag_mem_bottom": "u_char",
            "*dag_mem_top": "u_char",
            "dag_fcs_bits": "int",
            "dag_flags": "int",
            "dag_stream": "int",
            "dag_timeout": "int",
            "dag_ref": "dag_card_ref_t",
            "dag_root": "dag_component_t",
            "drop_attr": "attr_uuid_t",
            "required_select_timeout": "struct timeval"
          },
          "pcap_dag",
          [
            170,
            0
          ],
          [
            185,
            1
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            171,
            1
          ],
          [
            171,
            17
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            183,
            1
          ],
          [
            183,
            15
          ]
        ],
        [
          "typedef struct pcap_dag_node {\n\tstruct pcap_dag_node *next;\n\tpcap_t *p;\n\tpid_t pid;\n} pcap_dag_node_t;",
          {
            "*next": "struct pcap_dag_node",
            "*p": "pcap_t",
            "pid": "pid_t"
          },
          "pcap_dag_node_t",
          [
            187,
            0
          ],
          [
            191,
            18
          ]
        ],
        [
          "struct pcap_dag_node",
          {},
          "",
          [
            188,
            1
          ],
          [
            188,
            21
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            210,
            32
          ],
          [
            210,
            48
          ]
        ],
        [
          "struct pcap_dag",
          {},
          "",
          [
            241,
            1
          ],
          [
            241,
            16
          ]
        ],
        [
          "struct pcap_dag",
          {},
          "",
          [
            341,
            1
          ],
          [
            341,
            16
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            399,
            2
          ],
          [
            399,
            20
          ]
        ],
        [
          "struct sunatm_hdr",
          {},
          "",
          [
            526,
            5
          ],
          [
            526,
            22
          ]
        ],
        [
          "struct sunatm_hdr",
          {},
          "",
          [
            526,
            34
          ],
          [
            526,
            51
          ]
        ],
        [
          "struct pcap_dag",
          {},
          "",
          [
            739,
            1
          ],
          [
            739,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            747,
            1
          ],
          [
            747,
            15
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            748,
            1
          ],
          [
            748,
            15
          ]
        ],
        [
          "struct pcap_dag",
          {},
          "",
          [
            1073,
            38
          ],
          [
            1073,
            53
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            1100,
            21
          ],
          [
            1100,
            37
          ]
        ],
        [
          "struct pcap_dag",
          {},
          "",
          [
            1101,
            1
          ],
          [
            1101,
            16
          ]
        ],
        [
          "struct pcap_dag",
          {},
          "",
          [
            1210,
            1
          ],
          [
            1210,
            16
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            1212,
            1
          ],
          [
            1212,
            15
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            1213,
            1
          ],
          [
            1213,
            15
          ]
        ],
        [
          "struct pcap_dag",
          {},
          "",
          [
            1258,
            1
          ],
          [
            1258,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <sys/param.h>\t\t\t/* optionally get BSD define */\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <sys/mman.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <net/if.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"dagnew.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include \"dagapi.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"dagpci.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include \"dag_config_api.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"pcap-dag.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-netfilter-linux.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nnetfilter_read_linux(pcap_t *handle, int max_packets, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_netfilter *handlep = handle->priv;\n\tregister u_char *bp, *ep;\n\tint count = 0;\n\tssize_t len;\n\n\t/*\n\t * Has \"pcap_breakloop()\" been called?\n\t */\n\tif (handle->break_loop) {\n\t\t/*\n\t\t * Yes - clear the flag that indicates that it\n\t\t * has, and return PCAP_ERROR_BREAK to indicate\n\t\t * that we were told to break out of the loop.\n\t\t */\n\t\thandle->break_loop = 0;\n\t\treturn PCAP_ERROR_BREAK;\n\t}\n\tlen = handle->cc;\n\tif (len == 0) {\n\t\t/*\n\t\t * The buffer is empty; refill it.\n\t\t *\n\t\t * We ignore EINTR, as that might just be due to a signal\n\t\t * being delivered - if the signal should interrupt the\n\t\t * loop, the signal handler should call pcap_breakloop()\n\t\t * to set handle->break_loop (we ignore it on other\n\t\t * platforms as well).\n\t\t */\n\t\tdo {\n\t\t\tlen = recv(handle->fd, handle->buffer, handle->bufsize, 0);\n\t\t\tif (handle->break_loop) {\n\t\t\t\thandle->break_loop = 0;\n\t\t\t\treturn PCAP_ERROR_BREAK;\n\t\t\t}\n\t\t\tif (errno == ENOBUFS)\n\t\t\t\thandlep->packets_nobufs++;\n\t\t} while ((len == -1) && (errno == EINTR || errno == ENOBUFS));\n\n\t\tif (len < 0) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"Can't receive packet\");\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\n\t\tbp = (unsigned char *)handle->buffer;\n\t} else\n\t\tbp = handle->bp;\n\tep = bp + len;\n\twhile (bp < ep) {\n\t\tconst struct nlmsghdr *nlh = (const struct nlmsghdr *) bp;\n\t\tuint32_t msg_len;\n\t\tnftype_t type = OTHER;\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t * If so, return immediately - if we haven't read any\n\t\t * packets, clear the flag and return PCAP_ERROR_BREAK\n\t\t * to indicate that we were told to break out of the loop,\n\t\t * otherwise leave the flag set, so that the *next* call\n\t\t * will break out of the loop without having read any\n\t\t * packets, and return the number of packets we've\n\t\t * processed so far.\n\t\t */\n\t\tif (handle->break_loop) {\n\t\t\thandle->bp = bp;\n\t\t\thandle->cc = (int)(ep - bp);\n\t\t\tif (count == 0) {\n\t\t\t\thandle->break_loop = 0;\n\t\t\t\treturn PCAP_ERROR_BREAK;\n\t\t\t} else\n\t\t\t\treturn count;\n\t\t}\n\t\tif (ep - bp < NLMSG_SPACE(0)) {\n\t\t\t/*\n\t\t\t * There's less than one netlink message left\n\t\t\t * in the buffer.  Give up.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\tif (nlh->nlmsg_len < sizeof(struct nlmsghdr) || (u_int)len < nlh->nlmsg_len) {\n\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Message truncated: (got: %zd) (nlmsg_len: %u)\", len, nlh->nlmsg_len);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (NFNL_SUBSYS_ID(nlh->nlmsg_type) == NFNL_SUBSYS_ULOG &&\n\t\t    NFNL_MSG_TYPE(nlh->nlmsg_type) == NFULNL_MSG_PACKET)\n\t\t\ttype = NFLOG;\n\t\telse if (NFNL_SUBSYS_ID(nlh->nlmsg_type) == NFNL_SUBSYS_QUEUE &&\n\t\t         NFNL_MSG_TYPE(nlh->nlmsg_type) == NFQNL_MSG_PACKET)\n\t\t\ttype = NFQUEUE;\n\n\t\tif (type != OTHER) {\n\t\t\tconst unsigned char *payload = NULL;\n\t\t\tstruct pcap_pkthdr pkth;\n\n\t\t\tconst struct nfgenmsg *nfg = NULL;\n\t\t\tint id = 0;\n\n\t\t\tif (handle->linktype != DLT_NFLOG) {\n\t\t\t\tconst struct nfattr *payload_attr = NULL;\n\n\t\t\t\tif (nlh->nlmsg_len < HDR_LENGTH) {\n\t\t\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Malformed message: (nlmsg_len: %u)\", nlh->nlmsg_len);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tnfg = NLMSG_DATA(nlh);\n\t\t\t\tif (nlh->nlmsg_len > HDR_LENGTH) {\n\t\t\t\t\tstruct nfattr *attr = NFM_NFA(nfg);\n\t\t\t\t\tint attr_len = nlh->nlmsg_len - NLMSG_ALIGN(HDR_LENGTH);\n\n\t\t\t\t\twhile (NFA_OK(attr, attr_len)) {\n\t\t\t\t\t\tif (type == NFQUEUE) {\n\t\t\t\t\t\t\tswitch (NFA_TYPE(attr)) {\n\t\t\t\t\t\t\t\tcase NFQA_PACKET_HDR:\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tconst struct nfqnl_msg_packet_hdr *pkt_hdr = (const struct nfqnl_msg_packet_hdr *) NFA_DATA(attr);\n\n\t\t\t\t\t\t\t\t\t\tid = ntohl(pkt_hdr->packet_id);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcase NFQA_PAYLOAD:\n\t\t\t\t\t\t\t\t\tpayload_attr = attr;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if (type == NFLOG) {\n\t\t\t\t\t\t\tswitch (NFA_TYPE(attr)) {\n\t\t\t\t\t\t\t\tcase NFULA_PAYLOAD:\n\t\t\t\t\t\t\t\t\tpayload_attr = attr;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tattr = NFA_NEXT(attr, attr_len);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (payload_attr) {\n\t\t\t\t\tpayload = NFA_DATA(payload_attr);\n\t\t\t\t\tpkth.len = pkth.caplen = NFA_PAYLOAD(payload_attr);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tpayload = NLMSG_DATA(nlh);\n\t\t\t\tpkth.caplen = pkth.len = nlh->nlmsg_len-NLMSG_ALIGN(sizeof(struct nlmsghdr));\n\t\t\t}\n\n\t\t\tif (payload) {\n\t\t\t\t/* pkth.caplen = min (payload_len, handle->snapshot); */\n\n\t\t\t\tgettimeofday(&pkth.ts, NULL);\n\t\t\t\tif (handle->fcode.bf_insns == NULL ||\n\t\t\t\t\t\tpcap_filter(handle->fcode.bf_insns, payload, pkth.len, pkth.caplen))\n\t\t\t\t{\n\t\t\t\t\thandlep->packets_read++;\n\t\t\t\t\tcallback(user, &pkth, payload);\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (type == NFQUEUE) {\n\t\t\t\t/* XXX, possible responses: NF_DROP, NF_ACCEPT, NF_STOLEN, NF_QUEUE, NF_REPEAT, NF_STOP */\n\t\t\t\t/* if type == NFQUEUE, handle->linktype is always != DLT_NFLOG,\n\t\t\t\t   so nfg is always initialized to NLMSG_DATA(nlh). */\n\t\t\t\tif (nfg != NULL)\n\t\t\t\t\tnfqueue_send_verdict(handle, ntohs(nfg->res_id), id, NF_ACCEPT);\n\t\t\t}\n\t\t}\n\n\t\tmsg_len = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\t/*\n\t\t * If the message length would run past the end of the\n\t\t * buffer, truncate it to the remaining space in the\n\t\t * buffer.\n\t\t */\n\t\tif (msg_len > ep - bp)\n\t\t\tmsg_len = (uint32_t)(ep - bp);\n\n\t\tbp += msg_len;\n\t\tif (count >= max_packets && !PACKET_COUNT_IS_UNLIMITED(max_packets)) {\n\t\t\thandle->bp = bp;\n\t\t\thandle->cc = (int)(ep - bp);\n\t\t\tif (handle->cc < 0)\n\t\t\t\thandle->cc = 0;\n\t\t\treturn count;\n\t\t}\n\t}\n\n\thandle->cc = 0;\n\treturn count;\n}",
          "fn_code_pos": [
            [
              87,
              0
            ],
            [
              280,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "netfilter_read_linux",
            "parameters": {
              "handle": "pcap_t",
              "max_packets": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nnetfilter_set_datalink(pcap_t *handle, int dlt)\n{\n\thandle->linktype = dlt;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              282,
              0
            ],
            [
              287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "netfilter_set_datalink",
            "parameters": {
              "handle": "pcap_t",
              "dlt": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nnetfilter_stats_linux(pcap_t *handle, struct pcap_stat *stats)\n{\n\tstruct pcap_netfilter *handlep = handle->priv;\n\n\tstats->ps_recv = handlep->packets_read;\n\tstats->ps_drop = handlep->packets_nobufs;\n\tstats->ps_ifdrop = 0;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              289,
              0
            ],
            [
              298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "netfilter_stats_linux",
            "parameters": {
              "handle": "pcap_t",
              "stats": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nnetfilter_inject_linux(pcap_t *handle, const void *buf _U_, int size _U_)\n{\n\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Packet injection is not supported on netfilter devices\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              300,
              0
            ],
            [
              306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "netfilter_inject_linux",
            "parameters": {
              "handle": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nnetfilter_send_config_msg(const pcap_t *handle, uint16_t msg_type, int ack, u_int8_t family, u_int16_t res_id, const struct my_nfattr *mynfa)\n{\n\tchar buf[1024] __attribute__ ((aligned));\n\n\tstruct nlmsghdr *nlh = (struct nlmsghdr *) buf;\n\tstruct nfgenmsg *nfg = (struct nfgenmsg *) (buf + sizeof(struct nlmsghdr));\n\n\tstruct sockaddr_nl snl;\n\tstatic unsigned int seq_id;\n\n\tif (!seq_id)\n\t\tseq_id = time(NULL);\n\t++seq_id;\n\n\tnlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nfgenmsg));\n\tnlh->nlmsg_type = msg_type;\n\tnlh->nlmsg_flags = NLM_F_REQUEST | (ack ? NLM_F_ACK : 0);\n\tnlh->nlmsg_pid = 0;\t/* to kernel */\n\tnlh->nlmsg_seq = seq_id;\n\n\tnfg->nfgen_family = family;\n\tnfg->version = NFNETLINK_V0;\n\tnfg->res_id = htons(res_id);\n\n\tif (mynfa) {\n\t\tstruct nfattr *nfa = (struct nfattr *) (buf + NLMSG_ALIGN(nlh->nlmsg_len));\n\n\t\tnfa->nfa_type = mynfa->nfa_type;\n\t\tnfa->nfa_len = NFA_LENGTH(mynfa->nfa_len);\n\t\tmemcpy(NFA_DATA(nfa), mynfa->data, mynfa->nfa_len);\n\t\tnlh->nlmsg_len = NLMSG_ALIGN(nlh->nlmsg_len) + NFA_ALIGN(nfa->nfa_len);\n\t}\n\n\tmemset(&snl, 0, sizeof(snl));\n\tsnl.nl_family = AF_NETLINK;\n\n\tif (sendto(handle->fd, nlh, nlh->nlmsg_len, 0, (struct sockaddr *) &snl, sizeof(snl)) == -1)\n\t\treturn -1;\n\n\tif (!ack)\n\t\treturn 0;\n\n\t/* waiting for reply loop */\n\tdo {\n\t\tsocklen_t addrlen = sizeof(snl);\n\t\tint len;\n\n\t\t/* ignore interrupt system call error */\n\t\tdo {\n\t\t\t/*\n\t\t\t * The buffer is not so big that its size won't\n\t\t\t * fit into an int.\n\t\t\t */\n\t\t\tlen = (int)recvfrom(handle->fd, buf, sizeof(buf), 0, (struct sockaddr *) &snl, &addrlen);\n\t\t} while ((len == -1) && (errno == EINTR));\n\n\t\tif (len <= 0)\n\t\t\treturn len;\n\n\t\tif (addrlen != sizeof(snl) || snl.nl_family != AF_NETLINK) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tnlh = (struct nlmsghdr *) buf;\n\t\tif (snl.nl_pid != 0 || seq_id != nlh->nlmsg_seq)\t/* if not from kernel or wrong sequence skip */\n\t\t\tcontinue;\n\n\t\twhile ((u_int)len >= NLMSG_SPACE(0) && NLMSG_OK(nlh, (u_int)len)) {\n\t\t\tif (nlh->nlmsg_type == NLMSG_ERROR || (nlh->nlmsg_type == NLMSG_DONE && nlh->nlmsg_flags & NLM_F_MULTI)) {\n\t\t\t\tif (nlh->nlmsg_len < NLMSG_ALIGN(sizeof(struct nlmsgerr))) {\n\t\t\t\t\terrno = EBADMSG;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\terrno = -(*((int *)NLMSG_DATA(nlh)));\n\t\t\t\treturn (errno == 0) ? 0 : -1;\n\t\t\t}\n\t\t\tnlh = NLMSG_NEXT(nlh, len);\n\t\t}\n\t} while (1);\n\n\treturn -1; /* never here */\n}",
          "fn_code_pos": [
            [
              314,
              0
            ],
            [
              397,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "netfilter_send_config_msg",
            "parameters": {
              "handle": "pcap_t",
              "msg_type": "uint16_t",
              "ack": "int",
              "family": "u_int8_t",
              "res_id": "u_int16_t",
              "mynfa": "struct my_nfattr"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nnflog_send_config_msg(const pcap_t *handle, uint8_t family, u_int16_t group_id, const struct my_nfattr *mynfa)\n{\n\treturn netfilter_send_config_msg(handle, (NFNL_SUBSYS_ULOG << 8) | NFULNL_MSG_CONFIG, 1, family, group_id, mynfa);\n}",
          "fn_code_pos": [
            [
              399,
              0
            ],
            [
              403,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nflog_send_config_msg",
            "parameters": {
              "handle": "pcap_t",
              "family": "uint8_t",
              "group_id": "u_int16_t",
              "mynfa": "struct my_nfattr"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nnflog_send_config_cmd(const pcap_t *handle, uint16_t group_id, u_int8_t cmd, u_int8_t family)\n{\n\tstruct nfulnl_msg_config_cmd msg;\n\tstruct my_nfattr nfa;\n\n\tmsg.command = cmd;\n\n\tnfa.data = &msg;\n\tnfa.nfa_type = NFULA_CFG_CMD;\n\tnfa.nfa_len = sizeof(msg);\n\n\treturn nflog_send_config_msg(handle, family, group_id, &nfa);\n}",
          "fn_code_pos": [
            [
              405,
              0
            ],
            [
              418,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nflog_send_config_cmd",
            "parameters": {
              "handle": "pcap_t",
              "group_id": "uint16_t",
              "cmd": "u_int8_t",
              "family": "u_int8_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nnflog_send_config_mode(const pcap_t *handle, uint16_t group_id, u_int8_t copy_mode, u_int32_t copy_range)\n{\n\tstruct nfulnl_msg_config_mode msg;\n\tstruct my_nfattr nfa;\n\n\tmsg.copy_range = htonl(copy_range);\n\tmsg.copy_mode = copy_mode;\n\n\tnfa.data = &msg;\n\tnfa.nfa_type = NFULA_CFG_MODE;\n\tnfa.nfa_len = sizeof(msg);\n\n\treturn nflog_send_config_msg(handle, AF_UNSPEC, group_id, &nfa);\n}",
          "fn_code_pos": [
            [
              420,
              0
            ],
            [
              434,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nflog_send_config_mode",
            "parameters": {
              "handle": "pcap_t",
              "group_id": "uint16_t",
              "copy_mode": "u_int8_t",
              "copy_range": "u_int32_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nnfqueue_send_verdict(const pcap_t *handle, uint16_t group_id, u_int32_t id, u_int32_t verdict)\n{\n\tstruct nfqnl_msg_verdict_hdr msg;\n\tstruct my_nfattr nfa;\n\n\tmsg.id = htonl(id);\n\tmsg.verdict = htonl(verdict);\n\n\tnfa.data = &msg;\n\tnfa.nfa_type = NFQA_VERDICT_HDR;\n\tnfa.nfa_len = sizeof(msg);\n\n\treturn netfilter_send_config_msg(handle, (NFNL_SUBSYS_QUEUE << 8) | NFQNL_MSG_VERDICT, 0, AF_UNSPEC, group_id, &nfa);\n}",
          "fn_code_pos": [
            [
              436,
              0
            ],
            [
              450,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nfqueue_send_verdict",
            "parameters": {
              "handle": "pcap_t",
              "group_id": "uint16_t",
              "id": "u_int32_t",
              "verdict": "u_int32_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nnfqueue_send_config_msg(const pcap_t *handle, uint8_t family, u_int16_t group_id, const struct my_nfattr *mynfa)\n{\n\treturn netfilter_send_config_msg(handle, (NFNL_SUBSYS_QUEUE << 8) | NFQNL_MSG_CONFIG, 1, family, group_id, mynfa);\n}",
          "fn_code_pos": [
            [
              452,
              0
            ],
            [
              456,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nfqueue_send_config_msg",
            "parameters": {
              "handle": "pcap_t",
              "family": "uint8_t",
              "group_id": "u_int16_t",
              "mynfa": "struct my_nfattr"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nnfqueue_send_config_cmd(const pcap_t *handle, uint16_t group_id, u_int8_t cmd, u_int16_t pf)\n{\n\tstruct nfqnl_msg_config_cmd msg;\n\tstruct my_nfattr nfa;\n\n\tmsg.command = cmd;\n\tmsg.pf = htons(pf);\n\n\tnfa.data = &msg;\n\tnfa.nfa_type = NFQA_CFG_CMD;\n\tnfa.nfa_len = sizeof(msg);\n\n\treturn nfqueue_send_config_msg(handle, AF_UNSPEC, group_id, &nfa);\n}",
          "fn_code_pos": [
            [
              458,
              0
            ],
            [
              472,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nfqueue_send_config_cmd",
            "parameters": {
              "handle": "pcap_t",
              "group_id": "uint16_t",
              "cmd": "u_int8_t",
              "pf": "u_int16_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nnfqueue_send_config_mode(const pcap_t *handle, uint16_t group_id, u_int8_t copy_mode, u_int32_t copy_range)\n{\n\tstruct nfqnl_msg_config_params msg;\n\tstruct my_nfattr nfa;\n\n\tmsg.copy_range = htonl(copy_range);\n\tmsg.copy_mode = copy_mode;\n\n\tnfa.data = &msg;\n\tnfa.nfa_type = NFQA_CFG_PARAMS;\n\tnfa.nfa_len = sizeof(msg);\n\n\treturn nfqueue_send_config_msg(handle, AF_UNSPEC, group_id, &nfa);\n}",
          "fn_code_pos": [
            [
              474,
              0
            ],
            [
              488,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nfqueue_send_config_mode",
            "parameters": {
              "handle": "pcap_t",
              "group_id": "uint16_t",
              "copy_mode": "u_int8_t",
              "copy_range": "u_int32_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nnetfilter_activate(pcap_t* handle)\n{\n\tconst char *dev = handle->opt.device;\n\tunsigned short groups[32];\n\tint group_count = 0;\n\tnftype_t type = OTHER;\n\tint i;\n\n \tif (strncmp(dev, NFLOG_IFACE, strlen(NFLOG_IFACE)) == 0) {\n \t\tdev += strlen(NFLOG_IFACE);\n\t\ttype = NFLOG;\n\n\t} else if (strncmp(dev, NFQUEUE_IFACE, strlen(NFQUEUE_IFACE)) == 0) {\n\t\tdev += strlen(NFQUEUE_IFACE);\n\t\ttype = NFQUEUE;\n\t}\n\n\tif (type != OTHER && *dev == ':') {\n\t\tdev++;\n\t\twhile (*dev) {\n\t\t\tlong int group_id;\n\t\t\tchar *end_dev;\n\n\t\t\tif (group_count == 32) {\n\t\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\t\"Maximum 32 netfilter groups! dev: %s\",\n\t\t\t\t\t\thandle->opt.device);\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\n\t\t\tgroup_id = strtol(dev, &end_dev, 0);\n\t\t\tif (end_dev != dev) {\n\t\t\t\tif (group_id < 0 || group_id > 65535) {\n\t\t\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t\t\t\"Netfilter group range from 0 to 65535 (got %ld)\",\n\t\t\t\t\t\t\tgroup_id);\n\t\t\t\t\treturn PCAP_ERROR;\n\t\t\t\t}\n\n\t\t\t\tgroups[group_count++] = (unsigned short) group_id;\n\t\t\t\tdev = end_dev;\n\t\t\t}\n\t\t\tif (*dev != ',')\n\t\t\t\tbreak;\n\t\t\tdev++;\n\t\t}\n\t}\n\n\tif (type == OTHER || *dev) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\"Can't get netfilter group(s) index from %s\",\n\t\t\t\thandle->opt.device);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/* if no groups, add default: 0 */\n\tif (!group_count) {\n\t\tgroups[0] = 0;\n\t\tgroup_count = 1;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)\n\t\thandle->snapshot = MAXIMUM_SNAPLEN;\n\n\t/* Initialize some components of the pcap structure. */\n\thandle->bufsize = 128 + handle->snapshot;\n\thandle->offset = 0;\n\thandle->read_op = netfilter_read_linux;\n\thandle->inject_op = netfilter_inject_linux;\n\thandle->setfilter_op = install_bpf_program; /* no kernel filtering */\n\thandle->setdirection_op = NULL;\n\thandle->set_datalink_op = netfilter_set_datalink;\n\thandle->getnonblock_op = pcap_getnonblock_fd;\n\thandle->setnonblock_op = pcap_setnonblock_fd;\n\thandle->stats_op = netfilter_stats_linux;\n\n\t/* Create netlink socket */\n\thandle->fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER);\n\tif (handle->fd < 0) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't create raw socket\");\n\t\treturn PCAP_ERROR;\n\t}\n\n\tif (type == NFLOG) {\n\t\thandle->linktype = DLT_NFLOG;\n\t\thandle->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);\n\t\tif (handle->dlt_list != NULL) {\n\t\t\thandle->dlt_list[0] = DLT_NFLOG;\n\t\t\thandle->dlt_list[1] = DLT_IPV4;\n\t\t\thandle->dlt_count = 2;\n\t\t}\n\n\t} else\n\t\thandle->linktype = DLT_IPV4;\n\n\thandle->buffer = malloc(handle->bufsize);\n\tif (!handle->buffer) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't allocate dump buffer\");\n\t\tgoto close_fail;\n\t}\n\n\tif (type == NFLOG) {\n\t\tif (nflog_send_config_cmd(handle, 0, NFULNL_CFG_CMD_PF_UNBIND, AF_INET) < 0) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"NFULNL_CFG_CMD_PF_UNBIND\");\n\t\t\tgoto close_fail;\n\t\t}\n\n\t\tif (nflog_send_config_cmd(handle, 0, NFULNL_CFG_CMD_PF_BIND, AF_INET) < 0) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"NFULNL_CFG_CMD_PF_BIND\");\n\t\t\tgoto close_fail;\n\t\t}\n\n\t\t/* Bind socket to the nflog groups */\n\t\tfor (i = 0; i < group_count; i++) {\n\t\t\tif (nflog_send_config_cmd(handle, groups[i], NFULNL_CFG_CMD_BIND, AF_UNSPEC) < 0) {\n\t\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"Can't listen on group group index\");\n\t\t\t\tgoto close_fail;\n\t\t\t}\n\n\t\t\tif (nflog_send_config_mode(handle, groups[i], NFULNL_COPY_PACKET, handle->snapshot) < 0) {\n\t\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"NFULNL_COPY_PACKET\");\n\t\t\t\tgoto close_fail;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tif (nfqueue_send_config_cmd(handle, 0, NFQNL_CFG_CMD_PF_UNBIND, AF_INET) < 0) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"NFQNL_CFG_CMD_PF_UNBIND\");\n\t\t\tgoto close_fail;\n\t\t}\n\n\t\tif (nfqueue_send_config_cmd(handle, 0, NFQNL_CFG_CMD_PF_BIND, AF_INET) < 0) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"NFQNL_CFG_CMD_PF_BIND\");\n\t\t\tgoto close_fail;\n\t\t}\n\n\t\t/* Bind socket to the nfqueue groups */\n\t\tfor (i = 0; i < group_count; i++) {\n\t\t\tif (nfqueue_send_config_cmd(handle, groups[i], NFQNL_CFG_CMD_BIND, AF_UNSPEC) < 0) {\n\t\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"Can't listen on group group index\");\n\t\t\t\tgoto close_fail;\n\t\t\t}\n\n\t\t\tif (nfqueue_send_config_mode(handle, groups[i], NFQNL_COPY_PACKET, handle->snapshot) < 0) {\n\t\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"NFQNL_COPY_PACKET\");\n\t\t\t\tgoto close_fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (handle->opt.rfmon) {\n\t\t/*\n\t\t * Monitor mode doesn't apply to netfilter devices.\n\t\t */\n\t\tpcap_cleanup_live_common(handle);\n\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t}\n\n\tif (handle->opt.buffer_size != 0) {\n\t\t/*\n\t\t * Set the socket buffer size to the specified value.\n\t\t */\n\t\tif (setsockopt(handle->fd, SOL_SOCKET, SO_RCVBUF, &handle->opt.buffer_size, sizeof(handle->opt.buffer_size)) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"SO_RCVBUF\");\n\t\t\tgoto close_fail;\n\t\t}\n\t}\n\n\thandle->selectable_fd = handle->fd;\n\treturn 0;\n\nclose_fail:\n\tpcap_cleanup_live_common(handle);\n\treturn PCAP_ERROR;\n}",
          "fn_code_pos": [
            [
              490,
              0
            ],
            [
              689,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "netfilter_activate",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\nnetfilter_create(const char *device, char *ebuf, int *is_ours)\n{\n\tconst char *cp;\n\tpcap_t *p;\n\n\t/* Does this look like an netfilter device? */\n\tcp = strrchr(device, '/');\n\tif (cp == NULL)\n\t\tcp = device;\n\n\t/* Does it begin with NFLOG_IFACE or NFQUEUE_IFACE? */\n\tif (strncmp(cp, NFLOG_IFACE, sizeof NFLOG_IFACE - 1) == 0)\n\t\tcp += sizeof NFLOG_IFACE - 1;\n\telse if (strncmp(cp, NFQUEUE_IFACE, sizeof NFQUEUE_IFACE - 1) == 0)\n\t\tcp += sizeof NFQUEUE_IFACE - 1;\n\telse {\n\t\t/* Nope, doesn't begin with NFLOG_IFACE nor NFQUEUE_IFACE */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Yes - is that either the end of the name, or is it followed\n\t * by a colon?\n\t */\n\tif (*cp != ':' && *cp != '\\0') {\n\t\t/* Nope */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\t/* OK, it's probably ours. */\n\t*is_ours = 1;\n\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_netfilter));\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = netfilter_activate;\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              691,
              0
            ],
            [
              732,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "netfilter_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "int\nnetfilter_findalldevs(pcap_if_list_t *devlistp, char *err_str)\n{\n\tint sock;\n\n\tsock = socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER);\n\tif (sock < 0) {\n\t\t/* if netlink is not supported this is not fatal */\n\t\tif (errno == EAFNOSUPPORT || errno == EPROTONOSUPPORT)\n\t\t\treturn 0;\n\t\tpcap_fmt_errmsg_for_errno(err_str, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't open netlink socket\");\n\t\treturn -1;\n\t}\n\tclose(sock);\n\n\t/*\n\t * The notion of \"connected\" vs. \"disconnected\" doesn't apply.\n\t * XXX - what about \"up\" and \"running\"?\n\t */\n\tif (add_dev(devlistp, NFLOG_IFACE,\n\t    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,\n\t    \"Linux netfilter log (NFLOG) interface\", err_str) == NULL)\n\t\treturn -1;\n\tif (add_dev(devlistp, NFQUEUE_IFACE,\n\t    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,\n\t    \"Linux netfilter queue (NFQUEUE) interface\", err_str) == NULL)\n\t\treturn -1;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              734,
              0
            ],
            [
              763,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "netfilter_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "err_str": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "nfqueue_send_verdict(const pcap_t *handle, uint16_t group_id, u_int32_t id, u_int32_t verdict)",
          "fn_dec_pos": [
            [
              84,
              11
            ],
            [
              84,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nfqueue_send_verdict",
            "parameters": {
              "handle": "pcap_t",
              "group_id": "uint16_t",
              "id": "u_int32_t",
              "verdict": "u_int32_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "netfilter_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              692,
              0
            ],
            [
              692,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "netfilter_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_netfilter {\n\tu_int\tpackets_read;\t/* count of packets read with recvfrom() */\n\tu_int   packets_nobufs; /* ENOBUFS counter */\n}",
          {
            "packets_read": "u_int",
            "packets_nobufs": "u_int"
          },
          "pcap_netfilter",
          [
            79,
            0
          ],
          [
            82,
            1
          ]
        ],
        [
          "struct my_nfattr {\n\tuint16_t nfa_len;\n\tuint16_t nfa_type;\n\tvoid *data;\n}",
          {
            "nfa_len": "uint16_t",
            "nfa_type": "uint16_t",
            "*data": "void"
          },
          "my_nfattr",
          [
            308,
            0
          ],
          [
            312,
            1
          ]
        ],
        [
          "struct pcap_netfilter {\n\tu_int\tpackets_read;\t/* count of packets read with recvfrom() */\n\tu_int   packets_nobufs; /* ENOBUFS counter */\n}",
          {
            "packets_read": "u_int",
            "packets_nobufs": "u_int"
          },
          "pcap_netfilter",
          [
            79,
            0
          ],
          [
            82,
            1
          ]
        ],
        [
          "struct pcap_netfilter",
          {},
          "",
          [
            90,
            1
          ],
          [
            90,
            22
          ]
        ],
        [
          "struct nlmsghdr",
          {},
          "",
          [
            139,
            8
          ],
          [
            139,
            23
          ]
        ],
        [
          "struct nlmsghdr",
          {},
          "",
          [
            139,
            38
          ],
          [
            139,
            53
          ]
        ],
        [
          "struct nlmsghdr",
          {},
          "",
          [
            169,
            30
          ],
          [
            169,
            45
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            183,
            3
          ],
          [
            183,
            21
          ]
        ],
        [
          "struct nfgenmsg",
          {},
          "",
          [
            185,
            9
          ],
          [
            185,
            24
          ]
        ],
        [
          "struct nfattr",
          {},
          "",
          [
            189,
            10
          ],
          [
            189,
            23
          ]
        ],
        [
          "struct nfattr",
          {},
          "",
          [
            198,
            5
          ],
          [
            198,
            18
          ]
        ],
        [
          "struct nfqnl_msg_packet_hdr",
          {},
          "",
          [
            206,
            16
          ],
          [
            206,
            43
          ]
        ],
        [
          "struct nfqnl_msg_packet_hdr",
          {},
          "",
          [
            206,
            62
          ],
          [
            206,
            89
          ]
        ],
        [
          "struct nlmsghdr",
          {},
          "",
          [
            234,
            63
          ],
          [
            234,
            78
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            290,
            38
          ],
          [
            290,
            54
          ]
        ],
        [
          "struct pcap_netfilter",
          {},
          "",
          [
            292,
            1
          ],
          [
            292,
            22
          ]
        ],
        [
          "struct my_nfattr {\n\tuint16_t nfa_len;\n\tuint16_t nfa_type;\n\tvoid *data;\n}",
          {
            "nfa_len": "uint16_t",
            "nfa_type": "uint16_t",
            "*data": "void"
          },
          "my_nfattr",
          [
            308,
            0
          ],
          [
            312,
            1
          ]
        ],
        [
          "struct my_nfattr",
          {},
          "",
          [
            315,
            117
          ],
          [
            315,
            133
          ]
        ],
        [
          "struct nlmsghdr",
          {},
          "",
          [
            319,
            1
          ],
          [
            319,
            16
          ]
        ],
        [
          "struct nlmsghdr",
          {},
          "",
          [
            319,
            25
          ],
          [
            319,
            40
          ]
        ],
        [
          "struct nfgenmsg",
          {},
          "",
          [
            320,
            1
          ],
          [
            320,
            16
          ]
        ],
        [
          "struct nfgenmsg",
          {},
          "",
          [
            320,
            25
          ],
          [
            320,
            40
          ]
        ],
        [
          "struct nlmsghdr",
          {},
          "",
          [
            320,
            58
          ],
          [
            320,
            73
          ]
        ],
        [
          "struct sockaddr_nl",
          {},
          "",
          [
            322,
            1
          ],
          [
            322,
            19
          ]
        ],
        [
          "struct nfgenmsg",
          {},
          "",
          [
            329,
            38
          ],
          [
            329,
            53
          ]
        ],
        [
          "struct nfattr",
          {},
          "",
          [
            340,
            2
          ],
          [
            340,
            15
          ]
        ],
        [
          "struct nfattr",
          {},
          "",
          [
            340,
            24
          ],
          [
            340,
            37
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            351,
            49
          ],
          [
            351,
            64
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            368,
            57
          ],
          [
            368,
            72
          ]
        ],
        [
          "struct nlmsghdr",
          {},
          "",
          [
            379,
            9
          ],
          [
            379,
            24
          ]
        ],
        [
          "struct nlmsgerr",
          {},
          "",
          [
            385,
            44
          ],
          [
            385,
            59
          ]
        ],
        [
          "struct my_nfattr",
          {},
          "",
          [
            400,
            86
          ],
          [
            400,
            102
          ]
        ],
        [
          "struct nfulnl_msg_config_cmd",
          {},
          "",
          [
            408,
            1
          ],
          [
            408,
            29
          ]
        ],
        [
          "struct my_nfattr",
          {},
          "",
          [
            409,
            1
          ],
          [
            409,
            17
          ]
        ],
        [
          "struct nfulnl_msg_config_mode",
          {},
          "",
          [
            423,
            1
          ],
          [
            423,
            30
          ]
        ],
        [
          "struct my_nfattr",
          {},
          "",
          [
            424,
            1
          ],
          [
            424,
            17
          ]
        ],
        [
          "struct nfqnl_msg_verdict_hdr",
          {},
          "",
          [
            439,
            1
          ],
          [
            439,
            29
          ]
        ],
        [
          "struct my_nfattr",
          {},
          "",
          [
            440,
            1
          ],
          [
            440,
            17
          ]
        ],
        [
          "struct my_nfattr",
          {},
          "",
          [
            453,
            88
          ],
          [
            453,
            104
          ]
        ],
        [
          "struct nfqnl_msg_config_cmd",
          {},
          "",
          [
            461,
            1
          ],
          [
            461,
            28
          ]
        ],
        [
          "struct my_nfattr",
          {},
          "",
          [
            462,
            1
          ],
          [
            462,
            17
          ]
        ],
        [
          "struct nfqnl_msg_config_params",
          {},
          "",
          [
            477,
            1
          ],
          [
            477,
            31
          ]
        ],
        [
          "struct my_nfattr",
          {},
          "",
          [
            478,
            1
          ],
          [
            478,
            17
          ]
        ],
        [
          "struct pcap_netfilter",
          {},
          "",
          [
            726,
            38
          ],
          [
            726,
            59
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include \"strerror.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <arpa/inet.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <time.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <linux/types.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include <linux/netlink.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <linux/netfilter.h>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <linux/netfilter/nfnetlink.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <linux/netfilter/nfnetlink_log.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include <linux/netfilter/nfnetlink_queue.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include \"pcap-netfilter-linux.h\"\n",
          [
            67,
            0
          ],
          [
            68,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum { OTHER = -1, NFLOG, NFQUEUE } nftype_t;",
          {
            "OTHER": "",
            "NFLOG": "",
            "NFQUEUE": ""
          },
          "nftype_t",
          [
            74,
            0
          ],
          [
            74,
            53
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-libdlpi.c": {
      "fn_def_list": [
        {
          "fn_code": "static boolean_t\nlist_interfaces(const char *linkname, void *arg)\n{\n\tlinkwalk_t\t*lwp = arg;\n\tlinknamelist_t\t*entry;\n\n\tif ((entry = calloc(1, sizeof(linknamelist_t))) == NULL) {\n\t\tlwp->lw_err = ENOMEM;\n\t\treturn (B_TRUE);\n\t}\n\t(void) pcap_strlcpy(entry->linkname, linkname, DLPI_LINKNAME_MAX);\n\n\tif (lwp->lw_list == NULL) {\n\t\tlwp->lw_list = entry;\n\t} else {\n\t\tentry->lnl_next = lwp->lw_list;\n\t\tlwp->lw_list = entry;\n\t}\n\n\treturn (B_FALSE);\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              92,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "list_interfaces",
            "parameters": {
              "linkname": "char",
              "arg": "void"
            },
            "return_type": "boolean_t"
          }
        },
        {
          "fn_code": "static int\npcap_activate_libdlpi(pcap_t *p)\n{\n\tstruct pcap_dlpi *pd = p->priv;\n\tint status = 0;\n\tint retv;\n\tdlpi_handle_t dh;\n\tdlpi_info_t dlinfo;\n\n\t/*\n\t * Enable Solaris raw and passive DLPI extensions;\n\t * dlpi_open() will not fail if the underlying link does not support\n\t * passive mode. See dlpi(7P) for details.\n\t */\n\tretv = dlpi_open(p->opt.device, &dh, DLPI_RAW|DLPI_PASSIVE);\n\tif (retv != DLPI_SUCCESS) {\n\t\tif (retv == DLPI_ELINKNAMEINVAL || retv == DLPI_ENOLINK)\n\t\t\tstatus = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\telse if (retv == DL_SYSERR &&\n\t\t    (errno == EPERM || errno == EACCES))\n\t\t\tstatus = PCAP_ERROR_PERM_DENIED;\n\t\telse\n\t\t\tstatus = PCAP_ERROR;\n\t\tpcap_libdlpi_err(p->opt.device, \"dlpi_open\", retv,\n\t\t    p->errbuf);\n\t\treturn (status);\n\t}\n\tpd->dlpi_hd = dh;\n\n\tif (p->opt.rfmon) {\n\t\t/*\n\t\t * This device exists, but we don't support monitor mode\n\t\t * any platforms that support DLPI.\n\t\t */\n\t\tstatus = PCAP_ERROR_RFMON_NOTSUP;\n\t\tgoto bad;\n\t}\n\n\t/* Bind with DLPI_ANY_SAP. */\n\tif ((retv = dlpi_bind(pd->dlpi_hd, DLPI_ANY_SAP, 0)) != DLPI_SUCCESS) {\n\t\tstatus = PCAP_ERROR;\n\t\tpcap_libdlpi_err(p->opt.device, \"dlpi_bind\", retv, p->errbuf);\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n\t/* Enable promiscuous mode. */\n\tif (p->opt.promisc) {\n\t\tretv = dlpromiscon(p, DL_PROMISC_PHYS);\n\t\tif (retv < 0) {\n\t\t\t/*\n\t\t\t * \"You don't have permission to capture on\n\t\t\t * this device\" and \"you don't have permission\n\t\t\t * to capture in promiscuous mode on this\n\t\t\t * device\" are different; let the user know,\n\t\t\t * so if they can't get permission to\n\t\t\t * capture in promiscuous mode, they can at\n\t\t\t * least try to capture in non-promiscuous\n\t\t\t * mode.\n\t\t\t *\n\t\t\t * XXX - you might have to capture in\n\t\t\t * promiscuous mode to see outgoing packets.\n\t\t\t */\n\t\t\tif (retv == PCAP_ERROR_PERM_DENIED)\n\t\t\t\tstatus = PCAP_ERROR_PROMISC_PERM_DENIED;\n\t\t\telse\n\t\t\t\tstatus = retv;\n\t\t\tgoto bad;\n\t\t}\n\t} else {\n\t\t/* Try to enable multicast. */\n\t\tretv = dlpromiscon(p, DL_PROMISC_MULTI);\n\t\tif (retv < 0) {\n\t\t\tstatus = retv;\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\t/* Try to enable SAP promiscuity. */\n\tretv = dlpromiscon(p, DL_PROMISC_SAP);\n\tif (retv < 0) {\n\t\t/*\n\t\t * Not fatal, since the DL_PROMISC_PHYS mode worked.\n\t\t * Report it as a warning, however.\n\t\t */\n\t\tif (p->opt.promisc)\n\t\t\tstatus = PCAP_WARNING;\n\t\telse {\n\t\t\tstatus = retv;\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\t/* Determine link type.  */\n\tif ((retv = dlpi_info(pd->dlpi_hd, &dlinfo, 0)) != DLPI_SUCCESS) {\n\t\tstatus = PCAP_ERROR;\n\t\tpcap_libdlpi_err(p->opt.device, \"dlpi_info\", retv, p->errbuf);\n\t\tgoto bad;\n\t}\n\n\tif (pcap_process_mactype(p, dlinfo.di_mactype) != 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\tp->fd = dlpi_fd(pd->dlpi_hd);\n\n\t/* Push and configure bufmod. */\n\tif (pcap_conf_bufmod(p, p->snapshot) != 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * Flush the read side.\n\t */\n\tif (ioctl(p->fd, I_FLUSH, FLUSHR) != 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"FLUSHR\");\n\t\tgoto bad;\n\t}\n\n\t/* Allocate data buffer. */\n\tif (pcap_alloc_databuf(p) != 0) {\n\t\tstatus = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * \"p->fd\" is a FD for a STREAMS device, so \"select()\" and\n\t * \"poll()\" should work on it.\n\t */\n\tp->selectable_fd = p->fd;\n\n\tp->read_op = pcap_read_libdlpi;\n\tp->inject_op = pcap_inject_libdlpi;\n\tp->setfilter_op = install_bpf_program;\t/* No kernel filtering */\n\tp->setdirection_op = NULL;\t/* Not implemented */\n\tp->set_datalink_op = NULL;\t/* Can't change data link type */\n\tp->getnonblock_op = pcap_getnonblock_fd;\n\tp->setnonblock_op = pcap_setnonblock_fd;\n\tp->stats_op = pcap_stats_dlpi;\n\tp->cleanup_op = pcap_cleanup_libdlpi;\n\n\treturn (status);\nbad:\n\tpcap_cleanup_libdlpi(p);\n\treturn (status);\n}",
          "fn_code_pos": [
            [
              94,
              0
            ],
            [
              253,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_activate_libdlpi",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndlpromiscon(pcap_t *p, bpf_u_int32 level)\n{\n\tstruct pcap_dlpi *pd = p->priv;\n\tint retv;\n\tint err;\n\n\tretv = dlpi_promiscon(pd->dlpi_hd, level);\n\tif (retv != DLPI_SUCCESS) {\n\t\tif (retv == DL_SYSERR &&\n\t\t    (errno == EPERM || errno == EACCES))\n\t\t\terr = PCAP_ERROR_PERM_DENIED;\n\t\telse\n\t\t\terr = PCAP_ERROR;\n\t\tpcap_libdlpi_err(p->opt.device, \"dlpi_promiscon\" STRINGIFY(level),\n\t\t    retv, p->errbuf);\n\t\treturn (err);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              257,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlpromiscon",
            "parameters": {
              "p": "pcap_t",
              "level": "bpf_u_int32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nis_dlpi_interface(const char *name _U_)\n{\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              283,
              0
            ],
            [
              287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "is_dlpi_interface",
            "parameters": {
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nget_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)\n{\n\t/*\n\t * Nothing we can do other than mark loopback devices as \"the\n\t * connected/disconnected status doesn't apply\".\n\t *\n\t * XXX - on Solaris, can we do what the dladm command does,\n\t * i.e. get a connected/disconnected indication from a kstat?\n\t * (Note that you can also get the link speed, and possibly\n\t * other information, from a kstat as well.)\n\t */\n\tif (*flags & PCAP_IF_LOOPBACK) {\n\t\t/*\n\t\t * Loopback devices aren't wireless, and \"connected\"/\n\t\t * \"disconnected\" doesn't apply to them.\n\t\t */\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\t\treturn (0);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              289,
              0
            ],
            [
              310,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_if_flags",
            "parameters": {
              "name": "char",
              "flags": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\tint retv = 0;\n\n\tlinknamelist_t\t*entry, *next;\n\tlinkwalk_t\tlw = {NULL, 0};\n\tint \t\tsave_errno;\n\n\t/*\n\t * Get the list of regular interfaces first.\n\t */\n\tif (pcap_findalldevs_interfaces(devlistp, errbuf,\n\t    is_dlpi_interface, get_if_flags) == -1)\n\t\treturn (-1);\t/* failure */\n\n\t/* dlpi_walk() for loopback will be added here. */\n\n\t/*\n\t * Find all DLPI devices in the current zone.\n\t *\n\t * XXX - will pcap_findalldevs_interfaces() find any devices\n\t * outside the current zone?  If not, the only reason to call\n\t * it would be to get the interface addresses.\n\t */\n\tdlpi_walk(list_interfaces, &lw, 0);\n\n\tif (lw.lw_err != 0) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    lw.lw_err, \"dlpi_walk\");\n\t\tretv = -1;\n\t\tgoto done;\n\t}\n\n\t/* Add linkname if it does not exist on the list. */\n\tfor (entry = lw.lw_list; entry != NULL; entry = entry->lnl_next) {\n\t\t/*\n\t\t * If it isn't already in the list of devices, try to\n\t\t * add it.\n\t\t */\n\t\tif (find_or_add_dev(devlistp, entry->linkname, 0, get_if_flags,\n\t\t    NULL, errbuf) == NULL)\n\t\t\tretv = -1;\n\t}\ndone:\n\tsave_errno = errno;\n\tfor (entry = lw.lw_list; entry != NULL; entry = next) {\n\t\tnext = entry->lnl_next;\n\t\tfree(entry);\n\t}\n\terrno = save_errno;\n\n\treturn (retv);\n}",
          "fn_code_pos": [
            [
              317,
              0
            ],
            [
              370,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_platform_finddevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_read_libdlpi(pcap_t *p, int count, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_dlpi *pd = p->priv;\n\tint len;\n\tu_char *bufp;\n\tsize_t msglen;\n\tint retv;\n\n\tlen = p->cc;\n\tif (len != 0) {\n\t\tbufp = p->bp;\n\t\tgoto process_pkts;\n\t}\n\tdo {\n\t\t/* Has \"pcap_breakloop()\" been called? */\n\t\tif (p->break_loop) {\n\t\t\t/*\n\t\t\t * Yes - clear the flag that indicates that it has,\n\t\t\t * and return -2 to indicate that we were told to\n\t\t\t * break out of the loop.\n\t\t\t */\n\t\t\tp->break_loop = 0;\n\t\t\treturn (-2);\n\t\t}\n\n\t\tmsglen = p->bufsize;\n\t\tbufp = (u_char *)p->buffer + p->offset;\n\n\t\tretv = dlpi_recv(pd->dlpi_hd, NULL, NULL, bufp,\n\t\t    &msglen, -1, NULL);\n\t\tif (retv != DLPI_SUCCESS) {\n\t\t\t/*\n\t\t\t * This is most likely a call to terminate out of the\n\t\t\t * loop. So, do not return an error message, instead\n\t\t\t * check if \"pcap_breakloop()\" has been called above.\n\t\t\t */\n\t\t\tif (retv == DL_SYSERR && errno == EINTR) {\n\t\t\t\tlen = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpcap_libdlpi_err(dlpi_linkname(pd->dlpi_hd),\n\t\t\t    \"dlpi_recv\", retv, p->errbuf);\n\t\t\treturn (-1);\n\t\t}\n\t\tlen = msglen;\n\t} while (len == 0);\n\nprocess_pkts:\n\treturn (pcap_process_pkts(p, callback, user, count, bufp, len));\n}",
          "fn_code_pos": [
            [
              376,
              0
            ],
            [
              426,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_libdlpi",
            "parameters": {
              "p": "pcap_t",
              "count": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_inject_libdlpi(pcap_t *p, const void *buf, int size)\n{\n\tstruct pcap_dlpi *pd = p->priv;\n\tint retv;\n\n\tretv = dlpi_send(pd->dlpi_hd, NULL, 0, buf, size, NULL);\n\tif (retv != DLPI_SUCCESS) {\n\t\tpcap_libdlpi_err(dlpi_linkname(pd->dlpi_hd), \"dlpi_send\", retv,\n\t\t    p->errbuf);\n\t\treturn (-1);\n\t}\n\t/*\n\t * dlpi_send(3DLPI) does not provide a way to return the number of\n\t * bytes sent on the wire. Based on the fact that DLPI_SUCCESS was\n\t * returned we are assuming 'size' bytes were sent.\n\t */\n\treturn (size);\n}",
          "fn_code_pos": [
            [
              428,
              0
            ],
            [
              446,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject_libdlpi",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\npcap_cleanup_libdlpi(pcap_t *p)\n{\n\tstruct pcap_dlpi *pd = p->priv;\n\n\tif (pd->dlpi_hd != NULL) {\n\t\tdlpi_close(pd->dlpi_hd);\n\t\tpd->dlpi_hd = NULL;\n\t\tp->fd = -1;\n\t}\n\tpcap_cleanup_live_common(p);\n}",
          "fn_code_pos": [
            [
              451,
              0
            ],
            [
              462,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_cleanup_libdlpi",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\npcap_libdlpi_err(const char *linkname, const char *func, int err, char *errbuf)\n{\n\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"libpcap: %s failed on %s: %s\",\n\t    func, linkname, dlpi_strerror(err));\n}",
          "fn_code_pos": [
            [
              467,
              0
            ],
            [
              472,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_libdlpi_err",
            "parameters": {
              "linkname": "char",
              "func": "char",
              "err": "int",
              "errbuf": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_create_interface(const char *device _U_, char *ebuf)\n{\n\tpcap_t *p;\n\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_dlpi));\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = pcap_activate_libdlpi;\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              474,
              0
            ],
            [
              485,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING);\n}",
          "fn_code_pos": [
            [
              490,
              0
            ],
            [
              494,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "dlpromiscon(pcap_t *, bpf_u_int32)",
          "fn_dec_pos": [
            [
              46,
              11
            ],
            [
              46,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlpromiscon",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_read_libdlpi(pcap_t *, int, pcap_handler, u_char *)",
          "fn_dec_pos": [
            [
              47,
              11
            ],
            [
              47,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_libdlpi",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_inject_libdlpi(pcap_t *, const void *, int)",
          "fn_dec_pos": [
            [
              48,
              11
            ],
            [
              48,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject_libdlpi",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_libdlpi_err(const char *, const char *, int, char *)",
          "fn_dec_pos": [
            [
              49,
              12
            ],
            [
              49,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_libdlpi_err",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_cleanup_libdlpi(pcap_t *)",
          "fn_dec_pos": [
            [
              50,
              12
            ],
            [
              50,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_cleanup_libdlpi",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "list_interfaces(const char *, void *)",
          "fn_dec_pos": [
            [
              56,
              17
            ],
            [
              56,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "list_interfaces",
            "parameters": {},
            "return_type": "boolean_t"
          }
        },
        {
          "fn_code": "pcap_create_interface(const char *device _U_, char *ebuf)",
          "fn_dec_pos": [
            [
              475,
              0
            ],
            [
              475,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              491,
              0
            ],
            [
              491,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct linknamelist {\n\tchar\tlinkname[DLPI_LINKNAME_MAX];\n\tstruct linknamelist *lnl_next;\n} linknamelist_t;",
          {
            "linkname[DLPI_LINKNAME_MAX]": "char",
            "*lnl_next": "struct linknamelist"
          },
          "linknamelist_t",
          [
            58,
            0
          ],
          [
            61,
            17
          ]
        ],
        [
          "typedef struct linkwalk {\n\tlinknamelist_t\t*lw_list;\n\tint\t\tlw_err;\n} linkwalk_t;",
          {
            "*lw_list": "linknamelist_t",
            "lw_err": "int"
          },
          "linkwalk_t",
          [
            63,
            0
          ],
          [
            66,
            13
          ]
        ],
        [
          "typedef struct linknamelist {\n\tchar\tlinkname[DLPI_LINKNAME_MAX];\n\tstruct linknamelist *lnl_next;\n} linknamelist_t;",
          {
            "linkname[DLPI_LINKNAME_MAX]": "char",
            "*lnl_next": "struct linknamelist"
          },
          "linknamelist_t",
          [
            58,
            0
          ],
          [
            61,
            17
          ]
        ],
        [
          "struct linknamelist",
          {},
          "",
          [
            60,
            1
          ],
          [
            60,
            20
          ]
        ],
        [
          "typedef struct linkwalk {\n\tlinknamelist_t\t*lw_list;\n\tint\t\tlw_err;\n} linkwalk_t;",
          {
            "*lw_list": "linknamelist_t",
            "lw_err": "int"
          },
          "linkwalk_t",
          [
            63,
            0
          ],
          [
            66,
            13
          ]
        ],
        [
          "struct pcap_dlpi",
          {},
          "",
          [
            97,
            1
          ],
          [
            97,
            17
          ]
        ],
        [
          "struct pcap_dlpi",
          {},
          "",
          [
            260,
            1
          ],
          [
            260,
            17
          ]
        ],
        [
          "struct pcap_dlpi",
          {},
          "",
          [
            379,
            1
          ],
          [
            379,
            17
          ]
        ],
        [
          "struct pcap_dlpi",
          {},
          "",
          [
            431,
            1
          ],
          [
            431,
            17
          ]
        ],
        [
          "struct pcap_dlpi",
          {},
          "",
          [
            454,
            1
          ],
          [
            454,
            17
          ]
        ],
        [
          "struct pcap_dlpi",
          {},
          "",
          [
            479,
            38
          ],
          [
            479,
            54
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <sys/bufmod.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <sys/stream.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <libdlpi.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <memory.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <stropts.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"dlpisubs.h\"\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/sf-pcap.c": {
      "fn_def_list": [
        {
          "fn_code": "pcap_t *\npcap_check_header(bpf_u_int32 magic, FILE *fp, u_int precision, char *errbuf,\n\t\t  int *err)\n{\n\tstruct pcap_file_header hdr;\n\tsize_t amt_read;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_sf *ps;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the magic\n\t * number for a pcap savefile, or for a byte-swapped pcap\n\t * savefile.\n\t */\n\tif (magic != TCPDUMP_MAGIC && magic != KUZNETZOV_TCPDUMP_MAGIC &&\n\t    magic != NSEC_TCPDUMP_MAGIC) {\n\t\tmagic = SWAPLONG(magic);\n\t\tif (magic != TCPDUMP_MAGIC && magic != KUZNETZOV_TCPDUMP_MAGIC &&\n\t\t    magic != NSEC_TCPDUMP_MAGIC)\n\t\t\treturn (NULL);\t/* nope */\n\t\tswapped = 1;\n\t}\n\n\t/*\n\t * They are.  Put the magic number in the header, and read\n\t * the rest of the header.\n\t */\n\thdr.magic = magic;\n\tamt_read = fread(((char *)&hdr) + sizeof hdr.magic, 1,\n\t    sizeof(hdr) - sizeof(hdr.magic), fp);\n\tif (amt_read != sizeof(hdr) - sizeof(hdr.magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t} else {\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"truncated dump file; tried to read %\" PRIsize \" file header bytes, only got %\" PRIsize,\n\t\t\t    sizeof(hdr), amt_read);\n\t\t}\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * If it's a byte-swapped capture file, byte-swap the header.\n\t */\n\tif (swapped) {\n\t\thdr.version_major = SWAPSHORT(hdr.version_major);\n\t\thdr.version_minor = SWAPSHORT(hdr.version_minor);\n\t\thdr.thiszone = SWAPLONG(hdr.thiszone);\n\t\thdr.sigfigs = SWAPLONG(hdr.sigfigs);\n\t\thdr.snaplen = SWAPLONG(hdr.snaplen);\n\t\thdr.linktype = SWAPLONG(hdr.linktype);\n\t}\n\n\tif (hdr.version_major < PCAP_VERSION_MAJOR) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"archaic pcap savefile format\");\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * currently only versions 2.[0-4] are supported with\n\t * the exception of 543.0 for DG/UX tcpdump.\n\t */\n\tif (! ((hdr.version_major == PCAP_VERSION_MAJOR &&\n\t\thdr.version_minor <= PCAP_VERSION_MINOR) ||\n\t       (hdr.version_major == 543 &&\n\t\thdr.version_minor == 0))) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t \"unsupported pcap savefile version %u.%u\",\n\t\t\t hdr.version_major, hdr.version_minor);\n\t\t*err = 1;\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * OK, this is a good pcap file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tp->version_major = hdr.version_major;\n\tp->version_minor = hdr.version_minor;\n\tp->snapshot = hdr.snaplen;\n\tif (p->snapshot <= 0) {\n\t\t/*\n\t\t * Bogus snapshot length; use the maximum for this\n\t\t * link-layer type as a fallback.\n\t\t *\n\t\t * XXX - the only reason why snapshot is signed is\n\t\t * that pcap_snapshot() returns an int, not an\n\t\t * unsigned int.\n\t\t */\n\t\tp->snapshot = max_snaplen_for_dlt(hdr.linktype);\n\t}\n\tp->linktype = linktype_to_dlt(LT_LINKTYPE(hdr.linktype));\n\tp->linktype_ext = LT_LINKTYPE_EXT(hdr.linktype);\n\n\tp->next_packet_op = pcap_next_packet;\n\n\tps = p->priv;\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Will we need to scale the timestamps to match what the\n\t * user wants?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tif (magic == NSEC_TCPDUMP_MAGIC) {\n\t\t\t/*\n\t\t\t * The file has nanoseconds, the user\n\t\t\t * wants microseconds; scale the\n\t\t\t * precision down.\n\t\t\t */\n\t\t\tps->scale_type = SCALE_DOWN;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The file has microseconds, the\n\t\t\t * user wants microseconds; nothing to do.\n\t\t\t */\n\t\t\tps->scale_type = PASS_THROUGH;\n\t\t}\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tif (magic == NSEC_TCPDUMP_MAGIC) {\n\t\t\t/*\n\t\t\t * The file has nanoseconds, the\n\t\t\t * user wants nanoseconds; nothing to do.\n\t\t\t */\n\t\t\tps->scale_type = PASS_THROUGH;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The file has microoseconds, the user\n\t\t\t * wants nanoseconds; scale the\n\t\t\t * precision up.\n\t\t\t */\n\t\t\tps->scale_type = SCALE_UP;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unknown time stamp resolution %u\", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * We interchanged the caplen and len fields at version 2.3,\n\t * in order to match the bpf header layout.  But unfortunately\n\t * some files were written with version 2.3 in their headers\n\t * but without the interchanged fields.\n\t *\n\t * In addition, DG/UX tcpdump writes out files with a version\n\t * number of 543.0, and with the caplen and len fields in the\n\t * pre-2.3 order.\n\t */\n\tswitch (hdr.version_major) {\n\n\tcase 2:\n\t\tif (hdr.version_minor < 3)\n\t\t\tps->lengths_swapped = SWAPPED;\n\t\telse if (hdr.version_minor == 3)\n\t\t\tps->lengths_swapped = MAYBE_SWAPPED;\n\t\telse\n\t\t\tps->lengths_swapped = NOT_SWAPPED;\n\t\tbreak;\n\n\tcase 543:\n\t\tps->lengths_swapped = SWAPPED;\n\t\tbreak;\n\n\tdefault:\n\t\tps->lengths_swapped = NOT_SWAPPED;\n\t\tbreak;\n\t}\n\n\tif (magic == KUZNETZOV_TCPDUMP_MAGIC) {\n\t\t/*\n\t\t * XXX - the patch that's in some versions of libpcap\n\t\t * changes the packet header but not the magic number,\n\t\t * and some other versions with this magic number have\n\t\t * some extra debugging information in the packet header;\n\t\t * we'd have to use some hacks^H^H^H^H^Hheuristics to\n\t\t * detect those variants.\n\t\t *\n\t\t * Ethereal does that, but it does so by trying to read\n\t\t * the first two packets of the file with each of the\n\t\t * record header formats.  That currently means it seeks\n\t\t * backwards and retries the reads, which doesn't work\n\t\t * on pipes.  We want to be able to read from a pipe, so\n\t\t * that strategy won't work; we'd have to buffer some\n\t\t * data ourselves and read from that buffer in order to\n\t\t * make that work.\n\t\t */\n\t\tps->hdrsize = sizeof(struct pcap_sf_patched_pkthdr);\n\n\t\tif (p->linktype == DLT_EN10MB) {\n\t\t\t/*\n\t\t\t * This capture might have been done in raw mode\n\t\t\t * or cooked mode.\n\t\t\t *\n\t\t\t * If it was done in cooked mode, p->snapshot was\n\t\t\t * passed to recvfrom() as the buffer size, meaning\n\t\t\t * that the most packet data that would be copied\n\t\t\t * would be p->snapshot.  However, a faked Ethernet\n\t\t\t * header would then have been added to it, so the\n\t\t\t * most data that would be in a packet in the file\n\t\t\t * would be p->snapshot + 14.\n\t\t\t *\n\t\t\t * We can't easily tell whether the capture was done\n\t\t\t * in raw mode or cooked mode, so we'll assume it was\n\t\t\t * cooked mode, and add 14 to the snapshot length.\n\t\t\t * That means that, for a raw capture, the snapshot\n\t\t\t * length will be misleading if you use it to figure\n\t\t\t * out why a capture doesn't have all the packet data,\n\t\t\t * but there's not much we can do to avoid that.\n\t\t\t *\n\t\t\t * But don't grow the snapshot length past the\n\t\t\t * maximum value of an int.\n\t\t\t */\n\t\t\tif (p->snapshot <= INT_MAX - 14)\n\t\t\t\tp->snapshot += 14;\n\t\t\telse\n\t\t\t\tp->snapshot = INT_MAX;\n\t\t}\n\t} else\n\t\tps->hdrsize = sizeof(struct pcap_sf_pkthdr);\n\n\t/*\n\t * Allocate a buffer for the packet data.\n\t * Choose the minimum of the file's snapshot length and 2K bytes;\n\t * that should be enough for most network packets - we'll grow it\n\t * if necessary.  That way, we don't allocate a huge chunk of\n\t * memory just because there's a huge snapshot length, as the\n\t * snapshot length might be larger than the size of the largest\n\t * packet.\n\t */\n\tp->bufsize = p->snapshot;\n\tif (p->bufsize > 2048)\n\t\tp->bufsize = 2048;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->cleanup_op = sf_cleanup;\n\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              151,
              0
            ],
            [
              421,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_check_header",
            "parameters": {
              "magic": "bpf_u_int32",
              "fp": "FILE",
              "precision": "u_int",
              "errbuf": "char",
              "err": "int"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static int\ngrow_buffer(pcap_t *p, u_int bufsize)\n{\n\tvoid *bigger_buffer;\n\n\tbigger_buffer = realloc(p->buffer, bufsize);\n\tif (bigger_buffer == NULL) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\treturn (0);\n\t}\n\tp->buffer = bigger_buffer;\n\tp->bufsize = bufsize;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              426,
              0
            ],
            [
              439,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "grow_buffer",
            "parameters": {
              "p": "pcap_t",
              "bufsize": "u_int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)\n{\n\tstruct pcap_sf *ps = p->priv;\n\tstruct pcap_sf_patched_pkthdr sf_hdr;\n\tFILE *fp = p->rfile;\n\tsize_t amt_read;\n\tbpf_u_int32 t;\n\n\t/*\n\t * Read the packet header; the structure we use as a buffer\n\t * is the longer structure for files generated by the patched\n\t * libpcap, but if the file has the magic number for an\n\t * unpatched libpcap we only read as many bytes as the regular\n\t * header has.\n\t */\n\tamt_read = fread(&sf_hdr, 1, ps->hdrsize, fp);\n\tif (amt_read != ps->hdrsize) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\treturn (-1);\n\t\t} else {\n\t\t\tif (amt_read != 0) {\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"truncated dump file; tried to read %\" PRIsize \" header bytes, only got %\" PRIsize,\n\t\t\t\t    ps->hdrsize, amt_read);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\t/* EOF */\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\tif (p->swapped) {\n\t\t/* these were written in opposite byte order */\n\t\thdr->caplen = SWAPLONG(sf_hdr.caplen);\n\t\thdr->len = SWAPLONG(sf_hdr.len);\n\t\thdr->ts.tv_sec = SWAPLONG(sf_hdr.ts.tv_sec);\n\t\thdr->ts.tv_usec = SWAPLONG(sf_hdr.ts.tv_usec);\n\t} else {\n\t\thdr->caplen = sf_hdr.caplen;\n\t\thdr->len = sf_hdr.len;\n\t\thdr->ts.tv_sec = sf_hdr.ts.tv_sec;\n\t\thdr->ts.tv_usec = sf_hdr.ts.tv_usec;\n\t}\n\n\tswitch (ps->scale_type) {\n\n\tcase PASS_THROUGH:\n\t\t/*\n\t\t * Just pass the time stamp through.\n\t\t */\n\t\tbreak;\n\n\tcase SCALE_UP:\n\t\t/*\n\t\t * File has microseconds, user wants nanoseconds; convert\n\t\t * it.\n\t\t */\n\t\thdr->ts.tv_usec = hdr->ts.tv_usec * 1000;\n\t\tbreak;\n\n\tcase SCALE_DOWN:\n\t\t/*\n\t\t * File has nanoseconds, user wants microseconds; convert\n\t\t * it.\n\t\t */\n\t\thdr->ts.tv_usec = hdr->ts.tv_usec / 1000;\n\t\tbreak;\n\t}\n\n\t/* Swap the caplen and len fields, if necessary. */\n\tswitch (ps->lengths_swapped) {\n\n\tcase NOT_SWAPPED:\n\t\tbreak;\n\n\tcase MAYBE_SWAPPED:\n\t\tif (hdr->caplen <= hdr->len) {\n\t\t\t/*\n\t\t\t * The captured length is <= the actual length,\n\t\t\t * so presumably they weren't swapped.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\t/* FALLTHROUGH */\n\n\tcase SWAPPED:\n\t\tt = hdr->caplen;\n\t\thdr->caplen = hdr->len;\n\t\thdr->len = t;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Is the packet bigger than we consider sane?\n\t */\n\tif (hdr->caplen > max_snaplen_for_dlt(p->linktype)) {\n\t\t/*\n\t\t * Yes.  This may be a damaged or fuzzed file.\n\t\t *\n\t\t * Is it bigger than the snapshot length?\n\t\t * (We don't treat that as an error if it's not\n\t\t * bigger than the maximum we consider sane; see\n\t\t * below.)\n\t\t */\n\t\tif (hdr->caplen > (bpf_u_int32)p->snapshot) {\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"invalid packet capture length %u, bigger than \"\n\t\t\t    \"snaplen of %d\", hdr->caplen, p->snapshot);\n\t\t} else {\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"invalid packet capture length %u, bigger than \"\n\t\t\t    \"maximum of %u\", hdr->caplen,\n\t\t\t    max_snaplen_for_dlt(p->linktype));\n\t\t}\n\t\treturn (-1);\n\t}\n\n\tif (hdr->caplen > (bpf_u_int32)p->snapshot) {\n\t\t/*\n\t\t * The packet is bigger than the snapshot length\n\t\t * for this file.\n\t\t *\n\t\t * This can happen due to Solaris 2.3 systems tripping\n\t\t * over the BUFMOD problem and not setting the snapshot\n\t\t * length correctly in the savefile header.\n\t\t *\n\t\t * libpcap 0.4 and later on Solaris 2.3 should set the\n\t\t * snapshot length correctly in the pcap file header,\n\t\t * even though they don't set a snapshot length in bufmod\n\t\t * (the buggy bufmod chops off the *beginning* of the\n\t\t * packet if a snapshot length is specified); they should\n\t\t * also reduce the captured length, as supplied to the\n\t\t * per-packet callback, to the snapshot length if it's\n\t\t * greater than the snapshot length, so the code using\n\t\t * libpcap should see the packet cut off at the snapshot\n\t\t * length, even though the full packet is copied up to\n\t\t * userland.\n\t\t *\n\t\t * However, perhaps some versions of libpcap failed to\n\t\t * set the snapshot length currectly in the file header\n\t\t * or the per-packet header, or perhaps this is a\n\t\t * corrupted safefile or a savefile built/modified by a\n\t\t * fuzz tester, so we check anyway.  We grow the buffer\n\t\t * to be big enough for the snapshot length, read up\n\t\t * to the snapshot length, discard the rest of the\n\t\t * packet, and report the snapshot length as the captured\n\t\t * length; we don't want to hand our caller a packet\n\t\t * bigger than the snapshot length, because they might\n\t\t * be assuming they'll never be handed such a packet,\n\t\t * and might copy the packet into a snapshot-length-\n\t\t * sized buffer, assuming it'll fit.\n\t\t */\n\t\tsize_t bytes_to_discard;\n\t\tsize_t bytes_to_read, bytes_read;\n\t\tchar discard_buf[4096];\n\n\t\tif (hdr->caplen > p->bufsize) {\n\t\t\t/*\n\t\t\t * Grow the buffer to the snapshot length.\n\t\t\t */\n\t\t\tif (!grow_buffer(p, p->snapshot))\n\t\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Read the first p->snapshot bytes into the buffer.\n\t\t */\n\t\tamt_read = fread(p->buffer, 1, p->snapshot, fp);\n\t\tif (amt_read != (bpf_u_int32)p->snapshot) {\n\t\t\tif (ferror(fp)) {\n\t\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t     PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"error reading dump file\");\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Yes, this uses hdr->caplen; technically,\n\t\t\t\t * it's true, because we would try to read\n\t\t\t\t * and discard the rest of those bytes, and\n\t\t\t\t * that would fail because we got EOF before\n\t\t\t\t * the read finished.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"truncated dump file; tried to read %u captured bytes, only got %\" PRIsize,\n\t\t\t\t    p->snapshot, amt_read);\n\t\t\t}\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Now read and discard what's left.\n\t\t */\n\t\tbytes_to_discard = hdr->caplen - p->snapshot;\n\t\tbytes_read = amt_read;\n\t\twhile (bytes_to_discard != 0) {\n\t\t\tbytes_to_read = bytes_to_discard;\n\t\t\tif (bytes_to_read > sizeof (discard_buf))\n\t\t\t\tbytes_to_read = sizeof (discard_buf);\n\t\t\tamt_read = fread(discard_buf, 1, bytes_to_read, fp);\n\t\t\tbytes_read += amt_read;\n\t\t\tif (amt_read != bytes_to_read) {\n\t\t\t\tif (ferror(fp)) {\n\t\t\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"error reading dump file\");\n\t\t\t\t} else {\n\t\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"truncated dump file; tried to read %u captured bytes, only got %\" PRIsize,\n\t\t\t\t\t    hdr->caplen, bytes_read);\n\t\t\t\t}\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tbytes_to_discard -= amt_read;\n\t\t}\n\n\t\t/*\n\t\t * Adjust caplen accordingly, so we don't get confused later\n\t\t * as to how many bytes we have to play with.\n\t\t */\n\t\thdr->caplen = p->snapshot;\n\t} else {\n\t\t/*\n\t\t * The packet is within the snapshot length for this file.\n\t\t */\n\t\tif (hdr->caplen > p->bufsize) {\n\t\t\t/*\n\t\t\t * Grow the buffer to the next power of 2, or\n\t\t\t * the snaplen, whichever is lower.\n\t\t\t */\n\t\t\tu_int new_bufsize;\n\n\t\t\tnew_bufsize = hdr->caplen;\n\t\t\t/*\n\t\t\t * http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2\n\t\t\t */\n\t\t\tnew_bufsize--;\n\t\t\tnew_bufsize |= new_bufsize >> 1;\n\t\t\tnew_bufsize |= new_bufsize >> 2;\n\t\t\tnew_bufsize |= new_bufsize >> 4;\n\t\t\tnew_bufsize |= new_bufsize >> 8;\n\t\t\tnew_bufsize |= new_bufsize >> 16;\n\t\t\tnew_bufsize++;\n\n\t\t\tif (new_bufsize > (u_int)p->snapshot)\n\t\t\t\tnew_bufsize = p->snapshot;\n\n\t\t\tif (!grow_buffer(p, new_bufsize))\n\t\t\t\treturn (-1);\n\t\t}\n\n\t\t/* read the packet itself */\n\t\tamt_read = fread(p->buffer, 1, hdr->caplen, fp);\n\t\tif (amt_read != hdr->caplen) {\n\t\t\tif (ferror(fp)) {\n\t\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"error reading dump file\");\n\t\t\t} else {\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"truncated dump file; tried to read %u captured bytes, only got %\" PRIsize,\n\t\t\t\t    hdr->caplen, amt_read);\n\t\t\t}\n\t\t\treturn (-1);\n\t\t}\n\t}\n\t*data = p->buffer;\n\n\tif (p->swapped)\n\t\tswap_pseudo_headers(p->linktype, hdr, *data);\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              446,
              0
            ],
            [
              719,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_next_packet",
            "parameters": {
              "p": "pcap_t",
              "hdr": "struct pcap_pkthdr",
              "data": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nsf_write_header(pcap_t *p, FILE *fp, int linktype, int snaplen)\n{\n\tstruct pcap_file_header hdr;\n\n\thdr.magic = p->opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO ? NSEC_TCPDUMP_MAGIC : TCPDUMP_MAGIC;\n\thdr.version_major = PCAP_VERSION_MAJOR;\n\thdr.version_minor = PCAP_VERSION_MINOR;\n\n\t/*\n\t * https://www.tcpdump.org/manpages/pcap-savefile.5.txt states:\n\t * thiszone: 4-byte time zone offset; this is always 0.\n\t * sigfigs:  4-byte number giving the accuracy of time stamps\n\t *           in the file; this is always 0.\n\t */\n\thdr.thiszone = 0;\n\thdr.sigfigs = 0;\n\thdr.snaplen = snaplen;\n\thdr.linktype = linktype;\n\n\tif (fwrite((char *)&hdr, sizeof(hdr), 1, fp) != 1)\n\t\treturn (-1);\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              721,
              0
            ],
            [
              745,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_write_header",
            "parameters": {
              "p": "pcap_t",
              "fp": "FILE",
              "linktype": "int",
              "snaplen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\npcap_dump(u_char *user, const struct pcap_pkthdr *h, const u_char *sp)\n{\n\tregister FILE *f;\n\tstruct pcap_sf_pkthdr sf_hdr;\n\n\tf = (FILE *)user;\n\t/*\n\t * Better not try writing pcap files after\n\t * 2038-01-19 03:14:07 UTC; switch to pcapng.\n\t */\n\tsf_hdr.ts.tv_sec  = (bpf_int32)h->ts.tv_sec;\n\tsf_hdr.ts.tv_usec = (bpf_int32)h->ts.tv_usec;\n\tsf_hdr.caplen     = h->caplen;\n\tsf_hdr.len        = h->len;\n\t/* XXX we should check the return status */\n\t(void)fwrite(&sf_hdr, sizeof(sf_hdr), 1, f);\n\t(void)fwrite(sp, h->caplen, 1, f);\n}",
          "fn_code_pos": [
            [
              750,
              0
            ],
            [
              768,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump",
            "parameters": {
              "user": "u_char",
              "h": "struct pcap_pkthdr",
              "sp": "u_char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static pcap_dumper_t *\npcap_setup_dump(pcap_t *p, int linktype, FILE *f, const char *fname)\n{\n\n#if defined(_WIN32) || defined(MSDOS)\n\t/*\n\t * If we're writing to the standard output, put it in binary\n\t * mode, as savefiles are binary files.\n\t *\n\t * Otherwise, we turn off buffering.\n\t * XXX - why?  And why not on the standard output?\n\t */\n\tif (f == stdout)\n\t\tSET_BINMODE(f);\n\telse\n\t\tsetvbuf(f, NULL, _IONBF, 0);\n#endif\n\tif (sf_write_header(p, f, linktype, p->snapshot) == -1) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't write to %s\", fname);\n\t\tif (f != stdout)\n\t\t\t(void)fclose(f);\n\t\treturn (NULL);\n\t}\n\treturn ((pcap_dumper_t *)f);\n}",
          "fn_code_pos": [
            [
              770,
              0
            ],
            [
              795,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setup_dump",
            "parameters": {
              "p": "pcap_t",
              "linktype": "int",
              "f": "FILE",
              "fname": "char"
            },
            "return_type": "pcap_dumper_t"
          }
        },
        {
          "fn_code": "pcap_dumper_t *\npcap_dump_open(pcap_t *p, const char *fname)\n{\n\tFILE *f;\n\tint linktype;\n\n\t/*\n\t * If this pcap_t hasn't been activated, it doesn't have a\n\t * link-layer type, so we can't use it.\n\t */\n\tif (!p->activated) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: not-yet-activated pcap_t passed to pcap_dump_open\",\n\t\t    fname);\n\t\treturn (NULL);\n\t}\n\tlinktype = dlt_to_linktype(p->linktype);\n\tif (linktype == -1) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: link-layer type %d isn't supported in savefiles\",\n\t\t    fname, p->linktype);\n\t\treturn (NULL);\n\t}\n\tlinktype |= p->linktype_ext;\n\n\tif (fname == NULL) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"A null pointer was supplied as the file name\");\n\t\treturn NULL;\n\t}\n\tif (fname[0] == '-' && fname[1] == '\\0') {\n\t\tf = stdout;\n\t\tfname = \"standard output\";\n\t} else {\n\t\t/*\n\t\t * \"b\" is supported as of C90, so *all* UN*Xes should\n\t\t * support it, even though it does nothing.  It's\n\t\t * required on Windows, as the file is a binary file\n\t\t * and must be written in binary mode.\n\t\t */\n\t\tf = fopen(fname, \"wb\");\n\t\tif (f == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"%s\", fname);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\treturn (pcap_setup_dump(p, linktype, f, fname));\n}",
          "fn_code_pos": [
            [
              800,
              0
            ],
            [
              848,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_open",
            "parameters": {
              "p": "pcap_t",
              "fname": "char"
            },
            "return_type": "pcap_dumper_t"
          }
        },
        {
          "fn_code": "pcap_dumper_t *\npcap_dump_hopen(pcap_t *p, intptr_t osfd)\n{\n\tint fd;\n\tFILE *file;\n\n\tfd = _open_osfhandle(osfd, _O_APPEND);\n\tif (fd < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"_open_osfhandle\");\n\t\treturn NULL;\n\t}\n\n\tfile = _fdopen(fd, \"wb\");\n\tif (file == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"_fdopen\");\n\t\t_close(fd);\n\t\treturn NULL;\n\t}\n\n\treturn pcap_dump_fopen(p, file);\n}",
          "fn_code_pos": [
            [
              855,
              0
            ],
            [
              877,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_hopen",
            "parameters": {
              "p": "pcap_t",
              "osfd": "intptr_t"
            },
            "return_type": "pcap_dumper_t"
          }
        },
        {
          "fn_code": "pcap_dumper_t *\npcap_dump_fopen(pcap_t *p, FILE *f)\n{\n\tint linktype;\n\n\tlinktype = dlt_to_linktype(p->linktype);\n\tif (linktype == -1) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"stream: link-layer type %d isn't supported in savefiles\",\n\t\t    p->linktype);\n\t\treturn (NULL);\n\t}\n\tlinktype |= p->linktype_ext;\n\n\treturn (pcap_setup_dump(p, linktype, f, \"stream\"));\n}",
          "fn_code_pos": [
            [
              886,
              0
            ],
            [
              901,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_fopen",
            "parameters": {
              "p": "pcap_t",
              "f": "FILE"
            },
            "return_type": "pcap_dumper_t"
          }
        },
        {
          "fn_code": "pcap_dumper_t *\npcap_dump_open_append(pcap_t *p, const char *fname)\n{\n\tFILE *f;\n\tint linktype;\n\tsize_t amt_read;\n\tstruct pcap_file_header ph;\n\n\tlinktype = dlt_to_linktype(p->linktype);\n\tif (linktype == -1) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"%s: link-layer type %d isn't supported in savefiles\",\n\t\t    fname, linktype);\n\t\treturn (NULL);\n\t}\n\n\tif (fname == NULL) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"A null pointer was supplied as the file name\");\n\t\treturn NULL;\n\t}\n\tif (fname[0] == '-' && fname[1] == '\\0')\n\t\treturn (pcap_setup_dump(p, linktype, stdout, \"standard output\"));\n\n\t/*\n\t * \"b\" is supported as of C90, so *all* UN*Xes should support it,\n\t * even though it does nothing.  It's required on Windows, as the\n\t * file is a binary file and must be read in binary mode.\n\t */\n\tf = fopen(fname, \"rb+\");\n\tif (f == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"%s\", fname);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Try to read a pcap header.\n\t */\n\tamt_read = fread(&ph, 1, sizeof (ph), f);\n\tif (amt_read != sizeof (ph)) {\n\t\tif (ferror(f)) {\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"%s\", fname);\n\t\t\tfclose(f);\n\t\t\treturn (NULL);\n\t\t} else if (feof(f) && amt_read > 0) {\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: truncated pcap file header\", fname);\n\t\t\tfclose(f);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n#if defined(_WIN32) || defined(MSDOS)\n\t/*\n\t * We turn off buffering.\n\t * XXX - why?  And why not on the standard output?\n\t */\n\tsetvbuf(f, NULL, _IONBF, 0);\n#endif\n\n\t/*\n\t * If a header is already present and:\n\t *\n\t *\tit's not for a pcap file of the appropriate resolution\n\t *\tand the right byte order for this machine;\n\t *\n\t *\tthe link-layer header types don't match;\n\t *\n\t *\tthe snapshot lengths don't match;\n\t *\n\t * return an error.\n\t */\n\tif (amt_read > 0) {\n\t\t/*\n\t\t * A header is already present.\n\t\t * Do the checks.\n\t\t */\n\t\tswitch (ph.magic) {\n\n\t\tcase TCPDUMP_MAGIC:\n\t\t\tif (p->opt.tstamp_precision != PCAP_TSTAMP_PRECISION_MICRO) {\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"%s: different time stamp precision, cannot append to file\", fname);\n\t\t\t\tfclose(f);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NSEC_TCPDUMP_MAGIC:\n\t\t\tif (p->opt.tstamp_precision != PCAP_TSTAMP_PRECISION_NANO) {\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"%s: different time stamp precision, cannot append to file\", fname);\n\t\t\t\tfclose(f);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SWAPLONG(TCPDUMP_MAGIC):\n\t\tcase SWAPLONG(NSEC_TCPDUMP_MAGIC):\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: different byte order, cannot append to file\", fname);\n\t\t\tfclose(f);\n\t\t\treturn (NULL);\n\n\t\tcase KUZNETZOV_TCPDUMP_MAGIC:\n\t\tcase SWAPLONG(KUZNETZOV_TCPDUMP_MAGIC):\n\t\tcase NAVTEL_TCPDUMP_MAGIC:\n\t\tcase SWAPLONG(NAVTEL_TCPDUMP_MAGIC):\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: not a pcap file to which we can append\", fname);\n\t\t\tfclose(f);\n\t\t\treturn (NULL);\n\n\t\tdefault:\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: not a pcap file\", fname);\n\t\t\tfclose(f);\n\t\t\treturn (NULL);\n\t\t}\n\n\t\t/*\n\t\t * Good version?\n\t\t */\n\t\tif (ph.version_major != PCAP_VERSION_MAJOR ||\n\t\t    ph.version_minor != PCAP_VERSION_MINOR) {\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: version is %u.%u, cannot append to file\", fname,\n\t\t\t    ph.version_major, ph.version_minor);\n\t\t\tfclose(f);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif ((bpf_u_int32)linktype != ph.linktype) {\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: different linktype, cannot append to file\", fname);\n\t\t\tfclose(f);\n\t\t\treturn (NULL);\n\t\t}\n\t\tif ((bpf_u_int32)p->snapshot != ph.snaplen) {\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: different snaplen, cannot append to file\", fname);\n\t\t\tfclose(f);\n\t\t\treturn (NULL);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * A header isn't present; attempt to write it.\n\t\t */\n\t\tif (sf_write_header(p, f, linktype, p->snapshot) == -1) {\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"Can't write to %s\", fname);\n\t\t\t(void)fclose(f);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\n\t/*\n\t * Start writing at the end of the file.\n\t */\n\tif (fseek(f, 0, SEEK_END) == -1) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't seek to end of %s\", fname);\n\t\t(void)fclose(f);\n\t\treturn (NULL);\n\t}\n\treturn ((pcap_dumper_t *)f);\n}",
          "fn_code_pos": [
            [
              903,
              0
            ],
            [
              1070,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_open_append",
            "parameters": {
              "p": "pcap_t",
              "fname": "char"
            },
            "return_type": "pcap_dumper_t"
          }
        },
        {
          "fn_code": "FILE *\npcap_dump_file(pcap_dumper_t *p)\n{\n\treturn ((FILE *)p);\n}",
          "fn_code_pos": [
            [
              1072,
              0
            ],
            [
              1076,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_file",
            "parameters": {
              "p": "pcap_dumper_t"
            },
            "return_type": "FILE"
          }
        },
        {
          "fn_code": "long\npcap_dump_ftell(pcap_dumper_t *p)\n{\n\treturn (ftell((FILE *)p));\n}",
          "fn_code_pos": [
            [
              1078,
              0
            ],
            [
              1082,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_ftell",
            "parameters": {
              "p": "pcap_dumper_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "int64_t\npcap_dump_ftell64(pcap_dumper_t *p)\n{\n\treturn (ftello((FILE *)p));\n}",
          "fn_code_pos": [
            [
              1091,
              0
            ],
            [
              1095,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_ftell64",
            "parameters": {
              "p": "pcap_dumper_t"
            },
            "return_type": "int64_t"
          }
        },
        {
          "fn_code": "int64_t\npcap_dump_ftell64(pcap_dumper_t *p)\n{\n\treturn (_ftelli64((FILE *)p));\n}",
          "fn_code_pos": [
            [
              1101,
              0
            ],
            [
              1105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_ftell64",
            "parameters": {
              "p": "pcap_dumper_t"
            },
            "return_type": "int64_t"
          }
        },
        {
          "fn_code": "int64_t\npcap_dump_ftell64(pcap_dumper_t *p)\n{\n\treturn (ftell((FILE *)p));\n}",
          "fn_code_pos": [
            [
              1116,
              0
            ],
            [
              1120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_ftell64",
            "parameters": {
              "p": "pcap_dumper_t"
            },
            "return_type": "int64_t"
          }
        },
        {
          "fn_code": "int\npcap_dump_flush(pcap_dumper_t *p)\n{\n\n\tif (fflush((FILE *)p) == EOF)\n\t\treturn (-1);\n\telse\n\t\treturn (0);\n}",
          "fn_code_pos": [
            [
              1123,
              0
            ],
            [
              1131,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_flush",
            "parameters": {
              "p": "pcap_dumper_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\npcap_dump_close(pcap_dumper_t *p)\n{\n\n#ifdef notyet\n\tif (ferror((FILE *)p))\n\t\treturn-an-error;\n\t/* XXX should check return from fclose() too */\n#endif\n\t(void)fclose((FILE *)p);\n}",
          "fn_code_pos": [
            [
              1133,
              0
            ],
            [
              1143,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_close",
            "parameters": {
              "p": "pcap_dumper_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "pcap_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **datap)",
          "fn_dec_pos": [
            [
              110,
              11
            ],
            [
              110,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_next_packet",
            "parameters": {
              "p": "pcap_t",
              "hdr": "struct pcap_pkthdr",
              "datap": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_dump_fopen(pcap_t *p, FILE *f)",
          "fn_dec_pos": [
            [
              123,
              22
            ],
            [
              123,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_fopen",
            "parameters": {
              "p": "pcap_t",
              "f": "FILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_check_header(bpf_u_int32 magic, FILE *fp, u_int precision, char *errbuf,\n\t\t  int *err)",
          "fn_dec_pos": [
            [
              152,
              0
            ],
            [
              153,
              13
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_check_header",
            "parameters": {
              "magic": "bpf_u_int32",
              "fp": "FILE",
              "precision": "u_int",
              "errbuf": "char",
              "err": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_setup_dump(pcap_t *p, int linktype, FILE *f, const char *fname)",
          "fn_dec_pos": [
            [
              771,
              0
            ],
            [
              771,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setup_dump",
            "parameters": {
              "p": "pcap_t",
              "linktype": "int",
              "f": "FILE",
              "fname": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_dump_open(pcap_t *p, const char *fname)",
          "fn_dec_pos": [
            [
              801,
              0
            ],
            [
              801,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_open",
            "parameters": {
              "p": "pcap_t",
              "fname": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_dump_hopen(pcap_t *p, intptr_t osfd)",
          "fn_dec_pos": [
            [
              856,
              0
            ],
            [
              856,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_hopen",
            "parameters": {
              "p": "pcap_t",
              "osfd": "intptr_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_dump_fopen(pcap_t *p, FILE *f)",
          "fn_dec_pos": [
            [
              887,
              0
            ],
            [
              887,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_fopen",
            "parameters": {
              "p": "pcap_t",
              "f": "FILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_dump_open_append(pcap_t *p, const char *fname)",
          "fn_dec_pos": [
            [
              904,
              0
            ],
            [
              904,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_open_append",
            "parameters": {
              "p": "pcap_t",
              "fname": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_dump_file(pcap_dumper_t *p)",
          "fn_dec_pos": [
            [
              1073,
              0
            ],
            [
              1073,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_file",
            "parameters": {
              "p": "pcap_dumper_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_sf {\n\tsize_t hdrsize;\n\tswapped_type_t lengths_swapped;\n\ttstamp_scale_type_t scale_type;\n}",
          {
            "hdrsize": "size_t",
            "lengths_swapped": "swapped_type_t",
            "scale_type": "tstamp_scale_type_t"
          },
          "pcap_sf",
          [
            141,
            0
          ],
          [
            145,
            1
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            110,
            39
          ],
          [
            110,
            57
          ]
        ],
        [
          "struct pcap_sf {\n\tsize_t hdrsize;\n\tswapped_type_t lengths_swapped;\n\ttstamp_scale_type_t scale_type;\n}",
          {
            "hdrsize": "size_t",
            "lengths_swapped": "swapped_type_t",
            "scale_type": "tstamp_scale_type_t"
          },
          "pcap_sf",
          [
            141,
            0
          ],
          [
            145,
            1
          ]
        ],
        [
          "struct pcap_file_header",
          {},
          "",
          [
            155,
            1
          ],
          [
            155,
            24
          ]
        ],
        [
          "struct pcap_sf",
          {},
          "",
          [
            159,
            1
          ],
          [
            159,
            15
          ]
        ],
        [
          "struct pcap_sf",
          {},
          "",
          [
            238,
            46
          ],
          [
            238,
            60
          ]
        ],
        [
          "struct pcap_sf_patched_pkthdr",
          {},
          "",
          [
            364,
            23
          ],
          [
            364,
            52
          ]
        ],
        [
          "struct pcap_sf_pkthdr",
          {},
          "",
          [
            396,
            23
          ],
          [
            396,
            44
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            447,
            28
          ],
          [
            447,
            46
          ]
        ],
        [
          "struct pcap_sf",
          {},
          "",
          [
            449,
            1
          ],
          [
            449,
            15
          ]
        ],
        [
          "struct pcap_sf_patched_pkthdr",
          {},
          "",
          [
            450,
            1
          ],
          [
            450,
            30
          ]
        ],
        [
          "struct pcap_file_header",
          {},
          "",
          [
            724,
            1
          ],
          [
            724,
            24
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            751,
            30
          ],
          [
            751,
            48
          ]
        ],
        [
          "struct pcap_sf_pkthdr",
          {},
          "",
          [
            754,
            1
          ],
          [
            754,
            22
          ]
        ],
        [
          "struct pcap_file_header",
          {},
          "",
          [
            909,
            1
          ],
          [
            909,
            24
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <pcap-types.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <io.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <memory.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <limits.h> /* for INT_MAX */\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"pcap-common.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include \"sf-pcap.h\"\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n\tNOT_SWAPPED,\n\tSWAPPED,\n\tMAYBE_SWAPPED\n} swapped_type_t;",
          {
            "NOT_SWAPPED": "",
            "SWAPPED": "",
            "MAYBE_SWAPPED": ""
          },
          "swapped_type_t",
          [
            129,
            0
          ],
          [
            133,
            17
          ]
        ],
        [
          "typedef enum {\n\tPASS_THROUGH,\n\tSCALE_UP,\n\tSCALE_DOWN\n} tstamp_scale_type_t;",
          {
            "PASS_THROUGH": "",
            "SCALE_UP": "",
            "SCALE_DOWN": ""
          },
          "tstamp_scale_type_t",
          [
            135,
            0
          ],
          [
            139,
            22
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/optimize.c": {
      "fn_def_list": [
        {
          "fn_code": "PCAP_API_DEF void\npcap_set_optimizer_debug(int value)\n{\n\tpcap_optimizer_debug = value;\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_optimizer_debug",
            "parameters": {
              "value": "int"
            },
            "return_type": "PCAP_API_DEF"
          }
        },
        {
          "fn_code": "PCAP_API_DEF void\npcap_set_print_dot_graph(int value)\n{\n\tpcap_print_dot_graph = value;\n}",
          "fn_code_pos": [
            [
              91,
              0
            ],
            [
              95,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_print_dot_graph",
            "parameters": {
              "value": "int"
            },
            "return_type": "PCAP_API_DEF"
          }
        },
        {
          "fn_code": "static __forceinline int\nlowest_set_bit(int mask)\n{\n\tunsigned long bit;\n\n\t/*\n\t * Don't sign-extend mask if long is longer than int.\n\t * (It's currently not, in MSVC, even on 64-bit platforms, but....)\n\t */\n\tif (_BitScanForward(&bit, (unsigned int)mask) == 0)\n\t\treturn -1;\t/* mask is zero */\n\treturn (int)bit;\n}",
          "fn_code_pos": [
            [
              129,
              0
            ],
            [
              141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lowest_set_bit",
            "parameters": {
              "mask": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nlowest_set_bit(int mask)\n{\n\tunsigned int v = (unsigned int)mask;\n\n\tstatic const int MultiplyDeBruijnBitPosition[32] = {\n\t\t0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,\n\t\t31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9\n\t};\n\n\t/*\n\t * We strip off all but the lowermost set bit (v & ~v),\n\t * and perform a minimal perfect hash on it to look up the\n\t * number of low-order zero bits in a table.\n\t *\n\t * See:\n\t *\n\t *\thttp://7ooo.mooo.com/text/ComputingTrailingZerosHOWTO.pdf\n\t *\n\t *\thttp://supertech.csail.mit.edu/papers/debruijn.pdf\n\t */\n\treturn (MultiplyDeBruijnBitPosition[((v & -v) * 0x077CB531U) >> 27]);\n}",
          "fn_code_pos": [
            [
              161,
              0
            ],
            [
              183,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lowest_set_bit",
            "parameters": {
              "mask": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nfind_levels_r(opt_state_t *opt_state, struct icode *ic, struct block *b)\n{\n\tint level;\n\n\tif (isMarked(ic, b))\n\t\treturn;\n\n\tMark(ic, b);\n\tb->link = 0;\n\n\tif (JT(b)) {\n\t\tfind_levels_r(opt_state, ic, JT(b));\n\t\tfind_levels_r(opt_state, ic, JF(b));\n\t\tlevel = MAX(JT(b)->level, JF(b)->level) + 1;\n\t} else\n\t\tlevel = 0;\n\tb->level = level;\n\tb->link = opt_state->levels[level];\n\topt_state->levels[level] = b;\n}",
          "fn_code_pos": [
            [
              360,
              0
            ],
            [
              380,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_levels_r",
            "parameters": {
              "opt_state": "opt_state_t",
              "ic": "struct icode",
              "b": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nfind_levels(opt_state_t *opt_state, struct icode *ic)\n{\n\tmemset((char *)opt_state->levels, 0, opt_state->n_blocks * sizeof(*opt_state->levels));\n\tunMarkAll(ic);\n\tfind_levels_r(opt_state, ic, ic->root);\n}",
          "fn_code_pos": [
            [
              388,
              0
            ],
            [
              394,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_levels",
            "parameters": {
              "opt_state": "opt_state_t",
              "ic": "struct icode"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nfind_dom(opt_state_t *opt_state, struct block *root)\n{\n\tint i;\n\tstruct block *b;\n\tbpf_u_int32 *x;\n\n\t/*\n\t * Initialize sets to contain all nodes.\n\t */\n\tx = opt_state->all_dom_sets;\n\ti = opt_state->n_blocks * opt_state->nodewords;\n\twhile (--i >= 0)\n\t\t*x++ = 0xFFFFFFFFU;\n\t/* Root starts off empty. */\n\tfor (i = opt_state->nodewords; --i >= 0;)\n\t\troot->dom[i] = 0;\n\n\t/* root->level is the highest level no found. */\n\tfor (i = root->level; i >= 0; --i) {\n\t\tfor (b = opt_state->levels[i]; b; b = b->link) {\n\t\t\tSET_INSERT(b->dom, b->id);\n\t\t\tif (JT(b) == 0)\n\t\t\t\tcontinue;\n\t\t\tSET_INTERSECT(JT(b)->dom, b->dom, opt_state->nodewords);\n\t\t\tSET_INTERSECT(JF(b)->dom, b->dom, opt_state->nodewords);\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              400,
              0
            ],
            [
              428,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_dom",
            "parameters": {
              "opt_state": "opt_state_t",
              "root": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\npropedom(opt_state_t *opt_state, struct edge *ep)\n{\n\tSET_INSERT(ep->edom, ep->id);\n\tif (ep->succ) {\n\t\tSET_INTERSECT(ep->succ->et.edom, ep->edom, opt_state->edgewords);\n\t\tSET_INTERSECT(ep->succ->ef.edom, ep->edom, opt_state->edgewords);\n\t}\n}",
          "fn_code_pos": [
            [
              430,
              0
            ],
            [
              438,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "propedom",
            "parameters": {
              "opt_state": "opt_state_t",
              "ep": "struct edge"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nfind_edom(opt_state_t *opt_state, struct block *root)\n{\n\tint i;\n\tuset x;\n\tstruct block *b;\n\n\tx = opt_state->all_edge_sets;\n\tfor (i = opt_state->n_edges * opt_state->edgewords; --i >= 0; )\n\t\tx[i] = 0xFFFFFFFFU;\n\n\t/* root->level is the highest level no found. */\n\tmemset(root->et.edom, 0, opt_state->edgewords * sizeof(*(uset)0));\n\tmemset(root->ef.edom, 0, opt_state->edgewords * sizeof(*(uset)0));\n\tfor (i = root->level; i >= 0; --i) {\n\t\tfor (b = opt_state->levels[i]; b != 0; b = b->link) {\n\t\t\tpropedom(opt_state, &b->et);\n\t\t\tpropedom(opt_state, &b->ef);\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              444,
              0
            ],
            [
              464,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_edom",
            "parameters": {
              "opt_state": "opt_state_t",
              "root": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nfind_closure(opt_state_t *opt_state, struct block *root)\n{\n\tint i;\n\tstruct block *b;\n\n\t/*\n\t * Initialize sets to contain no nodes.\n\t */\n\tmemset((char *)opt_state->all_closure_sets, 0,\n\t      opt_state->n_blocks * opt_state->nodewords * sizeof(*opt_state->all_closure_sets));\n\n\t/* root->level is the highest level no found. */\n\tfor (i = root->level; i >= 0; --i) {\n\t\tfor (b = opt_state->levels[i]; b; b = b->link) {\n\t\t\tSET_INSERT(b->closure, b->id);\n\t\t\tif (JT(b) == 0)\n\t\t\t\tcontinue;\n\t\t\tSET_UNION(JT(b)->closure, b->closure, opt_state->nodewords);\n\t\t\tSET_UNION(JF(b)->closure, b->closure, opt_state->nodewords);\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              473,
              0
            ],
            [
              495,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_closure",
            "parameters": {
              "opt_state": "opt_state_t",
              "root": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\natomuse(struct stmt *s)\n{\n\tregister int c = s->code;\n\n\tif (c == NOP)\n\t\treturn -1;\n\n\tswitch (BPF_CLASS(c)) {\n\n\tcase BPF_RET:\n\t\treturn (BPF_RVAL(c) == BPF_A) ? A_ATOM :\n\t\t\t(BPF_RVAL(c) == BPF_X) ? X_ATOM : -1;\n\n\tcase BPF_LD:\n\tcase BPF_LDX:\n\t\t/*\n\t\t * As there are fewer than 2^31 memory locations,\n\t\t * s->k should be convertable to int without problems.\n\t\t */\n\t\treturn (BPF_MODE(c) == BPF_IND) ? X_ATOM :\n\t\t\t(BPF_MODE(c) == BPF_MEM) ? (int)s->k : -1;\n\n\tcase BPF_ST:\n\t\treturn A_ATOM;\n\n\tcase BPF_STX:\n\t\treturn X_ATOM;\n\n\tcase BPF_JMP:\n\tcase BPF_ALU:\n\t\tif (BPF_SRC(c) == BPF_X)\n\t\t\treturn AX_ATOM;\n\t\treturn A_ATOM;\n\n\tcase BPF_MISC:\n\t\treturn BPF_MISCOP(c) == BPF_TXA ? X_ATOM : A_ATOM;\n\t}\n\tabort();\n\t/* NOTREACHED */\n}",
          "fn_code_pos": [
            [
              506,
              0
            ],
            [
              546,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "atomuse",
            "parameters": {
              "s": "struct stmt"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\natomdef(struct stmt *s)\n{\n\tif (s->code == NOP)\n\t\treturn -1;\n\n\tswitch (BPF_CLASS(s->code)) {\n\n\tcase BPF_LD:\n\tcase BPF_ALU:\n\t\treturn A_ATOM;\n\n\tcase BPF_LDX:\n\t\treturn X_ATOM;\n\n\tcase BPF_ST:\n\tcase BPF_STX:\n\t\treturn s->k;\n\n\tcase BPF_MISC:\n\t\treturn BPF_MISCOP(s->code) == BPF_TAX ? X_ATOM : A_ATOM;\n\t}\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              555,
              0
            ],
            [
              578,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "atomdef",
            "parameters": {
              "s": "struct stmt"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ncompute_local_ud(struct block *b)\n{\n\tstruct slist *s;\n\tatomset def = 0, use = 0, killed = 0;\n\tint atom;\n\n\tfor (s = b->stmts; s; s = s->next) {\n\t\tif (s->s.code == NOP)\n\t\t\tcontinue;\n\t\tatom = atomuse(&s->s);\n\t\tif (atom >= 0) {\n\t\t\tif (atom == AX_ATOM) {\n\t\t\t\tif (!ATOMELEM(def, X_ATOM))\n\t\t\t\t\tuse |= ATOMMASK(X_ATOM);\n\t\t\t\tif (!ATOMELEM(def, A_ATOM))\n\t\t\t\t\tuse |= ATOMMASK(A_ATOM);\n\t\t\t}\n\t\t\telse if (atom < N_ATOMS) {\n\t\t\t\tif (!ATOMELEM(def, atom))\n\t\t\t\t\tuse |= ATOMMASK(atom);\n\t\t\t}\n\t\t\telse\n\t\t\t\tabort();\n\t\t}\n\t\tatom = atomdef(&s->s);\n\t\tif (atom >= 0) {\n\t\t\tif (!ATOMELEM(use, atom))\n\t\t\t\tkilled |= ATOMMASK(atom);\n\t\t\tdef |= ATOMMASK(atom);\n\t\t}\n\t}\n\tif (BPF_CLASS(b->s.code) == BPF_JMP) {\n\t\t/*\n\t\t * XXX - what about RET?\n\t\t */\n\t\tatom = atomuse(&b->s);\n\t\tif (atom >= 0) {\n\t\t\tif (atom == AX_ATOM) {\n\t\t\t\tif (!ATOMELEM(def, X_ATOM))\n\t\t\t\t\tuse |= ATOMMASK(X_ATOM);\n\t\t\t\tif (!ATOMELEM(def, A_ATOM))\n\t\t\t\t\tuse |= ATOMMASK(A_ATOM);\n\t\t\t}\n\t\t\telse if (atom < N_ATOMS) {\n\t\t\t\tif (!ATOMELEM(def, atom))\n\t\t\t\t\tuse |= ATOMMASK(atom);\n\t\t\t}\n\t\t\telse\n\t\t\t\tabort();\n\t\t}\n\t}\n\n\tb->def = def;\n\tb->kill = killed;\n\tb->in_use = use;\n}",
          "fn_code_pos": [
            [
              591,
              0
            ],
            [
              647,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compute_local_ud",
            "parameters": {
              "b": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nfind_ud(opt_state_t *opt_state, struct block *root)\n{\n\tint i, maxlevel;\n\tstruct block *p;\n\n\t/*\n\t * root->level is the highest level no found;\n\t * count down from there.\n\t */\n\tmaxlevel = root->level;\n\tfor (i = maxlevel; i >= 0; --i)\n\t\tfor (p = opt_state->levels[i]; p; p = p->link) {\n\t\t\tcompute_local_ud(p);\n\t\t\tp->out_use = 0;\n\t\t}\n\n\tfor (i = 1; i <= maxlevel; ++i) {\n\t\tfor (p = opt_state->levels[i]; p; p = p->link) {\n\t\t\tp->out_use |= JT(p)->in_use | JF(p)->in_use;\n\t\t\tp->in_use |= p->out_use &~ p->kill;\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              652,
              0
            ],
            [
              675,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_ud",
            "parameters": {
              "opt_state": "opt_state_t",
              "root": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ninit_val(opt_state_t *opt_state)\n{\n\topt_state->curval = 0;\n\topt_state->next_vnode = opt_state->vnode_base;\n\tmemset((char *)opt_state->vmap, 0, opt_state->maxval * sizeof(*opt_state->vmap));\n\tmemset((char *)opt_state->hashtbl, 0, sizeof opt_state->hashtbl);\n}",
          "fn_code_pos": [
            [
              676,
              0
            ],
            [
              683,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "init_val",
            "parameters": {
              "opt_state": "opt_state_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static bpf_u_int32\nF(opt_state_t *opt_state, int code, bpf_u_int32 v0, bpf_u_int32 v1)\n{\n\tu_int hash;\n\tbpf_u_int32 val;\n\tstruct valnode *p;\n\n\thash = (u_int)code ^ (v0 << 4) ^ (v1 << 8);\n\thash %= MODULUS;\n\n\tfor (p = opt_state->hashtbl[hash]; p; p = p->next)\n\t\tif (p->code == code && p->v0 == v0 && p->v1 == v1)\n\t\t\treturn p->val;\n\n\t/*\n\t * Not found.  Allocate a new value, and assign it a new\n\t * value number.\n\t *\n\t * opt_state->curval starts out as 0, which means VAL_UNKNOWN; we\n\t * increment it before using it as the new value number, which\n\t * means we never assign VAL_UNKNOWN.\n\t *\n\t * XXX - unless we overflow, but we probably won't have 2^32-1\n\t * values; we treat 32 bits as effectively infinite.\n\t */\n\tval = ++opt_state->curval;\n\tif (BPF_MODE(code) == BPF_IMM &&\n\t    (BPF_CLASS(code) == BPF_LD || BPF_CLASS(code) == BPF_LDX)) {\n\t\topt_state->vmap[val].const_val = v0;\n\t\topt_state->vmap[val].is_const = 1;\n\t}\n\tp = opt_state->next_vnode++;\n\tp->val = val;\n\tp->code = code;\n\tp->v0 = v0;\n\tp->v1 = v1;\n\tp->next = opt_state->hashtbl[hash];\n\topt_state->hashtbl[hash] = p;\n\n\treturn val;\n}",
          "fn_code_pos": [
            [
              694,
              0
            ],
            [
              734,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "F",
            "parameters": {
              "opt_state": "opt_state_t",
              "code": "int",
              "v0": "bpf_u_int32",
              "v1": "bpf_u_int32"
            },
            "return_type": "bpf_u_int32"
          }
        },
        {
          "fn_code": "static inline void\nvstore(struct stmt *s, bpf_u_int32 *valp, bpf_u_int32 newval, int alter)\n{\n\tif (alter && newval != VAL_UNKNOWN && *valp == newval)\n\t\ts->code = NOP;\n\telse\n\t\t*valp = newval;\n}",
          "fn_code_pos": [
            [
              736,
              0
            ],
            [
              743,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "vstore",
            "parameters": {
              "s": "struct stmt",
              "valp": "bpf_u_int32",
              "newval": "bpf_u_int32",
              "alter": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nfold_op(opt_state_t *opt_state, struct stmt *s, bpf_u_int32 v0, bpf_u_int32 v1)\n{\n\tbpf_u_int32 a, b;\n\n\ta = opt_state->vmap[v0].const_val;\n\tb = opt_state->vmap[v1].const_val;\n\n\tswitch (BPF_OP(s->code)) {\n\tcase BPF_ADD:\n\t\ta += b;\n\t\tbreak;\n\n\tcase BPF_SUB:\n\t\ta -= b;\n\t\tbreak;\n\n\tcase BPF_MUL:\n\t\ta *= b;\n\t\tbreak;\n\n\tcase BPF_DIV:\n\t\tif (b == 0)\n\t\t\topt_error(opt_state, \"division by zero\");\n\t\ta /= b;\n\t\tbreak;\n\n\tcase BPF_MOD:\n\t\tif (b == 0)\n\t\t\topt_error(opt_state, \"modulus by zero\");\n\t\ta %= b;\n\t\tbreak;\n\n\tcase BPF_AND:\n\t\ta &= b;\n\t\tbreak;\n\n\tcase BPF_OR:\n\t\ta |= b;\n\t\tbreak;\n\n\tcase BPF_XOR:\n\t\ta ^= b;\n\t\tbreak;\n\n\tcase BPF_LSH:\n\t\t/*\n\t\t * A left shift of more than the width of the type\n\t\t * is undefined in C; we'll just treat it as shifting\n\t\t * all the bits out.\n\t\t *\n\t\t * XXX - the BPF interpreter doesn't check for this,\n\t\t * so its behavior is dependent on the behavior of\n\t\t * the processor on which it's running.  There are\n\t\t * processors on which it shifts all the bits out\n\t\t * and processors on which it does no shift.\n\t\t */\n\t\tif (b < 32)\n\t\t\ta <<= b;\n\t\telse\n\t\t\ta = 0;\n\t\tbreak;\n\n\tcase BPF_RSH:\n\t\t/*\n\t\t * A right shift of more than the width of the type\n\t\t * is undefined in C; we'll just treat it as shifting\n\t\t * all the bits out.\n\t\t *\n\t\t * XXX - the BPF interpreter doesn't check for this,\n\t\t * so its behavior is dependent on the behavior of\n\t\t * the processor on which it's running.  There are\n\t\t * processors on which it shifts all the bits out\n\t\t * and processors on which it does no shift.\n\t\t */\n\t\tif (b < 32)\n\t\t\ta >>= b;\n\t\telse\n\t\t\ta = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\ts->k = a;\n\ts->code = BPF_LD|BPF_IMM;\n\topt_state->done = 0;\n}",
          "fn_code_pos": [
            [
              749,
              0
            ],
            [
              836,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fold_op",
            "parameters": {
              "opt_state": "opt_state_t",
              "s": "struct stmt",
              "v0": "bpf_u_int32",
              "v1": "bpf_u_int32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static inline struct slist *\nthis_op(struct slist *s)\n{\n\twhile (s != 0 && s->s.code == NOP)\n\t\ts = s->next;\n\treturn s;\n}",
          "fn_code_pos": [
            [
              838,
              0
            ],
            [
              844,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "this_op",
            "parameters": {
              "s": "struct slist"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void\nopt_not(struct block *b)\n{\n\tstruct block *tmp = JT(b);\n\n\tJT(b) = JF(b);\n\tJF(b) = tmp;\n}",
          "fn_code_pos": [
            [
              846,
              0
            ],
            [
              853,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_not",
            "parameters": {
              "b": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nopt_peep(opt_state_t *opt_state, struct block *b)\n{\n\tstruct slist *s;\n\tstruct slist *next, *last;\n\tbpf_u_int32 val;\n\n\ts = b->stmts;\n\tif (s == 0)\n\t\treturn;\n\n\tlast = s;\n\tfor (/*empty*/; /*empty*/; s = next) {\n\t\t/*\n\t\t * Skip over nops.\n\t\t */\n\t\ts = this_op(s);\n\t\tif (s == 0)\n\t\t\tbreak;\t/* nothing left in the block */\n\n\t\t/*\n\t\t * Find the next real instruction after that one\n\t\t * (skipping nops).\n\t\t */\n\t\tnext = this_op(s->next);\n\t\tif (next == 0)\n\t\t\tbreak;\t/* no next instruction */\n\t\tlast = next;\n\n\t\t/*\n\t\t * st  M[k]\t-->\tst  M[k]\n\t\t * ldx M[k]\t\ttax\n\t\t */\n\t\tif (s->s.code == BPF_ST &&\n\t\t    next->s.code == (BPF_LDX|BPF_MEM) &&\n\t\t    s->s.k == next->s.k) {\n\t\t\topt_state->done = 0;\n\t\t\tnext->s.code = BPF_MISC|BPF_TAX;\n\t\t}\n\t\t/*\n\t\t * ld  #k\t-->\tldx  #k\n\t\t * tax\t\t\ttxa\n\t\t */\n\t\tif (s->s.code == (BPF_LD|BPF_IMM) &&\n\t\t    next->s.code == (BPF_MISC|BPF_TAX)) {\n\t\t\ts->s.code = BPF_LDX|BPF_IMM;\n\t\t\tnext->s.code = BPF_MISC|BPF_TXA;\n\t\t\topt_state->done = 0;\n\t\t}\n\t\t/*\n\t\t * This is an ugly special case, but it happens\n\t\t * when you say tcp[k] or udp[k] where k is a constant.\n\t\t */\n\t\tif (s->s.code == (BPF_LD|BPF_IMM)) {\n\t\t\tstruct slist *add, *tax, *ild;\n\n\t\t\t/*\n\t\t\t * Check that X isn't used on exit from this\n\t\t\t * block (which the optimizer might cause).\n\t\t\t * We know the code generator won't generate\n\t\t\t * any local dependencies.\n\t\t\t */\n\t\t\tif (ATOMELEM(b->out_use, X_ATOM))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Check that the instruction following the ldi\n\t\t\t * is an addx, or it's an ldxms with an addx\n\t\t\t * following it (with 0 or more nops between the\n\t\t\t * ldxms and addx).\n\t\t\t */\n\t\t\tif (next->s.code != (BPF_LDX|BPF_MSH|BPF_B))\n\t\t\t\tadd = next;\n\t\t\telse\n\t\t\t\tadd = this_op(next->next);\n\t\t\tif (add == 0 || add->s.code != (BPF_ALU|BPF_ADD|BPF_X))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Check that a tax follows that (with 0 or more\n\t\t\t * nops between them).\n\t\t\t */\n\t\t\ttax = this_op(add->next);\n\t\t\tif (tax == 0 || tax->s.code != (BPF_MISC|BPF_TAX))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * Check that an ild follows that (with 0 or more\n\t\t\t * nops between them).\n\t\t\t */\n\t\t\tild = this_op(tax->next);\n\t\t\tif (ild == 0 || BPF_CLASS(ild->s.code) != BPF_LD ||\n\t\t\t    BPF_MODE(ild->s.code) != BPF_IND)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * We want to turn this sequence:\n\t\t\t *\n\t\t\t * (004) ldi     #0x2\t\t{s}\n\t\t\t * (005) ldxms   [14]\t\t{next}  -- optional\n\t\t\t * (006) addx\t\t\t{add}\n\t\t\t * (007) tax\t\t\t{tax}\n\t\t\t * (008) ild     [x+0]\t\t{ild}\n\t\t\t *\n\t\t\t * into this sequence:\n\t\t\t *\n\t\t\t * (004) nop\n\t\t\t * (005) ldxms   [14]\n\t\t\t * (006) nop\n\t\t\t * (007) nop\n\t\t\t * (008) ild     [x+2]\n\t\t\t *\n\t\t\t * XXX We need to check that X is not\n\t\t\t * subsequently used, because we want to change\n\t\t\t * what'll be in it after this sequence.\n\t\t\t *\n\t\t\t * We know we can eliminate the accumulator\n\t\t\t * modifications earlier in the sequence since\n\t\t\t * it is defined by the last stmt of this sequence\n\t\t\t * (i.e., the last statement of the sequence loads\n\t\t\t * a value into the accumulator, so we can eliminate\n\t\t\t * earlier operations on the accumulator).\n\t\t\t */\n\t\t\tild->s.k += s->s.k;\n\t\t\ts->s.code = NOP;\n\t\t\tadd->s.code = NOP;\n\t\t\ttax->s.code = NOP;\n\t\t\topt_state->done = 0;\n\t\t}\n\t}\n\t/*\n\t * If the comparison at the end of a block is an equality\n\t * comparison against a constant, and nobody uses the value\n\t * we leave in the A register at the end of a block, and\n\t * the operation preceding the comparison is an arithmetic\n\t * operation, we can sometime optimize it away.\n\t */\n\tif (b->s.code == (BPF_JMP|BPF_JEQ|BPF_K) &&\n\t    !ATOMELEM(b->out_use, A_ATOM)) {\n\t    \t/*\n\t    \t * We can optimize away certain subtractions of the\n\t    \t * X register.\n\t    \t */\n\t\tif (last->s.code == (BPF_ALU|BPF_SUB|BPF_X)) {\n\t\t\tval = b->val[X_ATOM];\n\t\t\tif (opt_state->vmap[val].is_const) {\n\t\t\t\t/*\n\t\t\t\t * If we have a subtract to do a comparison,\n\t\t\t\t * and the X register is a known constant,\n\t\t\t\t * we can merge this value into the\n\t\t\t\t * comparison:\n\t\t\t\t *\n\t\t\t\t * sub x  ->\tnop\n\t\t\t\t * jeq #y\tjeq #(x+y)\n\t\t\t\t */\n\t\t\t\tb->s.k += opt_state->vmap[val].const_val;\n\t\t\t\tlast->s.code = NOP;\n\t\t\t\topt_state->done = 0;\n\t\t\t} else if (b->s.k == 0) {\n\t\t\t\t/*\n\t\t\t\t * If the X register isn't a constant,\n\t\t\t\t * and the comparison in the test is\n\t\t\t\t * against 0, we can compare with the\n\t\t\t\t * X register, instead:\n\t\t\t\t *\n\t\t\t\t * sub x  ->\tnop\n\t\t\t\t * jeq #0\tjeq x\n\t\t\t\t */\n\t\t\t\tlast->s.code = NOP;\n\t\t\t\tb->s.code = BPF_JMP|BPF_JEQ|BPF_X;\n\t\t\t\topt_state->done = 0;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Likewise, a constant subtract can be simplified:\n\t\t *\n\t\t * sub #x ->\tnop\n\t\t * jeq #y ->\tjeq #(x+y)\n\t\t */\n\t\telse if (last->s.code == (BPF_ALU|BPF_SUB|BPF_K)) {\n\t\t\tlast->s.code = NOP;\n\t\t\tb->s.k += last->s.k;\n\t\t\topt_state->done = 0;\n\t\t}\n\t\t/*\n\t\t * And, similarly, a constant AND can be simplified\n\t\t * if we're testing against 0, i.e.:\n\t\t *\n\t\t * and #k\tnop\n\t\t * jeq #0  ->\tjset #k\n\t\t */\n\t\telse if (last->s.code == (BPF_ALU|BPF_AND|BPF_K) &&\n\t\t    b->s.k == 0) {\n\t\t\tb->s.k = last->s.k;\n\t\t\tb->s.code = BPF_JMP|BPF_K|BPF_JSET;\n\t\t\tlast->s.code = NOP;\n\t\t\topt_state->done = 0;\n\t\t\topt_not(b);\n\t\t}\n\t}\n\t/*\n\t * jset #0        ->   never\n\t * jset #ffffffff ->   always\n\t */\n\tif (b->s.code == (BPF_JMP|BPF_K|BPF_JSET)) {\n\t\tif (b->s.k == 0)\n\t\t\tJT(b) = JF(b);\n\t\tif (b->s.k == 0xffffffffU)\n\t\t\tJF(b) = JT(b);\n\t}\n\t/*\n\t * If we're comparing against the index register, and the index\n\t * register is a known constant, we can just compare against that\n\t * constant.\n\t */\n\tval = b->val[X_ATOM];\n\tif (opt_state->vmap[val].is_const && BPF_SRC(b->s.code) == BPF_X) {\n\t\tbpf_u_int32 v = opt_state->vmap[val].const_val;\n\t\tb->s.code &= ~BPF_X;\n\t\tb->s.k = v;\n\t}\n\t/*\n\t * If the accumulator is a known constant, we can compute the\n\t * comparison result.\n\t */\n\tval = b->val[A_ATOM];\n\tif (opt_state->vmap[val].is_const && BPF_SRC(b->s.code) == BPF_K) {\n\t\tbpf_u_int32 v = opt_state->vmap[val].const_val;\n\t\tswitch (BPF_OP(b->s.code)) {\n\n\t\tcase BPF_JEQ:\n\t\t\tv = v == b->s.k;\n\t\t\tbreak;\n\n\t\tcase BPF_JGT:\n\t\t\tv = v > b->s.k;\n\t\t\tbreak;\n\n\t\tcase BPF_JGE:\n\t\t\tv = v >= b->s.k;\n\t\t\tbreak;\n\n\t\tcase BPF_JSET:\n\t\t\tv &= b->s.k;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tabort();\n\t\t}\n\t\tif (JF(b) != JT(b))\n\t\t\topt_state->done = 0;\n\t\tif (v)\n\t\t\tJF(b) = JT(b);\n\t\telse\n\t\t\tJT(b) = JF(b);\n\t}\n}",
          "fn_code_pos": [
            [
              855,
              0
            ],
            [
              1110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_peep",
            "parameters": {
              "opt_state": "opt_state_t",
              "b": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nopt_stmt(opt_state_t *opt_state, struct stmt *s, bpf_u_int32 val[], int alter)\n{\n\tint op;\n\tbpf_u_int32 v;\n\n\tswitch (s->code) {\n\n\tcase BPF_LD|BPF_ABS|BPF_W:\n\tcase BPF_LD|BPF_ABS|BPF_H:\n\tcase BPF_LD|BPF_ABS|BPF_B:\n\t\tv = F(opt_state, s->code, s->k, 0L);\n\t\tvstore(s, &val[A_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_LD|BPF_IND|BPF_W:\n\tcase BPF_LD|BPF_IND|BPF_H:\n\tcase BPF_LD|BPF_IND|BPF_B:\n\t\tv = val[X_ATOM];\n\t\tif (alter && opt_state->vmap[v].is_const) {\n\t\t\ts->code = BPF_LD|BPF_ABS|BPF_SIZE(s->code);\n\t\t\ts->k += opt_state->vmap[v].const_val;\n\t\t\tv = F(opt_state, s->code, s->k, 0L);\n\t\t\topt_state->done = 0;\n\t\t}\n\t\telse\n\t\t\tv = F(opt_state, s->code, s->k, v);\n\t\tvstore(s, &val[A_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_LD|BPF_LEN:\n\t\tv = F(opt_state, s->code, 0L, 0L);\n\t\tvstore(s, &val[A_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_LD|BPF_IMM:\n\t\tv = K(s->k);\n\t\tvstore(s, &val[A_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_LDX|BPF_IMM:\n\t\tv = K(s->k);\n\t\tvstore(s, &val[X_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_LDX|BPF_MSH|BPF_B:\n\t\tv = F(opt_state, s->code, s->k, 0L);\n\t\tvstore(s, &val[X_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_NEG:\n\t\tif (alter && opt_state->vmap[val[A_ATOM]].is_const) {\n\t\t\ts->code = BPF_LD|BPF_IMM;\n\t\t\t/*\n\t\t\t * Do this negation as unsigned arithmetic; that's\n\t\t\t * what modern BPF engines do, and it guarantees\n\t\t\t * that all possible values can be negated.  (Yeah,\n\t\t\t * negating 0x80000000, the minimum signed 32-bit\n\t\t\t * two's-complement value, results in 0x80000000,\n\t\t\t * so it's still negative, but we *should* be doing\n\t\t\t * all unsigned arithmetic here, to match what\n\t\t\t * modern BPF engines do.)\n\t\t\t *\n\t\t\t * Express it as 0U - (unsigned value) so that we\n\t\t\t * don't get compiler warnings about negating an\n\t\t\t * unsigned value and don't get UBSan warnings\n\t\t\t * about the result of negating 0x80000000 being\n\t\t\t * undefined.\n\t\t\t */\n\t\t\ts->k = 0U - opt_state->vmap[val[A_ATOM]].const_val;\n\t\t\tval[A_ATOM] = K(s->k);\n\t\t}\n\t\telse\n\t\t\tval[A_ATOM] = F(opt_state, s->code, val[A_ATOM], 0L);\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_ADD|BPF_K:\n\tcase BPF_ALU|BPF_SUB|BPF_K:\n\tcase BPF_ALU|BPF_MUL|BPF_K:\n\tcase BPF_ALU|BPF_DIV|BPF_K:\n\tcase BPF_ALU|BPF_MOD|BPF_K:\n\tcase BPF_ALU|BPF_AND|BPF_K:\n\tcase BPF_ALU|BPF_OR|BPF_K:\n\tcase BPF_ALU|BPF_XOR|BPF_K:\n\tcase BPF_ALU|BPF_LSH|BPF_K:\n\tcase BPF_ALU|BPF_RSH|BPF_K:\n\t\top = BPF_OP(s->code);\n\t\tif (alter) {\n\t\t\tif (s->k == 0) {\n\t\t\t\t/*\n\t\t\t\t * Optimize operations where the constant\n\t\t\t\t * is zero.\n\t\t\t\t *\n\t\t\t\t * Don't optimize away \"sub #0\"\n\t\t\t\t * as it may be needed later to\n\t\t\t\t * fixup the generated math code.\n\t\t\t\t *\n\t\t\t\t * Fail if we're dividing by zero or taking\n\t\t\t\t * a modulus by zero.\n\t\t\t\t */\n\t\t\t\tif (op == BPF_ADD ||\n\t\t\t\t    op == BPF_LSH || op == BPF_RSH ||\n\t\t\t\t    op == BPF_OR || op == BPF_XOR) {\n\t\t\t\t\ts->code = NOP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (op == BPF_MUL || op == BPF_AND) {\n\t\t\t\t\ts->code = BPF_LD|BPF_IMM;\n\t\t\t\t\tval[A_ATOM] = K(s->k);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (op == BPF_DIV)\n\t\t\t\t\topt_error(opt_state,\n\t\t\t\t\t    \"division by zero\");\n\t\t\t\tif (op == BPF_MOD)\n\t\t\t\t\topt_error(opt_state,\n\t\t\t\t\t    \"modulus by zero\");\n\t\t\t}\n\t\t\tif (opt_state->vmap[val[A_ATOM]].is_const) {\n\t\t\t\tfold_op(opt_state, s, val[A_ATOM], K(s->k));\n\t\t\t\tval[A_ATOM] = K(s->k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tval[A_ATOM] = F(opt_state, s->code, val[A_ATOM], K(s->k));\n\t\tbreak;\n\n\tcase BPF_ALU|BPF_ADD|BPF_X:\n\tcase BPF_ALU|BPF_SUB|BPF_X:\n\tcase BPF_ALU|BPF_MUL|BPF_X:\n\tcase BPF_ALU|BPF_DIV|BPF_X:\n\tcase BPF_ALU|BPF_MOD|BPF_X:\n\tcase BPF_ALU|BPF_AND|BPF_X:\n\tcase BPF_ALU|BPF_OR|BPF_X:\n\tcase BPF_ALU|BPF_XOR|BPF_X:\n\tcase BPF_ALU|BPF_LSH|BPF_X:\n\tcase BPF_ALU|BPF_RSH|BPF_X:\n\t\top = BPF_OP(s->code);\n\t\tif (alter && opt_state->vmap[val[X_ATOM]].is_const) {\n\t\t\tif (opt_state->vmap[val[A_ATOM]].is_const) {\n\t\t\t\tfold_op(opt_state, s, val[A_ATOM], val[X_ATOM]);\n\t\t\t\tval[A_ATOM] = K(s->k);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts->code = BPF_ALU|BPF_K|op;\n\t\t\t\ts->k = opt_state->vmap[val[X_ATOM]].const_val;\n\t\t\t\tif ((op == BPF_LSH || op == BPF_RSH) &&\n\t\t\t\t    s->k > 31)\n\t\t\t\t\topt_error(opt_state,\n\t\t\t\t\t    \"shift by more than 31 bits\");\n\t\t\t\topt_state->done = 0;\n\t\t\t\tval[A_ATOM] =\n\t\t\t\t\tF(opt_state, s->code, val[A_ATOM], K(s->k));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Check if we're doing something to an accumulator\n\t\t * that is 0, and simplify.  This may not seem like\n\t\t * much of a simplification but it could open up further\n\t\t * optimizations.\n\t\t * XXX We could also check for mul by 1, etc.\n\t\t */\n\t\tif (alter && opt_state->vmap[val[A_ATOM]].is_const\n\t\t    && opt_state->vmap[val[A_ATOM]].const_val == 0) {\n\t\t\tif (op == BPF_ADD || op == BPF_OR || op == BPF_XOR) {\n\t\t\t\ts->code = BPF_MISC|BPF_TXA;\n\t\t\t\tvstore(s, &val[A_ATOM], val[X_ATOM], alter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (op == BPF_MUL || op == BPF_DIV || op == BPF_MOD ||\n\t\t\t\t op == BPF_AND || op == BPF_LSH || op == BPF_RSH) {\n\t\t\t\ts->code = BPF_LD|BPF_IMM;\n\t\t\t\ts->k = 0;\n\t\t\t\tvstore(s, &val[A_ATOM], K(s->k), alter);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (op == BPF_NEG) {\n\t\t\t\ts->code = NOP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tval[A_ATOM] = F(opt_state, s->code, val[A_ATOM], val[X_ATOM]);\n\t\tbreak;\n\n\tcase BPF_MISC|BPF_TXA:\n\t\tvstore(s, &val[A_ATOM], val[X_ATOM], alter);\n\t\tbreak;\n\n\tcase BPF_LD|BPF_MEM:\n\t\tv = val[s->k];\n\t\tif (alter && opt_state->vmap[v].is_const) {\n\t\t\ts->code = BPF_LD|BPF_IMM;\n\t\t\ts->k = opt_state->vmap[v].const_val;\n\t\t\topt_state->done = 0;\n\t\t}\n\t\tvstore(s, &val[A_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_MISC|BPF_TAX:\n\t\tvstore(s, &val[X_ATOM], val[A_ATOM], alter);\n\t\tbreak;\n\n\tcase BPF_LDX|BPF_MEM:\n\t\tv = val[s->k];\n\t\tif (alter && opt_state->vmap[v].is_const) {\n\t\t\ts->code = BPF_LDX|BPF_IMM;\n\t\t\ts->k = opt_state->vmap[v].const_val;\n\t\t\topt_state->done = 0;\n\t\t}\n\t\tvstore(s, &val[X_ATOM], v, alter);\n\t\tbreak;\n\n\tcase BPF_ST:\n\t\tvstore(s, &val[s->k], val[A_ATOM], alter);\n\t\tbreak;\n\n\tcase BPF_STX:\n\t\tvstore(s, &val[s->k], val[X_ATOM], alter);\n\t\tbreak;\n\t}\n}",
          "fn_code_pos": [
            [
              1118,
              0
            ],
            [
              1339,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_stmt",
            "parameters": {
              "opt_state": "opt_state_t",
              "s": "struct stmt",
              "val": "bpf_u_int32",
              "alter": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ndeadstmt(opt_state_t *opt_state, register struct stmt *s, register struct stmt *last[])\n{\n\tregister int atom;\n\n\tatom = atomuse(s);\n\tif (atom >= 0) {\n\t\tif (atom == AX_ATOM) {\n\t\t\tlast[X_ATOM] = 0;\n\t\t\tlast[A_ATOM] = 0;\n\t\t}\n\t\telse\n\t\t\tlast[atom] = 0;\n\t}\n\tatom = atomdef(s);\n\tif (atom >= 0) {\n\t\tif (last[atom]) {\n\t\t\topt_state->done = 0;\n\t\t\tlast[atom]->code = NOP;\n\t\t}\n\t\tlast[atom] = s;\n\t}\n}",
          "fn_code_pos": [
            [
              1341,
              0
            ],
            [
              1363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deadstmt",
            "parameters": {
              "opt_state": "opt_state_t",
              "s": "struct stmt",
              "last": "struct stmt"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nopt_deadstores(opt_state_t *opt_state, register struct block *b)\n{\n\tregister struct slist *s;\n\tregister int atom;\n\tstruct stmt *last[N_ATOMS];\n\n\tmemset((char *)last, 0, sizeof last);\n\n\tfor (s = b->stmts; s != 0; s = s->next)\n\t\tdeadstmt(opt_state, &s->s, last);\n\tdeadstmt(opt_state, &b->s, last);\n\n\tfor (atom = 0; atom < N_ATOMS; ++atom)\n\t\tif (last[atom] && !ATOMELEM(b->out_use, atom)) {\n\t\t\tlast[atom]->code = NOP;\n\t\t\topt_state->done = 0;\n\t\t}\n}",
          "fn_code_pos": [
            [
              1365,
              0
            ],
            [
              1383,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_deadstores",
            "parameters": {
              "opt_state": "opt_state_t",
              "b": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nopt_blk(opt_state_t *opt_state, struct block *b, int do_stmts)\n{\n\tstruct slist *s;\n\tstruct edge *p;\n\tint i;\n\tbpf_u_int32 aval, xval;\n\n#if 0\n\tfor (s = b->stmts; s && s->next; s = s->next)\n\t\tif (BPF_CLASS(s->s.code) == BPF_JMP) {\n\t\t\tdo_stmts = 0;\n\t\t\tbreak;\n\t\t}\n#endif\n\n\t/*\n\t * Initialize the atom values.\n\t */\n\tp = b->in_edges;\n\tif (p == 0) {\n\t\t/*\n\t\t * We have no predecessors, so everything is undefined\n\t\t * upon entry to this block.\n\t\t */\n\t\tmemset((char *)b->val, 0, sizeof(b->val));\n\t} else {\n\t\t/*\n\t\t * Inherit values from our predecessors.\n\t\t *\n\t\t * First, get the values from the predecessor along the\n\t\t * first edge leading to this node.\n\t\t */\n\t\tmemcpy((char *)b->val, (char *)p->pred->val, sizeof(b->val));\n\t\t/*\n\t\t * Now look at all the other nodes leading to this node.\n\t\t * If, for the predecessor along that edge, a register\n\t\t * has a different value from the one we have (i.e.,\n\t\t * control paths are merging, and the merging paths\n\t\t * assign different values to that register), give the\n\t\t * register the undefined value of 0.\n\t\t */\n\t\twhile ((p = p->next) != NULL) {\n\t\t\tfor (i = 0; i < N_ATOMS; ++i)\n\t\t\t\tif (b->val[i] != p->pred->val[i])\n\t\t\t\t\tb->val[i] = 0;\n\t\t}\n\t}\n\taval = b->val[A_ATOM];\n\txval = b->val[X_ATOM];\n\tfor (s = b->stmts; s; s = s->next)\n\t\topt_stmt(opt_state, &s->s, b->val, do_stmts);\n\n\t/*\n\t * This is a special case: if we don't use anything from this\n\t * block, and we load the accumulator or index register with a\n\t * value that is already there, or if this block is a return,\n\t * eliminate all the statements.\n\t *\n\t * XXX - what if it does a store?\n\t *\n\t * XXX - why does it matter whether we use anything from this\n\t * block?  If the accumulator or index register doesn't change\n\t * its value, isn't that OK even if we use that value?\n\t *\n\t * XXX - if we load the accumulator with a different value,\n\t * and the block ends with a conditional branch, we obviously\n\t * can't eliminate it, as the branch depends on that value.\n\t * For the index register, the conditional branch only depends\n\t * on the index register value if the test is against the index\n\t * register value rather than a constant; if nothing uses the\n\t * value we put into the index register, and we're not testing\n\t * against the index register's value, and there aren't any\n\t * other problems that would keep us from eliminating this\n\t * block, can we eliminate it?\n\t */\n\tif (do_stmts &&\n\t    ((b->out_use == 0 &&\n\t      aval != VAL_UNKNOWN && b->val[A_ATOM] == aval &&\n\t      xval != VAL_UNKNOWN && b->val[X_ATOM] == xval) ||\n\t     BPF_CLASS(b->s.code) == BPF_RET)) {\n\t\tif (b->stmts != 0) {\n\t\t\tb->stmts = 0;\n\t\t\topt_state->done = 0;\n\t\t}\n\t} else {\n\t\topt_peep(opt_state, b);\n\t\topt_deadstores(opt_state, b);\n\t}\n\t/*\n\t * Set up values for branch optimizer.\n\t */\n\tif (BPF_SRC(b->s.code) == BPF_K)\n\t\tb->oval = K(b->s.k);\n\telse\n\t\tb->oval = b->val[X_ATOM];\n\tb->et.code = b->s.code;\n\tb->ef.code = -b->s.code;\n}",
          "fn_code_pos": [
            [
              1385,
              0
            ],
            [
              1483,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_blk",
            "parameters": {
              "opt_state": "opt_state_t",
              "b": "struct block",
              "do_stmts": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nuse_conflict(struct block *b, struct block *succ)\n{\n\tint atom;\n\tatomset use = succ->out_use;\n\n\tif (use == 0)\n\t\treturn 0;\n\n\tfor (atom = 0; atom < N_ATOMS; ++atom)\n\t\tif (ATOMELEM(use, atom))\n\t\t\tif (b->val[atom] != succ->val[atom])\n\t\t\t\treturn 1;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1490,
              0
            ],
            [
              1504,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "use_conflict",
            "parameters": {
              "b": "struct block",
              "succ": "struct block"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static struct block *\nfold_edge(struct block *child, struct edge *ep)\n{\n\tint sense;\n\tbpf_u_int32 aval0, aval1, oval0, oval1;\n\tint code = ep->code;\n\n\tif (code < 0) {\n\t\tcode = -code;\n\t\tsense = 0;\n\t} else\n\t\tsense = 1;\n\n\tif (child->s.code != code)\n\t\treturn 0;\n\n\taval0 = child->val[A_ATOM];\n\toval0 = child->oval;\n\taval1 = ep->pred->val[A_ATOM];\n\toval1 = ep->pred->oval;\n\n\tif (aval0 != aval1)\n\t\treturn 0;\n\n\tif (oval0 == oval1)\n\t\t/*\n\t\t * The operands of the branch instructions are\n\t\t * identical, so the result is true if a true\n\t\t * branch was taken to get here, otherwise false.\n\t\t */\n\t\treturn sense ? JT(child) : JF(child);\n\n\tif (sense && code == (BPF_JMP|BPF_JEQ|BPF_K))\n\t\t/*\n\t\t * At this point, we only know the comparison if we\n\t\t * came down the true branch, and it was an equality\n\t\t * comparison with a constant.\n\t\t *\n\t\t * I.e., if we came down the true branch, and the branch\n\t\t * was an equality comparison with a constant, we know the\n\t\t * accumulator contains that constant.  If we came down\n\t\t * the false branch, or the comparison wasn't with a\n\t\t * constant, we don't know what was in the accumulator.\n\t\t *\n\t\t * We rely on the fact that distinct constants have distinct\n\t\t * value numbers.\n\t\t */\n\t\treturn JF(child);\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1506,
              0
            ],
            [
              1556,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fold_edge",
            "parameters": {
              "child": "struct block",
              "ep": "struct edge"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void\nopt_j(opt_state_t *opt_state, struct edge *ep)\n{\n\tregister int i, k;\n\tregister struct block *target;\n\n\tif (JT(ep->succ) == 0)\n\t\treturn;\n\n\tif (JT(ep->succ) == JF(ep->succ)) {\n\t\t/*\n\t\t * Common branch targets can be eliminated, provided\n\t\t * there is no data dependency.\n\t\t */\n\t\tif (!use_conflict(ep->pred, ep->succ->et.succ)) {\n\t\t\topt_state->done = 0;\n\t\t\tep->succ = JT(ep->succ);\n\t\t}\n\t}\n\t/*\n\t * For each edge dominator that matches the successor of this\n\t * edge, promote the edge successor to the its grandchild.\n\t *\n\t * XXX We violate the set abstraction here in favor a reasonably\n\t * efficient loop.\n\t */\n top:\n\tfor (i = 0; i < opt_state->edgewords; ++i) {\n\t\tregister bpf_u_int32 x = ep->edom[i];\n\n\t\twhile (x != 0) {\n\t\t\tk = lowest_set_bit(x);\n\t\t\tx &=~ ((bpf_u_int32)1 << k);\n\t\t\tk += i * BITS_PER_WORD;\n\n\t\t\ttarget = fold_edge(ep->succ, opt_state->edges[k]);\n\t\t\t/*\n\t\t\t * Check that there is no data dependency between\n\t\t\t * nodes that will be violated if we move the edge.\n\t\t\t */\n\t\t\tif (target != 0 && !use_conflict(ep->pred, target)) {\n\t\t\t\topt_state->done = 0;\n\t\t\t\tep->succ = target;\n\t\t\t\tif (JT(target) != 0)\n\t\t\t\t\t/*\n\t\t\t\t\t * Start over unless we hit a leaf.\n\t\t\t\t\t */\n\t\t\t\t\tgoto top;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              1558,
              0
            ],
            [
              1610,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_j",
            "parameters": {
              "opt_state": "opt_state_t",
              "ep": "struct edge"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nor_pullup(opt_state_t *opt_state, struct block *b)\n{\n\tbpf_u_int32 val;\n\tint at_top;\n\tstruct block *pull;\n\tstruct block **diffp, **samep;\n\tstruct edge *ep;\n\n\tep = b->in_edges;\n\tif (ep == 0)\n\t\treturn;\n\n\t/*\n\t * Make sure each predecessor loads the same value.\n\t * XXX why?\n\t */\n\tval = ep->pred->val[A_ATOM];\n\tfor (ep = ep->next; ep != 0; ep = ep->next)\n\t\tif (val != ep->pred->val[A_ATOM])\n\t\t\treturn;\n\n\tif (JT(b->in_edges->pred) == b)\n\t\tdiffp = &JT(b->in_edges->pred);\n\telse\n\t\tdiffp = &JF(b->in_edges->pred);\n\n\tat_top = 1;\n\tfor (;;) {\n\t\tif (*diffp == 0)\n\t\t\treturn;\n\n\t\tif (JT(*diffp) != JT(b))\n\t\t\treturn;\n\n\t\tif (!SET_MEMBER((*diffp)->dom, b->id))\n\t\t\treturn;\n\n\t\tif ((*diffp)->val[A_ATOM] != val)\n\t\t\tbreak;\n\n\t\tdiffp = &JF(*diffp);\n\t\tat_top = 0;\n\t}\n\tsamep = &JF(*diffp);\n\tfor (;;) {\n\t\tif (*samep == 0)\n\t\t\treturn;\n\n\t\tif (JT(*samep) != JT(b))\n\t\t\treturn;\n\n\t\tif (!SET_MEMBER((*samep)->dom, b->id))\n\t\t\treturn;\n\n\t\tif ((*samep)->val[A_ATOM] == val)\n\t\t\tbreak;\n\n\t\t/* XXX Need to check that there are no data dependencies\n\t\t   between dp0 and dp1.  Currently, the code generator\n\t\t   will not produce such dependencies. */\n\t\tsamep = &JF(*samep);\n\t}\n#ifdef notdef\n\t/* XXX This doesn't cover everything. */\n\tfor (i = 0; i < N_ATOMS; ++i)\n\t\tif ((*samep)->val[i] != pred->val[i])\n\t\t\treturn;\n#endif\n\t/* Pull up the node. */\n\tpull = *samep;\n\t*samep = JF(pull);\n\tJF(pull) = *diffp;\n\n\t/*\n\t * At the top of the chain, each predecessor needs to point at the\n\t * pulled up node.  Inside the chain, there is only one predecessor\n\t * to worry about.\n\t */\n\tif (at_top) {\n\t\tfor (ep = b->in_edges; ep != 0; ep = ep->next) {\n\t\t\tif (JT(ep->pred) == b)\n\t\t\t\tJT(ep->pred) = pull;\n\t\t\telse\n\t\t\t\tJF(ep->pred) = pull;\n\t\t}\n\t}\n\telse\n\t\t*diffp = pull;\n\n\topt_state->done = 0;\n}",
          "fn_code_pos": [
            [
              1613,
              0
            ],
            [
              1704,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "or_pullup",
            "parameters": {
              "opt_state": "opt_state_t",
              "b": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nand_pullup(opt_state_t *opt_state, struct block *b)\n{\n\tbpf_u_int32 val;\n\tint at_top;\n\tstruct block *pull;\n\tstruct block **diffp, **samep;\n\tstruct edge *ep;\n\n\tep = b->in_edges;\n\tif (ep == 0)\n\t\treturn;\n\n\t/*\n\t * Make sure each predecessor loads the same value.\n\t */\n\tval = ep->pred->val[A_ATOM];\n\tfor (ep = ep->next; ep != 0; ep = ep->next)\n\t\tif (val != ep->pred->val[A_ATOM])\n\t\t\treturn;\n\n\tif (JT(b->in_edges->pred) == b)\n\t\tdiffp = &JT(b->in_edges->pred);\n\telse\n\t\tdiffp = &JF(b->in_edges->pred);\n\n\tat_top = 1;\n\tfor (;;) {\n\t\tif (*diffp == 0)\n\t\t\treturn;\n\n\t\tif (JF(*diffp) != JF(b))\n\t\t\treturn;\n\n\t\tif (!SET_MEMBER((*diffp)->dom, b->id))\n\t\t\treturn;\n\n\t\tif ((*diffp)->val[A_ATOM] != val)\n\t\t\tbreak;\n\n\t\tdiffp = &JT(*diffp);\n\t\tat_top = 0;\n\t}\n\tsamep = &JT(*diffp);\n\tfor (;;) {\n\t\tif (*samep == 0)\n\t\t\treturn;\n\n\t\tif (JF(*samep) != JF(b))\n\t\t\treturn;\n\n\t\tif (!SET_MEMBER((*samep)->dom, b->id))\n\t\t\treturn;\n\n\t\tif ((*samep)->val[A_ATOM] == val)\n\t\t\tbreak;\n\n\t\t/* XXX Need to check that there are no data dependencies\n\t\t   between diffp and samep.  Currently, the code generator\n\t\t   will not produce such dependencies. */\n\t\tsamep = &JT(*samep);\n\t}\n#ifdef notdef\n\t/* XXX This doesn't cover everything. */\n\tfor (i = 0; i < N_ATOMS; ++i)\n\t\tif ((*samep)->val[i] != pred->val[i])\n\t\t\treturn;\n#endif\n\t/* Pull up the node. */\n\tpull = *samep;\n\t*samep = JT(pull);\n\tJT(pull) = *diffp;\n\n\t/*\n\t * At the top of the chain, each predecessor needs to point at the\n\t * pulled up node.  Inside the chain, there is only one predecessor\n\t * to worry about.\n\t */\n\tif (at_top) {\n\t\tfor (ep = b->in_edges; ep != 0; ep = ep->next) {\n\t\t\tif (JT(ep->pred) == b)\n\t\t\t\tJT(ep->pred) = pull;\n\t\t\telse\n\t\t\t\tJF(ep->pred) = pull;\n\t\t}\n\t}\n\telse\n\t\t*diffp = pull;\n\n\topt_state->done = 0;\n}",
          "fn_code_pos": [
            [
              1706,
              0
            ],
            [
              1796,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "and_pullup",
            "parameters": {
              "opt_state": "opt_state_t",
              "b": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nopt_blks(opt_state_t *opt_state, struct icode *ic, int do_stmts)\n{\n\tint i, maxlevel;\n\tstruct block *p;\n\n\tinit_val(opt_state);\n\tmaxlevel = ic->root->level;\n\n\tfind_inedges(opt_state, ic->root);\n\tfor (i = maxlevel; i >= 0; --i)\n\t\tfor (p = opt_state->levels[i]; p; p = p->link)\n\t\t\topt_blk(opt_state, p, do_stmts);\n\n\tif (do_stmts)\n\t\t/*\n\t\t * No point trying to move branches; it can't possibly\n\t\t * make a difference at this point.\n\t\t */\n\t\treturn;\n\n\tfor (i = 1; i <= maxlevel; ++i) {\n\t\tfor (p = opt_state->levels[i]; p; p = p->link) {\n\t\t\topt_j(opt_state, &p->et);\n\t\t\topt_j(opt_state, &p->ef);\n\t\t}\n\t}\n\n\tfind_inedges(opt_state, ic->root);\n\tfor (i = 1; i <= maxlevel; ++i) {\n\t\tfor (p = opt_state->levels[i]; p; p = p->link) {\n\t\t\tor_pullup(opt_state, p);\n\t\t\tand_pullup(opt_state, p);\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              1798,
              0
            ],
            [
              1833,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_blks",
            "parameters": {
              "opt_state": "opt_state_t",
              "ic": "struct icode",
              "do_stmts": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static inline void\nlink_inedge(struct edge *parent, struct block *child)\n{\n\tparent->next = child->in_edges;\n\tchild->in_edges = parent;\n}",
          "fn_code_pos": [
            [
              1835,
              0
            ],
            [
              1840,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "link_inedge",
            "parameters": {
              "parent": "struct edge",
              "child": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nfind_inedges(opt_state_t *opt_state, struct block *root)\n{\n\tint i;\n\tstruct block *b;\n\n\tfor (i = 0; i < opt_state->n_blocks; ++i)\n\t\topt_state->blocks[i]->in_edges = 0;\n\n\t/*\n\t * Traverse the graph, adding each edge to the predecessor\n\t * list of its successors.  Skip the leaves (i.e. level 0).\n\t */\n\tfor (i = root->level; i > 0; --i) {\n\t\tfor (b = opt_state->levels[i]; b != 0; b = b->link) {\n\t\t\tlink_inedge(&b->et, JT(b));\n\t\t\tlink_inedge(&b->ef, JF(b));\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              1842,
              0
            ],
            [
              1861,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_inedges",
            "parameters": {
              "opt_state": "opt_state_t",
              "root": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nopt_root(struct block **b)\n{\n\tstruct slist *tmp, *s;\n\n\ts = (*b)->stmts;\n\t(*b)->stmts = 0;\n\twhile (BPF_CLASS((*b)->s.code) == BPF_JMP && JT(*b) == JF(*b))\n\t\t*b = JT(*b);\n\n\ttmp = (*b)->stmts;\n\tif (tmp != 0)\n\t\tsappend(s, tmp);\n\t(*b)->stmts = s;\n\n\t/*\n\t * If the root node is a return, then there is no\n\t * point executing any statements (since the bpf machine\n\t * has no side effects).\n\t */\n\tif (BPF_CLASS((*b)->s.code) == BPF_RET)\n\t\t(*b)->stmts = 0;\n}",
          "fn_code_pos": [
            [
              1863,
              0
            ],
            [
              1885,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_root",
            "parameters": {
              "b": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nopt_loop(opt_state_t *opt_state, struct icode *ic, int do_stmts)\n{\n\n#ifdef BDEBUG\n\tif (pcap_optimizer_debug > 1 || pcap_print_dot_graph) {\n\t\tprintf(\"opt_loop(root, %d) begin\\n\", do_stmts);\n\t\topt_dump(opt_state, ic);\n\t}\n#endif\n\tdo {\n\t\topt_state->done = 1;\n\t\tfind_levels(opt_state, ic);\n\t\tfind_dom(opt_state, ic->root);\n\t\tfind_closure(opt_state, ic->root);\n\t\tfind_ud(opt_state, ic->root);\n\t\tfind_edom(opt_state, ic->root);\n\t\topt_blks(opt_state, ic, do_stmts);\n#ifdef BDEBUG\n\t\tif (pcap_optimizer_debug > 1 || pcap_print_dot_graph) {\n\t\t\tprintf(\"opt_loop(root, %d) bottom, done=%d\\n\", do_stmts, opt_state->done);\n\t\t\topt_dump(opt_state, ic);\n\t\t}\n#endif\n\t} while (!opt_state->done);\n}",
          "fn_code_pos": [
            [
              1887,
              0
            ],
            [
              1912,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_loop",
            "parameters": {
              "opt_state": "opt_state_t",
              "ic": "struct icode",
              "do_stmts": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\nbpf_optimize(struct icode *ic, char *errbuf)\n{\n\topt_state_t opt_state;\n\n\tmemset(&opt_state, 0, sizeof(opt_state));\n\topt_state.errbuf = errbuf;\n\tif (setjmp(opt_state.top_ctx)) {\n\t\topt_cleanup(&opt_state);\n\t\treturn -1;\n\t}\n\topt_init(&opt_state, ic);\n\topt_loop(&opt_state, ic, 0);\n\topt_loop(&opt_state, ic, 1);\n\tintern_blocks(&opt_state, ic);\n#ifdef BDEBUG\n\tif (pcap_optimizer_debug > 1 || pcap_print_dot_graph) {\n\t\tprintf(\"after intern_blocks()\\n\");\n\t\topt_dump(&opt_state, ic);\n\t}\n#endif\n\topt_root(&ic->root);\n#ifdef BDEBUG\n\tif (pcap_optimizer_debug > 1 || pcap_print_dot_graph) {\n\t\tprintf(\"after opt_root()\\n\");\n\t\topt_dump(&opt_state, ic);\n\t}\n#endif\n\topt_cleanup(&opt_state);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1918,
              0
            ],
            [
              1948,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_optimize",
            "parameters": {
              "ic": "struct icode",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nmake_marks(struct icode *ic, struct block *p)\n{\n\tif (!isMarked(ic, p)) {\n\t\tMark(ic, p);\n\t\tif (BPF_CLASS(p->s.code) != BPF_RET) {\n\t\t\tmake_marks(ic, JT(p));\n\t\t\tmake_marks(ic, JF(p));\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              1950,
              0
            ],
            [
              1960,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "make_marks",
            "parameters": {
              "ic": "struct icode",
              "p": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nmark_code(struct icode *ic)\n{\n\tic->cur_mark += 1;\n\tmake_marks(ic, ic->root);\n}",
          "fn_code_pos": [
            [
              1966,
              0
            ],
            [
              1971,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mark_code",
            "parameters": {
              "ic": "struct icode"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\neq_slist(struct slist *x, struct slist *y)\n{\n\tfor (;;) {\n\t\twhile (x && x->s.code == NOP)\n\t\t\tx = x->next;\n\t\twhile (y && y->s.code == NOP)\n\t\t\ty = y->next;\n\t\tif (x == 0)\n\t\t\treturn y == 0;\n\t\tif (y == 0)\n\t\t\treturn x == 0;\n\t\tif (x->s.code != y->s.code || x->s.k != y->s.k)\n\t\t\treturn 0;\n\t\tx = x->next;\n\t\ty = y->next;\n\t}\n}",
          "fn_code_pos": [
            [
              1977,
              0
            ],
            [
              1994,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "eq_slist",
            "parameters": {
              "x": "struct slist",
              "y": "struct slist"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static inline int\neq_blk(struct block *b0, struct block *b1)\n{\n\tif (b0->s.code == b1->s.code &&\n\t    b0->s.k == b1->s.k &&\n\t    b0->et.succ == b1->et.succ &&\n\t    b0->ef.succ == b1->ef.succ)\n\t\treturn eq_slist(b0->stmts, b1->stmts);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1996,
              0
            ],
            [
              2005,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "eq_blk",
            "parameters": {
              "b0": "struct block",
              "b1": "struct block"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nintern_blocks(opt_state_t *opt_state, struct icode *ic)\n{\n\tstruct block *p;\n\tint i, j;\n\tint done1; /* don't shadow global */\n top:\n\tdone1 = 1;\n\tfor (i = 0; i < opt_state->n_blocks; ++i)\n\t\topt_state->blocks[i]->link = 0;\n\n\tmark_code(ic);\n\n\tfor (i = opt_state->n_blocks - 1; --i >= 0; ) {\n\t\tif (!isMarked(ic, opt_state->blocks[i]))\n\t\t\tcontinue;\n\t\tfor (j = i + 1; j < opt_state->n_blocks; ++j) {\n\t\t\tif (!isMarked(ic, opt_state->blocks[j]))\n\t\t\t\tcontinue;\n\t\t\tif (eq_blk(opt_state->blocks[i], opt_state->blocks[j])) {\n\t\t\t\topt_state->blocks[i]->link = opt_state->blocks[j]->link ?\n\t\t\t\t\topt_state->blocks[j]->link : opt_state->blocks[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < opt_state->n_blocks; ++i) {\n\t\tp = opt_state->blocks[i];\n\t\tif (JT(p) == 0)\n\t\t\tcontinue;\n\t\tif (JT(p)->link) {\n\t\t\tdone1 = 0;\n\t\t\tJT(p) = JT(p)->link;\n\t\t}\n\t\tif (JF(p)->link) {\n\t\t\tdone1 = 0;\n\t\t\tJF(p) = JF(p)->link;\n\t\t}\n\t}\n\tif (!done1)\n\t\tgoto top;\n}",
          "fn_code_pos": [
            [
              2007,
              0
            ],
            [
              2048,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "intern_blocks",
            "parameters": {
              "opt_state": "opt_state_t",
              "ic": "struct icode"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nopt_cleanup(opt_state_t *opt_state)\n{\n\tfree((void *)opt_state->vnode_base);\n\tfree((void *)opt_state->vmap);\n\tfree((void *)opt_state->edges);\n\tfree((void *)opt_state->space);\n\tfree((void *)opt_state->levels);\n\tfree((void *)opt_state->blocks);\n}",
          "fn_code_pos": [
            [
              2050,
              0
            ],
            [
              2059,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_cleanup",
            "parameters": {
              "opt_state": "opt_state_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void PCAP_NORETURN\nopt_error(opt_state_t *opt_state, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tif (opt_state->errbuf != NULL) {\n\t\tva_start(ap, fmt);\n\t\t(void)pcap_vsnprintf(opt_state->errbuf,\n\t\t    PCAP_ERRBUF_SIZE, fmt, ap);\n\t\tva_end(ap);\n\t}\n\tlongjmp(opt_state->top_ctx, 1);\n\t/* NOTREACHED */\n}",
          "fn_code_pos": [
            [
              2064,
              0
            ],
            [
              2077,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN\nopt_error",
            "parameters": {
              "opt_state": "opt_state_t",
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static u_int\nslength(struct slist *s)\n{\n\tu_int n = 0;\n\n\tfor (; s; s = s->next)\n\t\tif (s->s.code != NOP)\n\t\t\t++n;\n\treturn n;\n}",
          "fn_code_pos": [
            [
              2082,
              0
            ],
            [
              2091,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "slength",
            "parameters": {
              "s": "struct slist"
            },
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "static int\ncount_blocks(struct icode *ic, struct block *p)\n{\n\tif (p == 0 || isMarked(ic, p))\n\t\treturn 0;\n\tMark(ic, p);\n\treturn count_blocks(ic, JT(p)) + count_blocks(ic, JF(p)) + 1;\n}",
          "fn_code_pos": [
            [
              2097,
              0
            ],
            [
              2104,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "count_blocks",
            "parameters": {
              "ic": "struct icode",
              "p": "struct block"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nnumber_blks_r(opt_state_t *opt_state, struct icode *ic, struct block *p)\n{\n\tint n;\n\n\tif (p == 0 || isMarked(ic, p))\n\t\treturn;\n\n\tMark(ic, p);\n\tn = opt_state->n_blocks++;\n\tp->id = n;\n\topt_state->blocks[n] = p;\n\n\tnumber_blks_r(opt_state, ic, JT(p));\n\tnumber_blks_r(opt_state, ic, JF(p));\n}",
          "fn_code_pos": [
            [
              2110,
              0
            ],
            [
              2125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "number_blks_r",
            "parameters": {
              "opt_state": "opt_state_t",
              "ic": "struct icode",
              "p": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static u_int\ncount_stmts(struct icode *ic, struct block *p)\n{\n\tu_int n;\n\n\tif (p == 0 || isMarked(ic, p))\n\t\treturn 0;\n\tMark(ic, p);\n\tn = count_stmts(ic, JT(p)) + count_stmts(ic, JF(p));\n\treturn slength(p->stmts) + n + 1 + p->longjt + p->longjf;\n}",
          "fn_code_pos": [
            [
              2145,
              0
            ],
            [
              2155,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "count_stmts",
            "parameters": {
              "ic": "struct icode",
              "p": "struct block"
            },
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "static void\nopt_init(opt_state_t *opt_state, struct icode *ic)\n{\n\tbpf_u_int32 *p;\n\tint i, n, max_stmts;\n\n\t/*\n\t * First, count the blocks, so we can malloc an array to map\n\t * block number to block.  Then, put the blocks into the array.\n\t */\n\tunMarkAll(ic);\n\tn = count_blocks(ic, ic->root);\n\topt_state->blocks = (struct block **)calloc(n, sizeof(*opt_state->blocks));\n\tif (opt_state->blocks == NULL)\n\t\topt_error(opt_state, \"malloc\");\n\tunMarkAll(ic);\n\topt_state->n_blocks = 0;\n\tnumber_blks_r(opt_state, ic, ic->root);\n\n\topt_state->n_edges = 2 * opt_state->n_blocks;\n\topt_state->edges = (struct edge **)calloc(opt_state->n_edges, sizeof(*opt_state->edges));\n\tif (opt_state->edges == NULL) {\n\t\tfree(opt_state->blocks);\n\t\topt_error(opt_state, \"malloc\");\n\t}\n\n\t/*\n\t * The number of levels is bounded by the number of nodes.\n\t */\n\topt_state->levels = (struct block **)calloc(opt_state->n_blocks, sizeof(*opt_state->levels));\n\tif (opt_state->levels == NULL) {\n\t\tfree(opt_state->edges);\n\t\tfree(opt_state->blocks);\n\t\topt_error(opt_state, \"malloc\");\n\t}\n\n\topt_state->edgewords = opt_state->n_edges / (8 * sizeof(bpf_u_int32)) + 1;\n\topt_state->nodewords = opt_state->n_blocks / (8 * sizeof(bpf_u_int32)) + 1;\n\n\t/* XXX */\n\topt_state->space = (bpf_u_int32 *)malloc(2 * opt_state->n_blocks * opt_state->nodewords * sizeof(*opt_state->space)\n\t\t\t\t + opt_state->n_edges * opt_state->edgewords * sizeof(*opt_state->space));\n\tif (opt_state->space == NULL) {\n\t\tfree(opt_state->levels);\n\t\tfree(opt_state->edges);\n\t\tfree(opt_state->blocks);\n\t\topt_error(opt_state, \"malloc\");\n\t}\n\tp = opt_state->space;\n\topt_state->all_dom_sets = p;\n\tfor (i = 0; i < n; ++i) {\n\t\topt_state->blocks[i]->dom = p;\n\t\tp += opt_state->nodewords;\n\t}\n\topt_state->all_closure_sets = p;\n\tfor (i = 0; i < n; ++i) {\n\t\topt_state->blocks[i]->closure = p;\n\t\tp += opt_state->nodewords;\n\t}\n\topt_state->all_edge_sets = p;\n\tfor (i = 0; i < n; ++i) {\n\t\tregister struct block *b = opt_state->blocks[i];\n\n\t\tb->et.edom = p;\n\t\tp += opt_state->edgewords;\n\t\tb->ef.edom = p;\n\t\tp += opt_state->edgewords;\n\t\tb->et.id = i;\n\t\topt_state->edges[i] = &b->et;\n\t\tb->ef.id = opt_state->n_blocks + i;\n\t\topt_state->edges[opt_state->n_blocks + i] = &b->ef;\n\t\tb->et.pred = b;\n\t\tb->ef.pred = b;\n\t}\n\tmax_stmts = 0;\n\tfor (i = 0; i < n; ++i)\n\t\tmax_stmts += slength(opt_state->blocks[i]->stmts) + 1;\n\t/*\n\t * We allocate at most 3 value numbers per statement,\n\t * so this is an upper bound on the number of valnodes\n\t * we'll need.\n\t */\n\topt_state->maxval = 3 * max_stmts;\n\topt_state->vmap = (struct vmapinfo *)calloc(opt_state->maxval, sizeof(*opt_state->vmap));\n\tif (opt_state->vmap == NULL) {\n\t\tfree(opt_state->space);\n\t\tfree(opt_state->levels);\n\t\tfree(opt_state->edges);\n\t\tfree(opt_state->blocks);\n\t\topt_error(opt_state, \"malloc\");\n\t}\n\topt_state->vnode_base = (struct valnode *)calloc(opt_state->maxval, sizeof(*opt_state->vnode_base));\n\tif (opt_state->vnode_base == NULL) {\n\t\tfree(opt_state->vmap);\n\t\tfree(opt_state->space);\n\t\tfree(opt_state->levels);\n\t\tfree(opt_state->edges);\n\t\tfree(opt_state->blocks);\n\t\topt_error(opt_state, \"malloc\");\n\t}\n}",
          "fn_code_pos": [
            [
              2162,
              0
            ],
            [
              2262,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_init",
            "parameters": {
              "opt_state": "opt_state_t",
              "ic": "struct icode"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nconvert_code_r(conv_state_t *conv_state, struct icode *ic, struct block *p)\n{\n\tstruct bpf_insn *dst;\n\tstruct slist *src;\n\tu_int slen;\n\tu_int off;\n\tu_int extrajmps;\t/* number of extra jumps inserted */\n\tstruct slist **offset = NULL;\n\n\tif (p == 0 || isMarked(ic, p))\n\t\treturn (1);\n\tMark(ic, p);\n\n\tif (convert_code_r(conv_state, ic, JF(p)) == 0)\n\t\treturn (0);\n\tif (convert_code_r(conv_state, ic, JT(p)) == 0)\n\t\treturn (0);\n\n\tslen = slength(p->stmts);\n\tdst = conv_state->ftail -= (slen + 1 + p->longjt + p->longjf);\n\t\t/* inflate length by any extra jumps */\n\n\tp->offset = (int)(dst - conv_state->fstart);\n\n\t/* generate offset[] for convenience  */\n\tif (slen) {\n\t\toffset = (struct slist **)calloc(slen, sizeof(struct slist *));\n\t\tif (!offset) {\n\t\t\tconv_error(conv_state, \"not enough core\");\n\t\t\t/*NOTREACHED*/\n\t\t}\n\t}\n\tsrc = p->stmts;\n\tfor (off = 0; off < slen && src; off++) {\n#if 0\n\t\tprintf(\"off=%d src=%x\\n\", off, src);\n#endif\n\t\toffset[off] = src;\n\t\tsrc = src->next;\n\t}\n\n\toff = 0;\n\tfor (src = p->stmts; src; src = src->next) {\n\t\tif (src->s.code == NOP)\n\t\t\tcontinue;\n\t\tdst->code = (u_short)src->s.code;\n\t\tdst->k = src->s.k;\n\n\t\t/* fill block-local relative jump */\n\t\tif (BPF_CLASS(src->s.code) != BPF_JMP || src->s.code == (BPF_JMP|BPF_JA)) {\n#if 0\n\t\t\tif (src->s.jt || src->s.jf) {\n\t\t\t\tfree(offset);\n\t\t\t\tconv_error(conv_state, \"illegal jmp destination\");\n\t\t\t\t/*NOTREACHED*/\n\t\t\t}\n#endif\n\t\t\tgoto filled;\n\t\t}\n\t\tif (off == slen - 2)\t/*???*/\n\t\t\tgoto filled;\n\n\t    {\n\t\tu_int i;\n\t\tint jt, jf;\n\t\tconst char ljerr[] = \"%s for block-local relative jump: off=%d\";\n\n#if 0\n\t\tprintf(\"code=%x off=%d %x %x\\n\", src->s.code,\n\t\t\toff, src->s.jt, src->s.jf);\n#endif\n\n\t\tif (!src->s.jt || !src->s.jf) {\n\t\t\tfree(offset);\n\t\t\tconv_error(conv_state, ljerr, \"no jmp destination\", off);\n\t\t\t/*NOTREACHED*/\n\t\t}\n\n\t\tjt = jf = 0;\n\t\tfor (i = 0; i < slen; i++) {\n\t\t\tif (offset[i] == src->s.jt) {\n\t\t\t\tif (jt) {\n\t\t\t\t\tfree(offset);\n\t\t\t\t\tconv_error(conv_state, ljerr, \"multiple matches\", off);\n\t\t\t\t\t/*NOTREACHED*/\n\t\t\t\t}\n\n\t\t\t\tif (i - off - 1 >= 256) {\n\t\t\t\t\tfree(offset);\n\t\t\t\t\tconv_error(conv_state, ljerr, \"out-of-range jump\", off);\n\t\t\t\t\t/*NOTREACHED*/\n\t\t\t\t}\n\t\t\t\tdst->jt = (u_char)(i - off - 1);\n\t\t\t\tjt++;\n\t\t\t}\n\t\t\tif (offset[i] == src->s.jf) {\n\t\t\t\tif (jf) {\n\t\t\t\t\tfree(offset);\n\t\t\t\t\tconv_error(conv_state, ljerr, \"multiple matches\", off);\n\t\t\t\t\t/*NOTREACHED*/\n\t\t\t\t}\n\t\t\t\tif (i - off - 1 >= 256) {\n\t\t\t\t\tfree(offset);\n\t\t\t\t\tconv_error(conv_state, ljerr, \"out-of-range jump\", off);\n\t\t\t\t\t/*NOTREACHED*/\n\t\t\t\t}\n\t\t\t\tdst->jf = (u_char)(i - off - 1);\n\t\t\t\tjf++;\n\t\t\t}\n\t\t}\n\t\tif (!jt || !jf) {\n\t\t\tfree(offset);\n\t\t\tconv_error(conv_state, ljerr, \"no destination found\", off);\n\t\t\t/*NOTREACHED*/\n\t\t}\n\t    }\nfilled:\n\t\t++dst;\n\t\t++off;\n\t}\n\tif (offset)\n\t\tfree(offset);\n\n#ifdef BDEBUG\n\tif (dst - conv_state->fstart < NBIDS)\n\t\tbids[dst - conv_state->fstart] = p->id + 1;\n#endif\n\tdst->code = (u_short)p->s.code;\n\tdst->k = p->s.k;\n\tif (JT(p)) {\n\t\textrajmps = 0;\n\t\toff = JT(p)->offset - (p->offset + slen) - 1;\n\t\tif (off >= 256) {\n\t\t    /* offset too large for branch, must add a jump */\n\t\t    if (p->longjt == 0) {\n\t\t    \t/* mark this instruction and retry */\n\t\t\tp->longjt++;\n\t\t\treturn(0);\n\t\t    }\n\t\t    /* branch if T to following jump */\n\t\t    if (extrajmps >= 256) {\n\t\t\tconv_error(conv_state, \"too many extra jumps\");\n\t\t\t/*NOTREACHED*/\n\t\t    }\n\t\t    dst->jt = (u_char)extrajmps;\n\t\t    extrajmps++;\n\t\t    dst[extrajmps].code = BPF_JMP|BPF_JA;\n\t\t    dst[extrajmps].k = off - extrajmps;\n\t\t}\n\t\telse\n\t\t    dst->jt = (u_char)off;\n\t\toff = JF(p)->offset - (p->offset + slen) - 1;\n\t\tif (off >= 256) {\n\t\t    /* offset too large for branch, must add a jump */\n\t\t    if (p->longjf == 0) {\n\t\t    \t/* mark this instruction and retry */\n\t\t\tp->longjf++;\n\t\t\treturn(0);\n\t\t    }\n\t\t    /* branch if F to following jump */\n\t\t    /* if two jumps are inserted, F goes to second one */\n\t\t    if (extrajmps >= 256) {\n\t\t\tconv_error(conv_state, \"too many extra jumps\");\n\t\t\t/*NOTREACHED*/\n\t\t    }\n\t\t    dst->jf = (u_char)extrajmps;\n\t\t    extrajmps++;\n\t\t    dst[extrajmps].code = BPF_JMP|BPF_JA;\n\t\t    dst[extrajmps].k = off - extrajmps;\n\t\t}\n\t\telse\n\t\t    dst->jf = (u_char)off;\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              2282,
              0
            ],
            [
              2457,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "convert_code_r",
            "parameters": {
              "conv_state": "conv_state_t",
              "ic": "struct icode",
              "p": "struct block"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "struct bpf_insn *\nicode_to_fcode(struct icode *ic, struct block *root, u_int *lenp,\n    char *errbuf)\n{\n\tu_int n;\n\tstruct bpf_insn *fp;\n\tconv_state_t conv_state;\n\n\tconv_state.fstart = NULL;\n\tconv_state.errbuf = errbuf;\n\tif (setjmp(conv_state.top_ctx) != 0) {\n\t\tfree(conv_state.fstart);\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Loop doing convert_code_r() until no branches remain\n\t * with too-large offsets.\n\t */\n\tfor (;;) {\n\t    unMarkAll(ic);\n\t    n = *lenp = count_stmts(ic, root);\n\n\t    fp = (struct bpf_insn *)malloc(sizeof(*fp) * n);\n\t    if (fp == NULL) {\n\t\t(void)pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"malloc\");\n\t\tfree(fp);\n\t\treturn NULL;\n\t    }\n\t    memset((char *)fp, 0, sizeof(*fp) * n);\n\t    conv_state.fstart = fp;\n\t    conv_state.ftail = fp + n;\n\n\t    unMarkAll(ic);\n\t    if (convert_code_r(&conv_state, ic, root))\n\t\tbreak;\n\t    free(fp);\n\t}\n\n\treturn fp;\n}",
          "fn_code_pos": [
            [
              2478,
              0
            ],
            [
              2519,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "icode_to_fcode",
            "parameters": {
              "ic": "struct icode",
              "root": "struct block",
              "lenp": "u_int",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void PCAP_NORETURN\nconv_error(conv_state_t *conv_state, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\t(void)pcap_vsnprintf(conv_state->errbuf,\n\t    PCAP_ERRBUF_SIZE, fmt, ap);\n\tva_end(ap);\n\tlongjmp(conv_state->top_ctx, 1);\n\t/* NOTREACHED */\n}",
          "fn_code_pos": [
            [
              2524,
              0
            ],
            [
              2535,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN\nconv_error",
            "parameters": {
              "conv_state": "conv_state_t",
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\ninstall_bpf_program(pcap_t *p, struct bpf_program *fp)\n{\n\tsize_t prog_size;\n\n\t/*\n\t * Validate the program.\n\t */\n\tif (!pcap_validate_filter(fp->bf_insns, fp->bf_len)) {\n\t\tpcap_snprintf(p->errbuf, sizeof(p->errbuf),\n\t\t\t\"BPF program is not valid\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Free up any already installed program.\n\t */\n\tpcap_freecode(&p->fcode);\n\n\tprog_size = sizeof(*fp->bf_insns) * fp->bf_len;\n\tp->fcode.bf_len = fp->bf_len;\n\tp->fcode.bf_insns = (struct bpf_insn *)malloc(prog_size);\n\tif (p->fcode.bf_insns == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t    errno, \"malloc\");\n\t\treturn (-1);\n\t}\n\tmemcpy(p->fcode.bf_insns, fp->bf_insns, prog_size);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2545,
              0
            ],
            [
              2574,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "install_bpf_program",
            "parameters": {
              "p": "pcap_t",
              "fp": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ndot_dump_node(struct icode *ic, struct block *block, struct bpf_program *prog,\n    FILE *out)\n{\n\tint icount, noffset;\n\tint i;\n\n\tif (block == NULL || isMarked(ic, block))\n\t\treturn;\n\tMark(ic, block);\n\n\ticount = slength(block->stmts) + 1 + block->longjt + block->longjf;\n\tnoffset = min(block->offset + icount, (int)prog->bf_len);\n\n\tfprintf(out, \"\\tblock%d [shape=ellipse, id=\\\"block-%d\\\" label=\\\"BLOCK%d\\\\n\", block->id, block->id, block->id);\n\tfor (i = block->offset; i < noffset; i++) {\n\t\tfprintf(out, \"\\\\n%s\", bpf_image(prog->bf_insns + i, i));\n\t}\n\tfprintf(out, \"\\\" tooltip=\\\"\");\n\tfor (i = 0; i < BPF_MEMWORDS; i++)\n\t\tif (block->val[i] != VAL_UNKNOWN)\n\t\t\tfprintf(out, \"val[%d]=%d \", i, block->val[i]);\n\tfprintf(out, \"val[A]=%d \", block->val[A_ATOM]);\n\tfprintf(out, \"val[X]=%d\", block->val[X_ATOM]);\n\tfprintf(out, \"\\\"\");\n\tif (JT(block) == NULL)\n\t\tfprintf(out, \", peripheries=2\");\n\tfprintf(out, \"];\\n\");\n\n\tdot_dump_node(ic, JT(block), prog, out);\n\tdot_dump_node(ic, JF(block), prog, out);\n}",
          "fn_code_pos": [
            [
              2577,
              0
            ],
            [
              2608,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dot_dump_node",
            "parameters": {
              "ic": "struct icode",
              "block": "struct block",
              "prog": "struct bpf_program",
              "out": "FILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ndot_dump_edge(struct icode *ic, struct block *block, FILE *out)\n{\n\tif (block == NULL || isMarked(ic, block))\n\t\treturn;\n\tMark(ic, block);\n\n\tif (JT(block)) {\n\t\tfprintf(out, \"\\t\\\"block%d\\\":se -> \\\"block%d\\\":n [label=\\\"T\\\"]; \\n\",\n\t\t\t\tblock->id, JT(block)->id);\n\t\tfprintf(out, \"\\t\\\"block%d\\\":sw -> \\\"block%d\\\":n [label=\\\"F\\\"]; \\n\",\n\t\t\t   block->id, JF(block)->id);\n\t}\n\tdot_dump_edge(ic, JT(block), out);\n\tdot_dump_edge(ic, JF(block), out);\n}",
          "fn_code_pos": [
            [
              2610,
              0
            ],
            [
              2625,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dot_dump_edge",
            "parameters": {
              "ic": "struct icode",
              "block": "struct block",
              "out": "FILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ndot_dump(struct icode *ic, char *errbuf)\n{\n\tstruct bpf_program f;\n\tFILE *out = stdout;\n\n\tmemset(bids, 0, sizeof bids);\n\tf.bf_insns = icode_to_fcode(ic, ic->root, &f.bf_len, errbuf);\n\tif (f.bf_insns == NULL)\n\t\treturn -1;\n\n\tfprintf(out, \"digraph BPF {\\n\");\n\tunMarkAll(ic);\n\tdot_dump_node(ic, ic->root, &f, out);\n\tunMarkAll(ic);\n\tdot_dump_edge(ic, ic->root, out);\n\tfprintf(out, \"}\\n\");\n\n\tfree((char *)f.bf_insns);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              2646,
              0
            ],
            [
              2666,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dot_dump",
            "parameters": {
              "ic": "struct icode",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nplain_dump(struct icode *ic, char *errbuf)\n{\n\tstruct bpf_program f;\n\n\tmemset(bids, 0, sizeof bids);\n\tf.bf_insns = icode_to_fcode(ic, ic->root, &f.bf_len, errbuf);\n\tif (f.bf_insns == NULL)\n\t\treturn -1;\n\tbpf_dump(&f, 1);\n\tputchar('\\n');\n\tfree((char *)f.bf_insns);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              2668,
              0
            ],
            [
              2681,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "plain_dump",
            "parameters": {
              "ic": "struct icode",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nopt_dump(opt_state_t *opt_state, struct icode *ic)\n{\n\tint status;\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\n\t/*\n\t * If the CFG, in DOT format, is requested, output it rather than\n\t * the code that would be generated from that graph.\n\t */\n\tif (pcap_print_dot_graph)\n\t\tstatus = dot_dump(ic, errbuf);\n\telse\n\t\tstatus = plain_dump(ic, errbuf);\n\tif (status == -1)\n\t\topt_error(opt_state, \"opt_dump: icode_to_fcode failed: %s\", errbuf);\n}",
          "fn_code_pos": [
            [
              2683,
              0
            ],
            [
              2699,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_dump",
            "parameters": {
              "opt_state": "opt_state_t",
              "ic": "struct icode"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "pcap_set_optimizer_debug(int value)",
          "fn_dec_pos": [
            [
              64,
              14
            ],
            [
              64,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_optimizer_debug",
            "parameters": {
              "value": "int"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_set_print_dot_graph(int value)",
          "fn_dec_pos": [
            [
              89,
              14
            ],
            [
              89,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_print_dot_graph",
            "parameters": {
              "value": "int"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "opt_init(opt_state_t *, struct icode *)",
          "fn_dec_pos": [
            [
              344,
              12
            ],
            [
              344,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_init",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "opt_cleanup(opt_state_t *)",
          "fn_dec_pos": [
            [
              345,
              12
            ],
            [
              345,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_cleanup",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PCAP_NORETURN opt_error(opt_state_t *, const char *, ...)",
          "fn_dec_pos": [
            [
              346,
              12
            ],
            [
              346,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN opt_error",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "intern_blocks(opt_state_t *, struct icode *)",
          "fn_dec_pos": [
            [
              349,
              12
            ],
            [
              349,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "intern_blocks",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "find_inedges(opt_state_t *, struct block *)",
          "fn_dec_pos": [
            [
              351,
              12
            ],
            [
              351,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_inedges",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "opt_dump(opt_state_t *, struct icode *)",
          "fn_dec_pos": [
            [
              353,
              12
            ],
            [
              353,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "opt_dump",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "this_op(struct slist *s)",
          "fn_dec_pos": [
            [
              839,
              0
            ],
            [
              839,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "this_op",
            "parameters": {
              "s": "struct slist"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "fold_edge(struct block *child, struct edge *ep)",
          "fn_dec_pos": [
            [
              1507,
              0
            ],
            [
              1507,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fold_edge",
            "parameters": {
              "child": "struct block",
              "ep": "struct edge"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PCAP_NORETURN conv_error(conv_state_t *, const char *, ...)",
          "fn_dec_pos": [
            [
              2273,
              12
            ],
            [
              2273,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN conv_error",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "icode_to_fcode(struct icode *ic, struct block *root, u_int *lenp,\n    char *errbuf)",
          "fn_dec_pos": [
            [
              2479,
              0
            ],
            [
              2480,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "icode_to_fcode",
            "parameters": {
              "ic": "struct icode",
              "root": "struct block",
              "lenp": "u_int",
              "errbuf": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct valnode {\n\tint code;\n\tbpf_u_int32 v0, v1;\n\tint val;\t\t/* the value number */\n\tstruct valnode *next;\n}",
          {
            "code": "int",
            "v0": "bpf_u_int32",
            "val": "int",
            "*next": "struct valnode"
          },
          "valnode",
          [
            213,
            0
          ],
          [
            218,
            1
          ]
        ],
        [
          "struct vmapinfo {\n\tint is_const;\n\tbpf_u_int32 const_val;\n}",
          {
            "is_const": "int",
            "const_val": "bpf_u_int32"
          },
          "vmapinfo",
          [
            223,
            0
          ],
          [
            226,
            1
          ]
        ],
        [
          "typedef struct {\n\t/*\n\t * Place to longjmp to on an error.\n\t */\n\tjmp_buf top_ctx;\n\n\t/*\n\t * The buffer into which to put error message.\n\t */\n\tchar *errbuf;\n\n\t/*\n\t * A flag to indicate that further optimization is needed.\n\t * Iterative passes are continued until a given pass yields no\n\t * branch movement.\n\t */\n\tint done;\n\n\tint n_blocks;\n\tstruct block **blocks;\n\tint n_edges;\n\tstruct edge **edges;\n\n\t/*\n\t * A bit vector set representation of the dominators.\n\t * We round up the set size to the next power of two.\n\t */\n\tint nodewords;\n\tint edgewords;\n\tstruct block **levels;\n\tbpf_u_int32 *space;\n\n#define BITS_PER_WORD (8*sizeof(bpf_u_int32))\n/*\n * True if a is in uset {p}\n */\n#define SET_MEMBER(p, a) \\\n((p)[(unsigned)(a) / BITS_PER_WORD] & ((bpf_u_int32)1 << ((unsigned)(a) % BITS_PER_WORD)))\n\n/*\n * Add 'a' to uset p.\n */\n#define SET_INSERT(p, a) \\\n(p)[(unsigned)(a) / BITS_PER_WORD] |= ((bpf_u_int32)1 << ((unsigned)(a) % BITS_PER_WORD))\n\n/*\n * Delete 'a' from uset p.\n */\n#define SET_DELETE(p, a) \\\n(p)[(unsigned)(a) / BITS_PER_WORD] &= ~((bpf_u_int32)1 << ((unsigned)(a) % BITS_PER_WORD))\n\n/*\n * a := a intersect b\n */\n#define SET_INTERSECT(a, b, n)\\\n{\\\n\tregister bpf_u_int32 *_x = a, *_y = b;\\\n\tregister int _n = n;\\\n\twhile (--_n >= 0) *_x++ &= *_y++;\\\n}\n\n/*\n * a := a - b\n */\n#define SET_SUBTRACT(a, b, n)\\\n{\\\n\tregister bpf_u_int32 *_x = a, *_y = b;\\\n\tregister int _n = n;\\\n\twhile (--_n >= 0) *_x++ &=~ *_y++;\\\n}\n\n/*\n * a := a union b\n */\n#define SET_UNION(a, b, n)\\\n{\\\n\tregister bpf_u_int32 *_x = a, *_y = b;\\\n\tregister int _n = n;\\\n\twhile (--_n >= 0) *_x++ |= *_y++;\\\n}\n\n\tuset all_dom_sets;\n\tuset all_closure_sets;\n\tuset all_edge_sets;\n\n#define MODULUS 213\n\tstruct valnode *hashtbl[MODULUS];\n\tbpf_u_int32 curval;\n\tbpf_u_int32 maxval;\n\n\tstruct vmapinfo *vmap;\n\tstruct valnode *vnode_base;\n\tstruct valnode *next_vnode;\n} opt_state_t;",
          {
            "top_ctx": "jmp_buf",
            "*errbuf": "char",
            "done": "int",
            "n_blocks": "int",
            "**blocks": "struct block",
            "n_edges": "int",
            "**edges": "struct edge",
            "nodewords": "int",
            "edgewords": "int",
            "**levels": "struct block",
            "*space": "bpf_u_int32",
            "all_dom_sets": "uset",
            "all_closure_sets": "uset",
            "all_edge_sets": "uset",
            "*hashtbl[MODULUS]": "struct valnode",
            "curval": "bpf_u_int32",
            "maxval": "bpf_u_int32",
            "*vmap": "struct vmapinfo",
            "*vnode_base": "struct valnode",
            "*next_vnode": "struct valnode"
          },
          "opt_state_t",
          [
            228,
            0
          ],
          [
            321,
            14
          ]
        ],
        [
          "typedef struct {\n\t/*\n\t * Place to longjmp to on an error.\n\t */\n\tjmp_buf top_ctx;\n\n\t/*\n\t * The buffer into which to put error message.\n\t */\n\tchar *errbuf;\n\n\t/*\n\t * Some pointers used to convert the basic block form of the code,\n\t * into the array form that BPF requires.  'fstart' will point to\n\t * the malloc'd array while 'ftail' is used during the recursive\n\t * traversal.\n\t */\n\tstruct bpf_insn *fstart;\n\tstruct bpf_insn *ftail;\n} conv_state_t;",
          {
            "top_ctx": "jmp_buf",
            "*errbuf": "char",
            "*fstart": "struct bpf_insn",
            "*ftail": "struct bpf_insn"
          },
          "conv_state_t",
          [
            323,
            0
          ],
          [
            342,
            15
          ]
        ],
        [
          "struct valnode {\n\tint code;\n\tbpf_u_int32 v0, v1;\n\tint val;\t\t/* the value number */\n\tstruct valnode *next;\n}",
          {
            "code": "int",
            "v0": "bpf_u_int32",
            "val": "int",
            "*next": "struct valnode"
          },
          "valnode",
          [
            213,
            0
          ],
          [
            218,
            1
          ]
        ],
        [
          "struct valnode",
          {},
          "",
          [
            217,
            1
          ],
          [
            217,
            15
          ]
        ],
        [
          "struct vmapinfo {\n\tint is_const;\n\tbpf_u_int32 const_val;\n}",
          {
            "is_const": "int",
            "const_val": "bpf_u_int32"
          },
          "vmapinfo",
          [
            223,
            0
          ],
          [
            226,
            1
          ]
        ],
        [
          "typedef struct {\n\t/*\n\t * Place to longjmp to on an error.\n\t */\n\tjmp_buf top_ctx;\n\n\t/*\n\t * The buffer into which to put error message.\n\t */\n\tchar *errbuf;\n\n\t/*\n\t * A flag to indicate that further optimization is needed.\n\t * Iterative passes are continued until a given pass yields no\n\t * branch movement.\n\t */\n\tint done;\n\n\tint n_blocks;\n\tstruct block **blocks;\n\tint n_edges;\n\tstruct edge **edges;\n\n\t/*\n\t * A bit vector set representation of the dominators.\n\t * We round up the set size to the next power of two.\n\t */\n\tint nodewords;\n\tint edgewords;\n\tstruct block **levels;\n\tbpf_u_int32 *space;\n\n#define BITS_PER_WORD (8*sizeof(bpf_u_int32))\n/*\n * True if a is in uset {p}\n */\n#define SET_MEMBER(p, a) \\\n((p)[(unsigned)(a) / BITS_PER_WORD] & ((bpf_u_int32)1 << ((unsigned)(a) % BITS_PER_WORD)))\n\n/*\n * Add 'a' to uset p.\n */\n#define SET_INSERT(p, a) \\\n(p)[(unsigned)(a) / BITS_PER_WORD] |= ((bpf_u_int32)1 << ((unsigned)(a) % BITS_PER_WORD))\n\n/*\n * Delete 'a' from uset p.\n */\n#define SET_DELETE(p, a) \\\n(p)[(unsigned)(a) / BITS_PER_WORD] &= ~((bpf_u_int32)1 << ((unsigned)(a) % BITS_PER_WORD))\n\n/*\n * a := a intersect b\n */\n#define SET_INTERSECT(a, b, n)\\\n{\\\n\tregister bpf_u_int32 *_x = a, *_y = b;\\\n\tregister int _n = n;\\\n\twhile (--_n >= 0) *_x++ &= *_y++;\\\n}\n\n/*\n * a := a - b\n */\n#define SET_SUBTRACT(a, b, n)\\\n{\\\n\tregister bpf_u_int32 *_x = a, *_y = b;\\\n\tregister int _n = n;\\\n\twhile (--_n >= 0) *_x++ &=~ *_y++;\\\n}\n\n/*\n * a := a union b\n */\n#define SET_UNION(a, b, n)\\\n{\\\n\tregister bpf_u_int32 *_x = a, *_y = b;\\\n\tregister int _n = n;\\\n\twhile (--_n >= 0) *_x++ |= *_y++;\\\n}\n\n\tuset all_dom_sets;\n\tuset all_closure_sets;\n\tuset all_edge_sets;\n\n#define MODULUS 213\n\tstruct valnode *hashtbl[MODULUS];\n\tbpf_u_int32 curval;\n\tbpf_u_int32 maxval;\n\n\tstruct vmapinfo *vmap;\n\tstruct valnode *vnode_base;\n\tstruct valnode *next_vnode;\n} opt_state_t;",
          {
            "top_ctx": "jmp_buf",
            "*errbuf": "char",
            "done": "int",
            "n_blocks": "int",
            "**blocks": "struct block",
            "n_edges": "int",
            "**edges": "struct edge",
            "nodewords": "int",
            "edgewords": "int",
            "**levels": "struct block",
            "*space": "bpf_u_int32",
            "all_dom_sets": "uset",
            "all_closure_sets": "uset",
            "all_edge_sets": "uset",
            "*hashtbl[MODULUS]": "struct valnode",
            "curval": "bpf_u_int32",
            "maxval": "bpf_u_int32",
            "*vmap": "struct vmapinfo",
            "*vnode_base": "struct valnode",
            "*next_vnode": "struct valnode"
          },
          "opt_state_t",
          [
            228,
            0
          ],
          [
            321,
            14
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            247,
            1
          ],
          [
            247,
            13
          ]
        ],
        [
          "struct edge",
          {},
          "",
          [
            249,
            1
          ],
          [
            249,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            257,
            1
          ],
          [
            257,
            13
          ]
        ],
        [
          "struct valnode",
          {},
          "",
          [
            314,
            1
          ],
          [
            314,
            15
          ]
        ],
        [
          "struct vmapinfo",
          {},
          "",
          [
            318,
            1
          ],
          [
            318,
            16
          ]
        ],
        [
          "struct valnode",
          {},
          "",
          [
            319,
            1
          ],
          [
            319,
            15
          ]
        ],
        [
          "struct valnode",
          {},
          "",
          [
            320,
            1
          ],
          [
            320,
            15
          ]
        ],
        [
          "typedef struct {\n\t/*\n\t * Place to longjmp to on an error.\n\t */\n\tjmp_buf top_ctx;\n\n\t/*\n\t * The buffer into which to put error message.\n\t */\n\tchar *errbuf;\n\n\t/*\n\t * Some pointers used to convert the basic block form of the code,\n\t * into the array form that BPF requires.  'fstart' will point to\n\t * the malloc'd array while 'ftail' is used during the recursive\n\t * traversal.\n\t */\n\tstruct bpf_insn *fstart;\n\tstruct bpf_insn *ftail;\n} conv_state_t;",
          {
            "top_ctx": "jmp_buf",
            "*errbuf": "char",
            "*fstart": "struct bpf_insn",
            "*ftail": "struct bpf_insn"
          },
          "conv_state_t",
          [
            323,
            0
          ],
          [
            342,
            15
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            340,
            1
          ],
          [
            340,
            16
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            341,
            1
          ],
          [
            341,
            16
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            344,
            36
          ],
          [
            344,
            48
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            349,
            41
          ],
          [
            349,
            53
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            351,
            40
          ],
          [
            351,
            52
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            353,
            36
          ],
          [
            353,
            48
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            361,
            38
          ],
          [
            361,
            50
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            361,
            56
          ],
          [
            361,
            68
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            389,
            36
          ],
          [
            389,
            48
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            401,
            33
          ],
          [
            401,
            45
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            404,
            1
          ],
          [
            404,
            13
          ]
        ],
        [
          "struct edge",
          {},
          "",
          [
            431,
            33
          ],
          [
            431,
            44
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            445,
            34
          ],
          [
            445,
            46
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            449,
            1
          ],
          [
            449,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            474,
            37
          ],
          [
            474,
            49
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            477,
            1
          ],
          [
            477,
            13
          ]
        ],
        [
          "struct stmt",
          {},
          "",
          [
            507,
            8
          ],
          [
            507,
            19
          ]
        ],
        [
          "struct stmt",
          {},
          "",
          [
            556,
            8
          ],
          [
            556,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            592,
            17
          ],
          [
            592,
            29
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            594,
            1
          ],
          [
            594,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            653,
            32
          ],
          [
            653,
            44
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            656,
            1
          ],
          [
            656,
            13
          ]
        ],
        [
          "struct valnode",
          {},
          "",
          [
            699,
            1
          ],
          [
            699,
            15
          ]
        ],
        [
          "struct stmt",
          {},
          "",
          [
            737,
            7
          ],
          [
            737,
            18
          ]
        ],
        [
          "struct stmt",
          {},
          "",
          [
            750,
            32
          ],
          [
            750,
            43
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            838,
            14
          ],
          [
            838,
            26
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            839,
            8
          ],
          [
            839,
            20
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            847,
            8
          ],
          [
            847,
            20
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            849,
            1
          ],
          [
            849,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            856,
            33
          ],
          [
            856,
            45
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            858,
            1
          ],
          [
            858,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            859,
            1
          ],
          [
            859,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            909,
            3
          ],
          [
            909,
            15
          ]
        ],
        [
          "struct stmt",
          {},
          "",
          [
            1119,
            33
          ],
          [
            1119,
            44
          ]
        ],
        [
          "struct stmt",
          {},
          "",
          [
            1342,
            42
          ],
          [
            1342,
            53
          ]
        ],
        [
          "struct stmt",
          {},
          "",
          [
            1342,
            67
          ],
          [
            1342,
            78
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1366,
            48
          ],
          [
            1366,
            60
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            1368,
            10
          ],
          [
            1368,
            22
          ]
        ],
        [
          "struct stmt",
          {},
          "",
          [
            1370,
            1
          ],
          [
            1370,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1386,
            32
          ],
          [
            1386,
            44
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            1388,
            1
          ],
          [
            1388,
            13
          ]
        ],
        [
          "struct edge",
          {},
          "",
          [
            1389,
            1
          ],
          [
            1389,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1491,
            13
          ],
          [
            1491,
            25
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1491,
            30
          ],
          [
            1491,
            42
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1506,
            7
          ],
          [
            1506,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1507,
            10
          ],
          [
            1507,
            22
          ]
        ],
        [
          "struct edge",
          {},
          "",
          [
            1507,
            31
          ],
          [
            1507,
            42
          ]
        ],
        [
          "struct edge",
          {},
          "",
          [
            1559,
            30
          ],
          [
            1559,
            41
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1562,
            10
          ],
          [
            1562,
            22
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1614,
            34
          ],
          [
            1614,
            46
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1618,
            1
          ],
          [
            1618,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1619,
            1
          ],
          [
            1619,
            13
          ]
        ],
        [
          "struct edge",
          {},
          "",
          [
            1620,
            1
          ],
          [
            1620,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1707,
            35
          ],
          [
            1707,
            47
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1711,
            1
          ],
          [
            1711,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1712,
            1
          ],
          [
            1712,
            13
          ]
        ],
        [
          "struct edge",
          {},
          "",
          [
            1713,
            1
          ],
          [
            1713,
            12
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            1799,
            33
          ],
          [
            1799,
            45
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1802,
            1
          ],
          [
            1802,
            13
          ]
        ],
        [
          "struct edge",
          {},
          "",
          [
            1836,
            12
          ],
          [
            1836,
            23
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1836,
            33
          ],
          [
            1836,
            45
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1843,
            37
          ],
          [
            1843,
            49
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1846,
            1
          ],
          [
            1846,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1864,
            9
          ],
          [
            1864,
            21
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            1866,
            1
          ],
          [
            1866,
            13
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            1888,
            33
          ],
          [
            1888,
            45
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            1919,
            13
          ],
          [
            1919,
            25
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            1951,
            11
          ],
          [
            1951,
            23
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1951,
            29
          ],
          [
            1951,
            41
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            1967,
            10
          ],
          [
            1967,
            22
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            1978,
            9
          ],
          [
            1978,
            21
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            1978,
            26
          ],
          [
            1978,
            38
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1997,
            7
          ],
          [
            1997,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1997,
            25
          ],
          [
            1997,
            37
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            2008,
            38
          ],
          [
            2008,
            50
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2010,
            1
          ],
          [
            2010,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2083,
            8
          ],
          [
            2083,
            20
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            2098,
            13
          ],
          [
            2098,
            25
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2098,
            31
          ],
          [
            2098,
            43
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            2111,
            38
          ],
          [
            2111,
            50
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2111,
            56
          ],
          [
            2111,
            68
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            2146,
            12
          ],
          [
            2146,
            24
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2146,
            30
          ],
          [
            2146,
            42
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            2163,
            33
          ],
          [
            2163,
            45
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2174,
            22
          ],
          [
            2174,
            34
          ]
        ],
        [
          "struct edge",
          {},
          "",
          [
            2182,
            21
          ],
          [
            2182,
            32
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2191,
            22
          ],
          [
            2191,
            34
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2223,
            11
          ],
          [
            2223,
            23
          ]
        ],
        [
          "struct vmapinfo",
          {},
          "",
          [
            2245,
            20
          ],
          [
            2245,
            35
          ]
        ],
        [
          "struct valnode",
          {},
          "",
          [
            2253,
            26
          ],
          [
            2253,
            40
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            2283,
            41
          ],
          [
            2283,
            53
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2283,
            59
          ],
          [
            2283,
            71
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            2285,
            1
          ],
          [
            2285,
            16
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2286,
            1
          ],
          [
            2286,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2290,
            1
          ],
          [
            2290,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2309,
            12
          ],
          [
            2309,
            24
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2309,
            48
          ],
          [
            2309,
            60
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            2478,
            0
          ],
          [
            2478,
            15
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            2479,
            15
          ],
          [
            2479,
            27
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2479,
            33
          ],
          [
            2479,
            45
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            2483,
            1
          ],
          [
            2483,
            16
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            2501,
            11
          ],
          [
            2501,
            26
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            2546,
            31
          ],
          [
            2546,
            49
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            2566,
            22
          ],
          [
            2566,
            37
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            2578,
            14
          ],
          [
            2578,
            26
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2578,
            32
          ],
          [
            2578,
            44
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            2578,
            53
          ],
          [
            2578,
            71
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            2611,
            14
          ],
          [
            2611,
            26
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2611,
            32
          ],
          [
            2611,
            44
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            2647,
            9
          ],
          [
            2647,
            21
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            2649,
            1
          ],
          [
            2649,
            19
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            2669,
            11
          ],
          [
            2669,
            23
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            2671,
            1
          ],
          [
            2671,
            19
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            2684,
            33
          ],
          [
            2684,
            45
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <pcap-types.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <memory.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <setjmp.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"gencode.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include \"optimize.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <intrin.h>\n",
          [
            123,
            0
          ],
          [
            124,
            0
          ]
        ],
        [
          "#include <strings.h>\n",
          [
            154,
            2
          ],
          [
            155,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/sslutils.c": {
      "fn_def_list": [
        {
          "fn_code": "void ssl_set_certfile(const char *certfile)\n{\n\tssl_certfile = certfile;\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ssl_set_certfile",
            "parameters": {
              "certfile": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ssl_set_keyfile(const char *keyfile)\n{\n\tssl_keyfile = keyfile;\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              59,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ssl_set_keyfile",
            "parameters": {
              "keyfile": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ssl_init_once(int is_server, int enable_compression, char *errbuf, size_t errbuflen)\n{\n\tstatic int inited = 0;\n\tif (inited) return 0;\n\n\tSSL_library_init();\n\tSSL_load_error_strings();\n\tOpenSSL_add_ssl_algorithms();\n\tif (enable_compression)\n\t\tSSL_COMP_get_compression_methods();\n\n\tSSL_METHOD const *meth =\n\t    is_server ? SSLv23_server_method() : SSLv23_client_method();\n\tctx = SSL_CTX_new(meth);\n\tif (! ctx)\n\t{\n\t\tpcap_snprintf(errbuf, errbuflen, \"Cannot get a new SSL context: %s\", ERR_error_string(ERR_get_error(), NULL));\n\t\tgoto die;\n\t}\n\n\tSSL_CTX_set_mode(ctx, SSL_MODE_AUTO_RETRY);\n\n\tif (is_server)\n\t{\n\t\tchar const *certfile = ssl_certfile[0] ? ssl_certfile : \"cert.pem\";\n\t\tif (1 != SSL_CTX_use_certificate_file(ctx, certfile, SSL_FILETYPE_PEM))\n\t\t{\n\t\t\tpcap_snprintf(errbuf, errbuflen, \"Cannot read certificate file %s: %s\", certfile, ERR_error_string(ERR_get_error(), NULL));\n\t\t\tgoto die;\n\t\t}\n\n\t\tchar const *keyfile = ssl_keyfile[0] ? ssl_keyfile : \"key.pem\";\n\t\tif (1 != SSL_CTX_use_PrivateKey_file(ctx, keyfile, SSL_FILETYPE_PEM))\n\t\t{\n\t\t\tpcap_snprintf(errbuf, errbuflen, \"Cannot read private key file %s: %s\", keyfile, ERR_error_string(ERR_get_error(), NULL));\n\t\t\tgoto die;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (ssl_rootfile[0])\n\t\t{\n\t\t\tif (! SSL_CTX_load_verify_locations(ctx, ssl_rootfile, 0))\n\t\t\t{\n\t\t\t\tpcap_snprintf(errbuf, errbuflen, \"Cannot read CA list from %s\", ssl_rootfile);\n\t\t\t\tgoto die;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);\n\t\t}\n\t}\n\n#if 0\n\tif (! RAND_load_file(RANDOM, 1024*1024))\n\t{\n\t\tpcap_snprintf(errbuf, errbuflen, \"Cannot init random\");\n\t\tgoto die;\n\t}\n\n\tif (is_server)\n\t{\n\t\tSSL_CTX_set_session_id_context(ctx, (void *)&s_server_session_id_context, sizeof(s_server_session_id_context));\n\t}\n#endif\n\n\tinited = 1;\n\treturn 0;\n\ndie:\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ssl_init_once",
            "parameters": {
              "is_server": "int",
              "enable_compression": "int",
              "errbuf": "char",
              "errbuflen": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "SSL *ssl_promotion(int is_server, SOCKET s, char *errbuf, size_t errbuflen)\n{\n\tif (ssl_init_once(is_server, 1, errbuf, errbuflen) < 0) {\n\t\treturn NULL;\n\t}\n\n\tSSL *ssl = SSL_new(ctx); // TODO: also a DTLS context\n\tSSL_set_fd(ssl, s);\n\n\tif (is_server) {\n\t\tif (SSL_accept(ssl) <= 0) {\n\t\t\tpcap_snprintf(errbuf, errbuflen, \"SSL_accept(): %s\",\n\t\t\t\t\tERR_error_string(ERR_get_error(), NULL));\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tif (SSL_connect(ssl) <= 0) {\n\t\t\tpcap_snprintf(errbuf, errbuflen, \"SSL_connect(): %s\",\n\t\t\t\t\tERR_error_string(ERR_get_error(), NULL));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn ssl;\n}",
          "fn_code_pos": [
            [
              135,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ssl_promotion",
            "parameters": {
              "is_server": "int",
              "s": "SOCKET",
              "errbuf": "char",
              "errbuflen": "size_t"
            },
            "return_type": "SSL"
          }
        },
        {
          "fn_code": "void ssl_finish(SSL *ssl)\n{\n\t//\n\t// We won't be using this again, so we can just send the\n\t// shutdown alert and free up the handle, and have our\n\t// caller close the socket.\n\t//\n\t// XXX - presumably, if the connection is shut down on\n\t// our side, either our peer won't have a problem sending\n\t// their shutdown alert or will not treat such a problem\n\t// as an error.  If this causes errors to be reported,\n\t// fix that as appropriate.\n\t//\n\tSSL_shutdown(ssl);\n\tSSL_free(ssl);\n}",
          "fn_code_pos": [
            [
              163,
              0
            ],
            [
              178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ssl_finish",
            "parameters": {
              "ssl": "SSL"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ssl_send(SSL *ssl, char const *buffer, int size, char *errbuf, size_t errbuflen)\n{\n\tint status = SSL_write(ssl, buffer, size);\n\tif (status > 0)\n\t{\n\t\t// \"SSL_write() will only return with success, when the complete contents (...) has been written.\"\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tint ssl_err = SSL_get_error(ssl, status); // TODO: does it pop the error?\n\t\tif (ssl_err == SSL_ERROR_ZERO_RETURN)\n\t\t{\n\t\t\treturn -2;\n\t\t}\n\t\telse if (ssl_err == SSL_ERROR_SYSCALL)\n\t\t{\n#ifndef _WIN32\n\t\t\tif (errno == ECONNRESET || errno == EPIPE) return -2;\n#endif\n\t\t}\n\t\tpcap_snprintf(errbuf, errbuflen, \"SSL_write(): %s\",\n\t\t    ERR_error_string(ERR_get_error(), NULL));\n\t\treturn -1;\n\t}\n}",
          "fn_code_pos": [
            [
              182,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ssl_send",
            "parameters": {
              "ssl": "SSL",
              "buffer": "char",
              "size": "int",
              "errbuf": "char",
              "errbuflen": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ssl_recv(SSL *ssl, char *buffer, int size, char *errbuf, size_t errbuflen)\n{\n\tint status = SSL_read(ssl, buffer, size);\n\tif (status <= 0)\n\t{\n\t\tint ssl_err = SSL_get_error(ssl, status);\n\t\tif (ssl_err == SSL_ERROR_ZERO_RETURN)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\telse if (ssl_err == SSL_ERROR_SYSCALL)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Should not happen\n\t\t\tpcap_snprintf(errbuf, errbuflen, \"SSL_read(): %s\",\n\t\t\t    ERR_error_string(ERR_get_error(), NULL));\n\t\t\treturn -2;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn status;\n\t}\n}",
          "fn_code_pos": [
            [
              210,
              0
            ],
            [
              236,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ssl_recv",
            "parameters": {
              "ssl": "SSL",
              "buffer": "char",
              "size": "int",
              "errbuf": "char",
              "errbuflen": "size_t"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ssl_promotion(int is_server, SOCKET s, char *errbuf, size_t errbuflen)",
          "fn_dec_pos": [
            [
              135,
              5
            ],
            [
              135,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ssl_promotion",
            "parameters": {
              "is_server": "int",
              "s": "SOCKET",
              "errbuf": "char",
              "errbuflen": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include \"sslutils.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/fad-glifc.c": {
      "fn_def_list": [
        {
          "fn_code": "int\npcap_findalldevs_interfaces(pcap_if_list_t *devlistp, char *errbuf,\n    int (*check_usable)(const char *), get_if_flags_func get_flags_func)\n{\n\tregister int fd4, fd6, fd;\n\tregister struct lifreq *ifrp, *ifend;\n\tstruct lifnum ifn;\n\tstruct lifconf ifc;\n\tchar *buf = NULL;\n\tunsigned buf_size;\n#ifdef HAVE_SOLARIS\n\tchar *p, *q;\n#endif\n\tstruct lifreq ifrflags, ifrnetmask, ifrbroadaddr, ifrdstaddr;\n\tstruct sockaddr *netmask, *broadaddr, *dstaddr;\n\tint ret = 0;\n\n\t/*\n\t * Create a socket from which to fetch the list of interfaces,\n\t * and from which to fetch IPv4 information.\n\t */\n\tfd4 = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd4 < 0) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"socket: AF_INET\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Create a socket from which to fetch IPv6 information.\n\t */\n\tfd6 = socket(AF_INET6, SOCK_DGRAM, 0);\n\tif (fd6 < 0) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"socket: AF_INET6\");\n\t\t(void)close(fd4);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * How many entries will SIOCGLIFCONF return?\n\t */\n\tifn.lifn_family = AF_UNSPEC;\n\tifn.lifn_flags = 0;\n\tifn.lifn_count = 0;\n\tif (ioctl(fd4, SIOCGLIFNUM, (char *)&ifn) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCGLIFNUM\");\n\t\t(void)close(fd6);\n\t\t(void)close(fd4);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Allocate a buffer for those entries.\n\t */\n\tbuf_size = ifn.lifn_count * sizeof (struct lifreq);\n\tbuf = malloc(buf_size);\n\tif (buf == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\t(void)close(fd6);\n\t\t(void)close(fd4);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Get the entries.\n\t */\n\tifc.lifc_len = buf_size;\n\tifc.lifc_buf = buf;\n\tifc.lifc_family = AF_UNSPEC;\n\tifc.lifc_flags = 0;\n\tmemset(buf, 0, buf_size);\n\tif (ioctl(fd4, SIOCGLIFCONF, (char *)&ifc) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCGLIFCONF\");\n\t\t(void)close(fd6);\n\t\t(void)close(fd4);\n\t\tfree(buf);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Loop over the entries.\n\t */\n\tifrp = (struct lifreq *)buf;\n\tifend = (struct lifreq *)(buf + ifc.lifc_len);\n\n\tfor (; ifrp < ifend; ifrp++) {\n\t\t/*\n\t\t * Skip entries that begin with \"dummy\".\n\t\t * XXX - what are these?  Is this Linux-specific?\n\t\t * Are there platforms on which we shouldn't do this?\n\t\t */\n\t\tif (strncmp(ifrp->lifr_name, \"dummy\", 5) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Can we capture on this device?\n\t\t */\n\t\tif (!(*check_usable)(ifrp->lifr_name)) {\n\t\t\t/*\n\t\t\t * No.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * IPv6 or not?\n\t\t */\n\t\tif (((struct sockaddr *)&ifrp->lifr_addr)->sa_family == AF_INET6)\n\t\t\tfd = fd6;\n\t\telse\n\t\t\tfd = fd4;\n\n\t\t/*\n\t\t * Get the flags for this interface.\n\t\t */\n\t\tstrncpy(ifrflags.lifr_name, ifrp->lifr_name,\n\t\t    sizeof(ifrflags.lifr_name));\n\t\tif (ioctl(fd, SIOCGLIFFLAGS, (char *)&ifrflags) < 0) {\n\t\t\tif (errno == ENXIO)\n\t\t\t\tcontinue;\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"SIOCGLIFFLAGS: %.*s\",\n\t\t\t    (int)sizeof(ifrflags.lifr_name),\n\t\t\t    ifrflags.lifr_name);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Get the netmask for this address on this interface.\n\t\t */\n\t\tstrncpy(ifrnetmask.lifr_name, ifrp->lifr_name,\n\t\t    sizeof(ifrnetmask.lifr_name));\n\t\tmemcpy(&ifrnetmask.lifr_addr, &ifrp->lifr_addr,\n\t\t    sizeof(ifrnetmask.lifr_addr));\n\t\tif (ioctl(fd, SIOCGLIFNETMASK, (char *)&ifrnetmask) < 0) {\n\t\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\t\t/*\n\t\t\t\t * Not available.\n\t\t\t\t */\n\t\t\t\tnetmask = NULL;\n\t\t\t} else {\n\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"SIOCGLIFNETMASK: %.*s\",\n\t\t\t\t    (int)sizeof(ifrnetmask.lifr_name),\n\t\t\t\t    ifrnetmask.lifr_name);\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tnetmask = (struct sockaddr *)&ifrnetmask.lifr_addr;\n\n\t\t/*\n\t\t * Get the broadcast address for this address on this\n\t\t * interface (if any).\n\t\t */\n\t\tif (ifrflags.lifr_flags & IFF_BROADCAST) {\n\t\t\tstrncpy(ifrbroadaddr.lifr_name, ifrp->lifr_name,\n\t\t\t    sizeof(ifrbroadaddr.lifr_name));\n\t\t\tmemcpy(&ifrbroadaddr.lifr_addr, &ifrp->lifr_addr,\n\t\t\t    sizeof(ifrbroadaddr.lifr_addr));\n\t\t\tif (ioctl(fd, SIOCGLIFBRDADDR,\n\t\t\t    (char *)&ifrbroadaddr) < 0) {\n\t\t\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Not available.\n\t\t\t\t\t */\n\t\t\t\t\tbroadaddr = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"SIOCGLIFBRDADDR: %.*s\",\n\t\t\t\t\t    (int)sizeof(ifrbroadaddr.lifr_name),\n\t\t\t\t\t    ifrbroadaddr.lifr_name);\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tbroadaddr = (struct sockaddr *)&ifrbroadaddr.lifr_broadaddr;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Not a broadcast interface, so no broadcast\n\t\t\t * address.\n\t\t\t */\n\t\t\tbroadaddr = NULL;\n\t\t}\n\n\t\t/*\n\t\t * Get the destination address for this address on this\n\t\t * interface (if any).\n\t\t */\n\t\tif (ifrflags.lifr_flags & IFF_POINTOPOINT) {\n\t\t\tstrncpy(ifrdstaddr.lifr_name, ifrp->lifr_name,\n\t\t\t    sizeof(ifrdstaddr.lifr_name));\n\t\t\tmemcpy(&ifrdstaddr.lifr_addr, &ifrp->lifr_addr,\n\t\t\t    sizeof(ifrdstaddr.lifr_addr));\n\t\t\tif (ioctl(fd, SIOCGLIFDSTADDR,\n\t\t\t    (char *)&ifrdstaddr) < 0) {\n\t\t\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Not available.\n\t\t\t\t\t */\n\t\t\t\t\tdstaddr = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"SIOCGLIFDSTADDR: %.*s\",\n\t\t\t\t\t    (int)sizeof(ifrdstaddr.lifr_name),\n\t\t\t\t\t    ifrdstaddr.lifr_name);\n\t\t\t\t\tret = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tdstaddr = (struct sockaddr *)&ifrdstaddr.lifr_dstaddr;\n\t\t} else\n\t\t\tdstaddr = NULL;\n\n#ifdef HAVE_SOLARIS\n\t\t/*\n\t\t * If this entry has a colon followed by a number at\n\t\t * the end, it's a logical interface.  Those are just\n\t\t * the way you assign multiple IP addresses to a real\n\t\t * interface, so an entry for a logical interface should\n\t\t * be treated like the entry for the real interface;\n\t\t * we do that by stripping off the \":\" and the number.\n\t\t */\n\t\tp = strchr(ifrp->lifr_name, ':');\n\t\tif (p != NULL) {\n\t\t\t/*\n\t\t\t * We have a \":\"; is it followed by a number?\n\t\t\t */\n\t\t\tq = p + 1;\n\t\t\twhile (isdigit((unsigned char)*q))\n\t\t\t\tq++;\n\t\t\tif (*q == '\\0') {\n\t\t\t\t/*\n\t\t\t\t * All digits after the \":\" until the end.\n\t\t\t\t * Strip off the \":\" and everything after\n\t\t\t\t * it.\n\t\t\t\t */\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Add information for this address to the list.\n\t\t */\n\t\tif (add_addr_to_if(devlistp, ifrp->lifr_name,\n\t\t    ifrflags.lifr_flags, get_flags_func,\n\t\t    (struct sockaddr *)&ifrp->lifr_addr,\n\t\t    sizeof (struct sockaddr_storage),\n\t\t    netmask, sizeof (struct sockaddr_storage),\n\t\t    broadaddr, sizeof (struct sockaddr_storage),\n\t\t    dstaddr, sizeof (struct sockaddr_storage), errbuf) < 0) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(buf);\n\t(void)close(fd6);\n\t(void)close(fd4);\n\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              345,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_findalldevs_interfaces",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char",
              "check_usable": "int",
              "get_flags_func": "get_if_flags_func"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*check_usable)(const char *)",
          "fn_dec_pos": [
            [
              78,
              8
            ],
            [
              78,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct mbuf",
          {},
          "",
          [
            47,
            0
          ],
          [
            47,
            11
          ]
        ],
        [
          "struct rtentry",
          {},
          "",
          [
            48,
            0
          ],
          [
            48,
            14
          ]
        ],
        [
          "struct lifreq",
          {},
          "",
          [
            81,
            10
          ],
          [
            81,
            23
          ]
        ],
        [
          "struct lifnum",
          {},
          "",
          [
            82,
            1
          ],
          [
            82,
            14
          ]
        ],
        [
          "struct lifconf",
          {},
          "",
          [
            83,
            1
          ],
          [
            83,
            15
          ]
        ],
        [
          "struct lifreq",
          {},
          "",
          [
            89,
            1
          ],
          [
            89,
            14
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            90,
            1
          ],
          [
            90,
            16
          ]
        ],
        [
          "struct lifreq",
          {},
          "",
          [
            132,
            37
          ],
          [
            132,
            50
          ]
        ],
        [
          "struct lifreq",
          {},
          "",
          [
            162,
            9
          ],
          [
            162,
            22
          ]
        ],
        [
          "struct lifreq",
          {},
          "",
          [
            163,
            10
          ],
          [
            163,
            23
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            187,
            8
          ],
          [
            187,
            23
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            231,
            14
          ],
          [
            231,
            29
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            259,
            17
          ],
          [
            259,
            32
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            294,
            15
          ],
          [
            294,
            30
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            331,
            7
          ],
          [
            331,
            22
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            332,
            14
          ],
          [
            332,
            37
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            333,
            23
          ],
          [
            333,
            46
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            334,
            25
          ],
          [
            334,
            48
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            335,
            23
          ],
          [
            335,
            46
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <sys/param.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <sys/file.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <sys/ioctl.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <sys/sockio.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <sys/time.h>\t\t\t\t/* concession to AIX */\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <net/if.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <memory.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/dlpisubs.c": {
      "fn_def_list": [
        {
          "fn_code": "int\npcap_stats_dlpi(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct pcap_dlpi *pd = p->priv;\n\n\t/*\n\t * \"ps_recv\" counts packets handed to the filter, not packets\n\t * that passed the filter.  As filtering is done in userland,\n\t * this would not include packets dropped because we ran out\n\t * of buffer space; in order to make this more like other\n\t * platforms (Linux 2.4 and later, BSDs with BPF), where the\n\t * \"packets received\" count includes packets received but dropped\n\t * due to running out of buffer space, and to keep from confusing\n\t * applications that, for example, compute packet drop percentages,\n\t * we also make it count packets dropped by \"bufmod\" (otherwise we\n\t * might run the risk of the packet drop count being bigger than\n\t * the received-packet count).\n\t *\n\t * \"ps_drop\" counts packets dropped by \"bufmod\" because of\n\t * flow control requirements or resource exhaustion; it doesn't\n\t * count packets dropped by the interface driver, or packets\n\t * dropped upstream.  As filtering is done in userland, it counts\n\t * packets regardless of whether they would've passed the filter.\n\t *\n\t * These statistics don't include packets not yet read from\n\t * the kernel by libpcap, but they may include packets not\n\t * yet read from libpcap by the application.\n\t */\n\t*ps = pd->stat;\n\n\t/*\n\t * Add in the drop count, as per the above comment.\n\t */\n\tps->ps_recv += ps->ps_drop;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              78,
              0
            ],
            [
              113,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_dlpi",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_process_mactype(pcap_t *p, u_int mactype)\n{\n\tint retv = 0;\n\n\tswitch (mactype) {\n\n\tcase DL_CSMACD:\n\tcase DL_ETHER:\n\t\tp->linktype = DLT_EN10MB;\n\t\tp->offset = 2;\n\t\t/*\n\t\t * This is (presumably) a real Ethernet capture; give it a\n\t\t * link-layer-type list with DLT_EN10MB and DLT_DOCSIS, so\n\t\t * that an application can let you choose it, in case you're\n\t\t * capturing DOCSIS traffic that a Cisco Cable Modem\n\t\t * Termination System is putting out onto an Ethernet (it\n\t\t * doesn't put an Ethernet header onto the wire, it puts raw\n\t\t * DOCSIS frames out on the wire inside the low-level\n\t\t * Ethernet framing).\n\t\t */\n\t\tp->dlt_list = (u_int *)malloc(sizeof(u_int) * 2);\n\t\t/*\n\t\t * If that fails, just leave the list empty.\n\t\t */\n\t\tif (p->dlt_list != NULL) {\n\t\t\tp->dlt_list[0] = DLT_EN10MB;\n\t\t\tp->dlt_list[1] = DLT_DOCSIS;\n\t\t\tp->dlt_count = 2;\n\t\t}\n\t\tbreak;\n\n\tcase DL_FDDI:\n\t\tp->linktype = DLT_FDDI;\n\t\tp->offset = 3;\n\t\tbreak;\n\n\tcase DL_TPR:\n\t\t/* XXX - what about DL_TPB?  Is that Token Bus?  */\n\t\tp->linktype = DLT_IEEE802;\n\t\tp->offset = 2;\n\t\tbreak;\n\n#ifdef HAVE_SOLARIS\n\tcase DL_IPATM:\n\t\tp->linktype = DLT_SUNATM;\n\t\tp->offset = 0;  /* works for LANE and LLC encapsulation */\n\t\tbreak;\n#endif\n\n#ifdef DL_IPV4\n\tcase DL_IPV4:\n\t\tp->linktype = DLT_IPV4;\n\t\tp->offset = 0;\n\t\tbreak;\n#endif\n\n#ifdef DL_IPV6\n\tcase DL_IPV6:\n\t\tp->linktype = DLT_IPV6;\n\t\tp->offset = 0;\n\t\tbreak;\n#endif\n\n#ifdef DL_IPNET\n\tcase DL_IPNET:\n\t\t/*\n\t\t * XXX - DL_IPNET devices default to \"raw IP\" rather than\n\t\t * \"IPNET header\"; see\n\t\t *\n\t\t *    http://seclists.org/tcpdump/2009/q1/202\n\t\t *\n\t\t * We'd have to do DL_IOC_IPNET_INFO to enable getting\n\t\t * the IPNET header.\n\t\t */\n\t\tp->linktype = DLT_RAW;\n\t\tp->offset = 0;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"unknown mactype 0x%x\",\n\t\t    mactype);\n\t\tretv = -1;\n\t}\n\n\treturn (retv);\n}",
          "fn_code_pos": [
            [
              221,
              0
            ],
            [
              308,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_process_mactype",
            "parameters": {
              "p": "pcap_t",
              "mactype": "u_int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_conf_bufmod(pcap_t *p, int snaplen)\n{\n\tstruct timeval to;\n\tbpf_u_int32 ss, chunksize;\n\n\t/* Non-standard call to get the data nicely buffered. */\n\tif (ioctl(p->fd, I_PUSH, \"bufmod\") != 0) {\n\t\tpcap_stream_err(\"I_PUSH bufmod\", errno, p->errbuf);\n\t\treturn (-1);\n\t}\n\n\tss = snaplen;\n\tif (ss > 0 &&\n\t    strioctl(p->fd, SBIOCSSNAP, sizeof(ss), (char *)&ss) != 0) {\n\t\tpcap_stream_err(\"SBIOCSSNAP\", errno, p->errbuf);\n\t\treturn (-1);\n\t}\n\n\tif (p->opt.immediate) {\n\t\t/* Set the timeout to zero, for immediate delivery. */\n\t\tto.tv_sec = 0;\n\t\tto.tv_usec = 0;\n\t\tif (strioctl(p->fd, SBIOCSTIME, sizeof(to), (char *)&to) != 0) {\n\t\t\tpcap_stream_err(\"SBIOCSTIME\", errno, p->errbuf);\n\t\t\treturn (-1);\n\t\t}\n\t} else {\n\t\t/* Set up the bufmod timeout. */\n\t\tif (p->opt.timeout != 0) {\n\t\t\tto.tv_sec = p->opt.timeout / 1000;\n\t\t\tto.tv_usec = (p->opt.timeout * 1000) % 1000000;\n\t\t\tif (strioctl(p->fd, SBIOCSTIME, sizeof(to), (char *)&to) != 0) {\n\t\t\t\tpcap_stream_err(\"SBIOCSTIME\", errno, p->errbuf);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t}\n\n\t\t/* Set the chunk length. */\n\t\tchunksize = CHUNKSIZE;\n\t\tif (strioctl(p->fd, SBIOCSCHUNK, sizeof(chunksize), (char *)&chunksize)\n\t\t    != 0) {\n\t\t\tpcap_stream_err(\"SBIOCSCHUNKP\", errno, p->errbuf);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              314,
              0
            ],
            [
              362,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_conf_bufmod",
            "parameters": {
              "p": "pcap_t",
              "snaplen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_alloc_databuf(pcap_t *p)\n{\n\tp->bufsize = PKTBUFSIZE;\n\tp->buffer = malloc(p->bufsize + p->offset);\n\tif (p->buffer == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              368,
              0
            ],
            [
              380,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_alloc_databuf",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nstrioctl(int fd, int cmd, int len, char *dp)\n{\n\tstruct strioctl str;\n\tint retv;\n\n\tstr.ic_cmd = cmd;\n\tstr.ic_timout = -1;\n\tstr.ic_len = len;\n\tstr.ic_dp = dp;\n\tif ((retv = ioctl(fd, I_STR, &str)) < 0)\n\t\treturn (retv);\n\n\treturn (str.ic_len);\n}",
          "fn_code_pos": [
            [
              386,
              0
            ],
            [
              400,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strioctl",
            "parameters": {
              "fd": "int",
              "cmd": "int",
              "len": "int",
              "dp": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\npcap_stream_err(const char *func, int err, char *errbuf)\n{\n\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, err, \"%s\", func);\n}",
          "fn_code_pos": [
            [
              406,
              0
            ],
            [
              410,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stream_err",
            "parameters": {
              "func": "char",
              "err": "int",
              "errbuf": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "pcap_stream_err(const char *, int, char *)",
          "fn_dec_pos": [
            [
              72,
              12
            ],
            [
              72,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stream_err",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_process_pkts(pcap_t *p, pcap_handler callback, u_char *user,\n\tint count, u_char *bufp, int len)",
          "fn_dec_pos": [
            [
              134,
              0
            ],
            [
              135,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_process_pkts",
            "parameters": {
              "p": "pcap_t",
              "callback": "pcap_handler",
              "user": "u_char",
              "count": "int",
              "bufp": "u_char",
              "len": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_stat",
          {},
          "",
          [
            79,
            27
          ],
          [
            79,
            43
          ]
        ],
        [
          "struct pcap_dlpi",
          {},
          "",
          [
            81,
            1
          ],
          [
            81,
            17
          ]
        ],
        [
          "struct pcap_dlpi",
          {},
          "",
          [
            137,
            1
          ],
          [
            137,
            17
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            140,
            1
          ],
          [
            140,
            19
          ]
        ],
        [
          "struct sb_hdr",
          {},
          "",
          [
            142,
            1
          ],
          [
            142,
            14
          ]
        ],
        [
          "struct sb_hdr",
          {},
          "",
          [
            144,
            1
          ],
          [
            144,
            14
          ]
        ],
        [
          "struct sb_hdr",
          {},
          "",
          [
            179,
            10
          ],
          [
            179,
            23
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            317,
            1
          ],
          [
            317,
            15
          ]
        ],
        [
          "struct strioctl",
          {},
          "",
          [
            389,
            1
          ],
          [
            389,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <sys/bufmod.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include <sys/dlpi.h>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <sys/stream.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include <memory.h>\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include <stropts.h>\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            62,
            0
          ],
          [
            63,
            0
          ]
        ],
        [
          "#include <libdlpi.h>\n",
          [
            65,
            0
          ],
          [
            66,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            68,
            0
          ],
          [
            69,
            0
          ]
        ],
        [
          "#include \"dlpisubs.h\"\n",
          [
            69,
            0
          ],
          [
            70,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/nametoaddr.c": {
      "fn_def_list": [
        {
          "fn_code": "bpf_u_int32 **\npcap_nametoaddr(const char *name)\n{\n#ifndef h_addr\n\tstatic bpf_u_int32 *hlist[2];\n#endif\n\tbpf_u_int32 **p;\n\tstruct hostent *hp;\n\n\t/*\n\t * gethostbyname() is deprecated on Windows, perhaps because\n\t * it's not thread-safe, or because it doesn't support IPv6,\n\t * or both.\n\t *\n\t * We deprecate pcap_nametoaddr() on all platforms because\n\t * it's not thread-safe; we supply it for backwards compatibility,\n\t * so suppress the deprecation warning.  We could, I guess,\n\t * use getaddrinfo() and construct the array ourselves, but\n\t * that's probably not worth the effort, as that wouldn't make\n\t * this thread-safe - we can't change the API to require that\n\t * our caller free the address array, so we still have to reuse\n\t * a local array.\n\t */\nDIAG_OFF_DEPRECATION\n\tif ((hp = gethostbyname(name)) != NULL) {\nDIAG_ON_DEPRECATION\n#ifndef h_addr\n\t\thlist[0] = (bpf_u_int32 *)hp->h_addr;\n\t\tNTOHL(hp->h_addr);\n\t\treturn hlist;\n#else\n\t\tfor (p = (bpf_u_int32 **)hp->h_addr_list; *p; ++p)\n\t\t\tNTOHL(**p);\n\t\treturn (bpf_u_int32 **)hp->h_addr_list;\n#endif\n\t}\n\telse\n\t\treturn 0;\n}",
          "fn_code_pos": [
            [
              157,
              0
            ],
            [
              195,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "bpf_u_int32"
          }
        },
        {
          "fn_code": "struct addrinfo *\npcap_nametoaddrinfo(const char *name)\n{\n\tstruct addrinfo hints, *res;\n\tint error;\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\t/*not really*/\n\thints.ai_protocol = IPPROTO_TCP;\t/*not really*/\n\terror = getaddrinfo(name, NULL, &hints, &res);\n\tif (error)\n\t\treturn NULL;\n\telse\n\t\treturn res;\n}",
          "fn_code_pos": [
            [
              197,
              0
            ],
            [
              212,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_nametoaddrinfo",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "bpf_u_int32\npcap_nametonetaddr(const char *name)\n{\n#ifdef _WIN32\n\t/*\n\t * There's no \"getnetbyname()\" on Windows.\n\t *\n\t * XXX - I guess we could use the BSD code to read\n\t * C:\\Windows\\System32\\drivers\\etc/networks, assuming\n\t * that's its home on all the versions of Windows\n\t * we use, but that file probably just has the loopback\n\t * network on 127/24 on 99 44/100% of Windows machines.\n\t *\n\t * (Heck, these days it probably just has that on 99 44/100%\n\t * of *UN*X* machines.)\n\t */\n\treturn 0;\n#else\n\t/*\n\t * UN*X.\n\t */\n\tstruct netent *np;\n  #if defined(HAVE_LINUX_GETNETBYNAME_R)\n\t/*\n\t * We have Linux's reentrant getnetbyname_r().\n\t */\n\tstruct netent result_buf;\n\tchar buf[1024];\t/* arbitrary size */\n\tint h_errnoval;\n\tint err;\n\n\t/*\n\t * Apparently, the man page at\n\t *\n\t *    http://man7.org/linux/man-pages/man3/getnetbyname_r.3.html\n\t *\n\t * lies when it says\n\t *\n\t *    If the function call successfully obtains a network record,\n\t *    then *result is set pointing to result_buf; otherwise, *result\n\t *    is set to NULL.\n\t *\n\t * and, in fact, at least in some versions of GNU libc, it does\n\t * *not* always get set if getnetbyname_r() succeeds.\n\t */\n\tnp = NULL;\n \terr = getnetbyname_r(name, &result_buf, buf, sizeof buf, &np,\n\t    &h_errnoval);\n\tif (err != 0) {\n\t\t/*\n\t\t * XXX - dynamically allocate the buffer, and make it\n\t\t * bigger if we get ERANGE back?\n\t\t */\n\t\treturn 0;\n\t}\n  #elif defined(HAVE_SOLARIS_IRIX_GETNETBYNAME_R)\n\t/*\n\t * We have Solaris's and IRIX's reentrant getnetbyname_r().\n\t */\n\tstruct netent result_buf;\n\tchar buf[1024];\t/* arbitrary size */\n\n\tnp = getnetbyname_r(name, &result_buf, buf, (int)sizeof buf);\n  #elif defined(HAVE_AIX_GETNETBYNAME_R)\n\t/*\n\t * We have AIX's reentrant getnetbyname_r().\n\t */\n\tstruct netent result_buf;\n\tstruct netent_data net_data;\n\n\tif (getnetbyname_r(name, &result_buf, &net_data) == -1)\n\t\tnp = NULL;\n\telse\n\t\tnp = &result_buf;\n  #else\n \t/*\n \t * We don't have any getnetbyname_r(); either we have a\n \t * getnetbyname() that uses thread-specific data, in which\n \t * case we're thread-safe (sufficiently recent FreeBSD,\n \t * sufficiently recent Darwin-based OS, sufficiently recent\n \t * HP-UX, sufficiently recent Tru64 UNIX), or we have the\n \t * traditional getnetbyname() (everything else, including\n \t * current NetBSD and OpenBSD), in which case we're not\n \t * thread-safe.\n \t */\n\tnp = getnetbyname(name);\n  #endif\n\tif (np != NULL)\n\t\treturn np->n_net;\n\telse\n\t\treturn 0;\n#endif /* _WIN32 */\n}",
          "fn_code_pos": [
            [
              220,
              0
            ],
            [
              312,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_nametonetaddr",
            "parameters": {
              "name": "char"
            },
            "return_type": "bpf_u_int32"
          }
        },
        {
          "fn_code": "int\npcap_nametoport(const char *name, int *port, int *proto)\n{\n\tstruct addrinfo hints, *res, *ai;\n\tint error;\n\tstruct sockaddr_in *in4;\n#ifdef INET6\n\tstruct sockaddr_in6 *in6;\n#endif\n\tint tcp_port = -1;\n\tint udp_port = -1;\n\n\t/*\n\t * We check for both TCP and UDP in case there are\n\t * ambiguous entries.\n\t */\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_protocol = IPPROTO_TCP;\n\terror = getaddrinfo(NULL, name, &hints, &res);\n\tif (error != 0) {\n\t\tif (error != EAI_NONAME &&\n\t\t    error != EAI_SERVICE) {\n\t\t\t/*\n\t\t\t * This is a real error, not just \"there's\n\t\t\t * no such service name\".\n\t\t\t * XXX - this doesn't return an error string.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * OK, we found it.  Did it find anything?\n\t\t */\n\t\tfor (ai = res; ai != NULL; ai = ai->ai_next) {\n\t\t\t/*\n\t\t\t * Does it have an address?\n\t\t\t */\n\t\t\tif (ai->ai_addr != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Yes.  Get a port number; we're done.\n\t\t\t\t */\n\t\t\t\tif (ai->ai_addr->sa_family == AF_INET) {\n\t\t\t\t\tin4 = (struct sockaddr_in *)ai->ai_addr;\n\t\t\t\t\ttcp_port = ntohs(in4->sin_port);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#ifdef INET6\n\t\t\t\tif (ai->ai_addr->sa_family == AF_INET6) {\n\t\t\t\t\tin6 = (struct sockaddr_in6 *)ai->ai_addr;\n\t\t\t\t\ttcp_port = ntohs(in6->sin6_port);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t\tfreeaddrinfo(res);\n\t}\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_DGRAM;\n\thints.ai_protocol = IPPROTO_UDP;\n\terror = getaddrinfo(NULL, name, &hints, &res);\n\tif (error != 0) {\n\t\tif (error != EAI_NONAME &&\n\t\t    error != EAI_SERVICE) {\n\t\t\t/*\n\t\t\t * This is a real error, not just \"there's\n\t\t\t * no such service name\".\n\t\t\t * XXX - this doesn't return an error string.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * OK, we found it.  Did it find anything?\n\t\t */\n\t\tfor (ai = res; ai != NULL; ai = ai->ai_next) {\n\t\t\t/*\n\t\t\t * Does it have an address?\n\t\t\t */\n\t\t\tif (ai->ai_addr != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Yes.  Get a port number; we're done.\n\t\t\t\t */\n\t\t\t\tif (ai->ai_addr->sa_family == AF_INET) {\n\t\t\t\t\tin4 = (struct sockaddr_in *)ai->ai_addr;\n\t\t\t\t\tudp_port = ntohs(in4->sin_port);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#ifdef INET6\n\t\t\t\tif (ai->ai_addr->sa_family == AF_INET6) {\n\t\t\t\t\tin6 = (struct sockaddr_in6 *)ai->ai_addr;\n\t\t\t\t\tudp_port = ntohs(in6->sin6_port);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t\tfreeaddrinfo(res);\n\t}\n\n\t/*\n\t * We need to check /etc/services for ambiguous entries.\n\t * If we find an ambiguous entry, and it has the\n\t * same port number, change the proto to PROTO_UNDEF\n\t * so both TCP and UDP will be checked.\n\t */\n\tif (tcp_port >= 0) {\n\t\t*port = tcp_port;\n\t\t*proto = IPPROTO_TCP;\n\t\tif (udp_port >= 0) {\n\t\t\tif (udp_port == tcp_port)\n\t\t\t\t*proto = PROTO_UNDEF;\n#ifdef notdef\n\t\t\telse\n\t\t\t\t/* Can't handle ambiguous names that refer\n\t\t\t\t   to different port numbers. */\n\t\t\t\twarning(\"ambiguous port %s in /etc/services\",\n\t\t\t\t\tname);\n#endif\n\t\t}\n\t\treturn 1;\n\t}\n\tif (udp_port >= 0) {\n\t\t*port = udp_port;\n\t\t*proto = IPPROTO_UDP;\n\t\treturn 1;\n\t}\n#if defined(ultrix) || defined(__osf__)\n\t/* Special hack in case NFS isn't in /etc/services */\n\tif (strcmp(name, \"nfs\") == 0) {\n\t\t*port = 2049;\n\t\t*proto = PROTO_UNDEF;\n\t\treturn 1;\n\t}\n#endif\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              319,
              0
            ],
            [
              459,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_nametoport",
            "parameters": {
              "name": "char",
              "port": "int",
              "proto": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_nametoportrange(const char *name, int *port1, int *port2, int *proto)\n{\n\tu_int p1, p2;\n\tchar *off, *cpy;\n\tint save_proto;\n\n\tif (sscanf(name, \"%d-%d\", &p1, &p2) != 2) {\n\t\tif ((cpy = strdup(name)) == NULL)\n\t\t\treturn 0;\n\n\t\tif ((off = strchr(cpy, '-')) == NULL) {\n\t\t\tfree(cpy);\n\t\t\treturn 0;\n\t\t}\n\n\t\t*off = '\\0';\n\n\t\tif (pcap_nametoport(cpy, port1, proto) == 0) {\n\t\t\tfree(cpy);\n\t\t\treturn 0;\n\t\t}\n\t\tsave_proto = *proto;\n\n\t\tif (pcap_nametoport(off + 1, port2, proto) == 0) {\n\t\t\tfree(cpy);\n\t\t\treturn 0;\n\t\t}\n\t\tfree(cpy);\n\n\t\tif (*proto != save_proto)\n\t\t\t*proto = PROTO_UNDEF;\n\t} else {\n\t\t*port1 = p1;\n\t\t*port2 = p2;\n\t\t*proto = PROTO_UNDEF;\n\t}\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              466,
              0
            ],
            [
              505,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_nametoportrange",
            "parameters": {
              "name": "char",
              "port1": "int",
              "port2": "int",
              "proto": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_nametoproto(const char *str)\n{\n\tstruct protoent *p;\n  #if defined(HAVE_LINUX_GETNETBYNAME_R)\n\t/*\n\t * We have Linux's reentrant getprotobyname_r().\n\t */\n\tstruct protoent result_buf;\n\tchar buf[1024];\t/* arbitrary size */\n\tint err;\n\n\terr = getprotobyname_r(str, &result_buf, buf, sizeof buf, &p);\n\tif (err != 0) {\n\t\t/*\n\t\t * XXX - dynamically allocate the buffer, and make it\n\t\t * bigger if we get ERANGE back?\n\t\t */\n\t\treturn 0;\n\t}\n  #elif defined(HAVE_SOLARIS_IRIX_GETNETBYNAME_R)\n\t/*\n\t * We have Solaris's and IRIX's reentrant getprotobyname_r().\n\t */\n\tstruct protoent result_buf;\n\tchar buf[1024];\t/* arbitrary size */\n\n\tp = getprotobyname_r(str, &result_buf, buf, (int)sizeof buf);\n  #elif defined(HAVE_AIX_GETNETBYNAME_R)\n\t/*\n\t * We have AIX's reentrant getprotobyname_r().\n\t */\n\tstruct protoent result_buf;\n\tstruct protoent_data proto_data;\n\n\tif (getprotobyname_r(str, &result_buf, &proto_data) == -1)\n\t\tp = NULL;\n\telse\n\t\tp = &result_buf;\n  #else\n \t/*\n \t * We don't have any getprotobyname_r(); either we have a\n \t * getprotobyname() that uses thread-specific data, in which\n \t * case we're thread-safe (sufficiently recent FreeBSD,\n \t * sufficiently recent Darwin-based OS, sufficiently recent\n \t * HP-UX, sufficiently recent Tru64 UNIX, Windows), or we have\n\t * the traditional getprotobyname() (everything else, including\n \t * current NetBSD and OpenBSD), in which case we're not\n \t * thread-safe.\n \t */\n\tp = getprotobyname(str);\n  #endif\n\tif (p != 0)\n\t\treturn p->p_proto;\n\telse\n\t\treturn PROTO_UNDEF;\n}",
          "fn_code_pos": [
            [
              511,
              0
            ],
            [
              567,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_nametoproto",
            "parameters": {
              "str": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_nametoeproto(const char *s)\n{\n\tstruct eproto *p = eproto_db;\n\n\twhile (p->s != 0) {\n\t\tif (strcmp(p->s, s) == 0)\n\t\t\treturn p->p;\n\t\tp += 1;\n\t}\n\treturn PROTO_UNDEF;\n}",
          "fn_code_pos": [
            [
              614,
              0
            ],
            [
              625,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_nametoeproto",
            "parameters": {
              "s": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_nametollc(const char *s)\n{\n\tstruct eproto *p = llc_db;\n\n\twhile (p->s != 0) {\n\t\tif (strcmp(p->s, s) == 0)\n\t\t\treturn p->p;\n\t\tp += 1;\n\t}\n\treturn PROTO_UNDEF;\n}",
          "fn_code_pos": [
            [
              638,
              0
            ],
            [
              649,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_nametollc",
            "parameters": {
              "s": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static inline u_char\nxdtoi(u_char c)\n{\n\tif (isdigit(c))\n\t\treturn (u_char)(c - '0');\n\telse if (islower(c))\n\t\treturn (u_char)(c - 'a' + 10);\n\telse\n\t\treturn (u_char)(c - 'A' + 10);\n}",
          "fn_code_pos": [
            [
              652,
              0
            ],
            [
              661,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "xdtoi",
            "parameters": {
              "c": "u_char"
            },
            "return_type": "u_char"
          }
        },
        {
          "fn_code": "int\n__pcap_atoin(const char *s, bpf_u_int32 *addr)\n{\n\tu_int n;\n\tint len;\n\n\t*addr = 0;\n\tlen = 0;\n\tfor (;;) {\n\t\tn = 0;\n\t\twhile (*s && *s != '.')\n\t\t\tn = n * 10 + *s++ - '0';\n\t\t*addr <<= 8;\n\t\t*addr |= n & 0xff;\n\t\tlen += 8;\n\t\tif (*s == '\\0')\n\t\t\treturn len;\n\t\t++s;\n\t}\n\t/* NOTREACHED */\n}",
          "fn_code_pos": [
            [
              663,
              0
            ],
            [
              683,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "__pcap_atoin",
            "parameters": {
              "s": "char",
              "addr": "bpf_u_int32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\n__pcap_atodn(const char *s, bpf_u_int32 *addr)\n{\n#define AREASHIFT 10\n#define AREAMASK 0176000\n#define NODEMASK 01777\n\n\tu_int node, area;\n\n\tif (sscanf(s, \"%d.%d\", &area, &node) != 2)\n\t\treturn(0);\n\n\t*addr = (area << AREASHIFT) & AREAMASK;\n\t*addr |= (node & NODEMASK);\n\n\treturn(32);\n}",
          "fn_code_pos": [
            [
              685,
              0
            ],
            [
              701,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "__pcap_atodn",
            "parameters": {
              "s": "char",
              "addr": "bpf_u_int32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "u_char *\npcap_ether_aton(const char *s)\n{\n\tregister u_char *ep, *e;\n\tregister u_char d;\n\n\te = ep = (u_char *)malloc(6);\n\tif (e == NULL)\n\t\treturn (NULL);\n\n\twhile (*s) {\n\t\tif (*s == ':' || *s == '.' || *s == '-')\n\t\t\ts += 1;\n\t\td = xdtoi(*s++);\n\t\tif (isxdigit((unsigned char)*s)) {\n\t\t\td <<= 4;\n\t\t\td |= xdtoi(*s++);\n\t\t}\n\t\t*ep++ = d;\n\t}\n\n\treturn (e);\n}",
          "fn_code_pos": [
            [
              715,
              0
            ],
            [
              737,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_ether_aton",
            "parameters": {
              "s": "char"
            },
            "return_type": "u_char"
          }
        },
        {
          "fn_code": "u_char *\npcap_ether_hostton(const char *name)\n{\n\tregister struct pcap_etherent *ep;\n\tregister u_char *ap;\n\tstatic FILE *fp = NULL;\n\tstatic int init = 0;\n\n\tif (!init) {\n\t\tfp = fopen(PCAP_ETHERS_FILE, \"r\");\n\t\t++init;\n\t\tif (fp == NULL)\n\t\t\treturn (NULL);\n\t} else if (fp == NULL)\n\t\treturn (NULL);\n\telse\n\t\trewind(fp);\n\n\twhile ((ep = pcap_next_etherent(fp)) != NULL) {\n\t\tif (strcmp(ep->name, name) == 0) {\n\t\t\tap = (u_char *)malloc(6);\n\t\t\tif (ap != NULL) {\n\t\t\t\tmemcpy(ap, ep->addr, 6);\n\t\t\t\treturn (ap);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              745,
              0
            ],
            [
              774,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_ether_hostton",
            "parameters": {
              "name": "char"
            },
            "return_type": "u_char"
          }
        },
        {
          "fn_code": "u_char *\npcap_ether_hostton(const char *name)\n{\n\tregister u_char *ap;\n\tu_char a[6];\n\n\tap = NULL;\n\tif (ether_hostton(name, (struct ether_addr *)a) == 0) {\n\t\tap = (u_char *)malloc(6);\n\t\tif (ap != NULL)\n\t\t\tmemcpy((char *)ap, (char *)a, 6);\n\t}\n\treturn (ap);\n}",
          "fn_code_pos": [
            [
              780,
              0
            ],
            [
              793,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_ether_hostton",
            "parameters": {
              "name": "char"
            },
            "return_type": "u_char"
          }
        },
        {
          "fn_code": "__pcap_nametodnaddr(const char *name _U_, u_short *res _U_)\n{\n\treturn(0);\n#endif\n}",
          "fn_code_pos": [
            [
              813,
              0
            ],
            [
              817,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "__pcap_nametodnaddr",
            "parameters": {
              "name": "char",
              "res": "u_short"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ether_hostton(const char *, struct ether_addr *)",
          "fn_dec_pos": [
            [
              121,
              17
            ],
            [
              121,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ether_hostton",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_nametoaddr(const char *name)",
          "fn_dec_pos": [
            [
              158,
              0
            ],
            [
              158,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_nametoaddr",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_nametoaddrinfo(const char *name)",
          "fn_dec_pos": [
            [
              198,
              0
            ],
            [
              198,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_nametoaddrinfo",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_ether_aton(const char *s)",
          "fn_dec_pos": [
            [
              716,
              0
            ],
            [
              716,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_ether_aton",
            "parameters": {
              "s": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_ether_hostton(const char *name)",
          "fn_dec_pos": [
            [
              746,
              0
            ],
            [
              746,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_ether_hostton",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_ether_hostton(const char *name)",
          "fn_dec_pos": [
            [
              781,
              0
            ],
            [
              781,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_ether_hostton",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "__pcap_nametodnaddr(const char *name, u_short *res)",
          "fn_dec_pos": [
            [
              801,
              0
            ],
            [
              801,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "__pcap_nametodnaddr",
            "parameters": {
              "name": "char",
              "res": "u_short"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "getnodebyname()",
          "fn_dec_pos": [
            [
              803,
              17
            ],
            [
              803,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getnodebyname",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ether_addr {\n\t\tunsigned char ether_addr_octet[6];\n\t}",
          {
            "ether_addr_octet[6]": "unsigned char"
          },
          "ether_addr",
          [
            105,
            1
          ],
          [
            107,
            2
          ]
        ],
        [
          "struct eproto {\n\tconst char *s;\n\tu_short p;\n}",
          {
            "char": "const",
            "p": "u_short"
          },
          "eproto",
          [
            571,
            0
          ],
          [
            574,
            1
          ]
        ],
        [
          "struct ether_addr {\n\t\tunsigned char ether_addr_octet[6];\n\t}",
          {
            "ether_addr_octet[6]": "unsigned char"
          },
          "ether_addr",
          [
            105,
            1
          ],
          [
            107,
            2
          ]
        ],
        [
          "struct ether_addr",
          {},
          "",
          [
            121,
            45
          ],
          [
            121,
            62
          ]
        ],
        [
          "struct hostent",
          {},
          "",
          [
            164,
            1
          ],
          [
            164,
            15
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            197,
            0
          ],
          [
            197,
            15
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            200,
            1
          ],
          [
            200,
            16
          ]
        ],
        [
          "struct netent",
          {},
          "",
          [
            241,
            1
          ],
          [
            241,
            14
          ]
        ],
        [
          "struct netent",
          {},
          "",
          [
            246,
            1
          ],
          [
            246,
            14
          ]
        ],
        [
          "struct netent",
          {},
          "",
          [
            279,
            1
          ],
          [
            279,
            14
          ]
        ],
        [
          "struct netent",
          {},
          "",
          [
            287,
            1
          ],
          [
            287,
            14
          ]
        ],
        [
          "struct netent_data",
          {},
          "",
          [
            288,
            1
          ],
          [
            288,
            19
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            322,
            1
          ],
          [
            322,
            16
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            324,
            1
          ],
          [
            324,
            19
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            326,
            1
          ],
          [
            326,
            20
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            363,
            12
          ],
          [
            363,
            30
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            369,
            12
          ],
          [
            369,
            31
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            407,
            12
          ],
          [
            407,
            30
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            413,
            12
          ],
          [
            413,
            31
          ]
        ],
        [
          "struct protoent",
          {},
          "",
          [
            514,
            1
          ],
          [
            514,
            16
          ]
        ],
        [
          "struct protoent",
          {},
          "",
          [
            519,
            1
          ],
          [
            519,
            16
          ]
        ],
        [
          "struct protoent",
          {},
          "",
          [
            535,
            1
          ],
          [
            535,
            16
          ]
        ],
        [
          "struct protoent",
          {},
          "",
          [
            543,
            1
          ],
          [
            543,
            16
          ]
        ],
        [
          "struct protoent_data",
          {},
          "",
          [
            544,
            1
          ],
          [
            544,
            21
          ]
        ],
        [
          "struct eproto {\n\tconst char *s;\n\tu_short p;\n}",
          {
            "char": "const",
            "p": "u_short"
          },
          "eproto",
          [
            571,
            0
          ],
          [
            574,
            1
          ]
        ],
        [
          "struct eproto",
          {},
          "",
          [
            617,
            1
          ],
          [
            617,
            14
          ]
        ],
        [
          "struct eproto",
          {},
          "",
          [
            630,
            7
          ],
          [
            630,
            20
          ]
        ],
        [
          "struct eproto",
          {},
          "",
          [
            641,
            1
          ],
          [
            641,
            14
          ]
        ],
        [
          "struct pcap_etherent",
          {},
          "",
          [
            748,
            10
          ],
          [
            748,
            30
          ]
        ],
        [
          "struct ether_addr",
          {},
          "",
          [
            787,
            26
          ],
          [
            787,
            43
          ]
        ],
        [
          "struct nodeent",
          {},
          "",
          [
            803,
            1
          ],
          [
            803,
            15
          ]
        ],
        [
          "struct nodeent",
          {},
          "",
          [
            804,
            1
          ],
          [
            804,
            15
          ]
        ],
        [
          "struct nodeent",
          {},
          "",
          [
            807,
            14
          ],
          [
            807,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <netdnet/dnetdb.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <winsock2.h>\n",
          [
            34,
            2
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <ws2tcpip.h>\n",
          [
            35,
            2
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <wspiapi.h>\n",
          [
            59,
            4
          ],
          [
            60,
            0
          ]
        ],
        [
          "#include <sys/param.h>\n",
          [
            62,
            2
          ],
          [
            63,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            63,
            2
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            64,
            2
          ],
          [
            65,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            65,
            2
          ],
          [
            66,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            67,
            2
          ],
          [
            68,
            0
          ]
        ],
        [
          "#include <net/ethernet.h>\n",
          [
            74,
            6
          ],
          [
            75,
            0
          ]
        ],
        [
          "#include <netinet/ether.h>\n",
          [
            79,
            6
          ],
          [
            80,
            0
          ]
        ],
        [
          "#include <sys/ethernet.h>\n",
          [
            84,
            6
          ],
          [
            85,
            0
          ]
        ],
        [
          "#include <arpa/inet.h>\n",
          [
            89,
            6
          ],
          [
            90,
            0
          ]
        ],
        [
          "#include <net/if.h>\t/* Needed on some platforms */\n",
          [
            112,
            6
          ],
          [
            113,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\t/* Needed on some platforms */\n",
          [
            113,
            6
          ],
          [
            114,
            0
          ]
        ],
        [
          "#include <netinet/if_ether.h>\n",
          [
            114,
            6
          ],
          [
            115,
            0
          ]
        ],
        [
          "#include <arpa/inet.h>\n",
          [
            125,
            2
          ],
          [
            126,
            0
          ]
        ],
        [
          "#include <netdb.h>\n",
          [
            126,
            2
          ],
          [
            127,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            129,
            0
          ],
          [
            130,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            130,
            0
          ],
          [
            131,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            131,
            0
          ],
          [
            132,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            132,
            0
          ],
          [
            133,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            133,
            0
          ],
          [
            134,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            135,
            0
          ],
          [
            136,
            0
          ]
        ],
        [
          "#include \"diag-control.h\"\n",
          [
            137,
            0
          ],
          [
            138,
            0
          ]
        ],
        [
          "#include \"gencode.h\"\n",
          [
            139,
            0
          ],
          [
            140,
            0
          ]
        ],
        [
          "#include <pcap/namedb.h>\n",
          [
            140,
            0
          ],
          [
            141,
            0
          ]
        ],
        [
          "#include \"nametoaddr.h\"\n",
          [
            141,
            0
          ],
          [
            142,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            144,
            0
          ],
          [
            145,
            0
          ]
        ],
        [
          "#include \"ethertype.h\"\n",
          [
            569,
            0
          ],
          [
            570,
            0
          ]
        ],
        [
          "#include \"llc.h\"\n",
          [
            627,
            0
          ],
          [
            628,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-rdmasniff.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nrdmasniff_stats(pcap_t *handle, struct pcap_stat *stat)\n{\n\tstruct pcap_rdmasniff *priv = handle->priv;\n\n\tstat->ps_recv = priv->packets_recv;\n\tstat->ps_drop = 0;\n\tstat->ps_ifdrop = 0;\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              74,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rdmasniff_stats",
            "parameters": {
              "handle": "pcap_t",
              "stat": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nrdmasniff_cleanup(pcap_t *handle)\n{\n\tstruct pcap_rdmasniff *priv = handle->priv;\n\n\tibv_dereg_mr(priv->mr);\n\tibv_destroy_flow(priv->flow);\n\tibv_destroy_qp(priv->qp);\n\tibv_destroy_cq(priv->cq);\n\tibv_dealloc_pd(priv->pd);\n\tibv_destroy_comp_channel(priv->channel);\n\tibv_close_device(priv->context);\n\tfree(priv->oneshot_buffer);\n\n\tpcap_cleanup_live_common(handle);\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              91,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rdmasniff_cleanup",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nrdmasniff_post_recv(pcap_t *handle, uint64_t wr_id)\n{\n\tstruct pcap_rdmasniff *priv = handle->priv;\n\tstruct ibv_sge sg_entry;\n\tstruct ibv_recv_wr wr, *bad_wr;\n\n\tsg_entry.length = RDMASNIFF_RECEIVE_SIZE;\n\tsg_entry.addr = (uintptr_t) handle->buffer + RDMASNIFF_RECEIVE_SIZE * wr_id;\n\tsg_entry.lkey = priv->mr->lkey;\n\n\twr.wr_id = wr_id;\n\twr.num_sge = 1;\n\twr.sg_list = &sg_entry;\n\twr.next = NULL;\n\n\tibv_post_recv(priv->qp, &wr, &bad_wr);\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rdmasniff_post_recv",
            "parameters": {
              "handle": "pcap_t",
              "wr_id": "uint64_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nrdmasniff_read(pcap_t *handle, int max_packets, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_rdmasniff *priv = handle->priv;\n\tstruct ibv_cq *ev_cq;\n\tvoid *ev_ctx;\n\tstruct ibv_wc wc;\n\tstruct pcap_pkthdr pkth;\n\tu_char *pktd;\n\tint count = 0;\n\n\tif (!priv->cq_event) {\n\t\twhile (ibv_get_cq_event(priv->channel, &ev_cq, &ev_ctx) < 0) {\n\t\t\tif (errno != EINTR) {\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t\tif (handle->break_loop) {\n\t\t\t\thandle->break_loop = 0;\n\t\t\t\treturn PCAP_ERROR_BREAK;\n\t\t\t}\n\t\t}\n\t\tibv_ack_cq_events(priv->cq, 1);\n\t\tibv_req_notify_cq(priv->cq, 0);\n\t\tpriv->cq_event = 1;\n\t}\n\n\twhile (count < max_packets || PACKET_COUNT_IS_UNLIMITED(max_packets)) {\n\t\tif (ibv_poll_cq(priv->cq, 1, &wc) != 1) {\n\t\t\tpriv->cq_event = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wc.status != IBV_WC_SUCCESS) {\n\t\t\tfprintf(stderr, \"failed WC wr_id %lld status %d/%s\\n\",\n\t\t\t\t(unsigned long long) wc.wr_id,\n\t\t\t\twc.status, ibv_wc_status_str(wc.status));\n\t\t\tcontinue;\n\t\t}\n\n\t\tpkth.len = wc.byte_len;\n\t\tpkth.caplen = min(pkth.len, (u_int)handle->snapshot);\n\t\tgettimeofday(&pkth.ts, NULL);\n\n\t\tpktd = (u_char *) handle->buffer + wc.wr_id * RDMASNIFF_RECEIVE_SIZE;\n\n\t\tif (handle->fcode.bf_insns == NULL ||\n\t\t    pcap_filter(handle->fcode.bf_insns, pktd, pkth.len, pkth.caplen)) {\n\t\t\tcallback(user, &pkth, pktd);\n\t\t\t++priv->packets_recv;\n\t\t\t++count;\n\t\t}\n\n\t\trdmasniff_post_recv(handle, wc.wr_id);\n\n\t\tif (handle->break_loop) {\n\t\t\thandle->break_loop = 0;\n\t\t\treturn PCAP_ERROR_BREAK;\n\t\t}\n\t}\n\n\treturn count;\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              173,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rdmasniff_read",
            "parameters": {
              "handle": "pcap_t",
              "max_packets": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nrdmasniff_oneshot(u_char *user, const struct pcap_pkthdr *h, const u_char *bytes)\n{\n\tstruct oneshot_userdata *sp = (struct oneshot_userdata *) user;\n\tpcap_t *handle = sp->pd;\n\tstruct pcap_rdmasniff *priv = handle->priv;\n\n\t*sp->hdr = *h;\n\tmemcpy(priv->oneshot_buffer, bytes, h->caplen);\n\t*sp->pkt = priv->oneshot_buffer;\n}",
          "fn_code_pos": [
            [
              175,
              0
            ],
            [
              185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rdmasniff_oneshot",
            "parameters": {
              "user": "u_char",
              "h": "struct pcap_pkthdr",
              "bytes": "u_char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nrdmasniff_activate(pcap_t *handle)\n{\n\tstruct pcap_rdmasniff *priv = handle->priv;\n\tstruct ibv_qp_init_attr qp_init_attr;\n\tstruct ibv_qp_attr qp_attr;\n\tstruct ibv_flow_attr flow_attr;\n\tstruct ibv_port_attr port_attr;\n\tint i;\n\n\tpriv->context = ibv_open_device(priv->rdma_device);\n\tif (!priv->context) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to open device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tpriv->pd = ibv_alloc_pd(priv->context);\n\tif (!priv->pd) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to alloc PD for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tpriv->channel = ibv_create_comp_channel(priv->context);\n\tif (!priv->channel) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to create comp channel for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tpriv->cq = ibv_create_cq(priv->context, RDMASNIFF_NUM_RECEIVES,\n\t\t\t\t NULL, priv->channel, 0);\n\tif (!priv->cq) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to create CQ for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tibv_req_notify_cq(priv->cq, 0);\n\n\tmemset(&qp_init_attr, 0, sizeof qp_init_attr);\n\tqp_init_attr.send_cq = qp_init_attr.recv_cq = priv->cq;\n\tqp_init_attr.cap.max_recv_wr = RDMASNIFF_NUM_RECEIVES;\n\tqp_init_attr.cap.max_recv_sge = 1;\n\tqp_init_attr.qp_type = IBV_QPT_RAW_PACKET;\n\tpriv->qp = ibv_create_qp(priv->pd, &qp_init_attr);\n\tif (!priv->qp) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to create QP for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tmemset(&qp_attr, 0, sizeof qp_attr);\n\tqp_attr.qp_state = IBV_QPS_INIT;\n\tqp_attr.port_num = priv->port_num;\n\tif (ibv_modify_qp(priv->qp, &qp_attr, IBV_QP_STATE | IBV_QP_PORT)) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to modify QP to INIT for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tmemset(&qp_attr, 0, sizeof qp_attr);\n\tqp_attr.qp_state = IBV_QPS_RTR;\n\tif (ibv_modify_qp(priv->qp, &qp_attr, IBV_QP_STATE)) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to modify QP to RTR for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tmemset(&flow_attr, 0, sizeof flow_attr);\n\tflow_attr.type = IBV_FLOW_ATTR_SNIFFER;\n\tflow_attr.size = sizeof flow_attr;\n\tflow_attr.port = priv->port_num;\n\tpriv->flow = ibv_create_flow(priv->qp, &flow_attr);\n\tif (!priv->flow) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to create flow for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\thandle->bufsize = RDMASNIFF_NUM_RECEIVES * RDMASNIFF_RECEIVE_SIZE;\n\thandle->buffer = malloc(handle->bufsize);\n\tif (!handle->buffer) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to allocate receive buffer for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tpriv->oneshot_buffer = malloc(RDMASNIFF_RECEIVE_SIZE);\n\tif (!priv->oneshot_buffer) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to allocate oneshot buffer for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\tpriv->mr = ibv_reg_mr(priv->pd, handle->buffer, handle->bufsize, IBV_ACCESS_LOCAL_WRITE);\n\tif (!priv->mr) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t      \"Failed to register MR for device %s\", handle->opt.device);\n\t\tgoto error;\n\t}\n\n\n\tfor (i = 0; i < RDMASNIFF_NUM_RECEIVES; ++i) {\n\t\trdmasniff_post_recv(handle, i);\n\t}\n\n\tif (!ibv_query_port(priv->context, priv->port_num, &port_attr) &&\n\t    port_attr.link_layer == IBV_LINK_LAYER_INFINIBAND) {\n\t\thandle->linktype = DLT_INFINIBAND;\n\t} else {\n\t\thandle->linktype = DLT_EN10MB;\n\t}\n\n\tif (handle->snapshot <= 0 || handle->snapshot > RDMASNIFF_RECEIVE_SIZE)\n\t\thandle->snapshot = RDMASNIFF_RECEIVE_SIZE;\n\n\thandle->offset = 0;\n\thandle->read_op = rdmasniff_read;\n\thandle->stats_op = rdmasniff_stats;\n\thandle->cleanup_op = rdmasniff_cleanup;\n\thandle->setfilter_op = install_bpf_program;\n\thandle->setdirection_op = NULL;\n\thandle->set_datalink_op = NULL;\n\thandle->getnonblock_op = pcap_getnonblock_fd;\n\thandle->setnonblock_op = pcap_setnonblock_fd;\n\thandle->oneshot_callback = rdmasniff_oneshot;\n\thandle->selectable_fd = priv->channel->fd;\n\n\treturn 0;\n\nerror:\n\tif (priv->mr) {\n\t\tibv_dereg_mr(priv->mr);\n\t}\n\n\tif (priv->flow) {\n\t\tibv_destroy_flow(priv->flow);\n\t}\n\n\tif (priv->qp) {\n\t\tibv_destroy_qp(priv->qp);\n\t}\n\n\tif (priv->cq) {\n\t\tibv_destroy_cq(priv->cq);\n\t}\n\n\tif (priv->channel) {\n\t\tibv_destroy_comp_channel(priv->channel);\n\t}\n\n\tif (priv->pd) {\n\t\tibv_dealloc_pd(priv->pd);\n\t}\n\n\tif (priv->context) {\n\t\tibv_close_device(priv->context);\n\t}\n\n\tif (priv->oneshot_buffer) {\n\t\tfree(priv->oneshot_buffer);\n\t}\n\n\treturn PCAP_ERROR;\n}",
          "fn_code_pos": [
            [
              187,
              0
            ],
            [
              353,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rdmasniff_activate",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\nrdmasniff_create(const char *device, char *ebuf, int *is_ours)\n{\n\tstruct pcap_rdmasniff *priv;\n\tstruct ibv_device **dev_list;\n\tint numdev;\n\tsize_t namelen;\n\tconst char *port;\n\tunsigned long port_num;\n\tint i;\n\tpcap_t *p = NULL;\n\n\t*is_ours = 0;\n\n\tdev_list = ibv_get_device_list(&numdev);\n\tif (!dev_list || !numdev) {\n\t\treturn NULL;\n\t}\n\n\tnamelen = strlen(device);\n\n\tport = strchr(device, ':');\n\tif (port) {\n\t\tport_num = strtoul(port + 1, NULL, 10);\n\t\tif (port_num > 0) {\n\t\t\tnamelen = port - device;\n\t\t} else {\n\t\t\tport_num = 1;\n\t\t}\n\t} else {\n\t\tport_num = 1;\n\t}\n\n\tfor (i = 0; i < numdev; ++i) {\n\t\tif (strlen(dev_list[i]->name) == namelen &&\n\t\t    !strncmp(device, dev_list[i]->name, namelen)) {\n\t\t\t*is_ours = 1;\n\n\t\t\tp = pcap_create_common(ebuf, sizeof (struct pcap_rdmasniff));\n\t\t\tif (p) {\n\t\t\t\tp->activate_op = rdmasniff_activate;\n\t\t\t\tpriv = p->priv;\n\t\t\t\tpriv->rdma_device = dev_list[i];\n\t\t\t\tpriv->port_num = port_num;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tibv_free_device_list(dev_list);\n\treturn p;\n}",
          "fn_code_pos": [
            [
              355,
              0
            ],
            [
              406,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rdmasniff_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "int\nrdmasniff_findalldevs(pcap_if_list_t *devlistp, char *err_str)\n{\n\tstruct ibv_device **dev_list;\n\tint numdev;\n\tint i;\n\tint ret = 0;\n\n\tdev_list = ibv_get_device_list(&numdev);\n\tif (!dev_list || !numdev) {\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < numdev; ++i) {\n\t\t/*\n\t\t * XXX - do the notions of \"up\", \"running\", or\n\t\t * \"connected\" apply here?\n\t\t */\n\t\tif (!add_dev(devlistp, dev_list[i]->name, 0, \"RDMA sniffer\", err_str)) {\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tibv_free_device_list(dev_list);\n\treturn ret;\n}",
          "fn_code_pos": [
            [
              408,
              0
            ],
            [
              435,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rdmasniff_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "err_str": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "rdmasniff_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              356,
              0
            ],
            [
              356,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rdmasniff_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_rdmasniff {\n\tstruct ibv_device *\t\trdma_device;\n\tstruct ibv_context *\t\tcontext;\n\tstruct ibv_comp_channel *\tchannel;\n\tstruct ibv_pd *\t\t\tpd;\n\tstruct ibv_cq *\t\t\tcq;\n\tstruct ibv_qp *\t\t\tqp;\n\tstruct ibv_flow *               flow;\n\tstruct ibv_mr *\t\t\tmr;\n\tu_char *\t\t\toneshot_buffer;\n\tunsigned long\t\t\tport_num;\n\tint                             cq_event;\n\tu_int                           packets_recv;\n}",
          {
            "*\t\trdma_device": "struct ibv_device",
            "*\t\tcontext": "struct ibv_context",
            "*\tchannel": "struct ibv_comp_channel",
            "*\t\t\tpd": "struct ibv_pd",
            "*\t\t\tcq": "struct ibv_cq",
            "*\t\t\tqp": "struct ibv_qp",
            "*               flow": "struct ibv_flow",
            "*\t\t\tmr": "struct ibv_mr",
            "*\t\t\toneshot_buffer": "u_char",
            "port_num": "unsigned long",
            "cq_event": "int",
            "packets_recv": "u_int"
          },
          "pcap_rdmasniff",
          [
            49,
            0
          ],
          [
            62,
            1
          ]
        ],
        [
          "struct pcap_rdmasniff {\n\tstruct ibv_device *\t\trdma_device;\n\tstruct ibv_context *\t\tcontext;\n\tstruct ibv_comp_channel *\tchannel;\n\tstruct ibv_pd *\t\t\tpd;\n\tstruct ibv_cq *\t\t\tcq;\n\tstruct ibv_qp *\t\t\tqp;\n\tstruct ibv_flow *               flow;\n\tstruct ibv_mr *\t\t\tmr;\n\tu_char *\t\t\toneshot_buffer;\n\tunsigned long\t\t\tport_num;\n\tint                             cq_event;\n\tu_int                           packets_recv;\n}",
          {
            "*\t\trdma_device": "struct ibv_device",
            "*\t\tcontext": "struct ibv_context",
            "*\tchannel": "struct ibv_comp_channel",
            "*\t\t\tpd": "struct ibv_pd",
            "*\t\t\tcq": "struct ibv_cq",
            "*\t\t\tqp": "struct ibv_qp",
            "*               flow": "struct ibv_flow",
            "*\t\t\tmr": "struct ibv_mr",
            "*\t\t\toneshot_buffer": "u_char",
            "port_num": "unsigned long",
            "cq_event": "int",
            "packets_recv": "u_int"
          },
          "pcap_rdmasniff",
          [
            49,
            0
          ],
          [
            62,
            1
          ]
        ],
        [
          "struct ibv_device",
          {},
          "",
          [
            50,
            1
          ],
          [
            50,
            18
          ]
        ],
        [
          "struct ibv_context",
          {},
          "",
          [
            51,
            1
          ],
          [
            51,
            19
          ]
        ],
        [
          "struct ibv_comp_channel",
          {},
          "",
          [
            52,
            1
          ],
          [
            52,
            24
          ]
        ],
        [
          "struct ibv_pd",
          {},
          "",
          [
            53,
            1
          ],
          [
            53,
            14
          ]
        ],
        [
          "struct ibv_cq",
          {},
          "",
          [
            54,
            1
          ],
          [
            54,
            14
          ]
        ],
        [
          "struct ibv_qp",
          {},
          "",
          [
            55,
            1
          ],
          [
            55,
            14
          ]
        ],
        [
          "struct ibv_flow",
          {},
          "",
          [
            56,
            1
          ],
          [
            56,
            16
          ]
        ],
        [
          "struct ibv_mr",
          {},
          "",
          [
            57,
            1
          ],
          [
            57,
            14
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            65,
            32
          ],
          [
            65,
            48
          ]
        ],
        [
          "struct pcap_rdmasniff",
          {},
          "",
          [
            67,
            1
          ],
          [
            67,
            22
          ]
        ],
        [
          "struct pcap_rdmasniff",
          {},
          "",
          [
            79,
            1
          ],
          [
            79,
            22
          ]
        ],
        [
          "struct pcap_rdmasniff",
          {},
          "",
          [
            96,
            1
          ],
          [
            96,
            22
          ]
        ],
        [
          "struct ibv_sge",
          {},
          "",
          [
            97,
            1
          ],
          [
            97,
            15
          ]
        ],
        [
          "struct ibv_recv_wr",
          {},
          "",
          [
            98,
            1
          ],
          [
            98,
            19
          ]
        ],
        [
          "struct pcap_rdmasniff",
          {},
          "",
          [
            115,
            1
          ],
          [
            115,
            22
          ]
        ],
        [
          "struct ibv_cq",
          {},
          "",
          [
            116,
            1
          ],
          [
            116,
            14
          ]
        ],
        [
          "struct ibv_wc",
          {},
          "",
          [
            118,
            1
          ],
          [
            118,
            14
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            119,
            1
          ],
          [
            119,
            19
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            176,
            38
          ],
          [
            176,
            56
          ]
        ],
        [
          "struct oneshot_userdata",
          {},
          "",
          [
            178,
            1
          ],
          [
            178,
            24
          ]
        ],
        [
          "struct oneshot_userdata",
          {},
          "",
          [
            178,
            32
          ],
          [
            178,
            55
          ]
        ],
        [
          "struct pcap_rdmasniff",
          {},
          "",
          [
            180,
            1
          ],
          [
            180,
            22
          ]
        ],
        [
          "struct pcap_rdmasniff",
          {},
          "",
          [
            190,
            1
          ],
          [
            190,
            22
          ]
        ],
        [
          "struct ibv_qp_init_attr",
          {},
          "",
          [
            191,
            1
          ],
          [
            191,
            24
          ]
        ],
        [
          "struct ibv_qp_attr",
          {},
          "",
          [
            192,
            1
          ],
          [
            192,
            19
          ]
        ],
        [
          "struct ibv_flow_attr",
          {},
          "",
          [
            193,
            1
          ],
          [
            193,
            21
          ]
        ],
        [
          "struct ibv_port_attr",
          {},
          "",
          [
            194,
            1
          ],
          [
            194,
            21
          ]
        ],
        [
          "struct pcap_rdmasniff",
          {},
          "",
          [
            358,
            1
          ],
          [
            358,
            22
          ]
        ],
        [
          "struct ibv_device",
          {},
          "",
          [
            359,
            1
          ],
          [
            359,
            18
          ]
        ],
        [
          "struct pcap_rdmasniff",
          {},
          "",
          [
            393,
            40
          ],
          [
            393,
            61
          ]
        ],
        [
          "struct ibv_device",
          {},
          "",
          [
            411,
            1
          ],
          [
            411,
            18
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"config.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include \"pcap-rdmasniff.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <infiniband/verbs.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/bpf_dump.c": {
      "fn_def_list": [
        {
          "fn_code": "void\nbpf_dump(const struct bpf_program *p, int option)\n{\n\tconst struct bpf_insn *insn;\n\tint i;\n\tint n = p->bf_len;\n\n\tinsn = p->bf_insns;\n\tif (option > 2) {\n\t\tprintf(\"%d\\n\", n);\n\t\tfor (i = 0; i < n; ++insn, ++i) {\n\t\t\tprintf(\"%u %u %u %u\\n\", insn->code,\n\t\t\t       insn->jt, insn->jf, insn->k);\n\t\t}\n\t\treturn ;\n\t}\n\tif (option > 1) {\n\t\tfor (i = 0; i < n; ++insn, ++i)\n\t\t\tprintf(\"{ 0x%x, %d, %d, 0x%08x },\\n\",\n\t\t\t       insn->code, insn->jt, insn->jf, insn->k);\n\t\treturn;\n\t}\n\tfor (i = 0; i < n; ++insn, ++i) {\n#ifdef BDEBUG\n\t\tif (i < NBIDS && bids[i] > 0)\n\t\t\tprintf(\"[%02d]\", bids[i] - 1);\n\t\telse\n\t\t\tprintf(\" -- \");\n#endif\n\t\tputs(bpf_image(insn, i));\n\t}\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              61,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_dump",
            "parameters": {
              "p": "struct bpf_program",
              "option": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct bpf_program",
          {},
          "",
          [
            31,
            15
          ],
          [
            31,
            33
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            33,
            7
          ],
          [
            33,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <pcap.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"optimize.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/gencode.c": {
      "fn_def_list": [
        {
          "fn_code": "void\nbpf_set_error(compiler_state_t *cstate, const char *fmt, ...)\n{\n\tva_list ap;\n\n\t/*\n\t * If we've already set an error, don't override it.\n\t * The lexical analyzer reports some errors by setting\n\t * the error and then returning a LEX_ERROR token, which\n\t * is not recognized by any grammar rule, and thus forces\n\t * the parse to stop.  We don't want the error reported\n\t * by the lexical analyzer to be overwritten by the syntax\n\t * error.\n\t */\n\tif (!cstate->error_set) {\n\t\tva_start(ap, fmt);\n\t\t(void)pcap_vsnprintf(cstate->bpf_pcap->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    fmt, ap);\n\t\tva_end(ap);\n\t\tcstate->error_set = 1;\n\t}\n}",
          "fn_code_pos": [
            [
              433,
              0
            ],
            [
              454,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_set_error",
            "parameters": {
              "cstate": "compiler_state_t",
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void PCAP_NORETURN\nbpf_error(compiler_state_t *cstate, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\t(void)pcap_vsnprintf(cstate->bpf_pcap->errbuf, PCAP_ERRBUF_SIZE,\n\t    fmt, ap);\n\tva_end(ap);\n\tlongjmp(cstate->top_ctx, 1);\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              463,
              0
            ],
            [
              474,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN\nbpf_error",
            "parameters": {
              "cstate": "compiler_state_t",
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ninitchunks(compiler_state_t *cstate)\n{\n\tint i;\n\n\tfor (i = 0; i < NCHUNKS; i++) {\n\t\tcstate->chunks[i].n_left = 0;\n\t\tcstate->chunks[i].m = NULL;\n\t}\n\tcstate->cur_chunk = 0;\n}",
          "fn_code_pos": [
            [
              588,
              0
            ],
            [
              598,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initchunks",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void *\nnewchunk_nolongjmp(compiler_state_t *cstate, size_t n)\n{\n\tstruct chunk *cp;\n\tint k;\n\tsize_t size;\n\n#ifndef __NetBSD__\n\t/* XXX Round up to nearest long. */\n\tn = (n + sizeof(long) - 1) & ~(sizeof(long) - 1);\n#else\n\t/* XXX Round up to structure boundary. */\n\tn = ALIGN(n);\n#endif\n\n\tcp = &cstate->chunks[cstate->cur_chunk];\n\tif (n > cp->n_left) {\n\t\t++cp;\n\t\tk = ++cstate->cur_chunk;\n\t\tif (k >= NCHUNKS) {\n\t\t\tbpf_set_error(cstate, \"out of memory\");\n\t\t\treturn (NULL);\n\t\t}\n\t\tsize = CHUNK0SIZE << k;\n\t\tcp->m = (void *)malloc(size);\n\t\tif (cp->m == NULL) {\n\t\t\tbpf_set_error(cstate, \"out of memory\");\n\t\t\treturn (NULL);\n\t\t}\n\t\tmemset((char *)cp->m, 0, size);\n\t\tcp->n_left = size;\n\t\tif (n > size) {\n\t\t\tbpf_set_error(cstate, \"out of memory\");\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tcp->n_left -= n;\n\treturn (void *)((char *)cp->m + cp->n_left);\n}",
          "fn_code_pos": [
            [
              600,
              0
            ],
            [
              638,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "newchunk_nolongjmp",
            "parameters": {
              "cstate": "compiler_state_t",
              "n": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void *\nnewchunk(compiler_state_t *cstate, size_t n)\n{\n\tvoid *p;\n\n\tp = newchunk_nolongjmp(cstate, n);\n\tif (p == NULL) {\n\t\tlongjmp(cstate->top_ctx, 1);\n\t\t/*NOTREACHED*/\n\t}\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              640,
              0
            ],
            [
              651,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "newchunk",
            "parameters": {
              "cstate": "compiler_state_t",
              "n": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nfreechunks(compiler_state_t *cstate)\n{\n\tint i;\n\n\tfor (i = 0; i < NCHUNKS; ++i)\n\t\tif (cstate->chunks[i].m != NULL)\n\t\t\tfree(cstate->chunks[i].m);\n}",
          "fn_code_pos": [
            [
              653,
              0
            ],
            [
              661,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "freechunks",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "char *\nsdup(compiler_state_t *cstate, const char *s)\n{\n\tsize_t n = strlen(s) + 1;\n\tchar *cp = newchunk_nolongjmp(cstate, n);\n\n\tif (cp == NULL)\n\t\treturn (NULL);\n\tpcap_strlcpy(cp, s, n);\n\treturn (cp);\n}",
          "fn_code_pos": [
            [
              669,
              0
            ],
            [
              679,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sdup",
            "parameters": {
              "cstate": "compiler_state_t",
              "s": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static inline struct block *\nnew_block(compiler_state_t *cstate, int code)\n{\n\tstruct block *p;\n\n\tp = (struct block *)newchunk(cstate, sizeof(*p));\n\tp->s.code = code;\n\tp->head = p;\n\n\treturn p;\n}",
          "fn_code_pos": [
            [
              681,
              0
            ],
            [
              691,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "new_block",
            "parameters": {
              "cstate": "compiler_state_t",
              "code": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static inline struct slist *\nnew_stmt(compiler_state_t *cstate, int code)\n{\n\tstruct slist *p;\n\n\tp = (struct slist *)newchunk(cstate, sizeof(*p));\n\tp->s.code = code;\n\n\treturn p;\n}",
          "fn_code_pos": [
            [
              693,
              0
            ],
            [
              702,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "new_stmt",
            "parameters": {
              "cstate": "compiler_state_t",
              "code": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_retblk(compiler_state_t *cstate, int v)\n{\n\tstruct block *b = new_block(cstate, BPF_RET|BPF_K);\n\n\tb->s.k = v;\n\treturn b;\n}",
          "fn_code_pos": [
            [
              704,
              0
            ],
            [
              711,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_retblk",
            "parameters": {
              "cstate": "compiler_state_t",
              "v": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static inline PCAP_NORETURN_DEF void\nsyntax(compiler_state_t *cstate)\n{\n\tbpf_error(cstate, \"syntax error in filter expression\");\n}",
          "fn_code_pos": [
            [
              713,
              0
            ],
            [
              717,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "syntax",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": "PCAP_NORETURN_DEF"
          }
        },
        {
          "fn_code": "int\npcap_compile(pcap_t *p, struct bpf_program *program,\n\t     const char *buf, int optimize, bpf_u_int32 mask)\n{\n#ifdef _WIN32\n\tstatic int done = 0;\n#endif\n\tcompiler_state_t cstate;\n\tconst char * volatile xbuf = buf;\n\tyyscan_t scanner = NULL;\n\tvolatile YY_BUFFER_STATE in_buffer = NULL;\n\tu_int len;\n\tint  rc;\n\n\t/*\n\t * If this pcap_t hasn't been activated, it doesn't have a\n\t * link-layer type, so we can't use it.\n\t */\n\tif (!p->activated) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"not-yet-activated pcap_t passed to pcap_compile\");\n\t\treturn (-1);\n\t}\n\n#ifdef _WIN32\n\tif (!done)\n\t\tpcap_wsockinit();\n\tdone = 1;\n#endif\n\n#ifdef ENABLE_REMOTE\n\t/*\n\t * If the device on which we're capturing need to be notified\n\t * that a new filter is being compiled, do so.\n\t *\n\t * This allows them to save a copy of it, in case, for example,\n\t * they're implementing a form of remote packet capture, and\n\t * want the remote machine to filter out the packets in which\n\t * it's sending the packets it's captured.\n\t *\n\t * XXX - the fact that we happen to be compiling a filter\n\t * doesn't necessarily mean we'll be installing it as the\n\t * filter for this pcap_t; we might be running it from userland\n\t * on captured packets to do packet classification.  We really\n\t * need a better way of handling this, but this is all that\n\t * the WinPcap code did.\n\t */\n\tif (p->save_current_filter_op != NULL)\n\t\t(p->save_current_filter_op)(p, buf);\n#endif\n\n\tinitchunks(&cstate);\n\tcstate.no_optimize = 0;\n#ifdef INET6\n\tcstate.ai = NULL;\n#endif\n\tcstate.e = NULL;\n\tcstate.ic.root = NULL;\n\tcstate.ic.cur_mark = 0;\n\tcstate.bpf_pcap = p;\n\tcstate.error_set = 0;\n\tinit_regs(&cstate);\n\n\tcstate.netmask = mask;\n\n\tcstate.snaplen = pcap_snapshot(p);\n\tif (cstate.snaplen == 0) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t \"snaplen of 0 rejects all packets\");\n\t\trc = -1;\n\t\tgoto quit;\n\t}\n\n\tif (pcap_lex_init(&scanner) != 0)\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"can't initialize scanner\");\n\tin_buffer = pcap__scan_string(xbuf ? xbuf : \"\", scanner);\n\n\t/*\n\t * Associate the compiler state with the lexical analyzer\n\t * state.\n\t */\n\tpcap_set_extra(&cstate, scanner);\n\n\tif (init_linktype(&cstate, p) == -1) {\n\t\trc = -1;\n\t\tgoto quit;\n\t}\n\tif (pcap_parse(scanner, &cstate) != 0) {\n#ifdef INET6\n\t\tif (cstate.ai != NULL)\n\t\t\tfreeaddrinfo(cstate.ai);\n#endif\n\t\tif (cstate.e != NULL)\n\t\t\tfree(cstate.e);\n\t\trc = -1;\n\t\tgoto quit;\n\t}\n\n\tif (cstate.ic.root == NULL) {\n\t\t/*\n\t\t * Catch errors reported by gen_retblk().\n\t\t */\n\t\tif (setjmp(cstate.top_ctx)) {\n\t\t\trc = -1;\n\t\t\tgoto quit;\n\t\t}\n\t\tcstate.ic.root = gen_retblk(&cstate, cstate.snaplen);\n\t}\n\n\tif (optimize && !cstate.no_optimize) {\n\t\tif (bpf_optimize(&cstate.ic, p->errbuf) == -1) {\n\t\t\t/* Failure */\n\t\t\trc = -1;\n\t\t\tgoto quit;\n\t\t}\n\t\tif (cstate.ic.root == NULL ||\n\t\t    (cstate.ic.root->s.code == (BPF_RET|BPF_K) && cstate.ic.root->s.k == 0)) {\n\t\t\t(void)pcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"expression rejects all packets\");\n\t\t\trc = -1;\n\t\t\tgoto quit;\n\t\t}\n\t}\n\tprogram->bf_insns = icode_to_fcode(&cstate.ic,\n\t    cstate.ic.root, &len, p->errbuf);\n\tif (program->bf_insns == NULL) {\n\t\t/* Failure */\n\t\trc = -1;\n\t\tgoto quit;\n\t}\n\tprogram->bf_len = len;\n\n\trc = 0;  /* We're all okay */\n\nquit:\n\t/*\n\t * Clean up everything for the lexical analyzer.\n\t */\n\tif (in_buffer != NULL)\n\t\tpcap__delete_buffer(in_buffer, scanner);\n\tif (scanner != NULL)\n\t\tpcap_lex_destroy(scanner);\n\n\t/*\n\t * Clean up our own allocated memory.\n\t */\n\tfreechunks(&cstate);\n\n\treturn (rc);\n}",
          "fn_code_pos": [
            [
              719,
              0
            ],
            [
              869,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_compile",
            "parameters": {
              "p": "pcap_t",
              "program": "struct bpf_program",
              "buf": "char",
              "optimize": "int",
              "mask": "bpf_u_int32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_compile_nopcap(int snaplen_arg, int linktype_arg,\n\t\t    struct bpf_program *program,\n\t     const char *buf, int optimize, bpf_u_int32 mask)\n{\n\tpcap_t *p;\n\tint ret;\n\n\tp = pcap_open_dead(linktype_arg, snaplen_arg);\n\tif (p == NULL)\n\t\treturn (-1);\n\tret = pcap_compile(p, program, buf, optimize, mask);\n\tpcap_close(p);\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              875,
              0
            ],
            [
              889,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_compile_nopcap",
            "parameters": {
              "snaplen_arg": "int",
              "linktype_arg": "int",
              "program": "struct bpf_program",
              "buf": "char",
              "optimize": "int",
              "mask": "bpf_u_int32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\npcap_freecode(struct bpf_program *program)\n{\n\tprogram->bf_len = 0;\n\tif (program->bf_insns != NULL) {\n\t\tfree((char *)program->bf_insns);\n\t\tprogram->bf_insns = NULL;\n\t}\n}",
          "fn_code_pos": [
            [
              895,
              0
            ],
            [
              903,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_freecode",
            "parameters": {
              "program": "struct bpf_program"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nbackpatch(struct block *list, struct block *target)\n{\n\tstruct block *next;\n\n\twhile (list) {\n\t\tif (!list->sense) {\n\t\t\tnext = JT(list);\n\t\t\tJT(list) = target;\n\t\t} else {\n\t\t\tnext = JF(list);\n\t\t\tJF(list) = target;\n\t\t}\n\t\tlist = next;\n\t}\n}",
          "fn_code_pos": [
            [
              911,
              0
            ],
            [
              926,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "backpatch",
            "parameters": {
              "list": "struct block",
              "target": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nmerge(struct block *b0, struct block *b1)\n{\n\tregister struct block **p = &b0;\n\n\t/* Find end of list. */\n\twhile (*p)\n\t\tp = !((*p)->sense) ? &JT(*p) : &JF(*p);\n\n\t/* Concatenate the lists. */\n\t*p = b1;\n}",
          "fn_code_pos": [
            [
              932,
              0
            ],
            [
              943,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "merge",
            "parameters": {
              "b0": "struct block",
              "b1": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\nfinish_parse(compiler_state_t *cstate, struct block *p)\n{\n\tstruct block *ppi_dlt_check;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return -1\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (-1);\n\n\t/*\n\t * Insert before the statements of the first (root) block any\n\t * statements needed to load the lengths of any variable-length\n\t * headers into registers.\n\t *\n\t * XXX - a fancier strategy would be to insert those before the\n\t * statements of all blocks that use those lengths and that\n\t * have no predecessors that use them, so that we only compute\n\t * the lengths if we need them.  There might be even better\n\t * approaches than that.\n\t *\n\t * However, those strategies would be more complicated, and\n\t * as we don't generate code to compute a length if the\n\t * program has no tests that use the length, and as most\n\t * tests will probably use those lengths, we would just\n\t * postpone computing the lengths so that it's not done\n\t * for tests that fail early, and it's not clear that's\n\t * worth the effort.\n\t */\n\tinsert_compute_vloffsets(cstate, p->head);\n\n\t/*\n\t * For DLT_PPI captures, generate a check of the per-packet\n\t * DLT value to make sure it's DLT_IEEE802_11.\n\t *\n\t * XXX - TurboCap cards use DLT_PPI for Ethernet.\n\t * Can we just define some DLT_ETHERNET_WITH_PHDR pseudo-header\n\t * with appropriate Ethernet information and use that rather\n\t * than using something such as DLT_PPI where you don't know\n\t * the link-layer header type until runtime, which, in the\n\t * general case, would force us to generate both Ethernet *and*\n\t * 802.11 code (*and* anything else for which PPI is used)\n\t * and choose between them early in the BPF program?\n\t */\n\tppi_dlt_check = gen_ppi_dlt_check(cstate);\n\tif (ppi_dlt_check != NULL)\n\t\tgen_and(ppi_dlt_check, p);\n\n\tbackpatch(p, gen_retblk(cstate, cstate->snaplen));\n\tp->sense = !p->sense;\n\tbackpatch(p, gen_retblk(cstate, 0));\n\tcstate->ic.root = p->head;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              945,
              0
            ],
            [
              1000,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "finish_parse",
            "parameters": {
              "cstate": "compiler_state_t",
              "p": "struct block"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\ngen_and(struct block *b0, struct block *b1)\n{\n\tbackpatch(b0, b1->head);\n\tb0->sense = !b0->sense;\n\tb1->sense = !b1->sense;\n\tmerge(b1, b0);\n\tb1->sense = !b1->sense;\n\tb1->head = b0->head;\n}",
          "fn_code_pos": [
            [
              1002,
              0
            ],
            [
              1011,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_and",
            "parameters": {
              "b0": "struct block",
              "b1": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\ngen_or(struct block *b0, struct block *b1)\n{\n\tb0->sense = !b0->sense;\n\tbackpatch(b0, b1->head);\n\tb0->sense = !b0->sense;\n\tmerge(b1, b0);\n\tb1->head = b0->head;\n}",
          "fn_code_pos": [
            [
              1013,
              0
            ],
            [
              1021,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_or",
            "parameters": {
              "b0": "struct block",
              "b1": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\ngen_not(struct block *b)\n{\n\tb->sense = !b->sense;\n}",
          "fn_code_pos": [
            [
              1023,
              0
            ],
            [
              1027,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_not",
            "parameters": {
              "b": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static struct block *\ngen_cmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v)\n{\n\treturn gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JEQ, 0, v);\n}",
          "fn_code_pos": [
            [
              1029,
              0
            ],
            [
              1034,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_cmp",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int",
              "v": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_cmp_gt(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v)\n{\n\treturn gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JGT, 0, v);\n}",
          "fn_code_pos": [
            [
              1036,
              0
            ],
            [
              1041,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_cmp_gt",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int",
              "v": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_cmp_ge(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v)\n{\n\treturn gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JGE, 0, v);\n}",
          "fn_code_pos": [
            [
              1043,
              0
            ],
            [
              1048,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_cmp_ge",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int",
              "v": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_cmp_lt(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v)\n{\n\treturn gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JGE, 1, v);\n}",
          "fn_code_pos": [
            [
              1050,
              0
            ],
            [
              1055,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_cmp_lt",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int",
              "v": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_cmp_le(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v)\n{\n\treturn gen_ncmp(cstate, offrel, offset, size, 0xffffffff, BPF_JGT, 1, v);\n}",
          "fn_code_pos": [
            [
              1057,
              0
            ],
            [
              1062,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_cmp_le",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int",
              "v": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_mcmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v, bpf_u_int32 mask)\n{\n\treturn gen_ncmp(cstate, offrel, offset, size, mask, BPF_JEQ, 0, v);\n}",
          "fn_code_pos": [
            [
              1064,
              0
            ],
            [
              1069,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mcmp",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int",
              "v": "bpf_u_int32",
              "mask": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_bcmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, const u_char *v)\n{\n\tregister struct block *b, *tmp;\n\n\tb = NULL;\n\twhile (size >= 4) {\n\t\tregister const u_char *p = &v[size - 4];\n\n\t\ttmp = gen_cmp(cstate, offrel, offset + size - 4, BPF_W,\n\t\t    EXTRACT_BE_U_4(p));\n\t\tif (b != NULL)\n\t\t\tgen_and(b, tmp);\n\t\tb = tmp;\n\t\tsize -= 4;\n\t}\n\twhile (size >= 2) {\n\t\tregister const u_char *p = &v[size - 2];\n\n\t\ttmp = gen_cmp(cstate, offrel, offset + size - 2, BPF_H,\n\t\t    EXTRACT_BE_U_2(p));\n\t\tif (b != NULL)\n\t\t\tgen_and(b, tmp);\n\t\tb = tmp;\n\t\tsize -= 2;\n\t}\n\tif (size > 0) {\n\t\ttmp = gen_cmp(cstate, offrel, offset, BPF_B, v[0]);\n\t\tif (b != NULL)\n\t\t\tgen_and(b, tmp);\n\t\tb = tmp;\n\t}\n\treturn b;\n}",
          "fn_code_pos": [
            [
              1071,
              0
            ],
            [
              1105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_bcmp",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int",
              "v": "u_char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_ncmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 mask, int jtype, int reverse,\n    bpf_u_int32 v)\n{\n\tstruct slist *s, *s2;\n\tstruct block *b;\n\n\ts = gen_load_a(cstate, offrel, offset, size);\n\n\tif (mask != 0xffffffff) {\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);\n\t\ts2->s.k = mask;\n\t\tsappend(s, s2);\n\t}\n\n\tb = new_block(cstate, JMP(jtype));\n\tb->stmts = s;\n\tb->s.k = v;\n\tif (reverse && (jtype == BPF_JGT || jtype == BPF_JGE))\n\t\tgen_not(b);\n\treturn b;\n}",
          "fn_code_pos": [
            [
              1113,
              0
            ],
            [
              1135,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ncmp",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int",
              "mask": "bpf_u_int32",
              "jtype": "int",
              "reverse": "int",
              "v": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static int\ninit_linktype(compiler_state_t *cstate, pcap_t *p)\n{\n\tcstate->pcap_fddipad = p->fddipad;\n\n\t/*\n\t * We start out with only one link-layer header.\n\t */\n\tcstate->outermostlinktype = pcap_datalink(p);\n\tcstate->off_outermostlinkhdr.constant_part = 0;\n\tcstate->off_outermostlinkhdr.is_variable = 0;\n\tcstate->off_outermostlinkhdr.reg = -1;\n\n\tcstate->prevlinktype = cstate->outermostlinktype;\n\tcstate->off_prevlinkhdr.constant_part = 0;\n\tcstate->off_prevlinkhdr.is_variable = 0;\n\tcstate->off_prevlinkhdr.reg = -1;\n\n\tcstate->linktype = cstate->outermostlinktype;\n\tcstate->off_linkhdr.constant_part = 0;\n\tcstate->off_linkhdr.is_variable = 0;\n\tcstate->off_linkhdr.reg = -1;\n\n\t/*\n\t * XXX\n\t */\n\tcstate->off_linkpl.constant_part = 0;\n\tcstate->off_linkpl.is_variable = 0;\n\tcstate->off_linkpl.reg = -1;\n\n\tcstate->off_linktype.constant_part = 0;\n\tcstate->off_linktype.is_variable = 0;\n\tcstate->off_linktype.reg = -1;\n\n\t/*\n\t * Assume it's not raw ATM with a pseudo-header, for now.\n\t */\n\tcstate->is_atm = 0;\n\tcstate->off_vpi = OFFSET_NOT_SET;\n\tcstate->off_vci = OFFSET_NOT_SET;\n\tcstate->off_proto = OFFSET_NOT_SET;\n\tcstate->off_payload = OFFSET_NOT_SET;\n\n\t/*\n\t * And not Geneve.\n\t */\n\tcstate->is_geneve = 0;\n\n\t/*\n\t * No variable length VLAN offset by default\n\t */\n\tcstate->is_vlan_vloffset = 0;\n\n\t/*\n\t * And assume we're not doing SS7.\n\t */\n\tcstate->off_li = OFFSET_NOT_SET;\n\tcstate->off_li_hsl = OFFSET_NOT_SET;\n\tcstate->off_sio = OFFSET_NOT_SET;\n\tcstate->off_opc = OFFSET_NOT_SET;\n\tcstate->off_dpc = OFFSET_NOT_SET;\n\tcstate->off_sls = OFFSET_NOT_SET;\n\n\tcstate->label_stack_depth = 0;\n\tcstate->vlan_stack_depth = 0;\n\n\tswitch (cstate->linktype) {\n\n\tcase DLT_ARCNET:\n\t\tcstate->off_linktype.constant_part = 2;\n\t\tcstate->off_linkpl.constant_part = 6;\n\t\tcstate->off_nl = 0;\t\t/* XXX in reality, variable! */\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_ARCNET_LINUX:\n\t\tcstate->off_linktype.constant_part = 4;\n\t\tcstate->off_linkpl.constant_part = 8;\n\t\tcstate->off_nl = 0;\t\t/* XXX in reality, variable! */\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_EN10MB:\n\t\tcstate->off_linktype.constant_part = 12;\n\t\tcstate->off_linkpl.constant_part = 14;\t/* Ethernet header length */\n\t\tcstate->off_nl = 0;\t\t/* Ethernet II */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.3+802.2 */\n\t\tbreak;\n\n\tcase DLT_SLIP:\n\t\t/*\n\t\t * SLIP doesn't have a link level type.  The 16 byte\n\t\t * header is hacked into our SLIP driver.\n\t\t */\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = 16;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_SLIP_BSDOS:\n\t\t/* XXX this may be the same as the DLT_PPP_BSDOS case */\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\t/* XXX end */\n\t\tcstate->off_linkpl.constant_part = 24;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_NULL:\n\tcase DLT_LOOP:\n\t\tcstate->off_linktype.constant_part = 0;\n\t\tcstate->off_linkpl.constant_part = 4;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_ENC:\n\t\tcstate->off_linktype.constant_part = 0;\n\t\tcstate->off_linkpl.constant_part = 12;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_PPP:\n\tcase DLT_PPP_PPPD:\n\tcase DLT_C_HDLC:\t\t/* BSD/OS Cisco HDLC */\n\tcase DLT_PPP_SERIAL:\t\t/* NetBSD sync/async serial PPP */\n\t\tcstate->off_linktype.constant_part = 2;\t/* skip HDLC-like framing */\n\t\tcstate->off_linkpl.constant_part = 4;\t/* skip HDLC-like framing and protocol field */\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_PPP_ETHER:\n\t\t/*\n\t\t * This does no include the Ethernet header, and\n\t\t * only covers session state.\n\t\t */\n\t\tcstate->off_linktype.constant_part = 6;\n\t\tcstate->off_linkpl.constant_part = 8;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_PPP_BSDOS:\n\t\tcstate->off_linktype.constant_part = 5;\n\t\tcstate->off_linkpl.constant_part = 24;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_FDDI:\n\t\t/*\n\t\t * FDDI doesn't really have a link-level type field.\n\t\t * We set \"off_linktype\" to the offset of the LLC header.\n\t\t *\n\t\t * To check for Ethernet types, we assume that SSAP = SNAP\n\t\t * is being used and pick out the encapsulated Ethernet type.\n\t\t * XXX - should we generate code to check for SNAP?\n\t\t */\n\t\tcstate->off_linktype.constant_part = 13;\n\t\tcstate->off_linktype.constant_part += cstate->pcap_fddipad;\n\t\tcstate->off_linkpl.constant_part = 13;\t/* FDDI MAC header length */\n\t\tcstate->off_linkpl.constant_part += cstate->pcap_fddipad;\n\t\tcstate->off_nl = 8;\t\t/* 802.2+SNAP */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.2 */\n\t\tbreak;\n\n\tcase DLT_IEEE802:\n\t\t/*\n\t\t * Token Ring doesn't really have a link-level type field.\n\t\t * We set \"off_linktype\" to the offset of the LLC header.\n\t\t *\n\t\t * To check for Ethernet types, we assume that SSAP = SNAP\n\t\t * is being used and pick out the encapsulated Ethernet type.\n\t\t * XXX - should we generate code to check for SNAP?\n\t\t *\n\t\t * XXX - the header is actually variable-length.\n\t\t * Some various Linux patched versions gave 38\n\t\t * as \"off_linktype\" and 40 as \"off_nl\"; however,\n\t\t * if a token ring packet has *no* routing\n\t\t * information, i.e. is not source-routed, the correct\n\t\t * values are 20 and 22, as they are in the vanilla code.\n\t\t *\n\t\t * A packet is source-routed iff the uppermost bit\n\t\t * of the first byte of the source address, at an\n\t\t * offset of 8, has the uppermost bit set.  If the\n\t\t * packet is source-routed, the total number of bytes\n\t\t * of routing information is 2 plus bits 0x1F00 of\n\t\t * the 16-bit value at an offset of 14 (shifted right\n\t\t * 8 - figure out which byte that is).\n\t\t */\n\t\tcstate->off_linktype.constant_part = 14;\n\t\tcstate->off_linkpl.constant_part = 14;\t/* Token Ring MAC header length */\n\t\tcstate->off_nl = 8;\t\t/* 802.2+SNAP */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.2 */\n\t\tbreak;\n\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_IEEE802_11_RADIO:\n\t\tcstate->off_linkhdr.is_variable = 1;\n\t\t/* Fall through, 802.11 doesn't have a variable link\n\t\t * prefix but is otherwise the same. */\n\t\t/* FALLTHROUGH */\n\n\tcase DLT_IEEE802_11:\n\t\t/*\n\t\t * 802.11 doesn't really have a link-level type field.\n\t\t * We set \"off_linktype.constant_part\" to the offset of\n\t\t * the LLC header.\n\t\t *\n\t\t * To check for Ethernet types, we assume that SSAP = SNAP\n\t\t * is being used and pick out the encapsulated Ethernet type.\n\t\t * XXX - should we generate code to check for SNAP?\n\t\t *\n\t\t * We also handle variable-length radio headers here.\n\t\t * The Prism header is in theory variable-length, but in\n\t\t * practice it's always 144 bytes long.  However, some\n\t\t * drivers on Linux use ARPHRD_IEEE80211_PRISM, but\n\t\t * sometimes or always supply an AVS header, so we\n\t\t * have to check whether the radio header is a Prism\n\t\t * header or an AVS header, so, in practice, it's\n\t\t * variable-length.\n\t\t */\n\t\tcstate->off_linktype.constant_part = 24;\n\t\tcstate->off_linkpl.constant_part = 0;\t/* link-layer header is variable-length */\n\t\tcstate->off_linkpl.is_variable = 1;\n\t\tcstate->off_nl = 8;\t\t/* 802.2+SNAP */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.2 */\n\t\tbreak;\n\n\tcase DLT_PPI:\n\t\t/*\n\t\t * At the moment we treat PPI the same way that we treat\n\t\t * normal Radiotap encoded packets. The difference is in\n\t\t * the function that generates the code at the beginning\n\t\t * to compute the header length.  Since this code generator\n\t\t * of PPI supports bare 802.11 encapsulation only (i.e.\n\t\t * the encapsulated DLT should be DLT_IEEE802_11) we\n\t\t * generate code to check for this too.\n\t\t */\n\t\tcstate->off_linktype.constant_part = 24;\n\t\tcstate->off_linkpl.constant_part = 0;\t/* link-layer header is variable-length */\n\t\tcstate->off_linkpl.is_variable = 1;\n\t\tcstate->off_linkhdr.is_variable = 1;\n\t\tcstate->off_nl = 8;\t\t/* 802.2+SNAP */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.2 */\n\t\tbreak;\n\n\tcase DLT_ATM_RFC1483:\n\tcase DLT_ATM_CLIP:\t/* Linux ATM defines this */\n\t\t/*\n\t\t * assume routed, non-ISO PDUs\n\t\t * (i.e., LLC = 0xAA-AA-03, OUT = 0x00-00-00)\n\t\t *\n\t\t * XXX - what about ISO PDUs, e.g. CLNP, ISIS, ESIS,\n\t\t * or PPP with the PPP NLPID (e.g., PPPoA)?  The\n\t\t * latter would presumably be treated the way PPPoE\n\t\t * should be, so you can do \"pppoe and udp port 2049\"\n\t\t * or \"pppoa and tcp port 80\" and have it check for\n\t\t * PPPo{A,E} and a PPP protocol of IP and....\n\t\t */\n\t\tcstate->off_linktype.constant_part = 0;\n\t\tcstate->off_linkpl.constant_part = 0;\t/* packet begins with LLC header */\n\t\tcstate->off_nl = 8;\t\t/* 802.2+SNAP */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.2 */\n\t\tbreak;\n\n\tcase DLT_SUNATM:\n\t\t/*\n\t\t * Full Frontal ATM; you get AALn PDUs with an ATM\n\t\t * pseudo-header.\n\t\t */\n\t\tcstate->is_atm = 1;\n\t\tcstate->off_vpi = SUNATM_VPI_POS;\n\t\tcstate->off_vci = SUNATM_VCI_POS;\n\t\tcstate->off_proto = PROTO_POS;\n\t\tcstate->off_payload = SUNATM_PKT_BEGIN_POS;\n\t\tcstate->off_linktype.constant_part = cstate->off_payload;\n\t\tcstate->off_linkpl.constant_part = cstate->off_payload;\t/* if LLC-encapsulated */\n\t\tcstate->off_nl = 8;\t\t/* 802.2+SNAP */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.2 */\n\t\tbreak;\n\n\tcase DLT_RAW:\n\tcase DLT_IPV4:\n\tcase DLT_IPV6:\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = 0;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_LINUX_SLL:\t/* fake header for Linux cooked socket v1 */\n\t\tcstate->off_linktype.constant_part = 14;\n\t\tcstate->off_linkpl.constant_part = 16;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_LINUX_SLL2:\t/* fake header for Linux cooked socket v2 */\n\t\tcstate->off_linktype.constant_part = 0;\n\t\tcstate->off_linkpl.constant_part = 20;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_LTALK:\n\t\t/*\n\t\t * LocalTalk does have a 1-byte type field in the LLAP header,\n\t\t * but really it just indicates whether there is a \"short\" or\n\t\t * \"long\" DDP packet following.\n\t\t */\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = 0;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_IP_OVER_FC:\n\t\t/*\n\t\t * RFC 2625 IP-over-Fibre-Channel doesn't really have a\n\t\t * link-level type field.  We set \"off_linktype\" to the\n\t\t * offset of the LLC header.\n\t\t *\n\t\t * To check for Ethernet types, we assume that SSAP = SNAP\n\t\t * is being used and pick out the encapsulated Ethernet type.\n\t\t * XXX - should we generate code to check for SNAP? RFC\n\t\t * 2625 says SNAP should be used.\n\t\t */\n\t\tcstate->off_linktype.constant_part = 16;\n\t\tcstate->off_linkpl.constant_part = 16;\n\t\tcstate->off_nl = 8;\t\t/* 802.2+SNAP */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.2 */\n\t\tbreak;\n\n\tcase DLT_FRELAY:\n\t\t/*\n\t\t * XXX - we should set this to handle SNAP-encapsulated\n\t\t * frames (NLPID of 0x80).\n\t\t */\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = 0;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n                /*\n                 * the only BPF-interesting FRF.16 frames are non-control frames;\n                 * Frame Relay has a variable length link-layer\n                 * so lets start with offset 4 for now and increments later on (FIXME);\n                 */\n\tcase DLT_MFR:\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = 0;\n\t\tcstate->off_nl = 4;\n\t\tcstate->off_nl_nosnap = 0;\t/* XXX - for now -> no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_APPLE_IP_OVER_IEEE1394:\n\t\tcstate->off_linktype.constant_part = 16;\n\t\tcstate->off_linkpl.constant_part = 18;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_SYMANTEC_FIREWALL:\n\t\tcstate->off_linktype.constant_part = 6;\n\t\tcstate->off_linkpl.constant_part = 44;\n\t\tcstate->off_nl = 0;\t\t/* Ethernet II */\n\t\tcstate->off_nl_nosnap = 0;\t/* XXX - what does it do with 802.3 packets? */\n\t\tbreak;\n\n#ifdef HAVE_NET_PFVAR_H\n\tcase DLT_PFLOG:\n\t\tcstate->off_linktype.constant_part = 0;\n\t\tcstate->off_linkpl.constant_part = PFLOG_HDRLEN;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\t\tbreak;\n#endif\n\n        case DLT_JUNIPER_MFR:\n        case DLT_JUNIPER_MLFR:\n        case DLT_JUNIPER_MLPPP:\n        case DLT_JUNIPER_PPP:\n        case DLT_JUNIPER_CHDLC:\n        case DLT_JUNIPER_FRELAY:\n\t\tcstate->off_linktype.constant_part = 4;\n\t\tcstate->off_linkpl.constant_part = 4;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\t/* no 802.2 LLC */\n                break;\n\n\tcase DLT_JUNIPER_ATM1:\n\t\tcstate->off_linktype.constant_part = 4;\t\t/* in reality variable between 4-8 */\n\t\tcstate->off_linkpl.constant_part = 4;\t/* in reality variable between 4-8 */\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 10;\n\t\tbreak;\n\n\tcase DLT_JUNIPER_ATM2:\n\t\tcstate->off_linktype.constant_part = 8;\t\t/* in reality variable between 8-12 */\n\t\tcstate->off_linkpl.constant_part = 8;\t/* in reality variable between 8-12 */\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 10;\n\t\tbreak;\n\n\t\t/* frames captured on a Juniper PPPoE service PIC\n\t\t * contain raw ethernet frames */\n\tcase DLT_JUNIPER_PPPOE:\n        case DLT_JUNIPER_ETHER:\n\t\tcstate->off_linkpl.constant_part = 14;\n\t\tcstate->off_linktype.constant_part = 16;\n\t\tcstate->off_nl = 18;\t\t/* Ethernet II */\n\t\tcstate->off_nl_nosnap = 21;\t/* 802.3+802.2 */\n\t\tbreak;\n\n\tcase DLT_JUNIPER_PPPOE_ATM:\n\t\tcstate->off_linktype.constant_part = 4;\n\t\tcstate->off_linkpl.constant_part = 6;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_JUNIPER_GGSN:\n\t\tcstate->off_linktype.constant_part = 6;\n\t\tcstate->off_linkpl.constant_part = 12;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_JUNIPER_ES:\n\t\tcstate->off_linktype.constant_part = 6;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\t/* not really a network layer but raw IP addresses */\n\t\tcstate->off_nl = OFFSET_NOT_SET;\t/* not really a network layer but raw IP addresses */\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_JUNIPER_MONITOR:\n\t\tcstate->off_linktype.constant_part = 12;\n\t\tcstate->off_linkpl.constant_part = 12;\n\t\tcstate->off_nl = 0;\t\t\t/* raw IP/IP6 header */\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_BACNET_MS_TP:\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_JUNIPER_SERVICES:\n\t\tcstate->off_linktype.constant_part = 12;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\t/* L3 proto location dep. on cookie type */\n\t\tcstate->off_nl = OFFSET_NOT_SET;\t/* L3 proto location dep. on cookie type */\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_JUNIPER_VP:\n\t\tcstate->off_linktype.constant_part = 18;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_JUNIPER_ST:\n\t\tcstate->off_linktype.constant_part = 18;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_JUNIPER_ISM:\n\t\tcstate->off_linktype.constant_part = 8;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_JUNIPER_VS:\n\tcase DLT_JUNIPER_SRX_E2E:\n\tcase DLT_JUNIPER_FIBRECHANNEL:\n\tcase DLT_JUNIPER_ATM_CEMIC:\n\t\tcstate->off_linktype.constant_part = 8;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_MTP2:\n\t\tcstate->off_li = 2;\n\t\tcstate->off_li_hsl = 4;\n\t\tcstate->off_sio = 3;\n\t\tcstate->off_opc = 4;\n\t\tcstate->off_dpc = 4;\n\t\tcstate->off_sls = 7;\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_MTP2_WITH_PHDR:\n\t\tcstate->off_li = 6;\n\t\tcstate->off_li_hsl = 8;\n\t\tcstate->off_sio = 7;\n\t\tcstate->off_opc = 8;\n\t\tcstate->off_dpc = 8;\n\t\tcstate->off_sls = 11;\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_ERF:\n\t\tcstate->off_li = 22;\n\t\tcstate->off_li_hsl = 24;\n\t\tcstate->off_sio = 23;\n\t\tcstate->off_opc = 24;\n\t\tcstate->off_dpc = 24;\n\t\tcstate->off_sls = 27;\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_PFSYNC:\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_linkpl.constant_part = 4;\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = 0;\n\t\tbreak;\n\n\tcase DLT_AX25_KISS:\n\t\t/*\n\t\t * Currently, only raw \"link[N:M]\" filtering is supported.\n\t\t */\n\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\t/* variable, min 15, max 71 steps of 7 */\n\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\tcstate->off_nl = OFFSET_NOT_SET;\t/* variable, min 16, max 71 steps of 7 */\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\t/* no 802.2 LLC */\n\t\tbreak;\n\n\tcase DLT_IPNET:\n\t\tcstate->off_linktype.constant_part = 1;\n\t\tcstate->off_linkpl.constant_part = 24;\t/* ipnet header length */\n\t\tcstate->off_nl = 0;\n\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\tbreak;\n\n\tcase DLT_NETANALYZER:\n\t\tcstate->off_linkhdr.constant_part = 4;\t/* Ethernet header is past 4-byte pseudo-header */\n\t\tcstate->off_linktype.constant_part = cstate->off_linkhdr.constant_part + 12;\n\t\tcstate->off_linkpl.constant_part = cstate->off_linkhdr.constant_part + 14;\t/* pseudo-header+Ethernet header length */\n\t\tcstate->off_nl = 0;\t\t/* Ethernet II */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.3+802.2 */\n\t\tbreak;\n\n\tcase DLT_NETANALYZER_TRANSPARENT:\n\t\tcstate->off_linkhdr.constant_part = 12;\t/* MAC header is past 4-byte pseudo-header, preamble, and SFD */\n\t\tcstate->off_linktype.constant_part = cstate->off_linkhdr.constant_part + 12;\n\t\tcstate->off_linkpl.constant_part = cstate->off_linkhdr.constant_part + 14;\t/* pseudo-header+preamble+SFD+Ethernet header length */\n\t\tcstate->off_nl = 0;\t\t/* Ethernet II */\n\t\tcstate->off_nl_nosnap = 3;\t/* 802.3+802.2 */\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * For values in the range in which we've assigned new\n\t\t * DLT_ values, only raw \"link[N:M]\" filtering is supported.\n\t\t */\n\t\tif (cstate->linktype >= DLT_MATCHING_MIN &&\n\t\t    cstate->linktype <= DLT_MATCHING_MAX) {\n\t\t\tcstate->off_linktype.constant_part = OFFSET_NOT_SET;\n\t\t\tcstate->off_linkpl.constant_part = OFFSET_NOT_SET;\n\t\t\tcstate->off_nl = OFFSET_NOT_SET;\n\t\t\tcstate->off_nl_nosnap = OFFSET_NOT_SET;\n\t\t} else {\n\t\t\tbpf_set_error(cstate, \"unknown data link type %d\", cstate->linktype);\n\t\t\treturn (-1);\n\t\t}\n\t\tbreak;\n\t}\n\n\tcstate->off_outermostlinkhdr = cstate->off_prevlinkhdr = cstate->off_linkhdr;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1137,
              0
            ],
            [
              1729,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "init_linktype",
            "parameters": {
              "cstate": "compiler_state_t",
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static struct slist *\ngen_load_absoffsetrel(compiler_state_t *cstate, bpf_abs_offset *abs_offset,\n    u_int offset, u_int size)\n{\n\tstruct slist *s, *s2;\n\n\ts = gen_abs_offset_varpart(cstate, abs_offset);\n\n\t/*\n\t * If \"s\" is non-null, it has code to arrange that the X register\n\t * contains the variable part of the absolute offset, so we\n\t * generate a load relative to that, with an offset of\n\t * abs_offset->constant_part + offset.\n\t *\n\t * Otherwise, we can do an absolute load with an offset of\n\t * abs_offset->constant_part + offset.\n\t */\n\tif (s != NULL) {\n\t\t/*\n\t\t * \"s\" points to a list of statements that puts the\n\t\t * variable part of the absolute offset into the X register.\n\t\t * Do an indirect load, to use the X register as an offset.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_IND|size);\n\t\ts2->s.k = abs_offset->constant_part + offset;\n\t\tsappend(s, s2);\n\t} else {\n\t\t/*\n\t\t * There is no variable part of the absolute offset, so\n\t\t * just do an absolute load.\n\t\t */\n\t\ts = new_stmt(cstate, BPF_LD|BPF_ABS|size);\n\t\ts->s.k = abs_offset->constant_part + offset;\n\t}\n\treturn s;\n}",
          "fn_code_pos": [
            [
              1734,
              0
            ],
            [
              1769,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_absoffsetrel",
            "parameters": {
              "cstate": "compiler_state_t",
              "abs_offset": "bpf_abs_offset",
              "offset": "u_int",
              "size": "u_int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct slist *\ngen_load_a(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size)\n{\n\tstruct slist *s, *s2;\n\n\t/*\n\t * Squelch warnings from compilers that *don't* assume that\n\t * offrel always has a valid enum value and therefore don't\n\t * assume that we'll always go through one of the case arms.\n\t *\n\t * If we have a default case, compilers that *do* assume that\n\t * will then complain about the default case code being\n\t * unreachable.\n\t *\n\t * Damned if you do, damned if you don't.\n\t */\n\ts = NULL;\n\n\tswitch (offrel) {\n\n\tcase OR_PACKET:\n                s = new_stmt(cstate, BPF_LD|BPF_ABS|size);\n                s->s.k = offset;\n\t\tbreak;\n\n\tcase OR_LINKHDR:\n\t\ts = gen_load_absoffsetrel(cstate, &cstate->off_linkhdr, offset, size);\n\t\tbreak;\n\n\tcase OR_PREVLINKHDR:\n\t\ts = gen_load_absoffsetrel(cstate, &cstate->off_prevlinkhdr, offset, size);\n\t\tbreak;\n\n\tcase OR_LLC:\n\t\ts = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, offset, size);\n\t\tbreak;\n\n\tcase OR_PREVMPLSHDR:\n\t\ts = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, cstate->off_nl - 4 + offset, size);\n\t\tbreak;\n\n\tcase OR_LINKPL:\n\t\ts = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, cstate->off_nl + offset, size);\n\t\tbreak;\n\n\tcase OR_LINKPL_NOSNAP:\n\t\ts = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, cstate->off_nl_nosnap + offset, size);\n\t\tbreak;\n\n\tcase OR_LINKTYPE:\n\t\ts = gen_load_absoffsetrel(cstate, &cstate->off_linktype, offset, size);\n\t\tbreak;\n\n\tcase OR_TRAN_IPV4:\n\t\t/*\n\t\t * Load the X register with the length of the IPv4 header\n\t\t * (plus the offset of the link-layer header, if it's\n\t\t * preceded by a variable-length header such as a radio\n\t\t * header), in bytes.\n\t\t */\n\t\ts = gen_loadx_iphdrlen(cstate);\n\n\t\t/*\n\t\t * Load the item at {offset of the link-layer payload} +\n\t\t * {offset, relative to the start of the link-layer\n\t\t * paylod, of the IPv4 header} + {length of the IPv4 header} +\n\t\t * {specified offset}.\n\t\t *\n\t\t * If the offset of the link-layer payload is variable,\n\t\t * the variable part of that offset is included in the\n\t\t * value in the X register, and we include the constant\n\t\t * part in the offset of the load.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_IND|size);\n\t\ts2->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + offset;\n\t\tsappend(s, s2);\n\t\tbreak;\n\n\tcase OR_TRAN_IPV6:\n\t\ts = gen_load_absoffsetrel(cstate, &cstate->off_linkpl, cstate->off_nl + 40 + offset, size);\n\t\tbreak;\n\t}\n\treturn s;\n}",
          "fn_code_pos": [
            [
              1774,
              0
            ],
            [
              1858,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_a",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct slist *\ngen_loadx_iphdrlen(compiler_state_t *cstate)\n{\n\tstruct slist *s, *s2;\n\n\ts = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);\n\tif (s != NULL) {\n\t\t/*\n\t\t * The offset of the link-layer payload has a variable\n\t\t * part.  \"s\" points to a list of statements that put\n\t\t * the variable part of that offset into the X register.\n\t\t *\n\t\t * The 4*([k]&0xf) addressing mode can't be used, as we\n\t\t * don't have a constant offset, so we have to load the\n\t\t * value in question into the A register and add to it\n\t\t * the value from the X register.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);\n\t\ts2->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\t\tsappend(s, s2);\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);\n\t\ts2->s.k = 0xf;\n\t\tsappend(s, s2);\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_LSH|BPF_K);\n\t\ts2->s.k = 2;\n\t\tsappend(s, s2);\n\n\t\t/*\n\t\t * The A register now contains the length of the IP header.\n\t\t * We need to add to it the variable part of the offset of\n\t\t * the link-layer payload, which is still in the X\n\t\t * register, and move the result into the X register.\n\t\t */\n\t\tsappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));\n\t\tsappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));\n\t} else {\n\t\t/*\n\t\t * The offset of the link-layer payload is a constant,\n\t\t * so no code was generated to load the (non-existent)\n\t\t * variable part of that offset.\n\t\t *\n\t\t * This means we can use the 4*([k]&0xf) addressing\n\t\t * mode.  Load the length of the IPv4 header, which\n\t\t * is at an offset of cstate->off_nl from the beginning of\n\t\t * the link-layer payload, and thus at an offset of\n\t\t * cstate->off_linkpl.constant_part + cstate->off_nl from the beginning\n\t\t * of the raw packet data, using that addressing mode.\n\t\t */\n\t\ts = new_stmt(cstate, BPF_LDX|BPF_MSH|BPF_B);\n\t\ts->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\t}\n\treturn s;\n}",
          "fn_code_pos": [
            [
              1865,
              0
            ],
            [
              1917,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_loadx_iphdrlen",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_uncond(compiler_state_t *cstate, int rsense)\n{\n\tstruct block *b;\n\tstruct slist *s;\n\n\ts = new_stmt(cstate, BPF_LD|BPF_IMM);\n\ts->s.k = !rsense;\n\tb = new_block(cstate, JMP(BPF_JEQ));\n\tb->stmts = s;\n\n\treturn b;\n}",
          "fn_code_pos": [
            [
              1920,
              0
            ],
            [
              1932,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_uncond",
            "parameters": {
              "cstate": "compiler_state_t",
              "rsense": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static inline struct block *\ngen_true(compiler_state_t *cstate)\n{\n\treturn gen_uncond(cstate, 1);\n}",
          "fn_code_pos": [
            [
              1934,
              0
            ],
            [
              1938,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_true",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static inline struct block *\ngen_false(compiler_state_t *cstate)\n{\n\treturn gen_uncond(cstate, 0);\n}",
          "fn_code_pos": [
            [
              1940,
              0
            ],
            [
              1944,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_false",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_ether_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)\n{\n\tstruct block *b0, *b1;\n\n\tswitch (ll_proto) {\n\n\tcase LLCSAP_ISONS:\n\tcase LLCSAP_IP:\n\tcase LLCSAP_NETBEUI:\n\t\t/*\n\t\t * OSI protocols and NetBEUI always use 802.2 encapsulation,\n\t\t * so we check the DSAP and SSAP.\n\t\t *\n\t\t * LLCSAP_IP checks for IP-over-802.2, rather\n\t\t * than IP-over-Ethernet or IP-over-SNAP.\n\t\t *\n\t\t * XXX - should we check both the DSAP and the\n\t\t * SSAP, like this, or should we check just the\n\t\t * DSAP, as we do for other types <= ETHERMTU\n\t\t * (i.e., other SAP values)?\n\t\t */\n\t\tb0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);\n\t\tgen_not(b0);\n\t\tb1 = gen_cmp(cstate, OR_LLC, 0, BPF_H, (ll_proto << 8) | ll_proto);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase LLCSAP_IPX:\n\t\t/*\n\t\t * Check for;\n\t\t *\n\t\t *\tEthernet_II frames, which are Ethernet\n\t\t *\tframes with a frame type of ETHERTYPE_IPX;\n\t\t *\n\t\t *\tEthernet_802.3 frames, which are 802.3\n\t\t *\tframes (i.e., the type/length field is\n\t\t *\ta length field, <= ETHERMTU, rather than\n\t\t *\ta type field) with the first two bytes\n\t\t *\tafter the Ethernet/802.3 header being\n\t\t *\t0xFFFF;\n\t\t *\n\t\t *\tEthernet_802.2 frames, which are 802.3\n\t\t *\tframes with an 802.2 LLC header and\n\t\t *\twith the IPX LSAP as the DSAP in the LLC\n\t\t *\theader;\n\t\t *\n\t\t *\tEthernet_SNAP frames, which are 802.3\n\t\t *\tframes with an LLC header and a SNAP\n\t\t *\theader and with an OUI of 0x000000\n\t\t *\t(encapsulated Ethernet) and a protocol\n\t\t *\tID of ETHERTYPE_IPX in the SNAP header.\n\t\t *\n\t\t * XXX - should we generate the same code both\n\t\t * for tests for LLCSAP_IPX and for ETHERTYPE_IPX?\n\t\t */\n\n\t\t/*\n\t\t * This generates code to check both for the\n\t\t * IPX LSAP (Ethernet_802.2) and for Ethernet_802.3.\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LLC, 0, BPF_B, LLCSAP_IPX);\n\t\tb1 = gen_cmp(cstate, OR_LLC, 0, BPF_H, 0xFFFF);\n\t\tgen_or(b0, b1);\n\n\t\t/*\n\t\t * Now we add code to check for SNAP frames with\n\t\t * ETHERTYPE_IPX, i.e. Ethernet_SNAP.\n\t\t */\n\t\tb0 = gen_snap(cstate, 0x000000, ETHERTYPE_IPX);\n\t\tgen_or(b0, b1);\n\n\t\t/*\n\t\t * Now we generate code to check for 802.3\n\t\t * frames in general.\n\t\t */\n\t\tb0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);\n\t\tgen_not(b0);\n\n\t\t/*\n\t\t * Now add the check for 802.3 frames before the\n\t\t * check for Ethernet_802.2 and Ethernet_802.3,\n\t\t * as those checks should only be done on 802.3\n\t\t * frames, not on Ethernet frames.\n\t\t */\n\t\tgen_and(b0, b1);\n\n\t\t/*\n\t\t * Now add the check for Ethernet_II frames, and\n\t\t * do that before checking for the other frame\n\t\t * types.\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ETHERTYPE_IPX);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase ETHERTYPE_ATALK:\n\tcase ETHERTYPE_AARP:\n\t\t/*\n\t\t * EtherTalk (AppleTalk protocols on Ethernet link\n\t\t * layer) may use 802.2 encapsulation.\n\t\t */\n\n\t\t/*\n\t\t * Check for 802.2 encapsulation (EtherTalk phase 2?);\n\t\t * we check for an Ethernet type field less than\n\t\t * 1500, which means it's an 802.3 length field.\n\t\t */\n\t\tb0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);\n\t\tgen_not(b0);\n\n\t\t/*\n\t\t * 802.2-encapsulated ETHERTYPE_ATALK packets are\n\t\t * SNAP packets with an organization code of\n\t\t * 0x080007 (Apple, for Appletalk) and a protocol\n\t\t * type of ETHERTYPE_ATALK (Appletalk).\n\t\t *\n\t\t * 802.2-encapsulated ETHERTYPE_AARP packets are\n\t\t * SNAP packets with an organization code of\n\t\t * 0x000000 (encapsulated Ethernet) and a protocol\n\t\t * type of ETHERTYPE_AARP (Appletalk ARP).\n\t\t */\n\t\tif (ll_proto == ETHERTYPE_ATALK)\n\t\t\tb1 = gen_snap(cstate, 0x080007, ETHERTYPE_ATALK);\n\t\telse\t/* ll_proto == ETHERTYPE_AARP */\n\t\t\tb1 = gen_snap(cstate, 0x000000, ETHERTYPE_AARP);\n\t\tgen_and(b0, b1);\n\n\t\t/*\n\t\t * Check for Ethernet encapsulation (Ethertalk\n\t\t * phase 1?); we just check for the Ethernet\n\t\t * protocol type.\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);\n\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tdefault:\n\t\tif (ll_proto <= ETHERMTU) {\n\t\t\t/*\n\t\t\t * This is an LLC SAP value, so the frames\n\t\t\t * that match would be 802.2 frames.\n\t\t\t * Check that the frame is an 802.2 frame\n\t\t\t * (i.e., that the length/type field is\n\t\t\t * a length field, <= ETHERMTU) and\n\t\t\t * then check the DSAP.\n\t\t\t */\n\t\t\tb0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);\n\t\t\tgen_not(b0);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKTYPE, 2, BPF_B, ll_proto);\n\t\t\tgen_and(b0, b1);\n\t\t\treturn b1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is an Ethernet type, so compare\n\t\t\t * the length/type field with it (if\n\t\t\t * the frame is an 802.2 frame, the length\n\t\t\t * field will be <= ETHERMTU, and, as\n\t\t\t * \"ll_proto\" is > ETHERMTU, this test\n\t\t\t * will fail and the frame won't match,\n\t\t\t * which is what we want).\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              1963,
              0
            ],
            [
              2129,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ether_linktype",
            "parameters": {
              "cstate": "compiler_state_t",
              "ll_proto": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_loopback_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)\n{\n\t/*\n\t * For DLT_NULL, the link-layer header is a 32-bit word\n\t * containing an AF_ value in *host* byte order, and for\n\t * DLT_ENC, the link-layer header begins with a 32-bit\n\t * word containing an AF_ value in host byte order.\n\t *\n\t * In addition, if we're reading a saved capture file,\n\t * the host byte order in the capture may not be the\n\t * same as the host byte order on this machine.\n\t *\n\t * For DLT_LOOP, the link-layer header is a 32-bit\n\t * word containing an AF_ value in *network* byte order.\n\t */\n\tif (cstate->linktype == DLT_NULL || cstate->linktype == DLT_ENC) {\n\t\t/*\n\t\t * The AF_ value is in host byte order, but the BPF\n\t\t * interpreter will convert it to network byte order.\n\t\t *\n\t\t * If this is a save file, and it's from a machine\n\t\t * with the opposite byte order to ours, we byte-swap\n\t\t * the AF_ value.\n\t\t *\n\t\t * Then we run it through \"htonl()\", and generate\n\t\t * code to compare against the result.\n\t\t */\n\t\tif (cstate->bpf_pcap->rfile != NULL && cstate->bpf_pcap->swapped)\n\t\t\tll_proto = SWAPLONG(ll_proto);\n\t\tll_proto = htonl(ll_proto);\n\t}\n\treturn (gen_cmp(cstate, OR_LINKHDR, 0, BPF_W, ll_proto));\n}",
          "fn_code_pos": [
            [
              2131,
              0
            ],
            [
              2164,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_loopback_linktype",
            "parameters": {
              "cstate": "compiler_state_t",
              "ll_proto": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_ipnet_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)\n{\n\tswitch (ll_proto) {\n\n\tcase ETHERTYPE_IP:\n\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B, IPH_AF_INET);\n\t\t/*NOTREACHED*/\n\n\tcase ETHERTYPE_IPV6:\n\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B, IPH_AF_INET6);\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn gen_false(cstate);\n}",
          "fn_code_pos": [
            [
              2170,
              0
            ],
            [
              2188,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ipnet_linktype",
            "parameters": {
              "cstate": "compiler_state_t",
              "ll_proto": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_linux_sll_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)\n{\n\tstruct block *b0, *b1;\n\n\tswitch (ll_proto) {\n\n\tcase LLCSAP_ISONS:\n\tcase LLCSAP_IP:\n\tcase LLCSAP_NETBEUI:\n\t\t/*\n\t\t * OSI protocols and NetBEUI always use 802.2 encapsulation,\n\t\t * so we check the DSAP and SSAP.\n\t\t *\n\t\t * LLCSAP_IP checks for IP-over-802.2, rather\n\t\t * than IP-over-Ethernet or IP-over-SNAP.\n\t\t *\n\t\t * XXX - should we check both the DSAP and the\n\t\t * SSAP, like this, or should we check just the\n\t\t * DSAP, as we do for other types <= ETHERMTU\n\t\t * (i.e., other SAP values)?\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_2);\n\t\tb1 = gen_cmp(cstate, OR_LLC, 0, BPF_H, (ll_proto << 8) | ll_proto);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase LLCSAP_IPX:\n\t\t/*\n\t\t *\tEthernet_II frames, which are Ethernet\n\t\t *\tframes with a frame type of ETHERTYPE_IPX;\n\t\t *\n\t\t *\tEthernet_802.3 frames, which have a frame\n\t\t *\ttype of LINUX_SLL_P_802_3;\n\t\t *\n\t\t *\tEthernet_802.2 frames, which are 802.3\n\t\t *\tframes with an 802.2 LLC header (i.e, have\n\t\t *\ta frame type of LINUX_SLL_P_802_2) and\n\t\t *\twith the IPX LSAP as the DSAP in the LLC\n\t\t *\theader;\n\t\t *\n\t\t *\tEthernet_SNAP frames, which are 802.3\n\t\t *\tframes with an LLC header and a SNAP\n\t\t *\theader and with an OUI of 0x000000\n\t\t *\t(encapsulated Ethernet) and a protocol\n\t\t *\tID of ETHERTYPE_IPX in the SNAP header.\n\t\t *\n\t\t * First, do the checks on LINUX_SLL_P_802_2\n\t\t * frames; generate the check for either\n\t\t * Ethernet_802.2 or Ethernet_SNAP frames, and\n\t\t * then put a check for LINUX_SLL_P_802_2 frames\n\t\t * before it.\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LLC, 0, BPF_B, LLCSAP_IPX);\n\t\tb1 = gen_snap(cstate, 0x000000, ETHERTYPE_IPX);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_2);\n\t\tgen_and(b0, b1);\n\n\t\t/*\n\t\t * Now check for 802.3 frames and OR that with\n\t\t * the previous test.\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_3);\n\t\tgen_or(b0, b1);\n\n\t\t/*\n\t\t * Now add the check for Ethernet_II frames, and\n\t\t * do that before checking for the other frame\n\t\t * types.\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ETHERTYPE_IPX);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase ETHERTYPE_ATALK:\n\tcase ETHERTYPE_AARP:\n\t\t/*\n\t\t * EtherTalk (AppleTalk protocols on Ethernet link\n\t\t * layer) may use 802.2 encapsulation.\n\t\t */\n\n\t\t/*\n\t\t * Check for 802.2 encapsulation (EtherTalk phase 2?);\n\t\t * we check for the 802.2 protocol type in the\n\t\t * \"Ethernet type\" field.\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_2);\n\n\t\t/*\n\t\t * 802.2-encapsulated ETHERTYPE_ATALK packets are\n\t\t * SNAP packets with an organization code of\n\t\t * 0x080007 (Apple, for Appletalk) and a protocol\n\t\t * type of ETHERTYPE_ATALK (Appletalk).\n\t\t *\n\t\t * 802.2-encapsulated ETHERTYPE_AARP packets are\n\t\t * SNAP packets with an organization code of\n\t\t * 0x000000 (encapsulated Ethernet) and a protocol\n\t\t * type of ETHERTYPE_AARP (Appletalk ARP).\n\t\t */\n\t\tif (ll_proto == ETHERTYPE_ATALK)\n\t\t\tb1 = gen_snap(cstate, 0x080007, ETHERTYPE_ATALK);\n\t\telse\t/* ll_proto == ETHERTYPE_AARP */\n\t\t\tb1 = gen_snap(cstate, 0x000000, ETHERTYPE_AARP);\n\t\tgen_and(b0, b1);\n\n\t\t/*\n\t\t * Check for Ethernet encapsulation (Ethertalk\n\t\t * phase 1?); we just check for the Ethernet\n\t\t * protocol type.\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);\n\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tdefault:\n\t\tif (ll_proto <= ETHERMTU) {\n\t\t\t/*\n\t\t\t * This is an LLC SAP value, so the frames\n\t\t\t * that match would be 802.2 frames.\n\t\t\t * Check for the 802.2 protocol type\n\t\t\t * in the \"Ethernet type\" field, and\n\t\t\t * then check the DSAP.\n\t\t\t */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, LINUX_SLL_P_802_2);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKHDR, cstate->off_linkpl.constant_part, BPF_B,\n\t\t\t     ll_proto);\n\t\t\tgen_and(b0, b1);\n\t\t\treturn b1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is an Ethernet type, so compare\n\t\t\t * the length/type field with it (if\n\t\t\t * the frame is an 802.2 frame, the length\n\t\t\t * field will be <= ETHERMTU, and, as\n\t\t\t * \"ll_proto\" is > ETHERMTU, this test\n\t\t\t * will fail and the frame won't match,\n\t\t\t * which is what we want).\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              2198,
              0
            ],
            [
              2341,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_linux_sll_linktype",
            "parameters": {
              "cstate": "compiler_state_t",
              "ll_proto": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct slist *\ngen_load_prism_llprefixlen(compiler_state_t *cstate)\n{\n\tstruct slist *s1, *s2;\n\tstruct slist *sjeq_avs_cookie;\n\tstruct slist *sjcommon;\n\n\t/*\n\t * This code is not compatible with the optimizer, as\n\t * we are generating jmp instructions within a normal\n\t * slist of instructions\n\t */\n\tcstate->no_optimize = 1;\n\n\t/*\n\t * Generate code to load the length of the radio header into\n\t * the register assigned to hold that length, if one has been\n\t * assigned.  (If one hasn't been assigned, no code we've\n\t * generated uses that prefix, so we don't need to generate any\n\t * code to load it.)\n\t *\n\t * Some Linux drivers use ARPHRD_IEEE80211_PRISM but sometimes\n\t * or always use the AVS header rather than the Prism header.\n\t * We load a 4-byte big-endian value at the beginning of the\n\t * raw packet data, and see whether, when masked with 0xFFFFF000,\n\t * it's equal to 0x80211000.  If so, that indicates that it's\n\t * an AVS header (the masked-out bits are the version number).\n\t * Otherwise, it's a Prism header.\n\t *\n\t * XXX - the Prism header is also, in theory, variable-length,\n\t * but no known software generates headers that aren't 144\n\t * bytes long.\n\t */\n\tif (cstate->off_linkhdr.reg != -1) {\n\t\t/*\n\t\t * Load the cookie.\n\t\t */\n\t\ts1 = new_stmt(cstate, BPF_LD|BPF_W|BPF_ABS);\n\t\ts1->s.k = 0;\n\n\t\t/*\n\t\t * AND it with 0xFFFFF000.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);\n\t\ts2->s.k = 0xFFFFF000;\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Compare with 0x80211000.\n\t\t */\n\t\tsjeq_avs_cookie = new_stmt(cstate, JMP(BPF_JEQ));\n\t\tsjeq_avs_cookie->s.k = 0x80211000;\n\t\tsappend(s1, sjeq_avs_cookie);\n\n\t\t/*\n\t\t * If it's AVS:\n\t\t *\n\t\t * The 4 bytes at an offset of 4 from the beginning of\n\t\t * the AVS header are the length of the AVS header.\n\t\t * That field is big-endian.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_W|BPF_ABS);\n\t\ts2->s.k = 4;\n\t\tsappend(s1, s2);\n\t\tsjeq_avs_cookie->s.jt = s2;\n\n\t\t/*\n\t\t * Now jump to the code to allocate a register\n\t\t * into which to save the header length and\n\t\t * store the length there.  (The \"jump always\"\n\t\t * instruction needs to have the k field set;\n\t\t * it's added to the PC, so, as we're jumping\n\t\t * over a single instruction, it should be 1.)\n\t\t */\n\t\tsjcommon = new_stmt(cstate, JMP(BPF_JA));\n\t\tsjcommon->s.k = 1;\n\t\tsappend(s1, sjcommon);\n\n\t\t/*\n\t\t * Now for the code that handles the Prism header.\n\t\t * Just load the length of the Prism header (144)\n\t\t * into the A register.  Have the test for an AVS\n\t\t * header branch here if we don't have an AVS header.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_W|BPF_IMM);\n\t\ts2->s.k = 144;\n\t\tsappend(s1, s2);\n\t\tsjeq_avs_cookie->s.jf = s2;\n\n\t\t/*\n\t\t * Now allocate a register to hold that value and store\n\t\t * it.  The code for the AVS header will jump here after\n\t\t * loading the length of the AVS header.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_ST);\n\t\ts2->s.k = cstate->off_linkhdr.reg;\n\t\tsappend(s1, s2);\n\t\tsjcommon->s.jf = s2;\n\n\t\t/*\n\t\t * Now move it into the X register.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\t\tsappend(s1, s2);\n\n\t\treturn (s1);\n\t} else\n\t\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              2343,
              0
            ],
            [
              2451,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_prism_llprefixlen",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct slist *\ngen_load_avs_llprefixlen(compiler_state_t *cstate)\n{\n\tstruct slist *s1, *s2;\n\n\t/*\n\t * Generate code to load the length of the AVS header into\n\t * the register assigned to hold that length, if one has been\n\t * assigned.  (If one hasn't been assigned, no code we've\n\t * generated uses that prefix, so we don't need to generate any\n\t * code to load it.)\n\t */\n\tif (cstate->off_linkhdr.reg != -1) {\n\t\t/*\n\t\t * The 4 bytes at an offset of 4 from the beginning of\n\t\t * the AVS header are the length of the AVS header.\n\t\t * That field is big-endian.\n\t\t */\n\t\ts1 = new_stmt(cstate, BPF_LD|BPF_W|BPF_ABS);\n\t\ts1->s.k = 4;\n\n\t\t/*\n\t\t * Now allocate a register to hold that value and store\n\t\t * it.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_ST);\n\t\ts2->s.k = cstate->off_linkhdr.reg;\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Now move it into the X register.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\t\tsappend(s1, s2);\n\n\t\treturn (s1);\n\t} else\n\t\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              2453,
              0
            ],
            [
              2491,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_avs_llprefixlen",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct slist *\ngen_load_radiotap_llprefixlen(compiler_state_t *cstate)\n{\n\tstruct slist *s1, *s2;\n\n\t/*\n\t * Generate code to load the length of the radiotap header into\n\t * the register assigned to hold that length, if one has been\n\t * assigned.  (If one hasn't been assigned, no code we've\n\t * generated uses that prefix, so we don't need to generate any\n\t * code to load it.)\n\t */\n\tif (cstate->off_linkhdr.reg != -1) {\n\t\t/*\n\t\t * The 2 bytes at offsets of 2 and 3 from the beginning\n\t\t * of the radiotap header are the length of the radiotap\n\t\t * header; unfortunately, it's little-endian, so we have\n\t\t * to load it a byte at a time and construct the value.\n\t\t */\n\n\t\t/*\n\t\t * Load the high-order byte, at an offset of 3, shift it\n\t\t * left a byte, and put the result in the X register.\n\t\t */\n\t\ts1 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n\t\ts1->s.k = 3;\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_LSH|BPF_K);\n\t\tsappend(s1, s2);\n\t\ts2->s.k = 8;\n\t\ts2 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Load the next byte, at an offset of 2, and OR the\n\t\t * value from the X register into it.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n\t\tsappend(s1, s2);\n\t\ts2->s.k = 2;\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_OR|BPF_X);\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Now allocate a register to hold that value and store\n\t\t * it.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_ST);\n\t\ts2->s.k = cstate->off_linkhdr.reg;\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Now move it into the X register.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\t\tsappend(s1, s2);\n\n\t\treturn (s1);\n\t} else\n\t\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              2493,
              0
            ],
            [
              2552,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_radiotap_llprefixlen",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct slist *\ngen_load_ppi_llprefixlen(compiler_state_t *cstate)\n{\n\tstruct slist *s1, *s2;\n\n\t/*\n\t * Generate code to load the length of the radiotap header\n\t * into the register assigned to hold that length, if one has\n\t * been assigned.\n\t */\n\tif (cstate->off_linkhdr.reg != -1) {\n\t\t/*\n\t\t * The 2 bytes at offsets of 2 and 3 from the beginning\n\t\t * of the radiotap header are the length of the radiotap\n\t\t * header; unfortunately, it's little-endian, so we have\n\t\t * to load it a byte at a time and construct the value.\n\t\t */\n\n\t\t/*\n\t\t * Load the high-order byte, at an offset of 3, shift it\n\t\t * left a byte, and put the result in the X register.\n\t\t */\n\t\ts1 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n\t\ts1->s.k = 3;\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_LSH|BPF_K);\n\t\tsappend(s1, s2);\n\t\ts2->s.k = 8;\n\t\ts2 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Load the next byte, at an offset of 2, and OR the\n\t\t * value from the X register into it.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n\t\tsappend(s1, s2);\n\t\ts2->s.k = 2;\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_OR|BPF_X);\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Now allocate a register to hold that value and store\n\t\t * it.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_ST);\n\t\ts2->s.k = cstate->off_linkhdr.reg;\n\t\tsappend(s1, s2);\n\n\t\t/*\n\t\t * Now move it into the X register.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\t\tsappend(s1, s2);\n\n\t\treturn (s1);\n\t} else\n\t\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              2563,
              0
            ],
            [
              2620,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_ppi_llprefixlen",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct slist *\ngen_load_802_11_header_len(compiler_state_t *cstate, struct slist *s, struct slist *snext)\n{\n\tstruct slist *s2;\n\tstruct slist *sjset_data_frame_1;\n\tstruct slist *sjset_data_frame_2;\n\tstruct slist *sjset_qos;\n\tstruct slist *sjset_radiotap_flags_present;\n\tstruct slist *sjset_radiotap_ext_present;\n\tstruct slist *sjset_radiotap_tsft_present;\n\tstruct slist *sjset_tsft_datapad, *sjset_notsft_datapad;\n\tstruct slist *s_roundup;\n\n\tif (cstate->off_linkpl.reg == -1) {\n\t\t/*\n\t\t * No register has been assigned to the offset of\n\t\t * the link-layer payload, which means nobody needs\n\t\t * it; don't bother computing it - just return\n\t\t * what we already have.\n\t\t */\n\t\treturn (s);\n\t}\n\n\t/*\n\t * This code is not compatible with the optimizer, as\n\t * we are generating jmp instructions within a normal\n\t * slist of instructions\n\t */\n\tcstate->no_optimize = 1;\n\n\t/*\n\t * If \"s\" is non-null, it has code to arrange that the X register\n\t * contains the length of the prefix preceding the link-layer\n\t * header.\n\t *\n\t * Otherwise, the length of the prefix preceding the link-layer\n\t * header is \"off_outermostlinkhdr.constant_part\".\n\t */\n\tif (s == NULL) {\n\t\t/*\n\t\t * There is no variable-length header preceding the\n\t\t * link-layer header.\n\t\t *\n\t\t * Load the length of the fixed-length prefix preceding\n\t\t * the link-layer header (if any) into the X register,\n\t\t * and store it in the cstate->off_linkpl.reg register.\n\t\t * That length is off_outermostlinkhdr.constant_part.\n\t\t */\n\t\ts = new_stmt(cstate, BPF_LDX|BPF_IMM);\n\t\ts->s.k = cstate->off_outermostlinkhdr.constant_part;\n\t}\n\n\t/*\n\t * The X register contains the offset of the beginning of the\n\t * link-layer header; add 24, which is the minimum length\n\t * of the MAC header for a data frame, to that, and store it\n\t * in cstate->off_linkpl.reg, and then load the Frame Control field,\n\t * which is at the offset in the X register, with an indexed load.\n\t */\n\ts2 = new_stmt(cstate, BPF_MISC|BPF_TXA);\n\tsappend(s, s2);\n\ts2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts2->s.k = 24;\n\tsappend(s, s2);\n\ts2 = new_stmt(cstate, BPF_ST);\n\ts2->s.k = cstate->off_linkpl.reg;\n\tsappend(s, s2);\n\n\ts2 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);\n\ts2->s.k = 0;\n\tsappend(s, s2);\n\n\t/*\n\t * Check the Frame Control field to see if this is a data frame;\n\t * a data frame has the 0x08 bit (b3) in that field set and the\n\t * 0x04 bit (b2) clear.\n\t */\n\tsjset_data_frame_1 = new_stmt(cstate, JMP(BPF_JSET));\n\tsjset_data_frame_1->s.k = 0x08;\n\tsappend(s, sjset_data_frame_1);\n\n\t/*\n\t * If b3 is set, test b2, otherwise go to the first statement of\n\t * the rest of the program.\n\t */\n\tsjset_data_frame_1->s.jt = sjset_data_frame_2 = new_stmt(cstate, JMP(BPF_JSET));\n\tsjset_data_frame_2->s.k = 0x04;\n\tsappend(s, sjset_data_frame_2);\n\tsjset_data_frame_1->s.jf = snext;\n\n\t/*\n\t * If b2 is not set, this is a data frame; test the QoS bit.\n\t * Otherwise, go to the first statement of the rest of the\n\t * program.\n\t */\n\tsjset_data_frame_2->s.jt = snext;\n\tsjset_data_frame_2->s.jf = sjset_qos = new_stmt(cstate, JMP(BPF_JSET));\n\tsjset_qos->s.k = 0x80;\t/* QoS bit */\n\tsappend(s, sjset_qos);\n\n\t/*\n\t * If it's set, add 2 to cstate->off_linkpl.reg, to skip the QoS\n\t * field.\n\t * Otherwise, go to the first statement of the rest of the\n\t * program.\n\t */\n\tsjset_qos->s.jt = s2 = new_stmt(cstate, BPF_LD|BPF_MEM);\n\ts2->s.k = cstate->off_linkpl.reg;\n\tsappend(s, s2);\n\ts2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_IMM);\n\ts2->s.k = 2;\n\tsappend(s, s2);\n\ts2 = new_stmt(cstate, BPF_ST);\n\ts2->s.k = cstate->off_linkpl.reg;\n\tsappend(s, s2);\n\n\t/*\n\t * If we have a radiotap header, look at it to see whether\n\t * there's Atheros padding between the MAC-layer header\n\t * and the payload.\n\t *\n\t * Note: all of the fields in the radiotap header are\n\t * little-endian, so we byte-swap all of the values\n\t * we test against, as they will be loaded as big-endian\n\t * values.\n\t *\n\t * XXX - in the general case, we would have to scan through\n\t * *all* the presence bits, if there's more than one word of\n\t * presence bits.  That would require a loop, meaning that\n\t * we wouldn't be able to run the filter in the kernel.\n\t *\n\t * We assume here that the Atheros adapters that insert the\n\t * annoying padding don't have multiple antennae and therefore\n\t * do not generate radiotap headers with multiple presence words.\n\t */\n\tif (cstate->linktype == DLT_IEEE802_11_RADIO) {\n\t\t/*\n\t\t * Is the IEEE80211_RADIOTAP_FLAGS bit (0x0000002) set\n\t\t * in the first presence flag word?\n\t\t */\n\t\tsjset_qos->s.jf = s2 = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_W);\n\t\ts2->s.k = 4;\n\t\tsappend(s, s2);\n\n\t\tsjset_radiotap_flags_present = new_stmt(cstate, JMP(BPF_JSET));\n\t\tsjset_radiotap_flags_present->s.k = SWAPLONG(0x00000002);\n\t\tsappend(s, sjset_radiotap_flags_present);\n\n\t\t/*\n\t\t * If not, skip all of this.\n\t\t */\n\t\tsjset_radiotap_flags_present->s.jf = snext;\n\n\t\t/*\n\t\t * Otherwise, is the \"extension\" bit set in that word?\n\t\t */\n\t\tsjset_radiotap_ext_present = new_stmt(cstate, JMP(BPF_JSET));\n\t\tsjset_radiotap_ext_present->s.k = SWAPLONG(0x80000000);\n\t\tsappend(s, sjset_radiotap_ext_present);\n\t\tsjset_radiotap_flags_present->s.jt = sjset_radiotap_ext_present;\n\n\t\t/*\n\t\t * If so, skip all of this.\n\t\t */\n\t\tsjset_radiotap_ext_present->s.jt = snext;\n\n\t\t/*\n\t\t * Otherwise, is the IEEE80211_RADIOTAP_TSFT bit set?\n\t\t */\n\t\tsjset_radiotap_tsft_present = new_stmt(cstate, JMP(BPF_JSET));\n\t\tsjset_radiotap_tsft_present->s.k = SWAPLONG(0x00000001);\n\t\tsappend(s, sjset_radiotap_tsft_present);\n\t\tsjset_radiotap_ext_present->s.jf = sjset_radiotap_tsft_present;\n\n\t\t/*\n\t\t * If IEEE80211_RADIOTAP_TSFT is set, the flags field is\n\t\t * at an offset of 16 from the beginning of the raw packet\n\t\t * data (8 bytes for the radiotap header and 8 bytes for\n\t\t * the TSFT field).\n\t\t *\n\t\t * Test whether the IEEE80211_RADIOTAP_F_DATAPAD bit (0x20)\n\t\t * is set.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_B);\n\t\ts2->s.k = 16;\n\t\tsappend(s, s2);\n\t\tsjset_radiotap_tsft_present->s.jt = s2;\n\n\t\tsjset_tsft_datapad = new_stmt(cstate, JMP(BPF_JSET));\n\t\tsjset_tsft_datapad->s.k = 0x20;\n\t\tsappend(s, sjset_tsft_datapad);\n\n\t\t/*\n\t\t * If IEEE80211_RADIOTAP_TSFT is not set, the flags field is\n\t\t * at an offset of 8 from the beginning of the raw packet\n\t\t * data (8 bytes for the radiotap header).\n\t\t *\n\t\t * Test whether the IEEE80211_RADIOTAP_F_DATAPAD bit (0x20)\n\t\t * is set.\n\t\t */\n\t\ts2 = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_B);\n\t\ts2->s.k = 8;\n\t\tsappend(s, s2);\n\t\tsjset_radiotap_tsft_present->s.jf = s2;\n\n\t\tsjset_notsft_datapad = new_stmt(cstate, JMP(BPF_JSET));\n\t\tsjset_notsft_datapad->s.k = 0x20;\n\t\tsappend(s, sjset_notsft_datapad);\n\n\t\t/*\n\t\t * In either case, if IEEE80211_RADIOTAP_F_DATAPAD is\n\t\t * set, round the length of the 802.11 header to\n\t\t * a multiple of 4.  Do that by adding 3 and then\n\t\t * dividing by and multiplying by 4, which we do by\n\t\t * ANDing with ~3.\n\t\t */\n\t\ts_roundup = new_stmt(cstate, BPF_LD|BPF_MEM);\n\t\ts_roundup->s.k = cstate->off_linkpl.reg;\n\t\tsappend(s, s_roundup);\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_IMM);\n\t\ts2->s.k = 3;\n\t\tsappend(s, s2);\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_IMM);\n\t\ts2->s.k = (bpf_u_int32)~3;\n\t\tsappend(s, s2);\n\t\ts2 = new_stmt(cstate, BPF_ST);\n\t\ts2->s.k = cstate->off_linkpl.reg;\n\t\tsappend(s, s2);\n\n\t\tsjset_tsft_datapad->s.jt = s_roundup;\n\t\tsjset_tsft_datapad->s.jf = snext;\n\t\tsjset_notsft_datapad->s.jt = s_roundup;\n\t\tsjset_notsft_datapad->s.jf = snext;\n\t} else\n\t\tsjset_qos->s.jf = snext;\n\n\treturn s;\n}",
          "fn_code_pos": [
            [
              2629,
              0
            ],
            [
              2866,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_802_11_header_len",
            "parameters": {
              "cstate": "compiler_state_t",
              "s": "struct slist",
              "snext": "struct slist"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void\ninsert_compute_vloffsets(compiler_state_t *cstate, struct block *b)\n{\n\tstruct slist *s;\n\n\t/* There is an implicit dependency between the link\n\t * payload and link header since the payload computation\n\t * includes the variable part of the header. Therefore,\n\t * if nobody else has allocated a register for the link\n\t * header and we need it, do it now. */\n\tif (cstate->off_linkpl.reg != -1 && cstate->off_linkhdr.is_variable &&\n\t    cstate->off_linkhdr.reg == -1)\n\t\tcstate->off_linkhdr.reg = alloc_reg(cstate);\n\n\t/*\n\t * For link-layer types that have a variable-length header\n\t * preceding the link-layer header, generate code to load\n\t * the offset of the link-layer header into the register\n\t * assigned to that offset, if any.\n\t *\n\t * XXX - this, and the next switch statement, won't handle\n\t * encapsulation of 802.11 or 802.11+radio information in\n\t * some other protocol stack.  That's significantly more\n\t * complicated.\n\t */\n\tswitch (cstate->outermostlinktype) {\n\n\tcase DLT_PRISM_HEADER:\n\t\ts = gen_load_prism_llprefixlen(cstate);\n\t\tbreak;\n\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\t\ts = gen_load_avs_llprefixlen(cstate);\n\t\tbreak;\n\n\tcase DLT_IEEE802_11_RADIO:\n\t\ts = gen_load_radiotap_llprefixlen(cstate);\n\t\tbreak;\n\n\tcase DLT_PPI:\n\t\ts = gen_load_ppi_llprefixlen(cstate);\n\t\tbreak;\n\n\tdefault:\n\t\ts = NULL;\n\t\tbreak;\n\t}\n\n\t/*\n\t * For link-layer types that have a variable-length link-layer\n\t * header, generate code to load the offset of the link-layer\n\t * payload into the register assigned to that offset, if any.\n\t */\n\tswitch (cstate->outermostlinktype) {\n\n\tcase DLT_IEEE802_11:\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_IEEE802_11_RADIO:\n\tcase DLT_PPI:\n\t\ts = gen_load_802_11_header_len(cstate, s, b->stmts);\n\t\tbreak;\n\t}\n\n\t/*\n\t * If there there is no initialization yet and we need variable\n\t * length offsets for VLAN, initialize them to zero\n\t */\n\tif (s == NULL && cstate->is_vlan_vloffset) {\n\t\tstruct slist *s2;\n\n\t\tif (cstate->off_linkpl.reg == -1)\n\t\t\tcstate->off_linkpl.reg = alloc_reg(cstate);\n\t\tif (cstate->off_linktype.reg == -1)\n\t\t\tcstate->off_linktype.reg = alloc_reg(cstate);\n\n\t\ts = new_stmt(cstate, BPF_LD|BPF_W|BPF_IMM);\n\t\ts->s.k = 0;\n\t\ts2 = new_stmt(cstate, BPF_ST);\n\t\ts2->s.k = cstate->off_linkpl.reg;\n\t\tsappend(s, s2);\n\t\ts2 = new_stmt(cstate, BPF_ST);\n\t\ts2->s.k = cstate->off_linktype.reg;\n\t\tsappend(s, s2);\n\t}\n\n\t/*\n\t * If we have any offset-loading code, append all the\n\t * existing statements in the block to those statements,\n\t * and make the resulting list the list of statements\n\t * for the block.\n\t */\n\tif (s != NULL) {\n\t\tsappend(s, b->stmts);\n\t\tb->stmts = s;\n\t}\n}",
          "fn_code_pos": [
            [
              2868,
              0
            ],
            [
              2964,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "insert_compute_vloffsets",
            "parameters": {
              "cstate": "compiler_state_t",
              "b": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static struct block *\ngen_ppi_dlt_check(compiler_state_t *cstate)\n{\n\tstruct slist *s_load_dlt;\n\tstruct block *b;\n\n\tif (cstate->linktype == DLT_PPI)\n\t{\n\t\t/* Create the statements that check for the DLT\n\t\t */\n\t\ts_load_dlt = new_stmt(cstate, BPF_LD|BPF_W|BPF_ABS);\n\t\ts_load_dlt->s.k = 4;\n\n\t\tb = new_block(cstate, JMP(BPF_JEQ));\n\n\t\tb->stmts = s_load_dlt;\n\t\tb->s.k = SWAPLONG(DLT_IEEE802_11);\n\t}\n\telse\n\t{\n\t\tb = NULL;\n\t}\n\n\treturn b;\n}",
          "fn_code_pos": [
            [
              2966,
              0
            ],
            [
              2990,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ppi_dlt_check",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct slist *\ngen_abs_offset_varpart(compiler_state_t *cstate, bpf_abs_offset *off)\n{\n\tstruct slist *s;\n\n\tif (off->is_variable) {\n\t\tif (off->reg == -1) {\n\t\t\t/*\n\t\t\t * We haven't yet assigned a register for the\n\t\t\t * variable part of the offset of the link-layer\n\t\t\t * header; allocate one.\n\t\t\t */\n\t\t\toff->reg = alloc_reg(cstate);\n\t\t}\n\n\t\t/*\n\t\t * Load the register containing the variable part of the\n\t\t * offset of the link-layer header into the X register.\n\t\t */\n\t\ts = new_stmt(cstate, BPF_LDX|BPF_MEM);\n\t\ts->s.k = off->reg;\n\t\treturn s;\n\t} else {\n\t\t/*\n\t\t * That offset isn't variable, there's no variable part,\n\t\t * so we don't need to generate any code.\n\t\t */\n\t\treturn NULL;\n\t}\n}",
          "fn_code_pos": [
            [
              3005,
              0
            ],
            [
              3034,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_abs_offset_varpart",
            "parameters": {
              "cstate": "compiler_state_t",
              "off": "bpf_abs_offset"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static bpf_u_int32\nethertype_to_ppptype(bpf_u_int32 ll_proto)\n{\n\tswitch (ll_proto) {\n\n\tcase ETHERTYPE_IP:\n\t\tll_proto = PPP_IP;\n\t\tbreak;\n\n\tcase ETHERTYPE_IPV6:\n\t\tll_proto = PPP_IPV6;\n\t\tbreak;\n\n\tcase ETHERTYPE_DN:\n\t\tll_proto = PPP_DECNET;\n\t\tbreak;\n\n\tcase ETHERTYPE_ATALK:\n\t\tll_proto = PPP_APPLE;\n\t\tbreak;\n\n\tcase ETHERTYPE_NS:\n\t\tll_proto = PPP_NS;\n\t\tbreak;\n\n\tcase LLCSAP_ISONS:\n\t\tll_proto = PPP_OSI;\n\t\tbreak;\n\n\tcase LLCSAP_8021D:\n\t\t/*\n\t\t * I'm assuming the \"Bridging PDU\"s that go\n\t\t * over PPP are Spanning Tree Protocol\n\t\t * Bridging PDUs.\n\t\t */\n\t\tll_proto = PPP_BRPDU;\n\t\tbreak;\n\n\tcase LLCSAP_IPX:\n\t\tll_proto = PPP_IPX;\n\t\tbreak;\n\t}\n\treturn (ll_proto);\n}",
          "fn_code_pos": [
            [
              3039,
              0
            ],
            [
              3082,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ethertype_to_ppptype",
            "parameters": {
              "ll_proto": "bpf_u_int32"
            },
            "return_type": "bpf_u_int32"
          }
        },
        {
          "fn_code": "static struct block *\ngen_prevlinkhdr_check(compiler_state_t *cstate)\n{\n\tstruct block *b0;\n\n\tif (cstate->is_geneve)\n\t\treturn gen_geneve_ll_check(cstate);\n\n\tswitch (cstate->prevlinktype) {\n\n\tcase DLT_SUNATM:\n\t\t/*\n\t\t * This is LANE-encapsulated Ethernet; check that the LANE\n\t\t * packet doesn't begin with an LE Control marker, i.e.\n\t\t * that it's data, not a control message.\n\t\t *\n\t\t * (We've already generated a test for LANE.)\n\t\t */\n\t\tb0 = gen_cmp(cstate, OR_PREVLINKHDR, SUNATM_PKT_BEGIN_POS, BPF_H, 0xFF00);\n\t\tgen_not(b0);\n\t\treturn b0;\n\n\tdefault:\n\t\t/*\n\t\t * No such tests are necessary.\n\t\t */\n\t\treturn NULL;\n\t}\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              3090,
              0
            ],
            [
              3119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_prevlinkhdr_check",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)\n{\n\tstruct block *b0, *b1, *b2;\n\tconst char *description;\n\n\t/* are we checking MPLS-encapsulated packets? */\n\tif (cstate->label_stack_depth > 0)\n\t\treturn gen_mpls_linktype(cstate, ll_proto);\n\n\tswitch (cstate->linktype) {\n\n\tcase DLT_EN10MB:\n\tcase DLT_NETANALYZER:\n\tcase DLT_NETANALYZER_TRANSPARENT:\n\t\t/* Geneve has an EtherType regardless of whether there is an\n\t\t * L2 header. */\n\t\tif (!cstate->is_geneve)\n\t\t\tb0 = gen_prevlinkhdr_check(cstate);\n\t\telse\n\t\t\tb0 = NULL;\n\n\t\tb1 = gen_ether_linktype(cstate, ll_proto);\n\t\tif (b0 != NULL)\n\t\t\tgen_and(b0, b1);\n\t\treturn b1;\n\t\t/*NOTREACHED*/\n\n\tcase DLT_C_HDLC:\n\t\tswitch (ll_proto) {\n\n\t\tcase LLCSAP_ISONS:\n\t\t\tll_proto = (ll_proto << 8 | LLCSAP_ISONS);\n\t\t\t/* fall through */\n\n\t\tdefault:\n\t\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);\n\t\t\t/*NOTREACHED*/\n\t\t}\n\n\tcase DLT_IEEE802_11:\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_IEEE802_11_RADIO:\n\tcase DLT_PPI:\n\t\t/*\n\t\t * Check that we have a data frame.\n\t\t */\n\t\tb0 = gen_check_802_11_data_frame(cstate);\n\n\t\t/*\n\t\t * Now check for the specified link-layer type.\n\t\t */\n\t\tb1 = gen_llc_linktype(cstate, ll_proto);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\t\t/*NOTREACHED*/\n\n\tcase DLT_FDDI:\n\t\t/*\n\t\t * XXX - check for LLC frames.\n\t\t */\n\t\treturn gen_llc_linktype(cstate, ll_proto);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_IEEE802:\n\t\t/*\n\t\t * XXX - check for LLC PDUs, as per IEEE 802.5.\n\t\t */\n\t\treturn gen_llc_linktype(cstate, ll_proto);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_ATM_RFC1483:\n\tcase DLT_ATM_CLIP:\n\tcase DLT_IP_OVER_FC:\n\t\treturn gen_llc_linktype(cstate, ll_proto);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_SUNATM:\n\t\t/*\n\t\t * Check for an LLC-encapsulated version of this protocol;\n\t\t * if we were checking for LANE, linktype would no longer\n\t\t * be DLT_SUNATM.\n\t\t *\n\t\t * Check for LLC encapsulation and then check the protocol.\n\t\t */\n\t\tb0 = gen_atmfield_code_internal(cstate, A_PROTOTYPE, PT_LLC, BPF_JEQ, 0);\n\t\tb1 = gen_llc_linktype(cstate, ll_proto);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\t\t/*NOTREACHED*/\n\n\tcase DLT_LINUX_SLL:\n\t\treturn gen_linux_sll_linktype(cstate, ll_proto);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_SLIP:\n\tcase DLT_SLIP_BSDOS:\n\tcase DLT_RAW:\n\t\t/*\n\t\t * These types don't provide any type field; packets\n\t\t * are always IPv4 or IPv6.\n\t\t *\n\t\t * XXX - for IPv4, check for a version number of 4, and,\n\t\t * for IPv6, check for a version number of 6?\n\t\t */\n\t\tswitch (ll_proto) {\n\n\t\tcase ETHERTYPE_IP:\n\t\t\t/* Check for a version number of 4. */\n\t\t\treturn gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, 0x40, 0xF0);\n\n\t\tcase ETHERTYPE_IPV6:\n\t\t\t/* Check for a version number of 6. */\n\t\t\treturn gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, 0x60, 0xF0);\n\n\t\tdefault:\n\t\t\treturn gen_false(cstate);\t/* always false */\n\t\t}\n\t\t/*NOTREACHED*/\n\n\tcase DLT_IPV4:\n\t\t/*\n\t\t * Raw IPv4, so no type field.\n\t\t */\n\t\tif (ll_proto == ETHERTYPE_IP)\n\t\t\treturn gen_true(cstate);\t/* always true */\n\n\t\t/* Checking for something other than IPv4; always false */\n\t\treturn gen_false(cstate);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_IPV6:\n\t\t/*\n\t\t * Raw IPv6, so no type field.\n\t\t */\n\t\tif (ll_proto == ETHERTYPE_IPV6)\n\t\t\treturn gen_true(cstate);\t/* always true */\n\n\t\t/* Checking for something other than IPv6; always false */\n\t\treturn gen_false(cstate);\n\t\t/*NOTREACHED*/\n\n\tcase DLT_PPP:\n\tcase DLT_PPP_PPPD:\n\tcase DLT_PPP_SERIAL:\n\tcase DLT_PPP_ETHER:\n\t\t/*\n\t\t * We use Ethernet protocol types inside libpcap;\n\t\t * map them to the corresponding PPP protocol types.\n\t\t */\n\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H,\n\t\t    ethertype_to_ppptype(ll_proto));\n\t\t/*NOTREACHED*/\n\n\tcase DLT_PPP_BSDOS:\n\t\t/*\n\t\t * We use Ethernet protocol types inside libpcap;\n\t\t * map them to the corresponding PPP protocol types.\n\t\t */\n\t\tswitch (ll_proto) {\n\n\t\tcase ETHERTYPE_IP:\n\t\t\t/*\n\t\t\t * Also check for Van Jacobson-compressed IP.\n\t\t\t * XXX - do this for other forms of PPP?\n\t\t\t */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, PPP_IP);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, PPP_VJC);\n\t\t\tgen_or(b0, b1);\n\t\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, PPP_VJNC);\n\t\t\tgen_or(b1, b0);\n\t\t\treturn b0;\n\n\t\tdefault:\n\t\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H,\n\t\t\t    ethertype_to_ppptype(ll_proto));\n\t\t}\n\t\t/*NOTREACHED*/\n\n\tcase DLT_NULL:\n\tcase DLT_LOOP:\n\tcase DLT_ENC:\n\t\tswitch (ll_proto) {\n\n\t\tcase ETHERTYPE_IP:\n\t\t\treturn (gen_loopback_linktype(cstate, AF_INET));\n\n\t\tcase ETHERTYPE_IPV6:\n\t\t\t/*\n\t\t\t * AF_ values may, unfortunately, be platform-\n\t\t\t * dependent; AF_INET isn't, because everybody\n\t\t\t * used 4.2BSD's value, but AF_INET6 is, because\n\t\t\t * 4.2BSD didn't have a value for it (given that\n\t\t\t * IPv6 didn't exist back in the early 1980's),\n\t\t\t * and they all picked their own values.\n\t\t\t *\n\t\t\t * This means that, if we're reading from a\n\t\t\t * savefile, we need to check for all the\n\t\t\t * possible values.\n\t\t\t *\n\t\t\t * If we're doing a live capture, we only need\n\t\t\t * to check for this platform's value; however,\n\t\t\t * Npcap uses 24, which isn't Windows's AF_INET6\n\t\t\t * value.  (Given the multiple different values,\n\t\t\t * programs that read pcap files shouldn't be\n\t\t\t * checking for their platform's AF_INET6 value\n\t\t\t * anyway, they should check for all of the\n\t\t\t * possible values. and they might as well do\n\t\t\t * that even for live captures.)\n\t\t\t */\n\t\t\tif (cstate->bpf_pcap->rfile != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Savefile - check for all three\n\t\t\t\t * possible IPv6 values.\n\t\t\t\t */\n\t\t\t\tb0 = gen_loopback_linktype(cstate, BSD_AFNUM_INET6_BSD);\n\t\t\t\tb1 = gen_loopback_linktype(cstate, BSD_AFNUM_INET6_FREEBSD);\n\t\t\t\tgen_or(b0, b1);\n\t\t\t\tb0 = gen_loopback_linktype(cstate, BSD_AFNUM_INET6_DARWIN);\n\t\t\t\tgen_or(b0, b1);\n\t\t\t\treturn (b1);\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Live capture, so we only need to\n\t\t\t\t * check for the value used on this\n\t\t\t\t * platform.\n\t\t\t\t */\n#ifdef _WIN32\n\t\t\t\t/*\n\t\t\t\t * Npcap doesn't use Windows's AF_INET6,\n\t\t\t\t * as that collides with AF_IPX on\n\t\t\t\t * some BSDs (both have the value 23).\n\t\t\t\t * Instead, it uses 24.\n\t\t\t\t */\n\t\t\t\treturn (gen_loopback_linktype(cstate, 24));\n#else /* _WIN32 */\n#ifdef AF_INET6\n\t\t\t\treturn (gen_loopback_linktype(cstate, AF_INET6));\n#else /* AF_INET6 */\n\t\t\t\t/*\n\t\t\t\t * I guess this platform doesn't support\n\t\t\t\t * IPv6, so we just reject all packets.\n\t\t\t\t */\n\t\t\t\treturn gen_false(cstate);\n#endif /* AF_INET6 */\n#endif /* _WIN32 */\n\t\t\t}\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Not a type on which we support filtering.\n\t\t\t * XXX - support those that have AF_ values\n\t\t\t * #defined on this platform, at least?\n\t\t\t */\n\t\t\treturn gen_false(cstate);\n\t\t}\n\n#ifdef HAVE_NET_PFVAR_H\n\tcase DLT_PFLOG:\n\t\t/*\n\t\t * af field is host byte order in contrast to the rest of\n\t\t * the packet.\n\t\t */\n\t\tif (ll_proto == ETHERTYPE_IP)\n\t\t\treturn (gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, af),\n\t\t\t    BPF_B, AF_INET));\n\t\telse if (ll_proto == ETHERTYPE_IPV6)\n\t\t\treturn (gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, af),\n\t\t\t    BPF_B, AF_INET6));\n\t\telse\n\t\t\treturn gen_false(cstate);\n\t\t/*NOTREACHED*/\n#endif /* HAVE_NET_PFVAR_H */\n\n\tcase DLT_ARCNET:\n\tcase DLT_ARCNET_LINUX:\n\t\t/*\n\t\t * XXX should we check for first fragment if the protocol\n\t\t * uses PHDS?\n\t\t */\n\t\tswitch (ll_proto) {\n\n\t\tdefault:\n\t\t\treturn gen_false(cstate);\n\n\t\tcase ETHERTYPE_IPV6:\n\t\t\treturn (gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t\tARCTYPE_INET6));\n\n\t\tcase ETHERTYPE_IP:\n\t\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t    ARCTYPE_IP);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t    ARCTYPE_IP_OLD);\n\t\t\tgen_or(b0, b1);\n\t\t\treturn (b1);\n\n\t\tcase ETHERTYPE_ARP:\n\t\t\tb0 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t    ARCTYPE_ARP);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t    ARCTYPE_ARP_OLD);\n\t\t\tgen_or(b0, b1);\n\t\t\treturn (b1);\n\n\t\tcase ETHERTYPE_REVARP:\n\t\t\treturn (gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t    ARCTYPE_REVARP));\n\n\t\tcase ETHERTYPE_ATALK:\n\t\t\treturn (gen_cmp(cstate, OR_LINKTYPE, 0, BPF_B,\n\t\t\t    ARCTYPE_ATALK));\n\t\t}\n\t\t/*NOTREACHED*/\n\n\tcase DLT_LTALK:\n\t\tswitch (ll_proto) {\n\t\tcase ETHERTYPE_ATALK:\n\t\t\treturn gen_true(cstate);\n\t\tdefault:\n\t\t\treturn gen_false(cstate);\n\t\t}\n\t\t/*NOTREACHED*/\n\n\tcase DLT_FRELAY:\n\t\t/*\n\t\t * XXX - assumes a 2-byte Frame Relay header with\n\t\t * DLCI and flags.  What if the address is longer?\n\t\t */\n\t\tswitch (ll_proto) {\n\n\t\tcase ETHERTYPE_IP:\n\t\t\t/*\n\t\t\t * Check for the special NLPID for IP.\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | 0xcc);\n\n\t\tcase ETHERTYPE_IPV6:\n\t\t\t/*\n\t\t\t * Check for the special NLPID for IPv6.\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | 0x8e);\n\n\t\tcase LLCSAP_ISONS:\n\t\t\t/*\n\t\t\t * Check for several OSI protocols.\n\t\t\t *\n\t\t\t * Frame Relay packets typically have an OSI\n\t\t\t * NLPID at the beginning; we check for each\n\t\t\t * of them.\n\t\t\t *\n\t\t\t * What we check for is the NLPID and a frame\n\t\t\t * control field of UI, i.e. 0x03 followed\n\t\t\t * by the NLPID.\n\t\t\t */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | ISO8473_CLNP);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | ISO9542_ESIS);\n\t\t\tb2 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | ISO10589_ISIS);\n\t\t\tgen_or(b1, b2);\n\t\t\tgen_or(b0, b2);\n\t\t\treturn b2;\n\n\t\tdefault:\n\t\t\treturn gen_false(cstate);\n\t\t}\n\t\t/*NOTREACHED*/\n\n\tcase DLT_MFR:\n\t\tbpf_error(cstate, \"Multi-link Frame Relay link-layer type filtering not implemented\");\n\n        case DLT_JUNIPER_MFR:\n        case DLT_JUNIPER_MLFR:\n        case DLT_JUNIPER_MLPPP:\n\tcase DLT_JUNIPER_ATM1:\n\tcase DLT_JUNIPER_ATM2:\n\tcase DLT_JUNIPER_PPPOE:\n\tcase DLT_JUNIPER_PPPOE_ATM:\n        case DLT_JUNIPER_GGSN:\n        case DLT_JUNIPER_ES:\n        case DLT_JUNIPER_MONITOR:\n        case DLT_JUNIPER_SERVICES:\n        case DLT_JUNIPER_ETHER:\n        case DLT_JUNIPER_PPP:\n        case DLT_JUNIPER_FRELAY:\n        case DLT_JUNIPER_CHDLC:\n        case DLT_JUNIPER_VP:\n        case DLT_JUNIPER_ST:\n        case DLT_JUNIPER_ISM:\n        case DLT_JUNIPER_VS:\n        case DLT_JUNIPER_SRX_E2E:\n        case DLT_JUNIPER_FIBRECHANNEL:\n\tcase DLT_JUNIPER_ATM_CEMIC:\n\n\t\t/* just lets verify the magic number for now -\n\t\t * on ATM we may have up to 6 different encapsulations on the wire\n\t\t * and need a lot of heuristics to figure out that the payload\n\t\t * might be;\n\t\t *\n\t\t * FIXME encapsulation specific BPF_ filters\n\t\t */\n\t\treturn gen_mcmp(cstate, OR_LINKHDR, 0, BPF_W, 0x4d474300, 0xffffff00); /* compare the magic number */\n\n\tcase DLT_BACNET_MS_TP:\n\t\treturn gen_mcmp(cstate, OR_LINKHDR, 0, BPF_W, 0x55FF0000, 0xffff0000);\n\n\tcase DLT_IPNET:\n\t\treturn gen_ipnet_linktype(cstate, ll_proto);\n\n\tcase DLT_LINUX_IRDA:\n\t\tbpf_error(cstate, \"IrDA link-layer type filtering not implemented\");\n\n\tcase DLT_DOCSIS:\n\t\tbpf_error(cstate, \"DOCSIS link-layer type filtering not implemented\");\n\n\tcase DLT_MTP2:\n\tcase DLT_MTP2_WITH_PHDR:\n\t\tbpf_error(cstate, \"MTP2 link-layer type filtering not implemented\");\n\n\tcase DLT_ERF:\n\t\tbpf_error(cstate, \"ERF link-layer type filtering not implemented\");\n\n\tcase DLT_PFSYNC:\n\t\tbpf_error(cstate, \"PFSYNC link-layer type filtering not implemented\");\n\n\tcase DLT_LINUX_LAPD:\n\t\tbpf_error(cstate, \"LAPD link-layer type filtering not implemented\");\n\n\tcase DLT_USB_FREEBSD:\n\tcase DLT_USB_LINUX:\n\tcase DLT_USB_LINUX_MMAPPED:\n\tcase DLT_USBPCAP:\n\t\tbpf_error(cstate, \"USB link-layer type filtering not implemented\");\n\n\tcase DLT_BLUETOOTH_HCI_H4:\n\tcase DLT_BLUETOOTH_HCI_H4_WITH_PHDR:\n\t\tbpf_error(cstate, \"Bluetooth link-layer type filtering not implemented\");\n\n\tcase DLT_CAN20B:\n\tcase DLT_CAN_SOCKETCAN:\n\t\tbpf_error(cstate, \"CAN link-layer type filtering not implemented\");\n\n\tcase DLT_IEEE802_15_4:\n\tcase DLT_IEEE802_15_4_LINUX:\n\tcase DLT_IEEE802_15_4_NONASK_PHY:\n\tcase DLT_IEEE802_15_4_NOFCS:\n\tcase DLT_IEEE802_15_4_TAP:\n\t\tbpf_error(cstate, \"IEEE 802.15.4 link-layer type filtering not implemented\");\n\n\tcase DLT_IEEE802_16_MAC_CPS_RADIO:\n\t\tbpf_error(cstate, \"IEEE 802.16 link-layer type filtering not implemented\");\n\n\tcase DLT_SITA:\n\t\tbpf_error(cstate, \"SITA link-layer type filtering not implemented\");\n\n\tcase DLT_RAIF1:\n\t\tbpf_error(cstate, \"RAIF1 link-layer type filtering not implemented\");\n\n\tcase DLT_IPMB:\n\t\tbpf_error(cstate, \"IPMB link-layer type filtering not implemented\");\n\n\tcase DLT_AX25_KISS:\n\t\tbpf_error(cstate, \"AX.25 link-layer type filtering not implemented\");\n\n\tcase DLT_NFLOG:\n\t\t/* Using the fixed-size NFLOG header it is possible to tell only\n\t\t * the address family of the packet, other meaningful data is\n\t\t * either missing or behind TLVs.\n\t\t */\n\t\tbpf_error(cstate, \"NFLOG link-layer type filtering not implemented\");\n\n\tdefault:\n\t\t/*\n\t\t * Does this link-layer header type have a field\n\t\t * indicating the type of the next protocol?  If\n\t\t * so, off_linktype.constant_part will be the offset of that\n\t\t * field in the packet; if not, it will be OFFSET_NOT_SET.\n\t\t */\n\t\tif (cstate->off_linktype.constant_part != OFFSET_NOT_SET) {\n\t\t\t/*\n\t\t\t * Yes; assume it's an Ethernet type.  (If\n\t\t\t * it's not, it needs to be handled specially\n\t\t\t * above.)\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LINKTYPE, 0, BPF_H, ll_proto);\n\t\t\t/*NOTREACHED */\n\t\t} else {\n\t\t\t/*\n\t\t\t * No; report an error.\n\t\t\t */\n\t\t\tdescription = pcap_datalink_val_to_description(cstate->linktype);\n\t\t\tif (description != NULL) {\n\t\t\t\tbpf_error(cstate, \"%s link-layer type filtering not implemented\",\n\t\t\t\t    description);\n\t\t\t} else {\n\t\t\t\tbpf_error(cstate, \"DLT %u link-layer type filtering not implemented\",\n\t\t\t\t    cstate->linktype);\n\t\t\t}\n\t\t\t/*NOTREACHED */\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              3136,
              0
            ],
            [
              3637,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_linktype",
            "parameters": {
              "cstate": "compiler_state_t",
              "ll_proto": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_snap(compiler_state_t *cstate, bpf_u_int32 orgcode, bpf_u_int32 ptype)\n{\n\tu_char snapblock[8];\n\n\tsnapblock[0] = LLCSAP_SNAP;\t\t/* DSAP = SNAP */\n\tsnapblock[1] = LLCSAP_SNAP;\t\t/* SSAP = SNAP */\n\tsnapblock[2] = 0x03;\t\t\t/* control = UI */\n\tsnapblock[3] = (u_char)(orgcode >> 16);\t/* upper 8 bits of organization code */\n\tsnapblock[4] = (u_char)(orgcode >> 8);\t/* middle 8 bits of organization code */\n\tsnapblock[5] = (u_char)(orgcode >> 0);\t/* lower 8 bits of organization code */\n\tsnapblock[6] = (u_char)(ptype >> 8);\t/* upper 8 bits of protocol type */\n\tsnapblock[7] = (u_char)(ptype >> 0);\t/* lower 8 bits of protocol type */\n\treturn gen_bcmp(cstate, OR_LLC, 0, 8, snapblock);\n}",
          "fn_code_pos": [
            [
              3646,
              0
            ],
            [
              3660,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_snap",
            "parameters": {
              "cstate": "compiler_state_t",
              "orgcode": "bpf_u_int32",
              "ptype": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_llc_internal(compiler_state_t *cstate)\n{\n\tstruct block *b0, *b1;\n\n\tswitch (cstate->linktype) {\n\n\tcase DLT_EN10MB:\n\t\t/*\n\t\t * We check for an Ethernet type field less than\n\t\t * 1500, which means it's an 802.3 length field.\n\t\t */\n\t\tb0 = gen_cmp_gt(cstate, OR_LINKTYPE, 0, BPF_H, ETHERMTU);\n\t\tgen_not(b0);\n\n\t\t/*\n\t\t * Now check for the purported DSAP and SSAP not being\n\t\t * 0xFF, to rule out NetWare-over-802.3.\n\t\t */\n\t\tb1 = gen_cmp(cstate, OR_LLC, 0, BPF_H, 0xFFFF);\n\t\tgen_not(b1);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase DLT_SUNATM:\n\t\t/*\n\t\t * We check for LLC traffic.\n\t\t */\n\t\tb0 = gen_atmtype_llc(cstate);\n\t\treturn b0;\n\n\tcase DLT_IEEE802:\t/* Token Ring */\n\t\t/*\n\t\t * XXX - check for LLC frames.\n\t\t */\n\t\treturn gen_true(cstate);\n\n\tcase DLT_FDDI:\n\t\t/*\n\t\t * XXX - check for LLC frames.\n\t\t */\n\t\treturn gen_true(cstate);\n\n\tcase DLT_ATM_RFC1483:\n\t\t/*\n\t\t * For LLC encapsulation, these are defined to have an\n\t\t * 802.2 LLC header.\n\t\t *\n\t\t * For VC encapsulation, they don't, but there's no\n\t\t * way to check for that; the protocol used on the VC\n\t\t * is negotiated out of band.\n\t\t */\n\t\treturn gen_true(cstate);\n\n\tcase DLT_IEEE802_11:\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_PPI:\n\t\t/*\n\t\t * Check that we have a data frame.\n\t\t */\n\t\tb0 = gen_check_802_11_data_frame(cstate);\n\t\treturn b0;\n\n\tdefault:\n\t\tbpf_error(cstate, \"'llc' not supported for linktype %d\", cstate->linktype);\n\t\t/*NOTREACHED*/\n\t}\n}",
          "fn_code_pos": [
            [
              3665,
              0
            ],
            [
              3734,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_internal",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_llc(compiler_state_t *cstate)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\treturn gen_llc_internal(cstate);\n}",
          "fn_code_pos": [
            [
              3736,
              0
            ],
            [
              3747,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_llc_i(compiler_state_t *cstate)\n{\n\tstruct block *b0, *b1;\n\tstruct slist *s;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Check whether this is an LLC frame.\n\t */\n\tb0 = gen_llc_internal(cstate);\n\n\t/*\n\t * Load the control byte and test the low-order bit; it must\n\t * be clear for I frames.\n\t */\n\ts = gen_load_a(cstate, OR_LLC, 2, BPF_B);\n\tb1 = new_block(cstate, JMP(BPF_JSET));\n\tb1->s.k = 0x01;\n\tb1->stmts = s;\n\tgen_not(b1);\n\tgen_and(b0, b1);\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              3749,
              0
            ],
            [
              3778,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_i",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_llc_s(compiler_state_t *cstate)\n{\n\tstruct block *b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Check whether this is an LLC frame.\n\t */\n\tb0 = gen_llc_internal(cstate);\n\n\t/*\n\t * Now compare the low-order 2 bit of the control byte against\n\t * the appropriate value for S frames.\n\t */\n\tb1 = gen_mcmp(cstate, OR_LLC, 2, BPF_B, LLC_S_FMT, 0x03);\n\tgen_and(b0, b1);\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              3780,
              0
            ],
            [
              3804,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_s",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_llc_u(compiler_state_t *cstate)\n{\n\tstruct block *b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Check whether this is an LLC frame.\n\t */\n\tb0 = gen_llc_internal(cstate);\n\n\t/*\n\t * Now compare the low-order 2 bit of the control byte against\n\t * the appropriate value for U frames.\n\t */\n\tb1 = gen_mcmp(cstate, OR_LLC, 2, BPF_B, LLC_U_FMT, 0x03);\n\tgen_and(b0, b1);\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              3806,
              0
            ],
            [
              3830,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_u",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_llc_s_subtype(compiler_state_t *cstate, bpf_u_int32 subtype)\n{\n\tstruct block *b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Check whether this is an LLC frame.\n\t */\n\tb0 = gen_llc_internal(cstate);\n\n\t/*\n\t * Now check for an S frame with the appropriate type.\n\t */\n\tb1 = gen_mcmp(cstate, OR_LLC, 2, BPF_B, subtype, LLC_S_CMD_MASK);\n\tgen_and(b0, b1);\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              3832,
              0
            ],
            [
              3855,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_s_subtype",
            "parameters": {
              "cstate": "compiler_state_t",
              "subtype": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_llc_u_subtype(compiler_state_t *cstate, bpf_u_int32 subtype)\n{\n\tstruct block *b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Check whether this is an LLC frame.\n\t */\n\tb0 = gen_llc_internal(cstate);\n\n\t/*\n\t * Now check for a U frame with the appropriate type.\n\t */\n\tb1 = gen_mcmp(cstate, OR_LLC, 2, BPF_B, subtype, LLC_U_CMD_MASK);\n\tgen_and(b0, b1);\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              3857,
              0
            ],
            [
              3880,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_u_subtype",
            "parameters": {
              "cstate": "compiler_state_t",
              "subtype": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_llc_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)\n{\n\t/*\n\t * XXX - handle token-ring variable-length header.\n\t */\n\tswitch (ll_proto) {\n\n\tcase LLCSAP_IP:\n\tcase LLCSAP_ISONS:\n\tcase LLCSAP_NETBEUI:\n\t\t/*\n\t\t * XXX - should we check both the DSAP and the\n\t\t * SSAP, like this, or should we check just the\n\t\t * DSAP, as we do for other SAP values?\n\t\t */\n\t\treturn gen_cmp(cstate, OR_LLC, 0, BPF_H, (bpf_u_int32)\n\t\t\t     ((ll_proto << 8) | ll_proto));\n\n\tcase LLCSAP_IPX:\n\t\t/*\n\t\t * XXX - are there ever SNAP frames for IPX on\n\t\t * non-Ethernet 802.x networks?\n\t\t */\n\t\treturn gen_cmp(cstate, OR_LLC, 0, BPF_B, LLCSAP_IPX);\n\n\tcase ETHERTYPE_ATALK:\n\t\t/*\n\t\t * 802.2-encapsulated ETHERTYPE_ATALK packets are\n\t\t * SNAP packets with an organization code of\n\t\t * 0x080007 (Apple, for Appletalk) and a protocol\n\t\t * type of ETHERTYPE_ATALK (Appletalk).\n\t\t *\n\t\t * XXX - check for an organization code of\n\t\t * encapsulated Ethernet as well?\n\t\t */\n\t\treturn gen_snap(cstate, 0x080007, ETHERTYPE_ATALK);\n\n\tdefault:\n\t\t/*\n\t\t * XXX - we don't have to check for IPX 802.3\n\t\t * here, but should we check for the IPX Ethertype?\n\t\t */\n\t\tif (ll_proto <= ETHERMTU) {\n\t\t\t/*\n\t\t\t * This is an LLC SAP value, so check\n\t\t\t * the DSAP.\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LLC, 0, BPF_B, ll_proto);\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is an Ethernet type; we assume that it's\n\t\t\t * unlikely that it'll appear in the right place\n\t\t\t * at random, and therefore check only the\n\t\t\t * location that would hold the Ethernet type\n\t\t\t * in a SNAP frame with an organization code of\n\t\t\t * 0x000000 (encapsulated Ethernet).\n\t\t\t *\n\t\t\t * XXX - if we were to check for the SNAP DSAP and\n\t\t\t * LSAP, as per XXX, and were also to check for an\n\t\t\t * organization code of 0x000000 (encapsulated\n\t\t\t * Ethernet), we'd do\n\t\t\t *\n\t\t\t *\treturn gen_snap(cstate, 0x000000, ll_proto);\n\t\t\t *\n\t\t\t * here; for now, we don't, as per the above.\n\t\t\t * I don't know whether it's worth the extra CPU\n\t\t\t * time to do the right check or not.\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LLC, 6, BPF_H, ll_proto);\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              3894,
              0
            ],
            [
              3966,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_linktype",
            "parameters": {
              "cstate": "compiler_state_t",
              "ll_proto": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_hostop(compiler_state_t *cstate, bpf_u_int32 addr, bpf_u_int32 mask,\n    int dir, bpf_u_int32 ll_proto, u_int src_off, u_int dst_off)\n{\n\tstruct block *b0, *b1;\n\tu_int offset;\n\n\tswitch (dir) {\n\n\tcase Q_SRC:\n\t\toffset = src_off;\n\t\tbreak;\n\n\tcase Q_DST:\n\t\toffset = dst_off;\n\t\tbreak;\n\n\tcase Q_AND:\n\t\tb0 = gen_hostop(cstate, addr, mask, Q_SRC, ll_proto, src_off, dst_off);\n\t\tb1 = gen_hostop(cstate, addr, mask, Q_DST, ll_proto, src_off, dst_off);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_hostop(cstate, addr, mask, Q_SRC, ll_proto, src_off, dst_off);\n\t\tb1 = gen_hostop(cstate, addr, mask, Q_DST, ll_proto, src_off, dst_off);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is not a valid qualifier for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is not a valid qualifier for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tabort();\n\t\t/*NOTREACHED*/\n\t}\n\tb0 = gen_linktype(cstate, ll_proto);\n\tb1 = gen_mcmp(cstate, OR_LINKPL, offset, BPF_W, addr, mask);\n\tgen_and(b0, b1);\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              3968,
              0
            ],
            [
              4030,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_hostop",
            "parameters": {
              "cstate": "compiler_state_t",
              "addr": "bpf_u_int32",
              "mask": "bpf_u_int32",
              "dir": "int",
              "ll_proto": "bpf_u_int32",
              "src_off": "u_int",
              "dst_off": "u_int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_hostop6(compiler_state_t *cstate, struct in6_addr *addr,\n    struct in6_addr *mask, int dir, bpf_u_int32 ll_proto, u_int src_off,\n    u_int dst_off)\n{\n\tstruct block *b0, *b1;\n\tu_int offset;\n\tuint32_t *a, *m;\n\n\tswitch (dir) {\n\n\tcase Q_SRC:\n\t\toffset = src_off;\n\t\tbreak;\n\n\tcase Q_DST:\n\t\toffset = dst_off;\n\t\tbreak;\n\n\tcase Q_AND:\n\t\tb0 = gen_hostop6(cstate, addr, mask, Q_SRC, ll_proto, src_off, dst_off);\n\t\tb1 = gen_hostop6(cstate, addr, mask, Q_DST, ll_proto, src_off, dst_off);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_hostop6(cstate, addr, mask, Q_SRC, ll_proto, src_off, dst_off);\n\t\tb1 = gen_hostop6(cstate, addr, mask, Q_DST, ll_proto, src_off, dst_off);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is not a valid qualifier for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is not a valid qualifier for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tabort();\n\t\t/*NOTREACHED*/\n\t}\n\t/* this order is important */\n\ta = (uint32_t *)addr;\n\tm = (uint32_t *)mask;\n\tb1 = gen_mcmp(cstate, OR_LINKPL, offset + 12, BPF_W, ntohl(a[3]), ntohl(m[3]));\n\tb0 = gen_mcmp(cstate, OR_LINKPL, offset + 8, BPF_W, ntohl(a[2]), ntohl(m[2]));\n\tgen_and(b0, b1);\n\tb0 = gen_mcmp(cstate, OR_LINKPL, offset + 4, BPF_W, ntohl(a[1]), ntohl(m[1]));\n\tgen_and(b0, b1);\n\tb0 = gen_mcmp(cstate, OR_LINKPL, offset + 0, BPF_W, ntohl(a[0]), ntohl(m[0]));\n\tgen_and(b0, b1);\n\tb0 = gen_linktype(cstate, ll_proto);\n\tgen_and(b0, b1);\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              4033,
              0
            ],
            [
              4106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_hostop6",
            "parameters": {
              "cstate": "compiler_state_t",
              "addr": "struct in6_addr",
              "mask": "struct in6_addr",
              "dir": "int",
              "ll_proto": "bpf_u_int32",
              "src_off": "u_int",
              "dst_off": "u_int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_ehostop(compiler_state_t *cstate, const u_char *eaddr, int dir)\n{\n\tregister struct block *b0, *b1;\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 6, 6, eaddr);\n\n\tcase Q_DST:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 0, 6, eaddr);\n\n\tcase Q_AND:\n\t\tb0 = gen_ehostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_ehostop(cstate, eaddr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_ehostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_ehostop(cstate, eaddr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are only supported on 802.11 with 802.11 headers\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are only supported on 802.11 with 802.11 headers\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are only supported on 802.11 with 802.11 headers\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are only supported on 802.11 with 802.11 headers\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is only supported on 802.11 with 802.11 headers\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is only supported on 802.11 with 802.11 headers\");\n\t\t/*NOTREACHED*/\n\t}\n\tabort();\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              4109,
              0
            ],
            [
              4160,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ehostop",
            "parameters": {
              "cstate": "compiler_state_t",
              "eaddr": "u_char",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_fhostop(compiler_state_t *cstate, const u_char *eaddr, int dir)\n{\n\tstruct block *b0, *b1;\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 6 + 1 + cstate->pcap_fddipad, 6, eaddr);\n\n\tcase Q_DST:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 0 + 1 + cstate->pcap_fddipad, 6, eaddr);\n\n\tcase Q_AND:\n\t\tb0 = gen_fhostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_fhostop(cstate, eaddr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_fhostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_fhostop(cstate, eaddr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\t}\n\tabort();\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              4165,
              0
            ],
            [
              4216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_fhostop",
            "parameters": {
              "cstate": "compiler_state_t",
              "eaddr": "u_char",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_thostop(compiler_state_t *cstate, const u_char *eaddr, int dir)\n{\n\tregister struct block *b0, *b1;\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 8, 6, eaddr);\n\n\tcase Q_DST:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 2, 6, eaddr);\n\n\tcase Q_AND:\n\t\tb0 = gen_thostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_thostop(cstate, eaddr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_thostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_thostop(cstate, eaddr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\t}\n\tabort();\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              4221,
              0
            ],
            [
              4272,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_thostop",
            "parameters": {
              "cstate": "compiler_state_t",
              "eaddr": "u_char",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_wlanhostop(compiler_state_t *cstate, const u_char *eaddr, int dir)\n{\n\tregister struct block *b0, *b1, *b2;\n\tregister struct slist *s;\n\n#ifdef ENABLE_WLAN_FILTERING_PATCH\n\t/*\n\t * TODO GV 20070613\n\t * We need to disable the optimizer because the optimizer is buggy\n\t * and wipes out some LD instructions generated by the below\n\t * code to validate the Frame Control bits\n\t */\n\tcstate->no_optimize = 1;\n#endif /* ENABLE_WLAN_FILTERING_PATCH */\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\t/*\n\t\t * Oh, yuk.\n\t\t *\n\t\t *\tFor control frames, there is no SA.\n\t\t *\n\t\t *\tFor management frames, SA is at an\n\t\t *\toffset of 10 from the beginning of\n\t\t *\tthe packet.\n\t\t *\n\t\t *\tFor data frames, SA is at an offset\n\t\t *\tof 10 from the beginning of the packet\n\t\t *\tif From DS is clear, at an offset of\n\t\t *\t16 from the beginning of the packet\n\t\t *\tif From DS is set and To DS is clear,\n\t\t *\tand an offset of 24 from the beginning\n\t\t *\tof the packet if From DS is set and To DS\n\t\t *\tis set.\n\t\t */\n\n\t\t/*\n\t\t * Generate the tests to be done for data frames\n\t\t * with From DS set.\n\t\t *\n\t\t * First, check for To DS set, i.e. check \"link[1] & 0x01\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x01;\t/* To DS */\n\t\tb1->stmts = s;\n\n\t\t/*\n\t\t * If To DS is set, the SA is at 24.\n\t\t */\n\t\tb0 = gen_bcmp(cstate, OR_LINKHDR, 24, 6, eaddr);\n\t\tgen_and(b1, b0);\n\n\t\t/*\n\t\t * Now, check for To DS not set, i.e. check\n\t\t * \"!(link[1] & 0x01)\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);\n\t\tb2 = new_block(cstate, JMP(BPF_JSET));\n\t\tb2->s.k = 0x01;\t/* To DS */\n\t\tb2->stmts = s;\n\t\tgen_not(b2);\n\n\t\t/*\n\t\t * If To DS is not set, the SA is at 16.\n\t\t */\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 16, 6, eaddr);\n\t\tgen_and(b2, b1);\n\n\t\t/*\n\t\t * Now OR together the last two checks.  That gives\n\t\t * the complete set of checks for data frames with\n\t\t * From DS set.\n\t\t */\n\t\tgen_or(b1, b0);\n\n\t\t/*\n\t\t * Now check for From DS being set, and AND that with\n\t\t * the ORed-together checks.\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x02;\t/* From DS */\n\t\tb1->stmts = s;\n\t\tgen_and(b1, b0);\n\n\t\t/*\n\t\t * Now check for data frames with From DS not set.\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);\n\t\tb2 = new_block(cstate, JMP(BPF_JSET));\n\t\tb2->s.k = 0x02;\t/* From DS */\n\t\tb2->stmts = s;\n\t\tgen_not(b2);\n\n\t\t/*\n\t\t * If From DS isn't set, the SA is at 10.\n\t\t */\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);\n\t\tgen_and(b2, b1);\n\n\t\t/*\n\t\t * Now OR together the checks for data frames with\n\t\t * From DS not set and for data frames with From DS\n\t\t * set; that gives the checks done for data frames.\n\t\t */\n\t\tgen_or(b1, b0);\n\n\t\t/*\n\t\t * Now check for a data frame.\n\t\t * I.e, check \"link[0] & 0x08\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x08;\n\t\tb1->stmts = s;\n\n\t\t/*\n\t\t * AND that with the checks done for data frames.\n\t\t */\n\t\tgen_and(b1, b0);\n\n\t\t/*\n\t\t * If the high-order bit of the type value is 0, this\n\t\t * is a management frame.\n\t\t * I.e, check \"!(link[0] & 0x08)\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\tb2 = new_block(cstate, JMP(BPF_JSET));\n\t\tb2->s.k = 0x08;\n\t\tb2->stmts = s;\n\t\tgen_not(b2);\n\n\t\t/*\n\t\t * For management frames, the SA is at 10.\n\t\t */\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);\n\t\tgen_and(b2, b1);\n\n\t\t/*\n\t\t * OR that with the checks done for data frames.\n\t\t * That gives the checks done for management and\n\t\t * data frames.\n\t\t */\n\t\tgen_or(b1, b0);\n\n\t\t/*\n\t\t * If the low-order bit of the type value is 1,\n\t\t * this is either a control frame or a frame\n\t\t * with a reserved type, and thus not a\n\t\t * frame with an SA.\n\t\t *\n\t\t * I.e., check \"!(link[0] & 0x04)\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x04;\n\t\tb1->stmts = s;\n\t\tgen_not(b1);\n\n\t\t/*\n\t\t * AND that with the checks for data and management\n\t\t * frames.\n\t\t */\n\t\tgen_and(b1, b0);\n\t\treturn b0;\n\n\tcase Q_DST:\n\t\t/*\n\t\t * Oh, yuk.\n\t\t *\n\t\t *\tFor control frames, there is no DA.\n\t\t *\n\t\t *\tFor management frames, DA is at an\n\t\t *\toffset of 4 from the beginning of\n\t\t *\tthe packet.\n\t\t *\n\t\t *\tFor data frames, DA is at an offset\n\t\t *\tof 4 from the beginning of the packet\n\t\t *\tif To DS is clear and at an offset of\n\t\t *\t16 from the beginning of the packet\n\t\t *\tif To DS is set.\n\t\t */\n\n\t\t/*\n\t\t * Generate the tests to be done for data frames.\n\t\t *\n\t\t * First, check for To DS set, i.e. \"link[1] & 0x01\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x01;\t/* To DS */\n\t\tb1->stmts = s;\n\n\t\t/*\n\t\t * If To DS is set, the DA is at 16.\n\t\t */\n\t\tb0 = gen_bcmp(cstate, OR_LINKHDR, 16, 6, eaddr);\n\t\tgen_and(b1, b0);\n\n\t\t/*\n\t\t * Now, check for To DS not set, i.e. check\n\t\t * \"!(link[1] & 0x01)\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);\n\t\tb2 = new_block(cstate, JMP(BPF_JSET));\n\t\tb2->s.k = 0x01;\t/* To DS */\n\t\tb2->stmts = s;\n\t\tgen_not(b2);\n\n\t\t/*\n\t\t * If To DS is not set, the DA is at 4.\n\t\t */\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 4, 6, eaddr);\n\t\tgen_and(b2, b1);\n\n\t\t/*\n\t\t * Now OR together the last two checks.  That gives\n\t\t * the complete set of checks for data frames.\n\t\t */\n\t\tgen_or(b1, b0);\n\n\t\t/*\n\t\t * Now check for a data frame.\n\t\t * I.e, check \"link[0] & 0x08\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x08;\n\t\tb1->stmts = s;\n\n\t\t/*\n\t\t * AND that with the checks done for data frames.\n\t\t */\n\t\tgen_and(b1, b0);\n\n\t\t/*\n\t\t * If the high-order bit of the type value is 0, this\n\t\t * is a management frame.\n\t\t * I.e, check \"!(link[0] & 0x08)\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\tb2 = new_block(cstate, JMP(BPF_JSET));\n\t\tb2->s.k = 0x08;\n\t\tb2->stmts = s;\n\t\tgen_not(b2);\n\n\t\t/*\n\t\t * For management frames, the DA is at 4.\n\t\t */\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 4, 6, eaddr);\n\t\tgen_and(b2, b1);\n\n\t\t/*\n\t\t * OR that with the checks done for data frames.\n\t\t * That gives the checks done for management and\n\t\t * data frames.\n\t\t */\n\t\tgen_or(b1, b0);\n\n\t\t/*\n\t\t * If the low-order bit of the type value is 1,\n\t\t * this is either a control frame or a frame\n\t\t * with a reserved type, and thus not a\n\t\t * frame with an SA.\n\t\t *\n\t\t * I.e., check \"!(link[0] & 0x04)\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x04;\n\t\tb1->stmts = s;\n\t\tgen_not(b1);\n\n\t\t/*\n\t\t * AND that with the checks for data and management\n\t\t * frames.\n\t\t */\n\t\tgen_and(b1, b0);\n\t\treturn b0;\n\n\tcase Q_AND:\n\t\tb0 = gen_wlanhostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_wlanhostop(cstate, eaddr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_wlanhostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_wlanhostop(cstate, eaddr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\t/*\n\t * XXX - add BSSID keyword?\n\t */\n\tcase Q_ADDR1:\n\t\treturn (gen_bcmp(cstate, OR_LINKHDR, 4, 6, eaddr));\n\n\tcase Q_ADDR2:\n\t\t/*\n\t\t * Not present in CTS or ACK control frames.\n\t\t */\n\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_TYPE_CTL,\n\t\t\tIEEE80211_FC0_TYPE_MASK);\n\t\tgen_not(b0);\n\t\tb1 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_SUBTYPE_CTS,\n\t\t\tIEEE80211_FC0_SUBTYPE_MASK);\n\t\tgen_not(b1);\n\t\tb2 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_SUBTYPE_ACK,\n\t\t\tIEEE80211_FC0_SUBTYPE_MASK);\n\t\tgen_not(b2);\n\t\tgen_and(b1, b2);\n\t\tgen_or(b0, b2);\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);\n\t\tgen_and(b2, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR3:\n\t\t/*\n\t\t * Not present in control frames.\n\t\t */\n\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_TYPE_CTL,\n\t\t\tIEEE80211_FC0_TYPE_MASK);\n\t\tgen_not(b0);\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 16, 6, eaddr);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR4:\n\t\t/*\n\t\t * Present only if the direction mask has both \"From DS\"\n\t\t * and \"To DS\" set.  Neither control frames nor management\n\t\t * frames should have both of those set, so we don't\n\t\t * check the frame type.\n\t\t */\n\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 1, BPF_B,\n\t\t\tIEEE80211_FC1_DIR_DSTODS, IEEE80211_FC1_DIR_MASK);\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 24, 6, eaddr);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_RA:\n\t\t/*\n\t\t * Not present in management frames; addr1 in other\n\t\t * frames.\n\t\t */\n\n\t\t/*\n\t\t * If the high-order bit of the type value is 0, this\n\t\t * is a management frame.\n\t\t * I.e, check \"(link[0] & 0x08)\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x08;\n\t\tb1->stmts = s;\n\n\t\t/*\n\t\t * Check addr1.\n\t\t */\n\t\tb0 = gen_bcmp(cstate, OR_LINKHDR, 4, 6, eaddr);\n\n\t\t/*\n\t\t * AND that with the check of addr1.\n\t\t */\n\t\tgen_and(b1, b0);\n\t\treturn (b0);\n\n\tcase Q_TA:\n\t\t/*\n\t\t * Not present in management frames; addr2, if present,\n\t\t * in other frames.\n\t\t */\n\n\t\t/*\n\t\t * Not present in CTS or ACK control frames.\n\t\t */\n\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_TYPE_CTL,\n\t\t\tIEEE80211_FC0_TYPE_MASK);\n\t\tgen_not(b0);\n\t\tb1 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_SUBTYPE_CTS,\n\t\t\tIEEE80211_FC0_SUBTYPE_MASK);\n\t\tgen_not(b1);\n\t\tb2 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, IEEE80211_FC0_SUBTYPE_ACK,\n\t\t\tIEEE80211_FC0_SUBTYPE_MASK);\n\t\tgen_not(b2);\n\t\tgen_and(b1, b2);\n\t\tgen_or(b0, b2);\n\n\t\t/*\n\t\t * If the high-order bit of the type value is 0, this\n\t\t * is a management frame.\n\t\t * I.e, check \"(link[0] & 0x08)\".\n\t\t */\n\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\tb1->s.k = 0x08;\n\t\tb1->stmts = s;\n\n\t\t/*\n\t\t * AND that with the check for frames other than\n\t\t * CTS and ACK frames.\n\t\t */\n\t\tgen_and(b1, b2);\n\n\t\t/*\n\t\t * Check addr2.\n\t\t */\n\t\tb1 = gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);\n\t\tgen_and(b2, b1);\n\t\treturn b1;\n\t}\n\tabort();\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              4278,
              0
            ],
            [
              4695,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_wlanhostop",
            "parameters": {
              "cstate": "compiler_state_t",
              "eaddr": "u_char",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_ipfchostop(compiler_state_t *cstate, const u_char *eaddr, int dir)\n{\n\tregister struct block *b0, *b1;\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 10, 6, eaddr);\n\n\tcase Q_DST:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 2, 6, eaddr);\n\n\tcase Q_AND:\n\t\tb0 = gen_ipfchostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_ipfchostop(cstate, eaddr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_ipfchostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_ipfchostop(cstate, eaddr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is only supported on 802.11\");\n\t\t/*NOTREACHED*/\n\t}\n\tabort();\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              4702,
              0
            ],
            [
              4753,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ipfchostop",
            "parameters": {
              "cstate": "compiler_state_t",
              "eaddr": "u_char",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_dnhostop(compiler_state_t *cstate, bpf_u_int32 addr, int dir)\n{\n\tstruct block *b0, *b1, *b2, *tmp;\n\tu_int offset_lh;\t/* offset if long header is received */\n\tu_int offset_sh;\t/* offset if short header is received */\n\n\tswitch (dir) {\n\n\tcase Q_DST:\n\t\toffset_sh = 1;\t/* follows flags */\n\t\toffset_lh = 7;\t/* flgs,darea,dsubarea,HIORD */\n\t\tbreak;\n\n\tcase Q_SRC:\n\t\toffset_sh = 3;\t/* follows flags, dstnode */\n\t\toffset_lh = 15;\t/* flgs,darea,dsubarea,did,sarea,ssub,HIORD */\n\t\tbreak;\n\n\tcase Q_AND:\n\t\t/* Inefficient because we do our Calvinball dance twice */\n\t\tb0 = gen_dnhostop(cstate, addr, Q_SRC);\n\t\tb1 = gen_dnhostop(cstate, addr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\t/* Inefficient because we do our Calvinball dance twice */\n\t\tb0 = gen_dnhostop(cstate, addr, Q_SRC);\n\t\tb1 = gen_dnhostop(cstate, addr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are not valid qualifiers for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is not a valid qualifier for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is not a valid qualifier for addresses other than 802.11 MAC addresses\");\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tabort();\n\t\t/*NOTREACHED*/\n\t}\n\tb0 = gen_linktype(cstate, ETHERTYPE_DN);\n\t/* Check for pad = 1, long header case */\n\ttmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_H,\n\t    (bpf_u_int32)ntohs(0x0681), (bpf_u_int32)ntohs(0x07FF));\n\tb1 = gen_cmp(cstate, OR_LINKPL, 2 + 1 + offset_lh,\n\t    BPF_H, (bpf_u_int32)ntohs((u_short)addr));\n\tgen_and(tmp, b1);\n\t/* Check for pad = 0, long header case */\n\ttmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_B, (bpf_u_int32)0x06,\n\t    (bpf_u_int32)0x7);\n\tb2 = gen_cmp(cstate, OR_LINKPL, 2 + offset_lh, BPF_H,\n\t    (bpf_u_int32)ntohs((u_short)addr));\n\tgen_and(tmp, b2);\n\tgen_or(b2, b1);\n\t/* Check for pad = 1, short header case */\n\ttmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_H,\n\t    (bpf_u_int32)ntohs(0x0281), (bpf_u_int32)ntohs(0x07FF));\n\tb2 = gen_cmp(cstate, OR_LINKPL, 2 + 1 + offset_sh, BPF_H,\n\t    (bpf_u_int32)ntohs((u_short)addr));\n\tgen_and(tmp, b2);\n\tgen_or(b2, b1);\n\t/* Check for pad = 0, short header case */\n\ttmp = gen_mcmp(cstate, OR_LINKPL, 2, BPF_B, (bpf_u_int32)0x02,\n\t    (bpf_u_int32)0x7);\n\tb2 = gen_cmp(cstate, OR_LINKPL, 2 + offset_sh, BPF_H,\n\t    (bpf_u_int32)ntohs((u_short)addr));\n\tgen_and(tmp, b2);\n\tgen_or(b2, b1);\n\n\t/* Combine with test for cstate->linktype */\n\tgen_and(b0, b1);\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              4773,
              0
            ],
            [
              4867,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_dnhostop",
            "parameters": {
              "cstate": "compiler_state_t",
              "addr": "bpf_u_int32",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_mpls_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)\n{\n\tstruct block *b0, *b1;\n\n        switch (ll_proto) {\n\n        case ETHERTYPE_IP:\n                /* match the bottom-of-stack bit */\n                b0 = gen_mcmp(cstate, OR_LINKPL, (u_int)-2, BPF_B, 0x01, 0x01);\n                /* match the IPv4 version number */\n                b1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_B, 0x40, 0xf0);\n                gen_and(b0, b1);\n                return b1;\n\n        case ETHERTYPE_IPV6:\n                /* match the bottom-of-stack bit */\n                b0 = gen_mcmp(cstate, OR_LINKPL, (u_int)-2, BPF_B, 0x01, 0x01);\n                /* match the IPv4 version number */\n                b1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_B, 0x60, 0xf0);\n                gen_and(b0, b1);\n                return b1;\n\n        default:\n               /* FIXME add other L3 proto IDs */\n               bpf_error(cstate, \"unsupported protocol over mpls\");\n               /*NOTREACHED*/\n        }\n}",
          "fn_code_pos": [
            [
              4874,
              0
            ],
            [
              4902,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mpls_linktype",
            "parameters": {
              "cstate": "compiler_state_t",
              "ll_proto": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_host(compiler_state_t *cstate, bpf_u_int32 addr, bpf_u_int32 mask,\n    int proto, int dir, int type)\n{\n\tstruct block *b0, *b1;\n\tconst char *typestr;\n\n\tif (type == Q_NET)\n\t\ttypestr = \"net\";\n\telse\n\t\ttypestr = \"host\";\n\n\tswitch (proto) {\n\n\tcase Q_DEFAULT:\n\t\tb0 = gen_host(cstate, addr, mask, Q_IP, dir, type);\n\t\t/*\n\t\t * Only check for non-IPv4 addresses if we're not\n\t\t * checking MPLS-encapsulated packets.\n\t\t */\n\t\tif (cstate->label_stack_depth == 0) {\n\t\t\tb1 = gen_host(cstate, addr, mask, Q_ARP, dir, type);\n\t\t\tgen_or(b0, b1);\n\t\t\tb0 = gen_host(cstate, addr, mask, Q_RARP, dir, type);\n\t\t\tgen_or(b1, b0);\n\t\t}\n\t\treturn b0;\n\n\tcase Q_LINK:\n\t\tbpf_error(cstate, \"link-layer modifier applied to %s\", typestr);\n\n\tcase Q_IP:\n\t\treturn gen_hostop(cstate, addr, mask, dir, ETHERTYPE_IP, 12, 16);\n\n\tcase Q_RARP:\n\t\treturn gen_hostop(cstate, addr, mask, dir, ETHERTYPE_REVARP, 14, 24);\n\n\tcase Q_ARP:\n\t\treturn gen_hostop(cstate, addr, mask, dir, ETHERTYPE_ARP, 14, 24);\n\n\tcase Q_SCTP:\n\t\tbpf_error(cstate, \"'sctp' modifier applied to %s\", typestr);\n\n\tcase Q_TCP:\n\t\tbpf_error(cstate, \"'tcp' modifier applied to %s\", typestr);\n\n\tcase Q_UDP:\n\t\tbpf_error(cstate, \"'udp' modifier applied to %s\", typestr);\n\n\tcase Q_ICMP:\n\t\tbpf_error(cstate, \"'icmp' modifier applied to %s\", typestr);\n\n\tcase Q_IGMP:\n\t\tbpf_error(cstate, \"'igmp' modifier applied to %s\", typestr);\n\n\tcase Q_IGRP:\n\t\tbpf_error(cstate, \"'igrp' modifier applied to %s\", typestr);\n\n\tcase Q_ATALK:\n\t\tbpf_error(cstate, \"AppleTalk host filtering not implemented\");\n\n\tcase Q_DECNET:\n\t\treturn gen_dnhostop(cstate, addr, dir);\n\n\tcase Q_LAT:\n\t\tbpf_error(cstate, \"LAT host filtering not implemented\");\n\n\tcase Q_SCA:\n\t\tbpf_error(cstate, \"SCA host filtering not implemented\");\n\n\tcase Q_MOPRC:\n\t\tbpf_error(cstate, \"MOPRC host filtering not implemented\");\n\n\tcase Q_MOPDL:\n\t\tbpf_error(cstate, \"MOPDL host filtering not implemented\");\n\n\tcase Q_IPV6:\n\t\tbpf_error(cstate, \"'ip6' modifier applied to ip host\");\n\n\tcase Q_ICMPV6:\n\t\tbpf_error(cstate, \"'icmp6' modifier applied to %s\", typestr);\n\n\tcase Q_AH:\n\t\tbpf_error(cstate, \"'ah' modifier applied to %s\", typestr);\n\n\tcase Q_ESP:\n\t\tbpf_error(cstate, \"'esp' modifier applied to %s\", typestr);\n\n\tcase Q_PIM:\n\t\tbpf_error(cstate, \"'pim' modifier applied to %s\", typestr);\n\n\tcase Q_VRRP:\n\t\tbpf_error(cstate, \"'vrrp' modifier applied to %s\", typestr);\n\n\tcase Q_AARP:\n\t\tbpf_error(cstate, \"AARP host filtering not implemented\");\n\n\tcase Q_ISO:\n\t\tbpf_error(cstate, \"ISO host filtering not implemented\");\n\n\tcase Q_ESIS:\n\t\tbpf_error(cstate, \"'esis' modifier applied to %s\", typestr);\n\n\tcase Q_ISIS:\n\t\tbpf_error(cstate, \"'isis' modifier applied to %s\", typestr);\n\n\tcase Q_CLNP:\n\t\tbpf_error(cstate, \"'clnp' modifier applied to %s\", typestr);\n\n\tcase Q_STP:\n\t\tbpf_error(cstate, \"'stp' modifier applied to %s\", typestr);\n\n\tcase Q_IPX:\n\t\tbpf_error(cstate, \"IPX host filtering not implemented\");\n\n\tcase Q_NETBEUI:\n\t\tbpf_error(cstate, \"'netbeui' modifier applied to %s\", typestr);\n\n\tcase Q_ISIS_L1:\n\t\tbpf_error(cstate, \"'l1' modifier applied to %s\", typestr);\n\n\tcase Q_ISIS_L2:\n\t\tbpf_error(cstate, \"'l2' modifier applied to %s\", typestr);\n\n\tcase Q_ISIS_IIH:\n\t\tbpf_error(cstate, \"'iih' modifier applied to %s\", typestr);\n\n\tcase Q_ISIS_SNP:\n\t\tbpf_error(cstate, \"'snp' modifier applied to %s\", typestr);\n\n\tcase Q_ISIS_CSNP:\n\t\tbpf_error(cstate, \"'csnp' modifier applied to %s\", typestr);\n\n\tcase Q_ISIS_PSNP:\n\t\tbpf_error(cstate, \"'psnp' modifier applied to %s\", typestr);\n\n\tcase Q_ISIS_LSP:\n\t\tbpf_error(cstate, \"'lsp' modifier applied to %s\", typestr);\n\n\tcase Q_RADIO:\n\t\tbpf_error(cstate, \"'radio' modifier applied to %s\", typestr);\n\n\tcase Q_CARP:\n\t\tbpf_error(cstate, \"'carp' modifier applied to %s\", typestr);\n\n\tdefault:\n\t\tabort();\n\t}\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              4904,
              0
            ],
            [
              5053,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_host",
            "parameters": {
              "cstate": "compiler_state_t",
              "addr": "bpf_u_int32",
              "mask": "bpf_u_int32",
              "proto": "int",
              "dir": "int",
              "type": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_host6(compiler_state_t *cstate, struct in6_addr *addr,\n    struct in6_addr *mask, int proto, int dir, int type)\n{\n\tconst char *typestr;\n\n\tif (type == Q_NET)\n\t\ttypestr = \"net\";\n\telse\n\t\ttypestr = \"host\";\n\n\tswitch (proto) {\n\n\tcase Q_DEFAULT:\n\t\treturn gen_host6(cstate, addr, mask, Q_IPV6, dir, type);\n\n\tcase Q_LINK:\n\t\tbpf_error(cstate, \"link-layer modifier applied to ip6 %s\", typestr);\n\n\tcase Q_IP:\n\t\tbpf_error(cstate, \"'ip' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_RARP:\n\t\tbpf_error(cstate, \"'rarp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ARP:\n\t\tbpf_error(cstate, \"'arp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_SCTP:\n\t\tbpf_error(cstate, \"'sctp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_TCP:\n\t\tbpf_error(cstate, \"'tcp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_UDP:\n\t\tbpf_error(cstate, \"'udp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ICMP:\n\t\tbpf_error(cstate, \"'icmp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_IGMP:\n\t\tbpf_error(cstate, \"'igmp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_IGRP:\n\t\tbpf_error(cstate, \"'igrp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ATALK:\n\t\tbpf_error(cstate, \"AppleTalk modifier applied to ip6 %s\", typestr);\n\n\tcase Q_DECNET:\n\t\tbpf_error(cstate, \"'decnet' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_LAT:\n\t\tbpf_error(cstate, \"'lat' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_SCA:\n\t\tbpf_error(cstate, \"'sca' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_MOPRC:\n\t\tbpf_error(cstate, \"'moprc' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_MOPDL:\n\t\tbpf_error(cstate, \"'mopdl' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_IPV6:\n\t\treturn gen_hostop6(cstate, addr, mask, dir, ETHERTYPE_IPV6, 8, 24);\n\n\tcase Q_ICMPV6:\n\t\tbpf_error(cstate, \"'icmp6' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_AH:\n\t\tbpf_error(cstate, \"'ah' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ESP:\n\t\tbpf_error(cstate, \"'esp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_PIM:\n\t\tbpf_error(cstate, \"'pim' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_VRRP:\n\t\tbpf_error(cstate, \"'vrrp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_AARP:\n\t\tbpf_error(cstate, \"'aarp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISO:\n\t\tbpf_error(cstate, \"'iso' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ESIS:\n\t\tbpf_error(cstate, \"'esis' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISIS:\n\t\tbpf_error(cstate, \"'isis' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_CLNP:\n\t\tbpf_error(cstate, \"'clnp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_STP:\n\t\tbpf_error(cstate, \"'stp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_IPX:\n\t\tbpf_error(cstate, \"'ipx' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_NETBEUI:\n\t\tbpf_error(cstate, \"'netbeui' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISIS_L1:\n\t\tbpf_error(cstate, \"'l1' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISIS_L2:\n\t\tbpf_error(cstate, \"'l2' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISIS_IIH:\n\t\tbpf_error(cstate, \"'iih' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISIS_SNP:\n\t\tbpf_error(cstate, \"'snp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISIS_CSNP:\n\t\tbpf_error(cstate, \"'csnp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISIS_PSNP:\n\t\tbpf_error(cstate, \"'psnp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_ISIS_LSP:\n\t\tbpf_error(cstate, \"'lsp' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_RADIO:\n\t\tbpf_error(cstate, \"'radio' modifier applied to ip6 %s\", typestr);\n\n\tcase Q_CARP:\n\t\tbpf_error(cstate, \"'carp' modifier applied to ip6 %s\", typestr);\n\n\tdefault:\n\t\tabort();\n\t}\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              5056,
              0
            ],
            [
              5193,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_host6",
            "parameters": {
              "cstate": "compiler_state_t",
              "addr": "struct in6_addr",
              "mask": "struct in6_addr",
              "proto": "int",
              "dir": "int",
              "type": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_gateway(compiler_state_t *cstate, const u_char *eaddr,\n    struct addrinfo *alist, int proto, int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\tstruct addrinfo *ai;\n\tstruct sockaddr_in *sin;\n\n\tif (dir != 0)\n\t\tbpf_error(cstate, \"direction applied to 'gateway'\");\n\n\tswitch (proto) {\n\tcase Q_DEFAULT:\n\tcase Q_IP:\n\tcase Q_ARP:\n\tcase Q_RARP:\n\t\tswitch (cstate->linktype) {\n\t\tcase DLT_EN10MB:\n\t\tcase DLT_NETANALYZER:\n\t\tcase DLT_NETANALYZER_TRANSPARENT:\n\t\t\tb1 = gen_prevlinkhdr_check(cstate);\n\t\t\tb0 = gen_ehostop(cstate, eaddr, Q_OR);\n\t\t\tif (b1 != NULL)\n\t\t\t\tgen_and(b1, b0);\n\t\t\tbreak;\n\t\tcase DLT_FDDI:\n\t\t\tb0 = gen_fhostop(cstate, eaddr, Q_OR);\n\t\t\tbreak;\n\t\tcase DLT_IEEE802:\n\t\t\tb0 = gen_thostop(cstate, eaddr, Q_OR);\n\t\t\tbreak;\n\t\tcase DLT_IEEE802_11:\n\t\tcase DLT_PRISM_HEADER:\n\t\tcase DLT_IEEE802_11_RADIO_AVS:\n\t\tcase DLT_IEEE802_11_RADIO:\n\t\tcase DLT_PPI:\n\t\t\tb0 = gen_wlanhostop(cstate, eaddr, Q_OR);\n\t\t\tbreak;\n\t\tcase DLT_SUNATM:\n\t\t\t/*\n\t\t\t * This is LLC-multiplexed traffic; if it were\n\t\t\t * LANE, cstate->linktype would have been set to\n\t\t\t * DLT_EN10MB.\n\t\t\t */\n\t\t\tbpf_error(cstate,\n\t\t\t    \"'gateway' supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel\");\n\t\t\tbreak;\n\t\tcase DLT_IP_OVER_FC:\n\t\t\tb0 = gen_ipfchostop(cstate, eaddr, Q_OR);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbpf_error(cstate,\n\t\t\t    \"'gateway' supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel\");\n\t\t}\n\t\tb1 = NULL;\n\t\tfor (ai = alist; ai != NULL; ai = ai->ai_next) {\n\t\t\t/*\n\t\t\t * Does it have an address?\n\t\t\t */\n\t\t\tif (ai->ai_addr != NULL) {\n\t\t\t\t/*\n\t\t\t\t * Yes.  Is it an IPv4 address?\n\t\t\t\t */\n\t\t\t\tif (ai->ai_addr->sa_family == AF_INET) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Generate an entry for it.\n\t\t\t\t\t */\n\t\t\t\t\tsin = (struct sockaddr_in *)ai->ai_addr;\n\t\t\t\t\ttmp = gen_host(cstate,\n\t\t\t\t\t    ntohl(sin->sin_addr.s_addr),\n\t\t\t\t\t    0xffffffff, proto, Q_OR, Q_HOST);\n\t\t\t\t\t/*\n\t\t\t\t\t * Is it the *first* IPv4 address?\n\t\t\t\t\t */\n\t\t\t\t\tif (b1 == NULL) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Yes, so start with it.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tb1 = tmp;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * No, so OR it into the\n\t\t\t\t\t\t * existing set of\n\t\t\t\t\t\t * addresses.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgen_or(b1, tmp);\n\t\t\t\t\t\tb1 = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (b1 == NULL) {\n\t\t\t/*\n\t\t\t * No IPv4 addresses found.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tgen_not(b1);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\t}\n\tbpf_error(cstate, \"illegal modifier of 'gateway'\");\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              5197,
              0
            ],
            [
              5300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_gateway",
            "parameters": {
              "cstate": "compiler_state_t",
              "eaddr": "u_char",
              "alist": "struct addrinfo",
              "proto": "int",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_proto_abbrev_internal(compiler_state_t *cstate, int proto)\n{\n\tstruct block *b0;\n\tstruct block *b1;\n\n\tswitch (proto) {\n\n\tcase Q_SCTP:\n\t\tb1 = gen_proto(cstate, IPPROTO_SCTP, Q_IP, Q_DEFAULT);\n\t\tb0 = gen_proto(cstate, IPPROTO_SCTP, Q_IPV6, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_TCP:\n\t\tb1 = gen_proto(cstate, IPPROTO_TCP, Q_IP, Q_DEFAULT);\n\t\tb0 = gen_proto(cstate, IPPROTO_TCP, Q_IPV6, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_UDP:\n\t\tb1 = gen_proto(cstate, IPPROTO_UDP, Q_IP, Q_DEFAULT);\n\t\tb0 = gen_proto(cstate, IPPROTO_UDP, Q_IPV6, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_ICMP:\n\t\tb1 = gen_proto(cstate, IPPROTO_ICMP, Q_IP, Q_DEFAULT);\n\t\tbreak;\n\n#ifndef\tIPPROTO_IGMP\n#define\tIPPROTO_IGMP\t2\n#endif\n\n\tcase Q_IGMP:\n\t\tb1 = gen_proto(cstate, IPPROTO_IGMP, Q_IP, Q_DEFAULT);\n\t\tbreak;\n\n#ifndef\tIPPROTO_IGRP\n#define\tIPPROTO_IGRP\t9\n#endif\n\tcase Q_IGRP:\n\t\tb1 = gen_proto(cstate, IPPROTO_IGRP, Q_IP, Q_DEFAULT);\n\t\tbreak;\n\n#ifndef IPPROTO_PIM\n#define IPPROTO_PIM\t103\n#endif\n\n\tcase Q_PIM:\n\t\tb1 = gen_proto(cstate, IPPROTO_PIM, Q_IP, Q_DEFAULT);\n\t\tb0 = gen_proto(cstate, IPPROTO_PIM, Q_IPV6, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n#ifndef IPPROTO_VRRP\n#define IPPROTO_VRRP\t112\n#endif\n\n\tcase Q_VRRP:\n\t\tb1 = gen_proto(cstate, IPPROTO_VRRP, Q_IP, Q_DEFAULT);\n\t\tbreak;\n\n#ifndef IPPROTO_CARP\n#define IPPROTO_CARP\t112\n#endif\n\n\tcase Q_CARP:\n\t\tb1 = gen_proto(cstate, IPPROTO_CARP, Q_IP, Q_DEFAULT);\n\t\tbreak;\n\n\tcase Q_IP:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_IP);\n\t\tbreak;\n\n\tcase Q_ARP:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_ARP);\n\t\tbreak;\n\n\tcase Q_RARP:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_REVARP);\n\t\tbreak;\n\n\tcase Q_LINK:\n\t\tbpf_error(cstate, \"link layer applied in wrong context\");\n\n\tcase Q_ATALK:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_ATALK);\n\t\tbreak;\n\n\tcase Q_AARP:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_AARP);\n\t\tbreak;\n\n\tcase Q_DECNET:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_DN);\n\t\tbreak;\n\n\tcase Q_SCA:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_SCA);\n\t\tbreak;\n\n\tcase Q_LAT:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_LAT);\n\t\tbreak;\n\n\tcase Q_MOPDL:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_MOPDL);\n\t\tbreak;\n\n\tcase Q_MOPRC:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_MOPRC);\n\t\tbreak;\n\n\tcase Q_IPV6:\n\t\tb1 = gen_linktype(cstate, ETHERTYPE_IPV6);\n\t\tbreak;\n\n#ifndef IPPROTO_ICMPV6\n#define IPPROTO_ICMPV6\t58\n#endif\n\tcase Q_ICMPV6:\n\t\tb1 = gen_proto(cstate, IPPROTO_ICMPV6, Q_IPV6, Q_DEFAULT);\n\t\tbreak;\n\n#ifndef IPPROTO_AH\n#define IPPROTO_AH\t51\n#endif\n\tcase Q_AH:\n\t\tb1 = gen_proto(cstate, IPPROTO_AH, Q_IP, Q_DEFAULT);\n\t\tb0 = gen_proto(cstate, IPPROTO_AH, Q_IPV6, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n#ifndef IPPROTO_ESP\n#define IPPROTO_ESP\t50\n#endif\n\tcase Q_ESP:\n\t\tb1 = gen_proto(cstate, IPPROTO_ESP, Q_IP, Q_DEFAULT);\n\t\tb0 = gen_proto(cstate, IPPROTO_ESP, Q_IPV6, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_ISO:\n\t\tb1 = gen_linktype(cstate, LLCSAP_ISONS);\n\t\tbreak;\n\n\tcase Q_ESIS:\n\t\tb1 = gen_proto(cstate, ISO9542_ESIS, Q_ISO, Q_DEFAULT);\n\t\tbreak;\n\n\tcase Q_ISIS:\n\t\tb1 = gen_proto(cstate, ISO10589_ISIS, Q_ISO, Q_DEFAULT);\n\t\tbreak;\n\n\tcase Q_ISIS_L1: /* all IS-IS Level1 PDU-Types */\n\t\tb0 = gen_proto(cstate, ISIS_L1_LAN_IIH, Q_ISIS, Q_DEFAULT);\n\t\tb1 = gen_proto(cstate, ISIS_PTP_IIH, Q_ISIS, Q_DEFAULT); /* FIXME extract the circuit-type bits */\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_L1_LSP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_L1_CSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_L1_PSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_ISIS_L2: /* all IS-IS Level2 PDU-Types */\n\t\tb0 = gen_proto(cstate, ISIS_L2_LAN_IIH, Q_ISIS, Q_DEFAULT);\n\t\tb1 = gen_proto(cstate, ISIS_PTP_IIH, Q_ISIS, Q_DEFAULT); /* FIXME extract the circuit-type bits */\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_L2_LSP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_L2_CSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_L2_PSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_ISIS_IIH: /* all IS-IS Hello PDU-Types */\n\t\tb0 = gen_proto(cstate, ISIS_L1_LAN_IIH, Q_ISIS, Q_DEFAULT);\n\t\tb1 = gen_proto(cstate, ISIS_L2_LAN_IIH, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_PTP_IIH, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_ISIS_LSP:\n\t\tb0 = gen_proto(cstate, ISIS_L1_LSP, Q_ISIS, Q_DEFAULT);\n\t\tb1 = gen_proto(cstate, ISIS_L2_LSP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_ISIS_SNP:\n\t\tb0 = gen_proto(cstate, ISIS_L1_CSNP, Q_ISIS, Q_DEFAULT);\n\t\tb1 = gen_proto(cstate, ISIS_L2_CSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_L1_PSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_proto(cstate, ISIS_L2_PSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_ISIS_CSNP:\n\t\tb0 = gen_proto(cstate, ISIS_L1_CSNP, Q_ISIS, Q_DEFAULT);\n\t\tb1 = gen_proto(cstate, ISIS_L2_CSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_ISIS_PSNP:\n\t\tb0 = gen_proto(cstate, ISIS_L1_PSNP, Q_ISIS, Q_DEFAULT);\n\t\tb1 = gen_proto(cstate, ISIS_L2_PSNP, Q_ISIS, Q_DEFAULT);\n\t\tgen_or(b0, b1);\n\t\tbreak;\n\n\tcase Q_CLNP:\n\t\tb1 = gen_proto(cstate, ISO8473_CLNP, Q_ISO, Q_DEFAULT);\n\t\tbreak;\n\n\tcase Q_STP:\n\t\tb1 = gen_linktype(cstate, LLCSAP_8021D);\n\t\tbreak;\n\n\tcase Q_IPX:\n\t\tb1 = gen_linktype(cstate, LLCSAP_IPX);\n\t\tbreak;\n\n\tcase Q_NETBEUI:\n\t\tb1 = gen_linktype(cstate, LLCSAP_NETBEUI);\n\t\tbreak;\n\n\tcase Q_RADIO:\n\t\tbpf_error(cstate, \"'radio' is not a valid protocol type\");\n\n\tdefault:\n\t\tabort();\n\t}\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              5303,
              0
            ],
            [
              5541,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_proto_abbrev_internal",
            "parameters": {
              "cstate": "compiler_state_t",
              "proto": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_proto_abbrev(compiler_state_t *cstate, int proto)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\treturn gen_proto_abbrev_internal(cstate, proto);\n}",
          "fn_code_pos": [
            [
              5543,
              0
            ],
            [
              5554,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_proto_abbrev",
            "parameters": {
              "cstate": "compiler_state_t",
              "proto": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_ipfrag(compiler_state_t *cstate)\n{\n\tstruct slist *s;\n\tstruct block *b;\n\n\t/* not IPv4 frag other than the first frag */\n\ts = gen_load_a(cstate, OR_LINKPL, 6, BPF_H);\n\tb = new_block(cstate, JMP(BPF_JSET));\n\tb->s.k = 0x1fff;\n\tb->stmts = s;\n\tgen_not(b);\n\n\treturn b;\n}",
          "fn_code_pos": [
            [
              5556,
              0
            ],
            [
              5570,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ipfrag",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_portatom(compiler_state_t *cstate, int off, bpf_u_int32 v)\n{\n\treturn gen_cmp(cstate, OR_TRAN_IPV4, off, BPF_H, v);\n}",
          "fn_code_pos": [
            [
              5581,
              0
            ],
            [
              5585,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portatom",
            "parameters": {
              "cstate": "compiler_state_t",
              "off": "int",
              "v": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_portatom6(compiler_state_t *cstate, int off, bpf_u_int32 v)\n{\n\treturn gen_cmp(cstate, OR_TRAN_IPV6, off, BPF_H, v);\n}",
          "fn_code_pos": [
            [
              5587,
              0
            ],
            [
              5591,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portatom6",
            "parameters": {
              "cstate": "compiler_state_t",
              "off": "int",
              "v": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_portop(compiler_state_t *cstate, u_int port, u_int proto, int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\n\t/* ip proto 'proto' and not a fragment other than the first fragment */\n\ttmp = gen_cmp(cstate, OR_LINKPL, 9, BPF_B, proto);\n\tb0 = gen_ipfrag(cstate);\n\tgen_and(tmp, b0);\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\tb1 = gen_portatom(cstate, 0, port);\n\t\tbreak;\n\n\tcase Q_DST:\n\t\tb1 = gen_portatom(cstate, 2, port);\n\t\tbreak;\n\n\tcase Q_AND:\n\t\ttmp = gen_portatom(cstate, 0, port);\n\t\tb1 = gen_portatom(cstate, 2, port);\n\t\tgen_and(tmp, b1);\n\t\tbreak;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\ttmp = gen_portatom(cstate, 0, port);\n\t\tb1 = gen_portatom(cstate, 2, port);\n\t\tgen_or(tmp, b1);\n\t\tbreak;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are not valid qualifiers for ports\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are not valid qualifiers for ports\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are not valid qualifiers for ports\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are not valid qualifiers for ports\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is not a valid qualifier for ports\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is not a valid qualifier for ports\");\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tabort();\n\t\t/*NOTREACHED*/\n\t}\n\tgen_and(b0, b1);\n\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              5593,
              0
            ],
            [
              5656,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portop",
            "parameters": {
              "cstate": "compiler_state_t",
              "port": "u_int",
              "proto": "u_int",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_port(compiler_state_t *cstate, u_int port, int ip_proto, int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\n\t/*\n\t * ether proto ip\n\t *\n\t * For FDDI, RFC 1188 says that SNAP encapsulation is used,\n\t * not LLC encapsulation with LLCSAP_IP.\n\t *\n\t * For IEEE 802 networks - which includes 802.5 token ring\n\t * (which is what DLT_IEEE802 means) and 802.11 - RFC 1042\n\t * says that SNAP encapsulation is used, not LLC encapsulation\n\t * with LLCSAP_IP.\n\t *\n\t * For LLC-encapsulated ATM/\"Classical IP\", RFC 1483 and\n\t * RFC 2225 say that SNAP encapsulation is used, not LLC\n\t * encapsulation with LLCSAP_IP.\n\t *\n\t * So we always check for ETHERTYPE_IP.\n\t */\n\tb0 = gen_linktype(cstate, ETHERTYPE_IP);\n\n\tswitch (ip_proto) {\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_SCTP:\n\t\tb1 = gen_portop(cstate, port, (u_int)ip_proto, dir);\n\t\tbreak;\n\n\tcase PROTO_UNDEF:\n\t\ttmp = gen_portop(cstate, port, IPPROTO_TCP, dir);\n\t\tb1 = gen_portop(cstate, port, IPPROTO_UDP, dir);\n\t\tgen_or(tmp, b1);\n\t\ttmp = gen_portop(cstate, port, IPPROTO_SCTP, dir);\n\t\tgen_or(tmp, b1);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\tgen_and(b0, b1);\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              5658,
              0
            ],
            [
              5702,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_port",
            "parameters": {
              "cstate": "compiler_state_t",
              "port": "u_int",
              "ip_proto": "int",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_portop6(compiler_state_t *cstate, u_int port, u_int proto, int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\n\t/* ip6 proto 'proto' */\n\t/* XXX - catch the first fragment of a fragmented packet? */\n\tb0 = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, proto);\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\tb1 = gen_portatom6(cstate, 0, port);\n\t\tbreak;\n\n\tcase Q_DST:\n\t\tb1 = gen_portatom6(cstate, 2, port);\n\t\tbreak;\n\n\tcase Q_AND:\n\t\ttmp = gen_portatom6(cstate, 0, port);\n\t\tb1 = gen_portatom6(cstate, 2, port);\n\t\tgen_and(tmp, b1);\n\t\tbreak;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\ttmp = gen_portatom6(cstate, 0, port);\n\t\tb1 = gen_portatom6(cstate, 2, port);\n\t\tgen_or(tmp, b1);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\tgen_and(b0, b1);\n\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              5704,
              0
            ],
            [
              5741,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portop6",
            "parameters": {
              "cstate": "compiler_state_t",
              "port": "u_int",
              "proto": "u_int",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_port6(compiler_state_t *cstate, u_int port, int ip_proto, int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\n\t/* link proto ip6 */\n\tb0 = gen_linktype(cstate, ETHERTYPE_IPV6);\n\n\tswitch (ip_proto) {\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_SCTP:\n\t\tb1 = gen_portop6(cstate, port, (u_int)ip_proto, dir);\n\t\tbreak;\n\n\tcase PROTO_UNDEF:\n\t\ttmp = gen_portop6(cstate, port, IPPROTO_TCP, dir);\n\t\tb1 = gen_portop6(cstate, port, IPPROTO_UDP, dir);\n\t\tgen_or(tmp, b1);\n\t\ttmp = gen_portop6(cstate, port, IPPROTO_SCTP, dir);\n\t\tgen_or(tmp, b1);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\tgen_and(b0, b1);\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              5743,
              0
            ],
            [
              5771,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_port6",
            "parameters": {
              "cstate": "compiler_state_t",
              "port": "u_int",
              "ip_proto": "int",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_portrangeatom(compiler_state_t *cstate, u_int off, bpf_u_int32 v1,\n    bpf_u_int32 v2)\n{\n\tstruct block *b1, *b2;\n\n\tif (v1 > v2) {\n\t\t/*\n\t\t * Reverse the order of the ports, so v1 is the lower one.\n\t\t */\n\t\tbpf_u_int32 vtemp;\n\n\t\tvtemp = v1;\n\t\tv1 = v2;\n\t\tv2 = vtemp;\n\t}\n\n\tb1 = gen_cmp_ge(cstate, OR_TRAN_IPV4, off, BPF_H, v1);\n\tb2 = gen_cmp_le(cstate, OR_TRAN_IPV4, off, BPF_H, v2);\n\n\tgen_and(b1, b2);\n\n\treturn b2;\n}",
          "fn_code_pos": [
            [
              5774,
              0
            ],
            [
              5797,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrangeatom",
            "parameters": {
              "cstate": "compiler_state_t",
              "off": "u_int",
              "v1": "bpf_u_int32",
              "v2": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_portrangeop(compiler_state_t *cstate, u_int port1, u_int port2,\n    bpf_u_int32 proto, int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\n\t/* ip proto 'proto' and not a fragment other than the first fragment */\n\ttmp = gen_cmp(cstate, OR_LINKPL, 9, BPF_B, proto);\n\tb0 = gen_ipfrag(cstate);\n\tgen_and(tmp, b0);\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\tb1 = gen_portrangeatom(cstate, 0, port1, port2);\n\t\tbreak;\n\n\tcase Q_DST:\n\t\tb1 = gen_portrangeatom(cstate, 2, port1, port2);\n\t\tbreak;\n\n\tcase Q_AND:\n\t\ttmp = gen_portrangeatom(cstate, 0, port1, port2);\n\t\tb1 = gen_portrangeatom(cstate, 2, port1, port2);\n\t\tgen_and(tmp, b1);\n\t\tbreak;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\ttmp = gen_portrangeatom(cstate, 0, port1, port2);\n\t\tb1 = gen_portrangeatom(cstate, 2, port1, port2);\n\t\tgen_or(tmp, b1);\n\t\tbreak;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are not valid qualifiers for port ranges\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are not valid qualifiers for port ranges\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are not valid qualifiers for port ranges\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are not valid qualifiers for port ranges\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is not a valid qualifier for port ranges\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is not a valid qualifier for port ranges\");\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tabort();\n\t\t/*NOTREACHED*/\n\t}\n\tgen_and(b0, b1);\n\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              5799,
              0
            ],
            [
              5863,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrangeop",
            "parameters": {
              "cstate": "compiler_state_t",
              "port1": "u_int",
              "port2": "u_int",
              "proto": "bpf_u_int32",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_portrange(compiler_state_t *cstate, u_int port1, u_int port2, int ip_proto,\n    int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\n\t/* link proto ip */\n\tb0 = gen_linktype(cstate, ETHERTYPE_IP);\n\n\tswitch (ip_proto) {\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_SCTP:\n\t\tb1 = gen_portrangeop(cstate, port1, port2, (bpf_u_int32)ip_proto,\n\t\t    dir);\n\t\tbreak;\n\n\tcase PROTO_UNDEF:\n\t\ttmp = gen_portrangeop(cstate, port1, port2, IPPROTO_TCP, dir);\n\t\tb1 = gen_portrangeop(cstate, port1, port2, IPPROTO_UDP, dir);\n\t\tgen_or(tmp, b1);\n\t\ttmp = gen_portrangeop(cstate, port1, port2, IPPROTO_SCTP, dir);\n\t\tgen_or(tmp, b1);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\tgen_and(b0, b1);\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              5865,
              0
            ],
            [
              5895,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrange",
            "parameters": {
              "cstate": "compiler_state_t",
              "port1": "u_int",
              "port2": "u_int",
              "ip_proto": "int",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_portrangeatom6(compiler_state_t *cstate, u_int off, bpf_u_int32 v1,\n    bpf_u_int32 v2)\n{\n\tstruct block *b1, *b2;\n\n\tif (v1 > v2) {\n\t\t/*\n\t\t * Reverse the order of the ports, so v1 is the lower one.\n\t\t */\n\t\tbpf_u_int32 vtemp;\n\n\t\tvtemp = v1;\n\t\tv1 = v2;\n\t\tv2 = vtemp;\n\t}\n\n\tb1 = gen_cmp_ge(cstate, OR_TRAN_IPV6, off, BPF_H, v1);\n\tb2 = gen_cmp_le(cstate, OR_TRAN_IPV6, off, BPF_H, v2);\n\n\tgen_and(b1, b2);\n\n\treturn b2;\n}",
          "fn_code_pos": [
            [
              5897,
              0
            ],
            [
              5920,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrangeatom6",
            "parameters": {
              "cstate": "compiler_state_t",
              "off": "u_int",
              "v1": "bpf_u_int32",
              "v2": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_portrangeop6(compiler_state_t *cstate, u_int port1, u_int port2,\n    bpf_u_int32 proto, int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\n\t/* ip6 proto 'proto' */\n\t/* XXX - catch the first fragment of a fragmented packet? */\n\tb0 = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, proto);\n\n\tswitch (dir) {\n\tcase Q_SRC:\n\t\tb1 = gen_portrangeatom6(cstate, 0, port1, port2);\n\t\tbreak;\n\n\tcase Q_DST:\n\t\tb1 = gen_portrangeatom6(cstate, 2, port1, port2);\n\t\tbreak;\n\n\tcase Q_AND:\n\t\ttmp = gen_portrangeatom6(cstate, 0, port1, port2);\n\t\tb1 = gen_portrangeatom6(cstate, 2, port1, port2);\n\t\tgen_and(tmp, b1);\n\t\tbreak;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\ttmp = gen_portrangeatom6(cstate, 0, port1, port2);\n\t\tb1 = gen_portrangeatom6(cstate, 2, port1, port2);\n\t\tgen_or(tmp, b1);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\tgen_and(b0, b1);\n\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              5922,
              0
            ],
            [
              5960,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrangeop6",
            "parameters": {
              "cstate": "compiler_state_t",
              "port1": "u_int",
              "port2": "u_int",
              "proto": "bpf_u_int32",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_portrange6(compiler_state_t *cstate, u_int port1, u_int port2, int ip_proto,\n    int dir)\n{\n\tstruct block *b0, *b1, *tmp;\n\n\t/* link proto ip6 */\n\tb0 = gen_linktype(cstate, ETHERTYPE_IPV6);\n\n\tswitch (ip_proto) {\n\tcase IPPROTO_UDP:\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_SCTP:\n\t\tb1 = gen_portrangeop6(cstate, port1, port2, (bpf_u_int32)ip_proto,\n\t\t    dir);\n\t\tbreak;\n\n\tcase PROTO_UNDEF:\n\t\ttmp = gen_portrangeop6(cstate, port1, port2, IPPROTO_TCP, dir);\n\t\tb1 = gen_portrangeop6(cstate, port1, port2, IPPROTO_UDP, dir);\n\t\tgen_or(tmp, b1);\n\t\ttmp = gen_portrangeop6(cstate, port1, port2, IPPROTO_SCTP, dir);\n\t\tgen_or(tmp, b1);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\tgen_and(b0, b1);\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              5962,
              0
            ],
            [
              5992,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrange6",
            "parameters": {
              "cstate": "compiler_state_t",
              "port1": "u_int",
              "port2": "u_int",
              "ip_proto": "int",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static int\nlookup_proto(compiler_state_t *cstate, const char *name, int proto)\n{\n\tregister int v;\n\n\tswitch (proto) {\n\n\tcase Q_DEFAULT:\n\tcase Q_IP:\n\tcase Q_IPV6:\n\t\tv = pcap_nametoproto(name);\n\t\tif (v == PROTO_UNDEF)\n\t\t\tbpf_error(cstate, \"unknown ip proto '%s'\", name);\n\t\tbreak;\n\n\tcase Q_LINK:\n\t\t/* XXX should look up h/w protocol type based on cstate->linktype */\n\t\tv = pcap_nametoeproto(name);\n\t\tif (v == PROTO_UNDEF) {\n\t\t\tv = pcap_nametollc(name);\n\t\t\tif (v == PROTO_UNDEF)\n\t\t\t\tbpf_error(cstate, \"unknown ether proto '%s'\", name);\n\t\t}\n\t\tbreak;\n\n\tcase Q_ISO:\n\t\tif (strcmp(name, \"esis\") == 0)\n\t\t\tv = ISO9542_ESIS;\n\t\telse if (strcmp(name, \"isis\") == 0)\n\t\t\tv = ISO10589_ISIS;\n\t\telse if (strcmp(name, \"clnp\") == 0)\n\t\t\tv = ISO8473_CLNP;\n\t\telse\n\t\t\tbpf_error(cstate, \"unknown osi proto '%s'\", name);\n\t\tbreak;\n\n\tdefault:\n\t\tv = PROTO_UNDEF;\n\t\tbreak;\n\t}\n\treturn v;\n}",
          "fn_code_pos": [
            [
              5994,
              0
            ],
            [
              6035,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lookup_proto",
            "parameters": {
              "cstate": "compiler_state_t",
              "name": "char",
              "proto": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "struct stmt *\ngen_joinsp(struct stmt **s, int n)\n{\n\treturn NULL;\n}",
          "fn_code_pos": [
            [
              6038,
              0
            ],
            [
              6042,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_joinsp",
            "parameters": {
              "s": "struct stmt",
              "n": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_protochain(compiler_state_t *cstate, bpf_u_int32 v, int proto)\n{\n#ifdef NO_PROTOCHAIN\n\treturn gen_proto(cstate, v, proto);\n#else\n\tstruct block *b0, *b;\n\tstruct slist *s[100];\n\tint fix2, fix3, fix4, fix5;\n\tint ahcheck, again, end;\n\tint i, max;\n\tint reg2 = alloc_reg(cstate);\n\n\tmemset(s, 0, sizeof(s));\n\tfix3 = fix4 = fix5 = 0;\n\n\tswitch (proto) {\n\tcase Q_IP:\n\tcase Q_IPV6:\n\t\tbreak;\n\tcase Q_DEFAULT:\n\t\tb0 = gen_protochain(cstate, v, Q_IP);\n\t\tb = gen_protochain(cstate, v, Q_IPV6);\n\t\tgen_or(b0, b);\n\t\treturn b;\n\tdefault:\n\t\tbpf_error(cstate, \"bad protocol applied for 'protochain'\");\n\t\t/*NOTREACHED*/\n\t}\n\n\t/*\n\t * We don't handle variable-length prefixes before the link-layer\n\t * header, or variable-length link-layer headers, here yet.\n\t * We might want to add BPF instructions to do the protochain\n\t * work, to simplify that and, on platforms that have a BPF\n\t * interpreter with the new instructions, let the filtering\n\t * be done in the kernel.  (We already require a modified BPF\n\t * engine to do the protochain stuff, to support backward\n\t * branches, and backward branch support is unlikely to appear\n\t * in kernel BPF engines.)\n\t */\n\tif (cstate->off_linkpl.is_variable)\n\t\tbpf_error(cstate, \"'protochain' not supported with variable length headers\");\n\n\tcstate->no_optimize = 1; /* this code is not compatible with optimizer yet */\n\n\t/*\n\t * s[0] is a dummy entry to protect other BPF insn from damage\n\t * by s[fix] = foo with uninitialized variable \"fix\".  It is somewhat\n\t * hard to find interdependency made by jump table fixup.\n\t */\n\ti = 0;\n\ts[i] = new_stmt(cstate, 0);\t/*dummy*/\n\ti++;\n\n\tswitch (proto) {\n\tcase Q_IP:\n\t\tb0 = gen_linktype(cstate, ETHERTYPE_IP);\n\n\t\t/* A = ip->ip_p */\n\t\ts[i] = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_B);\n\t\ts[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 9;\n\t\ti++;\n\t\t/* X = ip->ip_hl << 2 */\n\t\ts[i] = new_stmt(cstate, BPF_LDX|BPF_MSH|BPF_B);\n\t\ts[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\t\ti++;\n\t\tbreak;\n\n\tcase Q_IPV6:\n\t\tb0 = gen_linktype(cstate, ETHERTYPE_IPV6);\n\n\t\t/* A = ip6->ip_nxt */\n\t\ts[i] = new_stmt(cstate, BPF_LD|BPF_ABS|BPF_B);\n\t\ts[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 6;\n\t\ti++;\n\t\t/* X = sizeof(struct ip6_hdr) */\n\t\ts[i] = new_stmt(cstate, BPF_LDX|BPF_IMM);\n\t\ts[i]->s.k = 40;\n\t\ti++;\n\t\tbreak;\n\n\tdefault:\n\t\tbpf_error(cstate, \"unsupported proto to gen_protochain\");\n\t\t/*NOTREACHED*/\n\t}\n\n\t/* again: if (A == v) goto end; else fall through; */\n\tagain = i;\n\ts[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);\n\ts[i]->s.k = v;\n\ts[i]->s.jt = NULL;\t\t/*later*/\n\ts[i]->s.jf = NULL;\t\t/*update in next stmt*/\n\tfix5 = i;\n\ti++;\n\n#ifndef IPPROTO_NONE\n#define IPPROTO_NONE\t59\n#endif\n\t/* if (A == IPPROTO_NONE) goto end */\n\ts[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);\n\ts[i]->s.jt = NULL;\t/*later*/\n\ts[i]->s.jf = NULL;\t/*update in next stmt*/\n\ts[i]->s.k = IPPROTO_NONE;\n\ts[fix5]->s.jf = s[i];\n\tfix2 = i;\n\ti++;\n\n\tif (proto == Q_IPV6) {\n\t\tint v6start, v6end, v6advance, j;\n\n\t\tv6start = i;\n\t\t/* if (A == IPPROTO_HOPOPTS) goto v6advance */\n\t\ts[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);\n\t\ts[i]->s.jt = NULL;\t/*later*/\n\t\ts[i]->s.jf = NULL;\t/*update in next stmt*/\n\t\ts[i]->s.k = IPPROTO_HOPOPTS;\n\t\ts[fix2]->s.jf = s[i];\n\t\ti++;\n\t\t/* if (A == IPPROTO_DSTOPTS) goto v6advance */\n\t\ts[i - 1]->s.jf = s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);\n\t\ts[i]->s.jt = NULL;\t/*later*/\n\t\ts[i]->s.jf = NULL;\t/*update in next stmt*/\n\t\ts[i]->s.k = IPPROTO_DSTOPTS;\n\t\ti++;\n\t\t/* if (A == IPPROTO_ROUTING) goto v6advance */\n\t\ts[i - 1]->s.jf = s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);\n\t\ts[i]->s.jt = NULL;\t/*later*/\n\t\ts[i]->s.jf = NULL;\t/*update in next stmt*/\n\t\ts[i]->s.k = IPPROTO_ROUTING;\n\t\ti++;\n\t\t/* if (A == IPPROTO_FRAGMENT) goto v6advance; else goto ahcheck; */\n\t\ts[i - 1]->s.jf = s[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);\n\t\ts[i]->s.jt = NULL;\t/*later*/\n\t\ts[i]->s.jf = NULL;\t/*later*/\n\t\ts[i]->s.k = IPPROTO_FRAGMENT;\n\t\tfix3 = i;\n\t\tv6end = i;\n\t\ti++;\n\n\t\t/* v6advance: */\n\t\tv6advance = i;\n\n\t\t/*\n\t\t * in short,\n\t\t * A = P[X + packet head];\n\t\t * X = X + (P[X + packet head + 1] + 1) * 8;\n\t\t */\n\t\t/* A = P[X + packet head] */\n\t\ts[i] = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);\n\t\ts[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\t\ti++;\n\t\t/* MEM[reg2] = A */\n\t\ts[i] = new_stmt(cstate, BPF_ST);\n\t\ts[i]->s.k = reg2;\n\t\ti++;\n\t\t/* A = P[X + packet head + 1]; */\n\t\ts[i] = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);\n\t\ts[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 1;\n\t\ti++;\n\t\t/* A += 1 */\n\t\ts[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\t\ts[i]->s.k = 1;\n\t\ti++;\n\t\t/* A *= 8 */\n\t\ts[i] = new_stmt(cstate, BPF_ALU|BPF_MUL|BPF_K);\n\t\ts[i]->s.k = 8;\n\t\ti++;\n\t\t/* A += X */\n\t\ts[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X);\n\t\ts[i]->s.k = 0;\n\t\ti++;\n\t\t/* X = A; */\n\t\ts[i] = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\t\ti++;\n\t\t/* A = MEM[reg2] */\n\t\ts[i] = new_stmt(cstate, BPF_LD|BPF_MEM);\n\t\ts[i]->s.k = reg2;\n\t\ti++;\n\n\t\t/* goto again; (must use BPF_JA for backward jump) */\n\t\ts[i] = new_stmt(cstate, BPF_JMP|BPF_JA);\n\t\ts[i]->s.k = again - i - 1;\n\t\ts[i - 1]->s.jf = s[i];\n\t\ti++;\n\n\t\t/* fixup */\n\t\tfor (j = v6start; j <= v6end; j++)\n\t\t\ts[j]->s.jt = s[v6advance];\n\t} else {\n\t\t/* nop */\n\t\ts[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\t\ts[i]->s.k = 0;\n\t\ts[fix2]->s.jf = s[i];\n\t\ti++;\n\t}\n\n\t/* ahcheck: */\n\tahcheck = i;\n\t/* if (A == IPPROTO_AH) then fall through; else goto end; */\n\ts[i] = new_stmt(cstate, BPF_JMP|BPF_JEQ|BPF_K);\n\ts[i]->s.jt = NULL;\t/*later*/\n\ts[i]->s.jf = NULL;\t/*later*/\n\ts[i]->s.k = IPPROTO_AH;\n\tif (fix3)\n\t\ts[fix3]->s.jf = s[ahcheck];\n\tfix4 = i;\n\ti++;\n\n\t/*\n\t * in short,\n\t * A = P[X];\n\t * X = X + (P[X + 1] + 2) * 4;\n\t */\n\t/* A = X */\n\ts[i - 1]->s.jt = s[i] = new_stmt(cstate, BPF_MISC|BPF_TXA);\n\ti++;\n\t/* A = P[X + packet head]; */\n\ts[i] = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);\n\ts[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\ti++;\n\t/* MEM[reg2] = A */\n\ts[i] = new_stmt(cstate, BPF_ST);\n\ts[i]->s.k = reg2;\n\ti++;\n\t/* A = X */\n\ts[i - 1]->s.jt = s[i] = new_stmt(cstate, BPF_MISC|BPF_TXA);\n\ti++;\n\t/* A += 1 */\n\ts[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts[i]->s.k = 1;\n\ti++;\n\t/* X = A */\n\ts[i] = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\ti++;\n\t/* A = P[X + packet head] */\n\ts[i] = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);\n\ts[i]->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\ti++;\n\t/* A += 2 */\n\ts[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts[i]->s.k = 2;\n\ti++;\n\t/* A *= 4 */\n\ts[i] = new_stmt(cstate, BPF_ALU|BPF_MUL|BPF_K);\n\ts[i]->s.k = 4;\n\ti++;\n\t/* X = A; */\n\ts[i] = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\ti++;\n\t/* A = MEM[reg2] */\n\ts[i] = new_stmt(cstate, BPF_LD|BPF_MEM);\n\ts[i]->s.k = reg2;\n\ti++;\n\n\t/* goto again; (must use BPF_JA for backward jump) */\n\ts[i] = new_stmt(cstate, BPF_JMP|BPF_JA);\n\ts[i]->s.k = again - i - 1;\n\ti++;\n\n\t/* end: nop */\n\tend = i;\n\ts[i] = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts[i]->s.k = 0;\n\ts[fix2]->s.jt = s[end];\n\ts[fix4]->s.jf = s[end];\n\ts[fix5]->s.jt = s[end];\n\ti++;\n\n\t/*\n\t * make slist chain\n\t */\n\tmax = i;\n\tfor (i = 0; i < max - 1; i++)\n\t\ts[i]->next = s[i + 1];\n\ts[max - 1]->next = NULL;\n\n\t/*\n\t * emit final check\n\t */\n\tb = new_block(cstate, JMP(BPF_JEQ));\n\tb->stmts = s[1];\t/*remember, s[0] is dummy*/\n\tb->s.k = v;\n\n\tfree_reg(cstate, reg2);\n\n\tgen_and(b0, b);\n\treturn b;\n#endif\n}",
          "fn_code_pos": [
            [
              6045,
              0
            ],
            [
              6334,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_protochain",
            "parameters": {
              "cstate": "compiler_state_t",
              "v": "bpf_u_int32",
              "proto": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_check_802_11_data_frame(compiler_state_t *cstate)\n{\n\tstruct slist *s;\n\tstruct block *b0, *b1;\n\n\t/*\n\t * A data frame has the 0x08 bit (b3) in the frame control field set\n\t * and the 0x04 bit (b2) clear.\n\t */\n\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\tb0 = new_block(cstate, JMP(BPF_JSET));\n\tb0->s.k = 0x08;\n\tb0->stmts = s;\n\n\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\tb1 = new_block(cstate, JMP(BPF_JSET));\n\tb1->s.k = 0x04;\n\tb1->stmts = s;\n\tgen_not(b1);\n\n\tgen_and(b1, b0);\n\n\treturn b0;\n}",
          "fn_code_pos": [
            [
              6336,
              0
            ],
            [
              6360,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_check_802_11_data_frame",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_proto(compiler_state_t *cstate, bpf_u_int32 v, int proto, int dir)\n{\n\tstruct block *b0, *b1;\n#ifndef CHASE_CHAIN\n\tstruct block *b2;\n#endif\n\n\tif (dir != Q_DEFAULT)\n\t\tbpf_error(cstate, \"direction applied to 'proto'\");\n\n\tswitch (proto) {\n\tcase Q_DEFAULT:\n\t\tb0 = gen_proto(cstate, v, Q_IP, dir);\n\t\tb1 = gen_proto(cstate, v, Q_IPV6, dir);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_LINK:\n\t\treturn gen_linktype(cstate, v);\n\n\tcase Q_IP:\n\t\t/*\n\t\t * For FDDI, RFC 1188 says that SNAP encapsulation is used,\n\t\t * not LLC encapsulation with LLCSAP_IP.\n\t\t *\n\t\t * For IEEE 802 networks - which includes 802.5 token ring\n\t\t * (which is what DLT_IEEE802 means) and 802.11 - RFC 1042\n\t\t * says that SNAP encapsulation is used, not LLC encapsulation\n\t\t * with LLCSAP_IP.\n\t\t *\n\t\t * For LLC-encapsulated ATM/\"Classical IP\", RFC 1483 and\n\t\t * RFC 2225 say that SNAP encapsulation is used, not LLC\n\t\t * encapsulation with LLCSAP_IP.\n\t\t *\n\t\t * So we always check for ETHERTYPE_IP.\n\t\t */\n\t\tb0 = gen_linktype(cstate, ETHERTYPE_IP);\n#ifndef CHASE_CHAIN\n\t\tb1 = gen_cmp(cstate, OR_LINKPL, 9, BPF_B, v);\n#else\n\t\tb1 = gen_protochain(cstate, v, Q_IP);\n#endif\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ARP:\n\t\tbpf_error(cstate, \"arp does not encapsulate another protocol\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RARP:\n\t\tbpf_error(cstate, \"rarp does not encapsulate another protocol\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_SCTP:\n\t\tbpf_error(cstate, \"'sctp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_TCP:\n\t\tbpf_error(cstate, \"'tcp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_UDP:\n\t\tbpf_error(cstate, \"'udp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ICMP:\n\t\tbpf_error(cstate, \"'icmp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_IGMP:\n\t\tbpf_error(cstate, \"'igmp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_IGRP:\n\t\tbpf_error(cstate, \"'igrp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ATALK:\n\t\tbpf_error(cstate, \"AppleTalk encapsulation is not specifiable\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_DECNET:\n\t\tbpf_error(cstate, \"DECNET encapsulation is not specifiable\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_LAT:\n\t\tbpf_error(cstate, \"LAT does not encapsulate another protocol\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_SCA:\n\t\tbpf_error(cstate, \"SCA does not encapsulate another protocol\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_MOPRC:\n\t\tbpf_error(cstate, \"MOPRC does not encapsulate another protocol\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_MOPDL:\n\t\tbpf_error(cstate, \"MOPDL does not encapsulate another protocol\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_IPV6:\n\t\tb0 = gen_linktype(cstate, ETHERTYPE_IPV6);\n#ifndef CHASE_CHAIN\n\t\t/*\n\t\t * Also check for a fragment header before the final\n\t\t * header.\n\t\t */\n\t\tb2 = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, IPPROTO_FRAGMENT);\n\t\tb1 = gen_cmp(cstate, OR_LINKPL, 40, BPF_B, v);\n\t\tgen_and(b2, b1);\n\t\tb2 = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, v);\n\t\tgen_or(b2, b1);\n#else\n\t\tb1 = gen_protochain(cstate, v, Q_IPV6);\n#endif\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ICMPV6:\n\t\tbpf_error(cstate, \"'icmp6 proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_AH:\n\t\tbpf_error(cstate, \"'ah proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ESP:\n\t\tbpf_error(cstate, \"'ah proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_PIM:\n\t\tbpf_error(cstate, \"'pim proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_VRRP:\n\t\tbpf_error(cstate, \"'vrrp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_AARP:\n\t\tbpf_error(cstate, \"'aarp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISO:\n\t\tswitch (cstate->linktype) {\n\n\t\tcase DLT_FRELAY:\n\t\t\t/*\n\t\t\t * Frame Relay packets typically have an OSI\n\t\t\t * NLPID at the beginning; \"gen_linktype(cstate, LLCSAP_ISONS)\"\n\t\t\t * generates code to check for all the OSI\n\t\t\t * NLPIDs, so calling it and then adding a check\n\t\t\t * for the particular NLPID for which we're\n\t\t\t * looking is bogus, as we can just check for\n\t\t\t * the NLPID.\n\t\t\t *\n\t\t\t * What we check for is the NLPID and a frame\n\t\t\t * control field value of UI, i.e. 0x03 followed\n\t\t\t * by the NLPID.\n\t\t\t *\n\t\t\t * XXX - assumes a 2-byte Frame Relay header with\n\t\t\t * DLCI and flags.  What if the address is longer?\n\t\t\t *\n\t\t\t * XXX - what about SNAP-encapsulated frames?\n\t\t\t */\n\t\t\treturn gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, (0x03<<8) | v);\n\t\t\t/*NOTREACHED*/\n\n\t\tcase DLT_C_HDLC:\n\t\t\t/*\n\t\t\t * Cisco uses an Ethertype lookalike - for OSI,\n\t\t\t * it's 0xfefe.\n\t\t\t */\n\t\t\tb0 = gen_linktype(cstate, LLCSAP_ISONS<<8 | LLCSAP_ISONS);\n\t\t\t/* OSI in C-HDLC is stuffed with a fudge byte */\n\t\t\tb1 = gen_cmp(cstate, OR_LINKPL_NOSNAP, 1, BPF_B, v);\n\t\t\tgen_and(b0, b1);\n\t\t\treturn b1;\n\n\t\tdefault:\n\t\t\tb0 = gen_linktype(cstate, LLCSAP_ISONS);\n\t\t\tb1 = gen_cmp(cstate, OR_LINKPL_NOSNAP, 0, BPF_B, v);\n\t\t\tgen_and(b0, b1);\n\t\t\treturn b1;\n\t\t}\n\n\tcase Q_ESIS:\n\t\tbpf_error(cstate, \"'esis proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISIS:\n\t\tb0 = gen_proto(cstate, ISO10589_ISIS, Q_ISO, Q_DEFAULT);\n\t\t/*\n\t\t * 4 is the offset of the PDU type relative to the IS-IS\n\t\t * header.\n\t\t */\n\t\tb1 = gen_cmp(cstate, OR_LINKPL_NOSNAP, 4, BPF_B, v);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_CLNP:\n\t\tbpf_error(cstate, \"'clnp proto' is not supported\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_STP:\n\t\tbpf_error(cstate, \"'stp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_IPX:\n\t\tbpf_error(cstate, \"'ipx proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_NETBEUI:\n\t\tbpf_error(cstate, \"'netbeui proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISIS_L1:\n\t\tbpf_error(cstate, \"'l1 proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISIS_L2:\n\t\tbpf_error(cstate, \"'l2 proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISIS_IIH:\n\t\tbpf_error(cstate, \"'iih proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISIS_SNP:\n\t\tbpf_error(cstate, \"'snp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISIS_CSNP:\n\t\tbpf_error(cstate, \"'csnp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISIS_PSNP:\n\t\tbpf_error(cstate, \"'psnp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_ISIS_LSP:\n\t\tbpf_error(cstate, \"'lsp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_RADIO:\n\t\tbpf_error(cstate, \"'radio proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_CARP:\n\t\tbpf_error(cstate, \"'carp proto' is bogus\");\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tabort();\n\t\t/*NOTREACHED*/\n\t}\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              6371,
              0
            ],
            [
              6629,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_proto",
            "parameters": {
              "cstate": "compiler_state_t",
              "v": "bpf_u_int32",
              "proto": "int",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_scode(compiler_state_t *cstate, const char *name, struct qual q)\n{\n\tint proto = q.proto;\n\tint dir = q.dir;\n\tint tproto;\n\tu_char *eaddr;\n\tbpf_u_int32 mask, addr;\n\tstruct addrinfo *res, *res0;\n\tstruct sockaddr_in *sin4;\n#ifdef INET6\n\tint tproto6;\n\tstruct sockaddr_in6 *sin6;\n\tstruct in6_addr mask128;\n#endif /*INET6*/\n\tstruct block *b, *tmp;\n\tint port, real_proto;\n\tint port1, port2;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (q.addr) {\n\n\tcase Q_NET:\n\t\taddr = pcap_nametonetaddr(name);\n\t\tif (addr == 0)\n\t\t\tbpf_error(cstate, \"unknown network '%s'\", name);\n\t\t/* Left justify network addr and calculate its network mask */\n\t\tmask = 0xffffffff;\n\t\twhile (addr && (addr & 0xff000000) == 0) {\n\t\t\taddr <<= 8;\n\t\t\tmask <<= 8;\n\t\t}\n\t\treturn gen_host(cstate, addr, mask, proto, dir, q.addr);\n\n\tcase Q_DEFAULT:\n\tcase Q_HOST:\n\t\tif (proto == Q_LINK) {\n\t\t\tswitch (cstate->linktype) {\n\n\t\t\tcase DLT_EN10MB:\n\t\t\tcase DLT_NETANALYZER:\n\t\t\tcase DLT_NETANALYZER_TRANSPARENT:\n\t\t\t\teaddr = pcap_ether_hostton(name);\n\t\t\t\tif (eaddr == NULL)\n\t\t\t\t\tbpf_error(cstate,\n\t\t\t\t\t    \"unknown ether host '%s'\", name);\n\t\t\t\ttmp = gen_prevlinkhdr_check(cstate);\n\t\t\t\tb = gen_ehostop(cstate, eaddr, dir);\n\t\t\t\tif (tmp != NULL)\n\t\t\t\t\tgen_and(tmp, b);\n\t\t\t\tfree(eaddr);\n\t\t\t\treturn b;\n\n\t\t\tcase DLT_FDDI:\n\t\t\t\teaddr = pcap_ether_hostton(name);\n\t\t\t\tif (eaddr == NULL)\n\t\t\t\t\tbpf_error(cstate,\n\t\t\t\t\t    \"unknown FDDI host '%s'\", name);\n\t\t\t\tb = gen_fhostop(cstate, eaddr, dir);\n\t\t\t\tfree(eaddr);\n\t\t\t\treturn b;\n\n\t\t\tcase DLT_IEEE802:\n\t\t\t\teaddr = pcap_ether_hostton(name);\n\t\t\t\tif (eaddr == NULL)\n\t\t\t\t\tbpf_error(cstate,\n\t\t\t\t\t    \"unknown token ring host '%s'\", name);\n\t\t\t\tb = gen_thostop(cstate, eaddr, dir);\n\t\t\t\tfree(eaddr);\n\t\t\t\treturn b;\n\n\t\t\tcase DLT_IEEE802_11:\n\t\t\tcase DLT_PRISM_HEADER:\n\t\t\tcase DLT_IEEE802_11_RADIO_AVS:\n\t\t\tcase DLT_IEEE802_11_RADIO:\n\t\t\tcase DLT_PPI:\n\t\t\t\teaddr = pcap_ether_hostton(name);\n\t\t\t\tif (eaddr == NULL)\n\t\t\t\t\tbpf_error(cstate,\n\t\t\t\t\t    \"unknown 802.11 host '%s'\", name);\n\t\t\t\tb = gen_wlanhostop(cstate, eaddr, dir);\n\t\t\t\tfree(eaddr);\n\t\t\t\treturn b;\n\n\t\t\tcase DLT_IP_OVER_FC:\n\t\t\t\teaddr = pcap_ether_hostton(name);\n\t\t\t\tif (eaddr == NULL)\n\t\t\t\t\tbpf_error(cstate,\n\t\t\t\t\t    \"unknown Fibre Channel host '%s'\", name);\n\t\t\t\tb = gen_ipfchostop(cstate, eaddr, dir);\n\t\t\t\tfree(eaddr);\n\t\t\t\treturn b;\n\t\t\t}\n\n\t\t\tbpf_error(cstate, \"only ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel supports link-level host name\");\n\t\t} else if (proto == Q_DECNET) {\n\t\t\tunsigned short dn_addr;\n\n\t\t\tif (!__pcap_nametodnaddr(name, &dn_addr)) {\n#ifdef\tDECNETLIB\n\t\t\t\tbpf_error(cstate, \"unknown decnet host name '%s'\\n\", name);\n#else\n\t\t\t\tbpf_error(cstate, \"decnet name support not included, '%s' cannot be translated\\n\",\n\t\t\t\t\tname);\n#endif\n\t\t\t}\n\t\t\t/*\n\t\t\t * I don't think DECNET hosts can be multihomed, so\n\t\t\t * there is no need to build up a list of addresses\n\t\t\t */\n\t\t\treturn (gen_host(cstate, dn_addr, 0, proto, dir, q.addr));\n\t\t} else {\n#ifdef INET6\n\t\t\tmemset(&mask128, 0xff, sizeof(mask128));\n#endif\n\t\t\tres0 = res = pcap_nametoaddrinfo(name);\n\t\t\tif (res == NULL)\n\t\t\t\tbpf_error(cstate, \"unknown host '%s'\", name);\n\t\t\tcstate->ai = res;\n\t\t\tb = tmp = NULL;\n\t\t\ttproto = proto;\n#ifdef INET6\n\t\t\ttproto6 = proto;\n#endif\n\t\t\tif (cstate->off_linktype.constant_part == OFFSET_NOT_SET &&\n\t\t\t    tproto == Q_DEFAULT) {\n\t\t\t\ttproto = Q_IP;\n#ifdef INET6\n\t\t\t\ttproto6 = Q_IPV6;\n#endif\n\t\t\t}\n\t\t\tfor (res = res0; res; res = res->ai_next) {\n\t\t\t\tswitch (res->ai_family) {\n\t\t\t\tcase AF_INET:\n#ifdef INET6\n\t\t\t\t\tif (tproto == Q_IPV6)\n\t\t\t\t\t\tcontinue;\n#endif\n\n\t\t\t\t\tsin4 = (struct sockaddr_in *)\n\t\t\t\t\t\tres->ai_addr;\n\t\t\t\t\ttmp = gen_host(cstate, ntohl(sin4->sin_addr.s_addr),\n\t\t\t\t\t\t0xffffffff, tproto, dir, q.addr);\n\t\t\t\t\tbreak;\n#ifdef INET6\n\t\t\t\tcase AF_INET6:\n\t\t\t\t\tif (tproto6 == Q_IP)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsin6 = (struct sockaddr_in6 *)\n\t\t\t\t\t\tres->ai_addr;\n\t\t\t\t\ttmp = gen_host6(cstate, &sin6->sin6_addr,\n\t\t\t\t\t\t&mask128, tproto6, dir, q.addr);\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (b)\n\t\t\t\t\tgen_or(b, tmp);\n\t\t\t\tb = tmp;\n\t\t\t}\n\t\t\tcstate->ai = NULL;\n\t\t\tfreeaddrinfo(res0);\n\t\t\tif (b == NULL) {\n\t\t\t\tbpf_error(cstate, \"unknown host '%s'%s\", name,\n\t\t\t\t    (proto == Q_DEFAULT)\n\t\t\t\t\t? \"\"\n\t\t\t\t\t: \" for specified address family\");\n\t\t\t}\n\t\t\treturn b;\n\t\t}\n\n\tcase Q_PORT:\n\t\tif (proto != Q_DEFAULT &&\n\t\t    proto != Q_UDP && proto != Q_TCP && proto != Q_SCTP)\n\t\t\tbpf_error(cstate, \"illegal qualifier of 'port'\");\n\t\tif (pcap_nametoport(name, &port, &real_proto) == 0)\n\t\t\tbpf_error(cstate, \"unknown port '%s'\", name);\n\t\tif (proto == Q_UDP) {\n\t\t\tif (real_proto == IPPROTO_TCP)\n\t\t\t\tbpf_error(cstate, \"port '%s' is tcp\", name);\n\t\t\telse if (real_proto == IPPROTO_SCTP)\n\t\t\t\tbpf_error(cstate, \"port '%s' is sctp\", name);\n\t\t\telse\n\t\t\t\t/* override PROTO_UNDEF */\n\t\t\t\treal_proto = IPPROTO_UDP;\n\t\t}\n\t\tif (proto == Q_TCP) {\n\t\t\tif (real_proto == IPPROTO_UDP)\n\t\t\t\tbpf_error(cstate, \"port '%s' is udp\", name);\n\n\t\t\telse if (real_proto == IPPROTO_SCTP)\n\t\t\t\tbpf_error(cstate, \"port '%s' is sctp\", name);\n\t\t\telse\n\t\t\t\t/* override PROTO_UNDEF */\n\t\t\t\treal_proto = IPPROTO_TCP;\n\t\t}\n\t\tif (proto == Q_SCTP) {\n\t\t\tif (real_proto == IPPROTO_UDP)\n\t\t\t\tbpf_error(cstate, \"port '%s' is udp\", name);\n\n\t\t\telse if (real_proto == IPPROTO_TCP)\n\t\t\t\tbpf_error(cstate, \"port '%s' is tcp\", name);\n\t\t\telse\n\t\t\t\t/* override PROTO_UNDEF */\n\t\t\t\treal_proto = IPPROTO_SCTP;\n\t\t}\n\t\tif (port < 0)\n\t\t\tbpf_error(cstate, \"illegal port number %d < 0\", port);\n\t\tif (port > 65535)\n\t\t\tbpf_error(cstate, \"illegal port number %d > 65535\", port);\n\t\tb = gen_port(cstate, port, real_proto, dir);\n\t\tgen_or(gen_port6(cstate, port, real_proto, dir), b);\n\t\treturn b;\n\n\tcase Q_PORTRANGE:\n\t\tif (proto != Q_DEFAULT &&\n\t\t    proto != Q_UDP && proto != Q_TCP && proto != Q_SCTP)\n\t\t\tbpf_error(cstate, \"illegal qualifier of 'portrange'\");\n\t\tif (pcap_nametoportrange(name, &port1, &port2, &real_proto) == 0)\n\t\t\tbpf_error(cstate, \"unknown port in range '%s'\", name);\n\t\tif (proto == Q_UDP) {\n\t\t\tif (real_proto == IPPROTO_TCP)\n\t\t\t\tbpf_error(cstate, \"port in range '%s' is tcp\", name);\n\t\t\telse if (real_proto == IPPROTO_SCTP)\n\t\t\t\tbpf_error(cstate, \"port in range '%s' is sctp\", name);\n\t\t\telse\n\t\t\t\t/* override PROTO_UNDEF */\n\t\t\t\treal_proto = IPPROTO_UDP;\n\t\t}\n\t\tif (proto == Q_TCP) {\n\t\t\tif (real_proto == IPPROTO_UDP)\n\t\t\t\tbpf_error(cstate, \"port in range '%s' is udp\", name);\n\t\t\telse if (real_proto == IPPROTO_SCTP)\n\t\t\t\tbpf_error(cstate, \"port in range '%s' is sctp\", name);\n\t\t\telse\n\t\t\t\t/* override PROTO_UNDEF */\n\t\t\t\treal_proto = IPPROTO_TCP;\n\t\t}\n\t\tif (proto == Q_SCTP) {\n\t\t\tif (real_proto == IPPROTO_UDP)\n\t\t\t\tbpf_error(cstate, \"port in range '%s' is udp\", name);\n\t\t\telse if (real_proto == IPPROTO_TCP)\n\t\t\t\tbpf_error(cstate, \"port in range '%s' is tcp\", name);\n\t\t\telse\n\t\t\t\t/* override PROTO_UNDEF */\n\t\t\t\treal_proto = IPPROTO_SCTP;\n\t\t}\n\t\tif (port1 < 0)\n\t\t\tbpf_error(cstate, \"illegal port number %d < 0\", port1);\n\t\tif (port1 > 65535)\n\t\t\tbpf_error(cstate, \"illegal port number %d > 65535\", port1);\n\t\tif (port2 < 0)\n\t\t\tbpf_error(cstate, \"illegal port number %d < 0\", port2);\n\t\tif (port2 > 65535)\n\t\t\tbpf_error(cstate, \"illegal port number %d > 65535\", port2);\n\n\t\tb = gen_portrange(cstate, port1, port2, real_proto, dir);\n\t\tgen_or(gen_portrange6(cstate, port1, port2, real_proto, dir), b);\n\t\treturn b;\n\n\tcase Q_GATEWAY:\n#ifndef INET6\n\t\teaddr = pcap_ether_hostton(name);\n\t\tif (eaddr == NULL)\n\t\t\tbpf_error(cstate, \"unknown ether host: %s\", name);\n\n\t\tres = pcap_nametoaddrinfo(name);\n\t\tcstate->ai = res;\n\t\tif (res == NULL)\n\t\t\tbpf_error(cstate, \"unknown host '%s'\", name);\n\t\tb = gen_gateway(cstate, eaddr, res, proto, dir);\n\t\tcstate->ai = NULL;\n\t\tfreeaddrinfo(res);\n\t\tif (b == NULL)\n\t\t\tbpf_error(cstate, \"unknown host '%s'\", name);\n\t\treturn b;\n#else\n\t\tbpf_error(cstate, \"'gateway' not supported in this configuration\");\n#endif /*INET6*/\n\n\tcase Q_PROTO:\n\t\treal_proto = lookup_proto(cstate, name, proto);\n\t\tif (real_proto >= 0)\n\t\t\treturn gen_proto(cstate, real_proto, proto, dir);\n\t\telse\n\t\t\tbpf_error(cstate, \"unknown protocol: %s\", name);\n\n\tcase Q_PROTOCHAIN:\n\t\treal_proto = lookup_proto(cstate, name, proto);\n\t\tif (real_proto >= 0)\n\t\t\treturn gen_protochain(cstate, real_proto, proto);\n\t\telse\n\t\t\tbpf_error(cstate, \"unknown protocol: %s\", name);\n\n\tcase Q_UNDEF:\n\t\tsyntax(cstate);\n\t\t/*NOTREACHED*/\n\t}\n\tabort();\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              6631,
              0
            ],
            [
              6939,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_scode",
            "parameters": {
              "cstate": "compiler_state_t",
              "name": "char",
              "q": "struct qual"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_mcode(compiler_state_t *cstate, const char *s1, const char *s2,\n    bpf_u_int32 masklen, struct qual q)\n{\n\tregister int nlen, mlen;\n\tbpf_u_int32 n, m;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tnlen = __pcap_atoin(s1, &n);\n\t/* Promote short ipaddr */\n\tn <<= 32 - nlen;\n\n\tif (s2 != NULL) {\n\t\tmlen = __pcap_atoin(s2, &m);\n\t\t/* Promote short ipaddr */\n\t\tm <<= 32 - mlen;\n\t\tif ((n & ~m) != 0)\n\t\t\tbpf_error(cstate, \"non-network bits set in \\\"%s mask %s\\\"\",\n\t\t\t    s1, s2);\n\t} else {\n\t\t/* Convert mask len to mask */\n\t\tif (masklen > 32)\n\t\t\tbpf_error(cstate, \"mask length must be <= 32\");\n\t\tif (masklen == 0) {\n\t\t\t/*\n\t\t\t * X << 32 is not guaranteed by C to be 0; it's\n\t\t\t * undefined.\n\t\t\t */\n\t\t\tm = 0;\n\t\t} else\n\t\t\tm = 0xffffffff << (32 - masklen);\n\t\tif ((n & ~m) != 0)\n\t\t\tbpf_error(cstate, \"non-network bits set in \\\"%s/%d\\\"\",\n\t\t\t    s1, masklen);\n\t}\n\n\tswitch (q.addr) {\n\n\tcase Q_NET:\n\t\treturn gen_host(cstate, n, m, q.proto, q.dir, q.addr);\n\n\tdefault:\n\t\tbpf_error(cstate, \"Mask syntax for networks only\");\n\t\t/*NOTREACHED*/\n\t}\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              6941,
              0
            ],
            [
              6993,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mcode",
            "parameters": {
              "cstate": "compiler_state_t",
              "s1": "char",
              "s2": "char",
              "masklen": "bpf_u_int32",
              "q": "struct qual"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_ncode(compiler_state_t *cstate, const char *s, bpf_u_int32 v, struct qual q)\n{\n\tbpf_u_int32 mask;\n\tint proto;\n\tint dir;\n\tregister int vlen;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tproto = q.proto;\n\tdir = q.dir;\n\tif (s == NULL)\n\t\tvlen = 32;\n\telse if (q.proto == Q_DECNET) {\n\t\tvlen = __pcap_atodn(s, &v);\n\t\tif (vlen == 0)\n\t\t\tbpf_error(cstate, \"malformed decnet address '%s'\", s);\n\t} else\n\t\tvlen = __pcap_atoin(s, &v);\n\n\tswitch (q.addr) {\n\n\tcase Q_DEFAULT:\n\tcase Q_HOST:\n\tcase Q_NET:\n\t\tif (proto == Q_DECNET)\n\t\t\treturn gen_host(cstate, v, 0, proto, dir, q.addr);\n\t\telse if (proto == Q_LINK) {\n\t\t\tbpf_error(cstate, \"illegal link layer address\");\n\t\t} else {\n\t\t\tmask = 0xffffffff;\n\t\t\tif (s == NULL && q.addr == Q_NET) {\n\t\t\t\t/* Promote short net number */\n\t\t\t\twhile (v && (v & 0xff000000) == 0) {\n\t\t\t\t\tv <<= 8;\n\t\t\t\t\tmask <<= 8;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Promote short ipaddr */\n\t\t\t\tv <<= 32 - vlen;\n\t\t\t\tmask <<= 32 - vlen ;\n\t\t\t}\n\t\t\treturn gen_host(cstate, v, mask, proto, dir, q.addr);\n\t\t}\n\n\tcase Q_PORT:\n\t\tif (proto == Q_UDP)\n\t\t\tproto = IPPROTO_UDP;\n\t\telse if (proto == Q_TCP)\n\t\t\tproto = IPPROTO_TCP;\n\t\telse if (proto == Q_SCTP)\n\t\t\tproto = IPPROTO_SCTP;\n\t\telse if (proto == Q_DEFAULT)\n\t\t\tproto = PROTO_UNDEF;\n\t\telse\n\t\t\tbpf_error(cstate, \"illegal qualifier of 'port'\");\n\n\t\tif (v > 65535)\n\t\t\tbpf_error(cstate, \"illegal port number %u > 65535\", v);\n\n\t    {\n\t\tstruct block *b;\n\t\tb = gen_port(cstate, v, proto, dir);\n\t\tgen_or(gen_port6(cstate, v, proto, dir), b);\n\t\treturn b;\n\t    }\n\n\tcase Q_PORTRANGE:\n\t\tif (proto == Q_UDP)\n\t\t\tproto = IPPROTO_UDP;\n\t\telse if (proto == Q_TCP)\n\t\t\tproto = IPPROTO_TCP;\n\t\telse if (proto == Q_SCTP)\n\t\t\tproto = IPPROTO_SCTP;\n\t\telse if (proto == Q_DEFAULT)\n\t\t\tproto = PROTO_UNDEF;\n\t\telse\n\t\t\tbpf_error(cstate, \"illegal qualifier of 'portrange'\");\n\n\t\tif (v > 65535)\n\t\t\tbpf_error(cstate, \"illegal port number %u > 65535\", v);\n\n\t    {\n\t\tstruct block *b;\n\t\tb = gen_portrange(cstate, v, v, proto, dir);\n\t\tgen_or(gen_portrange6(cstate, v, v, proto, dir), b);\n\t\treturn b;\n\t    }\n\n\tcase Q_GATEWAY:\n\t\tbpf_error(cstate, \"'gateway' requires a name\");\n\t\t/*NOTREACHED*/\n\n\tcase Q_PROTO:\n\t\treturn gen_proto(cstate, v, proto, dir);\n\n\tcase Q_PROTOCHAIN:\n\t\treturn gen_protochain(cstate, v, proto);\n\n\tcase Q_UNDEF:\n\t\tsyntax(cstate);\n\t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tabort();\n\t\t/*NOTREACHED*/\n\t}\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              6995,
              0
            ],
            [
              7109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ncode",
            "parameters": {
              "cstate": "compiler_state_t",
              "s": "char",
              "v": "bpf_u_int32",
              "q": "struct qual"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_mcode6(compiler_state_t *cstate, const char *s1, const char *s2,\n    bpf_u_int32 masklen, struct qual q)\n{\n\tstruct addrinfo *res;\n\tstruct in6_addr *addr;\n\tstruct in6_addr mask;\n\tstruct block *b;\n\tuint32_t *a, *m;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif (s2)\n\t\tbpf_error(cstate, \"no mask %s supported\", s2);\n\n\tres = pcap_nametoaddrinfo(s1);\n\tif (!res)\n\t\tbpf_error(cstate, \"invalid ip6 address %s\", s1);\n\tcstate->ai = res;\n\tif (res->ai_next)\n\t\tbpf_error(cstate, \"%s resolved to multiple address\", s1);\n\taddr = &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr;\n\n\tif (sizeof(mask) * 8 < masklen)\n\t\tbpf_error(cstate, \"mask length must be <= %u\", (unsigned int)(sizeof(mask) * 8));\n\tmemset(&mask, 0, sizeof(mask));\n\tmemset(&mask, 0xff, masklen / 8);\n\tif (masklen % 8) {\n\t\tmask.s6_addr[masklen / 8] =\n\t\t\t(0xff << (8 - masklen % 8)) & 0xff;\n\t}\n\n\ta = (uint32_t *)addr;\n\tm = (uint32_t *)&mask;\n\tif ((a[0] & ~m[0]) || (a[1] & ~m[1])\n\t || (a[2] & ~m[2]) || (a[3] & ~m[3])) {\n\t\tbpf_error(cstate, \"non-network bits set in \\\"%s/%d\\\"\", s1, masklen);\n\t}\n\n\tswitch (q.addr) {\n\n\tcase Q_DEFAULT:\n\tcase Q_HOST:\n\t\tif (masklen != 128)\n\t\t\tbpf_error(cstate, \"Mask syntax for networks only\");\n\t\t/* FALLTHROUGH */\n\n\tcase Q_NET:\n\t\tb = gen_host6(cstate, addr, &mask, q.proto, q.dir, q.addr);\n\t\tcstate->ai = NULL;\n\t\tfreeaddrinfo(res);\n\t\treturn b;\n\n\tdefault:\n\t\tbpf_error(cstate, \"invalid qualifier against IPv6 address\");\n\t\t/*NOTREACHED*/\n\t}\n}",
          "fn_code_pos": [
            [
              7112,
              0
            ],
            [
              7174,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mcode6",
            "parameters": {
              "cstate": "compiler_state_t",
              "s1": "char",
              "s2": "char",
              "masklen": "bpf_u_int32",
              "q": "struct qual"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_ecode(compiler_state_t *cstate, const char *s, struct qual q)\n{\n\tstruct block *b, *tmp;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif ((q.addr == Q_HOST || q.addr == Q_DEFAULT) && q.proto == Q_LINK) {\n\t\tcstate->e = pcap_ether_aton(s);\n\t\tif (cstate->e == NULL)\n\t\t\tbpf_error(cstate, \"malloc\");\n\t\tswitch (cstate->linktype) {\n\t\tcase DLT_EN10MB:\n\t\tcase DLT_NETANALYZER:\n\t\tcase DLT_NETANALYZER_TRANSPARENT:\n\t\t\ttmp = gen_prevlinkhdr_check(cstate);\n\t\t\tb = gen_ehostop(cstate, cstate->e, (int)q.dir);\n\t\t\tif (tmp != NULL)\n\t\t\t\tgen_and(tmp, b);\n\t\t\tbreak;\n\t\tcase DLT_FDDI:\n\t\t\tb = gen_fhostop(cstate, cstate->e, (int)q.dir);\n\t\t\tbreak;\n\t\tcase DLT_IEEE802:\n\t\t\tb = gen_thostop(cstate, cstate->e, (int)q.dir);\n\t\t\tbreak;\n\t\tcase DLT_IEEE802_11:\n\t\tcase DLT_PRISM_HEADER:\n\t\tcase DLT_IEEE802_11_RADIO_AVS:\n\t\tcase DLT_IEEE802_11_RADIO:\n\t\tcase DLT_PPI:\n\t\t\tb = gen_wlanhostop(cstate, cstate->e, (int)q.dir);\n\t\t\tbreak;\n\t\tcase DLT_IP_OVER_FC:\n\t\t\tb = gen_ipfchostop(cstate, cstate->e, (int)q.dir);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfree(cstate->e);\n\t\t\tcstate->e = NULL;\n\t\t\tbpf_error(cstate, \"ethernet addresses supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel\");\n\t\t\t/*NOTREACHED*/\n\t\t}\n\t\tfree(cstate->e);\n\t\tcstate->e = NULL;\n\t\treturn (b);\n\t}\n\tbpf_error(cstate, \"ethernet address used in non-ether expression\");\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              7177,
              0
            ],
            [
              7230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ecode",
            "parameters": {
              "cstate": "compiler_state_t",
              "s": "char",
              "q": "struct qual"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void\nsappend(struct slist *s0, struct slist *s1)\n{\n\t/*\n\t * This is definitely not the best way to do this, but the\n\t * lists will rarely get long.\n\t */\n\twhile (s0->next)\n\t\ts0 = s0->next;\n\ts0->next = s1;\n}",
          "fn_code_pos": [
            [
              7232,
              0
            ],
            [
              7242,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sappend",
            "parameters": {
              "s0": "struct slist",
              "s1": "struct slist"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static struct slist *\nxfer_to_x(compiler_state_t *cstate, struct arth *a)\n{\n\tstruct slist *s;\n\n\ts = new_stmt(cstate, BPF_LDX|BPF_MEM);\n\ts->s.k = a->regno;\n\treturn s;\n}",
          "fn_code_pos": [
            [
              7244,
              0
            ],
            [
              7252,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "xfer_to_x",
            "parameters": {
              "cstate": "compiler_state_t",
              "a": "struct arth"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct slist *\nxfer_to_a(compiler_state_t *cstate, struct arth *a)\n{\n\tstruct slist *s;\n\n\ts = new_stmt(cstate, BPF_LD|BPF_MEM);\n\ts->s.k = a->regno;\n\treturn s;\n}",
          "fn_code_pos": [
            [
              7254,
              0
            ],
            [
              7262,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "xfer_to_a",
            "parameters": {
              "cstate": "compiler_state_t",
              "a": "struct arth"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct arth *\ngen_load_internal(compiler_state_t *cstate, int proto, struct arth *inst,\n    bpf_u_int32 size)\n{\n\tint size_code;\n\tstruct slist *s, *tmp;\n\tstruct block *b;\n\tint regno = alloc_reg(cstate);\n\n\tfree_reg(cstate, inst->regno);\n\tswitch (size) {\n\n\tdefault:\n\t\tbpf_error(cstate, \"data size must be 1, 2, or 4\");\n\t\t/*NOTREACHED*/\n\n\tcase 1:\n\t\tsize_code = BPF_B;\n\t\tbreak;\n\n\tcase 2:\n\t\tsize_code = BPF_H;\n\t\tbreak;\n\n\tcase 4:\n\t\tsize_code = BPF_W;\n\t\tbreak;\n\t}\n\tswitch (proto) {\n\tdefault:\n\t\tbpf_error(cstate, \"unsupported index operation\");\n\n\tcase Q_RADIO:\n\t\t/*\n\t\t * The offset is relative to the beginning of the packet\n\t\t * data, if we have a radio header.  (If we don't, this\n\t\t * is an error.)\n\t\t */\n\t\tif (cstate->linktype != DLT_IEEE802_11_RADIO_AVS &&\n\t\t    cstate->linktype != DLT_IEEE802_11_RADIO &&\n\t\t    cstate->linktype != DLT_PRISM_HEADER)\n\t\t\tbpf_error(cstate, \"radio information not present in capture\");\n\n\t\t/*\n\t\t * Load into the X register the offset computed into the\n\t\t * register specified by \"index\".\n\t\t */\n\t\ts = xfer_to_x(cstate, inst);\n\n\t\t/*\n\t\t * Load the item at that offset.\n\t\t */\n\t\ttmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);\n\t\tsappend(s, tmp);\n\t\tsappend(inst->s, s);\n\t\tbreak;\n\n\tcase Q_LINK:\n\t\t/*\n\t\t * The offset is relative to the beginning of\n\t\t * the link-layer header.\n\t\t *\n\t\t * XXX - what about ATM LANE?  Should the index be\n\t\t * relative to the beginning of the AAL5 frame, so\n\t\t * that 0 refers to the beginning of the LE Control\n\t\t * field, or relative to the beginning of the LAN\n\t\t * frame, so that 0 refers, for Ethernet LANE, to\n\t\t * the beginning of the destination address?\n\t\t */\n\t\ts = gen_abs_offset_varpart(cstate, &cstate->off_linkhdr);\n\n\t\t/*\n\t\t * If \"s\" is non-null, it has code to arrange that the\n\t\t * X register contains the length of the prefix preceding\n\t\t * the link-layer header.  Add to it the offset computed\n\t\t * into the register specified by \"index\", and move that\n\t\t * into the X register.  Otherwise, just load into the X\n\t\t * register the offset computed into the register specified\n\t\t * by \"index\".\n\t\t */\n\t\tif (s != NULL) {\n\t\t\tsappend(s, xfer_to_a(cstate, inst));\n\t\t\tsappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));\n\t\t\tsappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));\n\t\t} else\n\t\t\ts = xfer_to_x(cstate, inst);\n\n\t\t/*\n\t\t * Load the item at the sum of the offset we've put in the\n\t\t * X register and the offset of the start of the link\n\t\t * layer header (which is 0 if the radio header is\n\t\t * variable-length; that header length is what we put\n\t\t * into the X register and then added to the index).\n\t\t */\n\t\ttmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);\n\t\ttmp->s.k = cstate->off_linkhdr.constant_part;\n\t\tsappend(s, tmp);\n\t\tsappend(inst->s, s);\n\t\tbreak;\n\n\tcase Q_IP:\n\tcase Q_ARP:\n\tcase Q_RARP:\n\tcase Q_ATALK:\n\tcase Q_DECNET:\n\tcase Q_SCA:\n\tcase Q_LAT:\n\tcase Q_MOPRC:\n\tcase Q_MOPDL:\n\tcase Q_IPV6:\n\t\t/*\n\t\t * The offset is relative to the beginning of\n\t\t * the network-layer header.\n\t\t * XXX - are there any cases where we want\n\t\t * cstate->off_nl_nosnap?\n\t\t */\n\t\ts = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);\n\n\t\t/*\n\t\t * If \"s\" is non-null, it has code to arrange that the\n\t\t * X register contains the variable part of the offset\n\t\t * of the link-layer payload.  Add to it the offset\n\t\t * computed into the register specified by \"index\",\n\t\t * and move that into the X register.  Otherwise, just\n\t\t * load into the X register the offset computed into\n\t\t * the register specified by \"index\".\n\t\t */\n\t\tif (s != NULL) {\n\t\t\tsappend(s, xfer_to_a(cstate, inst));\n\t\t\tsappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));\n\t\t\tsappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));\n\t\t} else\n\t\t\ts = xfer_to_x(cstate, inst);\n\n\t\t/*\n\t\t * Load the item at the sum of the offset we've put in the\n\t\t * X register, the offset of the start of the network\n\t\t * layer header from the beginning of the link-layer\n\t\t * payload, and the constant part of the offset of the\n\t\t * start of the link-layer payload.\n\t\t */\n\t\ttmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);\n\t\ttmp->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\t\tsappend(s, tmp);\n\t\tsappend(inst->s, s);\n\n\t\t/*\n\t\t * Do the computation only if the packet contains\n\t\t * the protocol in question.\n\t\t */\n\t\tb = gen_proto_abbrev_internal(cstate, proto);\n\t\tif (inst->b)\n\t\t\tgen_and(inst->b, b);\n\t\tinst->b = b;\n\t\tbreak;\n\n\tcase Q_SCTP:\n\tcase Q_TCP:\n\tcase Q_UDP:\n\tcase Q_ICMP:\n\tcase Q_IGMP:\n\tcase Q_IGRP:\n\tcase Q_PIM:\n\tcase Q_VRRP:\n\tcase Q_CARP:\n\t\t/*\n\t\t * The offset is relative to the beginning of\n\t\t * the transport-layer header.\n\t\t *\n\t\t * Load the X register with the length of the IPv4 header\n\t\t * (plus the offset of the link-layer header, if it's\n\t\t * a variable-length header), in bytes.\n\t\t *\n\t\t * XXX - are there any cases where we want\n\t\t * cstate->off_nl_nosnap?\n\t\t * XXX - we should, if we're built with\n\t\t * IPv6 support, generate code to load either\n\t\t * IPv4, IPv6, or both, as appropriate.\n\t\t */\n\t\ts = gen_loadx_iphdrlen(cstate);\n\n\t\t/*\n\t\t * The X register now contains the sum of the variable\n\t\t * part of the offset of the link-layer payload and the\n\t\t * length of the network-layer header.\n\t\t *\n\t\t * Load into the A register the offset relative to\n\t\t * the beginning of the transport layer header,\n\t\t * add the X register to that, move that to the\n\t\t * X register, and load with an offset from the\n\t\t * X register equal to the sum of the constant part of\n\t\t * the offset of the link-layer payload and the offset,\n\t\t * relative to the beginning of the link-layer payload,\n\t\t * of the network-layer header.\n\t\t */\n\t\tsappend(s, xfer_to_a(cstate, inst));\n\t\tsappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));\n\t\tsappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));\n\t\tsappend(s, tmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code));\n\t\ttmp->s.k = cstate->off_linkpl.constant_part + cstate->off_nl;\n\t\tsappend(inst->s, s);\n\n\t\t/*\n\t\t * Do the computation only if the packet contains\n\t\t * the protocol in question - which is true only\n\t\t * if this is an IP datagram and is the first or\n\t\t * only fragment of that datagram.\n\t\t */\n\t\tgen_and(gen_proto_abbrev_internal(cstate, proto), b = gen_ipfrag(cstate));\n\t\tif (inst->b)\n\t\t\tgen_and(inst->b, b);\n\t\tgen_and(gen_proto_abbrev_internal(cstate, Q_IP), b);\n\t\tinst->b = b;\n\t\tbreak;\n\tcase Q_ICMPV6:\n        /*\n        * Do the computation only if the packet contains\n        * the protocol in question.\n        */\n        b = gen_proto_abbrev_internal(cstate, Q_IPV6);\n        if (inst->b) {\n            gen_and(inst->b, b);\n        }\n        inst->b = b;\n\n        /*\n        * Check if we have an icmp6 next header\n        */\n        b = gen_cmp(cstate, OR_LINKPL, 6, BPF_B, 58);\n        if (inst->b) {\n            gen_and(inst->b, b);\n        }\n        inst->b = b;\n\n\n        s = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);\n        /*\n        * If \"s\" is non-null, it has code to arrange that the\n        * X register contains the variable part of the offset\n        * of the link-layer payload.  Add to it the offset\n        * computed into the register specified by \"index\",\n        * and move that into the X register.  Otherwise, just\n        * load into the X register the offset computed into\n        * the register specified by \"index\".\n        */\n        if (s != NULL) {\n            sappend(s, xfer_to_a(cstate, inst));\n            sappend(s, new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X));\n            sappend(s, new_stmt(cstate, BPF_MISC|BPF_TAX));\n        } else {\n            s = xfer_to_x(cstate, inst);\n        }\n\n        /*\n        * Load the item at the sum of the offset we've put in the\n        * X register, the offset of the start of the network\n        * layer header from the beginning of the link-layer\n        * payload, and the constant part of the offset of the\n        * start of the link-layer payload.\n        */\n        tmp = new_stmt(cstate, BPF_LD|BPF_IND|size_code);\n        tmp->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 40;\n\n        sappend(s, tmp);\n        sappend(inst->s, s);\n\n        break;\n\t}\n\tinst->regno = regno;\n\ts = new_stmt(cstate, BPF_ST);\n\ts->s.k = regno;\n\tsappend(inst->s, s);\n\n\treturn inst;\n}",
          "fn_code_pos": [
            [
              7271,
              0
            ],
            [
              7545,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_internal",
            "parameters": {
              "cstate": "compiler_state_t",
              "proto": "int",
              "inst": "struct arth",
              "size": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct arth *\ngen_load(compiler_state_t *cstate, int proto, struct arth *inst,\n    bpf_u_int32 size)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\treturn gen_load_internal(cstate, proto, inst, size);\n}",
          "fn_code_pos": [
            [
              7547,
              0
            ],
            [
              7559,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load",
            "parameters": {
              "cstate": "compiler_state_t",
              "proto": "int",
              "inst": "struct arth",
              "size": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_relation_internal(compiler_state_t *cstate, int code, struct arth *a0,\n    struct arth *a1, int reversed)\n{\n\tstruct slist *s0, *s1, *s2;\n\tstruct block *b, *tmp;\n\n\ts0 = xfer_to_x(cstate, a1);\n\ts1 = xfer_to_a(cstate, a0);\n\tif (code == BPF_JEQ) {\n\t\ts2 = new_stmt(cstate, BPF_ALU|BPF_SUB|BPF_X);\n\t\tb = new_block(cstate, JMP(code));\n\t\tsappend(s1, s2);\n\t}\n\telse\n\t\tb = new_block(cstate, BPF_JMP|code|BPF_X);\n\tif (reversed)\n\t\tgen_not(b);\n\n\tsappend(s0, s1);\n\tsappend(a1->s, s0);\n\tsappend(a0->s, a1->s);\n\n\tb->stmts = a0->s;\n\n\tfree_reg(cstate, a0->regno);\n\tfree_reg(cstate, a1->regno);\n\n\t/* 'and' together protocol checks */\n\tif (a0->b) {\n\t\tif (a1->b) {\n\t\t\tgen_and(a0->b, tmp = a1->b);\n\t\t}\n\t\telse\n\t\t\ttmp = a0->b;\n\t} else\n\t\ttmp = a1->b;\n\n\tif (tmp)\n\t\tgen_and(tmp, b);\n\n\treturn b;\n}",
          "fn_code_pos": [
            [
              7561,
              0
            ],
            [
              7603,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_relation_internal",
            "parameters": {
              "cstate": "compiler_state_t",
              "code": "int",
              "a0": "struct arth",
              "a1": "struct arth",
              "reversed": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_relation(compiler_state_t *cstate, int code, struct arth *a0,\n    struct arth *a1, int reversed)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\treturn gen_relation_internal(cstate, code, a0, a1, reversed);\n}",
          "fn_code_pos": [
            [
              7605,
              0
            ],
            [
              7617,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_relation",
            "parameters": {
              "cstate": "compiler_state_t",
              "code": "int",
              "a0": "struct arth",
              "a1": "struct arth",
              "reversed": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct arth *\ngen_loadlen(compiler_state_t *cstate)\n{\n\tint regno;\n\tstruct arth *a;\n\tstruct slist *s;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tregno = alloc_reg(cstate);\n\ta = (struct arth *)newchunk(cstate, sizeof(*a));\n\ts = new_stmt(cstate, BPF_LD|BPF_LEN);\n\ts->next = new_stmt(cstate, BPF_ST);\n\ts->next->s.k = regno;\n\ta->s = s;\n\ta->regno = regno;\n\n\treturn a;\n}",
          "fn_code_pos": [
            [
              7619,
              0
            ],
            [
              7642,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_loadlen",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct arth *\ngen_loadi_internal(compiler_state_t *cstate, bpf_u_int32 val)\n{\n\tstruct arth *a;\n\tstruct slist *s;\n\tint reg;\n\n\ta = (struct arth *)newchunk(cstate, sizeof(*a));\n\n\treg = alloc_reg(cstate);\n\n\ts = new_stmt(cstate, BPF_LD|BPF_IMM);\n\ts->s.k = val;\n\ts->next = new_stmt(cstate, BPF_ST);\n\ts->next->s.k = reg;\n\ta->s = s;\n\ta->regno = reg;\n\n\treturn a;\n}",
          "fn_code_pos": [
            [
              7644,
              0
            ],
            [
              7663,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_loadi_internal",
            "parameters": {
              "cstate": "compiler_state_t",
              "val": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct arth *\ngen_loadi(compiler_state_t *cstate, bpf_u_int32 val)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\treturn gen_loadi_internal(cstate, val);\n}",
          "fn_code_pos": [
            [
              7665,
              0
            ],
            [
              7676,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_loadi",
            "parameters": {
              "cstate": "compiler_state_t",
              "val": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct arth *\ngen_neg(compiler_state_t *cstate, struct arth *a_arg)\n{\n\tstruct arth *a = a_arg;\n\tstruct slist *s;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\ts = xfer_to_a(cstate, a);\n\tsappend(a->s, s);\n\ts = new_stmt(cstate, BPF_ALU|BPF_NEG);\n\ts->s.k = 0;\n\tsappend(a->s, s);\n\ts = new_stmt(cstate, BPF_ST);\n\ts->s.k = a->regno;\n\tsappend(a->s, s);\n\n\treturn a;\n}",
          "fn_code_pos": [
            [
              7683,
              0
            ],
            [
              7706,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_neg",
            "parameters": {
              "cstate": "compiler_state_t",
              "a_arg": "struct arth"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct arth *\ngen_arth(compiler_state_t *cstate, int code, struct arth *a0_arg,\n    struct arth *a1)\n{\n\tstruct arth *a0 = a0_arg;\n\tstruct slist *s0, *s1, *s2;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Disallow division by, or modulus by, zero; we do this here\n\t * so that it gets done even if the optimizer is disabled.\n\t *\n\t * Also disallow shifts by a value greater than 31; we do this\n\t * here, for the same reason.\n\t */\n\tif (code == BPF_DIV) {\n\t\tif (a1->s->s.code == (BPF_LD|BPF_IMM) && a1->s->s.k == 0)\n\t\t\tbpf_error(cstate, \"division by zero\");\n\t} else if (code == BPF_MOD) {\n\t\tif (a1->s->s.code == (BPF_LD|BPF_IMM) && a1->s->s.k == 0)\n\t\t\tbpf_error(cstate, \"modulus by zero\");\n\t} else if (code == BPF_LSH || code == BPF_RSH) {\n\t\tif (a1->s->s.code == (BPF_LD|BPF_IMM) && a1->s->s.k > 31)\n\t\t\tbpf_error(cstate, \"shift by more than 31 bits\");\n\t}\n\ts0 = xfer_to_x(cstate, a1);\n\ts1 = xfer_to_a(cstate, a0);\n\ts2 = new_stmt(cstate, BPF_ALU|BPF_X|code);\n\n\tsappend(s1, s2);\n\tsappend(s0, s1);\n\tsappend(a1->s, s0);\n\tsappend(a0->s, a1->s);\n\n\tfree_reg(cstate, a0->regno);\n\tfree_reg(cstate, a1->regno);\n\n\ts0 = new_stmt(cstate, BPF_ST);\n\ta0->regno = s0->s.k = alloc_reg(cstate);\n\tsappend(a0->s, s0);\n\n\treturn a0;\n}",
          "fn_code_pos": [
            [
              7713,
              0
            ],
            [
              7761,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_arth",
            "parameters": {
              "cstate": "compiler_state_t",
              "code": "int",
              "a0_arg": "struct arth",
              "a1": "struct arth"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void\ninit_regs(compiler_state_t *cstate)\n{\n\tcstate->curreg = 0;\n\tmemset(cstate->regused, 0, sizeof cstate->regused);\n}",
          "fn_code_pos": [
            [
              7766,
              0
            ],
            [
              7771,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "init_regs",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nalloc_reg(compiler_state_t *cstate)\n{\n\tint n = BPF_MEMWORDS;\n\n\twhile (--n >= 0) {\n\t\tif (cstate->regused[cstate->curreg])\n\t\t\tcstate->curreg = (cstate->curreg + 1) % BPF_MEMWORDS;\n\t\telse {\n\t\t\tcstate->regused[cstate->curreg] = 1;\n\t\t\treturn cstate->curreg;\n\t\t}\n\t}\n\tbpf_error(cstate, \"too many registers needed to evaluate expression\");\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              7776,
              0
            ],
            [
              7791,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "alloc_reg",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nfree_reg(compiler_state_t *cstate, int n)\n{\n\tcstate->regused[n] = 0;\n}",
          "fn_code_pos": [
            [
              7797,
              0
            ],
            [
              7801,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "free_reg",
            "parameters": {
              "cstate": "compiler_state_t",
              "n": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static struct block *\ngen_len(compiler_state_t *cstate, int jmp, int n)\n{\n\tstruct slist *s;\n\tstruct block *b;\n\n\ts = new_stmt(cstate, BPF_LD|BPF_LEN);\n\tb = new_block(cstate, JMP(jmp));\n\tb->stmts = s;\n\tb->s.k = n;\n\n\treturn b;\n}",
          "fn_code_pos": [
            [
              7803,
              0
            ],
            [
              7815,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_len",
            "parameters": {
              "cstate": "compiler_state_t",
              "jmp": "int",
              "n": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_greater(compiler_state_t *cstate, int n)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\treturn gen_len(cstate, BPF_JGE, n);\n}",
          "fn_code_pos": [
            [
              7817,
              0
            ],
            [
              7828,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_greater",
            "parameters": {
              "cstate": "compiler_state_t",
              "n": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_less(compiler_state_t *cstate, int n)\n{\n\tstruct block *b;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tb = gen_len(cstate, BPF_JGT, n);\n\tgen_not(b);\n\n\treturn b;\n}",
          "fn_code_pos": [
            [
              7833,
              0
            ],
            [
              7849,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_less",
            "parameters": {
              "cstate": "compiler_state_t",
              "n": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_byteop(compiler_state_t *cstate, int op, int idx, bpf_u_int32 val)\n{\n\tstruct block *b;\n\tstruct slist *s;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (op) {\n\tdefault:\n\t\tabort();\n\n\tcase '=':\n\t\treturn gen_cmp(cstate, OR_LINKHDR, (u_int)idx, BPF_B, val);\n\n\tcase '<':\n\t\tb = gen_cmp_lt(cstate, OR_LINKHDR, (u_int)idx, BPF_B, val);\n\t\treturn b;\n\n\tcase '>':\n\t\tb = gen_cmp_gt(cstate, OR_LINKHDR, (u_int)idx, BPF_B, val);\n\t\treturn b;\n\n\tcase '|':\n\t\ts = new_stmt(cstate, BPF_ALU|BPF_OR|BPF_K);\n\t\tbreak;\n\n\tcase '&':\n\t\ts = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);\n\t\tbreak;\n\t}\n\ts->s.k = val;\n\tb = new_block(cstate, JMP(BPF_JEQ));\n\tb->stmts = s;\n\tgen_not(b);\n\n\treturn b;\n}",
          "fn_code_pos": [
            [
              7861,
              0
            ],
            [
              7903,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_byteop",
            "parameters": {
              "cstate": "compiler_state_t",
              "op": "int",
              "idx": "int",
              "val": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_broadcast(compiler_state_t *cstate, int proto)\n{\n\tbpf_u_int32 hostmask;\n\tstruct block *b0, *b1, *b2;\n\tstatic const u_char ebroadcast[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (proto) {\n\n\tcase Q_DEFAULT:\n\tcase Q_LINK:\n\t\tswitch (cstate->linktype) {\n\t\tcase DLT_ARCNET:\n\t\tcase DLT_ARCNET_LINUX:\n\t\t\treturn gen_ahostop(cstate, abroadcast, Q_DST);\n\t\tcase DLT_EN10MB:\n\t\tcase DLT_NETANALYZER:\n\t\tcase DLT_NETANALYZER_TRANSPARENT:\n\t\t\tb1 = gen_prevlinkhdr_check(cstate);\n\t\t\tb0 = gen_ehostop(cstate, ebroadcast, Q_DST);\n\t\t\tif (b1 != NULL)\n\t\t\t\tgen_and(b1, b0);\n\t\t\treturn b0;\n\t\tcase DLT_FDDI:\n\t\t\treturn gen_fhostop(cstate, ebroadcast, Q_DST);\n\t\tcase DLT_IEEE802:\n\t\t\treturn gen_thostop(cstate, ebroadcast, Q_DST);\n\t\tcase DLT_IEEE802_11:\n\t\tcase DLT_PRISM_HEADER:\n\t\tcase DLT_IEEE802_11_RADIO_AVS:\n\t\tcase DLT_IEEE802_11_RADIO:\n\t\tcase DLT_PPI:\n\t\t\treturn gen_wlanhostop(cstate, ebroadcast, Q_DST);\n\t\tcase DLT_IP_OVER_FC:\n\t\t\treturn gen_ipfchostop(cstate, ebroadcast, Q_DST);\n\t\tdefault:\n\t\t\tbpf_error(cstate, \"not a broadcast link\");\n\t\t}\n \t\t/*NOTREACHED*/\n\n\tcase Q_IP:\n\t\t/*\n\t\t * We treat a netmask of PCAP_NETMASK_UNKNOWN (0xffffffff)\n\t\t * as an indication that we don't know the netmask, and fail\n\t\t * in that case.\n\t\t */\n\t\tif (cstate->netmask == PCAP_NETMASK_UNKNOWN)\n\t\t\tbpf_error(cstate, \"netmask not known, so 'ip broadcast' not supported\");\n\t\tb0 = gen_linktype(cstate, ETHERTYPE_IP);\n\t\thostmask = ~cstate->netmask;\n\t\tb1 = gen_mcmp(cstate, OR_LINKPL, 16, BPF_W, 0, hostmask);\n\t\tb2 = gen_mcmp(cstate, OR_LINKPL, 16, BPF_W,\n\t\t\t      ~0 & hostmask, hostmask);\n\t\tgen_or(b1, b2);\n\t\tgen_and(b0, b2);\n\t\treturn b2;\n\t}\n\tbpf_error(cstate, \"only link-layer/IP broadcast filters supported\");\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              7907,
              0
            ],
            [
              7973,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_broadcast",
            "parameters": {
              "cstate": "compiler_state_t",
              "proto": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_mac_multicast(compiler_state_t *cstate, int offset)\n{\n\tregister struct block *b0;\n\tregister struct slist *s;\n\n\t/* link[offset] & 1 != 0 */\n\ts = gen_load_a(cstate, OR_LINKHDR, offset, BPF_B);\n\tb0 = new_block(cstate, JMP(BPF_JSET));\n\tb0->s.k = 1;\n\tb0->stmts = s;\n\treturn b0;\n}",
          "fn_code_pos": [
            [
              7979,
              0
            ],
            [
              7991,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mac_multicast",
            "parameters": {
              "cstate": "compiler_state_t",
              "offset": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_multicast(compiler_state_t *cstate, int proto)\n{\n\tregister struct block *b0, *b1, *b2;\n\tregister struct slist *s;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (proto) {\n\n\tcase Q_DEFAULT:\n\tcase Q_LINK:\n\t\tswitch (cstate->linktype) {\n\t\tcase DLT_ARCNET:\n\t\tcase DLT_ARCNET_LINUX:\n\t\t\t/* all ARCnet multicasts use the same address */\n\t\t\treturn gen_ahostop(cstate, abroadcast, Q_DST);\n\t\tcase DLT_EN10MB:\n\t\tcase DLT_NETANALYZER:\n\t\tcase DLT_NETANALYZER_TRANSPARENT:\n\t\t\tb1 = gen_prevlinkhdr_check(cstate);\n\t\t\t/* ether[0] & 1 != 0 */\n\t\t\tb0 = gen_mac_multicast(cstate, 0);\n\t\t\tif (b1 != NULL)\n\t\t\t\tgen_and(b1, b0);\n\t\t\treturn b0;\n\t\tcase DLT_FDDI:\n\t\t\t/*\n\t\t\t * XXX TEST THIS: MIGHT NOT PORT PROPERLY XXX\n\t\t\t *\n\t\t\t * XXX - was that referring to bit-order issues?\n\t\t\t */\n\t\t\t/* fddi[1] & 1 != 0 */\n\t\t\treturn gen_mac_multicast(cstate, 1);\n\t\tcase DLT_IEEE802:\n\t\t\t/* tr[2] & 1 != 0 */\n\t\t\treturn gen_mac_multicast(cstate, 2);\n\t\tcase DLT_IEEE802_11:\n\t\tcase DLT_PRISM_HEADER:\n\t\tcase DLT_IEEE802_11_RADIO_AVS:\n\t\tcase DLT_IEEE802_11_RADIO:\n\t\tcase DLT_PPI:\n\t\t\t/*\n\t\t\t * Oh, yuk.\n\t\t\t *\n\t\t\t *\tFor control frames, there is no DA.\n\t\t\t *\n\t\t\t *\tFor management frames, DA is at an\n\t\t\t *\toffset of 4 from the beginning of\n\t\t\t *\tthe packet.\n\t\t\t *\n\t\t\t *\tFor data frames, DA is at an offset\n\t\t\t *\tof 4 from the beginning of the packet\n\t\t\t *\tif To DS is clear and at an offset of\n\t\t\t *\t16 from the beginning of the packet\n\t\t\t *\tif To DS is set.\n\t\t\t */\n\n\t\t\t/*\n\t\t\t * Generate the tests to be done for data frames.\n\t\t\t *\n\t\t\t * First, check for To DS set, i.e. \"link[1] & 0x01\".\n\t\t\t */\n\t\t\ts = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);\n\t\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\t\tb1->s.k = 0x01;\t/* To DS */\n\t\t\tb1->stmts = s;\n\n\t\t\t/*\n\t\t\t * If To DS is set, the DA is at 16.\n\t\t\t */\n\t\t\tb0 = gen_mac_multicast(cstate, 16);\n\t\t\tgen_and(b1, b0);\n\n\t\t\t/*\n\t\t\t * Now, check for To DS not set, i.e. check\n\t\t\t * \"!(link[1] & 0x01)\".\n\t\t\t */\n\t\t\ts = gen_load_a(cstate, OR_LINKHDR, 1, BPF_B);\n\t\t\tb2 = new_block(cstate, JMP(BPF_JSET));\n\t\t\tb2->s.k = 0x01;\t/* To DS */\n\t\t\tb2->stmts = s;\n\t\t\tgen_not(b2);\n\n\t\t\t/*\n\t\t\t * If To DS is not set, the DA is at 4.\n\t\t\t */\n\t\t\tb1 = gen_mac_multicast(cstate, 4);\n\t\t\tgen_and(b2, b1);\n\n\t\t\t/*\n\t\t\t * Now OR together the last two checks.  That gives\n\t\t\t * the complete set of checks for data frames.\n\t\t\t */\n\t\t\tgen_or(b1, b0);\n\n\t\t\t/*\n\t\t\t * Now check for a data frame.\n\t\t\t * I.e, check \"link[0] & 0x08\".\n\t\t\t */\n\t\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\t\tb1->s.k = 0x08;\n\t\t\tb1->stmts = s;\n\n\t\t\t/*\n\t\t\t * AND that with the checks done for data frames.\n\t\t\t */\n\t\t\tgen_and(b1, b0);\n\n\t\t\t/*\n\t\t\t * If the high-order bit of the type value is 0, this\n\t\t\t * is a management frame.\n\t\t\t * I.e, check \"!(link[0] & 0x08)\".\n\t\t\t */\n\t\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\t\tb2 = new_block(cstate, JMP(BPF_JSET));\n\t\t\tb2->s.k = 0x08;\n\t\t\tb2->stmts = s;\n\t\t\tgen_not(b2);\n\n\t\t\t/*\n\t\t\t * For management frames, the DA is at 4.\n\t\t\t */\n\t\t\tb1 = gen_mac_multicast(cstate, 4);\n\t\t\tgen_and(b2, b1);\n\n\t\t\t/*\n\t\t\t * OR that with the checks done for data frames.\n\t\t\t * That gives the checks done for management and\n\t\t\t * data frames.\n\t\t\t */\n\t\t\tgen_or(b1, b0);\n\n\t\t\t/*\n\t\t\t * If the low-order bit of the type value is 1,\n\t\t\t * this is either a control frame or a frame\n\t\t\t * with a reserved type, and thus not a\n\t\t\t * frame with an SA.\n\t\t\t *\n\t\t\t * I.e., check \"!(link[0] & 0x04)\".\n\t\t\t */\n\t\t\ts = gen_load_a(cstate, OR_LINKHDR, 0, BPF_B);\n\t\t\tb1 = new_block(cstate, JMP(BPF_JSET));\n\t\t\tb1->s.k = 0x04;\n\t\t\tb1->stmts = s;\n\t\t\tgen_not(b1);\n\n\t\t\t/*\n\t\t\t * AND that with the checks for data and management\n\t\t\t * frames.\n\t\t\t */\n\t\t\tgen_and(b1, b0);\n\t\t\treturn b0;\n\t\tcase DLT_IP_OVER_FC:\n\t\t\tb0 = gen_mac_multicast(cstate, 2);\n\t\t\treturn b0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t/* Link not known to support multicasts */\n\t\tbreak;\n\n\tcase Q_IP:\n\t\tb0 = gen_linktype(cstate, ETHERTYPE_IP);\n\t\tb1 = gen_cmp_ge(cstate, OR_LINKPL, 16, BPF_B, 224);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_IPV6:\n\t\tb0 = gen_linktype(cstate, ETHERTYPE_IPV6);\n\t\tb1 = gen_cmp(cstate, OR_LINKPL, 24, BPF_B, 255);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\t}\n\tbpf_error(cstate, \"link-layer multicast filters supported only on ethernet/FDDI/token ring/ARCNET/802.11/ATM LANE/Fibre Channel\");\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              7993,
              0
            ],
            [
              8175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_multicast",
            "parameters": {
              "cstate": "compiler_state_t",
              "proto": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_inbound(compiler_state_t *cstate, int dir)\n{\n\tregister struct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Only some data link types support inbound/outbound qualifiers.\n\t */\n\tswitch (cstate->linktype) {\n\tcase DLT_SLIP:\n\t\tb0 = gen_relation_internal(cstate, BPF_JEQ,\n\t\t\t  gen_load_internal(cstate, Q_LINK, gen_loadi_internal(cstate, 0), 1),\n\t\t\t  gen_loadi_internal(cstate, 0),\n\t\t\t  dir);\n\t\tbreak;\n\n\tcase DLT_IPNET:\n\t\tif (dir) {\n\t\t\t/* match outgoing packets */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, IPNET_OUTBOUND);\n\t\t} else {\n\t\t\t/* match incoming packets */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 2, BPF_H, IPNET_INBOUND);\n\t\t}\n\t\tbreak;\n\n\tcase DLT_LINUX_SLL:\n\t\t/* match outgoing packets */\n\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 0, BPF_H, LINUX_SLL_OUTGOING);\n\t\tif (!dir) {\n\t\t\t/* to filter on inbound traffic, invert the match */\n\t\t\tgen_not(b0);\n\t\t}\n\t\tbreak;\n\n\tcase DLT_LINUX_SLL2:\n\t\t/* match outgoing packets */\n\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 10, BPF_B, LINUX_SLL_OUTGOING);\n\t\tif (!dir) {\n\t\t\t/* to filter on inbound traffic, invert the match */\n\t\t\tgen_not(b0);\n\t\t}\n\t\tbreak;\n\n#ifdef HAVE_NET_PFVAR_H\n\tcase DLT_PFLOG:\n\t\tb0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, dir), BPF_B,\n\t\t    ((dir == 0) ? PF_IN : PF_OUT));\n\t\tbreak;\n#endif\n\n\tcase DLT_PPP_PPPD:\n\t\tif (dir) {\n\t\t\t/* match outgoing packets */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 0, BPF_B, PPP_PPPD_OUT);\n\t\t} else {\n\t\t\t/* match incoming packets */\n\t\t\tb0 = gen_cmp(cstate, OR_LINKHDR, 0, BPF_B, PPP_PPPD_IN);\n\t\t}\n\t\tbreak;\n\n        case DLT_JUNIPER_MFR:\n        case DLT_JUNIPER_MLFR:\n        case DLT_JUNIPER_MLPPP:\n\tcase DLT_JUNIPER_ATM1:\n\tcase DLT_JUNIPER_ATM2:\n\tcase DLT_JUNIPER_PPPOE:\n\tcase DLT_JUNIPER_PPPOE_ATM:\n        case DLT_JUNIPER_GGSN:\n        case DLT_JUNIPER_ES:\n        case DLT_JUNIPER_MONITOR:\n        case DLT_JUNIPER_SERVICES:\n        case DLT_JUNIPER_ETHER:\n        case DLT_JUNIPER_PPP:\n        case DLT_JUNIPER_FRELAY:\n        case DLT_JUNIPER_CHDLC:\n        case DLT_JUNIPER_VP:\n        case DLT_JUNIPER_ST:\n        case DLT_JUNIPER_ISM:\n        case DLT_JUNIPER_VS:\n        case DLT_JUNIPER_SRX_E2E:\n        case DLT_JUNIPER_FIBRECHANNEL:\n\tcase DLT_JUNIPER_ATM_CEMIC:\n\n\t\t/* juniper flags (including direction) are stored\n\t\t * the byte after the 3-byte magic number */\n\t\tif (dir) {\n\t\t\t/* match outgoing packets */\n\t\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 3, BPF_B, 0, 0x01);\n\t\t} else {\n\t\t\t/* match incoming packets */\n\t\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 3, BPF_B, 1, 0x01);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * If we have packet meta-data indicating a direction,\n\t\t * and that metadata can be checked by BPF code, check\n\t\t * it.  Otherwise, give up, as this link-layer type has\n\t\t * nothing in the packet data.\n\t\t *\n\t\t * Currently, the only platform where a BPF filter can\n\t\t * check that metadata is Linux with the in-kernel\n\t\t * BPF interpreter.  If other packet capture mechanisms\n\t\t * and BPF filters also supported this, it would be\n\t\t * nice.  It would be even better if they made that\n\t\t * metadata available so that we could provide it\n\t\t * with newer capture APIs, allowing it to be saved\n\t\t * in pcapng files.\n\t\t */\n#if defined(linux) && defined(PF_PACKET) && defined(SO_ATTACH_FILTER)\n\t\t/*\n\t\t * This is Linux with PF_PACKET support.\n\t\t * If this is a *live* capture, we can look at\n\t\t * special meta-data in the filter expression;\n\t\t * if it's a savefile, we can't.\n\t\t */\n\t\tif (cstate->bpf_pcap->rfile != NULL) {\n\t\t\t/* We have a FILE *, so this is a savefile */\n\t\t\tbpf_error(cstate, \"inbound/outbound not supported on linktype %d when reading savefiles\",\n\t\t\t    cstate->linktype);\n\t\t\tb0 = NULL;\n\t\t\t/*NOTREACHED*/\n\t\t}\n\t\t/* match outgoing packets */\n\t\tb0 = gen_cmp(cstate, OR_LINKHDR, SKF_AD_OFF + SKF_AD_PKTTYPE, BPF_H,\n\t\t             PACKET_OUTGOING);\n\t\tif (!dir) {\n\t\t\t/* to filter on inbound traffic, invert the match */\n\t\t\tgen_not(b0);\n\t\t}\n#else /* defined(linux) && defined(PF_PACKET) && defined(SO_ATTACH_FILTER) */\n\t\tbpf_error(cstate, \"inbound/outbound not supported on linktype %d\",\n\t\t    cstate->linktype);\n\t\t/*NOTREACHED*/\n#endif /* defined(linux) && defined(PF_PACKET) && defined(SO_ATTACH_FILTER) */\n\t}\n\treturn (b0);\n}",
          "fn_code_pos": [
            [
              8186,
              0
            ],
            [
              8332,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_inbound",
            "parameters": {
              "cstate": "compiler_state_t",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_pf_ifname(compiler_state_t *cstate, const char *ifname)\n{\n\tstruct block *b0;\n\tu_int len, off;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif (cstate->linktype != DLT_PFLOG) {\n\t\tbpf_error(cstate, \"ifname supported only on PF linktype\");\n\t\t/*NOTREACHED*/\n\t}\n\tlen = sizeof(((struct pfloghdr *)0)->ifname);\n\toff = offsetof(struct pfloghdr, ifname);\n\tif (strlen(ifname) >= len) {\n\t\tbpf_error(cstate, \"ifname interface names can only be %d characters\",\n\t\t    len-1);\n\t\t/*NOTREACHED*/\n\t}\n\tb0 = gen_bcmp(cstate, OR_LINKHDR, off, (u_int)strlen(ifname),\n\t    (const u_char *)ifname);\n\treturn (b0);\n}",
          "fn_code_pos": [
            [
              8336,
              0
            ],
            [
              8363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_ifname",
            "parameters": {
              "cstate": "compiler_state_t",
              "ifname": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_pf_ruleset(compiler_state_t *cstate, char *ruleset)\n{\n\tstruct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif (cstate->linktype != DLT_PFLOG) {\n\t\tbpf_error(cstate, \"ruleset supported only on PF linktype\");\n\t\t/*NOTREACHED*/\n\t}\n\n\tif (strlen(ruleset) >= sizeof(((struct pfloghdr *)0)->ruleset)) {\n\t\tbpf_error(cstate, \"ruleset names can only be %ld characters\",\n\t\t    (long)(sizeof(((struct pfloghdr *)0)->ruleset) - 1));\n\t\t/*NOTREACHED*/\n\t}\n\n\tb0 = gen_bcmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, ruleset),\n\t    (u_int)strlen(ruleset), (const u_char *)ruleset);\n\treturn (b0);\n}",
          "fn_code_pos": [
            [
              8366,
              0
            ],
            [
              8392,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_ruleset",
            "parameters": {
              "cstate": "compiler_state_t",
              "ruleset": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_pf_rnr(compiler_state_t *cstate, int rnr)\n{\n\tstruct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif (cstate->linktype != DLT_PFLOG) {\n\t\tbpf_error(cstate, \"rnr supported only on PF linktype\");\n\t\t/*NOTREACHED*/\n\t}\n\n\tb0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, rulenr), BPF_W,\n\t\t (bpf_u_int32)rnr);\n\treturn (b0);\n}",
          "fn_code_pos": [
            [
              8395,
              0
            ],
            [
              8415,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_rnr",
            "parameters": {
              "cstate": "compiler_state_t",
              "rnr": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_pf_srnr(compiler_state_t *cstate, int srnr)\n{\n\tstruct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif (cstate->linktype != DLT_PFLOG) {\n\t\tbpf_error(cstate, \"srnr supported only on PF linktype\");\n\t\t/*NOTREACHED*/\n\t}\n\n\tb0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, subrulenr), BPF_W,\n\t    (bpf_u_int32)srnr);\n\treturn (b0);\n}",
          "fn_code_pos": [
            [
              8418,
              0
            ],
            [
              8438,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_srnr",
            "parameters": {
              "cstate": "compiler_state_t",
              "srnr": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_pf_reason(compiler_state_t *cstate, int reason)\n{\n\tstruct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif (cstate->linktype != DLT_PFLOG) {\n\t\tbpf_error(cstate, \"reason supported only on PF linktype\");\n\t\t/*NOTREACHED*/\n\t}\n\n\tb0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, reason), BPF_B,\n\t    (bpf_u_int32)reason);\n\treturn (b0);\n}",
          "fn_code_pos": [
            [
              8441,
              0
            ],
            [
              8461,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_reason",
            "parameters": {
              "cstate": "compiler_state_t",
              "reason": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_pf_action(compiler_state_t *cstate, int action)\n{\n\tstruct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tif (cstate->linktype != DLT_PFLOG) {\n\t\tbpf_error(cstate, \"action supported only on PF linktype\");\n\t\t/*NOTREACHED*/\n\t}\n\n\tb0 = gen_cmp(cstate, OR_LINKHDR, offsetof(struct pfloghdr, action), BPF_B,\n\t    (bpf_u_int32)action);\n\treturn (b0);\n}",
          "fn_code_pos": [
            [
              8464,
              0
            ],
            [
              8484,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_action",
            "parameters": {
              "cstate": "compiler_state_t",
              "action": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_pf_ifname(compiler_state_t *cstate, const char *ifname _U_)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tbpf_error(cstate, \"libpcap was compiled without pf support\");\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              8486,
              0
            ],
            [
              8498,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_ifname",
            "parameters": {
              "cstate": "compiler_state_t",
              "ifname": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_pf_ruleset(compiler_state_t *cstate, char *ruleset _U_)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tbpf_error(cstate, \"libpcap was compiled on a machine without pf support\");\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              8500,
              0
            ],
            [
              8512,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_ruleset",
            "parameters": {
              "cstate": "compiler_state_t",
              "ruleset": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_pf_rnr(compiler_state_t *cstate, int rnr _U_)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tbpf_error(cstate, \"libpcap was compiled on a machine without pf support\");\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              8514,
              0
            ],
            [
              8526,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_rnr",
            "parameters": {
              "cstate": "compiler_state_t",
              "rnr": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_pf_srnr(compiler_state_t *cstate, int srnr _U_)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tbpf_error(cstate, \"libpcap was compiled on a machine without pf support\");\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              8528,
              0
            ],
            [
              8540,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_srnr",
            "parameters": {
              "cstate": "compiler_state_t",
              "srnr": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_pf_reason(compiler_state_t *cstate, int reason _U_)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tbpf_error(cstate, \"libpcap was compiled on a machine without pf support\");\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              8542,
              0
            ],
            [
              8554,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_reason",
            "parameters": {
              "cstate": "compiler_state_t",
              "reason": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_pf_action(compiler_state_t *cstate, int action _U_)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tbpf_error(cstate, \"libpcap was compiled on a machine without pf support\");\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              8556,
              0
            ],
            [
              8568,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_action",
            "parameters": {
              "cstate": "compiler_state_t",
              "action": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_p80211_type(compiler_state_t *cstate, bpf_u_int32 type, bpf_u_int32 mask)\n{\n\tstruct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (cstate->linktype) {\n\n\tcase DLT_IEEE802_11:\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_IEEE802_11_RADIO:\n\t\tb0 = gen_mcmp(cstate, OR_LINKHDR, 0, BPF_B, type, mask);\n\t\tbreak;\n\n\tdefault:\n\t\tbpf_error(cstate, \"802.11 link-layer types supported only on 802.11\");\n\t\t/*NOTREACHED*/\n\t}\n\n\treturn (b0);\n}",
          "fn_code_pos": [
            [
              8572,
              0
            ],
            [
              8599,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_p80211_type",
            "parameters": {
              "cstate": "compiler_state_t",
              "type": "bpf_u_int32",
              "mask": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_p80211_fcdir(compiler_state_t *cstate, bpf_u_int32 fcdir)\n{\n\tstruct block *b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (cstate->linktype) {\n\n\tcase DLT_IEEE802_11:\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_IEEE802_11_RADIO:\n\t\tbreak;\n\n\tdefault:\n\t\tbpf_error(cstate, \"frame direction supported only with 802.11 headers\");\n\t\t/*NOTREACHED*/\n\t}\n\n\tb0 = gen_mcmp(cstate, OR_LINKHDR, 1, BPF_B, fcdir,\n\t    IEEE80211_FC1_DIR_MASK);\n\n\treturn (b0);\n}",
          "fn_code_pos": [
            [
              8601,
              0
            ],
            [
              8630,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_p80211_fcdir",
            "parameters": {
              "cstate": "compiler_state_t",
              "fcdir": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_acode(compiler_state_t *cstate, const char *s, struct qual q)\n{\n\tstruct block *b;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (cstate->linktype) {\n\n\tcase DLT_ARCNET:\n\tcase DLT_ARCNET_LINUX:\n\t\tif ((q.addr == Q_HOST || q.addr == Q_DEFAULT) &&\n\t\t    q.proto == Q_LINK) {\n\t\t\tcstate->e = pcap_ether_aton(s);\n\t\t\tif (cstate->e == NULL)\n\t\t\t\tbpf_error(cstate, \"malloc\");\n\t\t\tb = gen_ahostop(cstate, cstate->e, (int)q.dir);\n\t\t\tfree(cstate->e);\n\t\t\tcstate->e = NULL;\n\t\t\treturn (b);\n\t\t} else\n\t\t\tbpf_error(cstate, \"ARCnet address used in non-arc expression\");\n \t\t/*NOTREACHED*/\n\n\tdefault:\n\t\tbpf_error(cstate, \"aid supported only on ARCnet\");\n\t\t/*NOTREACHED*/\n\t}\n}",
          "fn_code_pos": [
            [
              8632,
              0
            ],
            [
              8665,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_acode",
            "parameters": {
              "cstate": "compiler_state_t",
              "s": "char",
              "q": "struct qual"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_ahostop(compiler_state_t *cstate, const u_char *eaddr, int dir)\n{\n\tregister struct block *b0, *b1;\n\n\tswitch (dir) {\n\t/* src comes first, different from Ethernet */\n\tcase Q_SRC:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 0, 1, eaddr);\n\n\tcase Q_DST:\n\t\treturn gen_bcmp(cstate, OR_LINKHDR, 1, 1, eaddr);\n\n\tcase Q_AND:\n\t\tb0 = gen_ahostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_ahostop(cstate, eaddr, Q_DST);\n\t\tgen_and(b0, b1);\n\t\treturn b1;\n\n\tcase Q_DEFAULT:\n\tcase Q_OR:\n\t\tb0 = gen_ahostop(cstate, eaddr, Q_SRC);\n\t\tb1 = gen_ahostop(cstate, eaddr, Q_DST);\n\t\tgen_or(b0, b1);\n\t\treturn b1;\n\n\tcase Q_ADDR1:\n\t\tbpf_error(cstate, \"'addr1' and 'address1' are only supported on 802.11\");\n \t\t/*NOTREACHED*/\n\n\tcase Q_ADDR2:\n\t\tbpf_error(cstate, \"'addr2' and 'address2' are only supported on 802.11\");\n \t\t/*NOTREACHED*/\n\n\tcase Q_ADDR3:\n\t\tbpf_error(cstate, \"'addr3' and 'address3' are only supported on 802.11\");\n \t\t/*NOTREACHED*/\n\n\tcase Q_ADDR4:\n\t\tbpf_error(cstate, \"'addr4' and 'address4' are only supported on 802.11\");\n \t\t/*NOTREACHED*/\n\n\tcase Q_RA:\n\t\tbpf_error(cstate, \"'ra' is only supported on 802.11\");\n \t\t/*NOTREACHED*/\n\n\tcase Q_TA:\n\t\tbpf_error(cstate, \"'ta' is only supported on 802.11\");\n \t\t/*NOTREACHED*/\n\t}\n\tabort();\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              8667,
              0
            ],
            [
              8719,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ahostop",
            "parameters": {
              "cstate": "compiler_state_t",
              "eaddr": "u_char",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_vlan_tpid_test(compiler_state_t *cstate)\n{\n\tstruct block *b0, *b1;\n\n\t/* check for VLAN, including QinQ */\n\tb0 = gen_linktype(cstate, ETHERTYPE_8021Q);\n\tb1 = gen_linktype(cstate, ETHERTYPE_8021AD);\n\tgen_or(b0,b1);\n\tb0 = b1;\n\tb1 = gen_linktype(cstate, ETHERTYPE_8021QINQ);\n\tgen_or(b0,b1);\n\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              8721,
              0
            ],
            [
              8735,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_vlan_tpid_test",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_vlan_vid_test(compiler_state_t *cstate, bpf_u_int32 vlan_num)\n{\n\tif (vlan_num > 0x0fff) {\n\t\tbpf_error(cstate, \"VLAN tag %u greater than maximum %u\",\n\t\t    vlan_num, 0x0fff);\n\t}\n\treturn gen_mcmp(cstate, OR_LINKPL, 0, BPF_H, vlan_num, 0x0fff);\n}",
          "fn_code_pos": [
            [
              8737,
              0
            ],
            [
              8745,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_vlan_vid_test",
            "parameters": {
              "cstate": "compiler_state_t",
              "vlan_num": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_vlan_no_bpf_extensions(compiler_state_t *cstate, bpf_u_int32 vlan_num,\n    int has_vlan_tag)\n{\n\tstruct block *b0, *b1;\n\n\tb0 = gen_vlan_tpid_test(cstate);\n\n\tif (has_vlan_tag) {\n\t\tb1 = gen_vlan_vid_test(cstate, vlan_num);\n\t\tgen_and(b0, b1);\n\t\tb0 = b1;\n\t}\n\n\t/*\n\t * Both payload and link header type follow the VLAN tags so that\n\t * both need to be updated.\n\t */\n\tcstate->off_linkpl.constant_part += 4;\n\tcstate->off_linktype.constant_part += 4;\n\n\treturn b0;\n}",
          "fn_code_pos": [
            [
              8747,
              0
            ],
            [
              8769,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_vlan_no_bpf_extensions",
            "parameters": {
              "cstate": "compiler_state_t",
              "vlan_num": "bpf_u_int32",
              "has_vlan_tag": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void\ngen_vlan_vloffset_add(compiler_state_t *cstate, bpf_abs_offset *off,\n    bpf_u_int32 v, struct slist *s)\n{\n\tstruct slist *s2;\n\n\tif (!off->is_variable)\n\t\toff->is_variable = 1;\n\tif (off->reg == -1)\n\t\toff->reg = alloc_reg(cstate);\n\n\ts2 = new_stmt(cstate, BPF_LD|BPF_MEM);\n\ts2->s.k = off->reg;\n\tsappend(s, s2);\n\ts2 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_IMM);\n\ts2->s.k = v;\n\tsappend(s, s2);\n\ts2 = new_stmt(cstate, BPF_ST);\n\ts2->s.k = off->reg;\n\tsappend(s, s2);\n}",
          "fn_code_pos": [
            [
              8773,
              0
            ],
            [
              8793,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_vlan_vloffset_add",
            "parameters": {
              "cstate": "compiler_state_t",
              "off": "bpf_abs_offset",
              "v": "bpf_u_int32",
              "s": "struct slist"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ngen_vlan_patch_tpid_test(compiler_state_t *cstate, struct block *b_tpid)\n{\n\tstruct slist s;\n\n\t/* offset determined at run time, shift variable part */\n\ts.next = NULL;\n\tcstate->is_vlan_vloffset = 1;\n\tgen_vlan_vloffset_add(cstate, &cstate->off_linkpl, 4, &s);\n\tgen_vlan_vloffset_add(cstate, &cstate->off_linktype, 4, &s);\n\n\t/* we get a pointer to a chain of or-ed blocks, patch first of them */\n\tsappend(s.next, b_tpid->head->stmts);\n\tb_tpid->head->stmts = s.next;\n}",
          "fn_code_pos": [
            [
              8799,
              0
            ],
            [
              8813,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_vlan_patch_tpid_test",
            "parameters": {
              "cstate": "compiler_state_t",
              "b_tpid": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ngen_vlan_patch_vid_test(compiler_state_t *cstate, struct block *b_vid)\n{\n\tstruct slist *s, *s2, *sjeq;\n\tunsigned cnt;\n\n\ts = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n\ts->s.k = SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT;\n\n\t/* true -> next instructions, false -> beginning of b_vid */\n\tsjeq = new_stmt(cstate, JMP(BPF_JEQ));\n\tsjeq->s.k = 1;\n\tsjeq->s.jf = b_vid->stmts;\n\tsappend(s, sjeq);\n\n\ts2 = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n\ts2->s.k = SKF_AD_OFF + SKF_AD_VLAN_TAG;\n\tsappend(s, s2);\n\tsjeq->s.jt = s2;\n\n\t/* Jump to the test in b_vid. We need to jump one instruction before\n\t * the end of the b_vid block so that we only skip loading the TCI\n\t * from packet data and not the 'and' instruction extractging VID.\n\t */\n\tcnt = 0;\n\tfor (s2 = b_vid->stmts; s2; s2 = s2->next)\n\t\tcnt++;\n\ts2 = new_stmt(cstate, JMP(BPF_JA));\n\ts2->s.k = cnt - 1;\n\tsappend(s, s2);\n\n\t/* insert our statements at the beginning of b_vid */\n\tsappend(s, b_vid->stmts);\n\tb_vid->stmts = s;\n}",
          "fn_code_pos": [
            [
              8819,
              0
            ],
            [
              8853,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_vlan_patch_vid_test",
            "parameters": {
              "cstate": "compiler_state_t",
              "b_vid": "struct block"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static struct block *\ngen_vlan_bpf_extensions(compiler_state_t *cstate, bpf_u_int32 vlan_num,\n    int has_vlan_tag)\n{\n        struct block *b0, *b_tpid, *b_vid = NULL;\n        struct slist *s;\n\n        /* generate new filter code based on extracting packet\n         * metadata */\n        s = new_stmt(cstate, BPF_LD|BPF_B|BPF_ABS);\n        s->s.k = SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT;\n\n        b0 = new_block(cstate, JMP(BPF_JEQ));\n        b0->stmts = s;\n        b0->s.k = 1;\n\n\t/*\n\t * This is tricky. We need to insert the statements updating variable\n\t * parts of offsets before the the traditional TPID and VID tests so\n\t * that they are called whenever SKF_AD_VLAN_TAG_PRESENT fails but\n\t * we do not want this update to affect those checks. That's why we\n\t * generate both test blocks first and insert the statements updating\n\t * variable parts of both offsets after that. This wouldn't work if\n\t * there already were variable length link header when entering this\n\t * function but gen_vlan_bpf_extensions() isn't called in that case.\n\t */\n\tb_tpid = gen_vlan_tpid_test(cstate);\n\tif (has_vlan_tag)\n\t\tb_vid = gen_vlan_vid_test(cstate, vlan_num);\n\n\tgen_vlan_patch_tpid_test(cstate, b_tpid);\n\tgen_or(b0, b_tpid);\n\tb0 = b_tpid;\n\n\tif (has_vlan_tag) {\n\t\tgen_vlan_patch_vid_test(cstate, b_vid);\n\t\tgen_and(b0, b_vid);\n\t\tb0 = b_vid;\n\t}\n\n        return b0;\n}",
          "fn_code_pos": [
            [
              8863,
              0
            ],
            [
              8904,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_vlan_bpf_extensions",
            "parameters": {
              "cstate": "compiler_state_t",
              "vlan_num": "bpf_u_int32",
              "has_vlan_tag": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_vlan(compiler_state_t *cstate, bpf_u_int32 vlan_num, int has_vlan_tag)\n{\n\tstruct\tblock\t*b0;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/* can't check for VLAN-encapsulated packets inside MPLS */\n\tif (cstate->label_stack_depth > 0)\n\t\tbpf_error(cstate, \"no VLAN match after MPLS\");\n\n\t/*\n\t * Check for a VLAN packet, and then change the offsets to point\n\t * to the type and data fields within the VLAN packet.  Just\n\t * increment the offsets, so that we can support a hierarchy, e.g.\n\t * \"vlan 300 && vlan 200\" to capture VLAN 200 encapsulated within\n\t * VLAN 100.\n\t *\n\t * XXX - this is a bit of a kludge.  If we were to split the\n\t * compiler into a parser that parses an expression and\n\t * generates an expression tree, and a code generator that\n\t * takes an expression tree (which could come from our\n\t * parser or from some other parser) and generates BPF code,\n\t * we could perhaps make the offsets parameters of routines\n\t * and, in the handler for an \"AND\" node, pass to subnodes\n\t * other than the VLAN node the adjusted offsets.\n\t *\n\t * This would mean that \"vlan\" would, instead of changing the\n\t * behavior of *all* tests after it, change only the behavior\n\t * of tests ANDed with it.  That would change the documented\n\t * semantics of \"vlan\", which might break some expressions.\n\t * However, it would mean that \"(vlan and ip) or ip\" would check\n\t * both for VLAN-encapsulated IP and IP-over-Ethernet, rather than\n\t * checking only for VLAN-encapsulated IP, so that could still\n\t * be considered worth doing; it wouldn't break expressions\n\t * that are of the form \"vlan and ...\" or \"vlan N and ...\",\n\t * which I suspect are the most common expressions involving\n\t * \"vlan\".  \"vlan or ...\" doesn't necessarily do what the user\n\t * would really want, now, as all the \"or ...\" tests would\n\t * be done assuming a VLAN, even though the \"or\" could be viewed\n\t * as meaning \"or, if this isn't a VLAN packet...\".\n\t */\n\tswitch (cstate->linktype) {\n\n\tcase DLT_EN10MB:\n\tcase DLT_NETANALYZER:\n\tcase DLT_NETANALYZER_TRANSPARENT:\n#if defined(SKF_AD_VLAN_TAG_PRESENT)\n\t\t/* Verify that this is the outer part of the packet and\n\t\t * not encapsulated somehow. */\n\t\tif (cstate->vlan_stack_depth == 0 && !cstate->off_linkhdr.is_variable &&\n\t\t    cstate->off_linkhdr.constant_part ==\n\t\t    cstate->off_outermostlinkhdr.constant_part) {\n\t\t\t/*\n\t\t\t * Do we need special VLAN handling?\n\t\t\t */\n\t\t\tif (cstate->bpf_pcap->bpf_codegen_flags & BPF_SPECIAL_VLAN_HANDLING)\n\t\t\t\tb0 = gen_vlan_bpf_extensions(cstate, vlan_num,\n\t\t\t\t    has_vlan_tag);\n\t\t\telse\n\t\t\t\tb0 = gen_vlan_no_bpf_extensions(cstate,\n\t\t\t\t    vlan_num, has_vlan_tag);\n\t\t} else\n#endif\n\t\t\tb0 = gen_vlan_no_bpf_extensions(cstate, vlan_num,\n\t\t\t    has_vlan_tag);\n                break;\n\n\tcase DLT_IEEE802_11:\n\tcase DLT_PRISM_HEADER:\n\tcase DLT_IEEE802_11_RADIO_AVS:\n\tcase DLT_IEEE802_11_RADIO:\n\t\tb0 = gen_vlan_no_bpf_extensions(cstate, vlan_num, has_vlan_tag);\n\t\tbreak;\n\n\tdefault:\n\t\tbpf_error(cstate, \"no VLAN support for data link type %d\",\n\t\t      cstate->linktype);\n\t\t/*NOTREACHED*/\n\t}\n\n        cstate->vlan_stack_depth++;\n\n\treturn (b0);\n}",
          "fn_code_pos": [
            [
              8910,
              0
            ],
            [
              8999,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_vlan",
            "parameters": {
              "cstate": "compiler_state_t",
              "vlan_num": "bpf_u_int32",
              "has_vlan_tag": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_mpls(compiler_state_t *cstate, bpf_u_int32 label_num_arg,\n    int has_label_num)\n{\n\tvolatile bpf_u_int32 label_num = label_num_arg;\n\tstruct\tblock\t*b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n        if (cstate->label_stack_depth > 0) {\n            /* just match the bottom-of-stack bit clear */\n            b0 = gen_mcmp(cstate, OR_PREVMPLSHDR, 2, BPF_B, 0, 0x01);\n        } else {\n            /*\n             * We're not in an MPLS stack yet, so check the link-layer\n             * type against MPLS.\n             */\n            switch (cstate->linktype) {\n\n            case DLT_C_HDLC: /* fall through */\n            case DLT_EN10MB:\n            case DLT_NETANALYZER:\n            case DLT_NETANALYZER_TRANSPARENT:\n                    b0 = gen_linktype(cstate, ETHERTYPE_MPLS);\n                    break;\n\n            case DLT_PPP:\n                    b0 = gen_linktype(cstate, PPP_MPLS_UCAST);\n                    break;\n\n                    /* FIXME add other DLT_s ...\n                     * for Frame-Relay/and ATM this may get messy due to SNAP headers\n                     * leave it for now */\n\n            default:\n                    bpf_error(cstate, \"no MPLS support for data link type %d\",\n                          cstate->linktype);\n                    /*NOTREACHED*/\n            }\n        }\n\n\t/* If a specific MPLS label is requested, check it */\n\tif (has_label_num) {\n\t\tif (label_num > 0xFFFFF) {\n\t\t\tbpf_error(cstate, \"MPLS label %u greater than maximum %u\",\n\t\t\t    label_num, 0xFFFFF);\n\t\t}\n\t\tlabel_num = label_num << 12; /* label is shifted 12 bits on the wire */\n\t\tb1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_W, label_num,\n\t\t    0xfffff000); /* only compare the first 20 bits */\n\t\tgen_and(b0, b1);\n\t\tb0 = b1;\n\t}\n\n        /*\n         * Change the offsets to point to the type and data fields within\n         * the MPLS packet.  Just increment the offsets, so that we\n         * can support a hierarchy, e.g. \"mpls 100000 && mpls 1024\" to\n         * capture packets with an outer label of 100000 and an inner\n         * label of 1024.\n         *\n         * Increment the MPLS stack depth as well; this indicates that\n         * we're checking MPLS-encapsulated headers, to make sure higher\n         * level code generators don't try to match against IP-related\n         * protocols such as Q_ARP, Q_RARP etc.\n         *\n         * XXX - this is a bit of a kludge.  See comments in gen_vlan().\n         */\n        cstate->off_nl_nosnap += 4;\n        cstate->off_nl += 4;\n        cstate->label_stack_depth++;\n\treturn (b0);\n}",
          "fn_code_pos": [
            [
              9008,
              0
            ],
            [
              9085,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mpls",
            "parameters": {
              "cstate": "compiler_state_t",
              "label_num_arg": "bpf_u_int32",
              "has_label_num": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_pppoed(compiler_state_t *cstate)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/* check for PPPoE discovery */\n\treturn gen_linktype(cstate, ETHERTYPE_PPPOED);\n}",
          "fn_code_pos": [
            [
              9090,
              0
            ],
            [
              9102,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pppoed",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_pppoes(compiler_state_t *cstate, bpf_u_int32 sess_num, int has_sess_num)\n{\n\tstruct block *b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\t/*\n\t * Test against the PPPoE session link-layer type.\n\t */\n\tb0 = gen_linktype(cstate, ETHERTYPE_PPPOES);\n\n\t/* If a specific session is requested, check PPPoE session id */\n\tif (has_sess_num) {\n\t\tif (sess_num > 0x0000ffff) {\n\t\t\tbpf_error(cstate, \"PPPoE session number %u greater than maximum %u\",\n\t\t\t    sess_num, 0x0000ffff);\n\t\t}\n\t\tb1 = gen_mcmp(cstate, OR_LINKPL, 0, BPF_W, sess_num, 0x0000ffff);\n\t\tgen_and(b0, b1);\n\t\tb0 = b1;\n\t}\n\n\t/*\n\t * Change the offsets to point to the type and data fields within\n\t * the PPP packet, and note that this is PPPoE rather than\n\t * raw PPP.\n\t *\n\t * XXX - this is a bit of a kludge.  If we were to split the\n\t * compiler into a parser that parses an expression and\n\t * generates an expression tree, and a code generator that\n\t * takes an expression tree (which could come from our\n\t * parser or from some other parser) and generates BPF code,\n\t * we could perhaps make the offsets parameters of routines\n\t * and, in the handler for an \"AND\" node, pass to subnodes\n\t * other than the PPPoE node the adjusted offsets.\n\t *\n\t * This would mean that \"pppoes\" would, instead of changing the\n\t * behavior of *all* tests after it, change only the behavior\n\t * of tests ANDed with it.  That would change the documented\n\t * semantics of \"pppoes\", which might break some expressions.\n\t * However, it would mean that \"(pppoes and ip) or ip\" would check\n\t * both for VLAN-encapsulated IP and IP-over-Ethernet, rather than\n\t * checking only for VLAN-encapsulated IP, so that could still\n\t * be considered worth doing; it wouldn't break expressions\n\t * that are of the form \"pppoes and ...\" which I suspect are the\n\t * most common expressions involving \"pppoes\".  \"pppoes or ...\"\n\t * doesn't necessarily do what the user would really want, now,\n\t * as all the \"or ...\" tests would be done assuming PPPoE, even\n\t * though the \"or\" could be viewed as meaning \"or, if this isn't\n\t * a PPPoE packet...\".\n\t *\n\t * The \"network-layer\" protocol is PPPoE, which has a 6-byte\n\t * PPPoE header, followed by a PPP packet.\n\t *\n\t * There is no HDLC encapsulation for the PPP packet (it's\n\t * encapsulated in PPPoES instead), so the link-layer type\n\t * starts at the first byte of the PPP packet.  For PPPoE,\n\t * that offset is relative to the beginning of the total\n\t * link-layer payload, including any 802.2 LLC header, so\n\t * it's 6 bytes past cstate->off_nl.\n\t */\n\tPUSH_LINKHDR(cstate, DLT_PPP, cstate->off_linkpl.is_variable,\n\t    cstate->off_linkpl.constant_part + cstate->off_nl + 6, /* 6 bytes past the PPPoE header */\n\t    cstate->off_linkpl.reg);\n\n\tcstate->off_linktype = cstate->off_linkhdr;\n\tcstate->off_linkpl.constant_part = cstate->off_linkhdr.constant_part + 2;\n\n\tcstate->off_nl = 0;\n\tcstate->off_nl_nosnap = 0;\t/* no 802.2 LLC */\n\n\treturn b0;\n}",
          "fn_code_pos": [
            [
              9104,
              0
            ],
            [
              9182,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pppoes",
            "parameters": {
              "cstate": "compiler_state_t",
              "sess_num": "bpf_u_int32",
              "has_sess_num": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_geneve_check(compiler_state_t *cstate,\n    struct block *(*gen_portfn)(compiler_state_t *, u_int, int, int),\n    enum e_offrel offrel, bpf_u_int32 vni, int has_vni)\n{\n\tstruct block *b0, *b1;\n\n\tb0 = gen_portfn(cstate, GENEVE_PORT, IPPROTO_UDP, Q_DST);\n\n\t/* Check that we are operating on version 0. Otherwise, we\n\t * can't decode the rest of the fields. The version is 2 bits\n\t * in the first byte of the Geneve header. */\n\tb1 = gen_mcmp(cstate, offrel, 8, BPF_B, 0, 0xc0);\n\tgen_and(b0, b1);\n\tb0 = b1;\n\n\tif (has_vni) {\n\t\tif (vni > 0xffffff) {\n\t\t\tbpf_error(cstate, \"Geneve VNI %u greater than maximum %u\",\n\t\t\t    vni, 0xffffff);\n\t\t}\n\t\tvni <<= 8; /* VNI is in the upper 3 bytes */\n\t\tb1 = gen_mcmp(cstate, offrel, 12, BPF_W, vni, 0xffffff00);\n\t\tgen_and(b0, b1);\n\t\tb0 = b1;\n\t}\n\n\treturn b0;\n}",
          "fn_code_pos": [
            [
              9186,
              0
            ],
            [
              9214,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_geneve_check",
            "parameters": {
              "cstate": "compiler_state_t",
              "gen_portfn": "struct block",
              "offrel": "enum e_offrel",
              "vni": "bpf_u_int32",
              "has_vni": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_geneve4(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)\n{\n\tstruct block *b0, *b1;\n\tstruct slist *s, *s1;\n\n\tb0 = gen_geneve_check(cstate, gen_port, OR_TRAN_IPV4, vni, has_vni);\n\n\t/* Load the IP header length into A. */\n\ts = gen_loadx_iphdrlen(cstate);\n\n\ts1 = new_stmt(cstate, BPF_MISC|BPF_TXA);\n\tsappend(s, s1);\n\n\t/* Forcibly append these statements to the true condition\n\t * of the protocol check by creating a new block that is\n\t * always true and ANDing them. */\n\tb1 = new_block(cstate, BPF_JMP|BPF_JEQ|BPF_X);\n\tb1->stmts = s;\n\tb1->s.k = 0;\n\n\tgen_and(b0, b1);\n\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              9221,
              0
            ],
            [
              9245,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_geneve4",
            "parameters": {
              "cstate": "compiler_state_t",
              "vni": "bpf_u_int32",
              "has_vni": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_geneve6(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)\n{\n\tstruct block *b0, *b1;\n\tstruct slist *s, *s1;\n\n\tb0 = gen_geneve_check(cstate, gen_port6, OR_TRAN_IPV6, vni, has_vni);\n\n\t/* Load the IP header length. We need to account for a\n\t * variable length link prefix if there is one. */\n\ts = gen_abs_offset_varpart(cstate, &cstate->off_linkpl);\n\tif (s) {\n\t\ts1 = new_stmt(cstate, BPF_LD|BPF_IMM);\n\t\ts1->s.k = 40;\n\t\tsappend(s, s1);\n\n\t\ts1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X);\n\t\ts1->s.k = 0;\n\t\tsappend(s, s1);\n\t} else {\n\t\ts = new_stmt(cstate, BPF_LD|BPF_IMM);\n\t\ts->s.k = 40;\n\t}\n\n\t/* Forcibly append these statements to the true condition\n\t * of the protocol check by creating a new block that is\n\t * always true and ANDing them. */\n\ts1 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\tsappend(s, s1);\n\n\tb1 = new_block(cstate, BPF_JMP|BPF_JEQ|BPF_X);\n\tb1->stmts = s;\n\tb1->s.k = 0;\n\n\tgen_and(b0, b1);\n\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              9247,
              0
            ],
            [
              9284,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_geneve6",
            "parameters": {
              "cstate": "compiler_state_t",
              "vni": "bpf_u_int32",
              "has_vni": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct slist *\ngen_geneve_offsets(compiler_state_t *cstate)\n{\n\tstruct slist *s, *s1, *s_proto;\n\n\t/* First we need to calculate the offset of the Geneve header\n\t * itself. This is composed of the IP header previously calculated\n\t * (include any variable link prefix) and stored in A plus the\n\t * fixed sized headers (fixed link prefix, MAC length, and UDP\n\t * header). */\n\ts = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts->s.k = cstate->off_linkpl.constant_part + cstate->off_nl + 8;\n\n\t/* Stash this in X since we'll need it later. */\n\ts1 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\tsappend(s, s1);\n\n\t/* The EtherType in Geneve is 2 bytes in. Calculate this and\n\t * store it. */\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts1->s.k = 2;\n\tsappend(s, s1);\n\n\tcstate->off_linktype.reg = alloc_reg(cstate);\n\tcstate->off_linktype.is_variable = 1;\n\tcstate->off_linktype.constant_part = 0;\n\n\ts1 = new_stmt(cstate, BPF_ST);\n\ts1->s.k = cstate->off_linktype.reg;\n\tsappend(s, s1);\n\n\t/* Load the Geneve option length and mask and shift to get the\n\t * number of bytes. It is stored in the first byte of the Geneve\n\t * header. */\n\ts1 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_B);\n\ts1->s.k = 0;\n\tsappend(s, s1);\n\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_AND|BPF_K);\n\ts1->s.k = 0x3f;\n\tsappend(s, s1);\n\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_MUL|BPF_K);\n\ts1->s.k = 4;\n\tsappend(s, s1);\n\n\t/* Add in the rest of the Geneve base header. */\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts1->s.k = 8;\n\tsappend(s, s1);\n\n\t/* Add the Geneve header length to its offset and store. */\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_X);\n\ts1->s.k = 0;\n\tsappend(s, s1);\n\n\t/* Set the encapsulated type as Ethernet. Even though we may\n\t * not actually have Ethernet inside there are two reasons this\n\t * is useful:\n\t * - The linktype field is always in EtherType format regardless\n\t *   of whether it is in Geneve or an inner Ethernet frame.\n\t * - The only link layer that we have specific support for is\n\t *   Ethernet. We will confirm that the packet actually is\n\t *   Ethernet at runtime before executing these checks. */\n\tPUSH_LINKHDR(cstate, DLT_EN10MB, 1, 0, alloc_reg(cstate));\n\n\ts1 = new_stmt(cstate, BPF_ST);\n\ts1->s.k = cstate->off_linkhdr.reg;\n\tsappend(s, s1);\n\n\t/* Calculate whether we have an Ethernet header or just raw IP/\n\t * MPLS/etc. If we have Ethernet, advance the end of the MAC offset\n\t * and linktype by 14 bytes so that the network header can be found\n\t * seamlessly. Otherwise, keep what we've calculated already. */\n\n\t/* We have a bare jmp so we can't use the optimizer. */\n\tcstate->no_optimize = 1;\n\n\t/* Load the EtherType in the Geneve header, 2 bytes in. */\n\ts1 = new_stmt(cstate, BPF_LD|BPF_IND|BPF_H);\n\ts1->s.k = 2;\n\tsappend(s, s1);\n\n\t/* Load X with the end of the Geneve header. */\n\ts1 = new_stmt(cstate, BPF_LDX|BPF_MEM);\n\ts1->s.k = cstate->off_linkhdr.reg;\n\tsappend(s, s1);\n\n\t/* Check if the EtherType is Transparent Ethernet Bridging. At the\n\t * end of this check, we should have the total length in X. In\n\t * the non-Ethernet case, it's already there. */\n\ts_proto = new_stmt(cstate, JMP(BPF_JEQ));\n\ts_proto->s.k = ETHERTYPE_TEB;\n\tsappend(s, s_proto);\n\n\ts1 = new_stmt(cstate, BPF_MISC|BPF_TXA);\n\tsappend(s, s1);\n\ts_proto->s.jt = s1;\n\n\t/* Since this is Ethernet, use the EtherType of the payload\n\t * directly as the linktype. Overwrite what we already have. */\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts1->s.k = 12;\n\tsappend(s, s1);\n\n\ts1 = new_stmt(cstate, BPF_ST);\n\ts1->s.k = cstate->off_linktype.reg;\n\tsappend(s, s1);\n\n\t/* Advance two bytes further to get the end of the Ethernet\n\t * header. */\n\ts1 = new_stmt(cstate, BPF_ALU|BPF_ADD|BPF_K);\n\ts1->s.k = 2;\n\tsappend(s, s1);\n\n\t/* Move the result to X. */\n\ts1 = new_stmt(cstate, BPF_MISC|BPF_TAX);\n\tsappend(s, s1);\n\n\t/* Store the final result of our linkpl calculation. */\n\tcstate->off_linkpl.reg = alloc_reg(cstate);\n\tcstate->off_linkpl.is_variable = 1;\n\tcstate->off_linkpl.constant_part = 0;\n\n\ts1 = new_stmt(cstate, BPF_STX);\n\ts1->s.k = cstate->off_linkpl.reg;\n\tsappend(s, s1);\n\ts_proto->s.jf = s1;\n\n\tcstate->off_nl = 0;\n\n\treturn s;\n}",
          "fn_code_pos": [
            [
              9290,
              0
            ],
            [
              9422,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_geneve_offsets",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_geneve(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)\n{\n\tstruct block *b0, *b1;\n\tstruct slist *s;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tb0 = gen_geneve4(cstate, vni, has_vni);\n\tb1 = gen_geneve6(cstate, vni, has_vni);\n\n\tgen_or(b0, b1);\n\tb0 = b1;\n\n\t/* Later filters should act on the payload of the Geneve frame,\n\t * update all of the header pointers. Attach this code so that\n\t * it gets executed in the event that the Geneve filter matches. */\n\ts = gen_geneve_offsets(cstate);\n\n\tb1 = gen_true(cstate);\n\tsappend(s, b1->stmts);\n\tb1->stmts = s;\n\n\tgen_and(b0, b1);\n\n\tcstate->is_geneve = 1;\n\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              9425,
              0
            ],
            [
              9458,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_geneve",
            "parameters": {
              "cstate": "compiler_state_t",
              "vni": "bpf_u_int32",
              "has_vni": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_geneve_ll_check(compiler_state_t *cstate)\n{\n\tstruct block *b0;\n\tstruct slist *s, *s1;\n\n\t/* The easiest way to see if there is a link layer present\n\t * is to check if the link layer header and payload are not\n\t * the same. */\n\n\t/* Geneve always generates pure variable offsets so we can\n\t * compare only the registers. */\n\ts = new_stmt(cstate, BPF_LD|BPF_MEM);\n\ts->s.k = cstate->off_linkhdr.reg;\n\n\ts1 = new_stmt(cstate, BPF_LDX|BPF_MEM);\n\ts1->s.k = cstate->off_linkpl.reg;\n\tsappend(s, s1);\n\n\tb0 = new_block(cstate, BPF_JMP|BPF_JEQ|BPF_X);\n\tb0->stmts = s;\n\tb0->s.k = 0;\n\tgen_not(b0);\n\n\treturn b0;\n}",
          "fn_code_pos": [
            [
              9462,
              0
            ],
            [
              9487,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_geneve_ll_check",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_atmfield_code_internal(compiler_state_t *cstate, int atmfield,\n    bpf_u_int32 jvalue, int jtype, int reverse)\n{\n\tstruct block *b0;\n\n\tswitch (atmfield) {\n\n\tcase A_VPI:\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'vpi' supported only on raw ATM\");\n\t\tif (cstate->off_vpi == OFFSET_NOT_SET)\n\t\t\tabort();\n\t\tb0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_vpi, BPF_B,\n\t\t    0xffffffffU, jtype, reverse, jvalue);\n\t\tbreak;\n\n\tcase A_VCI:\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'vci' supported only on raw ATM\");\n\t\tif (cstate->off_vci == OFFSET_NOT_SET)\n\t\t\tabort();\n\t\tb0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_vci, BPF_H,\n\t\t    0xffffffffU, jtype, reverse, jvalue);\n\t\tbreak;\n\n\tcase A_PROTOTYPE:\n\t\tif (cstate->off_proto == OFFSET_NOT_SET)\n\t\t\tabort();\t/* XXX - this isn't on FreeBSD */\n\t\tb0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_proto, BPF_B,\n\t\t    0x0fU, jtype, reverse, jvalue);\n\t\tbreak;\n\n\tcase A_MSGTYPE:\n\t\tif (cstate->off_payload == OFFSET_NOT_SET)\n\t\t\tabort();\n\t\tb0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_payload + MSG_TYPE_POS, BPF_B,\n\t\t    0xffffffffU, jtype, reverse, jvalue);\n\t\tbreak;\n\n\tcase A_CALLREFTYPE:\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'callref' supported only on raw ATM\");\n\t\tif (cstate->off_proto == OFFSET_NOT_SET)\n\t\t\tabort();\n\t\tb0 = gen_ncmp(cstate, OR_LINKHDR, cstate->off_proto, BPF_B,\n\t\t    0xffffffffU, jtype, reverse, jvalue);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\treturn b0;\n}",
          "fn_code_pos": [
            [
              9489,
              0
            ],
            [
              9542,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmfield_code_internal",
            "parameters": {
              "cstate": "compiler_state_t",
              "atmfield": "int",
              "jvalue": "bpf_u_int32",
              "jtype": "int",
              "reverse": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_atmtype_metac(compiler_state_t *cstate)\n{\n\tstruct block *b0, *b1;\n\n\tb0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);\n\tb1 = gen_atmfield_code_internal(cstate, A_VCI, 1, BPF_JEQ, 0);\n\tgen_and(b0, b1);\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              9544,
              0
            ],
            [
              9553,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmtype_metac",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_atmtype_sc(compiler_state_t *cstate)\n{\n\tstruct block *b0, *b1;\n\n\tb0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);\n\tb1 = gen_atmfield_code_internal(cstate, A_VCI, 5, BPF_JEQ, 0);\n\tgen_and(b0, b1);\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              9555,
              0
            ],
            [
              9564,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmtype_sc",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_atmtype_llc(compiler_state_t *cstate)\n{\n\tstruct block *b0;\n\n\tb0 = gen_atmfield_code_internal(cstate, A_PROTOTYPE, PT_LLC, BPF_JEQ, 0);\n\tcstate->linktype = cstate->prevlinktype;\n\treturn b0;\n}",
          "fn_code_pos": [
            [
              9566,
              0
            ],
            [
              9574,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmtype_llc",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_atmfield_code(compiler_state_t *cstate, int atmfield,\n    bpf_u_int32 jvalue, int jtype, int reverse)\n{\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\treturn gen_atmfield_code_internal(cstate, atmfield, jvalue, jtype,\n\t    reverse);\n}",
          "fn_code_pos": [
            [
              9576,
              0
            ],
            [
              9589,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmfield_code",
            "parameters": {
              "cstate": "compiler_state_t",
              "atmfield": "int",
              "jvalue": "bpf_u_int32",
              "jtype": "int",
              "reverse": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_atmtype_abbrev(compiler_state_t *cstate, int type)\n{\n\tstruct block *b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (type) {\n\n\tcase A_METAC:\n\t\t/* Get all packets in Meta signalling Circuit */\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'metac' supported only on raw ATM\");\n\t\tb1 = gen_atmtype_metac(cstate);\n\t\tbreak;\n\n\tcase A_BCC:\n\t\t/* Get all packets in Broadcast Circuit*/\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'bcc' supported only on raw ATM\");\n\t\tb0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);\n\t\tb1 = gen_atmfield_code_internal(cstate, A_VCI, 2, BPF_JEQ, 0);\n\t\tgen_and(b0, b1);\n\t\tbreak;\n\n\tcase A_OAMF4SC:\n\t\t/* Get all cells in Segment OAM F4 circuit*/\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'oam4sc' supported only on raw ATM\");\n\t\tb0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);\n\t\tb1 = gen_atmfield_code_internal(cstate, A_VCI, 3, BPF_JEQ, 0);\n\t\tgen_and(b0, b1);\n\t\tbreak;\n\n\tcase A_OAMF4EC:\n\t\t/* Get all cells in End-to-End OAM F4 Circuit*/\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'oam4ec' supported only on raw ATM\");\n\t\tb0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);\n\t\tb1 = gen_atmfield_code_internal(cstate, A_VCI, 4, BPF_JEQ, 0);\n\t\tgen_and(b0, b1);\n\t\tbreak;\n\n\tcase A_SC:\n\t\t/*  Get all packets in connection Signalling Circuit */\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'sc' supported only on raw ATM\");\n\t\tb1 = gen_atmtype_sc(cstate);\n\t\tbreak;\n\n\tcase A_ILMIC:\n\t\t/* Get all packets in ILMI Circuit */\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'ilmic' supported only on raw ATM\");\n\t\tb0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);\n\t\tb1 = gen_atmfield_code_internal(cstate, A_VCI, 16, BPF_JEQ, 0);\n\t\tgen_and(b0, b1);\n\t\tbreak;\n\n\tcase A_LANE:\n\t\t/* Get all LANE packets */\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'lane' supported only on raw ATM\");\n\t\tb1 = gen_atmfield_code_internal(cstate, A_PROTOTYPE, PT_LANE, BPF_JEQ, 0);\n\n\t\t/*\n\t\t * Arrange that all subsequent tests assume LANE\n\t\t * rather than LLC-encapsulated packets, and set\n\t\t * the offsets appropriately for LANE-encapsulated\n\t\t * Ethernet.\n\t\t *\n\t\t * We assume LANE means Ethernet, not Token Ring.\n\t\t */\n\t\tPUSH_LINKHDR(cstate, DLT_EN10MB, 0,\n\t\t    cstate->off_payload + 2,\t/* Ethernet header */\n\t\t    -1);\n\t\tcstate->off_linktype.constant_part = cstate->off_linkhdr.constant_part + 12;\n\t\tcstate->off_linkpl.constant_part = cstate->off_linkhdr.constant_part + 14;\t/* Ethernet */\n\t\tcstate->off_nl = 0;\t\t\t/* Ethernet II */\n\t\tcstate->off_nl_nosnap = 3;\t\t/* 802.3+802.2 */\n\t\tbreak;\n\n\tcase A_LLC:\n\t\t/* Get all LLC-encapsulated packets */\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'llc' supported only on raw ATM\");\n\t\tb1 = gen_atmtype_llc(cstate);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              9591,
              0
            ],
            [
              9689,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmtype_abbrev",
            "parameters": {
              "cstate": "compiler_state_t",
              "type": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_mtp2type_abbrev(compiler_state_t *cstate, int type)\n{\n\tstruct block *b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (type) {\n\n\tcase M_FISU:\n\t\tif ( (cstate->linktype != DLT_MTP2) &&\n\t\t     (cstate->linktype != DLT_ERF) &&\n\t\t     (cstate->linktype != DLT_MTP2_WITH_PHDR) )\n\t\t\tbpf_error(cstate, \"'fisu' supported only on MTP2\");\n\t\t/* gen_ncmp(cstate, offrel, offset, size, mask, jtype, reverse, value) */\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li, BPF_B,\n\t\t    0x3fU, BPF_JEQ, 0, 0U);\n\t\tbreak;\n\n\tcase M_LSSU:\n\t\tif ( (cstate->linktype != DLT_MTP2) &&\n\t\t     (cstate->linktype != DLT_ERF) &&\n\t\t     (cstate->linktype != DLT_MTP2_WITH_PHDR) )\n\t\t\tbpf_error(cstate, \"'lssu' supported only on MTP2\");\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li, BPF_B,\n\t\t    0x3fU, BPF_JGT, 1, 2U);\n\t\tb1 = gen_ncmp(cstate, OR_PACKET, cstate->off_li, BPF_B,\n\t\t    0x3fU, BPF_JGT, 0, 0U);\n\t\tgen_and(b1, b0);\n\t\tbreak;\n\n\tcase M_MSU:\n\t\tif ( (cstate->linktype != DLT_MTP2) &&\n\t\t     (cstate->linktype != DLT_ERF) &&\n\t\t     (cstate->linktype != DLT_MTP2_WITH_PHDR) )\n\t\t\tbpf_error(cstate, \"'msu' supported only on MTP2\");\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li, BPF_B,\n\t\t    0x3fU, BPF_JGT, 0, 2U);\n\t\tbreak;\n\n\tcase MH_FISU:\n\t\tif ( (cstate->linktype != DLT_MTP2) &&\n\t\t     (cstate->linktype != DLT_ERF) &&\n\t\t     (cstate->linktype != DLT_MTP2_WITH_PHDR) )\n\t\t\tbpf_error(cstate, \"'hfisu' supported only on MTP2_HSL\");\n\t\t/* gen_ncmp(cstate, offrel, offset, size, mask, jtype, reverse, value) */\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li_hsl, BPF_H,\n\t\t    0xff80U, BPF_JEQ, 0, 0U);\n\t\tbreak;\n\n\tcase MH_LSSU:\n\t\tif ( (cstate->linktype != DLT_MTP2) &&\n\t\t     (cstate->linktype != DLT_ERF) &&\n\t\t     (cstate->linktype != DLT_MTP2_WITH_PHDR) )\n\t\t\tbpf_error(cstate, \"'hlssu' supported only on MTP2_HSL\");\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li_hsl, BPF_H,\n\t\t    0xff80U, BPF_JGT, 1, 0x0100U);\n\t\tb1 = gen_ncmp(cstate, OR_PACKET, cstate->off_li_hsl, BPF_H,\n\t\t    0xff80U, BPF_JGT, 0, 0U);\n\t\tgen_and(b1, b0);\n\t\tbreak;\n\n\tcase MH_MSU:\n\t\tif ( (cstate->linktype != DLT_MTP2) &&\n\t\t     (cstate->linktype != DLT_ERF) &&\n\t\t     (cstate->linktype != DLT_MTP2_WITH_PHDR) )\n\t\t\tbpf_error(cstate, \"'hmsu' supported only on MTP2_HSL\");\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, cstate->off_li_hsl, BPF_H,\n\t\t    0xff80U, BPF_JGT, 0, 0x0100U);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\treturn b0;\n}",
          "fn_code_pos": [
            [
              9698,
              0
            ],
            [
              9778,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mtp2type_abbrev",
            "parameters": {
              "cstate": "compiler_state_t",
              "type": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_mtp3field_code(compiler_state_t *cstate, int mtp3field,\n    bpf_u_int32 jvalue_arg, int jtype, int reverse)\n{\n\tvolatile bpf_u_int32 jvalue = jvalue_arg;\n\tstruct block *b0;\n\tbpf_u_int32 val1 , val2 , val3;\n\tu_int newoff_sio;\n\tu_int newoff_opc;\n\tu_int newoff_dpc;\n\tu_int newoff_sls;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tnewoff_sio = cstate->off_sio;\n\tnewoff_opc = cstate->off_opc;\n\tnewoff_dpc = cstate->off_dpc;\n\tnewoff_sls = cstate->off_sls;\n\tswitch (mtp3field) {\n\n\tcase MH_SIO:\n\t\tnewoff_sio += 3; /* offset for MTP2_HSL */\n\t\t/* FALLTHROUGH */\n\n\tcase M_SIO:\n\t\tif (cstate->off_sio == OFFSET_NOT_SET)\n\t\t\tbpf_error(cstate, \"'sio' supported only on SS7\");\n\t\t/* sio coded on 1 byte so max value 255 */\n\t\tif(jvalue > 255)\n\t\t        bpf_error(cstate, \"sio value %u too big; max value = 255\",\n\t\t            jvalue);\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, newoff_sio, BPF_B, 0xffffffffU,\n\t\t    jtype, reverse, jvalue);\n\t\tbreak;\n\n\tcase MH_OPC:\n\t\tnewoff_opc += 3;\n\n\t\t/* FALLTHROUGH */\n        case M_OPC:\n\t        if (cstate->off_opc == OFFSET_NOT_SET)\n\t\t\tbpf_error(cstate, \"'opc' supported only on SS7\");\n\t\t/* opc coded on 14 bits so max value 16383 */\n\t\tif (jvalue > 16383)\n\t\t        bpf_error(cstate, \"opc value %u too big; max value = 16383\",\n\t\t            jvalue);\n\t\t/* the following instructions are made to convert jvalue\n\t\t * to the form used to write opc in an ss7 message*/\n\t\tval1 = jvalue & 0x00003c00;\n\t\tval1 = val1 >>10;\n\t\tval2 = jvalue & 0x000003fc;\n\t\tval2 = val2 <<6;\n\t\tval3 = jvalue & 0x00000003;\n\t\tval3 = val3 <<22;\n\t\tjvalue = val1 + val2 + val3;\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, newoff_opc, BPF_W, 0x00c0ff0fU,\n\t\t    jtype, reverse, jvalue);\n\t\tbreak;\n\n\tcase MH_DPC:\n\t\tnewoff_dpc += 3;\n\t\t/* FALLTHROUGH */\n\n\tcase M_DPC:\n\t        if (cstate->off_dpc == OFFSET_NOT_SET)\n\t\t\tbpf_error(cstate, \"'dpc' supported only on SS7\");\n\t\t/* dpc coded on 14 bits so max value 16383 */\n\t\tif (jvalue > 16383)\n\t\t        bpf_error(cstate, \"dpc value %u too big; max value = 16383\",\n\t\t            jvalue);\n\t\t/* the following instructions are made to convert jvalue\n\t\t * to the forme used to write dpc in an ss7 message*/\n\t\tval1 = jvalue & 0x000000ff;\n\t\tval1 = val1 << 24;\n\t\tval2 = jvalue & 0x00003f00;\n\t\tval2 = val2 << 8;\n\t\tjvalue = val1 + val2;\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, newoff_dpc, BPF_W, 0xff3f0000U,\n\t\t    jtype, reverse, jvalue);\n\t\tbreak;\n\n\tcase MH_SLS:\n\t\tnewoff_sls += 3;\n\t\t/* FALLTHROUGH */\n\n\tcase M_SLS:\n\t        if (cstate->off_sls == OFFSET_NOT_SET)\n\t\t\tbpf_error(cstate, \"'sls' supported only on SS7\");\n\t\t/* sls coded on 4 bits so max value 15 */\n\t\tif (jvalue > 15)\n\t\t         bpf_error(cstate, \"sls value %u too big; max value = 15\",\n\t\t             jvalue);\n\t\t/* the following instruction is made to convert jvalue\n\t\t * to the forme used to write sls in an ss7 message*/\n\t\tjvalue = jvalue << 4;\n\t\tb0 = gen_ncmp(cstate, OR_PACKET, newoff_sls, BPF_B, 0xf0U,\n\t\t    jtype, reverse, jvalue);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\treturn b0;\n}",
          "fn_code_pos": [
            [
              9785,
              0
            ],
            [
              9893,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mtp3field_code",
            "parameters": {
              "cstate": "compiler_state_t",
              "mtp3field": "int",
              "jvalue_arg": "bpf_u_int32",
              "jtype": "int",
              "reverse": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static struct block *\ngen_msg_abbrev(compiler_state_t *cstate, int type)\n{\n\tstruct block *b1;\n\n\t/*\n\t * Q.2931 signalling protocol messages for handling virtual circuits\n\t * establishment and teardown\n\t */\n\tswitch (type) {\n\n\tcase A_SETUP:\n\t\tb1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, SETUP, BPF_JEQ, 0);\n\t\tbreak;\n\n\tcase A_CALLPROCEED:\n\t\tb1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, CALL_PROCEED, BPF_JEQ, 0);\n\t\tbreak;\n\n\tcase A_CONNECT:\n\t\tb1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, CONNECT, BPF_JEQ, 0);\n\t\tbreak;\n\n\tcase A_CONNECTACK:\n\t\tb1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, CONNECT_ACK, BPF_JEQ, 0);\n\t\tbreak;\n\n\tcase A_RELEASE:\n\t\tb1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, RELEASE, BPF_JEQ, 0);\n\t\tbreak;\n\n\tcase A_RELEASE_DONE:\n\t\tb1 = gen_atmfield_code_internal(cstate, A_MSGTYPE, RELEASE_DONE, BPF_JEQ, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              9895,
              0
            ],
            [
              9934,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_msg_abbrev",
            "parameters": {
              "cstate": "compiler_state_t",
              "type": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "struct block *\ngen_atmmulti_abbrev(compiler_state_t *cstate, int type)\n{\n\tstruct block *b0, *b1;\n\n\t/*\n\t * Catch errors reported by us and routines below us, and return NULL\n\t * on an error.\n\t */\n\tif (setjmp(cstate->top_ctx))\n\t\treturn (NULL);\n\n\tswitch (type) {\n\n\tcase A_OAM:\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'oam' supported only on raw ATM\");\n\t\t/* OAM F4 type */\n\t\tb0 = gen_atmfield_code_internal(cstate, A_VCI, 3, BPF_JEQ, 0);\n\t\tb1 = gen_atmfield_code_internal(cstate, A_VCI, 4, BPF_JEQ, 0);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);\n\t\tgen_and(b0, b1);\n\t\tbreak;\n\n\tcase A_OAMF4:\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'oamf4' supported only on raw ATM\");\n\t\t/* OAM F4 type */\n\t\tb0 = gen_atmfield_code_internal(cstate, A_VCI, 3, BPF_JEQ, 0);\n\t\tb1 = gen_atmfield_code_internal(cstate, A_VCI, 4, BPF_JEQ, 0);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_atmfield_code_internal(cstate, A_VPI, 0, BPF_JEQ, 0);\n\t\tgen_and(b0, b1);\n\t\tbreak;\n\n\tcase A_CONNECTMSG:\n\t\t/*\n\t\t * Get Q.2931 signalling messages for switched\n\t\t * virtual connection\n\t\t */\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'connectmsg' supported only on raw ATM\");\n\t\tb0 = gen_msg_abbrev(cstate, A_SETUP);\n\t\tb1 = gen_msg_abbrev(cstate, A_CALLPROCEED);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_msg_abbrev(cstate, A_CONNECT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_msg_abbrev(cstate, A_CONNECTACK);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_msg_abbrev(cstate, A_RELEASE);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_msg_abbrev(cstate, A_RELEASE_DONE);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_atmtype_sc(cstate);\n\t\tgen_and(b0, b1);\n\t\tbreak;\n\n\tcase A_METACONNECT:\n\t\tif (!cstate->is_atm)\n\t\t\tbpf_error(cstate, \"'metaconnect' supported only on raw ATM\");\n\t\tb0 = gen_msg_abbrev(cstate, A_SETUP);\n\t\tb1 = gen_msg_abbrev(cstate, A_CALLPROCEED);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_msg_abbrev(cstate, A_CONNECT);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_msg_abbrev(cstate, A_RELEASE);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_msg_abbrev(cstate, A_RELEASE_DONE);\n\t\tgen_or(b0, b1);\n\t\tb0 = gen_atmtype_metac(cstate);\n\t\tgen_and(b0, b1);\n\t\tbreak;\n\n\tdefault:\n\t\tabort();\n\t}\n\treturn b1;\n}",
          "fn_code_pos": [
            [
              9936,
              0
            ],
            [
              10014,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmmulti_abbrev",
            "parameters": {
              "cstate": "compiler_state_t",
              "type": "int"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "__SOCKADDR_COMMON (sin6_)",
          "fn_dec_pos": [
            [
              112,
              4
            ],
            [
              112,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "__SOCKADDR_COMMON",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "PCAP_NORETURN bpf_error(compiler_state_t *, const char *, ...)",
          "fn_dec_pos": [
            [
              459,
              12
            ],
            [
              459,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN bpf_error",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "init_linktype(compiler_state_t *, pcap_t *)",
          "fn_dec_pos": [
            [
              476,
              11
            ],
            [
              476,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "init_linktype",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "init_regs(compiler_state_t *)",
          "fn_dec_pos": [
            [
              478,
              12
            ],
            [
              478,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "init_regs",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "alloc_reg(compiler_state_t *)",
          "fn_dec_pos": [
            [
              479,
              11
            ],
            [
              479,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "alloc_reg",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "free_reg(compiler_state_t *, int)",
          "fn_dec_pos": [
            [
              480,
              12
            ],
            [
              480,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "free_reg",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "initchunks(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              482,
              12
            ],
            [
              482,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initchunks",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "newchunk_nolongjmp(compiler_state_t *cstate, size_t)",
          "fn_dec_pos": [
            [
              483,
              13
            ],
            [
              483,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "newchunk_nolongjmp",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "newchunk(compiler_state_t *cstate, size_t)",
          "fn_dec_pos": [
            [
              484,
              13
            ],
            [
              484,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "newchunk",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "freechunks(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              485,
              12
            ],
            [
              485,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "freechunks",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "new_block(compiler_state_t *cstate, int)",
          "fn_dec_pos": [
            [
              486,
              28
            ],
            [
              486,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "new_block",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "new_stmt(compiler_state_t *cstate, int)",
          "fn_dec_pos": [
            [
              487,
              28
            ],
            [
              487,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "new_stmt",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_retblk(compiler_state_t *cstate, int)",
          "fn_dec_pos": [
            [
              488,
              21
            ],
            [
              488,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_retblk",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "syntax(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              489,
              19
            ],
            [
              489,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "syntax",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "backpatch(struct block *, struct block *)",
          "fn_dec_pos": [
            [
              491,
              12
            ],
            [
              491,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "backpatch",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "merge(struct block *, struct block *)",
          "fn_dec_pos": [
            [
              492,
              12
            ],
            [
              492,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "merge",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "gen_cmp(compiler_state_t *, enum e_offrel, u_int,\n    u_int, bpf_u_int32)",
          "fn_dec_pos": [
            [
              493,
              21
            ],
            [
              494,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_cmp",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_cmp_gt(compiler_state_t *, enum e_offrel, u_int,\n    u_int, bpf_u_int32)",
          "fn_dec_pos": [
            [
              495,
              21
            ],
            [
              496,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_cmp_gt",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_cmp_ge(compiler_state_t *, enum e_offrel, u_int,\n    u_int, bpf_u_int32)",
          "fn_dec_pos": [
            [
              497,
              21
            ],
            [
              498,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_cmp_ge",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_cmp_lt(compiler_state_t *, enum e_offrel, u_int,\n    u_int, bpf_u_int32)",
          "fn_dec_pos": [
            [
              499,
              21
            ],
            [
              500,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_cmp_lt",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_cmp_le(compiler_state_t *, enum e_offrel, u_int,\n    u_int, bpf_u_int32)",
          "fn_dec_pos": [
            [
              501,
              21
            ],
            [
              502,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_cmp_le",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_mcmp(compiler_state_t *, enum e_offrel, u_int,\n    u_int, bpf_u_int32, bpf_u_int32)",
          "fn_dec_pos": [
            [
              503,
              21
            ],
            [
              504,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mcmp",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_bcmp(compiler_state_t *, enum e_offrel, u_int,\n    u_int, const u_char *)",
          "fn_dec_pos": [
            [
              505,
              21
            ],
            [
              506,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_bcmp",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ncmp(compiler_state_t *, enum e_offrel, u_int,\n    u_int, bpf_u_int32, int, int, bpf_u_int32)",
          "fn_dec_pos": [
            [
              507,
              21
            ],
            [
              508,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ncmp",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_load_absoffsetrel(compiler_state_t *, bpf_abs_offset *,\n    u_int, u_int)",
          "fn_dec_pos": [
            [
              509,
              21
            ],
            [
              510,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_absoffsetrel",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_load_a(compiler_state_t *, enum e_offrel, u_int,\n    u_int)",
          "fn_dec_pos": [
            [
              511,
              21
            ],
            [
              512,
              10
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_a",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_loadx_iphdrlen(compiler_state_t *)",
          "fn_dec_pos": [
            [
              513,
              21
            ],
            [
              513,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_loadx_iphdrlen",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_uncond(compiler_state_t *, int)",
          "fn_dec_pos": [
            [
              514,
              21
            ],
            [
              514,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_uncond",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_true(compiler_state_t *)",
          "fn_dec_pos": [
            [
              515,
              28
            ],
            [
              515,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_true",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_false(compiler_state_t *)",
          "fn_dec_pos": [
            [
              516,
              28
            ],
            [
              516,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_false",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ether_linktype(compiler_state_t *, bpf_u_int32)",
          "fn_dec_pos": [
            [
              517,
              21
            ],
            [
              517,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ether_linktype",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ipnet_linktype(compiler_state_t *, bpf_u_int32)",
          "fn_dec_pos": [
            [
              518,
              21
            ],
            [
              518,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ipnet_linktype",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_linux_sll_linktype(compiler_state_t *, bpf_u_int32)",
          "fn_dec_pos": [
            [
              519,
              21
            ],
            [
              519,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_linux_sll_linktype",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_load_prism_llprefixlen(compiler_state_t *)",
          "fn_dec_pos": [
            [
              520,
              21
            ],
            [
              520,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_prism_llprefixlen",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_load_avs_llprefixlen(compiler_state_t *)",
          "fn_dec_pos": [
            [
              521,
              21
            ],
            [
              521,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_avs_llprefixlen",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_load_radiotap_llprefixlen(compiler_state_t *)",
          "fn_dec_pos": [
            [
              522,
              21
            ],
            [
              522,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_radiotap_llprefixlen",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_load_ppi_llprefixlen(compiler_state_t *)",
          "fn_dec_pos": [
            [
              523,
              21
            ],
            [
              523,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_ppi_llprefixlen",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "insert_compute_vloffsets(compiler_state_t *, struct block *)",
          "fn_dec_pos": [
            [
              524,
              12
            ],
            [
              524,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "insert_compute_vloffsets",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "gen_abs_offset_varpart(compiler_state_t *,\n    bpf_abs_offset *)",
          "fn_dec_pos": [
            [
              525,
              21
            ],
            [
              526,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_abs_offset_varpart",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ethertype_to_ppptype(bpf_u_int32)",
          "fn_dec_pos": [
            [
              527,
              19
            ],
            [
              527,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ethertype_to_ppptype",
            "parameters": {},
            "return_type": "bpf_u_int32"
          }
        },
        {
          "fn_code": "gen_linktype(compiler_state_t *, bpf_u_int32)",
          "fn_dec_pos": [
            [
              528,
              21
            ],
            [
              528,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_linktype",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_snap(compiler_state_t *, bpf_u_int32, bpf_u_int32)",
          "fn_dec_pos": [
            [
              529,
              21
            ],
            [
              529,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_snap",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_llc_linktype(compiler_state_t *, bpf_u_int32)",
          "fn_dec_pos": [
            [
              530,
              21
            ],
            [
              530,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_linktype",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_hostop(compiler_state_t *, bpf_u_int32, bpf_u_int32,\n    int, bpf_u_int32, u_int, u_int)",
          "fn_dec_pos": [
            [
              531,
              21
            ],
            [
              532,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_hostop",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_hostop6(compiler_state_t *, struct in6_addr *,\n    struct in6_addr *, int, bpf_u_int32, u_int, u_int)",
          "fn_dec_pos": [
            [
              534,
              21
            ],
            [
              535,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_hostop6",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ahostop(compiler_state_t *, const u_char *, int)",
          "fn_dec_pos": [
            [
              537,
              21
            ],
            [
              537,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ahostop",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ehostop(compiler_state_t *, const u_char *, int)",
          "fn_dec_pos": [
            [
              538,
              21
            ],
            [
              538,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ehostop",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_fhostop(compiler_state_t *, const u_char *, int)",
          "fn_dec_pos": [
            [
              539,
              21
            ],
            [
              539,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_fhostop",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_thostop(compiler_state_t *, const u_char *, int)",
          "fn_dec_pos": [
            [
              540,
              21
            ],
            [
              540,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_thostop",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_wlanhostop(compiler_state_t *, const u_char *, int)",
          "fn_dec_pos": [
            [
              541,
              21
            ],
            [
              541,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_wlanhostop",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ipfchostop(compiler_state_t *, const u_char *, int)",
          "fn_dec_pos": [
            [
              542,
              21
            ],
            [
              542,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ipfchostop",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_dnhostop(compiler_state_t *, bpf_u_int32, int)",
          "fn_dec_pos": [
            [
              543,
              21
            ],
            [
              543,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_dnhostop",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_mpls_linktype(compiler_state_t *, bpf_u_int32)",
          "fn_dec_pos": [
            [
              544,
              21
            ],
            [
              544,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mpls_linktype",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_host(compiler_state_t *, bpf_u_int32, bpf_u_int32,\n    int, int, int)",
          "fn_dec_pos": [
            [
              545,
              21
            ],
            [
              546,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_host",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_host6(compiler_state_t *, struct in6_addr *,\n    struct in6_addr *, int, int, int)",
          "fn_dec_pos": [
            [
              548,
              21
            ],
            [
              549,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_host6",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_gateway(compiler_state_t *, const u_char *,\n    struct addrinfo *, int, int)",
          "fn_dec_pos": [
            [
              552,
              21
            ],
            [
              553,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_gateway",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ipfrag(compiler_state_t *)",
          "fn_dec_pos": [
            [
              555,
              21
            ],
            [
              555,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ipfrag",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portatom(compiler_state_t *, int, bpf_u_int32)",
          "fn_dec_pos": [
            [
              556,
              21
            ],
            [
              556,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portatom",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portrangeatom(compiler_state_t *, u_int, bpf_u_int32,\n    bpf_u_int32)",
          "fn_dec_pos": [
            [
              557,
              21
            ],
            [
              558,
              16
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrangeatom",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portatom6(compiler_state_t *, int, bpf_u_int32)",
          "fn_dec_pos": [
            [
              559,
              21
            ],
            [
              559,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portatom6",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portrangeatom6(compiler_state_t *, u_int, bpf_u_int32,\n    bpf_u_int32)",
          "fn_dec_pos": [
            [
              560,
              21
            ],
            [
              561,
              16
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrangeatom6",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portop(compiler_state_t *, u_int, u_int, int)",
          "fn_dec_pos": [
            [
              562,
              21
            ],
            [
              562,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portop",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_port(compiler_state_t *, u_int, int, int)",
          "fn_dec_pos": [
            [
              563,
              21
            ],
            [
              563,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_port",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portrangeop(compiler_state_t *, u_int, u_int,\n    bpf_u_int32, int)",
          "fn_dec_pos": [
            [
              564,
              21
            ],
            [
              565,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrangeop",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portrange(compiler_state_t *, u_int, u_int, int, int)",
          "fn_dec_pos": [
            [
              566,
              21
            ],
            [
              566,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrange",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portop6(compiler_state_t *, u_int, u_int, int)",
          "fn_dec_pos": [
            [
              567,
              14
            ],
            [
              567,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portop6",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_port6(compiler_state_t *, u_int, int, int)",
          "fn_dec_pos": [
            [
              568,
              21
            ],
            [
              568,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_port6",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portrangeop6(compiler_state_t *, u_int, u_int,\n    bpf_u_int32, int)",
          "fn_dec_pos": [
            [
              569,
              21
            ],
            [
              570,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrangeop6",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portrange6(compiler_state_t *, u_int, u_int, int, int)",
          "fn_dec_pos": [
            [
              571,
              21
            ],
            [
              571,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrange6",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "lookup_proto(compiler_state_t *, const char *, int)",
          "fn_dec_pos": [
            [
              572,
              11
            ],
            [
              572,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lookup_proto",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "gen_protochain(compiler_state_t *, bpf_u_int32, int)",
          "fn_dec_pos": [
            [
              573,
              21
            ],
            [
              573,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_protochain",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_proto(compiler_state_t *, bpf_u_int32, int, int)",
          "fn_dec_pos": [
            [
              574,
              21
            ],
            [
              574,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_proto",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "xfer_to_x(compiler_state_t *, struct arth *)",
          "fn_dec_pos": [
            [
              575,
              21
            ],
            [
              575,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "xfer_to_x",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "xfer_to_a(compiler_state_t *, struct arth *)",
          "fn_dec_pos": [
            [
              576,
              21
            ],
            [
              576,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "xfer_to_a",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_mac_multicast(compiler_state_t *, int)",
          "fn_dec_pos": [
            [
              577,
              21
            ],
            [
              577,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mac_multicast",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_len(compiler_state_t *, int, int)",
          "fn_dec_pos": [
            [
              578,
              21
            ],
            [
              578,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_len",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_check_802_11_data_frame(compiler_state_t *)",
          "fn_dec_pos": [
            [
              579,
              21
            ],
            [
              579,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_check_802_11_data_frame",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_geneve_ll_check(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              580,
              21
            ],
            [
              580,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_geneve_ll_check",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ppi_dlt_check(compiler_state_t *)",
          "fn_dec_pos": [
            [
              582,
              21
            ],
            [
              582,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ppi_dlt_check",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_atmfield_code_internal(compiler_state_t *, int,\n    bpf_u_int32, int, int)",
          "fn_dec_pos": [
            [
              583,
              21
            ],
            [
              584,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmfield_code_internal",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_atmtype_llc(compiler_state_t *)",
          "fn_dec_pos": [
            [
              585,
              21
            ],
            [
              585,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmtype_llc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_msg_abbrev(compiler_state_t *, int type)",
          "fn_dec_pos": [
            [
              586,
              21
            ],
            [
              586,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_msg_abbrev",
            "parameters": {
              "type": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "newchunk_nolongjmp(compiler_state_t *cstate, size_t n)",
          "fn_dec_pos": [
            [
              601,
              0
            ],
            [
              601,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "newchunk_nolongjmp",
            "parameters": {
              "cstate": "compiler_state_t",
              "n": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "newchunk(compiler_state_t *cstate, size_t n)",
          "fn_dec_pos": [
            [
              641,
              0
            ],
            [
              641,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "newchunk",
            "parameters": {
              "cstate": "compiler_state_t",
              "n": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "sdup(compiler_state_t *cstate, const char *s)",
          "fn_dec_pos": [
            [
              670,
              0
            ],
            [
              670,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sdup",
            "parameters": {
              "cstate": "compiler_state_t",
              "s": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "new_block(compiler_state_t *cstate, int code)",
          "fn_dec_pos": [
            [
              682,
              0
            ],
            [
              682,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "new_block",
            "parameters": {
              "cstate": "compiler_state_t",
              "code": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "new_stmt(compiler_state_t *cstate, int code)",
          "fn_dec_pos": [
            [
              694,
              0
            ],
            [
              694,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "new_stmt",
            "parameters": {
              "cstate": "compiler_state_t",
              "code": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_retblk(compiler_state_t *cstate, int v)",
          "fn_dec_pos": [
            [
              705,
              0
            ],
            [
              705,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_retblk",
            "parameters": {
              "cstate": "compiler_state_t",
              "v": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_cmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v)",
          "fn_dec_pos": [
            [
              1030,
              0
            ],
            [
              1031,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_cmp",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int",
              "v": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_cmp_gt(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v)",
          "fn_dec_pos": [
            [
              1037,
              0
            ],
            [
              1038,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_cmp_gt",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int",
              "v": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_cmp_ge(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v)",
          "fn_dec_pos": [
            [
              1044,
              0
            ],
            [
              1045,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_cmp_ge",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int",
              "v": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_cmp_lt(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v)",
          "fn_dec_pos": [
            [
              1051,
              0
            ],
            [
              1052,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_cmp_lt",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int",
              "v": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_cmp_le(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v)",
          "fn_dec_pos": [
            [
              1058,
              0
            ],
            [
              1059,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_cmp_le",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int",
              "v": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_mcmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 v, bpf_u_int32 mask)",
          "fn_dec_pos": [
            [
              1065,
              0
            ],
            [
              1066,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mcmp",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int",
              "v": "bpf_u_int32",
              "mask": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_bcmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, const u_char *v)",
          "fn_dec_pos": [
            [
              1072,
              0
            ],
            [
              1073,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_bcmp",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int",
              "v": "u_char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ncmp(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size, bpf_u_int32 mask, int jtype, int reverse,\n    bpf_u_int32 v)",
          "fn_dec_pos": [
            [
              1114,
              0
            ],
            [
              1116,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ncmp",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int",
              "mask": "bpf_u_int32",
              "jtype": "int",
              "reverse": "int",
              "v": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_load_absoffsetrel(compiler_state_t *cstate, bpf_abs_offset *abs_offset,\n    u_int offset, u_int size)",
          "fn_dec_pos": [
            [
              1735,
              0
            ],
            [
              1736,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_absoffsetrel",
            "parameters": {
              "cstate": "compiler_state_t",
              "abs_offset": "bpf_abs_offset",
              "offset": "u_int",
              "size": "u_int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_load_a(compiler_state_t *cstate, enum e_offrel offrel, u_int offset,\n    u_int size)",
          "fn_dec_pos": [
            [
              1775,
              0
            ],
            [
              1776,
              15
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_a",
            "parameters": {
              "cstate": "compiler_state_t",
              "offrel": "enum e_offrel",
              "offset": "u_int",
              "size": "u_int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_loadx_iphdrlen(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              1866,
              0
            ],
            [
              1866,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_loadx_iphdrlen",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_uncond(compiler_state_t *cstate, int rsense)",
          "fn_dec_pos": [
            [
              1921,
              0
            ],
            [
              1921,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_uncond",
            "parameters": {
              "cstate": "compiler_state_t",
              "rsense": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_true(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              1935,
              0
            ],
            [
              1935,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_true",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_false(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              1941,
              0
            ],
            [
              1941,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_false",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ether_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)",
          "fn_dec_pos": [
            [
              1964,
              0
            ],
            [
              1964,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ether_linktype",
            "parameters": {
              "cstate": "compiler_state_t",
              "ll_proto": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_loopback_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)",
          "fn_dec_pos": [
            [
              2132,
              0
            ],
            [
              2132,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_loopback_linktype",
            "parameters": {
              "cstate": "compiler_state_t",
              "ll_proto": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ipnet_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)",
          "fn_dec_pos": [
            [
              2171,
              0
            ],
            [
              2171,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ipnet_linktype",
            "parameters": {
              "cstate": "compiler_state_t",
              "ll_proto": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_linux_sll_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)",
          "fn_dec_pos": [
            [
              2199,
              0
            ],
            [
              2199,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_linux_sll_linktype",
            "parameters": {
              "cstate": "compiler_state_t",
              "ll_proto": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_load_prism_llprefixlen(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              2344,
              0
            ],
            [
              2344,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_prism_llprefixlen",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_load_avs_llprefixlen(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              2454,
              0
            ],
            [
              2454,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_avs_llprefixlen",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_load_radiotap_llprefixlen(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              2494,
              0
            ],
            [
              2494,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_radiotap_llprefixlen",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_load_ppi_llprefixlen(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              2564,
              0
            ],
            [
              2564,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_ppi_llprefixlen",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_load_802_11_header_len(compiler_state_t *cstate, struct slist *s, struct slist *snext)",
          "fn_dec_pos": [
            [
              2630,
              0
            ],
            [
              2630,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_802_11_header_len",
            "parameters": {
              "cstate": "compiler_state_t",
              "s": "struct slist",
              "snext": "struct slist"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ppi_dlt_check(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              2967,
              0
            ],
            [
              2967,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ppi_dlt_check",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_abs_offset_varpart(compiler_state_t *cstate, bpf_abs_offset *off)",
          "fn_dec_pos": [
            [
              3006,
              0
            ],
            [
              3006,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_abs_offset_varpart",
            "parameters": {
              "cstate": "compiler_state_t",
              "off": "bpf_abs_offset"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_prevlinkhdr_check(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              3091,
              0
            ],
            [
              3091,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_prevlinkhdr_check",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)",
          "fn_dec_pos": [
            [
              3137,
              0
            ],
            [
              3137,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_linktype",
            "parameters": {
              "cstate": "compiler_state_t",
              "ll_proto": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_snap(compiler_state_t *cstate, bpf_u_int32 orgcode, bpf_u_int32 ptype)",
          "fn_dec_pos": [
            [
              3647,
              0
            ],
            [
              3647,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_snap",
            "parameters": {
              "cstate": "compiler_state_t",
              "orgcode": "bpf_u_int32",
              "ptype": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_llc_internal(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              3666,
              0
            ],
            [
              3666,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_internal",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_llc(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              3737,
              0
            ],
            [
              3737,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_llc_i(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              3750,
              0
            ],
            [
              3750,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_i",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_llc_s(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              3781,
              0
            ],
            [
              3781,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_s",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_llc_u(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              3807,
              0
            ],
            [
              3807,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_u",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_llc_s_subtype(compiler_state_t *cstate, bpf_u_int32 subtype)",
          "fn_dec_pos": [
            [
              3833,
              0
            ],
            [
              3833,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_s_subtype",
            "parameters": {
              "cstate": "compiler_state_t",
              "subtype": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_llc_u_subtype(compiler_state_t *cstate, bpf_u_int32 subtype)",
          "fn_dec_pos": [
            [
              3858,
              0
            ],
            [
              3858,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_u_subtype",
            "parameters": {
              "cstate": "compiler_state_t",
              "subtype": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_llc_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)",
          "fn_dec_pos": [
            [
              3895,
              0
            ],
            [
              3895,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_linktype",
            "parameters": {
              "cstate": "compiler_state_t",
              "ll_proto": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_hostop(compiler_state_t *cstate, bpf_u_int32 addr, bpf_u_int32 mask,\n    int dir, bpf_u_int32 ll_proto, u_int src_off, u_int dst_off)",
          "fn_dec_pos": [
            [
              3969,
              0
            ],
            [
              3970,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_hostop",
            "parameters": {
              "cstate": "compiler_state_t",
              "addr": "bpf_u_int32",
              "mask": "bpf_u_int32",
              "dir": "int",
              "ll_proto": "bpf_u_int32",
              "src_off": "u_int",
              "dst_off": "u_int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_hostop6(compiler_state_t *cstate, struct in6_addr *addr,\n    struct in6_addr *mask, int dir, bpf_u_int32 ll_proto, u_int src_off,\n    u_int dst_off)",
          "fn_dec_pos": [
            [
              4034,
              0
            ],
            [
              4036,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_hostop6",
            "parameters": {
              "cstate": "compiler_state_t",
              "addr": "struct in6_addr",
              "mask": "struct in6_addr",
              "dir": "int",
              "ll_proto": "bpf_u_int32",
              "src_off": "u_int",
              "dst_off": "u_int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ehostop(compiler_state_t *cstate, const u_char *eaddr, int dir)",
          "fn_dec_pos": [
            [
              4110,
              0
            ],
            [
              4110,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ehostop",
            "parameters": {
              "cstate": "compiler_state_t",
              "eaddr": "u_char",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_fhostop(compiler_state_t *cstate, const u_char *eaddr, int dir)",
          "fn_dec_pos": [
            [
              4166,
              0
            ],
            [
              4166,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_fhostop",
            "parameters": {
              "cstate": "compiler_state_t",
              "eaddr": "u_char",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_thostop(compiler_state_t *cstate, const u_char *eaddr, int dir)",
          "fn_dec_pos": [
            [
              4222,
              0
            ],
            [
              4222,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_thostop",
            "parameters": {
              "cstate": "compiler_state_t",
              "eaddr": "u_char",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_wlanhostop(compiler_state_t *cstate, const u_char *eaddr, int dir)",
          "fn_dec_pos": [
            [
              4279,
              0
            ],
            [
              4279,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_wlanhostop",
            "parameters": {
              "cstate": "compiler_state_t",
              "eaddr": "u_char",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ipfchostop(compiler_state_t *cstate, const u_char *eaddr, int dir)",
          "fn_dec_pos": [
            [
              4703,
              0
            ],
            [
              4703,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ipfchostop",
            "parameters": {
              "cstate": "compiler_state_t",
              "eaddr": "u_char",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_dnhostop(compiler_state_t *cstate, bpf_u_int32 addr, int dir)",
          "fn_dec_pos": [
            [
              4774,
              0
            ],
            [
              4774,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_dnhostop",
            "parameters": {
              "cstate": "compiler_state_t",
              "addr": "bpf_u_int32",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_mpls_linktype(compiler_state_t *cstate, bpf_u_int32 ll_proto)",
          "fn_dec_pos": [
            [
              4875,
              0
            ],
            [
              4875,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mpls_linktype",
            "parameters": {
              "cstate": "compiler_state_t",
              "ll_proto": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_host(compiler_state_t *cstate, bpf_u_int32 addr, bpf_u_int32 mask,\n    int proto, int dir, int type)",
          "fn_dec_pos": [
            [
              4905,
              0
            ],
            [
              4906,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_host",
            "parameters": {
              "cstate": "compiler_state_t",
              "addr": "bpf_u_int32",
              "mask": "bpf_u_int32",
              "proto": "int",
              "dir": "int",
              "type": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_host6(compiler_state_t *cstate, struct in6_addr *addr,\n    struct in6_addr *mask, int proto, int dir, int type)",
          "fn_dec_pos": [
            [
              5057,
              0
            ],
            [
              5058,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_host6",
            "parameters": {
              "cstate": "compiler_state_t",
              "addr": "struct in6_addr",
              "mask": "struct in6_addr",
              "proto": "int",
              "dir": "int",
              "type": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_gateway(compiler_state_t *cstate, const u_char *eaddr,\n    struct addrinfo *alist, int proto, int dir)",
          "fn_dec_pos": [
            [
              5198,
              0
            ],
            [
              5199,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_gateway",
            "parameters": {
              "cstate": "compiler_state_t",
              "eaddr": "u_char",
              "alist": "struct addrinfo",
              "proto": "int",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_proto_abbrev_internal(compiler_state_t *cstate, int proto)",
          "fn_dec_pos": [
            [
              5304,
              0
            ],
            [
              5304,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_proto_abbrev_internal",
            "parameters": {
              "cstate": "compiler_state_t",
              "proto": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_proto_abbrev(compiler_state_t *cstate, int proto)",
          "fn_dec_pos": [
            [
              5544,
              0
            ],
            [
              5544,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_proto_abbrev",
            "parameters": {
              "cstate": "compiler_state_t",
              "proto": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ipfrag(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              5557,
              0
            ],
            [
              5557,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ipfrag",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portatom(compiler_state_t *cstate, int off, bpf_u_int32 v)",
          "fn_dec_pos": [
            [
              5582,
              0
            ],
            [
              5582,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portatom",
            "parameters": {
              "cstate": "compiler_state_t",
              "off": "int",
              "v": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portatom6(compiler_state_t *cstate, int off, bpf_u_int32 v)",
          "fn_dec_pos": [
            [
              5588,
              0
            ],
            [
              5588,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portatom6",
            "parameters": {
              "cstate": "compiler_state_t",
              "off": "int",
              "v": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portop(compiler_state_t *cstate, u_int port, u_int proto, int dir)",
          "fn_dec_pos": [
            [
              5594,
              0
            ],
            [
              5594,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portop",
            "parameters": {
              "cstate": "compiler_state_t",
              "port": "u_int",
              "proto": "u_int",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_port(compiler_state_t *cstate, u_int port, int ip_proto, int dir)",
          "fn_dec_pos": [
            [
              5659,
              0
            ],
            [
              5659,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_port",
            "parameters": {
              "cstate": "compiler_state_t",
              "port": "u_int",
              "ip_proto": "int",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portop6(compiler_state_t *cstate, u_int port, u_int proto, int dir)",
          "fn_dec_pos": [
            [
              5705,
              0
            ],
            [
              5705,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portop6",
            "parameters": {
              "cstate": "compiler_state_t",
              "port": "u_int",
              "proto": "u_int",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_port6(compiler_state_t *cstate, u_int port, int ip_proto, int dir)",
          "fn_dec_pos": [
            [
              5744,
              0
            ],
            [
              5744,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_port6",
            "parameters": {
              "cstate": "compiler_state_t",
              "port": "u_int",
              "ip_proto": "int",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portrangeatom(compiler_state_t *cstate, u_int off, bpf_u_int32 v1,\n    bpf_u_int32 v2)",
          "fn_dec_pos": [
            [
              5775,
              0
            ],
            [
              5776,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrangeatom",
            "parameters": {
              "cstate": "compiler_state_t",
              "off": "u_int",
              "v1": "bpf_u_int32",
              "v2": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portrangeop(compiler_state_t *cstate, u_int port1, u_int port2,\n    bpf_u_int32 proto, int dir)",
          "fn_dec_pos": [
            [
              5800,
              0
            ],
            [
              5801,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrangeop",
            "parameters": {
              "cstate": "compiler_state_t",
              "port1": "u_int",
              "port2": "u_int",
              "proto": "bpf_u_int32",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portrange(compiler_state_t *cstate, u_int port1, u_int port2, int ip_proto,\n    int dir)",
          "fn_dec_pos": [
            [
              5866,
              0
            ],
            [
              5867,
              12
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrange",
            "parameters": {
              "cstate": "compiler_state_t",
              "port1": "u_int",
              "port2": "u_int",
              "ip_proto": "int",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portrangeatom6(compiler_state_t *cstate, u_int off, bpf_u_int32 v1,\n    bpf_u_int32 v2)",
          "fn_dec_pos": [
            [
              5898,
              0
            ],
            [
              5899,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrangeatom6",
            "parameters": {
              "cstate": "compiler_state_t",
              "off": "u_int",
              "v1": "bpf_u_int32",
              "v2": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portrangeop6(compiler_state_t *cstate, u_int port1, u_int port2,\n    bpf_u_int32 proto, int dir)",
          "fn_dec_pos": [
            [
              5923,
              0
            ],
            [
              5924,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrangeop6",
            "parameters": {
              "cstate": "compiler_state_t",
              "port1": "u_int",
              "port2": "u_int",
              "proto": "bpf_u_int32",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_portrange6(compiler_state_t *cstate, u_int port1, u_int port2, int ip_proto,\n    int dir)",
          "fn_dec_pos": [
            [
              5963,
              0
            ],
            [
              5964,
              12
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_portrange6",
            "parameters": {
              "cstate": "compiler_state_t",
              "port1": "u_int",
              "port2": "u_int",
              "ip_proto": "int",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_joinsp(struct stmt **s, int n)",
          "fn_dec_pos": [
            [
              6039,
              0
            ],
            [
              6039,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_joinsp",
            "parameters": {
              "s": "struct stmt",
              "n": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_protochain(compiler_state_t *cstate, bpf_u_int32 v, int proto)",
          "fn_dec_pos": [
            [
              6046,
              0
            ],
            [
              6046,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_protochain",
            "parameters": {
              "cstate": "compiler_state_t",
              "v": "bpf_u_int32",
              "proto": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_check_802_11_data_frame(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              6337,
              0
            ],
            [
              6337,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_check_802_11_data_frame",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_proto(compiler_state_t *cstate, bpf_u_int32 v, int proto, int dir)",
          "fn_dec_pos": [
            [
              6372,
              0
            ],
            [
              6372,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_proto",
            "parameters": {
              "cstate": "compiler_state_t",
              "v": "bpf_u_int32",
              "proto": "int",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_scode(compiler_state_t *cstate, const char *name, struct qual q)",
          "fn_dec_pos": [
            [
              6632,
              0
            ],
            [
              6632,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_scode",
            "parameters": {
              "cstate": "compiler_state_t",
              "name": "char",
              "q": "struct qual"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_mcode(compiler_state_t *cstate, const char *s1, const char *s2,\n    bpf_u_int32 masklen, struct qual q)",
          "fn_dec_pos": [
            [
              6942,
              0
            ],
            [
              6943,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mcode",
            "parameters": {
              "cstate": "compiler_state_t",
              "s1": "char",
              "s2": "char",
              "masklen": "bpf_u_int32",
              "q": "struct qual"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ncode(compiler_state_t *cstate, const char *s, bpf_u_int32 v, struct qual q)",
          "fn_dec_pos": [
            [
              6996,
              0
            ],
            [
              6996,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ncode",
            "parameters": {
              "cstate": "compiler_state_t",
              "s": "char",
              "v": "bpf_u_int32",
              "q": "struct qual"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_mcode6(compiler_state_t *cstate, const char *s1, const char *s2,\n    bpf_u_int32 masklen, struct qual q)",
          "fn_dec_pos": [
            [
              7113,
              0
            ],
            [
              7114,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mcode6",
            "parameters": {
              "cstate": "compiler_state_t",
              "s1": "char",
              "s2": "char",
              "masklen": "bpf_u_int32",
              "q": "struct qual"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ecode(compiler_state_t *cstate, const char *s, struct qual q)",
          "fn_dec_pos": [
            [
              7178,
              0
            ],
            [
              7178,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ecode",
            "parameters": {
              "cstate": "compiler_state_t",
              "s": "char",
              "q": "struct qual"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "xfer_to_x(compiler_state_t *cstate, struct arth *a)",
          "fn_dec_pos": [
            [
              7245,
              0
            ],
            [
              7245,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "xfer_to_x",
            "parameters": {
              "cstate": "compiler_state_t",
              "a": "struct arth"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "xfer_to_a(compiler_state_t *cstate, struct arth *a)",
          "fn_dec_pos": [
            [
              7255,
              0
            ],
            [
              7255,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "xfer_to_a",
            "parameters": {
              "cstate": "compiler_state_t",
              "a": "struct arth"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_load_internal(compiler_state_t *cstate, int proto, struct arth *inst,\n    bpf_u_int32 size)",
          "fn_dec_pos": [
            [
              7272,
              0
            ],
            [
              7273,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load_internal",
            "parameters": {
              "cstate": "compiler_state_t",
              "proto": "int",
              "inst": "struct arth",
              "size": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_load(compiler_state_t *cstate, int proto, struct arth *inst,\n    bpf_u_int32 size)",
          "fn_dec_pos": [
            [
              7548,
              0
            ],
            [
              7549,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load",
            "parameters": {
              "cstate": "compiler_state_t",
              "proto": "int",
              "inst": "struct arth",
              "size": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_relation_internal(compiler_state_t *cstate, int code, struct arth *a0,\n    struct arth *a1, int reversed)",
          "fn_dec_pos": [
            [
              7562,
              0
            ],
            [
              7563,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_relation_internal",
            "parameters": {
              "cstate": "compiler_state_t",
              "code": "int",
              "a0": "struct arth",
              "a1": "struct arth",
              "reversed": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_relation(compiler_state_t *cstate, int code, struct arth *a0,\n    struct arth *a1, int reversed)",
          "fn_dec_pos": [
            [
              7606,
              0
            ],
            [
              7607,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_relation",
            "parameters": {
              "cstate": "compiler_state_t",
              "code": "int",
              "a0": "struct arth",
              "a1": "struct arth",
              "reversed": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_loadlen(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              7620,
              0
            ],
            [
              7620,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_loadlen",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_loadi_internal(compiler_state_t *cstate, bpf_u_int32 val)",
          "fn_dec_pos": [
            [
              7645,
              0
            ],
            [
              7645,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_loadi_internal",
            "parameters": {
              "cstate": "compiler_state_t",
              "val": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_loadi(compiler_state_t *cstate, bpf_u_int32 val)",
          "fn_dec_pos": [
            [
              7666,
              0
            ],
            [
              7666,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_loadi",
            "parameters": {
              "cstate": "compiler_state_t",
              "val": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_neg(compiler_state_t *cstate, struct arth *a_arg)",
          "fn_dec_pos": [
            [
              7684,
              0
            ],
            [
              7684,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_neg",
            "parameters": {
              "cstate": "compiler_state_t",
              "a_arg": "struct arth"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_arth(compiler_state_t *cstate, int code, struct arth *a0_arg,\n    struct arth *a1)",
          "fn_dec_pos": [
            [
              7714,
              0
            ],
            [
              7715,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_arth",
            "parameters": {
              "cstate": "compiler_state_t",
              "code": "int",
              "a0_arg": "struct arth",
              "a1": "struct arth"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_len(compiler_state_t *cstate, int jmp, int n)",
          "fn_dec_pos": [
            [
              7804,
              0
            ],
            [
              7804,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_len",
            "parameters": {
              "cstate": "compiler_state_t",
              "jmp": "int",
              "n": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_greater(compiler_state_t *cstate, int n)",
          "fn_dec_pos": [
            [
              7818,
              0
            ],
            [
              7818,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_greater",
            "parameters": {
              "cstate": "compiler_state_t",
              "n": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_less(compiler_state_t *cstate, int n)",
          "fn_dec_pos": [
            [
              7834,
              0
            ],
            [
              7834,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_less",
            "parameters": {
              "cstate": "compiler_state_t",
              "n": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_byteop(compiler_state_t *cstate, int op, int idx, bpf_u_int32 val)",
          "fn_dec_pos": [
            [
              7862,
              0
            ],
            [
              7862,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_byteop",
            "parameters": {
              "cstate": "compiler_state_t",
              "op": "int",
              "idx": "int",
              "val": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_broadcast(compiler_state_t *cstate, int proto)",
          "fn_dec_pos": [
            [
              7908,
              0
            ],
            [
              7908,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_broadcast",
            "parameters": {
              "cstate": "compiler_state_t",
              "proto": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_mac_multicast(compiler_state_t *cstate, int offset)",
          "fn_dec_pos": [
            [
              7980,
              0
            ],
            [
              7980,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mac_multicast",
            "parameters": {
              "cstate": "compiler_state_t",
              "offset": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_multicast(compiler_state_t *cstate, int proto)",
          "fn_dec_pos": [
            [
              7994,
              0
            ],
            [
              7994,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_multicast",
            "parameters": {
              "cstate": "compiler_state_t",
              "proto": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_inbound(compiler_state_t *cstate, int dir)",
          "fn_dec_pos": [
            [
              8187,
              0
            ],
            [
              8187,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_inbound",
            "parameters": {
              "cstate": "compiler_state_t",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_ifname(compiler_state_t *cstate, const char *ifname)",
          "fn_dec_pos": [
            [
              8337,
              0
            ],
            [
              8337,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_ifname",
            "parameters": {
              "cstate": "compiler_state_t",
              "ifname": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_ruleset(compiler_state_t *cstate, char *ruleset)",
          "fn_dec_pos": [
            [
              8367,
              0
            ],
            [
              8367,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_ruleset",
            "parameters": {
              "cstate": "compiler_state_t",
              "ruleset": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_rnr(compiler_state_t *cstate, int rnr)",
          "fn_dec_pos": [
            [
              8396,
              0
            ],
            [
              8396,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_rnr",
            "parameters": {
              "cstate": "compiler_state_t",
              "rnr": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_srnr(compiler_state_t *cstate, int srnr)",
          "fn_dec_pos": [
            [
              8419,
              0
            ],
            [
              8419,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_srnr",
            "parameters": {
              "cstate": "compiler_state_t",
              "srnr": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_reason(compiler_state_t *cstate, int reason)",
          "fn_dec_pos": [
            [
              8442,
              0
            ],
            [
              8442,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_reason",
            "parameters": {
              "cstate": "compiler_state_t",
              "reason": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_action(compiler_state_t *cstate, int action)",
          "fn_dec_pos": [
            [
              8465,
              0
            ],
            [
              8465,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_action",
            "parameters": {
              "cstate": "compiler_state_t",
              "action": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_ifname(compiler_state_t *cstate, const char *ifname _U_)",
          "fn_dec_pos": [
            [
              8487,
              0
            ],
            [
              8487,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_ifname",
            "parameters": {
              "cstate": "compiler_state_t",
              "ifname": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_ruleset(compiler_state_t *cstate, char *ruleset _U_)",
          "fn_dec_pos": [
            [
              8501,
              0
            ],
            [
              8501,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_ruleset",
            "parameters": {
              "cstate": "compiler_state_t",
              "ruleset": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_rnr(compiler_state_t *cstate, int rnr _U_)",
          "fn_dec_pos": [
            [
              8515,
              0
            ],
            [
              8515,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_rnr",
            "parameters": {
              "cstate": "compiler_state_t",
              "rnr": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_srnr(compiler_state_t *cstate, int srnr _U_)",
          "fn_dec_pos": [
            [
              8529,
              0
            ],
            [
              8529,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_srnr",
            "parameters": {
              "cstate": "compiler_state_t",
              "srnr": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_reason(compiler_state_t *cstate, int reason _U_)",
          "fn_dec_pos": [
            [
              8543,
              0
            ],
            [
              8543,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_reason",
            "parameters": {
              "cstate": "compiler_state_t",
              "reason": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_action(compiler_state_t *cstate, int action _U_)",
          "fn_dec_pos": [
            [
              8557,
              0
            ],
            [
              8557,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_action",
            "parameters": {
              "cstate": "compiler_state_t",
              "action": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_p80211_type(compiler_state_t *cstate, bpf_u_int32 type, bpf_u_int32 mask)",
          "fn_dec_pos": [
            [
              8573,
              0
            ],
            [
              8573,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_p80211_type",
            "parameters": {
              "cstate": "compiler_state_t",
              "type": "bpf_u_int32",
              "mask": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_p80211_fcdir(compiler_state_t *cstate, bpf_u_int32 fcdir)",
          "fn_dec_pos": [
            [
              8602,
              0
            ],
            [
              8602,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_p80211_fcdir",
            "parameters": {
              "cstate": "compiler_state_t",
              "fcdir": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_acode(compiler_state_t *cstate, const char *s, struct qual q)",
          "fn_dec_pos": [
            [
              8633,
              0
            ],
            [
              8633,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_acode",
            "parameters": {
              "cstate": "compiler_state_t",
              "s": "char",
              "q": "struct qual"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ahostop(compiler_state_t *cstate, const u_char *eaddr, int dir)",
          "fn_dec_pos": [
            [
              8668,
              0
            ],
            [
              8668,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ahostop",
            "parameters": {
              "cstate": "compiler_state_t",
              "eaddr": "u_char",
              "dir": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_vlan_tpid_test(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              8722,
              0
            ],
            [
              8722,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_vlan_tpid_test",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_vlan_vid_test(compiler_state_t *cstate, bpf_u_int32 vlan_num)",
          "fn_dec_pos": [
            [
              8738,
              0
            ],
            [
              8738,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_vlan_vid_test",
            "parameters": {
              "cstate": "compiler_state_t",
              "vlan_num": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_vlan_no_bpf_extensions(compiler_state_t *cstate, bpf_u_int32 vlan_num,\n    int has_vlan_tag)",
          "fn_dec_pos": [
            [
              8748,
              0
            ],
            [
              8749,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_vlan_no_bpf_extensions",
            "parameters": {
              "cstate": "compiler_state_t",
              "vlan_num": "bpf_u_int32",
              "has_vlan_tag": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_vlan_bpf_extensions(compiler_state_t *cstate, bpf_u_int32 vlan_num,\n    int has_vlan_tag)",
          "fn_dec_pos": [
            [
              8864,
              0
            ],
            [
              8865,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_vlan_bpf_extensions",
            "parameters": {
              "cstate": "compiler_state_t",
              "vlan_num": "bpf_u_int32",
              "has_vlan_tag": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_vlan(compiler_state_t *cstate, bpf_u_int32 vlan_num, int has_vlan_tag)",
          "fn_dec_pos": [
            [
              8911,
              0
            ],
            [
              8911,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_vlan",
            "parameters": {
              "cstate": "compiler_state_t",
              "vlan_num": "bpf_u_int32",
              "has_vlan_tag": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_mpls(compiler_state_t *cstate, bpf_u_int32 label_num_arg,\n    int has_label_num)",
          "fn_dec_pos": [
            [
              9009,
              0
            ],
            [
              9010,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mpls",
            "parameters": {
              "cstate": "compiler_state_t",
              "label_num_arg": "bpf_u_int32",
              "has_label_num": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pppoed(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              9091,
              0
            ],
            [
              9091,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pppoed",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pppoes(compiler_state_t *cstate, bpf_u_int32 sess_num, int has_sess_num)",
          "fn_dec_pos": [
            [
              9105,
              0
            ],
            [
              9105,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pppoes",
            "parameters": {
              "cstate": "compiler_state_t",
              "sess_num": "bpf_u_int32",
              "has_sess_num": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_geneve_check(compiler_state_t *cstate,\n    struct block *(*gen_portfn)(compiler_state_t *, u_int, int, int),\n    enum e_offrel offrel, bpf_u_int32 vni, int has_vni)",
          "fn_dec_pos": [
            [
              9187,
              0
            ],
            [
              9189,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_geneve_check",
            "parameters": {
              "cstate": "compiler_state_t",
              "gen_portfn": "struct block",
              "offrel": "enum e_offrel",
              "vni": "bpf_u_int32",
              "has_vni": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*gen_portfn)(compiler_state_t *, u_int, int, int)",
          "fn_dec_pos": [
            [
              9188,
              18
            ],
            [
              9188,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_geneve4(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)",
          "fn_dec_pos": [
            [
              9222,
              0
            ],
            [
              9222,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_geneve4",
            "parameters": {
              "cstate": "compiler_state_t",
              "vni": "bpf_u_int32",
              "has_vni": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_geneve6(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)",
          "fn_dec_pos": [
            [
              9248,
              0
            ],
            [
              9248,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_geneve6",
            "parameters": {
              "cstate": "compiler_state_t",
              "vni": "bpf_u_int32",
              "has_vni": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_geneve_offsets(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              9291,
              0
            ],
            [
              9291,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_geneve_offsets",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_geneve(compiler_state_t *cstate, bpf_u_int32 vni, int has_vni)",
          "fn_dec_pos": [
            [
              9426,
              0
            ],
            [
              9426,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_geneve",
            "parameters": {
              "cstate": "compiler_state_t",
              "vni": "bpf_u_int32",
              "has_vni": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_geneve_ll_check(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              9463,
              0
            ],
            [
              9463,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_geneve_ll_check",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_atmfield_code_internal(compiler_state_t *cstate, int atmfield,\n    bpf_u_int32 jvalue, int jtype, int reverse)",
          "fn_dec_pos": [
            [
              9490,
              0
            ],
            [
              9491,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmfield_code_internal",
            "parameters": {
              "cstate": "compiler_state_t",
              "atmfield": "int",
              "jvalue": "bpf_u_int32",
              "jtype": "int",
              "reverse": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_atmtype_metac(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              9545,
              0
            ],
            [
              9545,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmtype_metac",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_atmtype_sc(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              9556,
              0
            ],
            [
              9556,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmtype_sc",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_atmtype_llc(compiler_state_t *cstate)",
          "fn_dec_pos": [
            [
              9567,
              0
            ],
            [
              9567,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmtype_llc",
            "parameters": {
              "cstate": "compiler_state_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_atmfield_code(compiler_state_t *cstate, int atmfield,\n    bpf_u_int32 jvalue, int jtype, int reverse)",
          "fn_dec_pos": [
            [
              9577,
              0
            ],
            [
              9578,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmfield_code",
            "parameters": {
              "cstate": "compiler_state_t",
              "atmfield": "int",
              "jvalue": "bpf_u_int32",
              "jtype": "int",
              "reverse": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_atmtype_abbrev(compiler_state_t *cstate, int type)",
          "fn_dec_pos": [
            [
              9592,
              0
            ],
            [
              9592,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmtype_abbrev",
            "parameters": {
              "cstate": "compiler_state_t",
              "type": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_mtp2type_abbrev(compiler_state_t *cstate, int type)",
          "fn_dec_pos": [
            [
              9699,
              0
            ],
            [
              9699,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mtp2type_abbrev",
            "parameters": {
              "cstate": "compiler_state_t",
              "type": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_mtp3field_code(compiler_state_t *cstate, int mtp3field,\n    bpf_u_int32 jvalue_arg, int jtype, int reverse)",
          "fn_dec_pos": [
            [
              9786,
              0
            ],
            [
              9787,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mtp3field_code",
            "parameters": {
              "cstate": "compiler_state_t",
              "mtp3field": "int",
              "jvalue_arg": "bpf_u_int32",
              "jtype": "int",
              "reverse": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_msg_abbrev(compiler_state_t *cstate, int type)",
          "fn_dec_pos": [
            [
              9896,
              0
            ],
            [
              9896,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_msg_abbrev",
            "parameters": {
              "cstate": "compiler_state_t",
              "type": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gen_atmmulti_abbrev(compiler_state_t *cstate, int type)",
          "fn_dec_pos": [
            [
              9937,
              0
            ],
            [
              9937,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmmulti_abbrev",
            "parameters": {
              "cstate": "compiler_state_t",
              "type": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct in6_addr\n  {\n    union\n      {\n\tuint8_t\t\tu6_addr8[16];\n\tuint16_t\tu6_addr16[8];\n\tuint32_t\tu6_addr32[4];\n      } in6_u;\n#define s6_addr\t\t\tin6_u.u6_addr8\n#define s6_addr16\t\tin6_u.u6_addr16\n#define s6_addr32\t\tin6_u.u6_addr32\n#define s6_addr64\t\tin6_u.u6_addr64\n  }",
          {
            "in6_u": "union\n      {\n\tuint8_t\t\tu6_addr8[16];\n\tuint16_t\tu6_addr16[8];\n\tuint32_t\tu6_addr32[4];\n      }",
            "u6_addr8[16]": "uint8_t",
            "u6_addr16[8]": "uint16_t",
            "u6_addr32[4]": "uint32_t"
          },
          "in6_addr",
          [
            90,
            0
          ],
          [
            102,
            3
          ]
        ],
        [
          "struct sockaddr_in6\n  {\n    __SOCKADDR_COMMON (sin6_);\n    uint16_t sin6_port;\t\t/* Transport layer port # */\n    uint32_t sin6_flowinfo;\t/* IPv6 flow information */\n    struct in6_addr sin6_addr;\t/* IPv6 address */\n  }",
          {
            "sin6_port": "uint16_t",
            "sin6_flowinfo": "uint32_t",
            "sin6_addr": "struct in6_addr"
          },
          "sockaddr_in6",
          [
            110,
            0
          ],
          [
            116,
            3
          ]
        ],
        [
          "struct addrinfo {\n\tint\tai_flags;\t/* AI_PASSIVE, AI_CANONNAME */\n\tint\tai_family;\t/* PF_xxx */\n\tint\tai_socktype;\t/* SOCK_xxx */\n\tint\tai_protocol;\t/* 0 or IPPROTO_xxx for IPv4 and IPv6 */\n\tsize_t\tai_addrlen;\t/* length of ai_addr */\n\tchar\t*ai_canonname;\t/* canonical name for hostname */\n\tstruct sockaddr *ai_addr;\t/* binary address */\n\tstruct addrinfo *ai_next;\t/* next structure in linked list */\n}",
          {
            "ai_flags": "int",
            "ai_family": "int",
            "ai_socktype": "int",
            "ai_protocol": "int",
            "ai_addrlen": "size_t",
            "*ai_canonname": "char",
            "*ai_addr": "struct sockaddr",
            "*ai_next": "struct addrinfo"
          },
          "addrinfo",
          [
            119,
            0
          ],
          [
            128,
            1
          ]
        ],
        [
          "typedef struct {\n\tint\tis_variable;\n\tu_int\tconstant_part;\n\tint\treg;\n} bpf_abs_offset;",
          {
            "is_variable": "int",
            "constant_part": "u_int",
            "reg": "int"
          },
          "bpf_abs_offset",
          [
            207,
            0
          ],
          [
            211,
            17
          ]
        ],
        [
          "struct chunk {\n\tsize_t n_left;\n\tvoid *m;\n}",
          {
            "n_left": "size_t",
            "*m": "void"
          },
          "chunk",
          [
            240,
            0
          ],
          [
            243,
            1
          ]
        ],
        [
          "struct _compiler_state {\n\tjmp_buf top_ctx;\n\tpcap_t *bpf_pcap;\n\tint error_set;\n\n\tstruct icode ic;\n\n\tint snaplen;\n\n\tint linktype;\n\tint prevlinktype;\n\tint outermostlinktype;\n\n\tbpf_u_int32 netmask;\n\tint no_optimize;\n\n\t/* Hack for handling VLAN and MPLS stacks. */\n\tu_int label_stack_depth;\n\tu_int vlan_stack_depth;\n\n\t/* XXX */\n\tu_int pcap_fddipad;\n\n\t/*\n\t * As errors are handled by a longjmp, anything allocated must\n\t * be freed in the longjmp handler, so it must be reachable\n\t * from that handler.\n\t *\n\t * One thing that's allocated is the result of pcap_nametoaddrinfo();\n\t * it must be freed with freeaddrinfo().  This variable points to\n\t * any addrinfo structure that would need to be freed.\n\t */\n\tstruct addrinfo *ai;\n\n\t/*\n\t * Another thing that's allocated is the result of pcap_ether_aton();\n\t * it must be freed with free().  This variable points to any\n\t * address that would need to be freed.\n\t */\n\tu_char *e;\n\n\t/*\n\t * Various code constructs need to know the layout of the packet.\n\t * These values give the necessary offsets from the beginning\n\t * of the packet data.\n\t */\n\n\t/*\n\t * Absolute offset of the beginning of the link-layer header.\n\t */\n\tbpf_abs_offset off_linkhdr;\n\n\t/*\n\t * If we're checking a link-layer header for a packet encapsulated\n\t * in another protocol layer, this is the equivalent information\n\t * for the previous layers' link-layer header from the beginning\n\t * of the raw packet data.\n\t */\n\tbpf_abs_offset off_prevlinkhdr;\n\n\t/*\n\t * This is the equivalent information for the outermost layers'\n\t * link-layer header.\n\t */\n\tbpf_abs_offset off_outermostlinkhdr;\n\n\t/*\n\t * Absolute offset of the beginning of the link-layer payload.\n\t */\n\tbpf_abs_offset off_linkpl;\n\n\t/*\n\t * \"off_linktype\" is the offset to information in the link-layer\n\t * header giving the packet type. This is an absolute offset\n\t * from the beginning of the packet.\n\t *\n\t * For Ethernet, it's the offset of the Ethernet type field; this\n\t * means that it must have a value that skips VLAN tags.\n\t *\n\t * For link-layer types that always use 802.2 headers, it's the\n\t * offset of the LLC header; this means that it must have a value\n\t * that skips VLAN tags.\n\t *\n\t * For PPP, it's the offset of the PPP type field.\n\t *\n\t * For Cisco HDLC, it's the offset of the CHDLC type field.\n\t *\n\t * For BSD loopback, it's the offset of the AF_ value.\n\t *\n\t * For Linux cooked sockets, it's the offset of the type field.\n\t *\n\t * off_linktype.constant_part is set to OFFSET_NOT_SET for no\n\t * encapsulation, in which case, IP is assumed.\n\t */\n\tbpf_abs_offset off_linktype;\n\n\t/*\n\t * TRUE if the link layer includes an ATM pseudo-header.\n\t */\n\tint is_atm;\n\n\t/*\n\t * TRUE if \"geneve\" appeared in the filter; it causes us to\n\t * generate code that checks for a Geneve header and assume\n\t * that later filters apply to the encapsulated payload.\n\t */\n\tint is_geneve;\n\n\t/*\n\t * TRUE if we need variable length part of VLAN offset\n\t */\n\tint is_vlan_vloffset;\n\n\t/*\n\t * These are offsets for the ATM pseudo-header.\n\t */\n\tu_int off_vpi;\n\tu_int off_vci;\n\tu_int off_proto;\n\n\t/*\n\t * These are offsets for the MTP2 fields.\n\t */\n\tu_int off_li;\n\tu_int off_li_hsl;\n\n\t/*\n\t * These are offsets for the MTP3 fields.\n\t */\n\tu_int off_sio;\n\tu_int off_opc;\n\tu_int off_dpc;\n\tu_int off_sls;\n\n\t/*\n\t * This is the offset of the first byte after the ATM pseudo_header,\n\t * or -1 if there is no ATM pseudo-header.\n\t */\n\tu_int off_payload;\n\n\t/*\n\t * These are offsets to the beginning of the network-layer header.\n\t * They are relative to the beginning of the link-layer payload\n\t * (i.e., they don't include off_linkhdr.constant_part or\n\t * off_linkpl.constant_part).\n\t *\n\t * If the link layer never uses 802.2 LLC:\n\t *\n\t *\t\"off_nl\" and \"off_nl_nosnap\" are the same.\n\t *\n\t * If the link layer always uses 802.2 LLC:\n\t *\n\t *\t\"off_nl\" is the offset if there's a SNAP header following\n\t *\tthe 802.2 header;\n\t *\n\t *\t\"off_nl_nosnap\" is the offset if there's no SNAP header.\n\t *\n\t * If the link layer is Ethernet:\n\t *\n\t *\t\"off_nl\" is the offset if the packet is an Ethernet II packet\n\t *\t(we assume no 802.3+802.2+SNAP);\n\t *\n\t *\t\"off_nl_nosnap\" is the offset if the packet is an 802.3 packet\n\t *\twith an 802.2 header following it.\n\t */\n\tu_int off_nl;\n\tu_int off_nl_nosnap;\n\n\t/*\n\t * Here we handle simple allocation of the scratch registers.\n\t * If too many registers are alloc'd, the allocator punts.\n\t */\n\tint regused[BPF_MEMWORDS];\n\tint curreg;\n\n\t/*\n\t * Memory chunks.\n\t */\n\tstruct chunk chunks[NCHUNKS];\n\tint cur_chunk;\n}",
          {
            "top_ctx": "jmp_buf",
            "*bpf_pcap": "pcap_t",
            "error_set": "int",
            "ic": "struct icode",
            "snaplen": "int",
            "linktype": "int",
            "prevlinktype": "int",
            "outermostlinktype": "int",
            "netmask": "bpf_u_int32",
            "no_optimize": "int",
            "label_stack_depth": "u_int",
            "vlan_stack_depth": "u_int",
            "pcap_fddipad": "u_int",
            "*ai": "struct addrinfo",
            "*e": "u_char",
            "off_linkhdr": "bpf_abs_offset",
            "off_prevlinkhdr": "bpf_abs_offset",
            "off_outermostlinkhdr": "bpf_abs_offset",
            "off_linkpl": "bpf_abs_offset",
            "off_linktype": "bpf_abs_offset",
            "is_atm": "int",
            "is_geneve": "int",
            "is_vlan_vloffset": "int",
            "off_vpi": "u_int",
            "off_vci": "u_int",
            "off_proto": "u_int",
            "off_li": "u_int",
            "off_li_hsl": "u_int",
            "off_sio": "u_int",
            "off_opc": "u_int",
            "off_dpc": "u_int",
            "off_sls": "u_int",
            "off_payload": "u_int",
            "off_nl": "u_int",
            "off_nl_nosnap": "u_int",
            "regused[BPF_MEMWORDS]": "int",
            "curreg": "int",
            "chunks[NCHUNKS]": "struct chunk",
            "cur_chunk": "int"
          },
          "_compiler_state",
          [
            247,
            0
          ],
          [
            427,
            1
          ]
        ],
        [
          "struct in6_addr\n  {\n    union\n      {\n\tuint8_t\t\tu6_addr8[16];\n\tuint16_t\tu6_addr16[8];\n\tuint32_t\tu6_addr32[4];\n      } in6_u;\n#define s6_addr\t\t\tin6_u.u6_addr8\n#define s6_addr16\t\tin6_u.u6_addr16\n#define s6_addr32\t\tin6_u.u6_addr32\n#define s6_addr64\t\tin6_u.u6_addr64\n  }",
          {
            "in6_u": "union\n      {\n\tuint8_t\t\tu6_addr8[16];\n\tuint16_t\tu6_addr16[8];\n\tuint32_t\tu6_addr32[4];\n      }",
            "u6_addr8[16]": "uint8_t",
            "u6_addr16[8]": "uint16_t",
            "u6_addr32[4]": "uint32_t"
          },
          "in6_addr",
          [
            90,
            0
          ],
          [
            102,
            3
          ]
        ],
        [
          "struct sockaddr_in6\n  {\n    __SOCKADDR_COMMON (sin6_);\n    uint16_t sin6_port;\t\t/* Transport layer port # */\n    uint32_t sin6_flowinfo;\t/* IPv6 flow information */\n    struct in6_addr sin6_addr;\t/* IPv6 address */\n  }",
          {
            "sin6_port": "uint16_t",
            "sin6_flowinfo": "uint32_t",
            "sin6_addr": "struct in6_addr"
          },
          "sockaddr_in6",
          [
            110,
            0
          ],
          [
            116,
            3
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            115,
            4
          ],
          [
            115,
            19
          ]
        ],
        [
          "struct addrinfo {\n\tint\tai_flags;\t/* AI_PASSIVE, AI_CANONNAME */\n\tint\tai_family;\t/* PF_xxx */\n\tint\tai_socktype;\t/* SOCK_xxx */\n\tint\tai_protocol;\t/* 0 or IPPROTO_xxx for IPv4 and IPv6 */\n\tsize_t\tai_addrlen;\t/* length of ai_addr */\n\tchar\t*ai_canonname;\t/* canonical name for hostname */\n\tstruct sockaddr *ai_addr;\t/* binary address */\n\tstruct addrinfo *ai_next;\t/* next structure in linked list */\n}",
          {
            "ai_flags": "int",
            "ai_family": "int",
            "ai_socktype": "int",
            "ai_protocol": "int",
            "ai_addrlen": "size_t",
            "*ai_canonname": "char",
            "*ai_addr": "struct sockaddr",
            "*ai_next": "struct addrinfo"
          },
          "addrinfo",
          [
            119,
            0
          ],
          [
            128,
            1
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            126,
            1
          ],
          [
            126,
            16
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            127,
            1
          ],
          [
            127,
            16
          ]
        ],
        [
          "typedef struct {\n\tint\tis_variable;\n\tu_int\tconstant_part;\n\tint\treg;\n} bpf_abs_offset;",
          {
            "is_variable": "int",
            "constant_part": "u_int",
            "reg": "int"
          },
          "bpf_abs_offset",
          [
            207,
            0
          ],
          [
            211,
            17
          ]
        ],
        [
          "struct chunk {\n\tsize_t n_left;\n\tvoid *m;\n}",
          {
            "n_left": "size_t",
            "*m": "void"
          },
          "chunk",
          [
            240,
            0
          ],
          [
            243,
            1
          ]
        ],
        [
          "struct _compiler_state {\n\tjmp_buf top_ctx;\n\tpcap_t *bpf_pcap;\n\tint error_set;\n\n\tstruct icode ic;\n\n\tint snaplen;\n\n\tint linktype;\n\tint prevlinktype;\n\tint outermostlinktype;\n\n\tbpf_u_int32 netmask;\n\tint no_optimize;\n\n\t/* Hack for handling VLAN and MPLS stacks. */\n\tu_int label_stack_depth;\n\tu_int vlan_stack_depth;\n\n\t/* XXX */\n\tu_int pcap_fddipad;\n\n\t/*\n\t * As errors are handled by a longjmp, anything allocated must\n\t * be freed in the longjmp handler, so it must be reachable\n\t * from that handler.\n\t *\n\t * One thing that's allocated is the result of pcap_nametoaddrinfo();\n\t * it must be freed with freeaddrinfo().  This variable points to\n\t * any addrinfo structure that would need to be freed.\n\t */\n\tstruct addrinfo *ai;\n\n\t/*\n\t * Another thing that's allocated is the result of pcap_ether_aton();\n\t * it must be freed with free().  This variable points to any\n\t * address that would need to be freed.\n\t */\n\tu_char *e;\n\n\t/*\n\t * Various code constructs need to know the layout of the packet.\n\t * These values give the necessary offsets from the beginning\n\t * of the packet data.\n\t */\n\n\t/*\n\t * Absolute offset of the beginning of the link-layer header.\n\t */\n\tbpf_abs_offset off_linkhdr;\n\n\t/*\n\t * If we're checking a link-layer header for a packet encapsulated\n\t * in another protocol layer, this is the equivalent information\n\t * for the previous layers' link-layer header from the beginning\n\t * of the raw packet data.\n\t */\n\tbpf_abs_offset off_prevlinkhdr;\n\n\t/*\n\t * This is the equivalent information for the outermost layers'\n\t * link-layer header.\n\t */\n\tbpf_abs_offset off_outermostlinkhdr;\n\n\t/*\n\t * Absolute offset of the beginning of the link-layer payload.\n\t */\n\tbpf_abs_offset off_linkpl;\n\n\t/*\n\t * \"off_linktype\" is the offset to information in the link-layer\n\t * header giving the packet type. This is an absolute offset\n\t * from the beginning of the packet.\n\t *\n\t * For Ethernet, it's the offset of the Ethernet type field; this\n\t * means that it must have a value that skips VLAN tags.\n\t *\n\t * For link-layer types that always use 802.2 headers, it's the\n\t * offset of the LLC header; this means that it must have a value\n\t * that skips VLAN tags.\n\t *\n\t * For PPP, it's the offset of the PPP type field.\n\t *\n\t * For Cisco HDLC, it's the offset of the CHDLC type field.\n\t *\n\t * For BSD loopback, it's the offset of the AF_ value.\n\t *\n\t * For Linux cooked sockets, it's the offset of the type field.\n\t *\n\t * off_linktype.constant_part is set to OFFSET_NOT_SET for no\n\t * encapsulation, in which case, IP is assumed.\n\t */\n\tbpf_abs_offset off_linktype;\n\n\t/*\n\t * TRUE if the link layer includes an ATM pseudo-header.\n\t */\n\tint is_atm;\n\n\t/*\n\t * TRUE if \"geneve\" appeared in the filter; it causes us to\n\t * generate code that checks for a Geneve header and assume\n\t * that later filters apply to the encapsulated payload.\n\t */\n\tint is_geneve;\n\n\t/*\n\t * TRUE if we need variable length part of VLAN offset\n\t */\n\tint is_vlan_vloffset;\n\n\t/*\n\t * These are offsets for the ATM pseudo-header.\n\t */\n\tu_int off_vpi;\n\tu_int off_vci;\n\tu_int off_proto;\n\n\t/*\n\t * These are offsets for the MTP2 fields.\n\t */\n\tu_int off_li;\n\tu_int off_li_hsl;\n\n\t/*\n\t * These are offsets for the MTP3 fields.\n\t */\n\tu_int off_sio;\n\tu_int off_opc;\n\tu_int off_dpc;\n\tu_int off_sls;\n\n\t/*\n\t * This is the offset of the first byte after the ATM pseudo_header,\n\t * or -1 if there is no ATM pseudo-header.\n\t */\n\tu_int off_payload;\n\n\t/*\n\t * These are offsets to the beginning of the network-layer header.\n\t * They are relative to the beginning of the link-layer payload\n\t * (i.e., they don't include off_linkhdr.constant_part or\n\t * off_linkpl.constant_part).\n\t *\n\t * If the link layer never uses 802.2 LLC:\n\t *\n\t *\t\"off_nl\" and \"off_nl_nosnap\" are the same.\n\t *\n\t * If the link layer always uses 802.2 LLC:\n\t *\n\t *\t\"off_nl\" is the offset if there's a SNAP header following\n\t *\tthe 802.2 header;\n\t *\n\t *\t\"off_nl_nosnap\" is the offset if there's no SNAP header.\n\t *\n\t * If the link layer is Ethernet:\n\t *\n\t *\t\"off_nl\" is the offset if the packet is an Ethernet II packet\n\t *\t(we assume no 802.3+802.2+SNAP);\n\t *\n\t *\t\"off_nl_nosnap\" is the offset if the packet is an 802.3 packet\n\t *\twith an 802.2 header following it.\n\t */\n\tu_int off_nl;\n\tu_int off_nl_nosnap;\n\n\t/*\n\t * Here we handle simple allocation of the scratch registers.\n\t * If too many registers are alloc'd, the allocator punts.\n\t */\n\tint regused[BPF_MEMWORDS];\n\tint curreg;\n\n\t/*\n\t * Memory chunks.\n\t */\n\tstruct chunk chunks[NCHUNKS];\n\tint cur_chunk;\n}",
          {
            "top_ctx": "jmp_buf",
            "*bpf_pcap": "pcap_t",
            "error_set": "int",
            "ic": "struct icode",
            "snaplen": "int",
            "linktype": "int",
            "prevlinktype": "int",
            "outermostlinktype": "int",
            "netmask": "bpf_u_int32",
            "no_optimize": "int",
            "label_stack_depth": "u_int",
            "vlan_stack_depth": "u_int",
            "pcap_fddipad": "u_int",
            "*ai": "struct addrinfo",
            "*e": "u_char",
            "off_linkhdr": "bpf_abs_offset",
            "off_prevlinkhdr": "bpf_abs_offset",
            "off_outermostlinkhdr": "bpf_abs_offset",
            "off_linkpl": "bpf_abs_offset",
            "off_linktype": "bpf_abs_offset",
            "is_atm": "int",
            "is_geneve": "int",
            "is_vlan_vloffset": "int",
            "off_vpi": "u_int",
            "off_vci": "u_int",
            "off_proto": "u_int",
            "off_li": "u_int",
            "off_li_hsl": "u_int",
            "off_sio": "u_int",
            "off_opc": "u_int",
            "off_dpc": "u_int",
            "off_sls": "u_int",
            "off_payload": "u_int",
            "off_nl": "u_int",
            "off_nl_nosnap": "u_int",
            "regused[BPF_MEMWORDS]": "int",
            "curreg": "int",
            "chunks[NCHUNKS]": "struct chunk",
            "cur_chunk": "int"
          },
          "_compiler_state",
          [
            247,
            0
          ],
          [
            427,
            1
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            252,
            1
          ],
          [
            252,
            13
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            279,
            1
          ],
          [
            279,
            16
          ]
        ],
        [
          "struct chunk",
          {},
          "",
          [
            425,
            1
          ],
          [
            425,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            486,
            14
          ],
          [
            486,
            26
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            487,
            14
          ],
          [
            487,
            26
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            488,
            7
          ],
          [
            488,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            491,
            22
          ],
          [
            491,
            34
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            491,
            38
          ],
          [
            491,
            50
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            492,
            18
          ],
          [
            492,
            30
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            492,
            34
          ],
          [
            492,
            46
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            493,
            7
          ],
          [
            493,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            495,
            7
          ],
          [
            495,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            497,
            7
          ],
          [
            497,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            499,
            7
          ],
          [
            499,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            501,
            7
          ],
          [
            501,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            503,
            7
          ],
          [
            503,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            505,
            7
          ],
          [
            505,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            507,
            7
          ],
          [
            507,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            509,
            7
          ],
          [
            509,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            511,
            7
          ],
          [
            511,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            513,
            7
          ],
          [
            513,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            514,
            7
          ],
          [
            514,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            515,
            14
          ],
          [
            515,
            26
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            516,
            14
          ],
          [
            516,
            26
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            517,
            7
          ],
          [
            517,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            518,
            7
          ],
          [
            518,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            519,
            7
          ],
          [
            519,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            520,
            7
          ],
          [
            520,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            521,
            7
          ],
          [
            521,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            522,
            7
          ],
          [
            522,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            523,
            7
          ],
          [
            523,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            524,
            57
          ],
          [
            524,
            69
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            525,
            7
          ],
          [
            525,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            528,
            7
          ],
          [
            528,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            529,
            7
          ],
          [
            529,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            530,
            7
          ],
          [
            530,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            531,
            7
          ],
          [
            531,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            534,
            7
          ],
          [
            534,
            19
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            534,
            53
          ],
          [
            534,
            68
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            535,
            4
          ],
          [
            535,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            537,
            7
          ],
          [
            537,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            538,
            7
          ],
          [
            538,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            539,
            7
          ],
          [
            539,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            540,
            7
          ],
          [
            540,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            541,
            7
          ],
          [
            541,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            542,
            7
          ],
          [
            542,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            543,
            7
          ],
          [
            543,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            544,
            7
          ],
          [
            544,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            545,
            7
          ],
          [
            545,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            548,
            7
          ],
          [
            548,
            19
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            548,
            51
          ],
          [
            548,
            66
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            549,
            4
          ],
          [
            549,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            552,
            7
          ],
          [
            552,
            19
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            553,
            4
          ],
          [
            553,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            555,
            7
          ],
          [
            555,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            556,
            7
          ],
          [
            556,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            557,
            7
          ],
          [
            557,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            559,
            7
          ],
          [
            559,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            560,
            7
          ],
          [
            560,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            562,
            7
          ],
          [
            562,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            563,
            7
          ],
          [
            563,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            564,
            7
          ],
          [
            564,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            566,
            7
          ],
          [
            566,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            567,
            0
          ],
          [
            567,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            568,
            7
          ],
          [
            568,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            569,
            7
          ],
          [
            569,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            571,
            7
          ],
          [
            571,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            573,
            7
          ],
          [
            573,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            574,
            7
          ],
          [
            574,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            575,
            7
          ],
          [
            575,
            19
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            575,
            51
          ],
          [
            575,
            62
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            576,
            7
          ],
          [
            576,
            19
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            576,
            51
          ],
          [
            576,
            62
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            577,
            7
          ],
          [
            577,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            578,
            7
          ],
          [
            578,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            579,
            7
          ],
          [
            579,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            580,
            7
          ],
          [
            580,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            582,
            7
          ],
          [
            582,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            583,
            7
          ],
          [
            583,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            585,
            7
          ],
          [
            585,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            586,
            7
          ],
          [
            586,
            19
          ]
        ],
        [
          "struct chunk",
          {},
          "",
          [
            603,
            1
          ],
          [
            603,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            681,
            14
          ],
          [
            681,
            26
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            684,
            1
          ],
          [
            684,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            686,
            6
          ],
          [
            686,
            18
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            693,
            14
          ],
          [
            693,
            26
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            696,
            1
          ],
          [
            696,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            698,
            6
          ],
          [
            698,
            18
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            704,
            7
          ],
          [
            704,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            707,
            1
          ],
          [
            707,
            13
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            720,
            24
          ],
          [
            720,
            42
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            877,
            6
          ],
          [
            877,
            24
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            896,
            14
          ],
          [
            896,
            32
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            912,
            10
          ],
          [
            912,
            22
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            912,
            30
          ],
          [
            912,
            42
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            914,
            1
          ],
          [
            914,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            933,
            6
          ],
          [
            933,
            18
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            933,
            24
          ],
          [
            933,
            36
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            935,
            10
          ],
          [
            935,
            22
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            946,
            39
          ],
          [
            946,
            51
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            948,
            1
          ],
          [
            948,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1003,
            8
          ],
          [
            1003,
            20
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1003,
            26
          ],
          [
            1003,
            38
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1014,
            7
          ],
          [
            1014,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1014,
            25
          ],
          [
            1014,
            37
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1024,
            8
          ],
          [
            1024,
            20
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1029,
            7
          ],
          [
            1029,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1036,
            7
          ],
          [
            1036,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1043,
            7
          ],
          [
            1043,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1050,
            7
          ],
          [
            1050,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1057,
            7
          ],
          [
            1057,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1064,
            7
          ],
          [
            1064,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1071,
            7
          ],
          [
            1071,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1075,
            10
          ],
          [
            1075,
            22
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1113,
            7
          ],
          [
            1113,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            1118,
            1
          ],
          [
            1118,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1119,
            1
          ],
          [
            1119,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            1734,
            7
          ],
          [
            1734,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            1738,
            1
          ],
          [
            1738,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            1774,
            7
          ],
          [
            1774,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            1778,
            1
          ],
          [
            1778,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            1865,
            7
          ],
          [
            1865,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            1868,
            1
          ],
          [
            1868,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1920,
            7
          ],
          [
            1920,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1923,
            1
          ],
          [
            1923,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            1924,
            1
          ],
          [
            1924,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1934,
            14
          ],
          [
            1934,
            26
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1940,
            14
          ],
          [
            1940,
            26
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1963,
            7
          ],
          [
            1963,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            1966,
            1
          ],
          [
            1966,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2131,
            7
          ],
          [
            2131,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2170,
            7
          ],
          [
            2170,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2198,
            7
          ],
          [
            2198,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2201,
            1
          ],
          [
            2201,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2343,
            7
          ],
          [
            2343,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2346,
            1
          ],
          [
            2346,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2347,
            1
          ],
          [
            2347,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2348,
            1
          ],
          [
            2348,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2453,
            7
          ],
          [
            2453,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2456,
            1
          ],
          [
            2456,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2493,
            7
          ],
          [
            2493,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2496,
            1
          ],
          [
            2496,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2563,
            7
          ],
          [
            2563,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2566,
            1
          ],
          [
            2566,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2629,
            7
          ],
          [
            2629,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2630,
            53
          ],
          [
            2630,
            65
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2630,
            70
          ],
          [
            2630,
            82
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2632,
            1
          ],
          [
            2632,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2633,
            1
          ],
          [
            2633,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2634,
            1
          ],
          [
            2634,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2635,
            1
          ],
          [
            2635,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2636,
            1
          ],
          [
            2636,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2637,
            1
          ],
          [
            2637,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2638,
            1
          ],
          [
            2638,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2639,
            1
          ],
          [
            2639,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2640,
            1
          ],
          [
            2640,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2869,
            51
          ],
          [
            2869,
            63
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2871,
            1
          ],
          [
            2871,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2937,
            2
          ],
          [
            2937,
            14
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2966,
            7
          ],
          [
            2966,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            2969,
            1
          ],
          [
            2969,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            2970,
            1
          ],
          [
            2970,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            3005,
            7
          ],
          [
            3005,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            3008,
            1
          ],
          [
            3008,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3090,
            7
          ],
          [
            3090,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3093,
            1
          ],
          [
            3093,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3136,
            7
          ],
          [
            3136,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3139,
            1
          ],
          [
            3139,
            13
          ]
        ],
        [
          "struct pfloghdr",
          {},
          "",
          [
            3401,
            48
          ],
          [
            3401,
            63
          ]
        ],
        [
          "struct pfloghdr",
          {},
          "",
          [
            3404,
            48
          ],
          [
            3404,
            63
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3646,
            7
          ],
          [
            3646,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3665,
            7
          ],
          [
            3665,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3668,
            1
          ],
          [
            3668,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3736,
            0
          ],
          [
            3736,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3749,
            0
          ],
          [
            3749,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3752,
            1
          ],
          [
            3752,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            3753,
            1
          ],
          [
            3753,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3780,
            0
          ],
          [
            3780,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3783,
            1
          ],
          [
            3783,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3806,
            0
          ],
          [
            3806,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3809,
            1
          ],
          [
            3809,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3832,
            0
          ],
          [
            3832,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3835,
            1
          ],
          [
            3835,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3857,
            0
          ],
          [
            3857,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3860,
            1
          ],
          [
            3860,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3894,
            7
          ],
          [
            3894,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3968,
            7
          ],
          [
            3968,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            3972,
            1
          ],
          [
            3972,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4033,
            7
          ],
          [
            4033,
            19
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            4034,
            38
          ],
          [
            4034,
            53
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            4035,
            4
          ],
          [
            4035,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4038,
            1
          ],
          [
            4038,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4109,
            7
          ],
          [
            4109,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4112,
            10
          ],
          [
            4112,
            22
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4165,
            7
          ],
          [
            4165,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4168,
            1
          ],
          [
            4168,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4221,
            7
          ],
          [
            4221,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4224,
            10
          ],
          [
            4224,
            22
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4278,
            7
          ],
          [
            4278,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4281,
            10
          ],
          [
            4281,
            22
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            4282,
            10
          ],
          [
            4282,
            22
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4702,
            7
          ],
          [
            4702,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4705,
            10
          ],
          [
            4705,
            22
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4773,
            7
          ],
          [
            4773,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4776,
            1
          ],
          [
            4776,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4874,
            7
          ],
          [
            4874,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4877,
            1
          ],
          [
            4877,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4904,
            7
          ],
          [
            4904,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            4908,
            1
          ],
          [
            4908,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5056,
            7
          ],
          [
            5056,
            19
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            5057,
            36
          ],
          [
            5057,
            51
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            5058,
            4
          ],
          [
            5058,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5197,
            7
          ],
          [
            5197,
            19
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            5199,
            4
          ],
          [
            5199,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5201,
            1
          ],
          [
            5201,
            13
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            5202,
            1
          ],
          [
            5202,
            16
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            5203,
            1
          ],
          [
            5203,
            19
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            5264,
            12
          ],
          [
            5264,
            30
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5303,
            7
          ],
          [
            5303,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5306,
            1
          ],
          [
            5306,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5307,
            1
          ],
          [
            5307,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5543,
            0
          ],
          [
            5543,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5556,
            7
          ],
          [
            5556,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            5559,
            1
          ],
          [
            5559,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5560,
            1
          ],
          [
            5560,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5581,
            7
          ],
          [
            5581,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5587,
            7
          ],
          [
            5587,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5593,
            7
          ],
          [
            5593,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5596,
            1
          ],
          [
            5596,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5658,
            7
          ],
          [
            5658,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5661,
            1
          ],
          [
            5661,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5704,
            0
          ],
          [
            5704,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5707,
            1
          ],
          [
            5707,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5743,
            7
          ],
          [
            5743,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5746,
            1
          ],
          [
            5746,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5774,
            7
          ],
          [
            5774,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5778,
            1
          ],
          [
            5778,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5799,
            7
          ],
          [
            5799,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5803,
            1
          ],
          [
            5803,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5865,
            7
          ],
          [
            5865,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5869,
            1
          ],
          [
            5869,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5897,
            7
          ],
          [
            5897,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5901,
            1
          ],
          [
            5901,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5922,
            7
          ],
          [
            5922,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5926,
            1
          ],
          [
            5926,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5962,
            7
          ],
          [
            5962,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            5966,
            1
          ],
          [
            5966,
            13
          ]
        ],
        [
          "struct stmt",
          {},
          "",
          [
            6038,
            0
          ],
          [
            6038,
            11
          ]
        ],
        [
          "struct stmt",
          {},
          "",
          [
            6039,
            11
          ],
          [
            6039,
            22
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            6045,
            7
          ],
          [
            6045,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            6051,
            1
          ],
          [
            6051,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            6052,
            1
          ],
          [
            6052,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            6336,
            7
          ],
          [
            6336,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            6339,
            1
          ],
          [
            6339,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            6340,
            1
          ],
          [
            6340,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            6371,
            7
          ],
          [
            6371,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            6374,
            1
          ],
          [
            6374,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            6376,
            1
          ],
          [
            6376,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            6631,
            0
          ],
          [
            6631,
            12
          ]
        ],
        [
          "struct qual",
          {},
          "",
          [
            6632,
            54
          ],
          [
            6632,
            65
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            6639,
            1
          ],
          [
            6639,
            16
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            6640,
            1
          ],
          [
            6640,
            19
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            6643,
            1
          ],
          [
            6643,
            20
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            6644,
            1
          ],
          [
            6644,
            16
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            6646,
            1
          ],
          [
            6646,
            13
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            6776,
            13
          ],
          [
            6776,
            31
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            6786,
            13
          ],
          [
            6786,
            32
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            6941,
            0
          ],
          [
            6941,
            12
          ]
        ],
        [
          "struct qual",
          {},
          "",
          [
            6943,
            25
          ],
          [
            6943,
            36
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            6995,
            0
          ],
          [
            6995,
            12
          ]
        ],
        [
          "struct qual",
          {},
          "",
          [
            6996,
            66
          ],
          [
            6996,
            77
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7062,
            2
          ],
          [
            7062,
            14
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7084,
            2
          ],
          [
            7084,
            14
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7112,
            0
          ],
          [
            7112,
            12
          ]
        ],
        [
          "struct qual",
          {},
          "",
          [
            7114,
            25
          ],
          [
            7114,
            36
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            7116,
            1
          ],
          [
            7116,
            16
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            7117,
            1
          ],
          [
            7117,
            16
          ]
        ],
        [
          "struct in6_addr",
          {},
          "",
          [
            7118,
            1
          ],
          [
            7118,
            16
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7119,
            1
          ],
          [
            7119,
            13
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            7138,
            11
          ],
          [
            7138,
            30
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7177,
            0
          ],
          [
            7177,
            12
          ]
        ],
        [
          "struct qual",
          {},
          "",
          [
            7178,
            51
          ],
          [
            7178,
            62
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7180,
            1
          ],
          [
            7180,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            7233,
            8
          ],
          [
            7233,
            20
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            7233,
            26
          ],
          [
            7233,
            38
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            7244,
            7
          ],
          [
            7244,
            19
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7245,
            36
          ],
          [
            7245,
            47
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            7247,
            1
          ],
          [
            7247,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            7254,
            7
          ],
          [
            7254,
            19
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7255,
            36
          ],
          [
            7255,
            47
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            7257,
            1
          ],
          [
            7257,
            13
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7271,
            7
          ],
          [
            7271,
            18
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7272,
            55
          ],
          [
            7272,
            66
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            7276,
            1
          ],
          [
            7276,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7277,
            1
          ],
          [
            7277,
            13
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7547,
            0
          ],
          [
            7547,
            11
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7548,
            46
          ],
          [
            7548,
            57
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7561,
            7
          ],
          [
            7561,
            19
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7562,
            58
          ],
          [
            7562,
            69
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7563,
            4
          ],
          [
            7563,
            15
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            7565,
            1
          ],
          [
            7565,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7566,
            1
          ],
          [
            7566,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7605,
            0
          ],
          [
            7605,
            12
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7606,
            49
          ],
          [
            7606,
            60
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7607,
            4
          ],
          [
            7607,
            15
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7619,
            0
          ],
          [
            7619,
            11
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7623,
            1
          ],
          [
            7623,
            12
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            7624,
            1
          ],
          [
            7624,
            13
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7634,
            6
          ],
          [
            7634,
            17
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7644,
            7
          ],
          [
            7644,
            18
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7647,
            1
          ],
          [
            7647,
            12
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            7648,
            1
          ],
          [
            7648,
            13
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7651,
            6
          ],
          [
            7651,
            17
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7665,
            0
          ],
          [
            7665,
            11
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7683,
            0
          ],
          [
            7683,
            11
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7684,
            34
          ],
          [
            7684,
            45
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7686,
            1
          ],
          [
            7686,
            12
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            7687,
            1
          ],
          [
            7687,
            13
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7713,
            0
          ],
          [
            7713,
            11
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7714,
            45
          ],
          [
            7714,
            56
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7715,
            4
          ],
          [
            7715,
            15
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            7717,
            1
          ],
          [
            7717,
            12
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            7718,
            1
          ],
          [
            7718,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7803,
            7
          ],
          [
            7803,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            7806,
            1
          ],
          [
            7806,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7807,
            1
          ],
          [
            7807,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7817,
            0
          ],
          [
            7817,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7833,
            0
          ],
          [
            7833,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7836,
            1
          ],
          [
            7836,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7861,
            0
          ],
          [
            7861,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7864,
            1
          ],
          [
            7864,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            7865,
            1
          ],
          [
            7865,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7907,
            0
          ],
          [
            7907,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7911,
            1
          ],
          [
            7911,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7979,
            7
          ],
          [
            7979,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7982,
            10
          ],
          [
            7982,
            22
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            7983,
            10
          ],
          [
            7983,
            22
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7993,
            0
          ],
          [
            7993,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            7996,
            10
          ],
          [
            7996,
            22
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            7997,
            10
          ],
          [
            7997,
            22
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8186,
            0
          ],
          [
            8186,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8189,
            10
          ],
          [
            8189,
            22
          ]
        ],
        [
          "struct pfloghdr",
          {},
          "",
          [
            8239,
            44
          ],
          [
            8239,
            59
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8336,
            0
          ],
          [
            8336,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8339,
            1
          ],
          [
            8339,
            13
          ]
        ],
        [
          "struct pfloghdr",
          {},
          "",
          [
            8353,
            16
          ],
          [
            8353,
            31
          ]
        ],
        [
          "struct pfloghdr",
          {},
          "",
          [
            8354,
            16
          ],
          [
            8354,
            31
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8366,
            0
          ],
          [
            8366,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8369,
            1
          ],
          [
            8369,
            13
          ]
        ],
        [
          "struct pfloghdr",
          {},
          "",
          [
            8383,
            33
          ],
          [
            8383,
            48
          ]
        ],
        [
          "struct pfloghdr",
          {},
          "",
          [
            8385,
            22
          ],
          [
            8385,
            37
          ]
        ],
        [
          "struct pfloghdr",
          {},
          "",
          [
            8389,
            44
          ],
          [
            8389,
            59
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8395,
            0
          ],
          [
            8395,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8398,
            1
          ],
          [
            8398,
            13
          ]
        ],
        [
          "struct pfloghdr",
          {},
          "",
          [
            8412,
            43
          ],
          [
            8412,
            58
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8418,
            0
          ],
          [
            8418,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8421,
            1
          ],
          [
            8421,
            13
          ]
        ],
        [
          "struct pfloghdr",
          {},
          "",
          [
            8435,
            43
          ],
          [
            8435,
            58
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8441,
            0
          ],
          [
            8441,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8444,
            1
          ],
          [
            8444,
            13
          ]
        ],
        [
          "struct pfloghdr",
          {},
          "",
          [
            8458,
            43
          ],
          [
            8458,
            58
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8464,
            0
          ],
          [
            8464,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8467,
            1
          ],
          [
            8467,
            13
          ]
        ],
        [
          "struct pfloghdr",
          {},
          "",
          [
            8481,
            43
          ],
          [
            8481,
            58
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8486,
            0
          ],
          [
            8486,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8500,
            0
          ],
          [
            8500,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8514,
            0
          ],
          [
            8514,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8528,
            0
          ],
          [
            8528,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8542,
            0
          ],
          [
            8542,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8556,
            0
          ],
          [
            8556,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8572,
            0
          ],
          [
            8572,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8575,
            1
          ],
          [
            8575,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8601,
            0
          ],
          [
            8601,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8604,
            1
          ],
          [
            8604,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8632,
            0
          ],
          [
            8632,
            12
          ]
        ],
        [
          "struct qual",
          {},
          "",
          [
            8633,
            51
          ],
          [
            8633,
            62
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8635,
            1
          ],
          [
            8635,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8667,
            7
          ],
          [
            8667,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8670,
            10
          ],
          [
            8670,
            22
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8721,
            7
          ],
          [
            8721,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8724,
            1
          ],
          [
            8724,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8737,
            7
          ],
          [
            8737,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8747,
            7
          ],
          [
            8747,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8751,
            1
          ],
          [
            8751,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            8775,
            19
          ],
          [
            8775,
            31
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            8777,
            1
          ],
          [
            8777,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8800,
            51
          ],
          [
            8800,
            63
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            8802,
            1
          ],
          [
            8802,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8820,
            50
          ],
          [
            8820,
            62
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            8822,
            1
          ],
          [
            8822,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8863,
            7
          ],
          [
            8863,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8867,
            8
          ],
          [
            8867,
            20
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            8868,
            8
          ],
          [
            8868,
            20
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            8910,
            0
          ],
          [
            8910,
            12
          ]
        ],
        [
          "struct\tblock",
          {},
          "",
          [
            8913,
            1
          ],
          [
            8913,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9008,
            0
          ],
          [
            9008,
            12
          ]
        ],
        [
          "struct\tblock",
          {},
          "",
          [
            9013,
            1
          ],
          [
            9013,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9090,
            0
          ],
          [
            9090,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9104,
            0
          ],
          [
            9104,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9107,
            1
          ],
          [
            9107,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9186,
            7
          ],
          [
            9186,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9188,
            4
          ],
          [
            9188,
            16
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9191,
            1
          ],
          [
            9191,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9221,
            7
          ],
          [
            9221,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9224,
            1
          ],
          [
            9224,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            9225,
            1
          ],
          [
            9225,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9247,
            7
          ],
          [
            9247,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9250,
            1
          ],
          [
            9250,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            9251,
            1
          ],
          [
            9251,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            9290,
            7
          ],
          [
            9290,
            19
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            9293,
            1
          ],
          [
            9293,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9425,
            0
          ],
          [
            9425,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9428,
            1
          ],
          [
            9428,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            9429,
            1
          ],
          [
            9429,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9462,
            7
          ],
          [
            9462,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9465,
            1
          ],
          [
            9465,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            9466,
            1
          ],
          [
            9466,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9489,
            7
          ],
          [
            9489,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9493,
            1
          ],
          [
            9493,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9544,
            7
          ],
          [
            9544,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9547,
            1
          ],
          [
            9547,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9555,
            7
          ],
          [
            9555,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9558,
            1
          ],
          [
            9558,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9566,
            7
          ],
          [
            9566,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9569,
            1
          ],
          [
            9569,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9576,
            0
          ],
          [
            9576,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9591,
            0
          ],
          [
            9591,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9594,
            1
          ],
          [
            9594,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9698,
            0
          ],
          [
            9698,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9701,
            1
          ],
          [
            9701,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9785,
            0
          ],
          [
            9785,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9790,
            1
          ],
          [
            9790,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9895,
            7
          ],
          [
            9895,
            19
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9898,
            1
          ],
          [
            9898,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9936,
            0
          ],
          [
            9936,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            9939,
            1
          ],
          [
            9939,
            13
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <pcap-types.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <ws2tcpip.h>\n",
          [
            28,
            2
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            30,
            2
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <sys/param.h>\n",
          [
            33,
            4
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            36,
            2
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <arpa/inet.h>\n",
          [
            37,
            2
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <memory.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <setjmp.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"pcap-dos.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include \"extract.h\"\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include \"ethertype.h\"\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include \"nlpid.h\"\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include \"llc.h\"\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include \"gencode.h\"\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#include \"ieee80211.h\"\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include \"atmuni31.h\"\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ],
        [
          "#include \"sunatmpos.h\"\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include \"ppp.h\"\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ],
        [
          "#include \"pcap/sll.h\"\n",
          [
            62,
            0
          ],
          [
            63,
            0
          ]
        ],
        [
          "#include \"pcap/ipnet.h\"\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include \"arcnet.h\"\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ],
        [
          "#include \"grammar.h\"\n",
          [
            66,
            0
          ],
          [
            67,
            0
          ]
        ],
        [
          "#include \"scanner.h\"\n",
          [
            67,
            0
          ],
          [
            68,
            0
          ]
        ],
        [
          "#include <linux/types.h>\n",
          [
            70,
            0
          ],
          [
            71,
            0
          ]
        ],
        [
          "#include <linux/if_packet.h>\n",
          [
            71,
            0
          ],
          [
            72,
            0
          ]
        ],
        [
          "#include <linux/filter.h>\n",
          [
            72,
            0
          ],
          [
            73,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            76,
            0
          ],
          [
            77,
            0
          ]
        ],
        [
          "#include <net/if.h>\n",
          [
            77,
            0
          ],
          [
            78,
            0
          ]
        ],
        [
          "#include <net/pfvar.h>\n",
          [
            78,
            0
          ],
          [
            79,
            0
          ]
        ],
        [
          "#include <net/if_pflog.h>\n",
          [
            79,
            0
          ],
          [
            80,
            0
          ]
        ],
        [
          "#include <netdb.h>\t/* for \"struct addrinfo\" */\n",
          [
            133,
            2
          ],
          [
            134,
            0
          ]
        ],
        [
          "#include <pcap/namedb.h>\n",
          [
            135,
            0
          ],
          [
            136,
            0
          ]
        ],
        [
          "#include \"nametoaddr.h\"\n",
          [
            137,
            0
          ],
          [
            138,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            164,
            0
          ],
          [
            165,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "enum e_offrel {\n\tOR_PACKET,\t\t/* full packet data */\n\tOR_LINKHDR,\t\t/* link-layer header */\n\tOR_PREVLINKHDR,\t\t/* previous link-layer header */\n\tOR_LLC,\t\t\t/* 802.2 LLC header */\n\tOR_PREVMPLSHDR,\t\t/* previous MPLS header */\n\tOR_LINKTYPE,\t\t/* link-layer type */\n\tOR_LINKPL,\t\t/* link-layer payload */\n\tOR_LINKPL_NOSNAP,\t/* link-layer payload, with no SNAP header at the link layer */\n\tOR_TRAN_IPV4,\t\t/* transport-layer header, with IPv4 network layer */\n\tOR_TRAN_IPV6\t\t/* transport-layer header, with IPv6 network layer */\n}",
          {
            "OR_PACKET": "",
            "OR_LINKHDR": "",
            "OR_PREVLINKHDR": "",
            "OR_LLC": "",
            "OR_PREVMPLSHDR": "",
            "OR_LINKTYPE": "",
            "OR_LINKPL": "",
            "OR_LINKPL_NOSNAP": "",
            "OR_TRAN_IPV4": "",
            "OR_TRAN_IPV6": ""
          },
          "e_offrel",
          [
            217,
            0
          ],
          [
            228,
            1
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            493,
            49
          ],
          [
            493,
            62
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            495,
            52
          ],
          [
            495,
            65
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            497,
            52
          ],
          [
            497,
            65
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            499,
            52
          ],
          [
            499,
            65
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            501,
            52
          ],
          [
            501,
            65
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            503,
            50
          ],
          [
            503,
            63
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            505,
            50
          ],
          [
            505,
            63
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            507,
            50
          ],
          [
            507,
            63
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            511,
            52
          ],
          [
            511,
            65
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            1030,
            34
          ],
          [
            1030,
            47
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            1037,
            37
          ],
          [
            1037,
            50
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            1044,
            37
          ],
          [
            1044,
            50
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            1051,
            37
          ],
          [
            1051,
            50
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            1058,
            37
          ],
          [
            1058,
            50
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            1065,
            35
          ],
          [
            1065,
            48
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            1072,
            35
          ],
          [
            1072,
            48
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            1114,
            35
          ],
          [
            1114,
            48
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            1775,
            37
          ],
          [
            1775,
            50
          ]
        ],
        [
          "enum e_offrel",
          {},
          "",
          [
            9189,
            4
          ],
          [
            9189,
            17
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-enet.c": {
      "fn_def_list": [
        {
          "fn_code": "void\nreadloop(int cnt, int if_fd, struct bpf_program *fp, printfunc printit)\n{\n#ifdef\tIBMRTPC\n\tregister struct packet_header *ph;\n\tregister u_char *bp;\n\tregister int inc;\n#else\t/* !IBMRTPC */\n\tstatic struct timeval tv = { 0 };\n#endif\t/* IBMRTPC */\n\tregister int cc, caplen;\n\tregister struct bpf_insn *fcode = fp->bf_insns;\n\tunion {\n\t\tstruct packet_header hdr;\n\t\tu_char\tp[BUFSPACE];\n\t\tu_short\ts;\n\t} buf;\n\n\twhile (1) {\n\t\tif ((cc = read(if_fd, (char *)buf.p, sizeof(buf))) < 0)\n\t\t\tefReadError(if_fd, \"reader\");\n\n#ifdef\tIBMRTPC\n\t\t/*\n\t\t * Loop through each packet.\n\t\t */\n\t\tbp = buf.p;\n\t\twhile (cc > 0) {\n\t\t\tph = (struct packet_header *)bp;\n\t\t\tcaplen = ph->tap.th_wirelen > snaplen ? snaplen : ph->tap\n.th_wirelen ;\n\t\t\tif (pcap_filter(fcode, (char *)ph->packet,\n\t\t\t\t\t\tph->tap.th_wirelen, caplen)) {\n\t\t\t\tif (cnt >= 0 && --cnt < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\t(*printit)((char *)ph->packet,\n\t\t\t\t\t(struct timeval *)ph->tap.th_timestamp,\n\t\t\t\t\tph->tap.th_wirelen, caplen);\n\t\t\t}\n\t\t\tinc = ph->length.PacketOffset;\n\t\t\tcc -= inc;\n\t\t\tbp += inc;\n\t\t}\n#else\t/* !IBMRTPC */\n\t\tcaplen = cc > snaplen ? snaplen : cc ;\n\t\tif (pcap_filter(fcode, buf.hdr.packet, cc, caplen)) {\n\t\t\tif (cnt >= 0 && --cnt < 0)\n\t\t\t\tgoto out;\n\t\t\t(*printit)(buf.hdr.packet, &tv, cc, caplen);\n\t\t}\n#endif\t/* IBMRTPC */\n\t}\n out:\n\twrapup(if_fd);\n}",
          "fn_code_pos": [
            [
              46,
              0
            ],
            [
              100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readloop",
            "parameters": {
              "cnt": "int",
              "if_fd": "int",
              "fp": "struct bpf_program",
              "printit": "printfunc"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nefReadError(int fid, char *msg)\n{\n\tif (errno == EINVAL) {\t/* read MAXINT bytes already! */\n\t\tif (lseek(fid, 0, 0) < 0) {\n\t\t\tperror(\"tcpdump: efReadError/lseek\");\n\t\t\texit(-1);\n\t\t}\n\t\telse\n\t\t\treturn;\n\t}\n\telse {\n\t\t(void) fprintf(stderr, \"tcpdump: \");\n\t\tperror(msg);\n\t\texit(-1);\n\t}\n}",
          "fn_code_pos": [
            [
              103,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "efReadError",
            "parameters": {
              "fid": "int",
              "msg": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nwrapup(int fd)\n{\n#ifdef\tIBMRTPC\n\tstruct enstats es;\n\n\tif (ioctl(fd, EIOSTATS, &es) == -1) {\n\t\tperror(\"tcpdump: enet ioctl EIOSTATS error\");\n\t\texit(-1);\n\t}\n\n\tfprintf(stderr, \"%d packets queued\", es.enStat_Rcnt);\n\tif (es.enStat_Rdrops > 0)\n\t\tfprintf(stderr, \", %d dropped\", es.enStat_Rdrops);\n\tif (es.enStat_Reads > 0)\n\t\tfprintf(stderr, \", %d tcpdump %s\", es.enStat_Reads,\n\t\t\t\tes.enStat_Reads > 1 ? \"reads\" : \"read\");\n\tif (es.enStat_MaxRead > 1)\n\t\tfprintf(stderr, \", %d packets in largest read\",\n\t\t\tes.enStat_MaxRead);\n\tputc('\\n', stderr);\n#endif\t/* IBMRTPC */\n\tclose(fd);\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "wrapup",
            "parameters": {
              "fd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\ninitdevice(char *device, int pflag, int *linktype)\n{\n\tstruct eniocb ctl;\n\tstruct enfilter filter;\n\tu_int maxwaiting;\n\tint if_fd;\n\n#ifdef\tIBMRTPC\n\tGETENETDEVICE(0, O_RDONLY, &if_fd);\n#else\t/* !IBMRTPC */\n\tif_fd = open(\"/dev/enet\", O_RDONLY, 0);\n#endif\t/* IBMRTPC */\n\n\tif (if_fd == -1) {\n\t\tperror(\"tcpdump: enet open error\");\n\t\terror(\n\"your system may not be properly configured; see \\\"man enet(4)\\\"\");\n\t\texit(-1);\n\t}\n\n\t/*  Get operating parameters. */\n\n\tif (ioctl(if_fd, EIOCGETP, (char *)&ctl) == -1) {\n\t\tperror(\"tcpdump: enet ioctl EIOCGETP error\");\n\t\texit(-1);\n\t}\n\n\t/*  Set operating parameters. */\n\n#ifdef\tIBMRTPC\n\tctl.en_rtout = 1 * ctl.en_hz;\n\tctl.en_tr_etherhead = 1;\n\tctl.en_tap_network = 1;\n\tctl.en_multi_packet = 1;\n\tctl.en_maxlen = BUFSPACE;\n#else\t/* !IBMRTPC */\n\tctl.en_rtout = 64;\t/* randomly picked value for HZ */\n#endif\t/* IBMRTPC */\n\tif (ioctl(if_fd, EIOCSETP, &ctl) == -1) {\n\t\tperror(\"tcpdump: enet ioctl EIOCSETP error\");\n\t\texit(-1);\n\t}\n\n\t/*  Flush the receive queue, since we've changed\n\t    the operating parameters and we otherwise might\n\t    receive data without headers. */\n\n\tif (ioctl(if_fd, EIOCFLUSH) == -1) {\n\t\tperror(\"tcpdump: enet ioctl EIOCFLUSH error\");\n\t\texit(-1);\n\t}\n\n\t/*  Set the receive queue depth to its maximum. */\n\n\tmaxwaiting = ctl.en_maxwaiting;\n\tif (ioctl(if_fd, EIOCSETW, &maxwaiting) == -1) {\n\t\tperror(\"tcpdump: enet ioctl EIOCSETW error\");\n\t\texit(-1);\n\t}\n\n#ifdef\tIBMRTPC\n\t/*  Clear statistics. */\n\n\tif (ioctl(if_fd, EIOCLRSTAT, 0) == -1) {\n\t\tperror(\"tcpdump: enet ioctl EIOCLRSTAT error\");\n\t\texit(-1);\n\t}\n#endif\t/* IBMRTPC */\n\n\t/*  Set the filter (accept all packets). */\n\n\tfilter.enf_Priority = 3;\n\tfilter.enf_FilterLen = 0;\n\tif (ioctl(if_fd, EIOCSETF, &filter) == -1) {\n\t\tperror(\"tcpdump: enet ioctl EIOCSETF error\");\n\t\texit(-1);\n\t}\n\t/*\n\t * \"enetfilter\" supports only ethernets.\n\t */\n\t*linktype = DLT_EN10MB;\n\n\treturn(if_fd);\n}",
          "fn_code_pos": [
            [
              146,
              0
            ],
            [
              230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initdevice",
            "parameters": {
              "device": "char",
              "pflag": "int",
              "linktype": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "efReadError(int, char *)",
          "fn_dec_pos": [
            [
              44,
              12
            ],
            [
              44,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "efReadError",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct LengthWords",
          {},
          "",
          [
            33,
            1
          ],
          [
            33,
            19
          ]
        ],
        [
          "struct tap_header",
          {},
          "",
          [
            34,
            1
          ],
          [
            34,
            18
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            47,
            29
          ],
          [
            47,
            47
          ]
        ],
        [
          "struct packet_header",
          {},
          "",
          [
            50,
            10
          ],
          [
            50,
            30
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            54,
            8
          ],
          [
            54,
            22
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            57,
            10
          ],
          [
            57,
            25
          ]
        ],
        [
          "struct packet_header",
          {},
          "",
          [
            59,
            2
          ],
          [
            59,
            22
          ]
        ],
        [
          "struct packet_header",
          {},
          "",
          [
            74,
            9
          ],
          [
            74,
            29
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            82,
            6
          ],
          [
            82,
            20
          ]
        ],
        [
          "struct enstats",
          {},
          "",
          [
            125,
            1
          ],
          [
            125,
            15
          ]
        ],
        [
          "struct eniocb",
          {},
          "",
          [
            149,
            1
          ],
          [
            149,
            14
          ]
        ],
        [
          "struct enfilter",
          {},
          "",
          [
            150,
            1
          ],
          [
            150,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include <sys/file.h>\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include <sys/ioctl.h>\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ],
        [
          "#include <net/if.h>\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include <pcap/bpf.h>\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include <net/enet.h>\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <netinet/if_ether.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"interface.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-dbus.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\ndbus_read(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_dbus *handlep = handle->priv;\n\n\tstruct pcap_pkthdr pkth;\n\tDBusMessage *message;\n\n\tchar *raw_msg;\n\tint raw_msg_len;\n\n\tint count = 0;\n\n\tmessage = dbus_connection_pop_message(handlep->conn);\n\n\twhile (!message) {\n\t\t/* XXX handle->opt.timeout = timeout_ms; */\n\t\tif (!dbus_connection_read_write(handlep->conn, 100)) {\n\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Connection closed\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (handle->break_loop) {\n\t\t\thandle->break_loop = 0;\n\t\t\treturn -2;\n\t\t}\n\n\t\tmessage = dbus_connection_pop_message(handlep->conn);\n\t}\n\n\tif (dbus_message_is_signal(message, DBUS_INTERFACE_LOCAL, \"Disconnected\")) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Disconnected\");\n\t\treturn -1;\n\t}\n\n\tif (dbus_message_marshal(message, &raw_msg, &raw_msg_len)) {\n\t\tpkth.caplen = pkth.len = raw_msg_len;\n\t\t/* pkth.caplen = min (payload_len, handle->snapshot); */\n\n\t\tgettimeofday(&pkth.ts, NULL);\n\t\tif (handle->fcode.bf_insns == NULL ||\n\t\t    pcap_filter(handle->fcode.bf_insns, (u_char *)raw_msg, pkth.len, pkth.caplen)) {\n\t\t\thandlep->packets_read++;\n\t\t\tcallback(user, &pkth, (u_char *)raw_msg);\n\t\t\tcount++;\n\t\t}\n\n\t\tdbus_free(raw_msg);\n\t}\n\treturn count;\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              102,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dbus_read",
            "parameters": {
              "handle": "pcap_t",
              "max_packets": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndbus_write(pcap_t *handle, const void *buf, int size)\n{\n\t/* XXX, not tested */\n\tstruct pcap_dbus *handlep = handle->priv;\n\n\tDBusError error = DBUS_ERROR_INIT;\n\tDBusMessage *msg;\n\n\tif (!(msg = dbus_message_demarshal(buf, size, &error))) {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"dbus_message_demarshal() failed: %s\", error.message);\n\t\tdbus_error_free(&error);\n\t\treturn -1;\n\t}\n\n\tdbus_connection_send(handlep->conn, msg, NULL);\n\tdbus_connection_flush(handlep->conn);\n\n\tdbus_message_unref(msg);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              104,
              0
            ],
            [
              124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dbus_write",
            "parameters": {
              "handle": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndbus_stats(pcap_t *handle, struct pcap_stat *stats)\n{\n\tstruct pcap_dbus *handlep = handle->priv;\n\n\tstats->ps_recv = handlep->packets_read;\n\tstats->ps_drop = 0;\n\tstats->ps_ifdrop = 0;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              126,
              0
            ],
            [
              135,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dbus_stats",
            "parameters": {
              "handle": "pcap_t",
              "stats": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ndbus_cleanup(pcap_t *handle)\n{\n\tstruct pcap_dbus *handlep = handle->priv;\n\n\tdbus_connection_unref(handlep->conn);\n\n\tpcap_cleanup_live_common(handle);\n}",
          "fn_code_pos": [
            [
              137,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dbus_cleanup",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ndbus_getnonblock(pcap_t *p)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Non-blocking mode isn't supported for capturing on D-Bus\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              153,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dbus_getnonblock",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndbus_setnonblock(pcap_t *p, int nonblock _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Non-blocking mode isn't supported for capturing on D-Bus\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              161,
              0
            ],
            [
              167,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dbus_setnonblock",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndbus_activate(pcap_t *handle)\n{\n#define EAVESDROPPING_RULE \"eavesdrop=true,\"\n\n\tstatic const char *rules[] = {\n\t\tEAVESDROPPING_RULE \"type='signal'\",\n\t\tEAVESDROPPING_RULE \"type='method_call'\",\n\t\tEAVESDROPPING_RULE \"type='method_return'\",\n\t\tEAVESDROPPING_RULE \"type='error'\",\n\t};\n\n\t#define N_RULES sizeof(rules)/sizeof(rules[0])\n\n\tstruct pcap_dbus *handlep = handle->priv;\n\tconst char *dev = handle->opt.device;\n\n\tDBusError error = DBUS_ERROR_INIT;\n\tu_int i;\n\n\tif (strcmp(dev, \"dbus-system\") == 0) {\n\t\tif (!(handlep->conn = dbus_bus_get(DBUS_BUS_SYSTEM, &error))) {\n\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Failed to get system bus: %s\", error.message);\n\t\t\tdbus_error_free(&error);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\n\t} else if (strcmp(dev, \"dbus-session\") == 0) {\n\t\tif (!(handlep->conn = dbus_bus_get(DBUS_BUS_SESSION, &error))) {\n\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Failed to get session bus: %s\", error.message);\n\t\t\tdbus_error_free(&error);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\n\t} else if (strncmp(dev, \"dbus://\", 7) == 0) {\n\t\tconst char *addr = dev + 7;\n\n\t\tif (!(handlep->conn = dbus_connection_open(addr, &error))) {\n\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Failed to open connection to: %s: %s\", addr, error.message);\n\t\t\tdbus_error_free(&error);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\n\t\tif (!dbus_bus_register(handlep->conn, &error)) {\n\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Failed to register bus %s: %s\\n\", addr, error.message);\n\t\t\tdbus_error_free(&error);\n\t\t\treturn PCAP_ERROR;\n\t\t}\n\n\t} else {\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Can't get bus address from %s\", handle->opt.device);\n\t\treturn PCAP_ERROR;\n\t}\n\n\t/* Initialize some components of the pcap structure. */\n\thandle->bufsize = 0;\n\thandle->offset = 0;\n\thandle->linktype = DLT_DBUS;\n\thandle->read_op = dbus_read;\n\thandle->inject_op = dbus_write;\n\thandle->setfilter_op = install_bpf_program; /* XXX, later add support for dbus_bus_add_match() */\n\thandle->setdirection_op = NULL;\n\thandle->set_datalink_op = NULL;      /* can't change data link type */\n\thandle->getnonblock_op = dbus_getnonblock;\n\thandle->setnonblock_op = dbus_setnonblock;\n\thandle->stats_op = dbus_stats;\n\thandle->cleanup_op = dbus_cleanup;\n\n#ifndef _WIN32\n\t/*\n\t * Unfortunately, trying to do a select()/poll()/epoll_wait()/\n\t * kevent()/etc. on a D-Bus connection isn't a simple\n\t * case of \"give me an FD on which to wait\".\n\t *\n\t * Apparently, you have to register \"add watch\", \"remove watch\",\n\t * and \"toggle watch\" functions with\n\t * dbus_connection_set_watch_functions(),\n\t * keep a *set* of FDs, add to that set in the \"add watch\"\n\t * function, subtract from it in the \"remove watch\" function,\n\t * and either add to or subtract from that set in the \"toggle\n\t * watch\" function, and do the wait on *all* of the FDs in the\n\t * set.  (Yes, you need the \"toggle watch\" function, so that\n\t * the main loop doesn't itself need to check for whether\n\t * a given watch is enabled or disabled - most libpcap programs\n\t * know nothing about D-Bus and shouldn't *have* to know anything\n\t * about D-Bus other than how to decode D-Bus messages.)\n\t *\n\t * Implementing that would require considerable changes in\n\t * the way libpcap exports \"selectable FDs\" to its client.\n\t * Until that's done, we just say \"you can't do that\".\n\t */\n\thandle->selectable_fd = handle->fd = -1;\n#endif\n\n\tif (handle->opt.rfmon) {\n\t\t/*\n\t\t * Monitor mode doesn't apply to dbus connections.\n\t\t */\n\t\tdbus_cleanup(handle);\n\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum message length for D-Bus (128MB).\n\t */\n\tif (handle->snapshot <= 0 || handle->snapshot > 134217728)\n\t\thandle->snapshot = 134217728;\n\n\t/* dbus_connection_set_max_message_size(handlep->conn, handle->snapshot); */\n\tif (handle->opt.buffer_size != 0)\n\t\tdbus_connection_set_max_received_size(handlep->conn, handle->opt.buffer_size);\n\n\tfor (i = 0; i < N_RULES; i++) {\n\t\tdbus_bus_add_match(handlep->conn, rules[i], &error);\n\t\tif (dbus_error_is_set(&error)) {\n\t\t\tdbus_error_free(&error);\n\n\t\t\t/* try without eavesdrop */\n\t\t\tdbus_bus_add_match(handlep->conn, rules[i] + strlen(EAVESDROPPING_RULE), &error);\n\t\t\tif (dbus_error_is_set(&error)) {\n\t\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"Failed to add bus match: %s\\n\", error.message);\n\t\t\t\tdbus_error_free(&error);\n\t\t\t\tdbus_cleanup(handle);\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              169,
              0
            ],
            [
              300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dbus_activate",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\ndbus_create(const char *device, char *ebuf, int *is_ours)\n{\n\tpcap_t *p;\n\n\tif (strcmp(device, \"dbus-system\") &&\n\t\tstrcmp(device, \"dbus-session\") &&\n\t\tstrncmp(device, \"dbus://\", 7))\n\t{\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\t*is_ours = 1;\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_dbus));\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = dbus_activate;\n\t/*\n\t * Set these up front, so that, even if our client tries\n\t * to set non-blocking mode before we're activated, or\n\t * query the state of non-blocking mode, they get an error,\n\t * rather than having the non-blocking mode option set\n\t * for use later.\n\t */\n\tp->getnonblock_op = dbus_getnonblock;\n\tp->setnonblock_op = dbus_setnonblock;\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              302,
              0
            ],
            [
              331,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dbus_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "int\ndbus_findalldevs(pcap_if_list_t *devlistp, char *err_str)\n{\n\t/*\n\t * The notion of \"connected\" vs. \"disconnected\" doesn't apply.\n\t * XXX - what about the notions of \"up\" and \"running\"?\n\t */\n\tif (add_dev(devlistp, \"dbus-system\",\n\t    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE, \"D-Bus system bus\",\n\t    err_str) == NULL)\n\t\treturn -1;\n\tif (add_dev(devlistp, \"dbus-session\",\n\t    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE, \"D-Bus session bus\",\n\t    err_str) == NULL)\n\t\treturn -1;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              333,
              0
            ],
            [
              349,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dbus_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "err_str": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "dbus_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              303,
              0
            ],
            [
              303,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dbus_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_dbus {\n\tDBusConnection *conn;\n\tu_int\tpackets_read;\t/* count of packets read */\n}",
          {
            "*conn": "DBusConnection",
            "packets_read": "u_int"
          },
          "pcap_dbus",
          [
            47,
            0
          ],
          [
            50,
            1
          ]
        ],
        [
          "struct pcap_dbus {\n\tDBusConnection *conn;\n\tu_int\tpackets_read;\t/* count of packets read */\n}",
          {
            "*conn": "DBusConnection",
            "packets_read": "u_int"
          },
          "pcap_dbus",
          [
            47,
            0
          ],
          [
            50,
            1
          ]
        ],
        [
          "struct pcap_dbus",
          {},
          "",
          [
            55,
            1
          ],
          [
            55,
            17
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            57,
            1
          ],
          [
            57,
            19
          ]
        ],
        [
          "struct pcap_dbus",
          {},
          "",
          [
            108,
            1
          ],
          [
            108,
            17
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            127,
            27
          ],
          [
            127,
            43
          ]
        ],
        [
          "struct pcap_dbus",
          {},
          "",
          [
            129,
            1
          ],
          [
            129,
            17
          ]
        ],
        [
          "struct pcap_dbus",
          {},
          "",
          [
            140,
            1
          ],
          [
            140,
            17
          ]
        ],
        [
          "struct pcap_dbus",
          {},
          "",
          [
            183,
            1
          ],
          [
            183,
            17
          ]
        ],
        [
          "struct pcap_dbus",
          {},
          "",
          [
            316,
            38
          ],
          [
            316,
            54
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <time.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <dbus/dbus.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include \"pcap-dbus.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-pf.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\npcap_read_pf(pcap_t *pc, int cnt, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_pf *pf = pc->priv;\n\tregister u_char *p, *bp;\n\tregister int cc, n, buflen, inc;\n\tregister struct enstamp *sp;\n\tstruct enstamp stamp;\n\tregister u_int pad;\n\n again:\n\tcc = pc->cc;\n\tif (cc == 0) {\n\t\tcc = read(pc->fd, (char *)pc->buffer + pc->offset, pc->bufsize);\n\t\tif (cc < 0) {\n\t\t\tif (errno == EWOULDBLOCK)\n\t\t\t\treturn (0);\n\t\t\tif (errno == EINVAL &&\n\t\t\t    lseek(pc->fd, 0L, SEEK_CUR) + pc->bufsize < 0) {\n\t\t\t\t/*\n\t\t\t\t * Due to a kernel bug, after 2^31 bytes,\n\t\t\t\t * the kernel file offset overflows and\n\t\t\t\t * read fails with EINVAL. The lseek()\n\t\t\t\t * to 0 will fix things.\n\t\t\t\t */\n\t\t\t\t(void)lseek(pc->fd, 0L, SEEK_SET);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tpcap_fmt_errmsg_for_errno(pc->errbuf,\n\t\t\t    sizeof(pc->errbuf), errno, \"pf read\");\n\t\t\treturn (-1);\n\t\t}\n\t\tbp = (u_char *)pc->buffer + pc->offset;\n\t} else\n\t\tbp = pc->bp;\n\t/*\n\t * Loop through each packet.\n\t */\n\tn = 0;\n\tpad = pc->fddipad;\n\twhile (cc > 0) {\n\t\t/*\n\t\t * Has \"pcap_breakloop()\" been called?\n\t\t * If so, return immediately - if we haven't read any\n\t\t * packets, clear the flag and return -2 to indicate\n\t\t * that we were told to break out of the loop, otherwise\n\t\t * leave the flag set, so that the *next* call will break\n\t\t * out of the loop without having read any packets, and\n\t\t * return the number of packets we've processed so far.\n\t\t */\n\t\tif (pc->break_loop) {\n\t\t\tif (n == 0) {\n\t\t\t\tpc->break_loop = 0;\n\t\t\t\treturn (-2);\n\t\t\t} else {\n\t\t\t\tpc->cc = cc;\n\t\t\t\tpc->bp = bp;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t}\n\t\tif (cc < sizeof(*sp)) {\n\t\t\tpcap_snprintf(pc->errbuf, sizeof(pc->errbuf),\n\t\t\t    \"pf short read (%d)\", cc);\n\t\t\treturn (-1);\n\t\t}\n\t\tif ((long)bp & 3) {\n\t\t\tsp = &stamp;\n\t\t\tmemcpy((char *)sp, (char *)bp, sizeof(*sp));\n\t\t} else\n\t\t\tsp = (struct enstamp *)bp;\n\t\tif (sp->ens_stamplen != sizeof(*sp)) {\n\t\t\tpcap_snprintf(pc->errbuf, sizeof(pc->errbuf),\n\t\t\t    \"pf short stamplen (%d)\",\n\t\t\t    sp->ens_stamplen);\n\t\t\treturn (-1);\n\t\t}\n\n\t\tp = bp + sp->ens_stamplen;\n\t\tbuflen = sp->ens_count;\n\t\tif (buflen > pc->snapshot)\n\t\t\tbuflen = pc->snapshot;\n\n\t\t/* Calculate inc before possible pad update */\n\t\tinc = ENALIGN(buflen + sp->ens_stamplen);\n\t\tcc -= inc;\n\t\tbp += inc;\n\t\tpf->TotPkts++;\n\t\tpf->TotDrops += sp->ens_dropped;\n\t\tpf->TotMissed = sp->ens_ifoverflows;\n\t\tif (pf->OrigMissed < 0)\n\t\t\tpf->OrigMissed = pf->TotMissed;\n\n\t\t/*\n\t\t * Short-circuit evaluation: if using BPF filter\n\t\t * in kernel, no need to do it now - we already know\n\t\t * the packet passed the filter.\n\t\t *\n\t\t * Note: the filter code was generated assuming\n\t\t * that pc->fddipad was the amount of padding\n\t\t * before the header, as that's what's required\n\t\t * in the kernel, so we run the filter before\n\t\t * skipping that padding.\n\t\t */\n\t\tif (pf->filtering_in_kernel ||\n\t\t    pcap_filter(pc->fcode.bf_insns, p, sp->ens_count, buflen)) {\n\t\t\tstruct pcap_pkthdr h;\n\t\t\tpf->TotAccepted++;\n\t\t\th.ts = sp->ens_tstamp;\n\t\t\th.len = sp->ens_count - pad;\n\t\t\tp += pad;\n\t\t\tbuflen -= pad;\n\t\t\th.caplen = buflen;\n\t\t\t(*callback)(user, &h, p);\n\t\t\tif (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt)) {\n\t\t\t\tpc->cc = cc;\n\t\t\t\tpc->bp = bp;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t}\n\t}\n\tpc->cc = 0;\n\treturn (n);\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              221,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_pf",
            "parameters": {
              "pc": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_inject_pf(pcap_t *p, const void *buf, int size)\n{\n\tint ret;\n\n\tret = write(p->fd, buf, size);\n\tif (ret == -1) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"send\");\n\t\treturn (-1);\n\t}\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              223,
              0
            ],
            [
              235,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject_pf",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_stats_pf(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct pcap_pf *pf = p->priv;\n\n\t/*\n\t * If packet filtering is being done in the kernel:\n\t *\n\t *\t\"ps_recv\" counts only packets that passed the filter.\n\t *\tThis does not include packets dropped because we\n\t *\tran out of buffer space.  (XXX - perhaps it should,\n\t *\tby adding \"ps_drop\" to \"ps_recv\", for compatibility\n\t *\twith some other platforms.  On the other hand, on\n\t *\tsome platforms \"ps_recv\" counts only packets that\n\t *\tpassed the filter, and on others it counts packets\n\t *\tthat didn't pass the filter....)\n\t *\n\t *\t\"ps_drop\" counts packets that passed the kernel filter\n\t *\t(if any) but were dropped because the input queue was\n\t *\tfull.\n\t *\n\t *\t\"ps_ifdrop\" counts packets dropped by the network\n\t *\tinteface (regardless of whether they would have passed\n\t *\tthe input filter, of course).\n\t *\n\t * If packet filtering is not being done in the kernel:\n\t *\n\t *\t\"ps_recv\" counts only packets that passed the filter.\n\t *\n\t *\t\"ps_drop\" counts packets that were dropped because the\n\t *\tinput queue was full, regardless of whether they passed\n\t *\tthe userland filter.\n\t *\n\t *\t\"ps_ifdrop\" counts packets dropped by the network\n\t *\tinteface (regardless of whether they would have passed\n\t *\tthe input filter, of course).\n\t *\n\t * These statistics don't include packets not yet read from\n\t * the kernel by libpcap, but they may include packets not\n\t * yet read from libpcap by the application.\n\t */\n\tps->ps_recv = pf->TotAccepted;\n\tps->ps_drop = pf->TotDrops;\n\tps->ps_ifdrop = pf->TotMissed - pf->OrigMissed;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              237,
              0
            ],
            [
              282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_pf",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_activate_pf(pcap_t *p)\n{\n\tstruct pcap_pf *pf = p->priv;\n\tshort enmode;\n\tint backlog = -1;\t/* request the most */\n\tstruct enfilter Filter;\n\tstruct endevp devparams;\n\tint err;\n\n\t/*\n\t * Initially try a read/write open (to allow the inject\n\t * method to work).  If that fails due to permission\n\t * issues, fall back to read-only.  This allows a\n\t * non-root user to be granted specific access to pcap\n\t * capabilities via file permissions.\n\t *\n\t * XXX - we should have an API that has a flag that\n\t * controls whether to open read-only or read-write,\n\t * so that denial of permission to send (or inability\n\t * to send, if sending packets isn't supported on\n\t * the device in question) can be indicated at open\n\t * time.\n\t *\n\t * XXX - we assume here that \"pfopen()\" does not, in fact, modify\n\t * its argument, even though it takes a \"char *\" rather than a\n\t * \"const char *\" as its first argument.  That appears to be\n\t * the case, at least on Digital UNIX 4.0.\n\t *\n\t * XXX - is there an error that means \"no such device\"?  Is\n\t * there one that means \"that device doesn't support pf\"?\n\t */\n\tp->fd = pfopen(p->opt.device, O_RDWR);\n\tif (p->fd == -1 && errno == EACCES)\n\t\tp->fd = pfopen(p->opt.device, O_RDONLY);\n\tif (p->fd < 0) {\n\t\tif (errno == EACCES) {\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"pf open: %s: Permission denied\\n\"\n\"your system may not be properly configured; see the packetfilter(4) man page\",\n\t\t\t    p->opt.device);\n\t\t\terr = PCAP_ERROR_PERM_DENIED;\n\t\t} else {\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"pf open: %s\", p->opt.device);\n\t\t\terr = PCAP_ERROR;\n\t\t}\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n\tpf->OrigMissed = -1;\n\tenmode = ENTSTAMP|ENNONEXCL;\n\tif (!p->opt.immediate)\n\t\tenmode |= ENBATCH;\n\tif (p->opt.promisc)\n\t\tenmode |= ENPROMISC;\n\tif (ioctl(p->fd, EIOCMBIS, (caddr_t)&enmode) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"EIOCMBIS\");\n\t\terr = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n#ifdef\tENCOPYALL\n\t/* Try to set COPYALL mode so that we see packets to ourself */\n\tenmode = ENCOPYALL;\n\t(void)ioctl(p->fd, EIOCMBIS, (caddr_t)&enmode);/* OK if this fails */\n#endif\n\t/* set the backlog */\n\tif (ioctl(p->fd, EIOCSETW, (caddr_t)&backlog) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"EIOCSETW\");\n\t\terr = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\t/* discover interface type */\n\tif (ioctl(p->fd, EIOCDEVP, (caddr_t)&devparams) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"EIOCDEVP\");\n\t\terr = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\t/* HACK: to compile prior to Ultrix 4.2 */\n#ifndef\tENDT_FDDI\n#define\tENDT_FDDI\t4\n#endif\n\tswitch (devparams.end_dev_type) {\n\n\tcase ENDT_10MB:\n\t\tp->linktype = DLT_EN10MB;\n\t\tp->offset = 2;\n\t\t/*\n\t\t * This is (presumably) a real Ethernet capture; give it a\n\t\t * link-layer-type list with DLT_EN10MB and DLT_DOCSIS, so\n\t\t * that an application can let you choose it, in case you're\n\t\t * capturing DOCSIS traffic that a Cisco Cable Modem\n\t\t * Termination System is putting out onto an Ethernet (it\n\t\t * doesn't put an Ethernet header onto the wire, it puts raw\n\t\t * DOCSIS frames out on the wire inside the low-level\n\t\t * Ethernet framing).\n\t\t */\n\t\tp->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);\n\t\t/*\n\t\t * If that fails, just leave the list empty.\n\t\t */\n\t\tif (p->dlt_list != NULL) {\n\t\t\tp->dlt_list[0] = DLT_EN10MB;\n\t\t\tp->dlt_list[1] = DLT_DOCSIS;\n\t\t\tp->dlt_count = 2;\n\t\t}\n\t\tbreak;\n\n\tcase ENDT_FDDI:\n\t\tp->linktype = DLT_FDDI;\n\t\tbreak;\n\n#ifdef ENDT_SLIP\n\tcase ENDT_SLIP:\n\t\tp->linktype = DLT_SLIP;\n\t\tbreak;\n#endif\n\n#ifdef ENDT_PPP\n\tcase ENDT_PPP:\n\t\tp->linktype = DLT_PPP;\n\t\tbreak;\n#endif\n\n#ifdef ENDT_LOOPBACK\n\tcase ENDT_LOOPBACK:\n\t\t/*\n\t\t * It appears to use Ethernet framing, at least on\n\t\t * Digital UNIX 4.0.\n\t\t */\n\t\tp->linktype = DLT_EN10MB;\n\t\tp->offset = 2;\n\t\tbreak;\n#endif\n\n#ifdef ENDT_TRN\n\tcase ENDT_TRN:\n\t\tp->linktype = DLT_IEEE802;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\t/*\n\t\t * XXX - what about ENDT_IEEE802?  The pfilt.h header\n\t\t * file calls this \"IEEE 802 networks (non-Ethernet)\",\n\t\t * but that doesn't specify a specific link layer type;\n\t\t * it could be 802.4, or 802.5 (except that 802.5 is\n\t\t * ENDT_TRN), or 802.6, or 802.11, or....  That's why\n\t\t * DLT_IEEE802 was hijacked to mean Token Ring in various\n\t\t * BSDs, and why we went along with that hijacking.\n\t\t *\n\t\t * XXX - what about ENDT_HDLC and ENDT_NULL?\n\t\t * Presumably, as ENDT_OTHER is just \"Miscellaneous\n\t\t * framing\", there's not much we can do, as that\n\t\t * doesn't specify a particular type of header.\n\t\t */\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unknown data-link type %u\", devparams.end_dev_type);\n\t\terr = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\t/* set truncation */\n\tif (p->linktype == DLT_FDDI) {\n\t\tp->fddipad = PCAP_FDDIPAD;\n\n\t\t/* packetfilter includes the padding in the snapshot */\n\t\tp->snapshot += PCAP_FDDIPAD;\n\t} else\n\t\tp->fddipad = 0;\n\tif (ioctl(p->fd, EIOCTRUNCATE, (caddr_t)&p->snapshot) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"EIOCTRUNCATE\");\n\t\terr = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\t/* accept all packets */\n\tmemset(&Filter, 0, sizeof(Filter));\n\tFilter.enf_Priority = 37;\t/* anything > 2 */\n\tFilter.enf_FilterLen = 0;\t/* means \"always true\" */\n\tif (ioctl(p->fd, EIOCSETF, (caddr_t)&Filter) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"EIOCSETF\");\n\t\terr = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\tif (p->opt.timeout != 0) {\n\t\tstruct timeval timeout;\n\t\ttimeout.tv_sec = p->opt.timeout / 1000;\n\t\ttimeout.tv_usec = (p->opt.timeout * 1000) % 1000000;\n\t\tif (ioctl(p->fd, EIOCSRTIMEOUT, (caddr_t)&timeout) < 0) {\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"EIOCSRTIMEOUT\");\n\t\t\terr = PCAP_ERROR;\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\tp->bufsize = BUFSPACE;\n\tp->buffer = malloc(p->bufsize + p->offset);\n\tif (p->buffer == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\terr = PCAP_ERROR;\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * \"select()\" and \"poll()\" work on packetfilter devices.\n\t */\n\tp->selectable_fd = p->fd;\n\n\tp->read_op = pcap_read_pf;\n\tp->inject_op = pcap_inject_pf;\n\tp->setfilter_op = pcap_setfilter_pf;\n\tp->setdirection_op = NULL;\t/* Not implemented. */\n\tp->set_datalink_op = NULL;\t/* can't change data link type */\n\tp->getnonblock_op = pcap_getnonblock_fd;\n\tp->setnonblock_op = pcap_setnonblock_fd;\n\tp->stats_op = pcap_stats_pf;\n\n\treturn (0);\n bad:\n\tpcap_cleanup_live_common(p);\n\treturn (err);\n}",
          "fn_code_pos": [
            [
              292,
              0
            ],
            [
              531,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_activate_pf",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_create_interface(const char *device _U_, char *ebuf)\n{\n\tpcap_t *p;\n\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_pf));\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = pcap_activate_pf;\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              533,
              0
            ],
            [
              544,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static int\ncan_be_bound(const char *name _U_)\n{\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              550,
              0
            ],
            [
              554,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "can_be_bound",
            "parameters": {
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nget_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)\n{\n\t/*\n\t * Nothing we can do other than mark loopback devices as \"the\n\t * connected/disconnected status doesn't apply\".\n\t *\n\t * XXX - is there a way to find out whether an adapter has\n\t * something plugged into it?\n\t */\n\tif (*flags & PCAP_IF_LOOPBACK) {\n\t\t/*\n\t\t * Loopback devices aren't wireless, and \"connected\"/\n\t\t * \"disconnected\" doesn't apply to them.\n\t\t */\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\t\treturn (0);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              556,
              0
            ],
            [
              575,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_if_flags",
            "parameters": {
              "name": "char",
              "flags": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\treturn (pcap_findalldevs_interfaces(devlistp, errbuf, can_be_bound,\n\t    get_if_flags));\n}",
          "fn_code_pos": [
            [
              577,
              0
            ],
            [
              582,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_platform_finddevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setfilter_pf(pcap_t *p, struct bpf_program *fp)\n{\n\tstruct pcap_pf *pf = p->priv;\n\tstruct bpf_version bv;\n\n\t/*\n\t * See if BIOCVERSION works.  If not, we assume the kernel doesn't\n\t * support BPF-style filters (it's not documented in the bpf(7)\n\t * or packetfiler(7) man pages, but the code used to fail if\n\t * BIOCSETF worked but BIOCVERSION didn't, and I've seen it do\n\t * kernel filtering in DU 4.0, so presumably BIOCVERSION works\n\t * there, at least).\n\t */\n\tif (ioctl(p->fd, BIOCVERSION, (caddr_t)&bv) >= 0) {\n\t\t/*\n\t\t * OK, we have the version of the BPF interpreter;\n\t\t * is it the same major version as us, and the same\n\t\t * or better minor version?\n\t\t */\n\t\tif (bv.bv_major == BPF_MAJOR_VERSION &&\n\t\t    bv.bv_minor >= BPF_MINOR_VERSION) {\n\t\t\t/*\n\t\t\t * Yes.  Try to install the filter.\n\t\t\t */\n\t\t\tif (ioctl(p->fd, BIOCSETF, (caddr_t)fp) < 0) {\n\t\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf,\n\t\t\t\t    sizeof(p->errbuf), errno, \"BIOCSETF\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * OK, that succeeded.  We're doing filtering in\n\t\t\t * the kernel.  (We assume we don't have a\n\t\t\t * userland filter installed - that'd require\n\t\t\t * a previous version check to have failed but\n\t\t\t * this one to succeed.)\n\t\t\t *\n\t\t\t * XXX - this message should be supplied to the\n\t\t\t * application as a warning of some sort,\n\t\t\t * except that if it's a GUI application, it's\n\t\t\t * not clear that it should be displayed in\n\t\t\t * a window to annoy the user.\n\t\t\t */\n\t\t\tfprintf(stderr, \"tcpdump: Using kernel BPF filter\\n\");\n\t\t\tpf->filtering_in_kernel = 1;\n\n\t\t\t/*\n\t\t\t * Discard any previously-received packets,\n\t\t\t * as they might have passed whatever filter\n\t\t\t * was formerly in effect, but might not pass\n\t\t\t * this filter (BIOCSETF discards packets buffered\n\t\t\t * in the kernel, so you can lose packets in any\n\t\t\t * case).\n\t\t\t */\n\t\t\tp->cc = 0;\n\t\t\treturn (0);\n\t\t}\n\n\t\t/*\n\t\t * We can't use the kernel's BPF interpreter; don't give\n\t\t * up, just log a message and be inefficient.\n\t\t *\n\t\t * XXX - this should really be supplied to the application\n\t\t * as a warning of some sort.\n\t\t */\n\t\tfprintf(stderr,\n\t    \"tcpdump: Requires BPF language %d.%d or higher; kernel is %d.%d\\n\",\n\t\t    BPF_MAJOR_VERSION, BPF_MINOR_VERSION,\n\t\t    bv.bv_major, bv.bv_minor);\n\t}\n\n\t/*\n\t * We couldn't do filtering in the kernel; do it in userland.\n\t */\n\tif (install_bpf_program(p, fp) < 0)\n\t\treturn (-1);\n\n\t/*\n\t * XXX - this message should be supplied by the application as\n\t * a warning of some sort.\n\t */\n\tfprintf(stderr, \"tcpdump: Filtering in user process\\n\");\n\tpf->filtering_in_kernel = 0;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              584,
              0
            ],
            [
              669,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_pf",
            "parameters": {
              "p": "pcap_t",
              "fp": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING);\n}",
          "fn_code_pos": [
            [
              674,
              0
            ],
            [
              678,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "pcap_setfilter_pf(pcap_t *, struct bpf_program *)",
          "fn_dec_pos": [
            [
              89,
              11
            ],
            [
              89,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_pf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_create_interface(const char *device _U_, char *ebuf)",
          "fn_dec_pos": [
            [
              534,
              0
            ],
            [
              534,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              675,
              0
            ],
            [
              675,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_pf {\n\tint\tfiltering_in_kernel; /* using kernel filter */\n\tu_long\tTotPkts;\t/* can't oflow for 79 hrs on ether */\n\tu_long\tTotAccepted;\t/* count accepted by filter */\n\tu_long\tTotDrops;\t/* count of dropped packets */\n\tlong\tTotMissed;\t/* missed by i/f during this run */\n\tlong\tOrigMissed;\t/* missed by i/f before this run */\n}",
          {
            "filtering_in_kernel": "int",
            "TotPkts": "u_long",
            "TotAccepted": "u_long",
            "TotDrops": "u_long",
            "TotMissed": "long",
            "OrigMissed": "long"
          },
          "pcap_pf",
          [
            80,
            0
          ],
          [
            87,
            1
          ]
        ],
        [
          "struct mbuf",
          {},
          "",
          [
            36,
            0
          ],
          [
            36,
            11
          ]
        ],
        [
          "struct rtentry",
          {},
          "",
          [
            37,
            0
          ],
          [
            37,
            14
          ]
        ],
        [
          "struct pcap_pf {\n\tint\tfiltering_in_kernel; /* using kernel filter */\n\tu_long\tTotPkts;\t/* can't oflow for 79 hrs on ether */\n\tu_long\tTotAccepted;\t/* count accepted by filter */\n\tu_long\tTotDrops;\t/* count of dropped packets */\n\tlong\tTotMissed;\t/* missed by i/f during this run */\n\tlong\tOrigMissed;\t/* missed by i/f before this run */\n}",
          {
            "filtering_in_kernel": "int",
            "TotPkts": "u_long",
            "TotAccepted": "u_long",
            "TotDrops": "u_long",
            "TotMissed": "long",
            "OrigMissed": "long"
          },
          "pcap_pf",
          [
            80,
            0
          ],
          [
            87,
            1
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            89,
            39
          ],
          [
            89,
            57
          ]
        ],
        [
          "struct pcap_pf",
          {},
          "",
          [
            102,
            1
          ],
          [
            102,
            15
          ]
        ],
        [
          "struct enstamp",
          {},
          "",
          [
            105,
            10
          ],
          [
            105,
            24
          ]
        ],
        [
          "struct enstamp",
          {},
          "",
          [
            106,
            1
          ],
          [
            106,
            15
          ]
        ],
        [
          "struct enstamp",
          {},
          "",
          [
            168,
            9
          ],
          [
            168,
            23
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            204,
            3
          ],
          [
            204,
            21
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            238,
            25
          ],
          [
            238,
            41
          ]
        ],
        [
          "struct pcap_pf",
          {},
          "",
          [
            240,
            1
          ],
          [
            240,
            15
          ]
        ],
        [
          "struct pcap_pf",
          {},
          "",
          [
            295,
            1
          ],
          [
            295,
            15
          ]
        ],
        [
          "struct enfilter",
          {},
          "",
          [
            298,
            1
          ],
          [
            298,
            16
          ]
        ],
        [
          "struct endevp",
          {},
          "",
          [
            299,
            1
          ],
          [
            299,
            14
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            493,
            2
          ],
          [
            493,
            16
          ]
        ],
        [
          "struct pcap_pf",
          {},
          "",
          [
            538,
            38
          ],
          [
            538,
            52
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            585,
            29
          ],
          [
            585,
            47
          ]
        ],
        [
          "struct pcap_pf",
          {},
          "",
          [
            587,
            1
          ],
          [
            587,
            15
          ]
        ],
        [
          "struct bpf_version",
          {},
          "",
          [
            588,
            1
          ],
          [
            588,
            19
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <sys/timeb.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <sys/file.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <sys/ioctl.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <net/pfilt.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <net/if.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <netinet/in_systm.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <netinet/ip.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <netinet/if_ether.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <netinet/ip_var.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <netinet/udp.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <netinet/udp_var.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <netinet/tcp.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <netinet/tcpip.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include <netdb.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include <net/bpf.h>\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            65,
            0
          ],
          [
            66,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            68,
            0
          ],
          [
            69,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/bpf_filter.c": {
      "fn_def_list": [
        {
          "fn_code": "u_int\npcap_filter_with_aux_data(const struct bpf_insn *pc, const u_char *p,\n    u_int wirelen, u_int buflen, const struct bpf_aux_data *aux_data _U_)\n#endif\n{\n\tregister uint32_t A, X;\n\tregister bpf_u_int32 k;\n\tuint32_t mem[BPF_MEMWORDS];\n\n\tif (pc == 0)\n\t\t/*\n\t\t * No filter means accept all.\n\t\t */\n\t\treturn (u_int)-1;\n\tA = 0;\n\tX = 0;\n\t--pc;\n\tfor (;;) {\n\t\t++pc;\n\t\tswitch (pc->code) {\n\n\t\tdefault:\n\t\t\tabort();\n\t\tcase BPF_RET|BPF_K:\n\t\t\treturn (u_int)pc->k;\n\n\t\tcase BPF_RET|BPF_A:\n\t\t\treturn (u_int)A;\n\n\t\tcase BPF_LD|BPF_W|BPF_ABS:\n\t\t\tk = pc->k;\n\t\t\tif (k > buflen || sizeof(int32_t) > buflen - k) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tA = EXTRACT_LONG(&p[k]);\n\t\t\tcontinue;\n\n\t\tcase BPF_LD|BPF_H|BPF_ABS:\n\t\t\tk = pc->k;\n\t\t\tif (k > buflen || sizeof(int16_t) > buflen - k) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tA = EXTRACT_SHORT(&p[k]);\n\t\t\tcontinue;\n\n\t\tcase BPF_LD|BPF_B|BPF_ABS:\n\t\t\tswitch (pc->k) {\n\n#if defined(SKF_AD_VLAN_TAG_PRESENT)\n\t\t\tcase SKF_AD_OFF + SKF_AD_VLAN_TAG:\n\t\t\t\tif (!aux_data)\n\t\t\t\t\treturn 0;\n\t\t\t\tA = aux_data->vlan_tag;\n\t\t\t\tbreak;\n\n\t\t\tcase SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT:\n\t\t\t\tif (!aux_data)\n\t\t\t\t\treturn 0;\n\t\t\t\tA = aux_data->vlan_tag_present;\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tk = pc->k;\n\t\t\t\tif (k >= buflen) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tA = p[k];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\n\t\tcase BPF_LD|BPF_W|BPF_LEN:\n\t\t\tA = wirelen;\n\t\t\tcontinue;\n\n\t\tcase BPF_LDX|BPF_W|BPF_LEN:\n\t\t\tX = wirelen;\n\t\t\tcontinue;\n\n\t\tcase BPF_LD|BPF_W|BPF_IND:\n\t\t\tk = X + pc->k;\n\t\t\tif (pc->k > buflen || X > buflen - pc->k ||\n\t\t\t    sizeof(int32_t) > buflen - k) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tA = EXTRACT_LONG(&p[k]);\n\t\t\tcontinue;\n\n\t\tcase BPF_LD|BPF_H|BPF_IND:\n\t\t\tk = X + pc->k;\n\t\t\tif (X > buflen || pc->k > buflen - X ||\n\t\t\t    sizeof(int16_t) > buflen - k) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tA = EXTRACT_SHORT(&p[k]);\n\t\t\tcontinue;\n\n\t\tcase BPF_LD|BPF_B|BPF_IND:\n\t\t\tk = X + pc->k;\n\t\t\tif (pc->k >= buflen || X >= buflen - pc->k) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tA = p[k];\n\t\t\tcontinue;\n\n\t\tcase BPF_LDX|BPF_MSH|BPF_B:\n\t\t\tk = pc->k;\n\t\t\tif (k >= buflen) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tX = (p[pc->k] & 0xf) << 2;\n\t\t\tcontinue;\n\n\t\tcase BPF_LD|BPF_IMM:\n\t\t\tA = pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_LDX|BPF_IMM:\n\t\t\tX = pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_LD|BPF_MEM:\n\t\t\tA = mem[pc->k];\n\t\t\tcontinue;\n\n\t\tcase BPF_LDX|BPF_MEM:\n\t\t\tX = mem[pc->k];\n\t\t\tcontinue;\n\n\t\tcase BPF_ST:\n\t\t\tmem[pc->k] = A;\n\t\t\tcontinue;\n\n\t\tcase BPF_STX:\n\t\t\tmem[pc->k] = X;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JA:\n\t\t\t/*\n\t\t\t * XXX - we currently implement \"ip6 protochain\"\n\t\t\t * with backward jumps, so sign-extend pc->k.\n\t\t\t */\n\t\t\tpc += (bpf_int32)pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JGT|BPF_K:\n\t\t\tpc += (A > pc->k) ? pc->jt : pc->jf;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JGE|BPF_K:\n\t\t\tpc += (A >= pc->k) ? pc->jt : pc->jf;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JEQ|BPF_K:\n\t\t\tpc += (A == pc->k) ? pc->jt : pc->jf;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JSET|BPF_K:\n\t\t\tpc += (A & pc->k) ? pc->jt : pc->jf;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JGT|BPF_X:\n\t\t\tpc += (A > X) ? pc->jt : pc->jf;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JGE|BPF_X:\n\t\t\tpc += (A >= X) ? pc->jt : pc->jf;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JEQ|BPF_X:\n\t\t\tpc += (A == X) ? pc->jt : pc->jf;\n\t\t\tcontinue;\n\n\t\tcase BPF_JMP|BPF_JSET|BPF_X:\n\t\t\tpc += (A & X) ? pc->jt : pc->jf;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_ADD|BPF_X:\n\t\t\tA += X;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_SUB|BPF_X:\n\t\t\tA -= X;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_MUL|BPF_X:\n\t\t\tA *= X;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_DIV|BPF_X:\n\t\t\tif (X == 0)\n\t\t\t\treturn 0;\n\t\t\tA /= X;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_MOD|BPF_X:\n\t\t\tif (X == 0)\n\t\t\t\treturn 0;\n\t\t\tA %= X;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_AND|BPF_X:\n\t\t\tA &= X;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_OR|BPF_X:\n\t\t\tA |= X;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_XOR|BPF_X:\n\t\t\tA ^= X;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_LSH|BPF_X:\n\t\t\tif (X < 32)\n\t\t\t\tA <<= X;\n\t\t\telse\n\t\t\t\tA = 0;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_RSH|BPF_X:\n\t\t\tif (X < 32)\n\t\t\t\tA >>= X;\n\t\t\telse\n\t\t\t\tA = 0;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_ADD|BPF_K:\n\t\t\tA += pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_SUB|BPF_K:\n\t\t\tA -= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_MUL|BPF_K:\n\t\t\tA *= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_DIV|BPF_K:\n\t\t\tA /= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_MOD|BPF_K:\n\t\t\tA %= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_AND|BPF_K:\n\t\t\tA &= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_OR|BPF_K:\n\t\t\tA |= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_XOR|BPF_K:\n\t\t\tA ^= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_LSH|BPF_K:\n\t\t\tA <<= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_RSH|BPF_K:\n\t\t\tA >>= pc->k;\n\t\t\tcontinue;\n\n\t\tcase BPF_ALU|BPF_NEG:\n\t\t\t/*\n\t\t\t * Most BPF arithmetic is unsigned, but negation\n\t\t\t * can't be unsigned; respecify it as subtracting\n\t\t\t * the accumulator from 0U, so that 1) we don't\n\t\t\t * get compiler warnings about negating an unsigned\n\t\t\t * value and 2) don't get UBSan warnings about\n\t\t\t * the result of negating 0x80000000 being undefined.\n\t\t\t */\n\t\t\tA = (0U - A);\n\t\t\tcontinue;\n\n\t\tcase BPF_MISC|BPF_TAX:\n\t\t\tX = A;\n\t\t\tcontinue;\n\n\t\tcase BPF_MISC|BPF_TXA:\n\t\t\tA = X;\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              90,
              0
            ],
            [
              378,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_filter_with_aux_data",
            "parameters": {
              "pc": "struct bpf_insn",
              "p": "u_char",
              "wirelen": "u_int",
              "buflen": "u_int",
              "aux_data": "struct bpf_aux_data"
            },
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "u_int\npcap_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,\n    u_int buflen)\n{\n\treturn pcap_filter_with_aux_data(pc, p, wirelen, buflen, NULL);\n}",
          "fn_code_pos": [
            [
              380,
              0
            ],
            [
              385,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_filter",
            "parameters": {
              "pc": "struct bpf_insn",
              "p": "u_char",
              "wirelen": "u_int",
              "buflen": "u_int"
            },
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "int\npcap_validate_filter(const struct bpf_insn *f, int len)\n{\n\tu_int i, from;\n\tconst struct bpf_insn *p;\n\n\tif (len < 1)\n\t\treturn 0;\n\n\tfor (i = 0; i < (u_int)len; ++i) {\n\t\tp = &f[i];\n\t\tswitch (BPF_CLASS(p->code)) {\n\t\t/*\n\t\t * Check that memory operations use valid addresses.\n\t\t */\n\t\tcase BPF_LD:\n\t\tcase BPF_LDX:\n\t\t\tswitch (BPF_MODE(p->code)) {\n\t\t\tcase BPF_IMM:\n\t\t\t\tbreak;\n\t\t\tcase BPF_ABS:\n\t\t\tcase BPF_IND:\n\t\t\tcase BPF_MSH:\n\t\t\t\t/*\n\t\t\t\t * There's no maximum packet data size\n\t\t\t\t * in userland.  The runtime packet length\n\t\t\t\t * check suffices.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\tcase BPF_MEM:\n\t\t\t\tif (p->k >= BPF_MEMWORDS)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tcase BPF_LEN:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_ST:\n\t\tcase BPF_STX:\n\t\t\tif (p->k >= BPF_MEMWORDS)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase BPF_ALU:\n\t\t\tswitch (BPF_OP(p->code)) {\n\t\t\tcase BPF_ADD:\n\t\t\tcase BPF_SUB:\n\t\t\tcase BPF_MUL:\n\t\t\tcase BPF_OR:\n\t\t\tcase BPF_AND:\n\t\t\tcase BPF_XOR:\n\t\t\tcase BPF_LSH:\n\t\t\tcase BPF_RSH:\n\t\t\tcase BPF_NEG:\n\t\t\t\tbreak;\n\t\t\tcase BPF_DIV:\n\t\t\tcase BPF_MOD:\n\t\t\t\t/*\n\t\t\t\t * Check for constant division or modulus\n\t\t\t\t * by 0.\n\t\t\t\t */\n\t\t\t\tif (BPF_SRC(p->code) == BPF_K && p->k == 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_JMP:\n\t\t\t/*\n\t\t\t * Check that jumps are within the code block,\n\t\t\t * and that unconditional branches don't go\n\t\t\t * backwards as a result of an overflow.\n\t\t\t * Unconditional branches have a 32-bit offset,\n\t\t\t * so they could overflow; we check to make\n\t\t\t * sure they don't.  Conditional branches have\n\t\t\t * an 8-bit offset, and the from address is <=\n\t\t\t * BPF_MAXINSNS, and we assume that BPF_MAXINSNS\n\t\t\t * is sufficiently small that adding 255 to it\n\t\t\t * won't overflow.\n\t\t\t *\n\t\t\t * We know that len is <= BPF_MAXINSNS, and we\n\t\t\t * assume that BPF_MAXINSNS is < the maximum size\n\t\t\t * of a u_int, so that i + 1 doesn't overflow.\n\t\t\t *\n\t\t\t * For userland, we don't know that the from\n\t\t\t * or len are <= BPF_MAXINSNS, but we know that\n\t\t\t * from <= len, and, except on a 64-bit system,\n\t\t\t * it's unlikely that len, if it truly reflects\n\t\t\t * the size of the program we've been handed,\n\t\t\t * will be anywhere near the maximum size of\n\t\t\t * a u_int.  We also don't check for backward\n\t\t\t * branches, as we currently support them in\n\t\t\t * userland for the protochain operation.\n\t\t\t */\n\t\t\tfrom = i + 1;\n\t\t\tswitch (BPF_OP(p->code)) {\n\t\t\tcase BPF_JA:\n\t\t\t\tif (from + p->k >= (u_int)len)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tcase BPF_JEQ:\n\t\t\tcase BPF_JGT:\n\t\t\tcase BPF_JGE:\n\t\t\tcase BPF_JSET:\n\t\t\t\tif (from + p->jt >= (u_int)len || from + p->jf >= (u_int)len)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BPF_RET:\n\t\t\tbreak;\n\t\tcase BPF_MISC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn BPF_CLASS(f[len - 1].code) == BPF_RET;\n}",
          "fn_code_pos": [
            [
              398,
              0
            ],
            [
              520,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_validate_filter",
            "parameters": {
              "f": "struct bpf_insn",
              "len": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "u_int\nbpf_filter(const struct bpf_insn *pc, const u_char *p, u_int wirelen,\n    u_int buflen)\n{\n\treturn pcap_filter(pc, p, wirelen, buflen);\n}",
          "fn_code_pos": [
            [
              525,
              0
            ],
            [
              530,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_filter",
            "parameters": {
              "pc": "struct bpf_insn",
              "p": "u_char",
              "wirelen": "u_int",
              "buflen": "u_int"
            },
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "int\nbpf_validate(const struct bpf_insn *f, int len)\n{\n\treturn pcap_validate_filter(f, len);\n}",
          "fn_code_pos": [
            [
              532,
              0
            ],
            [
              536,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_validate",
            "parameters": {
              "f": "struct bpf_insn",
              "len": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "pcap_filter_with_aux_data(const struct bpf_insn *pc, const u_char *p,\n    u_int wirelen, u_int buflen, const struct bpf_aux_data *aux_data)",
          "fn_dec_pos": [
            [
              87,
              0
            ],
            [
              88,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_filter_with_aux_data",
            "parameters": {
              "pc": "struct bpf_insn",
              "p": "u_char",
              "wirelen": "u_int",
              "buflen": "u_int",
              "aux_data": "struct bpf_aux_data"
            },
            "return_type": "u_int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct bpf_insn",
          {},
          "",
          [
            87,
            32
          ],
          [
            87,
            47
          ]
        ],
        [
          "struct bpf_aux_data",
          {},
          "",
          [
            88,
            39
          ],
          [
            88,
            58
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            91,
            32
          ],
          [
            91,
            47
          ]
        ],
        [
          "struct bpf_aux_data",
          {},
          "",
          [
            92,
            39
          ],
          [
            92,
            58
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            381,
            18
          ],
          [
            381,
            33
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            399,
            27
          ],
          [
            399,
            42
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            402,
            7
          ],
          [
            402,
            22
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            526,
            17
          ],
          [
            526,
            32
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            533,
            19
          ],
          [
            533,
            34
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <pcap/pcap-inttypes.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"pcap-types.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include \"extract.h\"\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <sys/param.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <pcap-int.h>\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ],
        [
          "#include <linux/types.h>\n",
          [
            62,
            0
          ],
          [
            63,
            0
          ]
        ],
        [
          "#include <linux/if_packet.h>\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include <linux/filter.h>\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "enum {\n        BPF_S_ANC_NONE,\n        BPF_S_ANC_VLAN_TAG,\n        BPF_S_ANC_VLAN_TAG_PRESENT,\n}",
          {
            "BPF_S_ANC_NONE": "",
            "BPF_S_ANC_VLAN_TAG": "",
            "BPF_S_ANC_VLAN_TAG_PRESENT": ""
          },
          "",
          [
            67,
            0
          ],
          [
            71,
            1
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap.c": {
      "fn_def_list": [
        {
          "fn_code": "BOOL WINAPI DllMain(\n  HANDLE hinstDLL,\n  DWORD dwReason,\n  LPVOID lpvReserved\n)\n{\n\treturn (TRUE);\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              137,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DllMain",
            "parameters": {
              "hinstDLL": "HANDLE",
              "dwReason": "DWORD",
              "lpvReserved": "LPVOID"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "int\nwsockinit(void)\n{\n\tWORD wVersionRequested;\n\tWSADATA wsaData;\n\tstatic int err = -1;\n\tstatic int done = 0;\n\n\tif (done)\n\t\treturn (err);\n\n\twVersionRequested = MAKEWORD( 1, 1);\n\terr = WSAStartup( wVersionRequested, &wsaData );\n\tatexit ((void(*)(void))WSACleanup);\n\tdone = 1;\n\n\tif ( err != 0 )\n\t\terr = -1;\n\treturn (err);\n}",
          "fn_code_pos": [
            [
              144,
              0
            ],
            [
              163,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "wsockinit",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_wsockinit(void)\n{\n       return (wsockinit());\n}",
          "fn_code_pos": [
            [
              168,
              0
            ],
            [
              172,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_wsockinit",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\npcap_set_not_initialized_message(pcap_t *pcap)\n{\n\tif (pcap->activated) {\n\t\t/* A module probably forgot to set the function pointer */\n\t\t(void)pcap_snprintf(pcap->errbuf, sizeof(pcap->errbuf),\n\t\t    \"This operation isn't properly handled by that device\");\n\t\treturn;\n\t}\n\t/* in case the caller doesn't check for PCAP_ERROR_NOT_ACTIVATED */\n\t(void)pcap_snprintf(pcap->errbuf, sizeof(pcap->errbuf),\n\t    \"This handle hasn't been activated yet\");\n}",
          "fn_code_pos": [
            [
              188,
              0
            ],
            [
              200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_not_initialized_message",
            "parameters": {
              "pcap": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\npcap_read_not_initialized(pcap_t *pcap, int cnt _U_, pcap_handler callback _U_,\n    u_char *user _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}",
          "fn_code_pos": [
            [
              202,
              0
            ],
            [
              209,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_inject_not_initialized(pcap_t *pcap, const void * buf _U_, int size _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}",
          "fn_code_pos": [
            [
              211,
              0
            ],
            [
              217,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setfilter_not_initialized(pcap_t *pcap, struct bpf_program *fp _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}",
          "fn_code_pos": [
            [
              219,
              0
            ],
            [
              225,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "fp": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setdirection_not_initialized(pcap_t *pcap, pcap_direction_t d _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}",
          "fn_code_pos": [
            [
              227,
              0
            ],
            [
              233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setdirection_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "d": "pcap_direction_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_set_datalink_not_initialized(pcap_t *pcap, int dlt _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}",
          "fn_code_pos": [
            [
              235,
              0
            ],
            [
              241,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_datalink_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "dlt": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_getnonblock_not_initialized(pcap_t *pcap)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}",
          "fn_code_pos": [
            [
              243,
              0
            ],
            [
              249,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getnonblock_not_initialized",
            "parameters": {
              "pcap": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_stats_not_initialized(pcap_t *pcap, struct pcap_stat *ps _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}",
          "fn_code_pos": [
            [
              251,
              0
            ],
            [
              257,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "struct pcap_stat *\npcap_stats_ex_not_initialized(pcap_t *pcap, int *pcap_stat_size _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              260,
              0
            ],
            [
              265,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_ex_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "pcap_stat_size": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static int\npcap_setbuff_not_initialized(pcap_t *pcap, int dim _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}",
          "fn_code_pos": [
            [
              267,
              0
            ],
            [
              273,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setbuff_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "dim": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setmode_not_initialized(pcap_t *pcap, int mode _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}",
          "fn_code_pos": [
            [
              275,
              0
            ],
            [
              281,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setmode_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "mode": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setmintocopy_not_initialized(pcap_t *pcap, int size _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\t/* this means 'not initialized' */\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}",
          "fn_code_pos": [
            [
              283,
              0
            ],
            [
              289,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setmintocopy_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static HANDLE\npcap_getevent_not_initialized(pcap_t *pcap)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (INVALID_HANDLE_VALUE);\n}",
          "fn_code_pos": [
            [
              291,
              0
            ],
            [
              296,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getevent_not_initialized",
            "parameters": {
              "pcap": "pcap_t"
            },
            "return_type": "HANDLE"
          }
        },
        {
          "fn_code": "static int\npcap_oid_get_request_not_initialized(pcap_t *pcap, bpf_u_int32 oid _U_,\n    void *data _U_, size_t *lenp _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}",
          "fn_code_pos": [
            [
              298,
              0
            ],
            [
              304,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_oid_get_request_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "oid": "bpf_u_int32",
              "data": "void",
              "lenp": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_oid_set_request_not_initialized(pcap_t *pcap, bpf_u_int32 oid _U_,\n    const void *data _U_, size_t *lenp _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}",
          "fn_code_pos": [
            [
              306,
              0
            ],
            [
              312,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_oid_set_request_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "oid": "bpf_u_int32",
              "data": "void",
              "lenp": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static u_int\npcap_sendqueue_transmit_not_initialized(pcap_t *pcap, pcap_send_queue* queue, int sync)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              314,
              0
            ],
            [
              319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_sendqueue_transmit_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "queue": "pcap_send_queue",
              "sync": "int"
            },
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "static int\npcap_setuserbuffer_not_initialized(pcap_t *pcap, int size _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}",
          "fn_code_pos": [
            [
              321,
              0
            ],
            [
              326,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setuserbuffer_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_live_dump_not_initialized(pcap_t *pcap, char *filename _U_, int maxsize _U_,\n    int maxpacks _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}",
          "fn_code_pos": [
            [
              328,
              0
            ],
            [
              334,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_live_dump_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "filename": "char",
              "maxsize": "int",
              "maxpacks": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_live_dump_ended_not_initialized(pcap_t *pcap, int sync _U_)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (PCAP_ERROR_NOT_ACTIVATED);\n}",
          "fn_code_pos": [
            [
              336,
              0
            ],
            [
              341,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_live_dump_ended_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "sync": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static PAirpcapHandle\npcap_get_airpcap_handle_not_initialized(pcap_t *pcap)\n{\n\tpcap_set_not_initialized_message(pcap);\n\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              343,
              0
            ],
            [
              348,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_get_airpcap_handle_not_initialized",
            "parameters": {
              "pcap": "pcap_t"
            },
            "return_type": "PAirpcapHandle"
          }
        },
        {
          "fn_code": "int\npcap_can_set_rfmon(pcap_t *p)\n{\n\treturn (p->can_set_rfmon_op(p));\n}",
          "fn_code_pos": [
            [
              355,
              0
            ],
            [
              359,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_can_set_rfmon",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_list_tstamp_types(pcap_t *p, int **tstamp_typesp)\n{\n\tif (p->tstamp_type_count == 0) {\n\t\t/*\n\t\t * We don't support multiple time stamp types.\n\t\t */\n\t\t*tstamp_typesp = NULL;\n\t} else {\n\t\t*tstamp_typesp = (int*)calloc(sizeof(**tstamp_typesp),\n\t\t    p->tstamp_type_count);\n\t\tif (*tstamp_typesp == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\t(void)memcpy(*tstamp_typesp, p->tstamp_type_list,\n\t\t    sizeof(**tstamp_typesp) * p->tstamp_type_count);\n\t}\n\treturn (p->tstamp_type_count);\n}",
          "fn_code_pos": [
            [
              381,
              0
            ],
            [
              401,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_list_tstamp_types",
            "parameters": {
              "p": "pcap_t",
              "tstamp_typesp": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\npcap_free_tstamp_types(int *tstamp_type_list)\n{\n\tfree(tstamp_type_list);\n}",
          "fn_code_pos": [
            [
              414,
              0
            ],
            [
              418,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_free_tstamp_types",
            "parameters": {
              "tstamp_type_list": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\npcap_oneshot(u_char *user, const struct pcap_pkthdr *h, const u_char *pkt)\n{\n\tstruct oneshot_userdata *sp = (struct oneshot_userdata *)user;\n\n\t*sp->hdr = *h;\n\t*sp->pkt = pkt;\n}",
          "fn_code_pos": [
            [
              425,
              0
            ],
            [
              432,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_oneshot",
            "parameters": {
              "user": "u_char",
              "h": "struct pcap_pkthdr",
              "pkt": "u_char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "const u_char *\npcap_next(pcap_t *p, struct pcap_pkthdr *h)\n{\n\tstruct oneshot_userdata s;\n\tconst u_char *pkt;\n\n\ts.hdr = h;\n\ts.pkt = &pkt;\n\ts.pd = p;\n\tif (pcap_dispatch(p, 1, p->oneshot_callback, (u_char *)&s) <= 0)\n\t\treturn (0);\n\treturn (pkt);\n}",
          "fn_code_pos": [
            [
              434,
              0
            ],
            [
              446,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_next",
            "parameters": {
              "p": "pcap_t",
              "h": "struct pcap_pkthdr"
            },
            "return_type": "u_char"
          }
        },
        {
          "fn_code": "int\npcap_next_ex(pcap_t *p, struct pcap_pkthdr **pkt_header,\n    const u_char **pkt_data)\n{\n\tstruct oneshot_userdata s;\n\n\ts.hdr = &p->pcap_header;\n\ts.pkt = pkt_data;\n\ts.pd = p;\n\n\t/* Saves a pointer to the packet headers */\n\t*pkt_header= &p->pcap_header;\n\n\tif (p->rfile != NULL) {\n\t\tint status;\n\n\t\t/* We are on an offline capture */\n\t\tstatus = pcap_offline_read(p, 1, p->oneshot_callback,\n\t\t    (u_char *)&s);\n\n\t\t/*\n\t\t * Return codes for pcap_offline_read() are:\n\t\t *   -  0: EOF\n\t\t *   - -1: error\n\t\t *   - >1: OK\n\t\t * The first one ('0') conflicts with the return code of\n\t\t * 0 from pcap_read() meaning \"no packets arrived before\n\t\t * the timeout expired\", so we map it to -2 so you can\n\t\t * distinguish between an EOF from a savefile and a\n\t\t * \"no packets arrived before the timeout expired, try\n\t\t * again\" from a live capture.\n\t\t */\n\t\tif (status == 0)\n\t\t\treturn (-2);\n\t\telse\n\t\t\treturn (status);\n\t}\n\n\t/*\n\t * Return codes for pcap_read() are:\n\t *   -  0: timeout\n\t *   - -1: error\n\t *   - -2: loop was broken out of with pcap_breakloop()\n\t *   - >1: OK\n\t * The first one ('0') conflicts with the return code of 0 from\n\t * pcap_offline_read() meaning \"end of file\".\n\t*/\n\treturn (p->read_op(p, 1, p->oneshot_callback, (u_char *)&s));\n}",
          "fn_code_pos": [
            [
              448,
              0
            ],
            [
              496,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_next_ex",
            "parameters": {
              "p": "pcap_t",
              "pkt_header": "struct pcap_pkthdr",
              "pkt_data": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_findalldevs(pcap_if_t **alldevsp, char *errbuf)\n{\n\tsize_t i;\n\tpcap_if_list_t devlist;\n\n\t/*\n\t * Find all the local network interfaces on which we\n\t * can capture.\n\t */\n\tdevlist.beginning = NULL;\n\tif (pcap_platform_finddevs(&devlist, errbuf) == -1) {\n\t\t/*\n\t\t * Failed - free all of the entries we were given\n\t\t * before we failed.\n\t\t */\n\t\tif (devlist.beginning != NULL)\n\t\t\tpcap_freealldevs(devlist.beginning);\n\t\t*alldevsp = NULL;\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Ask each of the non-local-network-interface capture\n\t * source types what interfaces they have.\n\t */\n\tfor (i = 0; capture_source_types[i].findalldevs_op != NULL; i++) {\n\t\tif (capture_source_types[i].findalldevs_op(&devlist, errbuf) == -1) {\n\t\t\t/*\n\t\t\t * We had an error; free the list we've been\n\t\t\t * constructing.\n\t\t\t */\n\t\t\tif (devlist.beginning != NULL)\n\t\t\t\tpcap_freealldevs(devlist.beginning);\n\t\t\t*alldevsp = NULL;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t/*\n\t * Return the first entry of the list of all devices.\n\t */\n\t*alldevsp = devlist.beginning;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              554,
              0
            ],
            [
              598,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_findalldevs",
            "parameters": {
              "alldevsp": "pcap_if_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static struct sockaddr *\ndup_sockaddr(struct sockaddr *sa, size_t sa_length)\n{\n\tstruct sockaddr *newsa;\n\n\tif ((newsa = malloc(sa_length)) == NULL)\n\t\treturn (NULL);\n\treturn (memcpy(newsa, sa, sa_length));\n}",
          "fn_code_pos": [
            [
              600,
              0
            ],
            [
              608,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dup_sockaddr",
            "parameters": {
              "sa": "struct sockaddr",
              "sa_length": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static u_int\nget_figure_of_merit(pcap_if_t *dev)\n{\n\tconst char *cp;\n\tu_int n;\n\n\tif (strcmp(dev->name, \"any\") == 0) {\n\t\t/*\n\t\t * Give the \"any\" device an artificially high instance\n\t\t * number, so it shows up after all other non-loopback\n\t\t * interfaces.\n\t\t */\n\t\tn = 0x1FFFFFFF;\t/* 29 all-1 bits */\n\t} else {\n\t\t/*\n\t\t * A number at the end of the device name string is\n\t\t * assumed to be an instance number.  Add 1 to the\n\t\t * instance number, and use 0 for \"no instance\n\t\t * number\", so we don't put \"no instance number\"\n\t\t * devices and \"instance 0\" devices together.\n\t\t */\n\t\tcp = dev->name + strlen(dev->name) - 1;\n\t\twhile (cp-1 >= dev->name && *(cp-1) >= '0' && *(cp-1) <= '9')\n\t\t\tcp--;\n\t\tif (*cp >= '0' && *cp <= '9')\n\t\t\tn = atoi(cp) + 1;\n\t\telse\n\t\t\tn = 0;\n\t}\n\tif (!(dev->flags & PCAP_IF_RUNNING))\n\t\tn |= 0x80000000;\n\tif (!(dev->flags & PCAP_IF_UP))\n\t\tn |= 0x40000000;\n\n\t/*\n\t * Give non-wireless interfaces that aren't disconnected a better\n\t * figure of merit than interfaces that are disconnected, as\n\t * \"disconnected\" should indicate that the interface isn't\n\t * plugged into a network and thus won't give you any traffic.\n\t *\n\t * For wireless interfaces, it means \"associated with a network\",\n\t * which we presume not to necessarily prevent capture, as you\n\t * might run the adapter in some flavor of monitor mode.\n\t */\n\tif (!(dev->flags & PCAP_IF_WIRELESS) &&\n\t    (dev->flags & PCAP_IF_CONNECTION_STATUS) == PCAP_IF_CONNECTION_STATUS_DISCONNECTED)\n\t\tn |= 0x20000000;\n\n\t/*\n\t * Sort loopback devices after non-loopback devices, *except* for\n\t * disconnected devices.\n\t */\n\tif (dev->flags & PCAP_IF_LOOPBACK)\n\t\tn |= 0x10000000;\n\n\treturn (n);\n}",
          "fn_code_pos": [
            [
              628,
              0
            ],
            [
              684,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_figure_of_merit",
            "parameters": {
              "dev": "pcap_if_t"
            },
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "get_if_description(const char *name _U_)\n{\n\treturn (NULL);\n#endif /* SIOCGIFDESCR */\n}",
          "fn_code_pos": [
            [
              849,
              0
            ],
            [
              853,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_if_description",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_if_t *\nfind_or_add_if(pcap_if_list_t *devlistp, const char *name,\n    bpf_u_int32 if_flags, get_if_flags_func get_flags_func, char *errbuf)\n{\n\tbpf_u_int32 pcap_flags;\n\n\t/*\n\t * Convert IFF_ flags to pcap flags.\n\t */\n\tpcap_flags = 0;\n#ifdef IFF_LOOPBACK\n\tif (if_flags & IFF_LOOPBACK)\n\t\tpcap_flags |= PCAP_IF_LOOPBACK;\n#else\n\t/*\n\t * We don't have IFF_LOOPBACK, so look at the device name to\n\t * see if it looks like a loopback device.\n\t */\n\tif (name[0] == 'l' && name[1] == 'o' &&\n\t    (isdigit((unsigned char)(name[2])) || name[2] == '\\0')\n\t\tpcap_flags |= PCAP_IF_LOOPBACK;\n#endif\n#ifdef IFF_UP\n\tif (if_flags & IFF_UP)\n\t\tpcap_flags |= PCAP_IF_UP;\n#endif\n#ifdef IFF_RUNNING\n\tif (if_flags & IFF_RUNNING)\n\t\tpcap_flags |= PCAP_IF_RUNNING;\n#endif\n\n\t/*\n\t * Attempt to find an entry for this device; if we don't find one,\n\t * attempt to add one.\n\t */\n\treturn (find_or_add_dev(devlistp, name, pcap_flags,\n\t    get_flags_func, get_if_description(name), errbuf));\n}",
          "fn_code_pos": [
            [
              864,
              0
            ],
            [
              901,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_or_add_if",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "name": "char",
              "if_flags": "bpf_u_int32",
              "get_flags_func": "get_if_flags_func",
              "errbuf": "char"
            },
            "return_type": "pcap_if_t"
          }
        },
        {
          "fn_code": "int\nadd_addr_to_if(pcap_if_list_t *devlistp, const char *name,\n    bpf_u_int32 if_flags, get_if_flags_func get_flags_func,\n    struct sockaddr *addr, size_t addr_size,\n    struct sockaddr *netmask, size_t netmask_size,\n    struct sockaddr *broadaddr, size_t broadaddr_size,\n    struct sockaddr *dstaddr, size_t dstaddr_size,\n    char *errbuf)\n{\n\tpcap_if_t *curdev;\n\n\t/*\n\t * Check whether the device exists and, if not, add it.\n\t */\n\tcurdev = find_or_add_if(devlistp, name, if_flags, get_flags_func,\n\t    errbuf);\n\tif (curdev == NULL) {\n\t\t/*\n\t\t * Error - give up.\n\t\t */\n\t\treturn (-1);\n\t}\n\n\tif (addr == NULL) {\n\t\t/*\n\t\t * There's no address to add; this entry just meant\n\t\t * \"here's a new interface\".\n\t\t */\n\t\treturn (0);\n\t}\n\n\t/*\n\t * \"curdev\" is an entry for this interface, and we have an\n\t * address for it; add an entry for that address to the\n\t * interface's list of addresses.\n\t */\n\treturn (add_addr_to_dev(curdev, addr, addr_size, netmask,\n\t    netmask_size, broadaddr, broadaddr_size, dstaddr,\n\t    dstaddr_size, errbuf));\n}",
          "fn_code_pos": [
            [
              921,
              0
            ],
            [
              960,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_addr_to_if",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "name": "char",
              "if_flags": "bpf_u_int32",
              "get_flags_func": "get_if_flags_func",
              "addr": "struct sockaddr",
              "addr_size": "size_t",
              "netmask": "struct sockaddr",
              "netmask_size": "size_t",
              "broadaddr": "struct sockaddr",
              "broadaddr_size": "size_t",
              "dstaddr": "struct sockaddr",
              "dstaddr_size": "size_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nadd_addr_to_dev(pcap_if_t *curdev,\n    struct sockaddr *addr, size_t addr_size,\n    struct sockaddr *netmask, size_t netmask_size,\n    struct sockaddr *broadaddr, size_t broadaddr_size,\n    struct sockaddr *dstaddr, size_t dstaddr_size,\n    char *errbuf)\n{\n\tpcap_addr_t *curaddr, *prevaddr, *nextaddr;\n\n\t/*\n\t * Allocate the new entry and fill it in.\n\t */\n\tcuraddr = (pcap_addr_t *)malloc(sizeof(pcap_addr_t));\n\tif (curaddr == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn (-1);\n\t}\n\n\tcuraddr->next = NULL;\n\tif (addr != NULL && addr_size != 0) {\n\t\tcuraddr->addr = (struct sockaddr *)dup_sockaddr(addr, addr_size);\n\t\tif (curaddr->addr == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tfree(curaddr);\n\t\t\treturn (-1);\n\t\t}\n\t} else\n\t\tcuraddr->addr = NULL;\n\n\tif (netmask != NULL && netmask_size != 0) {\n\t\tcuraddr->netmask = (struct sockaddr *)dup_sockaddr(netmask, netmask_size);\n\t\tif (curaddr->netmask == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tif (curaddr->addr != NULL)\n\t\t\t\tfree(curaddr->addr);\n\t\t\tfree(curaddr);\n\t\t\treturn (-1);\n\t\t}\n\t} else\n\t\tcuraddr->netmask = NULL;\n\n\tif (broadaddr != NULL && broadaddr_size != 0) {\n\t\tcuraddr->broadaddr = (struct sockaddr *)dup_sockaddr(broadaddr, broadaddr_size);\n\t\tif (curaddr->broadaddr == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tif (curaddr->netmask != NULL)\n\t\t\t\tfree(curaddr->netmask);\n\t\t\tif (curaddr->addr != NULL)\n\t\t\t\tfree(curaddr->addr);\n\t\t\tfree(curaddr);\n\t\t\treturn (-1);\n\t\t}\n\t} else\n\t\tcuraddr->broadaddr = NULL;\n\n\tif (dstaddr != NULL && dstaddr_size != 0) {\n\t\tcuraddr->dstaddr = (struct sockaddr *)dup_sockaddr(dstaddr, dstaddr_size);\n\t\tif (curaddr->dstaddr == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tif (curaddr->broadaddr != NULL)\n\t\t\t\tfree(curaddr->broadaddr);\n\t\t\tif (curaddr->netmask != NULL)\n\t\t\t\tfree(curaddr->netmask);\n\t\t\tif (curaddr->addr != NULL)\n\t\t\t\tfree(curaddr->addr);\n\t\t\tfree(curaddr);\n\t\t\treturn (-1);\n\t\t}\n\t} else\n\t\tcuraddr->dstaddr = NULL;\n\n\t/*\n\t * Find the end of the list of addresses.\n\t */\n\tfor (prevaddr = curdev->addresses; prevaddr != NULL; prevaddr = nextaddr) {\n\t\tnextaddr = prevaddr->next;\n\t\tif (nextaddr == NULL) {\n\t\t\t/*\n\t\t\t * This is the end of the list.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (prevaddr == NULL) {\n\t\t/*\n\t\t * The list was empty; this is the first member.\n\t\t */\n\t\tcurdev->addresses = curaddr;\n\t} else {\n\t\t/*\n\t\t * \"prevaddr\" is the last member of the list; append\n\t\t * this member to it.\n\t\t */\n\t\tprevaddr->next = curaddr;\n\t}\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              967,
              0
            ],
            [
              1071,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_addr_to_dev",
            "parameters": {
              "curdev": "pcap_if_t",
              "addr": "struct sockaddr",
              "addr_size": "size_t",
              "netmask": "struct sockaddr",
              "netmask_size": "size_t",
              "broadaddr": "struct sockaddr",
              "broadaddr_size": "size_t",
              "dstaddr": "struct sockaddr",
              "dstaddr_size": "size_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_if_t *\nfind_or_add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,\n    get_if_flags_func get_flags_func, const char *description, char *errbuf)\n{\n\tpcap_if_t *curdev;\n\n\t/*\n\t * Is there already an entry in the list for this device?\n\t */\n\tcurdev = find_dev(devlistp, name);\n\tif (curdev != NULL) {\n\t\t/*\n\t\t * Yes, return it.\n\t\t */\n\t\treturn (curdev);\n\t}\n\n\t/*\n\t * No, we didn't find it.\n\t */\n\n\t/*\n\t * Try to get additional flags for the device.\n\t */\n\tif ((*get_flags_func)(name, &flags, errbuf) == -1) {\n\t\t/*\n\t\t * Failed.\n\t\t */\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Now, try to add it to the list of devices.\n\t */\n\treturn (add_dev(devlistp, name, flags, description, errbuf));\n}",
          "fn_code_pos": [
            [
              1082,
              0
            ],
            [
              1117,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_or_add_dev",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "name": "char",
              "flags": "bpf_u_int32",
              "get_flags_func": "get_if_flags_func",
              "description": "char",
              "errbuf": "char"
            },
            "return_type": "pcap_if_t"
          }
        },
        {
          "fn_code": "pcap_if_t *\nfind_dev(pcap_if_list_t *devlistp, const char *name)\n{\n\tpcap_if_t *curdev;\n\n\t/*\n\t * Is there an entry in the list for this device?\n\t */\n\tfor (curdev = devlistp->beginning; curdev != NULL;\n\t    curdev = curdev->next) {\n\t\tif (strcmp(name, curdev->name) == 0) {\n\t\t\t/*\n\t\t\t * We found it, so, yes, there is.  No need to\n\t\t\t * add it.  Provide the entry we found to our\n\t\t\t * caller.\n\t\t\t */\n\t\t\treturn (curdev);\n\t\t}\n\t}\n\n\t/*\n\t * No.\n\t */\n\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              1123,
              0
            ],
            [
              1147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_dev",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "name": "char"
            },
            "return_type": "pcap_if_t"
          }
        },
        {
          "fn_code": "pcap_if_t *\nadd_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,\n    const char *description, char *errbuf)\n{\n\tpcap_if_t *curdev, *prevdev, *nextdev;\n\tu_int this_figure_of_merit, nextdev_figure_of_merit;\n\n\tcurdev = malloc(sizeof(pcap_if_t));\n\tif (curdev == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Fill in the entry.\n\t */\n\tcurdev->next = NULL;\n\tcurdev->name = strdup(name);\n\tif (curdev->name == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tfree(curdev);\n\t\treturn (NULL);\n\t}\n\tif (description == NULL) {\n\t\t/*\n\t\t * We weren't handed a description for the interface.\n\t\t */\n\t\tcurdev->description = NULL;\n\t} else {\n\t\t/*\n\t\t * We were handed a description; make a copy.\n\t\t */\n\t\tcurdev->description = strdup(description);\n\t\tif (curdev->description == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tfree(curdev->name);\n\t\t\tfree(curdev);\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\tcurdev->addresses = NULL;\t/* list starts out as empty */\n\tcurdev->flags = flags;\n\n\t/*\n\t * Add it to the list, in the appropriate location.\n\t * First, get the \"figure of merit\" for this interface.\n\t */\n\tthis_figure_of_merit = get_figure_of_merit(curdev);\n\n\t/*\n\t * Now look for the last interface with an figure of merit\n\t * less than or equal to the new interface's figure of merit.\n\t *\n\t * We start with \"prevdev\" being NULL, meaning we're before\n\t * the first element in the list.\n\t */\n\tprevdev = NULL;\n\tfor (;;) {\n\t\t/*\n\t\t * Get the interface after this one.\n\t\t */\n\t\tif (prevdev == NULL) {\n\t\t\t/*\n\t\t\t * The next element is the first element.\n\t\t\t */\n\t\t\tnextdev = devlistp->beginning;\n\t\t} else\n\t\t\tnextdev = prevdev->next;\n\n\t\t/*\n\t\t * Are we at the end of the list?\n\t\t */\n\t\tif (nextdev == NULL) {\n\t\t\t/*\n\t\t\t * Yes - we have to put the new entry after \"prevdev\".\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Is the new interface's figure of merit less\n\t\t * than the next interface's figure of merit,\n\t\t * meaning that the new interface is better\n\t\t * than the next interface?\n\t\t */\n\t\tnextdev_figure_of_merit = get_figure_of_merit(nextdev);\n\t\tif (this_figure_of_merit < nextdev_figure_of_merit) {\n\t\t\t/*\n\t\t\t * Yes - we should put the new entry\n\t\t\t * before \"nextdev\", i.e. after \"prevdev\".\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\tprevdev = nextdev;\n\t}\n\n\t/*\n\t * Insert before \"nextdev\".\n\t */\n\tcurdev->next = nextdev;\n\n\t/*\n\t * Insert after \"prevdev\" - unless \"prevdev\" is null,\n\t * in which case this is the first interface.\n\t */\n\tif (prevdev == NULL) {\n\t\t/*\n\t\t * This is the first interface.  Make it\n\t\t * the first element in the list of devices.\n\t\t */\n\t\tdevlistp->beginning = curdev;\n\t} else\n\t\tprevdev->next = curdev;\n\treturn (curdev);\n}",
          "fn_code_pos": [
            [
              1157,
              0
            ],
            [
              1275,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_dev",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "name": "char",
              "flags": "bpf_u_int32",
              "description": "char",
              "errbuf": "char"
            },
            "return_type": "pcap_if_t"
          }
        },
        {
          "fn_code": "void\npcap_freealldevs(pcap_if_t *alldevs)\n{\n\tpcap_if_t *curdev, *nextdev;\n\tpcap_addr_t *curaddr, *nextaddr;\n\n\tfor (curdev = alldevs; curdev != NULL; curdev = nextdev) {\n\t\tnextdev = curdev->next;\n\n\t\t/*\n\t\t * Free all addresses.\n\t\t */\n\t\tfor (curaddr = curdev->addresses; curaddr != NULL; curaddr = nextaddr) {\n\t\t\tnextaddr = curaddr->next;\n\t\t\tif (curaddr->addr)\n\t\t\t\tfree(curaddr->addr);\n\t\t\tif (curaddr->netmask)\n\t\t\t\tfree(curaddr->netmask);\n\t\t\tif (curaddr->broadaddr)\n\t\t\t\tfree(curaddr->broadaddr);\n\t\t\tif (curaddr->dstaddr)\n\t\t\t\tfree(curaddr->dstaddr);\n\t\t\tfree(curaddr);\n\t\t}\n\n\t\t/*\n\t\t * Free the name string.\n\t\t */\n\t\tfree(curdev->name);\n\n\t\t/*\n\t\t * Free the description string, if any.\n\t\t */\n\t\tif (curdev->description != NULL)\n\t\t\tfree(curdev->description);\n\n\t\t/*\n\t\t * Free the interface.\n\t\t */\n\t\tfree(curdev);\n\t}\n}",
          "fn_code_pos": [
            [
              1280,
              0
            ],
            [
              1321,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_freealldevs",
            "parameters": {
              "alldevs": "pcap_if_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "char *\npcap_lookupdev(char *errbuf)\n{\n\tpcap_if_t *alldevs;\n#ifdef _WIN32\n  /*\n   * Windows - use the same size as the old WinPcap 3.1 code.\n   * XXX - this is probably bigger than it needs to be.\n   */\n  #define IF_NAMESIZE 8192\n#else\n  /*\n   * UN*X - use the system's interface name size.\n   * XXX - that might not be large enough for capture devices\n   * that aren't regular network interfaces.\n   */\n  /* for old BSD systems, including bsdi3 */\n  #ifndef IF_NAMESIZE\n  #define IF_NAMESIZE IFNAMSIZ\n  #endif\n#endif\n\tstatic char device[IF_NAMESIZE + 1];\n\tchar *ret;\n\n\tif (pcap_findalldevs(&alldevs, errbuf) == -1)\n\t\treturn (NULL);\n\n\tif (alldevs == NULL || (alldevs->flags & PCAP_IF_LOOPBACK)) {\n\t\t/*\n\t\t * There are no devices on the list, or the first device\n\t\t * on the list is a loopback device, which means there\n\t\t * are no non-loopback devices on the list.  This means\n\t\t * we can't return any device.\n\t\t *\n\t\t * XXX - why not return a loopback device?  If we can't\n\t\t * capture on it, it won't be on the list, and if it's\n\t\t * on the list, there aren't any non-loopback devices,\n\t\t * so why not just supply it as the default device?\n\t\t */\n\t\t(void)pcap_strlcpy(errbuf, \"no suitable device found\",\n\t\t    PCAP_ERRBUF_SIZE);\n\t\tret = NULL;\n\t} else {\n\t\t/*\n\t\t * Return the name of the first device on the list.\n\t\t */\n\t\t(void)pcap_strlcpy(device, alldevs->name, sizeof(device));\n\t\tret = device;\n\t}\n\n\tpcap_freealldevs(alldevs);\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              1340,
              0
            ],
            [
              1392,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lookupdev",
            "parameters": {
              "errbuf": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int\npcap_lookupnet(const char *device, bpf_u_int32 *netp, bpf_u_int32 *maskp,\n    char *errbuf)\n{\n\tregister int fd;\n\tregister struct sockaddr_in *sin4;\n\tstruct ifreq ifr;\n\n\t/*\n\t * The pseudo-device \"any\" listens on all interfaces and therefore\n\t * has the network address and -mask \"0.0.0.0\" therefore catching\n\t * all traffic. Using NULL for the interface is the same as \"any\".\n\t */\n\tif (!device || strcmp(device, \"any\") == 0\n#ifdef HAVE_DAG_API\n\t    || strstr(device, \"dag\") != NULL\n#endif\n#ifdef HAVE_SEPTEL_API\n\t    || strstr(device, \"septel\") != NULL\n#endif\n#ifdef PCAP_SUPPORT_BT\n\t    || strstr(device, \"bluetooth\") != NULL\n#endif\n#ifdef PCAP_SUPPORT_USB\n\t    || strstr(device, \"usbmon\") != NULL\n#endif\n#ifdef HAVE_SNF_API\n\t    || strstr(device, \"snf\") != NULL\n#endif\n#ifdef PCAP_SUPPORT_NETMAP\n\t    || strncmp(device, \"netmap:\", 7) == 0\n\t    || strncmp(device, \"vale\", 4) == 0\n#endif\n#ifdef PCAP_SUPPORT_DPDK\n\t    || strncmp(device, \"dpdk:\", 5) == 0\n#endif\n\t    ) {\n\t\t*netp = *maskp = 0;\n\t\treturn 0;\n\t}\n\n\tfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (fd < 0) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"socket\");\n\t\treturn (-1);\n\t}\n\tmemset(&ifr, 0, sizeof(ifr));\n#ifdef linux\n\t/* XXX Work around Linux kernel bug */\n\tifr.ifr_addr.sa_family = AF_INET;\n#endif\n\t(void)pcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));\n\tif (ioctl(fd, SIOCGIFADDR, (char *)&ifr) < 0) {\n\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\t(void)pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"%s: no IPv4 address assigned\", device);\n\t\t} else {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"SIOCGIFADDR: %s\", device);\n\t\t}\n\t\t(void)close(fd);\n\t\treturn (-1);\n\t}\n\tsin4 = (struct sockaddr_in *)&ifr.ifr_addr;\n\t*netp = sin4->sin_addr.s_addr;\n\tmemset(&ifr, 0, sizeof(ifr));\n#ifdef linux\n\t/* XXX Work around Linux kernel bug */\n\tifr.ifr_addr.sa_family = AF_INET;\n#endif\n\t(void)pcap_strlcpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));\n\tif (ioctl(fd, SIOCGIFNETMASK, (char *)&ifr) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCGIFNETMASK: %s\", device);\n\t\t(void)close(fd);\n\t\treturn (-1);\n\t}\n\t(void)close(fd);\n\t*maskp = sin4->sin_addr.s_addr;\n\tif (*maskp == 0) {\n\t\tif (IN_CLASSA(*netp))\n\t\t\t*maskp = IN_CLASSA_NET;\n\t\telse if (IN_CLASSB(*netp))\n\t\t\t*maskp = IN_CLASSB_NET;\n\t\telse if (IN_CLASSC(*netp))\n\t\t\t*maskp = IN_CLASSC_NET;\n\t\telse {\n\t\t\t(void)pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"inet class for 0x%x unknown\", *netp);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\t*netp &= *maskp;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1404,
              0
            ],
            [
              1499,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lookupnet",
            "parameters": {
              "device": "char",
              "netp": "bpf_u_int32",
              "maskp": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static char *\nget_substring(const char *p, size_t len, char *ebuf)\n{\n\tchar *token;\n\n\ttoken = malloc(len + 1);\n\tif (token == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn (NULL);\n\t}\n\tmemcpy(token, p, len);\n\ttoken[len] = '\\0';\n\treturn (token);\n}",
          "fn_code_pos": [
            [
              1508,
              0
            ],
            [
              1522,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_substring",
            "parameters": {
              "p": "char",
              "len": "size_t",
              "ebuf": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static int\npcap_parse_source(const char *source, char **schemep, char **userinfop,\n    char **hostp, char **portp, char **pathp, char *ebuf)\n{\n\tchar *colonp;\n\tsize_t scheme_len;\n\tchar *scheme;\n\tconst char *endp;\n\tsize_t authority_len;\n\tchar *authority;\n\tchar *parsep, *atsignp, *bracketp;\n\tchar *userinfo, *host, *port, *path;\n\n\t/*\n\t * Start out returning nothing.\n\t */\n\t*schemep = NULL;\n\t*userinfop = NULL;\n\t*hostp = NULL;\n\t*portp = NULL;\n\t*pathp = NULL;\n\n\t/*\n\t * RFC 3986 says:\n\t *\n\t *   URI         = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n\t *\n\t *   hier-part   = \"//\" authority path-abempty\n\t *               / path-absolute\n\t *               / path-rootless\n\t *               / path-empty\n\t *\n\t *   authority   = [ userinfo \"@\" ] host [ \":\" port ]\n\t *\n\t *   userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" )\n         *\n         * Step 1: look for the \":\" at the end of the scheme.\n\t * A colon in the source is *NOT* sufficient to indicate that\n\t * this is a URL, as interface names on some platforms might\n\t * include colons (e.g., I think some Solaris interfaces\n\t * might).\n\t */\n\tcolonp = strchr(source, ':');\n\tif (colonp == NULL) {\n\t\t/*\n\t\t * The source is the device to open.\n\t\t * Return a NULL pointer for the scheme, user information,\n\t\t * host, and port, and return the device as the path.\n\t\t */\n\t\t*pathp = strdup(source);\n\t\tif (*pathp == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (-1);\n\t\t}\n\t\treturn (0);\n\t}\n\n\t/*\n\t * All schemes must have \"//\" after them, i.e. we only support\n\t * hier-part   = \"//\" authority path-abempty, not\n\t * hier-part   = path-absolute\n\t * hier-part   = path-rootless\n\t * hier-part   = path-empty\n\t *\n\t * We need that in order to distinguish between a local device\n\t * name that happens to contain a colon and a URI.\n\t */\n\tif (strncmp(colonp + 1, \"//\", 2) != 0) {\n\t\t/*\n\t\t * The source is the device to open.\n\t\t * Return a NULL pointer for the scheme, user information,\n\t\t * host, and port, and return the device as the path.\n\t\t */\n\t\t*pathp = strdup(source);\n\t\tif (*pathp == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (-1);\n\t\t}\n\t\treturn (0);\n\t}\n\n\t/*\n\t * XXX - check whether the purported scheme could be a scheme?\n\t */\n\n\t/*\n\t * OK, this looks like a URL.\n\t * Get the scheme.\n\t */\n\tscheme_len = colonp - source;\n\tscheme = malloc(scheme_len + 1);\n\tif (scheme == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn (-1);\n\t}\n\tmemcpy(scheme, source, scheme_len);\n\tscheme[scheme_len] = '\\0';\n\n\t/*\n\t * Treat file: specially - take everything after file:// as\n\t * the pathname.\n\t */\n\tif (pcap_strcasecmp(scheme, \"file\") == 0) {\n\t\t*pathp = strdup(colonp + 3);\n\t\tif (*pathp == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\tfree(scheme);\n\t\t\treturn (-1);\n\t\t}\n\t\t*schemep = scheme;\n\t\treturn (0);\n\t}\n\n\t/*\n\t * The WinPcap documentation says you can specify a local\n\t * interface with \"rpcap://{device}\"; we special-case\n\t * that here.  If the scheme is \"rpcap\", and there are\n\t * no slashes past the \"//\", we just return the device.\n\t *\n\t * XXX - %-escaping?\n\t */\n\tif ((pcap_strcasecmp(scheme, \"rpcap\") == 0 ||\n\t    pcap_strcasecmp(scheme, \"rpcaps\") == 0) &&\n\t    strchr(colonp + 3, '/') == NULL) {\n\t\t/*\n\t\t * Local device.\n\t\t *\n\t\t * Return a NULL pointer for the scheme, user information,\n\t\t * host, and port, and return the device as the path.\n\t\t */\n\t\tfree(scheme);\n\t\t*pathp = strdup(colonp + 3);\n\t\tif (*pathp == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (-1);\n\t\t}\n\t\treturn (0);\n\t}\n\n\t/*\n\t * OK, now start parsing the authority.\n\t * Get token, terminated with / or terminated at the end of\n\t * the string.\n\t */\n\tauthority_len = strcspn(colonp + 3, \"/\");\n\tauthority = get_substring(colonp + 3, authority_len, ebuf);\n\tif (authority == NULL) {\n\t\t/*\n\t\t * Error.\n\t\t */\n\t\tfree(scheme);\n\t\treturn (-1);\n\t}\n\tendp = colonp + 3 + authority_len;\n\n\t/*\n\t * Now carve the authority field into its components.\n\t */\n\tparsep = authority;\n\n\t/*\n\t * Is there a userinfo field?\n\t */\n\tatsignp = strchr(parsep, '@');\n\tif (atsignp != NULL) {\n\t\t/*\n\t\t * Yes.\n\t\t */\n\t\tsize_t userinfo_len;\n\n\t\tuserinfo_len = atsignp - parsep;\n\t\tuserinfo = get_substring(parsep, userinfo_len, ebuf);\n\t\tif (userinfo == NULL) {\n\t\t\t/*\n\t\t\t * Error.\n\t\t\t */\n\t\t\tfree(authority);\n\t\t\tfree(scheme);\n\t\t\treturn (-1);\n\t\t}\n\t\tparsep = atsignp + 1;\n\t} else {\n\t\t/*\n\t\t * No.\n\t\t */\n\t\tuserinfo = NULL;\n\t}\n\n\t/*\n\t * Is there a host field?\n\t */\n\tif (*parsep == '\\0') {\n\t\t/*\n\t\t * No; there's no host field or port field.\n\t\t */\n\t\thost = NULL;\n\t\tport = NULL;\n\t} else {\n\t\t/*\n\t\t * Yes.\n\t\t */\n\t\tsize_t host_len;\n\n\t\t/*\n\t\t * Is it an IP-literal?\n\t\t */\n\t\tif (*parsep == '[') {\n\t\t\t/*\n\t\t\t * Yes.\n\t\t\t * Treat verything up to the closing square\n\t\t\t * bracket as the IP-Literal; we don't worry\n\t\t\t * about whether it's a valid IPv6address or\n\t\t\t * IPvFuture (or an IPv4address, for that\n\t\t\t * matter, just in case we get handed a\n\t\t\t * URL with an IPv4 IP-Literal, of the sort\n\t\t\t * that pcap_createsrcstr() used to generate,\n\t\t\t * and that pcap_parsesrcstr(), in the original\n\t\t\t * WinPcap code, accepted).\n\t\t\t */\n\t\t\tbracketp = strchr(parsep, ']');\n\t\t\tif (bracketp == NULL) {\n\t\t\t\t/*\n\t\t\t\t * There's no closing square bracket.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"IP-literal in URL doesn't end with ]\");\n\t\t\t\tfree(userinfo);\n\t\t\t\tfree(authority);\n\t\t\t\tfree(scheme);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tif (*(bracketp + 1) != '\\0' &&\n\t\t\t    *(bracketp + 1) != ':') {\n\t\t\t\t/*\n\t\t\t\t * There's extra crud after the\n\t\t\t\t * closing square bracketn.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(ebuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Extra text after IP-literal in URL\");\n\t\t\t\tfree(userinfo);\n\t\t\t\tfree(authority);\n\t\t\t\tfree(scheme);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\thost_len = (bracketp - 1) - parsep;\n\t\t\thost = get_substring(parsep + 1, host_len, ebuf);\n\t\t\tif (host == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Error.\n\t\t\t\t */\n\t\t\t\tfree(userinfo);\n\t\t\t\tfree(authority);\n\t\t\t\tfree(scheme);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tparsep = bracketp + 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * No.\n\t\t\t * Treat everything up to a : or the end of\n\t\t\t * the string as the host.\n\t\t\t */\n\t\t\thost_len = strcspn(parsep, \":\");\n\t\t\thost = get_substring(parsep, host_len, ebuf);\n\t\t\tif (host == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Error.\n\t\t\t\t */\n\t\t\t\tfree(userinfo);\n\t\t\t\tfree(authority);\n\t\t\t\tfree(scheme);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tparsep = parsep + host_len;\n\t\t}\n\n\t\t/*\n\t\t * Is there a port field?\n\t\t */\n\t\tif (*parsep == ':') {\n\t\t\t/*\n\t\t\t * Yes.  It's the rest of the authority field.\n\t\t\t */\n\t\t\tsize_t port_len;\n\n\t\t\tparsep++;\n\t\t\tport_len = strlen(parsep);\n\t\t\tport = get_substring(parsep, port_len, ebuf);\n\t\t\tif (port == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Error.\n\t\t\t\t */\n\t\t\t\tfree(host);\n\t\t\t\tfree(userinfo);\n\t\t\t\tfree(authority);\n\t\t\t\tfree(scheme);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * No.\n\t\t\t */\n\t\t\tport = NULL;\n\t\t}\n\t}\n\tfree(authority);\n\n\t/*\n\t * Everything else is the path.  Strip off the leading /.\n\t */\n\tif (*endp == '\\0')\n\t\tpath = strdup(\"\");\n\telse\n\t\tpath = strdup(endp + 1);\n\tif (path == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tfree(port);\n\t\tfree(host);\n\t\tfree(userinfo);\n\t\tfree(scheme);\n\t\treturn (-1);\n\t}\n\t*schemep = scheme;\n\t*userinfop = userinfo;\n\t*hostp = host;\n\t*portp = port;\n\t*pathp = path;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1559,
              0
            ],
            [
              1893,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_parse_source",
            "parameters": {
              "source": "char",
              "schemep": "char",
              "userinfop": "char",
              "hostp": "char",
              "portp": "char",
              "pathp": "char",
              "ebuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_createsrcstr_ex(char *source, int type, const char *host, const char *port,\n    const char *name, unsigned char uses_ssl, char *errbuf)\n{\n\tswitch (type) {\n\n\tcase PCAP_SRC_FILE:\n\t\tpcap_strlcpy(source, PCAP_SRC_FILE_STRING, PCAP_BUF_SIZE);\n\t\tif (name != NULL && *name != '\\0') {\n\t\t\tpcap_strlcat(source, name, PCAP_BUF_SIZE);\n\t\t\treturn (0);\n\t\t} else {\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"The file name cannot be NULL.\");\n\t\t\treturn (-1);\n\t\t}\n\n\tcase PCAP_SRC_IFREMOTE:\n\t\tpcap_strlcpy(source,\n\t\t    (uses_ssl ? \"rpcaps://\" : PCAP_SRC_IF_STRING),\n\t\t    PCAP_BUF_SIZE);\n\t\tif (host != NULL && *host != '\\0') {\n\t\t\tif (strchr(host, ':') != NULL) {\n\t\t\t\t/*\n\t\t\t\t * The host name contains a colon, so it's\n\t\t\t\t * probably an IPv6 address, and needs to\n\t\t\t\t * be included in square brackets.\n\t\t\t\t */\n\t\t\t\tpcap_strlcat(source, \"[\", PCAP_BUF_SIZE);\n\t\t\t\tpcap_strlcat(source, host, PCAP_BUF_SIZE);\n\t\t\t\tpcap_strlcat(source, \"]\", PCAP_BUF_SIZE);\n\t\t\t} else\n\t\t\t\tpcap_strlcat(source, host, PCAP_BUF_SIZE);\n\n\t\t\tif (port != NULL && *port != '\\0') {\n\t\t\t\tpcap_strlcat(source, \":\", PCAP_BUF_SIZE);\n\t\t\t\tpcap_strlcat(source, port, PCAP_BUF_SIZE);\n\t\t\t}\n\n\t\t\tpcap_strlcat(source, \"/\", PCAP_BUF_SIZE);\n\t\t} else {\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"The host name cannot be NULL.\");\n\t\t\treturn (-1);\n\t\t}\n\n\t\tif (name != NULL && *name != '\\0')\n\t\t\tpcap_strlcat(source, name, PCAP_BUF_SIZE);\n\n\t\treturn (0);\n\n\tcase PCAP_SRC_IFLOCAL:\n\t\tpcap_strlcpy(source, PCAP_SRC_IF_STRING, PCAP_BUF_SIZE);\n\n\t\tif (name != NULL && *name != '\\0')\n\t\t\tpcap_strlcat(source, name, PCAP_BUF_SIZE);\n\n\t\treturn (0);\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"The interface type is not valid.\");\n\t\treturn (-1);\n\t}\n}",
          "fn_code_pos": [
            [
              1895,
              0
            ],
            [
              1959,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_createsrcstr_ex",
            "parameters": {
              "source": "char",
              "type": "int",
              "host": "char",
              "port": "char",
              "name": "char",
              "uses_ssl": "unsigned char",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_createsrcstr(char *source, int type, const char *host, const char *port,\n    const char *name, char *errbuf)\n{\n\treturn (pcap_createsrcstr_ex(source, type, host, port, name, 0, errbuf));\n}",
          "fn_code_pos": [
            [
              1962,
              0
            ],
            [
              1967,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_createsrcstr",
            "parameters": {
              "source": "char",
              "type": "int",
              "host": "char",
              "port": "char",
              "name": "char",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_parsesrcstr_ex(const char *source, int *type, char *host, char *port,\n    char *name, unsigned char *uses_ssl, char *errbuf)\n{\n\tchar *scheme, *tmpuserinfo, *tmphost, *tmpport, *tmppath;\n\n\t/* Initialization stuff */\n\tif (host)\n\t\t*host = '\\0';\n\tif (port)\n\t\t*port = '\\0';\n\tif (name)\n\t\t*name = '\\0';\n\tif (uses_ssl)\n\t\t*uses_ssl = 0;\n\n\t/* Parse the source string */\n\tif (pcap_parse_source(source, &scheme, &tmpuserinfo, &tmphost,\n\t    &tmpport, &tmppath, errbuf) == -1) {\n\t\t/*\n\t\t * Fail.\n\t\t */\n\t\treturn (-1);\n\t}\n\n\tif (scheme == NULL) {\n\t\t/*\n\t\t * Local device.\n\t\t */\n\t\tif (name && tmppath)\n\t\t\tpcap_strlcpy(name, tmppath, PCAP_BUF_SIZE);\n\t\tif (type)\n\t\t\t*type = PCAP_SRC_IFLOCAL;\n\t\tfree(tmppath);\n\t\tfree(tmpport);\n\t\tfree(tmphost);\n\t\tfree(tmpuserinfo);\n\t\treturn (0);\n\t}\n\n\tint is_rpcap = 0;\n\tif (strcmp(scheme, \"rpcaps\") == 0) {\n\t\tis_rpcap = 1;\n\t\tif (uses_ssl) *uses_ssl = 1;\n\t} else if (strcmp(scheme, \"rpcap\") == 0) {\n\t\tis_rpcap = 1;\n\t}\n\n\tif (is_rpcap) {\n\t\t/*\n\t\t * rpcap[s]://\n\t\t *\n\t\t * pcap_parse_source() has already handled the case of\n\t\t * rpcap[s]://device\n\t\t */\n\t\tif (host && tmphost) {\n\t\t\tif (tmpuserinfo)\n\t\t\t\tpcap_snprintf(host, PCAP_BUF_SIZE, \"%s@%s\",\n\t\t\t\t    tmpuserinfo, tmphost);\n\t\t\telse\n\t\t\t\tpcap_strlcpy(host, tmphost, PCAP_BUF_SIZE);\n\t\t}\n\t\tif (port && tmpport)\n\t\t\tpcap_strlcpy(port, tmpport, PCAP_BUF_SIZE);\n\t\tif (name && tmppath)\n\t\t\tpcap_strlcpy(name, tmppath, PCAP_BUF_SIZE);\n\t\tif (type)\n\t\t\t*type = PCAP_SRC_IFREMOTE;\n\t\tfree(tmppath);\n\t\tfree(tmpport);\n\t\tfree(tmphost);\n\t\tfree(tmpuserinfo);\n\t\tfree(scheme);\n\t\treturn (0);\n\t}\n\n\tif (strcmp(scheme, \"file\") == 0) {\n\t\t/*\n\t\t * file://\n\t\t */\n\t\tif (name && tmppath)\n\t\t\tpcap_strlcpy(name, tmppath, PCAP_BUF_SIZE);\n\t\tif (type)\n\t\t\t*type = PCAP_SRC_FILE;\n\t\tfree(tmppath);\n\t\tfree(tmpport);\n\t\tfree(tmphost);\n\t\tfree(tmpuserinfo);\n\t\tfree(scheme);\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Neither rpcap: nor file:; just treat the entire string\n\t * as a local device.\n\t */\n\tif (name)\n\t\tpcap_strlcpy(name, source, PCAP_BUF_SIZE);\n\tif (type)\n\t\t*type = PCAP_SRC_IFLOCAL;\n\tfree(tmppath);\n\tfree(tmpport);\n\tfree(tmphost);\n\tfree(tmpuserinfo);\n\tfree(scheme);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1969,
              0
            ],
            [
              2075,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_parsesrcstr_ex",
            "parameters": {
              "source": "char",
              "type": "int",
              "host": "char",
              "port": "char",
              "name": "char",
              "uses_ssl": "unsigned char",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_parsesrcstr(const char *source, int *type, char *host, char *port,\n    char *name, char *errbuf)\n{\n  return pcap_parsesrcstr_ex(source, type, host, port, name, NULL, errbuf);\n}",
          "fn_code_pos": [
            [
              2077,
              0
            ],
            [
              2082,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_parsesrcstr",
            "parameters": {
              "source": "char",
              "type": "int",
              "host": "char",
              "port": "char",
              "name": "char",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_create(const char *device, char *errbuf)\n{\n\tsize_t i;\n\tint is_theirs;\n\tpcap_t *p;\n\tchar *device_str;\n\n\t/*\n\t * A null device name is equivalent to the \"any\" device -\n\t * which might not be supported on this platform, but\n\t * this means that you'll get a \"not supported\" error\n\t * rather than, say, a crash when we try to dereference\n\t * the null pointer.\n\t */\n\tif (device == NULL)\n\t\tdevice_str = strdup(\"any\");\n\telse {\n#ifdef _WIN32\n\t\t/*\n\t\t * If the string appears to be little-endian UCS-2/UTF-16,\n\t\t * convert it to ASCII.\n\t\t *\n\t\t * XXX - to UTF-8 instead?  Or report an error if any\n\t\t * character isn't ASCII?\n\t\t */\n\t\tif (device[0] != '\\0' && device[1] == '\\0') {\n\t\t\tsize_t length;\n\n\t\t\tlength = wcslen((wchar_t *)device);\n\t\t\tdevice_str = (char *)malloc(length + 1);\n\t\t\tif (device_str == NULL) {\n\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"malloc\");\n\t\t\t\treturn (NULL);\n\t\t\t}\n\n\t\t\tpcap_snprintf(device_str, length + 1, \"%ws\",\n\t\t\t    (const wchar_t *)device);\n\t\t} else\n#endif\n\t\t\tdevice_str = strdup(device);\n\t}\n\tif (device_str == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Try each of the non-local-network-interface capture\n\t * source types until we find one that works for this\n\t * device or run out of types.\n\t */\n\tfor (i = 0; capture_source_types[i].create_op != NULL; i++) {\n\t\tis_theirs = 0;\n\t\tp = capture_source_types[i].create_op(device_str, errbuf,\n\t\t    &is_theirs);\n\t\tif (is_theirs) {\n\t\t\t/*\n\t\t\t * The device name refers to a device of the\n\t\t\t * type in question; either it succeeded,\n\t\t\t * in which case p refers to a pcap_t to\n\t\t\t * later activate for the device, or it\n\t\t\t * failed, in which case p is null and we\n\t\t\t * should return that to report the failure\n\t\t\t * to create.\n\t\t\t */\n\t\t\tif (p == NULL) {\n\t\t\t\t/*\n\t\t\t\t * We assume the caller filled in errbuf.\n\t\t\t\t */\n\t\t\t\tfree(device_str);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tp->opt.device = device_str;\n\t\t\treturn (p);\n\t\t}\n\t}\n\n\t/*\n\t * OK, try it as a regular network interface.\n\t */\n\tp = pcap_create_interface(device_str, errbuf);\n\tif (p == NULL) {\n\t\t/*\n\t\t * We assume the caller filled in errbuf.\n\t\t */\n\t\tfree(device_str);\n\t\treturn (NULL);\n\t}\n\tp->opt.device = device_str;\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              2085,
              0
            ],
            [
              2179,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create",
            "parameters": {
              "device": "char",
              "errbuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static int\npcap_setnonblock_unactivated(pcap_t *p, int nonblock)\n{\n\tp->opt.nonblock = nonblock;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2186,
              0
            ],
            [
              2191,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setnonblock_unactivated",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ninitialize_ops(pcap_t *p)\n{\n\t/*\n\t * Set operation pointers for operations that only work on\n\t * an activated pcap_t to point to a routine that returns\n\t * a \"this isn't activated\" error.\n\t */\n\tp->read_op = pcap_read_not_initialized;\n\tp->inject_op = pcap_inject_not_initialized;\n\tp->setfilter_op = pcap_setfilter_not_initialized;\n\tp->setdirection_op = pcap_setdirection_not_initialized;\n\tp->set_datalink_op = pcap_set_datalink_not_initialized;\n\tp->getnonblock_op = pcap_getnonblock_not_initialized;\n\tp->stats_op = pcap_stats_not_initialized;\n#ifdef _WIN32\n\tp->stats_ex_op = pcap_stats_ex_not_initialized;\n\tp->setbuff_op = pcap_setbuff_not_initialized;\n\tp->setmode_op = pcap_setmode_not_initialized;\n\tp->setmintocopy_op = pcap_setmintocopy_not_initialized;\n\tp->getevent_op = pcap_getevent_not_initialized;\n\tp->oid_get_request_op = pcap_oid_get_request_not_initialized;\n\tp->oid_set_request_op = pcap_oid_set_request_not_initialized;\n\tp->sendqueue_transmit_op = pcap_sendqueue_transmit_not_initialized;\n\tp->setuserbuffer_op = pcap_setuserbuffer_not_initialized;\n\tp->live_dump_op = pcap_live_dump_not_initialized;\n\tp->live_dump_ended_op = pcap_live_dump_ended_not_initialized;\n\tp->get_airpcap_handle_op = pcap_get_airpcap_handle_not_initialized;\n#endif\n\n\t/*\n\t * Default cleanup operation - implementations can override\n\t * this, but should call pcap_cleanup_live_common() after\n\t * doing their own additional cleanup.\n\t */\n\tp->cleanup_op = pcap_cleanup_live_common;\n\n\t/*\n\t * In most cases, the standard one-shot callback can\n\t * be used for pcap_next()/pcap_next_ex().\n\t */\n\tp->oneshot_callback = pcap_oneshot;\n\n    /*\n     * Default breakloop operation - implementations can override\n     * this, but should call pcap_breakloop_common() before doing\n     * their own logic.\n     */\n    p->breakloop_op = pcap_breakloop_common;\n}",
          "fn_code_pos": [
            [
              2193,
              0
            ],
            [
              2242,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initialize_ops",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static pcap_t *\npcap_alloc_pcap_t(char *ebuf, size_t size)\n{\n\tchar *chunk;\n\tpcap_t *p;\n\n\t/*\n\t * Allocate a chunk of memory big enough for a pcap_t\n\t * plus a structure following it of size \"size\".  The\n\t * structure following it is a private data structure\n\t * for the routines that handle this pcap_t.\n\t *\n\t * The structure following it must be aligned on\n\t * the appropriate alignment boundary for this platform.\n\t * We align on an 8-byte boundary as that's probably what\n\t * at least some platforms do, even with 32-bit integers,\n\t * and because we can't be sure that some values won't\n\t * require 8-byte alignment even on platforms with 32-bit\n\t * integers.\n\t */\n#define PCAP_T_ALIGNED_SIZE\t((sizeof(pcap_t) + 7) & ~0x7)\n\tchunk = malloc(PCAP_T_ALIGNED_SIZE + size);\n\tif (chunk == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\treturn (NULL);\n\t}\n\tmemset(chunk, 0, PCAP_T_ALIGNED_SIZE + size);\n\n\t/*\n\t * Get a pointer to the pcap_t at the beginning.\n\t */\n\tp = (pcap_t *)chunk;\n\n#ifdef _WIN32\n\tp->handle = INVALID_HANDLE_VALUE;\t/* not opened yet */\n#else /* _WIN32 */\n\tp->fd = -1;\t/* not opened yet */\n#ifndef MSDOS\n\tp->selectable_fd = -1;\n\tp->required_select_timeout = NULL;\n#endif /* MSDOS */\n#endif /* _WIN32 */\n\n\tif (size == 0) {\n\t\t/* No private data was requested. */\n\t\tp->priv = NULL;\n\t} else {\n\t\t/*\n\t\t * Set the pointer to the private data; that's the structure\n\t\t * of size \"size\" following the pcap_t.\n\t\t */\n\t\tp->priv = (void *)(chunk + PCAP_T_ALIGNED_SIZE);\n\t}\n\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              2244,
              0
            ],
            [
              2300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_alloc_pcap_t",
            "parameters": {
              "ebuf": "char",
              "size": "size_t"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_create_common(char *ebuf, size_t size)\n{\n\tpcap_t *p;\n\n\tp = pcap_alloc_pcap_t(ebuf, size);\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\t/*\n\t * Default to \"can't set rfmon mode\"; if it's supported by\n\t * a platform, the create routine that called us can set\n\t * the op to its routine to check whether a particular\n\t * device supports it.\n\t */\n\tp->can_set_rfmon_op = pcap_cant_set_rfmon;\n\n\t/*\n\t * If pcap_setnonblock() is called on a not-yet-activated\n\t * pcap_t, default to setting a flag and turning\n\t * on non-blocking mode when activated.\n\t */\n\tp->setnonblock_op = pcap_setnonblock_unactivated;\n\n\tinitialize_ops(p);\n\n\t/* put in some defaults*/\n\tp->snapshot = 0;\t\t/* max packet size unspecified */\n\tp->opt.timeout = 0;\t\t/* no timeout specified */\n\tp->opt.buffer_size = 0;\t\t/* use the platform's default */\n\tp->opt.promisc = 0;\n\tp->opt.rfmon = 0;\n\tp->opt.immediate = 0;\n\tp->opt.tstamp_type = -1;\t/* default to not setting time stamp type */\n\tp->opt.tstamp_precision = PCAP_TSTAMP_PRECISION_MICRO;\n\t/*\n\t * Platform-dependent options.\n\t */\n#ifdef __linux__\n\tp->opt.protocol = 0;\n#endif\n#ifdef _WIN32\n\tp->opt.nocapture_local = 0;\n#endif\n\n\t/*\n\t * Start out with no BPF code generation flags set.\n\t */\n\tp->bpf_codegen_flags = 0;\n\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              2302,
              0
            ],
            [
              2353,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_common",
            "parameters": {
              "ebuf": "char",
              "size": "size_t"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "int\npcap_check_activated(pcap_t *p)\n{\n\tif (p->activated) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"can't perform \"\n\t\t\t\" operation on activated capture\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2355,
              0
            ],
            [
              2364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_check_activated",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_set_snaplen(pcap_t *p, int snaplen)\n{\n\tif (pcap_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\tp->snapshot = snaplen;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2366,
              0
            ],
            [
              2373,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_snaplen",
            "parameters": {
              "p": "pcap_t",
              "snaplen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_set_promisc(pcap_t *p, int promisc)\n{\n\tif (pcap_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\tp->opt.promisc = promisc;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2375,
              0
            ],
            [
              2382,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_promisc",
            "parameters": {
              "p": "pcap_t",
              "promisc": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_set_rfmon(pcap_t *p, int rfmon)\n{\n\tif (pcap_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\tp->opt.rfmon = rfmon;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2384,
              0
            ],
            [
              2391,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_rfmon",
            "parameters": {
              "p": "pcap_t",
              "rfmon": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_set_timeout(pcap_t *p, int timeout_ms)\n{\n\tif (pcap_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\tp->opt.timeout = timeout_ms;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2393,
              0
            ],
            [
              2400,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_timeout",
            "parameters": {
              "p": "pcap_t",
              "timeout_ms": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_set_tstamp_type(pcap_t *p, int tstamp_type)\n{\n\tint i;\n\n\tif (pcap_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\n\t/*\n\t * The argument should have been u_int, but that's too late\n\t * to change now - it's an API.\n\t */\n\tif (tstamp_type < 0)\n\t\treturn (PCAP_WARNING_TSTAMP_TYPE_NOTSUP);\n\n\t/*\n\t * If p->tstamp_type_count is 0, we only support PCAP_TSTAMP_HOST;\n\t * the default time stamp type is PCAP_TSTAMP_HOST.\n\t */\n\tif (p->tstamp_type_count == 0) {\n\t\tif (tstamp_type == PCAP_TSTAMP_HOST) {\n\t\t\tp->opt.tstamp_type = tstamp_type;\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Check whether we claim to support this type of time stamp.\n\t\t */\n\t\tfor (i = 0; i < p->tstamp_type_count; i++) {\n\t\t\tif (p->tstamp_type_list[i] == (u_int)tstamp_type) {\n\t\t\t\t/*\n\t\t\t\t * Yes.\n\t\t\t\t */\n\t\t\t\tp->opt.tstamp_type = tstamp_type;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We don't support this type of time stamp.\n\t */\n\treturn (PCAP_WARNING_TSTAMP_TYPE_NOTSUP);\n}",
          "fn_code_pos": [
            [
              2402,
              0
            ],
            [
              2445,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_tstamp_type",
            "parameters": {
              "p": "pcap_t",
              "tstamp_type": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_set_immediate_mode(pcap_t *p, int immediate)\n{\n\tif (pcap_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\tp->opt.immediate = immediate;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2447,
              0
            ],
            [
              2454,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_immediate_mode",
            "parameters": {
              "p": "pcap_t",
              "immediate": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_set_buffer_size(pcap_t *p, int buffer_size)\n{\n\tif (pcap_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\tif (buffer_size <= 0) {\n\t\t/*\n\t\t * Silently ignore invalid values.\n\t\t */\n\t\treturn (0);\n\t}\n\tp->opt.buffer_size = buffer_size;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              2456,
              0
            ],
            [
              2469,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_buffer_size",
            "parameters": {
              "p": "pcap_t",
              "buffer_size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_set_tstamp_precision(pcap_t *p, int tstamp_precision)\n{\n\tint i;\n\n\tif (pcap_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\n\t/*\n\t * The argument should have been u_int, but that's too late\n\t * to change now - it's an API.\n\t */\n\tif (tstamp_precision < 0)\n\t\treturn (PCAP_ERROR_TSTAMP_PRECISION_NOTSUP);\n\n\t/*\n\t * If p->tstamp_precision_count is 0, we only support setting\n\t * the time stamp precision to microsecond precision; every\n\t * pcap module *MUST* support microsecond precision, even if\n\t * it does so by converting the native precision to\n\t * microseconds.\n\t */\n\tif (p->tstamp_precision_count == 0) {\n\t\tif (tstamp_precision == PCAP_TSTAMP_PRECISION_MICRO) {\n\t\t\tp->opt.tstamp_precision = tstamp_precision;\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Check whether we claim to support this precision of\n\t\t * time stamp.\n\t\t */\n\t\tfor (i = 0; i < p->tstamp_precision_count; i++) {\n\t\t\tif (p->tstamp_precision_list[i] == (u_int)tstamp_precision) {\n\t\t\t\t/*\n\t\t\t\t * Yes.\n\t\t\t\t */\n\t\t\t\tp->opt.tstamp_precision = tstamp_precision;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * We don't support this time stamp precision.\n\t */\n\treturn (PCAP_ERROR_TSTAMP_PRECISION_NOTSUP);\n}",
          "fn_code_pos": [
            [
              2471,
              0
            ],
            [
              2518,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_tstamp_precision",
            "parameters": {
              "p": "pcap_t",
              "tstamp_precision": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_get_tstamp_precision(pcap_t *p)\n{\n        return (p->opt.tstamp_precision);\n}",
          "fn_code_pos": [
            [
              2520,
              0
            ],
            [
              2524,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_get_tstamp_precision",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_activate(pcap_t *p)\n{\n\tint status;\n\n\t/*\n\t * Catch attempts to re-activate an already-activated\n\t * pcap_t; this should, for example, catch code that\n\t * calls pcap_open_live() followed by pcap_activate(),\n\t * as some code that showed up in a Stack Exchange\n\t * question did.\n\t */\n\tif (pcap_check_activated(p))\n\t\treturn (PCAP_ERROR_ACTIVATED);\n\tstatus = p->activate_op(p);\n\tif (status >= 0) {\n\t\t/*\n\t\t * If somebody requested non-blocking mode before\n\t\t * calling pcap_activate(), turn it on now.\n\t\t */\n\t\tif (p->opt.nonblock) {\n\t\t\tstatus = p->setnonblock_op(p, 1);\n\t\t\tif (status < 0) {\n\t\t\t\t/*\n\t\t\t\t * Failed.  Undo everything done by\n\t\t\t\t * the activate operation.\n\t\t\t\t */\n\t\t\t\tp->cleanup_op(p);\n\t\t\t\tinitialize_ops(p);\n\t\t\t\treturn (status);\n\t\t\t}\n\t\t}\n\t\tp->activated = 1;\n\t} else {\n\t\tif (p->errbuf[0] == '\\0') {\n\t\t\t/*\n\t\t\t * No error message supplied by the activate routine;\n\t\t\t * for the benefit of programs that don't specially\n\t\t\t * handle errors other than PCAP_ERROR, return the\n\t\t\t * error message corresponding to the status.\n\t\t\t */\n\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE, \"%s\",\n\t\t\t    pcap_statustostr(status));\n\t\t}\n\n\t\t/*\n\t\t * Undo any operation pointer setting, etc. done by\n\t\t * the activate operation.\n\t\t */\n\t\tinitialize_ops(p);\n\t}\n\treturn (status);\n}",
          "fn_code_pos": [
            [
              2526,
              0
            ],
            [
              2578,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_activate",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_open_live(const char *device, int snaplen, int promisc, int to_ms, char *errbuf)\n{\n\tpcap_t *p;\n\tint status;\n#ifdef ENABLE_REMOTE\n\tchar host[PCAP_BUF_SIZE + 1];\n\tchar port[PCAP_BUF_SIZE + 1];\n\tchar name[PCAP_BUF_SIZE + 1];\n\tint srctype;\n\n\t/*\n\t * Retrofit - we have to make older applications compatible with\n\t * remote capture.\n\t * So we're calling pcap_open_remote() from here; this is a very\n\t * dirty hack.\n\t * Obviously, we cannot exploit all the new features; for instance,\n\t * we cannot send authentication, we cannot use a UDP data connection,\n\t * and so on.\n\t */\n\tif (pcap_parsesrcstr(device, &srctype, host, port, name, errbuf))\n\t\treturn (NULL);\n\n\tif (srctype == PCAP_SRC_IFREMOTE) {\n\t\t/*\n\t\t * Although we already have host, port and iface, we prefer\n\t\t * to pass only 'device' to pcap_open_rpcap(), so that it has\n\t\t * to call pcap_parsesrcstr() again.\n\t\t * This is less optimized, but much clearer.\n\t\t */\n\t\treturn (pcap_open_rpcap(device, snaplen,\n\t\t    promisc ? PCAP_OPENFLAG_PROMISCUOUS : 0, to_ms,\n\t\t    NULL, errbuf));\n\t}\n\tif (srctype == PCAP_SRC_FILE) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"unknown URL scheme \\\"file\\\"\");\n\t\treturn (NULL);\n\t}\n\tif (srctype == PCAP_SRC_IFLOCAL) {\n\t\t/*\n\t\t * If it starts with rpcap://, that refers to a local device\n\t\t * (no host part in the URL). Remove the rpcap://, and\n\t\t * fall through to the regular open path.\n\t\t */\n\t\tif (strncmp(device, PCAP_SRC_IF_STRING, strlen(PCAP_SRC_IF_STRING)) == 0) {\n\t\t\tsize_t len = strlen(device) - strlen(PCAP_SRC_IF_STRING) + 1;\n\n\t\t\tif (len > 0)\n\t\t\t\tdevice += strlen(PCAP_SRC_IF_STRING);\n\t\t}\n\t}\n#endif\t/* ENABLE_REMOTE */\n\n\tp = pcap_create(device, errbuf);\n\tif (p == NULL)\n\t\treturn (NULL);\n\tstatus = pcap_set_snaplen(p, snaplen);\n\tif (status < 0)\n\t\tgoto fail;\n\tstatus = pcap_set_promisc(p, promisc);\n\tif (status < 0)\n\t\tgoto fail;\n\tstatus = pcap_set_timeout(p, to_ms);\n\tif (status < 0)\n\t\tgoto fail;\n\t/*\n\t * Mark this as opened with pcap_open_live(), so that, for\n\t * example, we show the full list of DLT_ values, rather\n\t * than just the ones that are compatible with capturing\n\t * when not in monitor mode.  That allows existing applications\n\t * to work the way they used to work, but allows new applications\n\t * that know about the new open API to, for example, find out the\n\t * DLT_ values that they can select without changing whether\n\t * the adapter is in monitor mode or not.\n\t */\n\tp->oldstyle = 1;\n\tstatus = pcap_activate(p);\n\tif (status < 0)\n\t\tgoto fail;\n\treturn (p);\nfail:\n\tif (status == PCAP_ERROR)\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"%s: %.*s\", device,\n\t\t    PCAP_ERRBUF_SIZE - 3, p->errbuf);\n\telse if (status == PCAP_ERROR_NO_SUCH_DEVICE ||\n\t    status == PCAP_ERROR_PERM_DENIED ||\n\t    status == PCAP_ERROR_PROMISC_PERM_DENIED)\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"%s: %s (%.*s)\", device,\n\t\t    pcap_statustostr(status), PCAP_ERRBUF_SIZE - 6, p->errbuf);\n\telse\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"%s: %s\", device,\n\t\t    pcap_statustostr(status));\n\tpcap_close(p);\n\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              2580,
              0
            ],
            [
              2674,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_live",
            "parameters": {
              "device": "char",
              "snaplen": "int",
              "promisc": "int",
              "to_ms": "int",
              "errbuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_open_offline_common(char *ebuf, size_t size)\n{\n\tpcap_t *p;\n\n\tp = pcap_alloc_pcap_t(ebuf, size);\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->opt.tstamp_precision = PCAP_TSTAMP_PRECISION_MICRO;\n\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              2676,
              0
            ],
            [
              2688,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_offline_common",
            "parameters": {
              "ebuf": "char",
              "size": "size_t"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "int\npcap_dispatch(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\treturn (p->read_op(p, cnt, callback, user));\n}",
          "fn_code_pos": [
            [
              2690,
              0
            ],
            [
              2694,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dispatch",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_loop(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tregister int n;\n\n\tfor (;;) {\n\t\tif (p->rfile != NULL) {\n\t\t\t/*\n\t\t\t * 0 means EOF, so don't loop if we get 0.\n\t\t\t */\n\t\t\tn = pcap_offline_read(p, cnt, callback, user);\n\t\t} else {\n\t\t\t/*\n\t\t\t * XXX keep reading until we get something\n\t\t\t * (or an error occurs)\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tn = p->read_op(p, cnt, callback, user);\n\t\t\t} while (n == 0);\n\t\t}\n\t\tif (n <= 0)\n\t\t\treturn (n);\n\t\tif (!PACKET_COUNT_IS_UNLIMITED(cnt)) {\n\t\t\tcnt -= n;\n\t\t\tif (cnt <= 0)\n\t\t\t\treturn (0);\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              2696,
              0
            ],
            [
              2724,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_loop",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\npcap_breakloop(pcap_t *p)\n{\n\tp->breakloop_op(p);\n}",
          "fn_code_pos": [
            [
              2729,
              0
            ],
            [
              2733,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_breakloop",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\npcap_datalink(pcap_t *p)\n{\n\tif (!p->activated)\n\t\treturn (PCAP_ERROR_NOT_ACTIVATED);\n\treturn (p->linktype);\n}",
          "fn_code_pos": [
            [
              2735,
              0
            ],
            [
              2741,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_datalink",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_datalink_ext(pcap_t *p)\n{\n\tif (!p->activated)\n\t\treturn (PCAP_ERROR_NOT_ACTIVATED);\n\treturn (p->linktype_ext);\n}",
          "fn_code_pos": [
            [
              2743,
              0
            ],
            [
              2749,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_datalink_ext",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_list_datalinks(pcap_t *p, int **dlt_buffer)\n{\n\tif (!p->activated)\n\t\treturn (PCAP_ERROR_NOT_ACTIVATED);\n\tif (p->dlt_count == 0) {\n\t\t/*\n\t\t * We couldn't fetch the list of DLTs, which means\n\t\t * this platform doesn't support changing the\n\t\t * DLT for an interface.  Return a list of DLTs\n\t\t * containing only the DLT this device supports.\n\t\t */\n\t\t*dlt_buffer = (int*)malloc(sizeof(**dlt_buffer));\n\t\tif (*dlt_buffer == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\t**dlt_buffer = p->linktype;\n\t\treturn (1);\n\t} else {\n\t\t*dlt_buffer = (int*)calloc(sizeof(**dlt_buffer), p->dlt_count);\n\t\tif (*dlt_buffer == NULL) {\n\t\t\tpcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t\t    errno, \"malloc\");\n\t\t\treturn (PCAP_ERROR);\n\t\t}\n\t\t(void)memcpy(*dlt_buffer, p->dlt_list,\n\t\t    sizeof(**dlt_buffer) * p->dlt_count);\n\t\treturn (p->dlt_count);\n\t}\n}",
          "fn_code_pos": [
            [
              2751,
              0
            ],
            [
              2782,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_list_datalinks",
            "parameters": {
              "p": "pcap_t",
              "dlt_buffer": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\npcap_free_datalinks(int *dlt_list)\n{\n\tfree(dlt_list);\n}",
          "fn_code_pos": [
            [
              2795,
              0
            ],
            [
              2799,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_free_datalinks",
            "parameters": {
              "dlt_list": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\npcap_set_datalink(pcap_t *p, int dlt)\n{\n\tint i;\n\tconst char *dlt_name;\n\n\tif (dlt < 0)\n\t\tgoto unsupported;\n\n\tif (p->dlt_count == 0 || p->set_datalink_op == NULL) {\n\t\t/*\n\t\t * We couldn't fetch the list of DLTs, or we don't\n\t\t * have a \"set datalink\" operation, which means\n\t\t * this platform doesn't support changing the\n\t\t * DLT for an interface.  Check whether the new\n\t\t * DLT is the one this interface supports.\n\t\t */\n\t\tif (p->linktype != dlt)\n\t\t\tgoto unsupported;\n\n\t\t/*\n\t\t * It is, so there's nothing we need to do here.\n\t\t */\n\t\treturn (0);\n\t}\n\tfor (i = 0; i < p->dlt_count; i++)\n\t\tif (p->dlt_list[i] == (u_int)dlt)\n\t\t\tbreak;\n\tif (i >= p->dlt_count)\n\t\tgoto unsupported;\n\tif (p->dlt_count == 2 && p->dlt_list[0] == DLT_EN10MB &&\n\t    dlt == DLT_DOCSIS) {\n\t\t/*\n\t\t * This is presumably an Ethernet device, as the first\n\t\t * link-layer type it offers is DLT_EN10MB, and the only\n\t\t * other type it offers is DLT_DOCSIS.  That means that\n\t\t * we can't tell the driver to supply DOCSIS link-layer\n\t\t * headers - we're just pretending that's what we're\n\t\t * getting, as, presumably, we're capturing on a dedicated\n\t\t * link to a Cisco Cable Modem Termination System, and\n\t\t * it's putting raw DOCSIS frames on the wire inside low-level\n\t\t * Ethernet framing.\n\t\t */\n\t\tp->linktype = dlt;\n\t\treturn (0);\n\t}\n\tif (p->set_datalink_op(p, dlt) == -1)\n\t\treturn (-1);\n\tp->linktype = dlt;\n\treturn (0);\n\nunsupported:\n\tdlt_name = pcap_datalink_val_to_name(dlt);\n\tif (dlt_name != NULL) {\n\t\t(void) pcap_snprintf(p->errbuf, sizeof(p->errbuf),\n\t\t    \"%s is not one of the DLTs supported by this device\",\n\t\t    dlt_name);\n\t} else {\n\t\t(void) pcap_snprintf(p->errbuf, sizeof(p->errbuf),\n\t\t    \"DLT %d is not one of the DLTs supported by this device\",\n\t\t    dlt);\n\t}\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              2801,
              0
            ],
            [
              2864,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_datalink",
            "parameters": {
              "p": "pcap_t",
              "dlt": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_strcasecmp(const char *s1, const char *s2)\n{\n\tregister const u_char\t*cm = charmap,\n\t\t\t\t*us1 = (const u_char *)s1,\n\t\t\t\t*us2 = (const u_char *)s2;\n\n\twhile (cm[*us1] == cm[*us2++])\n\t\tif (*us1++ == '\\0')\n\t\t\treturn(0);\n\treturn (cm[*us1] - cm[*--us2]);\n}",
          "fn_code_pos": [
            [
              2938,
              0
            ],
            [
              2949,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_strcasecmp",
            "parameters": {
              "s1": "char",
              "s2": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_datalink_name_to_val(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; dlt_choices[i].name != NULL; i++) {\n\t\tif (pcap_strcasecmp(dlt_choices[i].name, name) == 0)\n\t\t\treturn (dlt_choices[i].dlt);\n\t}\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              3107,
              0
            ],
            [
              3117,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_datalink_name_to_val",
            "parameters": {
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char *\npcap_datalink_val_to_name(int dlt)\n{\n\tint i;\n\n\tfor (i = 0; dlt_choices[i].name != NULL; i++) {\n\t\tif (dlt_choices[i].dlt == dlt)\n\t\t\treturn (dlt_choices[i].name);\n\t}\n\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              3119,
              0
            ],
            [
              3129,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_datalink_val_to_name",
            "parameters": {
              "dlt": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *\npcap_datalink_val_to_description(int dlt)\n{\n\tint i;\n\n\tfor (i = 0; dlt_choices[i].name != NULL; i++) {\n\t\tif (dlt_choices[i].dlt == dlt)\n\t\t\treturn (dlt_choices[i].description);\n\t}\n\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              3131,
              0
            ],
            [
              3141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_datalink_val_to_description",
            "parameters": {
              "dlt": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int\npcap_tstamp_type_name_to_val(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; tstamp_type_choices[i].name != NULL; i++) {\n\t\tif (pcap_strcasecmp(tstamp_type_choices[i].name, name) == 0)\n\t\t\treturn (tstamp_type_choices[i].type);\n\t}\n\treturn (PCAP_ERROR);\n}",
          "fn_code_pos": [
            [
              3158,
              0
            ],
            [
              3168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_tstamp_type_name_to_val",
            "parameters": {
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char *\npcap_tstamp_type_val_to_name(int tstamp_type)\n{\n\tint i;\n\n\tfor (i = 0; tstamp_type_choices[i].name != NULL; i++) {\n\t\tif (tstamp_type_choices[i].type == tstamp_type)\n\t\t\treturn (tstamp_type_choices[i].name);\n\t}\n\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              3170,
              0
            ],
            [
              3180,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_tstamp_type_val_to_name",
            "parameters": {
              "tstamp_type": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *\npcap_tstamp_type_val_to_description(int tstamp_type)\n{\n\tint i;\n\n\tfor (i = 0; tstamp_type_choices[i].name != NULL; i++) {\n\t\tif (tstamp_type_choices[i].type == tstamp_type)\n\t\t\treturn (tstamp_type_choices[i].description);\n\t}\n\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              3182,
              0
            ],
            [
              3192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_tstamp_type_val_to_description",
            "parameters": {
              "tstamp_type": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int\npcap_snapshot(pcap_t *p)\n{\n\tif (!p->activated)\n\t\treturn (PCAP_ERROR_NOT_ACTIVATED);\n\treturn (p->snapshot);\n}",
          "fn_code_pos": [
            [
              3194,
              0
            ],
            [
              3200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_snapshot",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_is_swapped(pcap_t *p)\n{\n\tif (!p->activated)\n\t\treturn (PCAP_ERROR_NOT_ACTIVATED);\n\treturn (p->swapped);\n}",
          "fn_code_pos": [
            [
              3202,
              0
            ],
            [
              3208,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_is_swapped",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_major_version(pcap_t *p)\n{\n\tif (!p->activated)\n\t\treturn (PCAP_ERROR_NOT_ACTIVATED);\n\treturn (p->version_major);\n}",
          "fn_code_pos": [
            [
              3210,
              0
            ],
            [
              3216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_major_version",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_minor_version(pcap_t *p)\n{\n\tif (!p->activated)\n\t\treturn (PCAP_ERROR_NOT_ACTIVATED);\n\treturn (p->version_minor);\n}",
          "fn_code_pos": [
            [
              3218,
              0
            ],
            [
              3224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_minor_version",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_bufsize(pcap_t *p)\n{\n\tif (!p->activated)\n\t\treturn (PCAP_ERROR_NOT_ACTIVATED);\n\treturn (p->bufsize);\n}",
          "fn_code_pos": [
            [
              3226,
              0
            ],
            [
              3232,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_bufsize",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "FILE *\npcap_file(pcap_t *p)\n{\n\treturn (p->rfile);\n}",
          "fn_code_pos": [
            [
              3234,
              0
            ],
            [
              3238,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_file",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "FILE"
          }
        },
        {
          "fn_code": "int\npcap_fileno(pcap_t *p)\n{\n#ifndef _WIN32\n\treturn (p->fd);\n#else\n\tif (p->handle != INVALID_HANDLE_VALUE)\n\t\treturn ((int)(DWORD)p->handle);\n\telse\n\t\treturn (PCAP_ERROR);\n#endif\n}",
          "fn_code_pos": [
            [
              3240,
              0
            ],
            [
              3251,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_fileno",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_get_selectable_fd(pcap_t *p)\n{\n\treturn (p->selectable_fd);\n}",
          "fn_code_pos": [
            [
              3254,
              0
            ],
            [
              3258,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_get_selectable_fd",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "struct timeval *\npcap_get_required_select_timeout(pcap_t *p)\n{\n\treturn (p->required_select_timeout);\n}",
          "fn_code_pos": [
            [
              3260,
              0
            ],
            [
              3264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_get_required_select_timeout",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void\npcap_perror(pcap_t *p, const char *prefix)\n{\n\tfprintf(stderr, \"%s: %s\\n\", prefix, p->errbuf);\n}",
          "fn_code_pos": [
            [
              3267,
              0
            ],
            [
              3271,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_perror",
            "parameters": {
              "p": "pcap_t",
              "prefix": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "char *\npcap_geterr(pcap_t *p)\n{\n\treturn (p->errbuf);\n}",
          "fn_code_pos": [
            [
              3273,
              0
            ],
            [
              3277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_geterr",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int\npcap_getnonblock(pcap_t *p, char *errbuf)\n{\n\tint ret;\n\n\tret = p->getnonblock_op(p);\n\tif (ret == -1) {\n\t\t/*\n\t\t * The get nonblock operation sets p->errbuf; this\n\t\t * function *shouldn't* have had a separate errbuf\n\t\t * argument, as it didn't need one, but I goofed\n\t\t * when adding it.\n\t\t *\n\t\t * We copy the error message to errbuf, so callers\n\t\t * can find it in either place.\n\t\t */\n\t\tpcap_strlcpy(errbuf, p->errbuf, PCAP_ERRBUF_SIZE);\n\t}\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              3279,
              0
            ],
            [
              3298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getnonblock",
            "parameters": {
              "p": "pcap_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_getnonblock_fd(pcap_t *p)\n{\n\tint fdflags;\n\n\tfdflags = fcntl(p->fd, F_GETFL, 0);\n\tif (fdflags == -1) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"F_GETFL\");\n\t\treturn (-1);\n\t}\n\tif (fdflags & O_NONBLOCK)\n\t\treturn (1);\n\telse\n\t\treturn (0);\n}",
          "fn_code_pos": [
            [
              3305,
              0
            ],
            [
              3320,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getnonblock_fd",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_setnonblock(pcap_t *p, int nonblock, char *errbuf)\n{\n\tint ret;\n\n\tret = p->setnonblock_op(p, nonblock);\n\tif (ret == -1) {\n\t\t/*\n\t\t * The set nonblock operation sets p->errbuf; this\n\t\t * function *shouldn't* have had a separate errbuf\n\t\t * argument, as it didn't need one, but I goofed\n\t\t * when adding it.\n\t\t *\n\t\t * We copy the error message to errbuf, so callers\n\t\t * can find it in either place.\n\t\t */\n\t\tpcap_strlcpy(errbuf, p->errbuf, PCAP_ERRBUF_SIZE);\n\t}\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              3323,
              0
            ],
            [
              3342,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setnonblock",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_setnonblock_fd(pcap_t *p, int nonblock)\n{\n\tint fdflags;\n\n\tfdflags = fcntl(p->fd, F_GETFL, 0);\n\tif (fdflags == -1) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"F_GETFL\");\n\t\treturn (-1);\n\t}\n\tif (nonblock)\n\t\tfdflags |= O_NONBLOCK;\n\telse\n\t\tfdflags &= ~O_NONBLOCK;\n\tif (fcntl(p->fd, F_SETFL, fdflags) == -1) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"F_SETFL\");\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              3351,
              0
            ],
            [
              3372,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setnonblock_fd",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char *\npcap_statustostr(int errnum)\n{\n\tstatic char ebuf[15+10+1];\n\n\tswitch (errnum) {\n\n\tcase PCAP_WARNING:\n\t\treturn(\"Generic warning\");\n\n\tcase PCAP_WARNING_TSTAMP_TYPE_NOTSUP:\n\t\treturn (\"That type of time stamp is not supported by that device\");\n\n\tcase PCAP_WARNING_PROMISC_NOTSUP:\n\t\treturn (\"That device doesn't support promiscuous mode\");\n\n\tcase PCAP_ERROR:\n\t\treturn(\"Generic error\");\n\n\tcase PCAP_ERROR_BREAK:\n\t\treturn(\"Loop terminated by pcap_breakloop\");\n\n\tcase PCAP_ERROR_NOT_ACTIVATED:\n\t\treturn(\"The pcap_t has not been activated\");\n\n\tcase PCAP_ERROR_ACTIVATED:\n\t\treturn (\"The setting can't be changed after the pcap_t is activated\");\n\n\tcase PCAP_ERROR_NO_SUCH_DEVICE:\n\t\treturn (\"No such device exists\");\n\n\tcase PCAP_ERROR_RFMON_NOTSUP:\n\t\treturn (\"That device doesn't support monitor mode\");\n\n\tcase PCAP_ERROR_NOT_RFMON:\n\t\treturn (\"That operation is supported only in monitor mode\");\n\n\tcase PCAP_ERROR_PERM_DENIED:\n\t\treturn (\"You don't have permission to capture on that device\");\n\n\tcase PCAP_ERROR_IFACE_NOT_UP:\n\t\treturn (\"That device is not up\");\n\n\tcase PCAP_ERROR_CANTSET_TSTAMP_TYPE:\n\t\treturn (\"That device doesn't support setting the time stamp type\");\n\n\tcase PCAP_ERROR_PROMISC_PERM_DENIED:\n\t\treturn (\"You don't have permission to capture in promiscuous mode on that device\");\n\n\tcase PCAP_ERROR_TSTAMP_PRECISION_NOTSUP:\n\t\treturn (\"That device doesn't support that time stamp precision\");\n\t}\n\t(void)pcap_snprintf(ebuf, sizeof ebuf, \"Unknown error: %d\", errnum);\n\treturn(ebuf);\n}",
          "fn_code_pos": [
            [
              3378,
              0
            ],
            [
              3432,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_statustostr",
            "parameters": {
              "errnum": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *\npcap_strerror(int errnum)\n{\n#ifdef HAVE_STRERROR\n#ifdef _WIN32\n\tstatic char errbuf[PCAP_ERRBUF_SIZE];\n\terrno_t err = strerror_s(errbuf, PCAP_ERRBUF_SIZE, errnum);\n\n\tif (err != 0) /* err = 0 if successful */\n\t\tpcap_strlcpy(errbuf, \"strerror_s() error\", PCAP_ERRBUF_SIZE);\n\treturn (errbuf);\n#else\n\treturn (strerror(errnum));\n#endif /* _WIN32 */\n#else\n\textern int sys_nerr;\n\textern const char *const sys_errlist[];\n\tstatic char errbuf[PCAP_ERRBUF_SIZE];\n\n\tif ((unsigned int)errnum < sys_nerr)\n\t\treturn ((char *)sys_errlist[errnum]);\n\t(void)pcap_snprintf(errbuf, sizeof errbuf, \"Unknown error: %d\", errnum);\n\treturn (errbuf);\n#endif\n}",
          "fn_code_pos": [
            [
              3437,
              0
            ],
            [
              3461,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_strerror",
            "parameters": {
              "errnum": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int\npcap_setfilter(pcap_t *p, struct bpf_program *fp)\n{\n\treturn (p->setfilter_op(p, fp));\n}",
          "fn_code_pos": [
            [
              3463,
              0
            ],
            [
              3467,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter",
            "parameters": {
              "p": "pcap_t",
              "fp": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_setdirection(pcap_t *p, pcap_direction_t d)\n{\n\tif (p->setdirection_op == NULL) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Setting direction is not implemented on this platform\");\n\t\treturn (-1);\n\t} else\n\t\treturn (p->setdirection_op(p, d));\n}",
          "fn_code_pos": [
            [
              3475,
              0
            ],
            [
              3484,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setdirection",
            "parameters": {
              "p": "pcap_t",
              "d": "pcap_direction_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_stats(pcap_t *p, struct pcap_stat *ps)\n{\n\treturn (p->stats_op(p, ps));\n}",
          "fn_code_pos": [
            [
              3486,
              0
            ],
            [
              3490,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "struct pcap_stat *\npcap_stats_ex(pcap_t *p, int *pcap_stat_size)\n{\n\treturn (p->stats_ex_op(p, pcap_stat_size));\n}",
          "fn_code_pos": [
            [
              3493,
              0
            ],
            [
              3497,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_ex",
            "parameters": {
              "p": "pcap_t",
              "pcap_stat_size": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "int\npcap_setbuff(pcap_t *p, int dim)\n{\n\treturn (p->setbuff_op(p, dim));\n}",
          "fn_code_pos": [
            [
              3499,
              0
            ],
            [
              3503,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setbuff",
            "parameters": {
              "p": "pcap_t",
              "dim": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_setmode(pcap_t *p, int mode)\n{\n\treturn (p->setmode_op(p, mode));\n}",
          "fn_code_pos": [
            [
              3505,
              0
            ],
            [
              3509,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setmode",
            "parameters": {
              "p": "pcap_t",
              "mode": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_setmintocopy(pcap_t *p, int size)\n{\n\treturn (p->setmintocopy_op(p, size));\n}",
          "fn_code_pos": [
            [
              3511,
              0
            ],
            [
              3515,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setmintocopy",
            "parameters": {
              "p": "pcap_t",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "HANDLE\npcap_getevent(pcap_t *p)\n{\n\treturn (p->getevent_op(p));\n}",
          "fn_code_pos": [
            [
              3517,
              0
            ],
            [
              3521,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getevent",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "HANDLE"
          }
        },
        {
          "fn_code": "int\npcap_oid_get_request(pcap_t *p, bpf_u_int32 oid, void *data, size_t *lenp)\n{\n\treturn (p->oid_get_request_op(p, oid, data, lenp));\n}",
          "fn_code_pos": [
            [
              3523,
              0
            ],
            [
              3527,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_oid_get_request",
            "parameters": {
              "p": "pcap_t",
              "oid": "bpf_u_int32",
              "data": "void",
              "lenp": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_oid_set_request(pcap_t *p, bpf_u_int32 oid, const void *data, size_t *lenp)\n{\n\treturn (p->oid_set_request_op(p, oid, data, lenp));\n}",
          "fn_code_pos": [
            [
              3529,
              0
            ],
            [
              3533,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_oid_set_request",
            "parameters": {
              "p": "pcap_t",
              "oid": "bpf_u_int32",
              "data": "void",
              "lenp": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_send_queue *\npcap_sendqueue_alloc(u_int memsize)\n{\n\tpcap_send_queue *tqueue;\n\n\t/* Allocate the queue */\n\ttqueue = (pcap_send_queue *)malloc(sizeof(pcap_send_queue));\n\tif (tqueue == NULL){\n\t\treturn (NULL);\n\t}\n\n\t/* Allocate the buffer */\n\ttqueue->buffer = (char *)malloc(memsize);\n\tif (tqueue->buffer == NULL) {\n\t\tfree(tqueue);\n\t\treturn (NULL);\n\t}\n\n\ttqueue->maxlen = memsize;\n\ttqueue->len = 0;\n\n\treturn (tqueue);\n}",
          "fn_code_pos": [
            [
              3535,
              0
            ],
            [
              3557,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_sendqueue_alloc",
            "parameters": {
              "memsize": "u_int"
            },
            "return_type": "pcap_send_queue"
          }
        },
        {
          "fn_code": "void\npcap_sendqueue_destroy(pcap_send_queue *queue)\n{\n\tfree(queue->buffer);\n\tfree(queue);\n}",
          "fn_code_pos": [
            [
              3559,
              0
            ],
            [
              3564,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_sendqueue_destroy",
            "parameters": {
              "queue": "pcap_send_queue"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\npcap_sendqueue_queue(pcap_send_queue *queue, const struct pcap_pkthdr *pkt_header, const u_char *pkt_data)\n{\n\tif (queue->len + sizeof(struct pcap_pkthdr) + pkt_header->caplen > queue->maxlen){\n\t\treturn (-1);\n\t}\n\n\t/* Copy the pcap_pkthdr header*/\n\tmemcpy(queue->buffer + queue->len, pkt_header, sizeof(struct pcap_pkthdr));\n\tqueue->len += sizeof(struct pcap_pkthdr);\n\n\t/* copy the packet */\n\tmemcpy(queue->buffer + queue->len, pkt_data, pkt_header->caplen);\n\tqueue->len += pkt_header->caplen;\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              3566,
              0
            ],
            [
              3582,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_sendqueue_queue",
            "parameters": {
              "queue": "pcap_send_queue",
              "pkt_header": "struct pcap_pkthdr",
              "pkt_data": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "u_int\npcap_sendqueue_transmit(pcap_t *p, pcap_send_queue *queue, int sync)\n{\n\treturn (p->sendqueue_transmit_op(p, queue, sync));\n}",
          "fn_code_pos": [
            [
              3584,
              0
            ],
            [
              3588,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_sendqueue_transmit",
            "parameters": {
              "p": "pcap_t",
              "queue": "pcap_send_queue",
              "sync": "int"
            },
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "int\npcap_setuserbuffer(pcap_t *p, int size)\n{\n\treturn (p->setuserbuffer_op(p, size));\n}",
          "fn_code_pos": [
            [
              3590,
              0
            ],
            [
              3594,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setuserbuffer",
            "parameters": {
              "p": "pcap_t",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_live_dump(pcap_t *p, char *filename, int maxsize, int maxpacks)\n{\n\treturn (p->live_dump_op(p, filename, maxsize, maxpacks));\n}",
          "fn_code_pos": [
            [
              3596,
              0
            ],
            [
              3600,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_live_dump",
            "parameters": {
              "p": "pcap_t",
              "filename": "char",
              "maxsize": "int",
              "maxpacks": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_live_dump_ended(pcap_t *p, int sync)\n{\n\treturn (p->live_dump_ended_op(p, sync));\n}",
          "fn_code_pos": [
            [
              3602,
              0
            ],
            [
              3606,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_live_dump_ended",
            "parameters": {
              "p": "pcap_t",
              "sync": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "PAirpcapHandle\npcap_get_airpcap_handle(pcap_t *p)\n{\n\tPAirpcapHandle handle;\n\n\thandle = p->get_airpcap_handle_op(p);\n\tif (handle == NULL) {\n\t\t(void)pcap_snprintf(p->errbuf, sizeof(p->errbuf),\n\t\t    \"This isn't an AirPcap device\");\n\t}\n\treturn (handle);\n}",
          "fn_code_pos": [
            [
              3608,
              0
            ],
            [
              3619,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_get_airpcap_handle",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "PAirpcapHandle"
          }
        },
        {
          "fn_code": "static void\npcap_close_all(void)\n{\n\tstruct pcap *handle;\n\n\twhile ((handle = pcaps_to_close) != NULL)\n\t\tpcap_close(handle);\n}",
          "fn_code_pos": [
            [
              3647,
              0
            ],
            [
              3654,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_close_all",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\npcap_do_addexit(pcap_t *p)\n{\n\t/*\n\t * If we haven't already done so, arrange to have\n\t * \"pcap_close_all()\" called when we exit.\n\t */\n\tif (!did_atexit) {\n\t\tif (atexit(pcap_close_all) != 0) {\n\t\t\t/*\n\t\t\t * \"atexit()\" failed; let our caller know.\n\t\t\t */\n\t\t\tpcap_strlcpy(p->errbuf, \"atexit failed\", PCAP_ERRBUF_SIZE);\n\t\t\treturn (0);\n\t\t}\n\t\tdid_atexit = 1;\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              3656,
              0
            ],
            [
              3674,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_do_addexit",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\npcap_add_to_pcaps_to_close(pcap_t *p)\n{\n\tp->next = pcaps_to_close;\n\tpcaps_to_close = p;\n}",
          "fn_code_pos": [
            [
              3676,
              0
            ],
            [
              3681,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_add_to_pcaps_to_close",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\npcap_remove_from_pcaps_to_close(pcap_t *p)\n{\n\tpcap_t *pc, *prevpc;\n\n\tfor (pc = pcaps_to_close, prevpc = NULL; pc != NULL;\n\t    prevpc = pc, pc = pc->next) {\n\t\tif (pc == p) {\n\t\t\t/*\n\t\t\t * Found it.  Remove it from the list.\n\t\t\t */\n\t\t\tif (prevpc == NULL) {\n\t\t\t\t/*\n\t\t\t\t * It was at the head of the list.\n\t\t\t\t */\n\t\t\t\tpcaps_to_close = pc->next;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * It was in the middle of the list.\n\t\t\t\t */\n\t\t\t\tprevpc->next = pc->next;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              3683,
              0
            ],
            [
              3708,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_remove_from_pcaps_to_close",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\npcap_breakloop_common(pcap_t *p)\n{\n\tp->break_loop = 1;\n}",
          "fn_code_pos": [
            [
              3710,
              0
            ],
            [
              3714,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_breakloop_common",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\npcap_cleanup_live_common(pcap_t *p)\n{\n\tif (p->buffer != NULL) {\n\t\tfree(p->buffer);\n\t\tp->buffer = NULL;\n\t}\n\tif (p->dlt_list != NULL) {\n\t\tfree(p->dlt_list);\n\t\tp->dlt_list = NULL;\n\t\tp->dlt_count = 0;\n\t}\n\tif (p->tstamp_type_list != NULL) {\n\t\tfree(p->tstamp_type_list);\n\t\tp->tstamp_type_list = NULL;\n\t\tp->tstamp_type_count = 0;\n\t}\n\tif (p->tstamp_precision_list != NULL) {\n\t\tfree(p->tstamp_precision_list);\n\t\tp->tstamp_precision_list = NULL;\n\t\tp->tstamp_precision_count = 0;\n\t}\n\tpcap_freecode(&p->fcode);\n#if !defined(_WIN32) && !defined(MSDOS)\n\tif (p->fd >= 0) {\n\t\tclose(p->fd);\n\t\tp->fd = -1;\n\t}\n\tp->selectable_fd = -1;\n#endif\n}",
          "fn_code_pos": [
            [
              3717,
              0
            ],
            [
              3747,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_cleanup_live_common",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\npcap_sendpacket(pcap_t *p, const u_char *buf, int size)\n{\n\tif (size <= 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"The number of bytes to be sent must be positive\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tif (p->inject_op(p, buf, size) == -1)\n\t\treturn (-1);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              3755,
              0
            ],
            [
              3767,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_sendpacket",
            "parameters": {
              "p": "pcap_t",
              "buf": "u_char",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_inject(pcap_t *p, const void *buf, size_t size)\n{\n\t/*\n\t * We return the number of bytes written, so the number of\n\t * bytes to write must fit in an int.\n\t */\n\tif (size > INT_MAX) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"More than %d bytes cannot be injected\", INT_MAX);\n\t\treturn (PCAP_ERROR);\n\t}\n\n\tif (size == 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"The number of bytes to be injected must not be zero\");\n\t\treturn (PCAP_ERROR);\n\t}\n\n\treturn (p->inject_op(p, buf, (int)size));\n}",
          "fn_code_pos": [
            [
              3773,
              0
            ],
            [
              3793,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\npcap_close(pcap_t *p)\n{\n\tif (p->opt.device != NULL)\n\t\tfree(p->opt.device);\n\tp->cleanup_op(p);\n\tfree(p);\n}",
          "fn_code_pos": [
            [
              3795,
              0
            ],
            [
              3802,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_close",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\npcap_offline_filter(const struct bpf_program *fp, const struct pcap_pkthdr *h,\n    const u_char *pkt)\n{\n\tconst struct bpf_insn *fcode = fp->bf_insns;\n\n\tif (fcode != NULL)\n\t\treturn (pcap_filter(fcode, pkt, h->len, h->caplen));\n\telse\n\t\treturn (0);\n}",
          "fn_code_pos": [
            [
              3810,
              0
            ],
            [
              3820,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_offline_filter",
            "parameters": {
              "fp": "struct bpf_program",
              "h": "struct pcap_pkthdr",
              "pkt": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_can_set_rfmon_dead(pcap_t *p)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Rfmon mode doesn't apply on a pcap_open_dead pcap_t\");\n\treturn (PCAP_ERROR);\n}",
          "fn_code_pos": [
            [
              3822,
              0
            ],
            [
              3828,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_can_set_rfmon_dead",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_read_dead(pcap_t *p, int cnt _U_, pcap_handler callback _U_,\n    u_char *user _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Packets aren't available from a pcap_open_dead pcap_t\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              3830,
              0
            ],
            [
              3837,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_dead",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_inject_dead(pcap_t *p, const void *buf _U_, int size _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Packets can't be sent on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              3839,
              0
            ],
            [
              3845,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject_dead",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setfilter_dead(pcap_t *p, struct bpf_program *fp _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"A filter cannot be set on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              3847,
              0
            ],
            [
              3853,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_dead",
            "parameters": {
              "p": "pcap_t",
              "fp": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setdirection_dead(pcap_t *p, pcap_direction_t d _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The packet direction cannot be set on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              3855,
              0
            ],
            [
              3861,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setdirection_dead",
            "parameters": {
              "p": "pcap_t",
              "d": "pcap_direction_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_set_datalink_dead(pcap_t *p, int dlt _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The link-layer header type cannot be set on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              3863,
              0
            ],
            [
              3869,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_datalink_dead",
            "parameters": {
              "p": "pcap_t",
              "dlt": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_getnonblock_dead(pcap_t *p)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"A pcap_open_dead pcap_t does not have a non-blocking mode setting\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              3871,
              0
            ],
            [
              3877,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getnonblock_dead",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setnonblock_dead(pcap_t *p, int nonblock _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"A pcap_open_dead pcap_t does not have a non-blocking mode setting\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              3879,
              0
            ],
            [
              3885,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setnonblock_dead",
            "parameters": {
              "p": "pcap_t",
              "nonblock": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_stats_dead(pcap_t *p, struct pcap_stat *ps _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Statistics aren't available from a pcap_open_dead pcap_t\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              3887,
              0
            ],
            [
              3893,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_dead",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "struct pcap_stat *\npcap_stats_ex_dead(pcap_t *p, int *pcap_stat_size _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Statistics aren't available from a pcap_open_dead pcap_t\");\n\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              3896,
              0
            ],
            [
              3902,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_ex_dead",
            "parameters": {
              "p": "pcap_t",
              "pcap_stat_size": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static int\npcap_setbuff_dead(pcap_t *p, int dim)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The kernel buffer size cannot be set on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              3904,
              0
            ],
            [
              3910,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setbuff_dead",
            "parameters": {
              "p": "pcap_t",
              "dim": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setmode_dead(pcap_t *p, int mode)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"impossible to set mode on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              3912,
              0
            ],
            [
              3918,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setmode_dead",
            "parameters": {
              "p": "pcap_t",
              "mode": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setmintocopy_dead(pcap_t *p, int size)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The mintocopy parameter cannot be set on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              3920,
              0
            ],
            [
              3926,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setmintocopy_dead",
            "parameters": {
              "p": "pcap_t",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static HANDLE\npcap_getevent_dead(pcap_t *p)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"A pcap_open_dead pcap_t has no event handle\");\n\treturn (INVALID_HANDLE_VALUE);\n}",
          "fn_code_pos": [
            [
              3928,
              0
            ],
            [
              3934,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getevent_dead",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "HANDLE"
          }
        },
        {
          "fn_code": "static int\npcap_oid_get_request_dead(pcap_t *p, bpf_u_int32 oid _U_, void *data _U_,\n    size_t *lenp _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"An OID get request cannot be performed on a pcap_open_dead pcap_t\");\n\treturn (PCAP_ERROR);\n}",
          "fn_code_pos": [
            [
              3936,
              0
            ],
            [
              3943,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_oid_get_request_dead",
            "parameters": {
              "p": "pcap_t",
              "oid": "bpf_u_int32",
              "data": "void",
              "lenp": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_oid_set_request_dead(pcap_t *p, bpf_u_int32 oid _U_, const void *data _U_,\n    size_t *lenp _U_)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"An OID set request cannot be performed on a pcap_open_dead pcap_t\");\n\treturn (PCAP_ERROR);\n}",
          "fn_code_pos": [
            [
              3945,
              0
            ],
            [
              3952,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_oid_set_request_dead",
            "parameters": {
              "p": "pcap_t",
              "oid": "bpf_u_int32",
              "data": "void",
              "lenp": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static u_int\npcap_sendqueue_transmit_dead(pcap_t *p, pcap_send_queue *queue, int sync)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Packets cannot be transmitted on a pcap_open_dead pcap_t\");\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              3954,
              0
            ],
            [
              3960,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_sendqueue_transmit_dead",
            "parameters": {
              "p": "pcap_t",
              "queue": "pcap_send_queue",
              "sync": "int"
            },
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "static int\npcap_setuserbuffer_dead(pcap_t *p, int size)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"The user buffer cannot be set on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              3962,
              0
            ],
            [
              3968,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setuserbuffer_dead",
            "parameters": {
              "p": "pcap_t",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_live_dump_dead(pcap_t *p, char *filename, int maxsize, int maxpacks)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Live packet dumping cannot be performed on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              3970,
              0
            ],
            [
              3976,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_live_dump_dead",
            "parameters": {
              "p": "pcap_t",
              "filename": "char",
              "maxsize": "int",
              "maxpacks": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_live_dump_ended_dead(pcap_t *p, int sync)\n{\n\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Live packet dumping cannot be performed on a pcap_open_dead pcap_t\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              3978,
              0
            ],
            [
              3984,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_live_dump_ended_dead",
            "parameters": {
              "p": "pcap_t",
              "sync": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static PAirpcapHandle\npcap_get_airpcap_handle_dead(pcap_t *p)\n{\n\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              3986,
              0
            ],
            [
              3990,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_get_airpcap_handle_dead",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "PAirpcapHandle"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_open_dead_with_tstamp_precision(int linktype, int snaplen, u_int precision)\n{\n\tpcap_t *p;\n\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tbreak;\n\n\tdefault:\n\t\t/*\n\t\t * This doesn't really matter, but we don't have any way\n\t\t * to report particular errors, so the only failure we\n\t\t * should have is a memory allocation failure.  Just\n\t\t * pick microsecond precision.\n\t\t */\n\t\tprecision = PCAP_TSTAMP_PRECISION_MICRO;\n\t\tbreak;\n\t}\n\tp = malloc(sizeof(*p));\n\tif (p == NULL)\n\t\treturn NULL;\n\tmemset (p, 0, sizeof(*p));\n\tp->snapshot = snaplen;\n\tp->linktype = linktype;\n\tp->opt.tstamp_precision = precision;\n\tp->can_set_rfmon_op = pcap_can_set_rfmon_dead;\n\tp->read_op = pcap_read_dead;\n\tp->inject_op = pcap_inject_dead;\n\tp->setfilter_op = pcap_setfilter_dead;\n\tp->setdirection_op = pcap_setdirection_dead;\n\tp->set_datalink_op = pcap_set_datalink_dead;\n\tp->getnonblock_op = pcap_getnonblock_dead;\n\tp->setnonblock_op = pcap_setnonblock_dead;\n\tp->stats_op = pcap_stats_dead;\n#ifdef _WIN32\n\tp->stats_ex_op = pcap_stats_ex_dead;\n\tp->setbuff_op = pcap_setbuff_dead;\n\tp->setmode_op = pcap_setmode_dead;\n\tp->setmintocopy_op = pcap_setmintocopy_dead;\n\tp->getevent_op = pcap_getevent_dead;\n\tp->oid_get_request_op = pcap_oid_get_request_dead;\n\tp->oid_set_request_op = pcap_oid_set_request_dead;\n\tp->sendqueue_transmit_op = pcap_sendqueue_transmit_dead;\n\tp->setuserbuffer_op = pcap_setuserbuffer_dead;\n\tp->live_dump_op = pcap_live_dump_dead;\n\tp->live_dump_ended_op = pcap_live_dump_ended_dead;\n\tp->get_airpcap_handle_op = pcap_get_airpcap_handle_dead;\n#endif\n\tp->cleanup_op = pcap_cleanup_dead;\n\n\t/*\n\t * A \"dead\" pcap_t never requires special BPF code generation.\n\t */\n\tp->bpf_codegen_flags = 0;\n\n\tp->activated = 1;\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              3999,
              0
            ],
            [
              4059,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_dead_with_tstamp_precision",
            "parameters": {
              "linktype": "int",
              "snaplen": "int",
              "precision": "u_int"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_open_dead(int linktype, int snaplen)\n{\n\treturn (pcap_open_dead_with_tstamp_precision(linktype, snaplen,\n\t    PCAP_TSTAMP_PRECISION_MICRO));\n}",
          "fn_code_pos": [
            [
              4061,
              0
            ],
            [
              4066,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_dead",
            "parameters": {
              "linktype": "int",
              "snaplen": "int"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "PCAP_API_DEF void\npcap_set_parser_debug(int value)\n{\n\tpcap_debug = value;\n}",
          "fn_code_pos": [
            [
              4083,
              0
            ],
            [
              4087,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_parser_debug",
            "parameters": {
              "value": "int"
            },
            "return_type": "PCAP_API_DEF"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "pcap_stats_ex_not_initialized(pcap_t *pcap, int *pcap_stat_size _U_)",
          "fn_dec_pos": [
            [
              261,
              0
            ],
            [
              261,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_ex_not_initialized",
            "parameters": {
              "pcap": "pcap_t",
              "pcap_stat_size": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_next(pcap_t *p, struct pcap_pkthdr *h)",
          "fn_dec_pos": [
            [
              435,
              0
            ],
            [
              435,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_next",
            "parameters": {
              "p": "pcap_t",
              "h": "struct pcap_pkthdr"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*findalldevs_op)(pcap_if_list_t *, char *)",
          "fn_dec_pos": [
            [
              506,
              5
            ],
            [
              506,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*create_op)(const char *, char *, int *)",
          "fn_dec_pos": [
            [
              507,
              9
            ],
            [
              507,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "dup_sockaddr(struct sockaddr *sa, size_t sa_length)",
          "fn_dec_pos": [
            [
              601,
              0
            ],
            [
              601,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dup_sockaddr",
            "parameters": {
              "sa": "struct sockaddr",
              "sa_length": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "get_if_description(const char *name)",
          "fn_dec_pos": [
            [
              738,
              0
            ],
            [
              738,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_if_description",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "find_or_add_if(pcap_if_list_t *devlistp, const char *name,\n    bpf_u_int32 if_flags, get_if_flags_func get_flags_func, char *errbuf)",
          "fn_dec_pos": [
            [
              865,
              0
            ],
            [
              866,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_or_add_if",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "name": "char",
              "if_flags": "bpf_u_int32",
              "get_flags_func": "get_if_flags_func",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "find_or_add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,\n    get_if_flags_func get_flags_func, const char *description, char *errbuf)",
          "fn_dec_pos": [
            [
              1083,
              0
            ],
            [
              1084,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_or_add_dev",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "name": "char",
              "flags": "bpf_u_int32",
              "get_flags_func": "get_if_flags_func",
              "description": "char",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "find_dev(pcap_if_list_t *devlistp, const char *name)",
          "fn_dec_pos": [
            [
              1124,
              0
            ],
            [
              1124,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_dev",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "add_dev(pcap_if_list_t *devlistp, const char *name, bpf_u_int32 flags,\n    const char *description, char *errbuf)",
          "fn_dec_pos": [
            [
              1158,
              0
            ],
            [
              1159,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_dev",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "name": "char",
              "flags": "bpf_u_int32",
              "description": "char",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lookupdev(char *errbuf)",
          "fn_dec_pos": [
            [
              1341,
              0
            ],
            [
              1341,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lookupdev",
            "parameters": {
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "get_substring(const char *p, size_t len, char *ebuf)",
          "fn_dec_pos": [
            [
              1509,
              0
            ],
            [
              1509,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_substring",
            "parameters": {
              "p": "char",
              "len": "size_t",
              "ebuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_create(const char *device, char *errbuf)",
          "fn_dec_pos": [
            [
              2086,
              0
            ],
            [
              2086,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create",
            "parameters": {
              "device": "char",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_alloc_pcap_t(char *ebuf, size_t size)",
          "fn_dec_pos": [
            [
              2245,
              0
            ],
            [
              2245,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_alloc_pcap_t",
            "parameters": {
              "ebuf": "char",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_create_common(char *ebuf, size_t size)",
          "fn_dec_pos": [
            [
              2303,
              0
            ],
            [
              2303,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_common",
            "parameters": {
              "ebuf": "char",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_open_live(const char *device, int snaplen, int promisc, int to_ms, char *errbuf)",
          "fn_dec_pos": [
            [
              2581,
              0
            ],
            [
              2581,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_live",
            "parameters": {
              "device": "char",
              "snaplen": "int",
              "promisc": "int",
              "to_ms": "int",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_open_offline_common(char *ebuf, size_t size)",
          "fn_dec_pos": [
            [
              2677,
              0
            ],
            [
              2677,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_offline_common",
            "parameters": {
              "ebuf": "char",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_datalink_val_to_name(int dlt)",
          "fn_dec_pos": [
            [
              3120,
              0
            ],
            [
              3120,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_datalink_val_to_name",
            "parameters": {
              "dlt": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_datalink_val_to_description(int dlt)",
          "fn_dec_pos": [
            [
              3132,
              0
            ],
            [
              3132,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_datalink_val_to_description",
            "parameters": {
              "dlt": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_tstamp_type_val_to_name(int tstamp_type)",
          "fn_dec_pos": [
            [
              3171,
              0
            ],
            [
              3171,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_tstamp_type_val_to_name",
            "parameters": {
              "tstamp_type": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_tstamp_type_val_to_description(int tstamp_type)",
          "fn_dec_pos": [
            [
              3183,
              0
            ],
            [
              3183,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_tstamp_type_val_to_description",
            "parameters": {
              "tstamp_type": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_file(pcap_t *p)",
          "fn_dec_pos": [
            [
              3235,
              0
            ],
            [
              3235,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_file",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_get_required_select_timeout(pcap_t *p)",
          "fn_dec_pos": [
            [
              3261,
              0
            ],
            [
              3261,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_get_required_select_timeout",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_geterr(pcap_t *p)",
          "fn_dec_pos": [
            [
              3274,
              0
            ],
            [
              3274,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_geterr",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_statustostr(int errnum)",
          "fn_dec_pos": [
            [
              3379,
              0
            ],
            [
              3379,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_statustostr",
            "parameters": {
              "errnum": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_strerror(int errnum)",
          "fn_dec_pos": [
            [
              3438,
              0
            ],
            [
              3438,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_strerror",
            "parameters": {
              "errnum": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_stats_ex(pcap_t *p, int *pcap_stat_size)",
          "fn_dec_pos": [
            [
              3494,
              0
            ],
            [
              3494,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_ex",
            "parameters": {
              "p": "pcap_t",
              "pcap_stat_size": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_sendqueue_alloc(u_int memsize)",
          "fn_dec_pos": [
            [
              3536,
              0
            ],
            [
              3536,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_sendqueue_alloc",
            "parameters": {
              "memsize": "u_int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_stats_ex_dead(pcap_t *p, int *pcap_stat_size _U_)",
          "fn_dec_pos": [
            [
              3897,
              0
            ],
            [
              3897,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_ex_dead",
            "parameters": {
              "p": "pcap_t",
              "pcap_stat_size": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_open_dead_with_tstamp_precision(int linktype, int snaplen, u_int precision)",
          "fn_dec_pos": [
            [
              4000,
              0
            ],
            [
              4000,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_dead_with_tstamp_precision",
            "parameters": {
              "linktype": "int",
              "snaplen": "int",
              "precision": "u_int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_open_dead(int linktype, int snaplen)",
          "fn_dec_pos": [
            [
              4062,
              0
            ],
            [
              4062,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_dead",
            "parameters": {
              "linktype": "int",
              "snaplen": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_set_parser_debug(int value)",
          "fn_dec_pos": [
            [
              4081,
              14
            ],
            [
              4081,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_parser_debug",
            "parameters": {
              "value": "int"
            },
            "return_type": "PCAP_API"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_if_list {\n\tpcap_if_t *beginning;\n}",
          {
            "*beginning": "pcap_if_t"
          },
          "pcap_if_list",
          [
            501,
            0
          ],
          [
            503,
            1
          ]
        ],
        [
          "struct capture_source_type {\n\tint (*findalldevs_op)(pcap_if_list_t *, char *);\n\tpcap_t *(*create_op)(const char *, char *, int *);\n}",
          {
            "(*findalldevs_op)(pcap_if_list_t *, char *)": "int",
            "*(*create_op)(const char *, char *, int *)": "pcap_t"
          },
          "capture_source_type",
          [
            505,
            7
          ],
          [
            508,
            1
          ]
        ],
        [
          "struct dlt_choice {\n\tconst char *name;\n\tconst char *description;\n\tint\tdlt;\n}",
          {
            "char": "const",
            "dlt": "int"
          },
          "dlt_choice",
          [
            2951,
            0
          ],
          [
            2955,
            1
          ]
        ],
        [
          "struct tstamp_type_choice {\n\tconst char *name;\n\tconst char *description;\n\tint\ttype;\n}",
          {
            "char": "const",
            "type": "int"
          },
          "tstamp_type_choice",
          [
            3143,
            0
          ],
          [
            3147,
            1
          ]
        ],
        [
          "struct mbuf",
          {},
          "",
          [
            49,
            0
          ],
          [
            49,
            11
          ]
        ],
        [
          "struct rtentry",
          {},
          "",
          [
            50,
            0
          ],
          [
            50,
            14
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            220,
            45
          ],
          [
            220,
            63
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            252,
            41
          ],
          [
            252,
            57
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            260,
            0
          ],
          [
            260,
            16
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            426,
            33
          ],
          [
            426,
            51
          ]
        ],
        [
          "struct oneshot_userdata",
          {},
          "",
          [
            428,
            1
          ],
          [
            428,
            24
          ]
        ],
        [
          "struct oneshot_userdata",
          {},
          "",
          [
            428,
            32
          ],
          [
            428,
            55
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            435,
            21
          ],
          [
            435,
            39
          ]
        ],
        [
          "struct oneshot_userdata",
          {},
          "",
          [
            437,
            1
          ],
          [
            437,
            24
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            449,
            24
          ],
          [
            449,
            42
          ]
        ],
        [
          "struct oneshot_userdata",
          {},
          "",
          [
            452,
            1
          ],
          [
            452,
            24
          ]
        ],
        [
          "struct pcap_if_list {\n\tpcap_if_t *beginning;\n}",
          {
            "*beginning": "pcap_if_t"
          },
          "pcap_if_list",
          [
            501,
            0
          ],
          [
            503,
            1
          ]
        ],
        [
          "struct capture_source_type {\n\tint (*findalldevs_op)(pcap_if_list_t *, char *);\n\tpcap_t *(*create_op)(const char *, char *, int *);\n}",
          {
            "(*findalldevs_op)(pcap_if_list_t *, char *)": "int",
            "*(*create_op)(const char *, char *, int *)": "pcap_t"
          },
          "capture_source_type",
          [
            505,
            7
          ],
          [
            508,
            1
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            600,
            7
          ],
          [
            600,
            22
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            601,
            13
          ],
          [
            601,
            28
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            603,
            1
          ],
          [
            603,
            16
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            742,
            1
          ],
          [
            742,
            13
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            924,
            4
          ],
          [
            924,
            19
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            925,
            4
          ],
          [
            925,
            19
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            926,
            4
          ],
          [
            926,
            19
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            927,
            4
          ],
          [
            927,
            19
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            969,
            4
          ],
          [
            969,
            19
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            970,
            4
          ],
          [
            970,
            19
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            971,
            4
          ],
          [
            971,
            19
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            972,
            4
          ],
          [
            972,
            19
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            989,
            19
          ],
          [
            989,
            34
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1000,
            22
          ],
          [
            1000,
            37
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1013,
            24
          ],
          [
            1013,
            39
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1028,
            22
          ],
          [
            1028,
            37
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            1409,
            10
          ],
          [
            1409,
            28
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            1410,
            1
          ],
          [
            1410,
            13
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            1468,
            9
          ],
          [
            1468,
            27
          ]
        ],
        [
          "struct dlt_choice {\n\tconst char *name;\n\tconst char *description;\n\tint\tdlt;\n}",
          {
            "char": "const",
            "dlt": "int"
          },
          "dlt_choice",
          [
            2951,
            0
          ],
          [
            2955,
            1
          ]
        ],
        [
          "struct dlt_choice",
          {},
          "",
          [
            2960,
            7
          ],
          [
            2960,
            24
          ]
        ],
        [
          "struct tstamp_type_choice {\n\tconst char *name;\n\tconst char *description;\n\tint\ttype;\n}",
          {
            "char": "const",
            "type": "int"
          },
          "tstamp_type_choice",
          [
            3143,
            0
          ],
          [
            3147,
            1
          ]
        ],
        [
          "struct tstamp_type_choice",
          {},
          "",
          [
            3149,
            7
          ],
          [
            3149,
            32
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            3260,
            0
          ],
          [
            3260,
            14
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            3464,
            26
          ],
          [
            3464,
            44
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            3487,
            22
          ],
          [
            3487,
            38
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            3493,
            0
          ],
          [
            3493,
            16
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            3567,
            51
          ],
          [
            3567,
            69
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            3569,
            25
          ],
          [
            3569,
            43
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            3574,
            55
          ],
          [
            3574,
            73
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            3575,
            22
          ],
          [
            3575,
            40
          ]
        ],
        [
          "struct pcap",
          {},
          "",
          [
            3639,
            7
          ],
          [
            3639,
            18
          ]
        ],
        [
          "struct pcap",
          {},
          "",
          [
            3650,
            1
          ],
          [
            3650,
            12
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            3811,
            26
          ],
          [
            3811,
            44
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            3811,
            56
          ],
          [
            3811,
            74
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            3814,
            7
          ],
          [
            3814,
            22
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            3848,
            31
          ],
          [
            3848,
            49
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            3888,
            27
          ],
          [
            3888,
            43
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            3896,
            0
          ],
          [
            3896,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <pcap-types.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <sys/param.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <sys/file.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <sys/ioctl.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <sys/sockio.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <net/if.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            62,
            0
          ],
          [
            63,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            67,
            0
          ],
          [
            68,
            0
          ]
        ],
        [
          "#include \"pcap-dos.h\"\n",
          [
            71,
            0
          ],
          [
            72,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            74,
            0
          ],
          [
            75,
            0
          ]
        ],
        [
          "#include \"optimize.h\"\n",
          [
            76,
            0
          ],
          [
            77,
            0
          ]
        ],
        [
          "#include \"pcap-dag.h\"\n",
          [
            79,
            0
          ],
          [
            80,
            0
          ]
        ],
        [
          "#include \"pcap-septel.h\"\n",
          [
            83,
            0
          ],
          [
            84,
            0
          ]
        ],
        [
          "#include \"pcap-snf.h\"\n",
          [
            87,
            0
          ],
          [
            88,
            0
          ]
        ],
        [
          "#include \"pcap-tc.h\"\n",
          [
            91,
            0
          ],
          [
            92,
            0
          ]
        ],
        [
          "#include \"pcap-usb-linux.h\"\n",
          [
            95,
            0
          ],
          [
            96,
            0
          ]
        ],
        [
          "#include \"pcap-bt-linux.h\"\n",
          [
            99,
            0
          ],
          [
            100,
            0
          ]
        ],
        [
          "#include \"pcap-bt-monitor-linux.h\"\n",
          [
            103,
            0
          ],
          [
            104,
            0
          ]
        ],
        [
          "#include \"pcap-netfilter-linux.h\"\n",
          [
            107,
            0
          ],
          [
            108,
            0
          ]
        ],
        [
          "#include \"pcap-netmap.h\"\n",
          [
            111,
            0
          ],
          [
            112,
            0
          ]
        ],
        [
          "#include \"pcap-dbus.h\"\n",
          [
            115,
            0
          ],
          [
            116,
            0
          ]
        ],
        [
          "#include \"pcap-rdmasniff.h\"\n",
          [
            119,
            0
          ],
          [
            120,
            0
          ]
        ],
        [
          "#include \"pcap-dpdk.h\"\n",
          [
            123,
            0
          ],
          [
            124,
            0
          ]
        ],
        [
          "#include \"pcap-rpcap.h\"\n",
          [
            1503,
            0
          ],
          [
            1504,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/rpcap-protocol.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nrpcap_senderror(SOCKET sock, SSL *ssl, uint8 ver, unsigned short errcode, const char *error, char *errbuf)\n{\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t/* temporary buffer in which data to be sent is buffered */\n\tint sendbufidx = 0;\t\t\t/* index which keeps the number of bytes currently buffered */\n\tuint16 length;\n\n\tlength = (uint16)strlen(error);\n\n\tif (length > PCAP_ERRBUF_SIZE)\n\t\tlength = PCAP_ERRBUF_SIZE;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver, RPCAP_MSG_ERROR, errcode, length);\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t\tRPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\tif (sock_bufferize(error, length, sendbuf, &sendbufidx,\n\t\tRPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errbuf, PCAP_ERRBUF_SIZE))\n\t\treturn -1;\n\n\tif (sock_send(sock, ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              107,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_senderror",
            "parameters": {
              "sock": "SOCKET",
              "ssl": "SSL",
              "ver": "uint8",
              "errcode": "unsigned short",
              "error": "char",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\nrpcap_createhdr(struct rpcap_header *header, uint8 ver, uint8 type, uint16 value, uint32 length)\n{\n\tmemset(header, 0, sizeof(struct rpcap_header));\n\n\theader->ver = ver;\n\theader->type = type;\n\theader->value = htons(value);\n\theader->plen = htonl(length);\n}",
          "fn_code_pos": [
            [
              135,
              0
            ],
            [
              144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_createhdr",
            "parameters": {
              "header": "struct rpcap_header",
              "ver": "uint8",
              "type": "uint8",
              "value": "uint16",
              "length": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "const char *\nrpcap_msg_type_string(uint8 type)\n{\n\tif (type & RPCAP_MSG_IS_REPLY) {\n\t\ttype &= ~RPCAP_MSG_IS_REPLY;\n\t\tif (type >= NUM_REPLY_TYPES)\n\t\t\treturn NULL;\n\t\treturn replies[type];\n\t} else {\n\t\tif (type >= NUM_REQ_TYPES)\n\t\t\treturn NULL;\n\t\treturn requests[type];\n\t}\n}",
          "fn_code_pos": [
            [
              183,
              0
            ],
            [
              196,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_msg_type_string",
            "parameters": {
              "type": "uint8"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "rpcap_msg_type_string(uint8 type)",
          "fn_dec_pos": [
            [
              184,
              0
            ],
            [
              184,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_msg_type_string",
            "parameters": {
              "type": "uint8"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct rpcap_header",
          {},
          "",
          [
            93,
            18
          ],
          [
            93,
            37
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            95,
            33
          ],
          [
            95,
            52
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            136,
            16
          ],
          [
            136,
            35
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            138,
            26
          ],
          [
            138,
            45
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <string.h>\t\t/* for strlen(), ... */\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <stdlib.h>\t\t/* for malloc(), free(), ... */\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <stdarg.h>\t\t/* for functions with variable number of arguments */\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <errno.h>\t\t/* for the errno variable */\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"sockutils.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"rpcap-protocol.h\"\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <pcap/pcap.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-snoop.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\npcap_read_snoop(pcap_t *p, int cnt, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_snoop *psn = p->priv;\n\tint cc;\n\tregister struct snoopheader *sh;\n\tregister u_int datalen;\n\tregister u_int caplen;\n\tregister u_char *cp;\n\nagain:\n\t/*\n\t * Has \"pcap_breakloop()\" been called?\n\t */\n\tif (p->break_loop) {\n\t\t/*\n\t\t * Yes - clear the flag that indicates that it\n\t\t * has, and return -2 to indicate that we were\n\t\t * told to break out of the loop.\n\t\t */\n\t\tp->break_loop = 0;\n\t\treturn (-2);\n\t}\n\tcc = read(p->fd, (char *)p->buffer, p->bufsize);\n\tif (cc < 0) {\n\t\t/* Don't choke when we get ptraced */\n\t\tswitch (errno) {\n\n\t\tcase EINTR:\n\t\t\tgoto again;\n\n\t\tcase EWOULDBLOCK:\n\t\t\treturn (0);\t\t\t/* XXX */\n\t\t}\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t    errno, \"read\");\n\t\treturn (-1);\n\t}\n\tsh = (struct snoopheader *)p->buffer;\n\tdatalen = sh->snoop_packetlen;\n\n\t/*\n\t * XXX - Sigh, snoop_packetlen is a 16 bit quantity.  If we\n\t * got a short length, but read a full sized snoop pakcet,\n\t * assume we overflowed and add back the 64K...\n\t */\n\tif (cc == (p->snapshot + sizeof(struct snoopheader)) &&\n\t    (datalen < p->snapshot))\n\t\tdatalen += (64 * 1024);\n\n\tcaplen = (datalen < p->snapshot) ? datalen : p->snapshot;\n\tcp = (u_char *)(sh + 1) + p->offset;\t\t/* XXX */\n\n\t/*\n\t * XXX unfortunately snoop loopback isn't exactly like\n\t * BSD's.  The address family is encoded in the first 2\n\t * bytes rather than the first 4 bytes!  Luckily the last\n\t * two snoop loopback bytes are zeroed.\n\t */\n\tif (p->linktype == DLT_NULL && *((short *)(cp + 2)) == 0) {\n\t\tu_int *uip = (u_int *)cp;\n\t\t*uip >>= 16;\n\t}\n\n\tif (p->fcode.bf_insns == NULL ||\n\t    pcap_filter(p->fcode.bf_insns, cp, datalen, caplen)) {\n\t\tstruct pcap_pkthdr h;\n\t\t++psn->stat.ps_recv;\n\t\th.ts.tv_sec = sh->snoop_timestamp.tv_sec;\n\t\th.ts.tv_usec = sh->snoop_timestamp.tv_usec;\n\t\th.len = datalen;\n\t\th.caplen = caplen;\n\t\t(*callback)(user, &h, cp);\n\t\treturn (1);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              139,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_snoop",
            "parameters": {
              "p": "pcap_t",
              "cnt": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_inject_snoop(pcap_t *p, const void *buf, int size)\n{\n\tint ret;\n\n\t/*\n\t * XXX - libnet overwrites the source address with what I\n\t * presume is the interface's address; is that required?\n\t */\n\tret = write(p->fd, buf, size);\n\tif (ret == -1) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"send\");\n\t\treturn (-1);\n\t}\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              141,
              0
            ],
            [
              157,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject_snoop",
            "parameters": {
              "p": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_stats_snoop(pcap_t *p, struct pcap_stat *ps)\n{\n\tstruct pcap_snoop *psn = p->priv;\n\tregister struct rawstats *rs;\n\tstruct rawstats rawstats;\n\n\trs = &rawstats;\n\tmemset(rs, 0, sizeof(*rs));\n\tif (ioctl(p->fd, SIOCRAWSTATS, (char *)rs) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),\n\t\t    errno, \"SIOCRAWSTATS\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * \"ifdrops\" are those dropped by the network interface\n\t * due to resource shortages or hardware errors.\n\t *\n\t * \"sbdrops\" are those dropped due to socket buffer limits.\n\t *\n\t * As filter is done in userland, \"sbdrops\" counts packets\n\t * regardless of whether they would've passed the filter.\n\t *\n\t * XXX - does this count *all* Snoop or Drain sockets,\n\t * rather than just this socket?  If not, why does it have\n\t * both Snoop and Drain statistics?\n\t */\n\tpsn->stat.ps_drop =\n\t    rs->rs_snoop.ss_ifdrops + rs->rs_snoop.ss_sbdrops +\n\t    rs->rs_drain.ds_ifdrops + rs->rs_drain.ds_sbdrops;\n\n\t/*\n\t * \"ps_recv\" counts only packets that passed the filter.\n\t * As filtering is done in userland, this does not include\n\t * packets dropped because we ran out of buffer space.\n\t */\n\t*ps = psn->stat;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              159,
              0
            ],
            [
              198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_snoop",
            "parameters": {
              "p": "pcap_t",
              "ps": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_activate_snoop(pcap_t *p)\n{\n\tint fd;\n\tstruct sockaddr_raw sr;\n\tstruct snoopfilter sf;\n\tu_int v;\n\tint ll_hdrlen;\n\tint snooplen;\n\tstruct ifreq ifr;\n\n\tfd = socket(PF_RAW, SOCK_RAW, RAWPROTO_SNOOP);\n\tif (fd < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"snoop socket\");\n\t\tgoto bad;\n\t}\n\tp->fd = fd;\n\tmemset(&sr, 0, sizeof(sr));\n\tsr.sr_family = AF_RAW;\n\t(void)strncpy(sr.sr_ifname, p->opt.device, sizeof(sr.sr_ifname));\n\tif (bind(fd, (struct sockaddr *)&sr, sizeof(sr))) {\n\t\t/*\n\t\t * XXX - there's probably a particular bind error that\n\t\t * means \"there's no such device\" and a particular bind\n\t\t * error that means \"that device doesn't support snoop\";\n\t\t * they might be the same error, if they both end up\n\t\t * meaning \"snoop doesn't know about that device\".\n\t\t */\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"snoop bind\");\n\t\tgoto bad;\n\t}\n\tmemset(&sf, 0, sizeof(sf));\n\tif (ioctl(fd, SIOCADDSNOOP, &sf) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCADDSNOOP\");\n\t\tgoto bad;\n\t}\n\tif (p->opt.buffer_size != 0)\n\t\tv = p->opt.buffer_size;\n\telse\n\t\tv = 64 * 1024;\t/* default to 64K buffer size */\n\t(void)setsockopt(fd, SOL_SOCKET, SO_RCVBUF, (char *)&v, sizeof(v));\n\t/*\n\t * XXX hack - map device name to link layer type\n\t */\n\tif (strncmp(\"et\", p->opt.device, 2) == 0 ||\t/* Challenge 10 Mbit */\n\t    strncmp(\"ec\", p->opt.device, 2) == 0 ||\t/* Indigo/Indy 10 Mbit,\n\t\t\t\t\t\t\t   O2 10/100 */\n\t    strncmp(\"ef\", p->opt.device, 2) == 0 ||\t/* O200/2000 10/100 Mbit */\n\t    strncmp(\"eg\", p->opt.device, 2) == 0 ||\t/* Octane/O2xxx/O3xxx Gigabit */\n\t    strncmp(\"gfe\", p->opt.device, 3) == 0 ||\t/* GIO 100 Mbit */\n\t    strncmp(\"fxp\", p->opt.device, 3) == 0 ||\t/* Challenge VME Enet */\n\t    strncmp(\"ep\", p->opt.device, 2) == 0 ||\t/* Challenge 8x10 Mbit EPLEX */\n\t    strncmp(\"vfe\", p->opt.device, 3) == 0 ||\t/* Challenge VME 100Mbit */\n\t    strncmp(\"fa\", p->opt.device, 2) == 0 ||\n\t    strncmp(\"qaa\", p->opt.device, 3) == 0 ||\n\t    strncmp(\"cip\", p->opt.device, 3) == 0 ||\n\t    strncmp(\"el\", p->opt.device, 2) == 0) {\n\t\tp->linktype = DLT_EN10MB;\n\t\tp->offset = RAW_HDRPAD(sizeof(struct ether_header));\n\t\tll_hdrlen = sizeof(struct ether_header);\n\t\t/*\n\t\t * This is (presumably) a real Ethernet capture; give it a\n\t\t * link-layer-type list with DLT_EN10MB and DLT_DOCSIS, so\n\t\t * that an application can let you choose it, in case you're\n\t\t * capturing DOCSIS traffic that a Cisco Cable Modem\n\t\t * Termination System is putting out onto an Ethernet (it\n\t\t * doesn't put an Ethernet header onto the wire, it puts raw\n\t\t * DOCSIS frames out on the wire inside the low-level\n\t\t * Ethernet framing).\n\t\t *\n\t\t * XXX - are there any sorts of \"fake Ethernet\" that have\n\t\t * Ethernet link-layer headers but that *shouldn't offer\n\t\t * DLT_DOCSIS as a Cisco CMTS won't put traffic onto it\n\t\t * or get traffic bridged onto it?  \"el\" is for ATM LANE\n\t\t * Ethernet devices, so that might be the case for them;\n\t\t * the same applies for \"qaa\" classical IP devices.  If\n\t\t * \"fa\" devices are for FORE SPANS, that'd apply to them\n\t\t * as well; what are \"cip\" devices - some other ATM\n\t\t * Classical IP devices?\n\t\t */\n\t\tp->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);\n\t\t/*\n\t\t * If that fails, just leave the list empty.\n\t\t */\n\t\tif (p->dlt_list != NULL) {\n\t\t\tp->dlt_list[0] = DLT_EN10MB;\n\t\t\tp->dlt_list[1] = DLT_DOCSIS;\n\t\t\tp->dlt_count = 2;\n\t\t}\n\t} else if (strncmp(\"ipg\", p->opt.device, 3) == 0 ||\n\t\t   strncmp(\"rns\", p->opt.device, 3) == 0 ||\t/* O2/200/2000 FDDI */\n\t\t   strncmp(\"xpi\", p->opt.device, 3) == 0) {\n\t\tp->linktype = DLT_FDDI;\n\t\tp->offset = 3;\t\t\t\t/* XXX yeah? */\n\t\tll_hdrlen = 13;\n\t} else if (strncmp(\"ppp\", p->opt.device, 3) == 0) {\n\t\tp->linktype = DLT_RAW;\n\t\tll_hdrlen = 0;\t/* DLT_RAW meaning \"no PPP header, just the IP packet\"? */\n\t} else if (strncmp(\"qfa\", p->opt.device, 3) == 0) {\n\t\tp->linktype = DLT_IP_OVER_FC;\n\t\tll_hdrlen = 24;\n\t} else if (strncmp(\"pl\", p->opt.device, 2) == 0) {\n\t\tp->linktype = DLT_RAW;\n\t\tll_hdrlen = 0;\t/* Cray UNICOS/mp pseudo link */\n\t} else if (strncmp(\"lo\", p->opt.device, 2) == 0) {\n\t\tp->linktype = DLT_NULL;\n\t\tll_hdrlen = 4;\n\t} else {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"snoop: unknown physical layer type\");\n\t\tgoto bad;\n\t}\n\n\tif (p->opt.rfmon) {\n\t\t/*\n\t\t * No monitor mode on Irix (no Wi-Fi devices on\n\t\t * hardware supported by Irix).\n\t\t */\n\t\treturn (PCAP_ERROR_RFMON_NOTSUP);\n\t}\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)\n\t\tp->snapshot = MAXIMUM_SNAPLEN;\n\n#ifdef SIOCGIFMTU\n\t/*\n\t * XXX - IRIX appears to give you an error if you try to set the\n\t * capture length to be greater than the MTU, so let's try to get\n\t * the MTU first and, if that succeeds, trim the snap length\n\t * to be no greater than the MTU.\n\t */\n\t(void)strncpy(ifr.ifr_name, p->opt.device, sizeof(ifr.ifr_name));\n\tif (ioctl(fd, SIOCGIFMTU, (char *)&ifr) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCGIFMTU\");\n\t\tgoto bad;\n\t}\n\t/*\n\t * OK, we got it.\n\t *\n\t * XXX - some versions of IRIX 6.5 define \"ifr_mtu\" and have an\n\t * \"ifru_metric\" member of the \"ifr_ifru\" union in an \"ifreq\"\n\t * structure, others don't.\n\t *\n\t * I've no idea what's going on, so, if \"ifr_mtu\" isn't defined,\n\t * we define it as \"ifr_metric\", as using that field appears to\n\t * work on the versions that lack \"ifr_mtu\" (and, on those that\n\t * don't lack it, \"ifru_metric\" and \"ifru_mtu\" are both \"int\"\n\t * members of the \"ifr_ifru\" union, which suggests that they\n\t * may be interchangeable in this case).\n\t */\n#ifndef ifr_mtu\n#define ifr_mtu\tifr_metric\n#endif\n\tif (p->snapshot > ifr.ifr_mtu + ll_hdrlen)\n\t\tp->snapshot = ifr.ifr_mtu + ll_hdrlen;\n#endif\n\n\t/*\n\t * The argument to SIOCSNOOPLEN is the number of link-layer\n\t * payload bytes to capture - it doesn't count link-layer\n\t * header bytes.\n\t */\n\tsnooplen = p->snapshot - ll_hdrlen;\n\tif (snooplen < 0)\n\t\tsnooplen = 0;\n\tif (ioctl(fd, SIOCSNOOPLEN, &snooplen) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCSNOOPLEN\");\n\t\tgoto bad;\n\t}\n\tv = 1;\n\tif (ioctl(fd, SIOCSNOOPING, &v) < 0) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"SIOCSNOOPING\");\n\t\tgoto bad;\n\t}\n\n\tp->bufsize = 4096;\t\t\t\t/* XXX */\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tgoto bad;\n\t}\n\n\t/*\n\t * \"p->fd\" is a socket, so \"select()\" should work on it.\n\t */\n\tp->selectable_fd = p->fd;\n\n\tp->read_op = pcap_read_snoop;\n\tp->inject_op = pcap_inject_snoop;\n\tp->setfilter_op = install_bpf_program;\t/* no kernel filtering */\n\tp->setdirection_op = NULL;\t/* Not implemented. */\n\tp->set_datalink_op = NULL;\t/* can't change data link type */\n\tp->getnonblock_op = pcap_getnonblock_fd;\n\tp->setnonblock_op = pcap_setnonblock_fd;\n\tp->stats_op = pcap_stats_snoop;\n\n\treturn (0);\n bad:\n\tpcap_cleanup_live_common(p);\n\treturn (PCAP_ERROR);\n}",
          "fn_code_pos": [
            [
              201,
              0
            ],
            [
              416,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_activate_snoop",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_create_interface(const char *device _U_, char *ebuf)\n{\n\tpcap_t *p;\n\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_snoop));\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = pcap_activate_snoop;\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              418,
              0
            ],
            [
              429,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static int\ncan_be_bound(const char *name _U_)\n{\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              435,
              0
            ],
            [
              439,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "can_be_bound",
            "parameters": {
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nget_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)\n{\n\t/*\n\t * Nothing we can do.\n\t * XXX - is there a way to find out whether an adapter has\n\t * something plugged into it?\n\t */\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              441,
              0
            ],
            [
              450,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_if_flags",
            "parameters": {
              "name": "char",
              "flags": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)\n{\n\treturn (pcap_findalldevs_interfaces(devlistp, errbuf, can_be_bound,\n\t    get_if_flags));\n}",
          "fn_code_pos": [
            [
              452,
              0
            ],
            [
              457,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_platform_finddevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char *\npcap_lib_version(void)\n{\n\treturn (PCAP_VERSION_STRING);\n}",
          "fn_code_pos": [
            [
              462,
              0
            ],
            [
              466,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "pcap_create_interface(const char *device _U_, char *ebuf)",
          "fn_dec_pos": [
            [
              419,
              0
            ],
            [
              419,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "ebuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              463,
              0
            ],
            [
              463,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_snoop {\n\tstruct pcap_stat stat;\n}",
          {
            "stat": "struct pcap_stat"
          },
          "pcap_snoop",
          [
            59,
            0
          ],
          [
            61,
            1
          ]
        ],
        [
          "struct pcap_snoop {\n\tstruct pcap_stat stat;\n}",
          {
            "stat": "struct pcap_stat"
          },
          "pcap_snoop",
          [
            59,
            0
          ],
          [
            61,
            1
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            60,
            1
          ],
          [
            60,
            17
          ]
        ],
        [
          "struct pcap_snoop",
          {},
          "",
          [
            66,
            1
          ],
          [
            66,
            18
          ]
        ],
        [
          "struct snoopheader",
          {},
          "",
          [
            68,
            10
          ],
          [
            68,
            28
          ]
        ],
        [
          "struct snoopheader",
          {},
          "",
          [
            101,
            7
          ],
          [
            101,
            25
          ]
        ],
        [
          "struct snoopheader",
          {},
          "",
          [
            109,
            33
          ],
          [
            109,
            51
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            129,
            2
          ],
          [
            129,
            20
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            160,
            28
          ],
          [
            160,
            44
          ]
        ],
        [
          "struct pcap_snoop",
          {},
          "",
          [
            162,
            1
          ],
          [
            162,
            18
          ]
        ],
        [
          "struct rawstats",
          {},
          "",
          [
            163,
            10
          ],
          [
            163,
            25
          ]
        ],
        [
          "struct rawstats",
          {},
          "",
          [
            164,
            1
          ],
          [
            164,
            16
          ]
        ],
        [
          "struct sockaddr_raw",
          {},
          "",
          [
            205,
            1
          ],
          [
            205,
            20
          ]
        ],
        [
          "struct snoopfilter",
          {},
          "",
          [
            206,
            1
          ],
          [
            206,
            19
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            210,
            1
          ],
          [
            210,
            13
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            222,
            15
          ],
          [
            222,
            30
          ]
        ],
        [
          "struct ether_header",
          {},
          "",
          [
            262,
            32
          ],
          [
            262,
            51
          ]
        ],
        [
          "struct ether_header",
          {},
          "",
          [
            263,
            21
          ],
          [
            263,
            40
          ]
        ],
        [
          "struct pcap_snoop",
          {},
          "",
          [
            423,
            38
          ],
          [
            423,
            55
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <sys/param.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <sys/file.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <sys/ioctl.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <net/raw.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <net/if.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <netinet/in_systm.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <netinet/ip.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <netinet/if_ether.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <netinet/ip_var.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <netinet/udp.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <netinet/udp_var.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <netinet/tcp.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <netinet/tcpip.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/sf-pcapng.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nread_bytes(FILE *fp, void *buf, size_t bytes_to_read, int fail_on_eof,\n    char *errbuf)\n{\n\tsize_t amt_read;\n\n\tamt_read = fread(buf, 1, bytes_to_read, fp);\n\tif (amt_read != bytes_to_read) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t} else {\n\t\t\tif (amt_read == 0 && !fail_on_eof)\n\t\t\t\treturn (0);\t/* EOF */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"truncated dump file; tried to read %\" PRIsize \" bytes, only got %\" PRIsize,\n\t\t\t    bytes_to_read, amt_read);\n\t\t}\n\t\treturn (-1);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              253,
              0
            ],
            [
              274,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_bytes",
            "parameters": {
              "fp": "FILE",
              "buf": "void",
              "bytes_to_read": "size_t",
              "fail_on_eof": "int",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nread_block(FILE *fp, pcap_t *p, struct block_cursor *cursor, char *errbuf)\n{\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_header bhdr;\n\tstruct block_trailer *btrlr;\n\tu_char *bdata;\n\tsize_t data_remaining;\n\n\tps = p->priv;\n\n\tstatus = read_bytes(fp, &bhdr, sizeof(bhdr), 0, errbuf);\n\tif (status <= 0)\n\t\treturn (status);\t/* error or EOF */\n\n\tif (p->swapped) {\n\t\tbhdr.block_type = SWAPLONG(bhdr.block_type);\n\t\tbhdr.total_length = SWAPLONG(bhdr.total_length);\n\t}\n\n\t/*\n\t * Is this block \"too small\" - i.e., is it shorter than a block\n\t * header plus a block trailer?\n\t */\n\tif (bhdr.total_length < sizeof(struct block_header) +\n\t    sizeof(struct block_trailer)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block in pcapng dump file has a length of %u < %\" PRIsize,\n\t\t    bhdr.total_length,\n\t\t    sizeof(struct block_header) + sizeof(struct block_trailer));\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Is the block total length a multiple of 4?\n\t */\n\tif ((bhdr.total_length % 4) != 0) {\n\t\t/*\n\t\t * No.  Report that as an error.\n\t\t */\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block in pcapng dump file has a length of %u that is not a multiple of 4\" PRIsize,\n\t\t    bhdr.total_length);\n\t\treturn (-1);\n\t}",
          "fn_code_pos": [
            [
              276,
              0
            ],
            [
              321,
              2
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_block",
            "parameters": {
              "fp": "FILE",
              "p": "pcap_t",
              "cursor": "struct block_cursor",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void *\nget_from_block_data(struct block_cursor *cursor, size_t chunk_size,\n    char *errbuf)\n{\n\tvoid *data;\n\n\t/*\n\t * Make sure we have the specified amount of data remaining in\n\t * the block data.\n\t */\n\tif (cursor->data_remaining < chunk_size) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block of type %u in pcapng dump file is too short\",\n\t\t    cursor->block_type);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Return the current pointer, and skip past the chunk.\n\t */\n\tdata = cursor->data;\n\tcursor->data += chunk_size;\n\tcursor->data_remaining -= chunk_size;\n\treturn (data);\n}",
          "fn_code_pos": [
            [
              385,
              0
            ],
            [
              409,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_from_block_data",
            "parameters": {
              "cursor": "struct block_cursor",
              "chunk_size": "size_t",
              "errbuf": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static struct option_header *\nget_opthdr_from_block_data(pcap_t *p, struct block_cursor *cursor, char *errbuf)\n{\n\tstruct option_header *opthdr;\n\n\topthdr = get_from_block_data(cursor, sizeof(*opthdr), errbuf);\n\tif (opthdr == NULL) {\n\t\t/*\n\t\t * Option header is cut short.\n\t\t */\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Byte-swap it if necessary.\n\t */\n\tif (p->swapped) {\n\t\topthdr->option_code = SWAPSHORT(opthdr->option_code);\n\t\topthdr->option_length = SWAPSHORT(opthdr->option_length);\n\t}\n\n\treturn (opthdr);\n}",
          "fn_code_pos": [
            [
              411,
              0
            ],
            [
              433,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_opthdr_from_block_data",
            "parameters": {
              "p": "pcap_t",
              "cursor": "struct block_cursor",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void *\nget_optvalue_from_block_data(struct block_cursor *cursor,\n    struct option_header *opthdr, char *errbuf)\n{\n\tsize_t padded_option_len;\n\tvoid *optvalue;\n\n\t/* Pad option length to 4-byte boundary */\n\tpadded_option_len = opthdr->option_length;\n\tpadded_option_len = ((padded_option_len + 3)/4)*4;\n\n\toptvalue = get_from_block_data(cursor, padded_option_len, errbuf);\n\tif (optvalue == NULL) {\n\t\t/*\n\t\t * Option value is cut short.\n\t\t */\n\t\treturn (NULL);\n\t}\n\n\treturn (optvalue);\n}",
          "fn_code_pos": [
            [
              435,
              0
            ],
            [
              455,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_optvalue_from_block_data",
            "parameters": {
              "cursor": "struct block_cursor",
              "opthdr": "struct option_header",
              "errbuf": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nprocess_idb_options(pcap_t *p, struct block_cursor *cursor, uint64_t *tsresol,\n    uint64_t *tsoffset, int *is_binary, char *errbuf)\n{\n\tstruct option_header *opthdr;\n\tvoid *optvalue;\n\tint saw_tsresol, saw_tsoffset;\n\tuint8_t tsresol_opt;\n\tu_int i;\n\n\tsaw_tsresol = 0;\n\tsaw_tsoffset = 0;\n\twhile (cursor->data_remaining != 0) {\n\t\t/*\n\t\t * Get the option header.\n\t\t */\n\t\topthdr = get_opthdr_from_block_data(p, cursor, errbuf);\n\t\tif (opthdr == NULL) {\n\t\t\t/*\n\t\t\t * Option header is cut short.\n\t\t\t */\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Get option value.\n\t\t */\n\t\toptvalue = get_optvalue_from_block_data(cursor, opthdr,\n\t\t    errbuf);\n\t\tif (optvalue == NULL) {\n\t\t\t/*\n\t\t\t * Option value is cut short.\n\t\t\t */\n\t\t\treturn (-1);\n\t\t}\n\n\t\tswitch (opthdr->option_code) {\n\n\t\tcase OPT_ENDOFOPT:\n\t\t\tif (opthdr->option_length != 0) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has opt_endofopt option with length %u != 0\",\n\t\t\t\t    opthdr->option_length);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tgoto done;\n\n\t\tcase IF_TSRESOL:\n\t\t\tif (opthdr->option_length != 1) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has if_tsresol option with length %u != 1\",\n\t\t\t\t    opthdr->option_length);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tif (saw_tsresol) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has more than one if_tsresol option\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tsaw_tsresol = 1;\n\t\t\tmemcpy(&tsresol_opt, optvalue, sizeof(tsresol_opt));\n\t\t\tif (tsresol_opt & 0x80) {\n\t\t\t\t/*\n\t\t\t\t * Resolution is negative power of 2.\n\t\t\t\t */\n\t\t\t\tuint8_t tsresol_shift = (tsresol_opt & 0x7F);\n\n\t\t\t\tif (tsresol_shift > 63) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Resolution is too high; 2^-{res}\n\t\t\t\t\t * won't fit in a 64-bit value.\n\t\t\t\t\t */\n\t\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"Interface Description Block if_tsresol option resolution 2^-%u is too high\",\n\t\t\t\t\t    tsresol_shift);\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t\t*is_binary = 1;\n\t\t\t\t*tsresol = ((uint64_t)1) << tsresol_shift;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Resolution is negative power of 10.\n\t\t\t\t */\n\t\t\t\tif (tsresol_opt > 19) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Resolution is too high; 2^-{res}\n\t\t\t\t\t * won't fit in a 64-bit value (the\n\t\t\t\t\t * largest power of 10 that fits\n\t\t\t\t\t * in a 64-bit value is 10^19, as\n\t\t\t\t\t * the largest 64-bit unsigned\n\t\t\t\t\t * value is ~1.8*10^19).\n\t\t\t\t\t */\n\t\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"Interface Description Block if_tsresol option resolution 10^-%u is too high\",\n\t\t\t\t\t    tsresol_opt);\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t\t*is_binary = 0;\n\t\t\t\t*tsresol = 1;\n\t\t\t\tfor (i = 0; i < tsresol_opt; i++)\n\t\t\t\t\t*tsresol *= 10;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IF_TSOFFSET:\n\t\t\tif (opthdr->option_length != 8) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has if_tsoffset option with length %u != 8\",\n\t\t\t\t    opthdr->option_length);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tif (saw_tsoffset) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has more than one if_tsoffset option\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tsaw_tsoffset = 1;\n\t\t\tmemcpy(tsoffset, optvalue, sizeof(*tsoffset));\n\t\t\tif (p->swapped)\n\t\t\t\t*tsoffset = SWAPLL(*tsoffset);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              457,
              0
            ],
            [
              586,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_idb_options",
            "parameters": {
              "p": "pcap_t",
              "cursor": "struct block_cursor",
              "tsresol": "uint64_t",
              "tsoffset": "uint64_t",
              "is_binary": "int",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nadd_interface(pcap_t *p, struct block_cursor *cursor, char *errbuf)\n{\n\tstruct pcap_ng_sf *ps;\n\tuint64_t tsresol;\n\tuint64_t tsoffset;\n\tint is_binary;\n\n\tps = p->priv;\n\n\t/*\n\t * Count this interface.\n\t */\n\tps->ifcount++;\n\n\t/*\n\t * Grow the array of per-interface information as necessary.\n\t */\n\tif (ps->ifcount > ps->ifaces_size) {\n\t\t/*\n\t\t * We need to grow the array.\n\t\t */\n\t\tbpf_u_int32 new_ifaces_size;\n\t\tstruct pcap_ng_if *new_ifaces;\n\n\t\tif (ps->ifaces_size == 0) {\n\t\t\t/*\n\t\t\t * It's currently empty.\n\t\t\t *\n\t\t\t * (The Clang static analyzer doesn't do enough,\n\t\t\t * err, umm, dataflow *analysis* to realize that\n\t\t\t * ps->ifaces_size == 0 if ps->ifaces == NULL,\n\t\t\t * and so complains about a possible zero argument\n\t\t\t * to realloc(), so we check for the former\n\t\t\t * condition to shut it up.\n\t\t\t *\n\t\t\t * However, it doesn't complain that one of the\n\t\t\t * multiplications below could overflow, which is\n\t\t\t * a real, albeit extremely unlikely, problem (you'd\n\t\t\t * need a pcapng file with tens of millions of\n\t\t\t * interfaces).)\n\t\t\t */\n\t\t\tnew_ifaces_size = 1;\n\t\t\tnew_ifaces = malloc(sizeof (struct pcap_ng_if));\n\t\t} else {\n\t\t\t/*\n\t\t\t * It's not currently empty; double its size.\n\t\t\t * (Perhaps overkill once we have a lot of interfaces.)\n\t\t\t *\n\t\t\t * Check for overflow if we double it.\n\t\t\t */\n\t\t\tif (ps->ifaces_size * 2 < ps->ifaces_size) {\n\t\t\t\t/*\n\t\t\t\t * The maximum number of interfaces before\n\t\t\t\t * ps->ifaces_size overflows is the largest\n\t\t\t\t * possible 32-bit power of 2, as we do\n\t\t\t\t * size doubling.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"more than %u interfaces in the file\",\n\t\t\t\t    0x80000000U);\n\t\t\t\treturn (0);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * ps->ifaces_size * 2 doesn't overflow, so it's\n\t\t\t * safe to multiply.\n\t\t\t */\n\t\t\tnew_ifaces_size = ps->ifaces_size * 2;\n\n\t\t\t/*\n\t\t\t * Now make sure that's not so big that it overflows\n\t\t\t * if we multiply by sizeof (struct pcap_ng_if).\n\t\t\t *\n\t\t\t * That can happen on 32-bit platforms, with a 32-bit\n\t\t\t * size_t; it shouldn't happen on 64-bit platforms,\n\t\t\t * with a 64-bit size_t, as new_ifaces_size is\n\t\t\t * 32 bits.\n\t\t\t */\n\t\t\tif (new_ifaces_size * sizeof (struct pcap_ng_if) < new_ifaces_size) {\n\t\t\t\t/*\n\t\t\t\t * As this fails only with 32-bit size_t,\n\t\t\t\t * the multiplication was 32x32->32, and\n\t\t\t\t * the largest 32-bit value that can safely\n\t\t\t\t * be multiplied by sizeof (struct pcap_ng_if)\n\t\t\t\t * without overflow is the largest 32-bit\n\t\t\t\t * (unsigned) value divided by\n\t\t\t\t * sizeof (struct pcap_ng_if).\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"more than %u interfaces in the file\",\n\t\t\t\t    0xFFFFFFFFU / ((u_int)sizeof (struct pcap_ng_if)));\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tnew_ifaces = realloc(ps->ifaces, new_ifaces_size * sizeof (struct pcap_ng_if));\n\t\t}\n\t\tif (new_ifaces == NULL) {\n\t\t\t/*\n\t\t\t * We ran out of memory.\n\t\t\t * Give up.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"out of memory for per-interface information (%u interfaces)\",\n\t\t\t    ps->ifcount);\n\t\t\treturn (0);\n\t\t}\n\t\tps->ifaces_size = new_ifaces_size;\n\t\tps->ifaces = new_ifaces;\n\t}\n\n\t/*\n\t * Set the default time stamp resolution and offset.\n\t */\n\ttsresol = 1000000;\t/* microsecond resolution */\n\tis_binary = 0;\t\t/* which is a power of 10 */\n\ttsoffset = 0;\t\t/* absolute timestamps */\n\n\t/*\n\t * Now look for various time stamp options, so we know\n\t * how to interpret the time stamps for this interface.\n\t */\n\tif (process_idb_options(p, cursor, &tsresol, &tsoffset, &is_binary,\n\t    errbuf) == -1)\n\t\treturn (0);\n\n\tps->ifaces[ps->ifcount - 1].tsresol = tsresol;\n\tps->ifaces[ps->ifcount - 1].tsoffset = tsoffset;\n\n\t/*\n\t * Determine whether we're scaling up or down or not\n\t * at all for this interface.\n\t */\n\tif (tsresol == ps->user_tsresol) {\n\t\t/*\n\t\t * The resolution is the resolution the user wants,\n\t\t * so we don't have to do scaling.\n\t\t */\n\t\tps->ifaces[ps->ifcount - 1].scale_type = PASS_THROUGH;\n\t} else if (tsresol > ps->user_tsresol) {\n\t\t/*\n\t\t * The resolution is greater than what the user wants,\n\t\t * so we have to scale the timestamps down.\n\t\t */\n\t\tif (is_binary)\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_DOWN_BIN;\n\t\telse {\n\t\t\t/*\n\t\t\t * Calculate the scale factor.\n\t\t\t */\n\t\t\tps->ifaces[ps->ifcount - 1].scale_factor = tsresol/ps->user_tsresol;\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_DOWN_DEC;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * The resolution is less than what the user wants,\n\t\t * so we have to scale the timestamps up.\n\t\t */\n\t\tif (is_binary)\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_UP_BIN;\n\t\telse {\n\t\t\t/*\n\t\t\t * Calculate the scale factor.\n\t\t\t */\n\t\t\tps->ifaces[ps->ifcount - 1].scale_factor = ps->user_tsresol/tsresol;\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_UP_DEC;\n\t\t}\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              588,
              0
            ],
            [
              756,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_interface",
            "parameters": {
              "p": "pcap_t",
              "cursor": "struct block_cursor",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_ng_check_header(bpf_u_int32 magic, FILE *fp, u_int precision, char *errbuf,\n    int *err)\n{\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tif (magic != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Section Header Block in pcapng dump file has a length of %u < %\" PRIsize,\n\t\t    total_length,\n\t\t    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer));\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Make sure it's not too big.\n\t */\n\tif (total_length > INITIAL_MAX_BLOCKSIZE) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"pcapng block size %u > maximum %u\",\n\t\t    total_length, INITIAL_MAX_BLOCKSIZE);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unknown time stamp resolution %u\", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    (u_char *)p->buffer + (sizeof(magic) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* currently only SHB version 1.0 is supported */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unsupported pcapng savefile version %u.%u\",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has no Interface Description Blocks\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has a packet block before any Interface Description Blocks\");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->snapshot = idbp->snaplen;\n\tif (p->snapshot <= 0) {\n\t\t/*\n\t\t * Bogus snapshot length; use the maximum for this\n\t\t * link-layer type as a fallback.\n\t\t *\n\t\t * XXX - the only reason why snapshot is signed is\n\t\t * that pcap_snapshot() returns an int, not an\n\t\t * unsigned int.\n\t\t */\n\t\tp->snapshot = max_snaplen_for_dlt(idbp->linktype);\n\t}\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              762,
              0
            ],
            [
              1081,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_ng_check_header",
            "parameters": {
              "magic": "bpf_u_int32",
              "fp": "FILE",
              "precision": "u_int",
              "errbuf": "char",
              "err": "int"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static void\npcap_ng_cleanup(pcap_t *p)\n{\n\tstruct pcap_ng_sf *ps = p->priv;\n\n\tfree(ps->ifaces);\n\tsf_cleanup(p);\n}",
          "fn_code_pos": [
            [
              1083,
              0
            ],
            [
              1090,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_ng_cleanup",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\npcap_ng_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)\n{\n\tstruct pcap_ng_sf *ps = p->priv;\n\tstruct block_cursor cursor;\n\tint status;\n\tstruct enhanced_packet_block *epbp;\n\tstruct simple_packet_block *spbp;\n\tstruct packet_block *pbp;\n\tbpf_u_int32 interface_id = 0xFFFFFFFF;\n\tstruct interface_description_block *idbp;\n\tstruct section_header_block *shbp;\n\tFILE *fp = p->rfile;\n\tuint64_t t, sec, frac;\n\n\t/*\n\t * Look for an Enhanced Packet Block, a Simple Packet Block,\n\t * or a Packet Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the block type and length; those are common\n\t\t * to all blocks.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, p->errbuf);\n\t\tif (status == 0)\n\t\t\treturn (1);\t/* EOF */\n\t\tif (status == -1)\n\t\t\treturn (-1);\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_EPB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * EPB.\n\t\t\t */\n\t\t\tepbp = get_from_block_data(&cursor, sizeof(*epbp),\n\t\t\t    p->errbuf);\n\t\t\tif (epbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\t/* these were written in opposite byte order */\n\t\t\t\tinterface_id = SWAPLONG(epbp->interface_id);\n\t\t\t\thdr->caplen = SWAPLONG(epbp->caplen);\n\t\t\t\thdr->len = SWAPLONG(epbp->len);\n\t\t\t\tt = ((uint64_t)SWAPLONG(epbp->timestamp_high)) << 32 |\n\t\t\t\t    SWAPLONG(epbp->timestamp_low);\n\t\t\t} else {\n\t\t\t\tinterface_id = epbp->interface_id;\n\t\t\t\thdr->caplen = epbp->caplen;\n\t\t\t\thdr->len = epbp->len;\n\t\t\t\tt = ((uint64_t)epbp->timestamp_high) << 32 |\n\t\t\t\t    epbp->timestamp_low;\n\t\t\t}\n\t\t\tgoto found;\n\n\t\tcase BT_SPB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * SPB.\n\t\t\t */\n\t\t\tspbp = get_from_block_data(&cursor, sizeof(*spbp),\n\t\t\t    p->errbuf);\n\t\t\tif (spbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * SPB packets are assumed to have arrived on\n\t\t\t * the first interface.\n\t\t\t */\n\t\t\tinterface_id = 0;\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\t/* these were written in opposite byte order */\n\t\t\t\thdr->len = SWAPLONG(spbp->len);\n\t\t\t} else\n\t\t\t\thdr->len = spbp->len;\n\n\t\t\t/*\n\t\t\t * The SPB doesn't give the captured length;\n\t\t\t * it's the minimum of the snapshot length\n\t\t\t * and the packet length.\n\t\t\t */\n\t\t\thdr->caplen = hdr->len;\n\t\t\tif (hdr->caplen > (bpf_u_int32)p->snapshot)\n\t\t\t\thdr->caplen = p->snapshot;\n\t\t\tt = 0;\t/* no time stamps */\n\t\t\tgoto found;\n\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * PB.\n\t\t\t */\n\t\t\tpbp = get_from_block_data(&cursor, sizeof(*pbp),\n\t\t\t    p->errbuf);\n\t\t\tif (pbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\t/* these were written in opposite byte order */\n\t\t\t\tinterface_id = SWAPSHORT(pbp->interface_id);\n\t\t\t\thdr->caplen = SWAPLONG(pbp->caplen);\n\t\t\t\thdr->len = SWAPLONG(pbp->len);\n\t\t\t\tt = ((uint64_t)SWAPLONG(pbp->timestamp_high)) << 32 |\n\t\t\t\t    SWAPLONG(pbp->timestamp_low);\n\t\t\t} else {\n\t\t\t\tinterface_id = pbp->interface_id;\n\t\t\t\thdr->caplen = pbp->caplen;\n\t\t\t\thdr->len = pbp->len;\n\t\t\t\tt = ((uint64_t)pbp->timestamp_high) << 32 |\n\t\t\t\t    pbp->timestamp_low;\n\t\t\t}\n\t\t\tgoto found;\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Interface Description Block.  Get a pointer\n\t\t\t * to its fixed-length portion.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    p->errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the link-layer type or snapshot length\n\t\t\t * differ from the ones for the first IDB we\n\t\t\t * saw, quit.\n\t\t\t *\n\t\t\t * XXX - just discard packets from those\n\t\t\t * interfaces?\n\t\t\t */\n\t\t\tif (p->linktype != idbp->linktype) {\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"an interface has a type %u different from the type of the first interface\",\n\t\t\t\t    idbp->linktype);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tif ((bpf_u_int32)p->snapshot != idbp->snaplen) {\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"an interface has a snapshot length %u different from the type of the first interface\",\n\t\t\t\t    idbp->snaplen);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, p->errbuf))\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\n\t\tcase BT_SHB:\n\t\t\t/*\n\t\t\t * Section Header Block.  Get a pointer\n\t\t\t * to its fixed-length portion.\n\t\t\t */\n\t\t\tshbp = get_from_block_data(&cursor, sizeof(*shbp),\n\t\t\t    p->errbuf);\n\t\t\tif (shbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Assume the byte order of this section is\n\t\t\t * the same as that of the previous section.\n\t\t\t * We'll check for that later.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tshbp->byte_order_magic =\n\t\t\t\t    SWAPLONG(shbp->byte_order_magic);\n\t\t\t\tshbp->major_version =\n\t\t\t\t    SWAPSHORT(shbp->major_version);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Make sure the byte order doesn't change;\n\t\t\t * pcap_is_swapped() shouldn't change its\n\t\t\t * return value in the middle of reading a capture.\n\t\t\t */\n\t\t\tswitch (shbp->byte_order_magic) {\n\n\t\t\tcase BYTE_ORDER_MAGIC:\n\t\t\t\t/*\n\t\t\t\t * OK.\n\t\t\t\t */\n\t\t\t\tbreak;\n\n\t\t\tcase SWAPLONG(BYTE_ORDER_MAGIC):\n\t\t\t\t/*\n\t\t\t\t * Byte order changes.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"the file has sections with different byte orders\");\n\t\t\t\treturn (-1);\n\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Not a valid SHB.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"the file has a section with a bad byte order magic field\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Make sure the major version is the version\n\t\t\t * we handle.\n\t\t\t */\n\t\t\tif (shbp->major_version != PCAP_NG_VERSION_MAJOR) {\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"unknown pcapng savefile major version number %u\",\n\t\t\t\t    shbp->major_version);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Reset the interface count; this section should\n\t\t\t * have its own set of IDBs.  If any of them\n\t\t\t * don't have the same interface type, snapshot\n\t\t\t * length, or resolution as the first interface\n\t\t\t * we saw, we'll fail.  (And if we don't see\n\t\t\t * any IDBs, we'll fail when we see a packet\n\t\t\t * block.)\n\t\t\t */\n\t\t\tps->ifcount = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Not a packet block, IDB, or SHB; ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\nfound:\n\t/*\n\t * Is the interface ID an interface we know?\n\t */\n\tif (interface_id >= ps->ifcount) {\n\t\t/*\n\t\t * Yes.  Fail.\n\t\t */\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"a packet arrived on interface %u, but there's no Interface Description Block for that interface\",\n\t\t    interface_id);\n\t\treturn (-1);\n\t}\n\n\tif (hdr->caplen > (bpf_u_int32)p->snapshot) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"invalid packet capture length %u, bigger than \"\n\t\t    \"snaplen of %d\", hdr->caplen, p->snapshot);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Convert the time stamp to seconds and fractions of a second,\n\t * with the fractions being in units of the file-supplied resolution.\n\t */\n\tsec = t / ps->ifaces[interface_id].tsresol + ps->ifaces[interface_id].tsoffset;\n\tfrac = t % ps->ifaces[interface_id].tsresol;\n\n\t/*\n\t * Convert the fractions from units of the file-supplied resolution\n\t * to units of the user-requested resolution.\n\t */\n\tswitch (ps->ifaces[interface_id].scale_type) {\n\n\tcase PASS_THROUGH:\n\t\t/*\n\t\t * The interface resolution is what the user wants,\n\t\t * so we're done.\n\t\t */\n\t\tbreak;\n\n\tcase SCALE_UP_DEC:\n\t\t/*\n\t\t * The interface resolution is less than what the user\n\t\t * wants; scale the fractional part up to the units of\n\t\t * the resolution the user requested by multiplying by\n\t\t * the quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.\n\t\t *\n\t\t * Those resolutions are both powers of 10, and the user-\n\t\t * requested resolution is greater than the file-supplied\n\t\t * resolution, so the quotient in question is an integer.\n\t\t * We've calculated that quotient already, so we just\n\t\t * multiply by it.\n\t\t */\n\t\tfrac *= ps->ifaces[interface_id].scale_factor;\n\t\tbreak;\n\n\tcase SCALE_UP_BIN:\n\t\t/*\n\t\t * The interface resolution is less than what the user\n\t\t * wants; scale the fractional part up to the units of\n\t\t * the resolution the user requested by multiplying by\n\t\t * the quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.\n\t\t *\n\t\t * The file-supplied resolution is a power of 2, so the\n\t\t * quotient is not an integer, so, in order to do this\n\t\t * entirely with integer arithmetic, we multiply by the\n\t\t * user-requested resolution and divide by the file-\n\t\t * supplied resolution.\n\t\t *\n\t\t * XXX - Is there something clever we could do here,\n\t\t * given that we know that the file-supplied resolution\n\t\t * is a power of 2?  Doing a multiplication followed by\n\t\t * a division runs the risk of overflowing, and involves\n\t\t * two non-simple arithmetic operations.\n\t\t */\n\t\tfrac *= ps->user_tsresol;\n\t\tfrac /= ps->ifaces[interface_id].tsresol;\n\t\tbreak;\n\n\tcase SCALE_DOWN_DEC:\n\t\t/*\n\t\t * The interface resolution is greater than what the user\n\t\t * wants; scale the fractional part up to the units of\n\t\t * the resolution the user requested by multiplying by\n\t\t * the quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.\n\t\t *\n\t\t * Those resolutions are both powers of 10, and the user-\n\t\t * requested resolution is less than the file-supplied\n\t\t * resolution, so the quotient in question isn't an\n\t\t * integer, but its reciprocal is, and we can just divide\n\t\t * by the reciprocal of the quotient.  We've calculated\n\t\t * the reciprocal of that quotient already, so we must\n\t\t * divide by it.\n\t\t */\n\t\tfrac /= ps->ifaces[interface_id].scale_factor;\n\t\tbreak;\n\n\n\tcase SCALE_DOWN_BIN:\n\t\t/*\n\t\t * The interface resolution is greater than what the user\n\t\t * wants; convert the fractional part to units of the\n\t\t * resolution the user requested by multiplying by the\n\t\t * quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.  We do that by multiplying\n\t\t * by the user-requested resolution and dividing by the\n\t\t * file-supplied resolution, as the quotient might not\n\t\t * fit in an integer.\n\t\t *\n\t\t * The file-supplied resolution is a power of 2, so the\n\t\t * quotient is not an integer, and neither is its\n\t\t * reciprocal, so, in order to do this entirely with\n\t\t * integer arithmetic, we multiply by the user-requested\n\t\t * resolution and divide by the file-supplied resolution.\n\t\t *\n\t\t * XXX - Is there something clever we could do here,\n\t\t * given that we know that the file-supplied resolution\n\t\t * is a power of 2?  Doing a multiplication followed by\n\t\t * a division runs the risk of overflowing, and involves\n\t\t * two non-simple arithmetic operations.\n\t\t */\n\t\tfrac *= ps->user_tsresol;\n\t\tfrac /= ps->ifaces[interface_id].tsresol;\n\t\tbreak;\n\t}\n#ifdef _WIN32\n\t/*\n\t * tv_sec and tv_used in the Windows struct timeval are both\n\t * longs.\n\t */\n\thdr->ts.tv_sec = (long)sec;\n\thdr->ts.tv_usec = (long)frac;\n#else\n\t/*\n\t * tv_sec in the UN*X struct timeval is a time_t; tv_usec is\n\t * suseconds_t in UN*Xes that work the way the current Single\n\t * UNIX Standard specify - but not all older UN*Xes necessarily\n\t * support that type, so just cast to int.\n\t */\n\thdr->ts.tv_sec = (time_t)sec;\n\thdr->ts.tv_usec = (int)frac;\n#endif\n\n\t/*\n\t * Get a pointer to the packet data.\n\t */\n\t*data = get_from_block_data(&cursor, hdr->caplen, p->errbuf);\n\tif (*data == NULL)\n\t\treturn (-1);\n\n\tif (p->swapped)\n\t\tswap_pseudo_headers(p->linktype, hdr, *data);\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1097,
              0
            ],
            [
              1509,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_ng_next_packet",
            "parameters": {
              "p": "pcap_t",
              "hdr": "struct pcap_pkthdr",
              "data": "u_char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "pcap_ng_cleanup(pcap_t *p)",
          "fn_dec_pos": [
            [
              249,
              12
            ],
            [
              249,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_ng_cleanup",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_ng_next_packet(pcap_t *p, struct pcap_pkthdr *hdr,\n    u_char **data)",
          "fn_dec_pos": [
            [
              250,
              11
            ],
            [
              251,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_ng_next_packet",
            "parameters": {
              "p": "pcap_t",
              "hdr": "struct pcap_pkthdr",
              "data": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "get_from_block_data(struct block_cursor *cursor, size_t chunk_size,\n    char *errbuf)",
          "fn_dec_pos": [
            [
              386,
              0
            ],
            [
              387,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_from_block_data",
            "parameters": {
              "cursor": "struct block_cursor",
              "chunk_size": "size_t",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "get_opthdr_from_block_data(pcap_t *p, struct block_cursor *cursor, char *errbuf)",
          "fn_dec_pos": [
            [
              412,
              0
            ],
            [
              412,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_opthdr_from_block_data",
            "parameters": {
              "p": "pcap_t",
              "cursor": "struct block_cursor",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "get_optvalue_from_block_data(struct block_cursor *cursor,\n    struct option_header *opthdr, char *errbuf)",
          "fn_dec_pos": [
            [
              436,
              0
            ],
            [
              437,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_optvalue_from_block_data",
            "parameters": {
              "cursor": "struct block_cursor",
              "opthdr": "struct option_header",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_ng_check_header(bpf_u_int32 magic, FILE *fp, u_int precision, char *errbuf,\n    int *err)",
          "fn_dec_pos": [
            [
              763,
              0
            ],
            [
              764,
              13
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_ng_check_header",
            "parameters": {
              "magic": "bpf_u_int32",
              "fp": "FILE",
              "precision": "u_int",
              "errbuf": "char",
              "err": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct block_header {\n\tbpf_u_int32\tblock_type;\n\tbpf_u_int32\ttotal_length;\n}",
          {
            "block_type": "bpf_u_int32",
            "total_length": "bpf_u_int32"
          },
          "block_header",
          [
            52,
            0
          ],
          [
            55,
            1
          ]
        ],
        [
          "struct block_trailer {\n\tbpf_u_int32\ttotal_length;\n}",
          {
            "total_length": "bpf_u_int32"
          },
          "block_trailer",
          [
            60,
            0
          ],
          [
            62,
            1
          ]
        ],
        [
          "struct option_header {\n\tu_short\t\toption_code;\n\tu_short\t\toption_length;\n}",
          {
            "option_code": "u_short",
            "option_length": "u_short"
          },
          "option_header",
          [
            73,
            0
          ],
          [
            76,
            1
          ]
        ],
        [
          "struct section_header_block {\n\tbpf_u_int32\tbyte_order_magic;\n\tu_short\t\tmajor_version;\n\tu_short\t\tminor_version;\n\tuint64_t\tsection_length;\n\t/* followed by options and trailer */\n}",
          {
            "byte_order_magic": "bpf_u_int32",
            "major_version": "u_short",
            "minor_version": "u_short",
            "section_length": "uint64_t"
          },
          "section_header_block",
          [
            88,
            0
          ],
          [
            94,
            1
          ]
        ],
        [
          "struct interface_description_block {\n\tu_short\t\tlinktype;\n\tu_short\t\treserved;\n\tbpf_u_int32\tsnaplen;\n\t/* followed by options and trailer */\n}",
          {
            "linktype": "u_short",
            "reserved": "u_short",
            "snaplen": "bpf_u_int32"
          },
          "interface_description_block",
          [
            113,
            0
          ],
          [
            118,
            1
          ]
        ],
        [
          "struct enhanced_packet_block {\n\tbpf_u_int32\tinterface_id;\n\tbpf_u_int32\ttimestamp_high;\n\tbpf_u_int32\ttimestamp_low;\n\tbpf_u_int32\tcaplen;\n\tbpf_u_int32\tlen;\n\t/* followed by packet data, options, and trailer */\n}",
          {
            "interface_id": "bpf_u_int32",
            "timestamp_high": "bpf_u_int32",
            "timestamp_low": "bpf_u_int32",
            "caplen": "bpf_u_int32",
            "len": "bpf_u_int32"
          },
          "enhanced_packet_block",
          [
            142,
            0
          ],
          [
            149,
            1
          ]
        ],
        [
          "struct simple_packet_block {\n\tbpf_u_int32\tlen;\n\t/* followed by packet data and trailer */\n}",
          {
            "len": "bpf_u_int32"
          },
          "simple_packet_block",
          [
            156,
            0
          ],
          [
            159,
            1
          ]
        ],
        [
          "struct packet_block {\n\tu_short\t\tinterface_id;\n\tu_short\t\tdrops_count;\n\tbpf_u_int32\ttimestamp_high;\n\tbpf_u_int32\ttimestamp_low;\n\tbpf_u_int32\tcaplen;\n\tbpf_u_int32\tlen;\n\t/* followed by packet data, options, and trailer */\n}",
          {
            "interface_id": "u_short",
            "drops_count": "u_short",
            "timestamp_high": "bpf_u_int32",
            "timestamp_low": "bpf_u_int32",
            "caplen": "bpf_u_int32",
            "len": "bpf_u_int32"
          },
          "packet_block",
          [
            166,
            0
          ],
          [
            174,
            1
          ]
        ],
        [
          "struct block_cursor {\n\tu_char\t\t*data;\n\tsize_t\t\tdata_remaining;\n\tbpf_u_int32\tblock_type;\n}",
          {
            "*data": "u_char",
            "data_remaining": "size_t",
            "block_type": "bpf_u_int32"
          },
          "block_cursor",
          [
            181,
            0
          ],
          [
            185,
            1
          ]
        ],
        [
          "struct pcap_ng_if {\n\tuint64_t tsresol;\t\t/* time stamp resolution */\n\ttstamp_scale_type_t scale_type;\t/* how to scale */\n\tuint64_t scale_factor;\t\t/* time stamp scale factor for power-of-10 tsresol */\n\tuint64_t tsoffset;\t\t/* time stamp offset */\n}",
          {
            "tsresol": "uint64_t",
            "scale_type": "tstamp_scale_type_t",
            "scale_factor": "uint64_t",
            "tsoffset": "uint64_t"
          },
          "pcap_ng_if",
          [
            198,
            0
          ],
          [
            203,
            1
          ]
        ],
        [
          "struct pcap_ng_sf {\n\tuint64_t user_tsresol;\t\t/* time stamp resolution requested by the user */\n\tu_int max_blocksize;\t\t/* don't grow buffer size past this */\n\tbpf_u_int32 ifcount;\t\t/* number of interfaces seen in this capture */\n\tbpf_u_int32 ifaces_size;\t/* size of array below */\n\tstruct pcap_ng_if *ifaces;\t/* array of interface information */\n}",
          {
            "user_tsresol": "uint64_t",
            "max_blocksize": "u_int",
            "ifcount": "bpf_u_int32",
            "ifaces_size": "bpf_u_int32",
            "*ifaces": "struct pcap_ng_if"
          },
          "pcap_ng_sf",
          [
            224,
            0
          ],
          [
            230,
            1
          ]
        ],
        [
          "struct block_header {\n\tbpf_u_int32\tblock_type;\n\tbpf_u_int32\ttotal_length;\n}",
          {
            "block_type": "bpf_u_int32",
            "total_length": "bpf_u_int32"
          },
          "block_header",
          [
            52,
            0
          ],
          [
            55,
            1
          ]
        ],
        [
          "struct block_trailer {\n\tbpf_u_int32\ttotal_length;\n}",
          {
            "total_length": "bpf_u_int32"
          },
          "block_trailer",
          [
            60,
            0
          ],
          [
            62,
            1
          ]
        ],
        [
          "struct option_header {\n\tu_short\t\toption_code;\n\tu_short\t\toption_length;\n}",
          {
            "option_code": "u_short",
            "option_length": "u_short"
          },
          "option_header",
          [
            73,
            0
          ],
          [
            76,
            1
          ]
        ],
        [
          "struct section_header_block {\n\tbpf_u_int32\tbyte_order_magic;\n\tu_short\t\tmajor_version;\n\tu_short\t\tminor_version;\n\tuint64_t\tsection_length;\n\t/* followed by options and trailer */\n}",
          {
            "byte_order_magic": "bpf_u_int32",
            "major_version": "u_short",
            "minor_version": "u_short",
            "section_length": "uint64_t"
          },
          "section_header_block",
          [
            88,
            0
          ],
          [
            94,
            1
          ]
        ],
        [
          "struct interface_description_block {\n\tu_short\t\tlinktype;\n\tu_short\t\treserved;\n\tbpf_u_int32\tsnaplen;\n\t/* followed by options and trailer */\n}",
          {
            "linktype": "u_short",
            "reserved": "u_short",
            "snaplen": "bpf_u_int32"
          },
          "interface_description_block",
          [
            113,
            0
          ],
          [
            118,
            1
          ]
        ],
        [
          "struct enhanced_packet_block {\n\tbpf_u_int32\tinterface_id;\n\tbpf_u_int32\ttimestamp_high;\n\tbpf_u_int32\ttimestamp_low;\n\tbpf_u_int32\tcaplen;\n\tbpf_u_int32\tlen;\n\t/* followed by packet data, options, and trailer */\n}",
          {
            "interface_id": "bpf_u_int32",
            "timestamp_high": "bpf_u_int32",
            "timestamp_low": "bpf_u_int32",
            "caplen": "bpf_u_int32",
            "len": "bpf_u_int32"
          },
          "enhanced_packet_block",
          [
            142,
            0
          ],
          [
            149,
            1
          ]
        ],
        [
          "struct simple_packet_block {\n\tbpf_u_int32\tlen;\n\t/* followed by packet data and trailer */\n}",
          {
            "len": "bpf_u_int32"
          },
          "simple_packet_block",
          [
            156,
            0
          ],
          [
            159,
            1
          ]
        ],
        [
          "struct packet_block {\n\tu_short\t\tinterface_id;\n\tu_short\t\tdrops_count;\n\tbpf_u_int32\ttimestamp_high;\n\tbpf_u_int32\ttimestamp_low;\n\tbpf_u_int32\tcaplen;\n\tbpf_u_int32\tlen;\n\t/* followed by packet data, options, and trailer */\n}",
          {
            "interface_id": "u_short",
            "drops_count": "u_short",
            "timestamp_high": "bpf_u_int32",
            "timestamp_low": "bpf_u_int32",
            "caplen": "bpf_u_int32",
            "len": "bpf_u_int32"
          },
          "packet_block",
          [
            166,
            0
          ],
          [
            174,
            1
          ]
        ],
        [
          "struct block_cursor {\n\tu_char\t\t*data;\n\tsize_t\t\tdata_remaining;\n\tbpf_u_int32\tblock_type;\n}",
          {
            "*data": "u_char",
            "data_remaining": "size_t",
            "block_type": "bpf_u_int32"
          },
          "block_cursor",
          [
            181,
            0
          ],
          [
            185,
            1
          ]
        ],
        [
          "struct pcap_ng_if {\n\tuint64_t tsresol;\t\t/* time stamp resolution */\n\ttstamp_scale_type_t scale_type;\t/* how to scale */\n\tuint64_t scale_factor;\t\t/* time stamp scale factor for power-of-10 tsresol */\n\tuint64_t tsoffset;\t\t/* time stamp offset */\n}",
          {
            "tsresol": "uint64_t",
            "scale_type": "tstamp_scale_type_t",
            "scale_factor": "uint64_t",
            "tsoffset": "uint64_t"
          },
          "pcap_ng_if",
          [
            198,
            0
          ],
          [
            203,
            1
          ]
        ],
        [
          "struct pcap_ng_sf {\n\tuint64_t user_tsresol;\t\t/* time stamp resolution requested by the user */\n\tu_int max_blocksize;\t\t/* don't grow buffer size past this */\n\tbpf_u_int32 ifcount;\t\t/* number of interfaces seen in this capture */\n\tbpf_u_int32 ifaces_size;\t/* size of array below */\n\tstruct pcap_ng_if *ifaces;\t/* array of interface information */\n}",
          {
            "user_tsresol": "uint64_t",
            "max_blocksize": "u_int",
            "ifcount": "bpf_u_int32",
            "ifaces_size": "bpf_u_int32",
            "*ifaces": "struct pcap_ng_if"
          },
          "pcap_ng_sf",
          [
            224,
            0
          ],
          [
            230,
            1
          ]
        ],
        [
          "struct pcap_ng_if",
          {},
          "",
          [
            229,
            1
          ],
          [
            229,
            18
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            250,
            42
          ],
          [
            250,
            60
          ]
        ],
        [
          "struct block_cursor",
          {},
          "",
          [
            277,
            32
          ],
          [
            277,
            51
          ]
        ],
        [
          "struct pcap_ng_sf",
          {},
          "",
          [
            279,
            1
          ],
          [
            279,
            18
          ]
        ],
        [
          "struct block_header",
          {},
          "",
          [
            281,
            1
          ],
          [
            281,
            20
          ]
        ],
        [
          "struct block_trailer",
          {},
          "",
          [
            282,
            1
          ],
          [
            282,
            21
          ]
        ],
        [
          "struct block_header",
          {},
          "",
          [
            301,
            32
          ],
          [
            301,
            51
          ]
        ],
        [
          "struct block_trailer",
          {},
          "",
          [
            302,
            12
          ],
          [
            302,
            32
          ]
        ],
        [
          "struct block_header",
          {},
          "",
          [
            306,
            13
          ],
          [
            306,
            32
          ]
        ],
        [
          "struct block_trailer",
          {},
          "",
          [
            306,
            43
          ],
          [
            306,
            63
          ]
        ],
        [
          "struct block_trailer",
          {},
          "",
          [
            359,
            10
          ],
          [
            359,
            30
          ]
        ],
        [
          "struct block_trailer",
          {},
          "",
          [
            359,
            67
          ],
          [
            359,
            87
          ]
        ],
        [
          "struct block_trailer",
          {},
          "",
          [
            380,
            50
          ],
          [
            380,
            70
          ]
        ],
        [
          "struct block_cursor",
          {},
          "",
          [
            386,
            20
          ],
          [
            386,
            39
          ]
        ],
        [
          "struct option_header",
          {},
          "",
          [
            411,
            7
          ],
          [
            411,
            27
          ]
        ],
        [
          "struct block_cursor",
          {},
          "",
          [
            412,
            38
          ],
          [
            412,
            57
          ]
        ],
        [
          "struct option_header",
          {},
          "",
          [
            414,
            1
          ],
          [
            414,
            21
          ]
        ],
        [
          "struct block_cursor",
          {},
          "",
          [
            436,
            29
          ],
          [
            436,
            48
          ]
        ],
        [
          "struct option_header",
          {},
          "",
          [
            437,
            4
          ],
          [
            437,
            24
          ]
        ],
        [
          "struct block_cursor",
          {},
          "",
          [
            458,
            31
          ],
          [
            458,
            50
          ]
        ],
        [
          "struct option_header",
          {},
          "",
          [
            461,
            1
          ],
          [
            461,
            21
          ]
        ],
        [
          "struct block_cursor",
          {},
          "",
          [
            589,
            25
          ],
          [
            589,
            44
          ]
        ],
        [
          "struct pcap_ng_sf",
          {},
          "",
          [
            591,
            1
          ],
          [
            591,
            18
          ]
        ],
        [
          "struct pcap_ng_if",
          {},
          "",
          [
            611,
            2
          ],
          [
            611,
            19
          ]
        ],
        [
          "struct pcap_ng_if",
          {},
          "",
          [
            631,
            31
          ],
          [
            631,
            48
          ]
        ],
        [
          "struct pcap_ng_if",
          {},
          "",
          [
            667,
            33
          ],
          [
            667,
            50
          ]
        ],
        [
          "struct pcap_ng_if",
          {},
          "",
          [
            679,
            38
          ],
          [
            679,
            55
          ]
        ],
        [
          "struct pcap_ng_if",
          {},
          "",
          [
            682,
            62
          ],
          [
            682,
            79
          ]
        ],
        [
          "struct block_header",
          {},
          "",
          [
            769,
            1
          ],
          [
            769,
            20
          ]
        ],
        [
          "struct section_header_block",
          {},
          "",
          [
            770,
            1
          ],
          [
            770,
            28
          ]
        ],
        [
          "struct pcap_ng_sf",
          {},
          "",
          [
            773,
            1
          ],
          [
            773,
            18
          ]
        ],
        [
          "struct block_cursor",
          {},
          "",
          [
            775,
            1
          ],
          [
            775,
            20
          ]
        ],
        [
          "struct interface_description_block",
          {},
          "",
          [
            776,
            1
          ],
          [
            776,
            35
          ]
        ],
        [
          "struct block_trailer",
          {},
          "",
          [
            856,
            60
          ],
          [
            856,
            80
          ]
        ],
        [
          "struct block_trailer",
          {},
          "",
          [
            860,
            46
          ],
          [
            860,
            66
          ]
        ],
        [
          "struct pcap_ng_sf",
          {},
          "",
          [
            880,
            46
          ],
          [
            880,
            63
          ]
        ],
        [
          "struct block_header",
          {},
          "",
          [
            944,
            10
          ],
          [
            944,
            29
          ]
        ],
        [
          "struct section_header_block",
          {},
          "",
          [
            945,
            9
          ],
          [
            945,
            36
          ]
        ],
        [
          "struct block_header",
          {},
          "",
          [
            945,
            69
          ],
          [
            945,
            88
          ]
        ],
        [
          "struct pcap_ng_sf",
          {},
          "",
          [
            1086,
            1
          ],
          [
            1086,
            18
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            1098,
            31
          ],
          [
            1098,
            49
          ]
        ],
        [
          "struct pcap_ng_sf",
          {},
          "",
          [
            1100,
            1
          ],
          [
            1100,
            18
          ]
        ],
        [
          "struct block_cursor",
          {},
          "",
          [
            1101,
            1
          ],
          [
            1101,
            20
          ]
        ],
        [
          "struct enhanced_packet_block",
          {},
          "",
          [
            1103,
            1
          ],
          [
            1103,
            29
          ]
        ],
        [
          "struct simple_packet_block",
          {},
          "",
          [
            1104,
            1
          ],
          [
            1104,
            27
          ]
        ],
        [
          "struct packet_block",
          {},
          "",
          [
            1105,
            1
          ],
          [
            1105,
            20
          ]
        ],
        [
          "struct interface_description_block",
          {},
          "",
          [
            1107,
            1
          ],
          [
            1107,
            35
          ]
        ],
        [
          "struct section_header_block",
          {},
          "",
          [
            1108,
            1
          ],
          [
            1108,
            28
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <pcap/pcap-inttypes.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <memory.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"pcap-common.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"os-proto.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"sf-pcapng.h\"\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n\tPASS_THROUGH,\n\tSCALE_UP_DEC,\n\tSCALE_DOWN_DEC,\n\tSCALE_UP_BIN,\n\tSCALE_DOWN_BIN\n} tstamp_scale_type_t;",
          {
            "PASS_THROUGH": "",
            "SCALE_UP_DEC": "",
            "SCALE_DOWN_DEC": "",
            "SCALE_UP_BIN": "",
            "SCALE_DOWN_BIN": ""
          },
          "tstamp_scale_type_t",
          [
            187,
            0
          ],
          [
            193,
            22
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-usb-linux.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nhave_binary_usbmon(void)\n{\n\tstruct utsname utsname;\n\tchar *version_component, *endp;\n\tlong major, minor, subminor;\n\n\tif (uname(&utsname) == 0) {\n\t\t/*\n\t\t * 2.6.21 is the first release with the binary-mode\n\t\t * USB monitoring.\n\t\t */\n\t\tversion_component = utsname.release;\n\t\tmajor = strtol(version_component, &endp, 10);\n\t\tif (endp != version_component && *endp == '.') {\n\t\t\t/*\n\t\t\t * OK, that was a valid major version.\n\t\t\t * Is it 3 or greater?  If so, we have binary\n\t\t\t * mode support.\n\t\t\t */\n\t\t\tif (major >= 3)\n\t\t\t\treturn 1;\n\n\t\t\t/*\n\t\t\t * Is it 1 or less?  If so, we don't have binary\n\t\t\t * mode support.  (In fact, we don't have any\n\t\t\t * USB monitoring....)\n\t\t\t */\n\t\t\tif (major <= 1)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * OK, this is a 2.x kernel.\n\t\t * What's the minor version?\n\t\t */\n\t\tversion_component = endp + 1;\n\t\tminor = strtol(version_component, &endp, 10);\n\t\tif (endp != version_component &&\n\t\t    (*endp == '.' || *endp == '\\0')) {\n\t\t\t/*\n\t\t\t * OK, that was a valid minor version.\n\t\t\t * Is is 2.6 or later?  (There shouldn't be a\n\t\t\t * \"later\", as 2.6.x went to 3.x, but we'll\n\t\t\t * check anyway.)\n\t\t\t */\n\t\t\tif (minor < 6) {\n\t\t\t\t/*\n\t\t\t\t * No, so no binary support (did 2.4 have\n\t\t\t\t * any USB monitoring at all?)\n\t\t\t\t */\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * OK, this is a 2.6.x kernel.\n\t\t\t * What's the subminor version?\n\t\t\t */\n\t\t\tversion_component = endp + 1;\n\t\t\tsubminor = strtol(version_component, &endp, 10);\n\t\t\tif (endp != version_component &&\n\t\t\t    (*endp == '.' || *endp == '\\0')) {\n\t\t\t\t/*\n\t\t\t\t * OK, that was a valid subminor version.\n\t\t\t\t * Is it 21 or greater?\n\t\t\t\t */\n\t\t\t\tif (subminor >= 21) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Yes - we have binary mode\n\t\t\t\t\t * support.\n\t\t\t\t\t */\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Either uname() failed, in which case we just say \"no binary\n\t * mode support\", or we don't have binary mode support.\n\t */\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              142,
              0
            ],
            [
              224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "have_binary_usbmon",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nusb_dev_add(pcap_if_list_t *devlistp, int n, char *err_str)\n{\n\tchar dev_name[10];\n\tchar dev_descr[30];\n\tpcap_snprintf(dev_name, 10, USB_IFACE\"%d\", n);\n\t/*\n\t * XXX - is there any notion of \"up\" and \"running\"?\n\t */\n\tif (n == 0) {\n\t\t/*\n\t\t * As this refers to all buses, there's no notion of\n\t\t * \"connected\" vs. \"disconnected\", as that's a property\n\t\t * that would apply to a particular USB interface.\n\t\t */\n\t\tif (add_dev(devlistp, dev_name,\n\t\t    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE,\n\t\t    \"Raw USB traffic, all USB buses\", err_str) == NULL)\n\t\t\treturn -1;\n\t} else {\n\t\t/*\n\t\t * XXX - is there a way to determine whether anything's\n\t\t * plugged into this bus interface or not, and set\n\t\t * PCAP_IF_CONNECTION_STATUS_CONNECTED or\n\t\t * PCAP_IF_CONNECTION_STATUS_DISCONNECTED?\n\t\t */\n\t\tpcap_snprintf(dev_descr, 30, \"Raw USB traffic, bus number %d\", n);\n\t\tif (add_dev(devlistp, dev_name, 0, dev_descr, err_str) == NULL)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              227,
              0
            ],
            [
              259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_dev_add",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "n": "int",
              "err_str": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nusb_findalldevs(pcap_if_list_t *devlistp, char *err_str)\n{\n\tchar usb_mon_dir[PATH_MAX];\n\tchar *usb_mon_prefix;\n\tsize_t usb_mon_prefix_len;\n\tstruct dirent* data;\n\tint ret = 0;\n\tDIR* dir;\n\tint n;\n\tchar* name;\n\tsize_t len;\n\n\tif (have_binary_usbmon()) {\n\t\t/*\n\t\t * We have binary-mode support.\n\t\t * What do the device names look like?\n\t\t * Split LINUX_USB_MON_DEV into a directory that we'll\n\t\t * scan and a file name prefix that we'll check for.\n\t\t */\n\t\tpcap_strlcpy(usb_mon_dir, LINUX_USB_MON_DEV, sizeof usb_mon_dir);\n\t\tusb_mon_prefix = strrchr(usb_mon_dir, '/');\n\t\tif (usb_mon_prefix == NULL) {\n\t\t\t/*\n\t\t\t * This \"shouldn't happen\".  Just give up if it\n\t\t\t * does.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t\t*usb_mon_prefix++ = '\\0';\n\t\tusb_mon_prefix_len = strlen(usb_mon_prefix);\n\n\t\t/*\n\t\t * Open the directory and scan it.\n\t\t */\n\t\tdir = opendir(usb_mon_dir);\n\t\tif (dir != NULL) {\n\t\t\twhile ((ret == 0) && ((data = readdir(dir)) != 0)) {\n\t\t\t\tname = data->d_name;\n\n\t\t\t\t/*\n\t\t\t\t * Is this a usbmon device?\n\t\t\t\t */\n\t\t\t\tif (strncmp(name, usb_mon_prefix, usb_mon_prefix_len) != 0)\n\t\t\t\t\tcontinue;\t/* no */\n\n\t\t\t\t/*\n\t\t\t\t * What's the device number?\n\t\t\t\t */\n\t\t\t\tif (sscanf(&name[usb_mon_prefix_len], \"%d\", &n) == 0)\n\t\t\t\t\tcontinue;\t/* failed */\n\n\t\t\t\tret = usb_dev_add(devlistp, n, err_str);\n\t\t\t}\n\n\t\t\tclosedir(dir);\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\t/*\n\t\t * We have only text mode support.\n\t\t * We don't look for the text devices because we can't\n\t\t * look for them without root privileges, and we don't\n\t\t * want to require root privileges to enumerate devices\n\t\t * (we want to let the user to try a device and get\n\t\t * an error, rather than seeing no devices and asking\n\t\t * \"why am I not seeing devices\" and forcing a long\n\t\t * process of poking to figure out whether it's \"no\n\t\t * privileges\" or \"your kernel is too old\" or \"the\n\t\t * usbmon module isn't loaded\" or...).\n\t\t *\n\t\t * Instead, we look to see what buses we have.\n\t\t * If the kernel is so old that it doesn't have\n\t\t * binary-mode support, it's also so old that\n\t\t * it doesn't have a \"scan all buses\" device.\n\t\t *\n\t\t * First, try scanning sysfs USB bus directory.\n\t\t */\n\t\tdir = opendir(SYS_USB_BUS_DIR);\n\t\tif (dir != NULL) {\n\t\t\twhile ((ret == 0) && ((data = readdir(dir)) != 0)) {\n\t\t\t\tname = data->d_name;\n\n\t\t\t\tif (strncmp(name, \"usb\", 3) != 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (sscanf(&name[3], \"%d\", &n) == 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tret = usb_dev_add(devlistp, n, err_str);\n\t\t\t}\n\n\t\t\tclosedir(dir);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* That didn't work; try scanning procfs USB bus directory. */\n\t\tdir = opendir(PROC_USB_BUS_DIR);\n\t\tif (dir != NULL) {\n\t\t\twhile ((ret == 0) && ((data = readdir(dir)) != 0)) {\n\t\t\t\tname = data->d_name;\n\t\t\t\tlen = strlen(name);\n\n\t\t\t\t/* if this file name does not end with a number it's not of our interest */\n\t\t\t\tif ((len < 1) || !isdigit(name[--len]))\n\t\t\t\t\tcontinue;\n\t\t\t\twhile (isdigit(name[--len]));\n\t\t\t\tif (sscanf(&name[len+1], \"%d\", &n) != 1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tret = usb_dev_add(devlistp, n, err_str);\n\t\t\t}\n\n\t\t\tclosedir(dir);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* neither of them worked */\n\t\treturn 0;\n\t}\n}",
          "fn_code_pos": [
            [
              261,
              0
            ],
            [
              381,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "err_str": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static\nint usb_mmap(pcap_t* handle)\n{\n\tstruct pcap_usb_linux *handlep = handle->priv;\n\tint len = ioctl(handle->fd, MON_IOCQ_RING_SIZE);\n\tif (len < 0)\n\t\treturn 0;\n\n\thandlep->mmapbuflen = len;\n\thandlep->mmapbuf = mmap(0, handlep->mmapbuflen, PROT_READ,\n\t    MAP_SHARED, handle->fd, 0);\n\treturn handlep->mmapbuf != MAP_FAILED;\n}",
          "fn_code_pos": [
            [
              383,
              0
            ],
            [
              395,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_mmap",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nprobe_devices(int bus)\n{\n\tstruct usbdevfs_ctrltransfer ctrl;\n\tstruct dirent* data;\n\tint ret = 0;\n\tchar buf[sizeof(\"/dev/bus/usb/000/\") + NAME_MAX];\n\tDIR* dir;\n\n\t/* scan usb bus directories for device nodes */\n\tpcap_snprintf(buf, sizeof(buf), \"/dev/bus/usb/%03d\", bus);\n\tdir = opendir(buf);\n\tif (!dir)\n\t\treturn;\n\n\twhile ((ret >= 0) && ((data = readdir(dir)) != 0)) {\n\t\tint fd;\n\t\tchar* name = data->d_name;\n\n\t\tif (name[0] == '.')\n\t\t\tcontinue;\n\n\t\tpcap_snprintf(buf, sizeof(buf), \"/dev/bus/usb/%03d/%s\", bus, data->d_name);\n\n\t\tfd = open(buf, O_RDWR);\n\t\tif (fd == -1)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Sigh.  Different kernels have different member names\n\t\t * for this structure.\n\t\t */\n#ifdef HAVE_STRUCT_USBDEVFS_CTRLTRANSFER_BREQUESTTYPE\n\t\tctrl.bRequestType = USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE;\n\t\tctrl.bRequest = USB_REQ_GET_DESCRIPTOR;\n\t\tctrl.wValue = USB_DT_DEVICE << 8;\n\t\tctrl.wIndex = 0;\n \t\tctrl.wLength = sizeof(buf);\n#else\n\t\tctrl.requesttype = USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE;\n\t\tctrl.request = USB_REQ_GET_DESCRIPTOR;\n\t\tctrl.value = USB_DT_DEVICE << 8;\n\t\tctrl.index = 0;\n \t\tctrl.length = sizeof(buf);\n#endif\n\t\tctrl.data = buf;\n\t\tctrl.timeout = CTRL_TIMEOUT;\n\n\t\tret = ioctl(fd, USBDEVFS_CONTROL, &ctrl);\n\n\t\tclose(fd);\n\t}\n\tclosedir(dir);\n}",
          "fn_code_pos": [
            [
              413,
              0
            ],
            [
              466,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "probe_devices",
            "parameters": {
              "bus": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_t *\nusb_create(const char *device, char *ebuf, int *is_ours)\n{\n\tconst char *cp;\n\tchar *cpend;\n\tlong devnum;\n\tpcap_t *p;\n\n\t/* Does this look like a USB monitoring device? */\n\tcp = strrchr(device, '/');\n\tif (cp == NULL)\n\t\tcp = device;\n\t/* Does it begin with USB_IFACE? */\n\tif (strncmp(cp, USB_IFACE, sizeof USB_IFACE - 1) != 0) {\n\t\t/* Nope, doesn't begin with USB_IFACE */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\t/* Yes - is USB_IFACE followed by a number? */\n\tcp += sizeof USB_IFACE - 1;\n\tdevnum = strtol(cp, &cpend, 10);\n\tif (cpend == cp || *cpend != '\\0') {\n\t\t/* Not followed by a number. */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\tif (devnum < 0) {\n\t\t/* Followed by a non-valid number. */\n\t\t*is_ours = 0;\n\t\treturn NULL;\n\t}\n\n\t/* OK, it's probably ours. */\n\t*is_ours = 1;\n\n\tp = pcap_create_common(ebuf, sizeof (struct pcap_usb_linux));\n\tif (p == NULL)\n\t\treturn (NULL);\n\n\tp->activate_op = usb_activate;\n\treturn (p);\n}",
          "fn_code_pos": [
            [
              469,
              0
            ],
            [
              510,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static int\nusb_activate(pcap_t* handle)\n{\n\tstruct pcap_usb_linux *handlep = handle->priv;\n\tchar \t\tfull_path[USB_LINE_LEN];\n\tint\t\tret;\n\n\t/*\n\t * Turn a negative snapshot value (invalid), a snapshot value of\n\t * 0 (unspecified), or a value bigger than the normal maximum\n\t * value, into the maximum allowed value.\n\t *\n\t * If some application really *needs* a bigger snapshot\n\t * length, we should just increase MAXIMUM_SNAPLEN.\n\t */\n\tif (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)\n\t\thandle->snapshot = MAXIMUM_SNAPLEN;\n\n\t/* Initialize some components of the pcap structure. */\n\thandle->bufsize = handle->snapshot;\n\thandle->offset = 0;\n\thandle->linktype = DLT_USB_LINUX;\n\n\thandle->inject_op = usb_inject_linux;\n\thandle->setfilter_op = install_bpf_program; /* no kernel filtering */\n\thandle->setdirection_op = usb_setdirection_linux;\n\thandle->set_datalink_op = NULL;\t/* can't change data link type */\n\thandle->getnonblock_op = pcap_getnonblock_fd;\n\thandle->setnonblock_op = pcap_setnonblock_fd;\n\n\t/*get usb bus index from device name */\n\tif (sscanf(handle->opt.device, USB_IFACE\"%d\", &handlep->bus_index) != 1)\n\t{\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\"Can't get USB bus index from %s\", handle->opt.device);\n\t\treturn PCAP_ERROR;\n\t}\n\n\tif (have_binary_usbmon())\n\t{\n\t\t/*\n\t\t * We have binary-mode support.\n\t\t * Try to open the binary interface.\n\t\t */\n\t\tpcap_snprintf(full_path, USB_LINE_LEN, LINUX_USB_MON_DEV\"%d\", handlep->bus_index);\n\t\thandle->fd = open(full_path, O_RDONLY, 0);\n\t\tif (handle->fd < 0)\n\t\t{\n\t\t\t/*\n\t\t\t * The attempt failed; why?\n\t\t\t */\n\t\t\tswitch (errno) {\n\n\t\t\tcase ENOENT:\n\t\t\t\t/*\n\t\t\t\t * The device doesn't exist.\n\t\t\t\t * That could either mean that there's\n\t\t\t\t * no support for monitoring USB buses\n\t\t\t\t * (which probably means \"the usbmon\n\t\t\t\t * module isn't loaded\") or that there\n\t\t\t\t * is but that *particular* device\n\t\t\t\t * doesn't exist (no \"scan all buses\"\n\t\t\t\t * device if the bus index is 0, no\n\t\t\t\t * such bus if the bus index isn't 0).\n\t\t\t\t */\n\t\t\t\treturn PCAP_ERROR_NO_SUCH_DEVICE;\n\n\t\t\tcase EACCES:\n\t\t\t\t/*\n\t\t\t\t * We didn't have permission to open it.\n\t\t\t\t */\n\t\t\t\treturn PCAP_ERROR_PERM_DENIED;\n\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Something went wrong.\n\t\t\t\t */\n\t\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"Can't open USB bus file %s\", full_path);\n\t\t\t\treturn PCAP_ERROR;\n\t\t\t}\n\t\t}\n\n\t\tif (handle->opt.rfmon)\n\t\t{\n\t\t\t/*\n\t\t\t * Monitor mode doesn't apply to USB devices.\n\t\t\t */\n\t\t\tclose(handle->fd);\n\t\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t\t}\n\n\t\t/* try to use fast mmap access */\n\t\tif (usb_mmap(handle))\n\t\t{\n\t\t\thandle->linktype = DLT_USB_LINUX_MMAPPED;\n\t\t\thandle->stats_op = usb_stats_linux_bin;\n\t\t\thandle->read_op = usb_read_linux_mmap;\n\t\t\thandle->cleanup_op = usb_cleanup_linux_mmap;\n#ifdef HAVE_LINUX_USBDEVICE_FS_H\n\t\t\tprobe_devices(handlep->bus_index);\n#endif\n\n\t\t\t/*\n\t\t\t * \"handle->fd\" is a real file, so\n\t\t\t * \"select()\" and \"poll()\" work on it.\n\t\t\t */\n\t\t\thandle->selectable_fd = handle->fd;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* can't mmap, use plain binary interface access */\n\t\thandle->stats_op = usb_stats_linux_bin;\n\t\thandle->read_op = usb_read_linux_bin;\n#ifdef HAVE_LINUX_USBDEVICE_FS_H\n\t\tprobe_devices(handlep->bus_index);\n#endif\n\t}\n\telse {\n\t\t/*\n\t\t * We don't have binary mode support.\n\t\t * Try opening the text-mode device.\n\t\t */\n\t\tpcap_snprintf(full_path, USB_LINE_LEN, USB_TEXT_DIR\"/%dt\", handlep->bus_index);\n\t\thandle->fd = open(full_path, O_RDONLY, 0);\n\t\tif (handle->fd < 0)\n\t\t{\n\t\t\tif (errno == ENOENT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Not found at the new location; try\n\t\t\t\t * the old location.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(full_path, USB_LINE_LEN, USB_TEXT_DIR_OLD\"/%dt\", handlep->bus_index);\n\t\t\t\thandle->fd = open(full_path, O_RDONLY, 0);\n\t\t\t}\n\t\t\tif (handle->fd < 0) {\n\t\t\t\tif (errno == ENOENT)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * The problem is that the file\n\t\t\t\t\t * doesn't exist.  Report that as\n\t\t\t\t\t * \"no such device\".  (That could\n\t\t\t\t\t * mean \"no such USB bus\" or\n\t\t\t\t\t * \"monitoring not supported\".)\n\t\t\t\t\t */\n\t\t\t\t\tret = PCAP_ERROR_NO_SUCH_DEVICE;\n\t\t\t\t}\n\t\t\t\telse if (errno == EACCES)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * The problem is that we don't\n\t\t\t\t\t * have sufficient permission to\n\t\t\t\t\t * open the file.  Report that.\n\t\t\t\t\t */\n\t\t\t\t\tret = PCAP_ERROR_PERM_DENIED;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Some other error.\n\t\t\t\t\t */\n\t\t\t\t\tret = PCAP_ERROR;\n\t\t\t\t}\n\t\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"Can't open USB bus file %s\",\n\t\t\t\t    full_path);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif (handle->opt.rfmon)\n\t\t{\n\t\t\t/*\n\t\t\t * Monitor mode doesn't apply to USB devices.\n\t\t\t */\n\t\t\tclose(handle->fd);\n\t\t\treturn PCAP_ERROR_RFMON_NOTSUP;\n\t\t}\n\n\t\thandle->stats_op = usb_stats_linux;\n\t\thandle->read_op = usb_read_linux;\n\t}\n\n\t/*\n\t * \"handle->fd\" is a real file, so \"select()\" and \"poll()\"\n\t * work on it.\n\t */\n\thandle->selectable_fd = handle->fd;\n\n\t/* for plain binary access and text access we need to allocate the read\n\t * buffer */\n\thandle->buffer = malloc(handle->bufsize);\n\tif (!handle->buffer) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc\");\n\t\tclose(handle->fd);\n\t\treturn PCAP_ERROR;\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              512,
              0
            ],
            [
              714,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_activate",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static inline int\nascii_to_int(char c)\n{\n\treturn c < 'A' ? c- '0': ((c<'a') ? c - 'A' + 10: c-'a'+10);\n}",
          "fn_code_pos": [
            [
              716,
              0
            ],
            [
              720,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ascii_to_int",
            "parameters": {
              "c": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nusb_read_linux(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char *user)\n{\n\t/* see:\n\t* /usr/src/linux/Documentation/usb/usbmon.txt\n\t* for message format\n\t*/\n\tstruct pcap_usb_linux *handlep = handle->priv;\n\tunsigned timestamp;\n\tint tag, cnt, ep_num, dev_addr, dummy, ret, urb_len, data_len;\n\tssize_t read_ret;\n\tchar etype, pipeid1, pipeid2, status[16], urb_tag, line[USB_LINE_LEN];\n\tchar *string = line;\n\tu_char * rawdata = handle->buffer;\n\tstruct pcap_pkthdr pkth;\n\tpcap_usb_header* uhdr = (pcap_usb_header*)handle->buffer;\n\tu_char urb_transfer=0;\n\tint incoming=0;\n\n\t/* ignore interrupt system call errors */\n\tdo {\n\t\tread_ret = read(handle->fd, line, USB_LINE_LEN - 1);\n\t\tif (handle->break_loop)\n\t\t{\n\t\t\thandle->break_loop = 0;\n\t\t\treturn -2;\n\t\t}\n\t} while ((read_ret == -1) && (errno == EINTR));\n\tif (read_ret < 0)\n\t{\n\t\tif (errno == EAGAIN)\n\t\t\treturn 0;\t/* no data there */\n\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't read from fd %d\", handle->fd);\n\t\treturn -1;\n\t}\n\n\t/* read urb header; %n argument may increment return value, but it's\n\t* not mandatory, so does not count on it*/\n\tstring[read_ret] = 0;\n\tret = sscanf(string, \"%x %d %c %c%c:%d:%d %s%n\", &tag, &timestamp, &etype,\n\t\t&pipeid1, &pipeid2, &dev_addr, &ep_num, status,\n\t\t&cnt);\n\tif (ret < 8)\n\t{\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Can't parse USB bus message '%s', too few tokens (expected 8 got %d)\",\n\t\t    string, ret);\n\t\treturn -1;\n\t}\n\tuhdr->id = tag;\n\tuhdr->device_address = dev_addr;\n\tuhdr->bus_id = handlep->bus_index;\n\tuhdr->status = 0;\n\tstring += cnt;\n\n\t/* don't use usbmon provided timestamp, since it have low precision*/\n\tif (gettimeofday(&pkth.ts, NULL) < 0)\n\t{\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't get timestamp for message '%s'\", string);\n\t\treturn -1;\n\t}\n\tuhdr->ts_sec = pkth.ts.tv_sec;\n\tuhdr->ts_usec = (int32_t)pkth.ts.tv_usec;\n\n\t/* parse endpoint information */\n\tif (pipeid1 == 'C')\n\t\turb_transfer = URB_CONTROL;\n\telse if (pipeid1 == 'Z')\n\t\turb_transfer = URB_ISOCHRONOUS;\n\telse if (pipeid1 == 'I')\n\t\turb_transfer = URB_INTERRUPT;\n\telse if (pipeid1 == 'B')\n\t\turb_transfer = URB_BULK;\n\tif (pipeid2 == 'i') {\n\t\tep_num |= URB_TRANSFER_IN;\n\t\tincoming = 1;\n\t}\n\tif (etype == 'C')\n\t\tincoming = !incoming;\n\n\t/* direction check*/\n\tif (incoming)\n\t{\n\t\tif (handle->direction == PCAP_D_OUT)\n\t\t\treturn 0;\n\t}\n\telse\n\t\tif (handle->direction == PCAP_D_IN)\n\t\t\treturn 0;\n\tuhdr->event_type = etype;\n\tuhdr->transfer_type = urb_transfer;\n\tuhdr->endpoint_number = ep_num;\n\tpkth.caplen = sizeof(pcap_usb_header);\n\trawdata += sizeof(pcap_usb_header);\n\n\t/* check if this is a setup packet */\n\tret = sscanf(status, \"%d\", &dummy);\n\tif (ret != 1)\n\t{\n\t\t/* this a setup packet, setup data can be filled with underscore if\n\t\t* usbmon has not been able to read them, so we must parse this fields as\n\t\t* strings */\n\t\tpcap_usb_setup* shdr;\n\t\tchar str1[3], str2[3], str3[5], str4[5], str5[5];\n\t\tret = sscanf(string, \"%s %s %s %s %s%n\", str1, str2, str3, str4,\n\t\tstr5, &cnt);\n\t\tif (ret < 5)\n\t\t{\n\t\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\"Can't parse USB bus message '%s', too few tokens (expected 5 got %d)\",\n\t\t\t\tstring, ret);\n\t\t\treturn -1;\n\t\t}\n\t\tstring += cnt;\n\n\t\t/* try to convert to corresponding integer */\n\t\tshdr = &uhdr->setup;\n\t\tshdr->bmRequestType = strtoul(str1, 0, 16);\n\t\tshdr->bRequest = strtoul(str2, 0, 16);\n\t\tshdr->wValue = htols(strtoul(str3, 0, 16));\n\t\tshdr->wIndex = htols(strtoul(str4, 0, 16));\n\t\tshdr->wLength = htols(strtoul(str5, 0, 16));\n\n\t\tuhdr->setup_flag = 0;\n\t}\n\telse\n\t\tuhdr->setup_flag = 1;\n\n\t/* read urb data */\n\tret = sscanf(string, \" %d%n\", &urb_len, &cnt);\n\tif (ret < 1)\n\t{\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t  \"Can't parse urb length from '%s'\", string);\n\t\treturn -1;\n\t}\n\tstring += cnt;\n\n\t/* urb tag is not present if urb length is 0, so we can stop here\n\t * text parsing */\n\tpkth.len = urb_len+pkth.caplen;\n\tuhdr->urb_len = urb_len;\n\tuhdr->data_flag = 1;\n\tdata_len = 0;\n\tif (uhdr->urb_len == 0)\n\t\tgoto got;\n\n\t/* check for data presence; data is present if and only if urb tag is '=' */\n\tif (sscanf(string, \" %c\", &urb_tag) != 1)\n\t{\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\"Can't parse urb tag from '%s'\", string);\n\t\treturn -1;\n\t}\n\n\tif (urb_tag != '=')\n\t\tgoto got;\n\n\t/* skip urb tag and following space */\n\tstring += 3;\n\n\t/* if we reach this point we got some urb data*/\n\tuhdr->data_flag = 0;\n\n\t/* read all urb data; if urb length is greater then the usbmon internal\n\t * buffer length used by the kernel to spool the URB, we get only\n\t * a partial information.\n\t * At least until linux 2.6.17 there is no way to set usbmon intenal buffer\n\t * length and default value is 130. */\n\twhile ((string[0] != 0) && (string[1] != 0) && (pkth.caplen < (bpf_u_int32)handle->snapshot))\n\t{\n\t\trawdata[0] = ascii_to_int(string[0]) * 16 + ascii_to_int(string[1]);\n\t\trawdata++;\n\t\tstring+=2;\n\t\tif (string[0] == ' ')\n\t\t\tstring++;\n\t\tpkth.caplen++;\n\t\tdata_len++;\n\t}\n\ngot:\n\tuhdr->data_len = data_len;\n\tif (pkth.caplen > (bpf_u_int32)handle->snapshot)\n\t\tpkth.caplen = (bpf_u_int32)handle->snapshot;\n\n\tif (handle->fcode.bf_insns == NULL ||\n\t    pcap_filter(handle->fcode.bf_insns, handle->buffer,\n\t      pkth.len, pkth.caplen)) {\n\t\thandlep->packets_read++;\n\t\tcallback(user, &pkth, handle->buffer);\n\t\treturn 1;\n\t}\n\treturn 0;\t/* didn't pass filter */\n}",
          "fn_code_pos": [
            [
              727,
              0
            ],
            [
              923,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_read_linux",
            "parameters": {
              "handle": "pcap_t",
              "max_packets": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nusb_inject_linux(pcap_t *handle, const void *buf _U_, int size _U_)\n{\n\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t    \"Packet injection is not supported on USB devices\");\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              925,
              0
            ],
            [
              931,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_inject_linux",
            "parameters": {
              "handle": "pcap_t",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nusb_stats_linux(pcap_t *handle, struct pcap_stat *stats)\n{\n\tstruct pcap_usb_linux *handlep = handle->priv;\n\tint dummy, cnt;\n\tssize_t ret, consumed;\n\tchar string[USB_LINE_LEN];\n\tchar token[USB_LINE_LEN];\n\tchar * ptr = string;\n\tint fd;\n\n\tpcap_snprintf(string, USB_LINE_LEN, USB_TEXT_DIR\"/%ds\", handlep->bus_index);\n\tfd = open(string, O_RDONLY, 0);\n\tif (fd < 0)\n\t{\n\t\tif (errno == ENOENT)\n\t\t{\n\t\t\t/*\n\t\t\t * Not found at the new location; try the old\n\t\t\t * location.\n\t\t\t */\n\t\t\tpcap_snprintf(string, USB_LINE_LEN, USB_TEXT_DIR_OLD\"/%ds\", handlep->bus_index);\n\t\t\tfd = open(string, O_RDONLY, 0);\n\t\t}\n\t\tif (fd < 0) {\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t    \"Can't open USB stats file %s\", string);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* read stats line */\n\tdo {\n\t\tret = read(fd, string, USB_LINE_LEN-1);\n\t} while ((ret == -1) && (errno == EINTR));\n\tclose(fd);\n\n\tif (ret < 0)\n\t{\n\t\tpcap_snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\"Can't read stats from fd %d \", fd);\n\t\treturn -1;\n\t}\n\tstring[ret] = 0;\n\n\tstats->ps_recv = handlep->packets_read;\n\tstats->ps_drop = 0;\t/* unless we find text_lost */\n\tstats->ps_ifdrop = 0;\n\n\t/* extract info on dropped urbs */\n\tfor (consumed=0; consumed < ret; ) {\n\t\t/* from the sscanf man page:\n \t\t * The C standard says: \"Execution of a %n directive does\n \t\t * not increment the assignment count returned at the completion\n\t\t * of  execution\" but the Corrigendum seems to contradict this.\n\t\t * Do not make any assumptions on the effect of %n conversions\n\t\t * on the return value and explicitly check for cnt assignmet*/\n\t\tint ntok;\n\n\t\tcnt = -1;\n\t\tntok = sscanf(ptr, \"%s%n\", token, &cnt);\n\t\tif ((ntok < 1) || (cnt < 0))\n\t\t\tbreak;\n\t\tconsumed += cnt;\n\t\tptr += cnt;\n\t\tif (strcmp(token, \"text_lost\") == 0)\n\t\t\tntok = sscanf(ptr, \"%d%n\", &stats->ps_drop, &cnt);\n\t\telse\n\t\t\tntok = sscanf(ptr, \"%d%n\", &dummy, &cnt);\n\t\tif ((ntok != 1) || (cnt < 0))\n\t\t\tbreak;\n\t\tconsumed += cnt;\n\t\tptr += cnt;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              933,
              0
            ],
            [
              1010,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_stats_linux",
            "parameters": {
              "handle": "pcap_t",
              "stats": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nusb_setdirection_linux(pcap_t *p, pcap_direction_t d)\n{\n\tp->direction = d;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1012,
              0
            ],
            [
              1017,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_setdirection_linux",
            "parameters": {
              "p": "pcap_t",
              "d": "pcap_direction_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nusb_stats_linux_bin(pcap_t *handle, struct pcap_stat *stats)\n{\n\tstruct pcap_usb_linux *handlep = handle->priv;\n\tint ret;\n\tstruct mon_bin_stats st;\n\tret = ioctl(handle->fd, MON_IOCG_STATS, &st);\n\tif (ret < 0)\n\t{\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't read stats from fd %d\", handle->fd);\n\t\treturn -1;\n\t}\n\n\tstats->ps_recv = handlep->packets_read + st.queued;\n\tstats->ps_drop = st.dropped;\n\tstats->ps_ifdrop = 0;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1020,
              0
            ],
            [
              1038,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_stats_linux_bin",
            "parameters": {
              "handle": "pcap_t",
              "stats": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nusb_read_linux_bin(pcap_t *handle, int max_packets _U_, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_usb_linux *handlep = handle->priv;\n\tstruct mon_bin_get info;\n\tint ret;\n\tstruct pcap_pkthdr pkth;\n\tu_int clen = handle->snapshot - sizeof(pcap_usb_header);\n\n\t/* the usb header is going to be part of 'packet' data*/\n\tinfo.hdr = (pcap_usb_header*) handle->buffer;\n\tinfo.data = (u_char *)handle->buffer + sizeof(pcap_usb_header);\n\tinfo.data_len = clen;\n\n\t/* ignore interrupt system call errors */\n\tdo {\n\t\tret = ioctl(handle->fd, MON_IOCX_GET, &info);\n\t\tif (handle->break_loop)\n\t\t{\n\t\t\thandle->break_loop = 0;\n\t\t\treturn -2;\n\t\t}\n\t} while ((ret == -1) && (errno == EINTR));\n\tif (ret < 0)\n\t{\n\t\tif (errno == EAGAIN)\n\t\t\treturn 0;\t/* no data there */\n\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't read from fd %d\", handle->fd);\n\t\treturn -1;\n\t}\n\n\t/* we can get less that than really captured from kernel, depending on\n\t * snaplen, so adjust header accordingly */\n\tif (info.hdr->data_len < clen)\n\t\tclen = info.hdr->data_len;\n\tinfo.hdr->data_len = clen;\n\tpkth.caplen = clen + sizeof(pcap_usb_header);\n\tpkth.len = info.hdr->data_len + sizeof(pcap_usb_header);\n\tpkth.ts.tv_sec = info.hdr->ts_sec;\n\tpkth.ts.tv_usec = info.hdr->ts_usec;\n\n\tif (handle->fcode.bf_insns == NULL ||\n\t    pcap_filter(handle->fcode.bf_insns, handle->buffer,\n\t      pkth.len, pkth.caplen)) {\n\t\thandlep->packets_read++;\n\t\tcallback(user, &pkth, handle->buffer);\n\t\treturn 1;\n\t}\n\n\treturn 0;\t/* didn't pass filter */\n}",
          "fn_code_pos": [
            [
              1044,
              0
            ],
            [
              1096,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_read_linux_bin",
            "parameters": {
              "handle": "pcap_t",
              "max_packets": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nusb_read_linux_mmap(pcap_t *handle, int max_packets, pcap_handler callback, u_char *user)\n{\n\tstruct pcap_usb_linux *handlep = handle->priv;\n\tstruct mon_bin_mfetch fetch;\n\tint32_t vec[VEC_SIZE];\n\tstruct pcap_pkthdr pkth;\n\tpcap_usb_header* hdr;\n\tint nflush = 0;\n\tint packets = 0;\n\tu_int clen, max_clen;\n\n\tmax_clen = handle->snapshot - sizeof(pcap_usb_header);\n\n\tfor (;;) {\n\t\tint i, ret;\n\t\tint limit = max_packets - packets;\n\t\tif (limit <= 0)\n\t\t\tlimit = VEC_SIZE;\n\t\tif (limit > VEC_SIZE)\n\t\t\tlimit = VEC_SIZE;\n\n\t\t/* try to fetch as many events as possible*/\n\t\tfetch.offvec = vec;\n\t\tfetch.nfetch = limit;\n\t\tfetch.nflush = nflush;\n\t\t/* ignore interrupt system call errors */\n\t\tdo {\n\t\t\tret = ioctl(handle->fd, MON_IOCX_MFETCH, &fetch);\n\t\t\tif (handle->break_loop)\n\t\t\t{\n\t\t\t\thandle->break_loop = 0;\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t} while ((ret == -1) && (errno == EINTR));\n\t\tif (ret < 0)\n\t\t{\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn 0;\t/* no data there */\n\n\t\t\tpcap_fmt_errmsg_for_errno(handle->errbuf,\n\t\t\t    PCAP_ERRBUF_SIZE, errno, \"Can't mfetch fd %d\",\n\t\t\t    handle->fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* keep track of processed events, we will flush them later */\n\t\tnflush = fetch.nfetch;\n\t\tfor (i=0; i<fetch.nfetch; ++i) {\n\t\t\t/* discard filler */\n\t\t\thdr = (pcap_usb_header*) &handlep->mmapbuf[vec[i]];\n\t\t\tif (hdr->event_type == '@')\n\t\t\t\tcontinue;\n\n\t\t\t/* we can get less that than really captured from kernel, depending on\n\t \t\t* snaplen, so adjust header accordingly */\n\t\t\tclen = max_clen;\n\t\t\tif (hdr->data_len < clen)\n\t\t\t\tclen = hdr->data_len;\n\n\t\t\t/* get packet info from header*/\n\t\t\tpkth.caplen = clen + sizeof(pcap_usb_header_mmapped);\n\t\t\tpkth.len = hdr->data_len + sizeof(pcap_usb_header_mmapped);\n\t\t\tpkth.ts.tv_sec = hdr->ts_sec;\n\t\t\tpkth.ts.tv_usec = hdr->ts_usec;\n\n\t\t\tif (handle->fcode.bf_insns == NULL ||\n\t\t\t    pcap_filter(handle->fcode.bf_insns, (u_char*) hdr,\n\t\t\t      pkth.len, pkth.caplen)) {\n\t\t\t\thandlep->packets_read++;\n\t\t\t\tcallback(user, &pkth, (u_char*) hdr);\n\t\t\t\tpackets++;\n\t\t\t}\n\t\t}\n\n\t\t/* with max_packets specifying \"unlimited\" we stop afer the first chunk*/\n\t\tif (PACKET_COUNT_IS_UNLIMITED(max_packets) || (packets == max_packets))\n\t\t\tbreak;\n\t}\n\n\t/* flush pending events*/\n\tif (ioctl(handle->fd, MON_IOCH_MFLUSH, nflush) == -1) {\n\t\tpcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"Can't mflush fd %d\", handle->fd);\n\t\treturn -1;\n\t}\n\treturn packets;\n}",
          "fn_code_pos": [
            [
              1103,
              0
            ],
            [
              1190,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_read_linux_mmap",
            "parameters": {
              "handle": "pcap_t",
              "max_packets": "int",
              "callback": "pcap_handler",
              "user": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusb_cleanup_linux_mmap(pcap_t* handle)\n{\n\tstruct pcap_usb_linux *handlep = handle->priv;\n\n\t/* if we have a memory-mapped buffer, unmap it */\n\tif (handlep->mmapbuf != NULL) {\n\t\tmunmap(handlep->mmapbuf, handlep->mmapbuflen);\n\t\thandlep->mmapbuf = NULL;\n\t}\n\tpcap_cleanup_live_common(handle);\n}",
          "fn_code_pos": [
            [
              1192,
              0
            ],
            [
              1203,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_cleanup_linux_mmap",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "usb_activate(pcap_t *)",
          "fn_dec_pos": [
            [
              132,
              11
            ],
            [
              132,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_activate",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "usb_stats_linux(pcap_t *, struct pcap_stat *)",
          "fn_dec_pos": [
            [
              133,
              11
            ],
            [
              133,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_stats_linux",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "usb_stats_linux_bin(pcap_t *, struct pcap_stat *)",
          "fn_dec_pos": [
            [
              134,
              11
            ],
            [
              134,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_stats_linux_bin",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "usb_read_linux(pcap_t *, int , pcap_handler , u_char *)",
          "fn_dec_pos": [
            [
              135,
              11
            ],
            [
              135,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_read_linux",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "usb_read_linux_bin(pcap_t *, int , pcap_handler , u_char *)",
          "fn_dec_pos": [
            [
              136,
              11
            ],
            [
              136,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_read_linux_bin",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "usb_read_linux_mmap(pcap_t *, int , pcap_handler , u_char *)",
          "fn_dec_pos": [
            [
              137,
              11
            ],
            [
              137,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_read_linux_mmap",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "usb_inject_linux(pcap_t *, const void *, int)",
          "fn_dec_pos": [
            [
              138,
              11
            ],
            [
              138,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_inject_linux",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "usb_setdirection_linux(pcap_t *, pcap_direction_t)",
          "fn_dec_pos": [
            [
              139,
              11
            ],
            [
              139,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_setdirection_linux",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "usb_cleanup_linux_mmap(pcap_t *)",
          "fn_dec_pos": [
            [
              140,
              12
            ],
            [
              140,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_cleanup_linux_mmap",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "usb_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              470,
              0
            ],
            [
              470,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct mon_bin_stats {\n\tuint32_t queued;\n\tuint32_t dropped;\n}",
          {
            "queued": "uint32_t",
            "dropped": "uint32_t"
          },
          "mon_bin_stats",
          [
            88,
            0
          ],
          [
            91,
            1
          ]
        ],
        [
          "struct mon_bin_get {\n\tpcap_usb_header *hdr;\n\tvoid *data;\n\tsize_t data_len;   /* Length of data (can be zero) */\n}",
          {
            "*hdr": "pcap_usb_header",
            "*data": "void",
            "data_len": "size_t"
          },
          "mon_bin_get",
          [
            93,
            0
          ],
          [
            97,
            1
          ]
        ],
        [
          "struct mon_bin_mfetch {\n\tint32_t *offvec;   /* Vector of events fetched */\n\tint32_t nfetch;    /* Number of events to fetch (out: fetched) */\n\tint32_t nflush;    /* Number of events to flush */\n}",
          {
            "*offvec": "int32_t",
            "nfetch": "int32_t",
            "nflush": "int32_t"
          },
          "mon_bin_mfetch",
          [
            99,
            0
          ],
          [
            103,
            1
          ]
        ],
        [
          "struct pcap_usb_linux {\n\tu_char *mmapbuf;\t/* memory-mapped region pointer */\n\tsize_t mmapbuflen;\t/* size of region */\n\tint bus_index;\n\tu_int packets_read;\n}",
          {
            "*mmapbuf": "u_char",
            "mmapbuflen": "size_t",
            "bus_index": "int",
            "packets_read": "u_int"
          },
          "pcap_usb_linux",
          [
            124,
            0
          ],
          [
            129,
            1
          ]
        ],
        [
          "struct mon_bin_stats {\n\tuint32_t queued;\n\tuint32_t dropped;\n}",
          {
            "queued": "uint32_t",
            "dropped": "uint32_t"
          },
          "mon_bin_stats",
          [
            88,
            0
          ],
          [
            91,
            1
          ]
        ],
        [
          "struct mon_bin_get {\n\tpcap_usb_header *hdr;\n\tvoid *data;\n\tsize_t data_len;   /* Length of data (can be zero) */\n}",
          {
            "*hdr": "pcap_usb_header",
            "*data": "void",
            "data_len": "size_t"
          },
          "mon_bin_get",
          [
            93,
            0
          ],
          [
            97,
            1
          ]
        ],
        [
          "struct mon_bin_mfetch {\n\tint32_t *offvec;   /* Vector of events fetched */\n\tint32_t nfetch;    /* Number of events to fetch (out: fetched) */\n\tint32_t nflush;    /* Number of events to flush */\n}",
          {
            "*offvec": "int32_t",
            "nfetch": "int32_t",
            "nflush": "int32_t"
          },
          "mon_bin_mfetch",
          [
            99,
            0
          ],
          [
            103,
            1
          ]
        ],
        [
          "struct pcap_usb_linux {\n\tu_char *mmapbuf;\t/* memory-mapped region pointer */\n\tsize_t mmapbuflen;\t/* size of region */\n\tint bus_index;\n\tu_int packets_read;\n}",
          {
            "*mmapbuf": "u_char",
            "mmapbuflen": "size_t",
            "bus_index": "int",
            "packets_read": "u_int"
          },
          "pcap_usb_linux",
          [
            124,
            0
          ],
          [
            129,
            1
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            133,
            37
          ],
          [
            133,
            53
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            134,
            41
          ],
          [
            134,
            57
          ]
        ],
        [
          "struct utsname",
          {},
          "",
          [
            145,
            1
          ],
          [
            145,
            15
          ]
        ],
        [
          "struct dirent",
          {},
          "",
          [
            267,
            1
          ],
          [
            267,
            14
          ]
        ],
        [
          "struct pcap_usb_linux",
          {},
          "",
          [
            386,
            1
          ],
          [
            386,
            22
          ]
        ],
        [
          "struct usbdevfs_ctrltransfer",
          {},
          "",
          [
            416,
            1
          ],
          [
            416,
            29
          ]
        ],
        [
          "struct dirent",
          {},
          "",
          [
            417,
            1
          ],
          [
            417,
            14
          ]
        ],
        [
          "struct pcap_usb_linux",
          {},
          "",
          [
            504,
            38
          ],
          [
            504,
            59
          ]
        ],
        [
          "struct pcap_usb_linux",
          {},
          "",
          [
            515,
            1
          ],
          [
            515,
            22
          ]
        ],
        [
          "struct pcap_usb_linux",
          {},
          "",
          [
            734,
            1
          ],
          [
            734,
            22
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            741,
            1
          ],
          [
            741,
            19
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            934,
            32
          ],
          [
            934,
            48
          ]
        ],
        [
          "struct pcap_usb_linux",
          {},
          "",
          [
            936,
            1
          ],
          [
            936,
            22
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            1021,
            36
          ],
          [
            1021,
            52
          ]
        ],
        [
          "struct pcap_usb_linux",
          {},
          "",
          [
            1023,
            1
          ],
          [
            1023,
            22
          ]
        ],
        [
          "struct mon_bin_stats",
          {},
          "",
          [
            1025,
            1
          ],
          [
            1025,
            21
          ]
        ],
        [
          "struct pcap_usb_linux",
          {},
          "",
          [
            1047,
            1
          ],
          [
            1047,
            22
          ]
        ],
        [
          "struct mon_bin_get",
          {},
          "",
          [
            1048,
            1
          ],
          [
            1048,
            19
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            1050,
            1
          ],
          [
            1050,
            19
          ]
        ],
        [
          "struct pcap_usb_linux",
          {},
          "",
          [
            1106,
            1
          ],
          [
            1106,
            22
          ]
        ],
        [
          "struct mon_bin_mfetch",
          {},
          "",
          [
            1107,
            1
          ],
          [
            1107,
            22
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            1109,
            1
          ],
          [
            1109,
            19
          ]
        ],
        [
          "struct pcap_usb_linux",
          {},
          "",
          [
            1195,
            1
          ],
          [
            1195,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include \"pcap-usb-linux.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"pcap/usb.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include \"strerror.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <dirent.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <byteswap.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include <sys/ioctl.h>\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#include <sys/mman.h>\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include <sys/utsname.h>\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ],
        [
          "#include <linux/compiler.h>\n",
          [
            66,
            0
          ],
          [
            67,
            0
          ]
        ],
        [
          "#include <linux/usbdevice_fs.h>\n",
          [
            68,
            0
          ],
          [
            69,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-new.c": {
      "fn_def_list": [
        {
          "fn_code": "int pcap_findalldevs_ex(const char *source, struct pcap_rmtauth *auth, pcap_if_t **alldevs, char *errbuf)\n{\n\tint type;\n\tchar name[PCAP_BUF_SIZE], path[PCAP_BUF_SIZE], filename[PCAP_BUF_SIZE];\n\tsize_t pathlen;\n\tsize_t stringlen;\n\tpcap_t *fp;\n\tchar tmpstring[PCAP_BUF_SIZE + 1];\t\t/* Needed to convert names and descriptions from 'old' syntax to the 'new' one */\n\tpcap_if_t *lastdev;\t/* Last device in the pcap_if_t list */\n\tpcap_if_t *dev;\t\t/* Device we're adding to the pcap_if_t list */\n\n\t/* List starts out empty. */\n\t(*alldevs) = NULL;\n\tlastdev = NULL;\n\n\tif (strlen(source) > PCAP_BUF_SIZE)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"The source string is too long. Cannot handle it correctly.\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Determine the type of the source (file, local, remote)\n\t * There are some differences if pcap_findalldevs_ex() is called to list files and remote adapters.\n\t * In the first case, the name of the directory we have to look into must be present (therefore\n\t * the 'name' parameter of the pcap_parsesrcstr() is present).\n\t * In the second case, the name of the adapter is not required (we need just the host). So, we have\n\t * to use a first time this function to get the source type, and a second time to get the appropriate\n\t * info, which depends on the source type.\n\t */\n\tif (pcap_parsesrcstr(source, &type, NULL, NULL, NULL, errbuf) == -1)\n\t\treturn -1;\n\n\tswitch (type)\n\t{\n\tcase PCAP_SRC_IFLOCAL:\n\t\tif (pcap_parsesrcstr(source, &type, NULL, NULL, NULL, errbuf) == -1)\n\t\t\treturn -1;\n\n\t\t/* Initialize temporary string */\n\t\ttmpstring[PCAP_BUF_SIZE] = 0;\n\n\t\t/* The user wants to retrieve adapters from a local host */\n\t\tif (pcap_findalldevs(alldevs, errbuf) == -1)\n\t\t\treturn -1;\n\n\t\tif (*alldevs == NULL)\n\t\t{\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\"No interfaces found! Make sure libpcap/WinPcap is properly installed\"\n\t\t\t\t\" on the local machine.\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Scan all the interfaces and modify name and description */\n\t\t/* This is a trick in order to avoid the re-implementation of the pcap_findalldevs here */\n\t\tdev = *alldevs;\n\t\twhile (dev)\n\t\t{\n\t\t\tchar *localdesc, *desc;\n\n\t\t\t/* Create the new device identifier */\n\t\t\tif (pcap_createsrcstr(tmpstring, PCAP_SRC_IFLOCAL, NULL, NULL, dev->name, errbuf) == -1)\n\t\t\t\treturn -1;\n\n\t\t\t/* Delete the old pointer */\n\t\t\tfree(dev->name);\n\n\t\t\t/* Make a copy of the new device identifier */\n\t\t\tdev->name = strdup(tmpstring);\n\t\t\tif (dev->name == NULL)\n\t\t\t{\n\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"malloc() failed\");\n\t\t\t\tpcap_freealldevs(*alldevs);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Create the description.\n\t\t\t */\n\t\t\tif ((dev->description == NULL) || (dev->description[0] == 0))\n\t\t\t\tlocaldesc = dev->name;\n\t\t\telse\n\t\t\t\tlocaldesc = dev->description;\n\t\t\tif (pcap_asprintf(&desc, \"%s '%s' %s\",\n\t\t\t    PCAP_TEXT_SOURCE_ADAPTER, localdesc,\n\t\t\t    PCAP_TEXT_SOURCE_ON_LOCAL_HOST) == -1)\n\t\t\t{\n\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t    \"malloc() failed\");\n\t\t\t\tpcap_freealldevs(*alldevs);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t/* Now overwrite the description */\n\t\t\tfree(dev->description);\n\t\t\tdev->description = desc;\n\n\t\t\tdev = dev->next;\n\t\t}\n\n\t\treturn 0;\n\n\tcase PCAP_SRC_FILE:\n\t{\n#ifdef _WIN32\n\t\tWIN32_FIND_DATA filedata;\n\t\tHANDLE filehandle;\n#else\n\t\tstruct dirent *filedata;\n\t\tDIR *unixdir;\n#endif\n\n\t\tif (pcap_parsesrcstr(source, &type, NULL, NULL, name, errbuf) == -1)\n\t\t\treturn -1;\n\n\t\t/* Check that the filename is correct */\n\t\tstringlen = strlen(name);\n\n\t\t/* The directory must end with '\\' in Win32 and '/' in UNIX */\n#ifdef _WIN32\n#define ENDING_CHAR '\\\\'\n#else\n#define ENDING_CHAR '/'\n#endif\n\n\t\tif (name[stringlen - 1] != ENDING_CHAR)\n\t\t{\n\t\t\tname[stringlen] = ENDING_CHAR;\n\t\t\tname[stringlen + 1] = 0;\n\n\t\t\tstringlen++;\n\t\t}\n\n\t\t/* Save the path for future reference */\n\t\tpcap_snprintf(path, sizeof(path), \"%s\", name);\n\t\tpathlen = strlen(path);\n\n#ifdef _WIN32\n\t\t/* To perform directory listing, Win32 must have an 'asterisk' as ending char */\n\t\tif (name[stringlen - 1] != '*')\n\t\t{\n\t\t\tname[stringlen] = '*';\n\t\t\tname[stringlen + 1] = 0;\n\t\t}\n\n\t\tfilehandle = FindFirstFile(name, &filedata);\n\n\t\tif (filehandle == INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Error when listing files: does folder '%s' exist?\", path);\n\t\t\treturn -1;\n\t\t}\n\n#else\n\t\t/* opening the folder */\n\t\tunixdir= opendir(path);\n\n\t\t/* get the first file into it */\n\t\tfiledata= readdir(unixdir);\n\n\t\tif (filedata == NULL)\n\t\t{\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Error when listing files: does folder '%s' exist?\", path);\n\t\t\treturn -1;\n\t\t}\n#endif\n\n\t\t/* Add all files we find to the list. */\n\t\tdo\n\t\t{\n#ifdef _WIN32\n\t\t\t/* Skip the file if the pathname won't fit in the buffer */\n\t\t\tif (pathlen + strlen(filedata.cFileName) >= sizeof(filename))\n\t\t\t\tcontinue;\n\t\t\tpcap_snprintf(filename, sizeof(filename), \"%s%s\", path, filedata.cFileName);\n#else\n\t\t\tif (pathlen + strlen(filedata->d_name) >= sizeof(filename))\n\t\t\t\tcontinue;\n\t\t\tpcap_snprintf(filename, sizeof(filename), \"%s%s\", path, filedata->d_name);\n#endif\n\n\t\t\tfp = pcap_open_offline(filename, errbuf);\n\n\t\t\tif (fp)\n\t\t\t{\n\t\t\t\t/* allocate the main structure */\n\t\t\t\tdev = (pcap_if_t *)malloc(sizeof(pcap_if_t));\n\t\t\t\tif (dev == NULL)\n\t\t\t\t{\n\t\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"malloc() failed\");\n\t\t\t\t\tpcap_freealldevs(*alldevs);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\t/* Initialize the structure to 'zero' */\n\t\t\t\tmemset(dev, 0, sizeof(pcap_if_t));\n\n\t\t\t\t/* Append it to the list. */\n\t\t\t\tif (lastdev == NULL)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * List is empty, so it's also\n\t\t\t\t\t * the first device.\n\t\t\t\t\t */\n\t\t\t\t\t*alldevs = dev;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * Append after the last device.\n\t\t\t\t\t */\n\t\t\t\t\tlastdev->next = dev;\n\t\t\t\t}\n\t\t\t\t/* It's now the last device. */\n\t\t\t\tlastdev = dev;\n\n\t\t\t\t/* Create the new source identifier */\n\t\t\t\tif (pcap_createsrcstr(tmpstring, PCAP_SRC_FILE, NULL, NULL, filename, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\tpcap_freealldevs(*alldevs);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tdev->name = strdup(tmpstring);\n\t\t\t\tif (dev->name == NULL)\n\t\t\t\t{\n\t\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"malloc() failed\");\n\t\t\t\t\tpcap_freealldevs(*alldevs);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Create the description.\n\t\t\t\t */\n\t\t\t\tif (pcap_asprintf(&dev->description,\n\t\t\t\t    \"%s '%s' %s\", PCAP_TEXT_SOURCE_FILE,\n\t\t\t\t    filename, PCAP_TEXT_SOURCE_ON_LOCAL_HOST) == -1)\n\t\t\t\t{\n\t\t\t\t\tpcap_fmt_errmsg_for_errno(errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE, errno,\n\t\t\t\t\t    \"malloc() failed\");\n\t\t\t\t\tpcap_freealldevs(*alldevs);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tpcap_close(fp);\n\t\t\t}\n\t\t}\n#ifdef _WIN32\n\t\twhile (FindNextFile(filehandle, &filedata) != 0);\n#else\n\t\twhile ( (filedata= readdir(unixdir)) != NULL);\n#endif\n\n\n#ifdef _WIN32\n\t\t/* Close the search handle. */\n\t\tFindClose(filehandle);\n#endif\n\n\t\treturn 0;\n\t}\n\n\tcase PCAP_SRC_IFREMOTE:\n\t\treturn pcap_findalldevs_ex_remote(source, auth, alldevs, errbuf);\n\n\tdefault:\n\t\tpcap_strlcpy(errbuf, \"Source type not supported\", PCAP_ERRBUF_SIZE);\n\t\treturn -1;\n\t}\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              349,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_findalldevs_ex",
            "parameters": {
              "source": "char",
              "auth": "struct pcap_rmtauth",
              "alldevs": "pcap_if_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *pcap_open(const char *source, int snaplen, int flags, int read_timeout, struct pcap_rmtauth *auth, char *errbuf)\n{\n\tchar name[PCAP_BUF_SIZE];\n\tint type;\n\tpcap_t *fp;\n\tint status;\n\n\tif (strlen(source) > PCAP_BUF_SIZE)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"The source string is too long. Cannot handle it correctly.\");\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Determine the type of the source (file, local, remote) and,\n\t * if it's file or local, the name of the file or capture device.\n\t */\n\tif (pcap_parsesrcstr(source, &type, NULL, NULL, name, errbuf) == -1)\n\t\treturn NULL;\n\n\tswitch (type)\n\t{\n\tcase PCAP_SRC_FILE:\n\t\treturn pcap_open_offline(name, errbuf);\n\n\tcase PCAP_SRC_IFLOCAL:\n\t\tfp = pcap_create(name, errbuf);\n\t\tbreak;\n\n\tcase PCAP_SRC_IFREMOTE:\n\t\t/*\n\t\t * Although we already have host, port and iface, we prefer\n\t\t * to pass only 'source' to pcap_open_rpcap(), so that it\n\t\t * has to call pcap_parsesrcstr() again.\n\t\t * This is less optimized, but much clearer.\n\t\t */\n\t\treturn pcap_open_rpcap(source, snaplen, flags, read_timeout, auth, errbuf);\n\n\tdefault:\n\t\tpcap_strlcpy(errbuf, \"Source type not supported\", PCAP_ERRBUF_SIZE);\n\t\treturn NULL;\n\t}\n\n\tif (fp == NULL)\n\t\treturn (NULL);\n\tstatus = pcap_set_snaplen(fp, snaplen);\n\tif (status < 0)\n\t\tgoto fail;\n\tif (flags & PCAP_OPENFLAG_PROMISCUOUS)\n\t{\n\t\tstatus = pcap_set_promisc(fp, 1);\n\t\tif (status < 0)\n\t\t\tgoto fail;\n\t}\n\tif (flags & PCAP_OPENFLAG_MAX_RESPONSIVENESS)\n\t{\n\t\tstatus = pcap_set_immediate_mode(fp, 1);\n\t\tif (status < 0)\n\t\t\tgoto fail;\n\t}\n#ifdef _WIN32\n\t/*\n\t * This flag is supported on Windows only.\n\t * XXX - is there a way to support it with\n\t * the capture mechanisms on UN*X?  It's not\n\t * exactly a \"set direction\" operation; I\n\t * think it means \"do not capture packets\n\t * injected with pcap_sendpacket() or\n\t * pcap_inject()\".\n\t */\n\t/* disable loopback capture if requested */\n\tif (flags & PCAP_OPENFLAG_NOCAPTURE_LOCAL)\n\t\tfp->opt.nocapture_local = 1;\n#endif /* _WIN32 */\n\tstatus = pcap_set_timeout(fp, read_timeout);\n\tif (status < 0)\n\t\tgoto fail;\n\tstatus = pcap_activate(fp);\n\tif (status < 0)\n\t\tgoto fail;\n\treturn fp;\n\nfail:\n\tif (status == PCAP_ERROR)\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"%s: %s\",\n\t\t    name, fp->errbuf);\n\telse if (status == PCAP_ERROR_NO_SUCH_DEVICE ||\n\t    status == PCAP_ERROR_PERM_DENIED ||\n\t    status == PCAP_ERROR_PROMISC_PERM_DENIED)\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"%s: %s (%s)\",\n\t\t    name, pcap_statustostr(status), fp->errbuf);\n\telse\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"%s: %s\",\n\t\t    name, pcap_statustostr(status));\n\tpcap_close(fp);\n\treturn NULL;\n}",
          "fn_code_pos": [
            [
              351,
              0
            ],
            [
              447,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open",
            "parameters": {
              "source": "char",
              "snaplen": "int",
              "flags": "int",
              "read_timeout": "int",
              "auth": "struct pcap_rmtauth",
              "errbuf": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "struct pcap_samp *pcap_setsampling(pcap_t *p)\n{\n\treturn &p->rmt_samp;\n}",
          "fn_code_pos": [
            [
              449,
              0
            ],
            [
              452,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setsampling",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "pcap_open(const char *source, int snaplen, int flags, int read_timeout, struct pcap_rmtauth *auth, char *errbuf)",
          "fn_dec_pos": [
            [
              351,
              8
            ],
            [
              351,
              120
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open",
            "parameters": {
              "source": "char",
              "snaplen": "int",
              "flags": "int",
              "read_timeout": "int",
              "auth": "struct pcap_rmtauth",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_setsampling(pcap_t *p)",
          "fn_dec_pos": [
            [
              449,
              18
            ],
            [
              449,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setsampling",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_rmtauth",
          {},
          "",
          [
            71,
            44
          ],
          [
            71,
            63
          ]
        ],
        [
          "struct dirent",
          {},
          "",
          [
            183,
            2
          ],
          [
            183,
            15
          ]
        ],
        [
          "struct pcap_rmtauth",
          {},
          "",
          [
            351,
            80
          ],
          [
            351,
            99
          ]
        ],
        [
          "struct pcap_samp",
          {},
          "",
          [
            449,
            0
          ],
          [
            449,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include \"sockutils.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\t// for the details of the pcap_t structure\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include \"pcap-rpcap.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"rpcap-protocol.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <errno.h>\t\t// for the errno variable\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <stdlib.h>\t\t// for malloc(), free(), ...\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <string.h>\t\t// for strstr, etc\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <dirent.h>\t\t// for readdir\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/fmtutils.c": {
      "fn_def_list": [
        {
          "fn_code": "void\npcap_fmt_errmsg_for_errno(char *errbuf, size_t errbuflen, int errnum,\n    const char *fmt, ...)\n{\n\tva_list ap;\n\tsize_t msglen;\n\tchar *p;\n\tsize_t errbuflen_remaining;\n#if defined(HAVE_STRERROR_S)\n\terrno_t err;\n#elif defined(HAVE_STRERROR_R)\n\tint err;\n#endif\n\n\tva_start(ap, fmt);\n\tpcap_vsnprintf(errbuf, errbuflen, fmt, ap);\n\tva_end(ap);\n\tmsglen = strlen(errbuf);\n\n\t/*\n\t * Do we have enough space to append \": \"?\n\t * Including the terminating '\\0', that's 3 bytes.\n\t */\n\tif (msglen + 3 > errbuflen) {\n\t\t/* No - just give them what we've produced. */\n\t\treturn;\n\t}\n\tp = errbuf + msglen;\n\terrbuflen_remaining = errbuflen - msglen;\n\t*p++ = ':';\n\t*p++ = ' ';\n\t*p = '\\0';\n\tmsglen += 2;\n\terrbuflen_remaining -= 2;\n\n\t/*\n\t * Now append the string for the error code.\n\t */\n#if defined(HAVE_STRERROR_S)\n\terr = strerror_s(p, errbuflen_remaining, errnum);\n\tif (err != 0) {\n\t\t/*\n\t\t * It doesn't appear to be documented anywhere obvious\n\t\t * what the error returns from strerror_s().\n\t\t */\n\t\tpcap_snprintf(p, errbuflen_remaining, \"Error %d\", errnum);\n\t}\n#elif defined(HAVE_STRERROR_R)\n\terr = strerror_r(errnum, p, errbuflen_remaining);\n\tif (err == EINVAL) {\n\t\t/*\n\t\t * UNIX 03 says this isn't guaranteed to produce a\n\t\t * fallback error message.\n\t\t */\n\t\tpcap_snprintf(p, errbuflen_remaining, \"Unknown error: %d\",\n\t\t    errnum);\n\t} else if (err == ERANGE) {\n\t\t/*\n\t\t * UNIX 03 says this isn't guaranteed to produce a\n\t\t * fallback error message.\n\t\t */\n\t\tpcap_snprintf(p, errbuflen_remaining,\n\t\t    \"Message for error %d is too long\", errnum);\n\t}\n#else\n\t/*\n\t * We have neither strerror_s() nor strerror_r(), so we're\n\t * stuck with using pcap_strerror().\n\t */\n\tpcap_snprintf(p, errbuflen_remaining, \"%s\", pcap_strerror(errnum));\n#endif\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_fmt_errmsg_for_errno",
            "parameters": {
              "errbuf": "char",
              "errbuflen": "size_t",
              "errnum": "int",
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\npcap_win32_err_to_str(DWORD error, char *errbuf)\n{\n\tDWORD retval;\n\tsize_t errlen;\n\tchar *p;\n\n\t/*\n\t * XXX - what language ID to use?\n\t *\n\t * For UN*Xes, pcap_strerror() may or may not return localized\n\t * strings.\n\t *\n\t * We currently don't have localized messages for libpcap, but\n\t * we might want to do so.  On the other hand, if most of these\n\t * messages are going to be read by libpcap developers and\n\t * perhaps by developers of libpcap-based applications, English\n\t * might be a better choice, so the developer doesn't have to\n\t * get the message translated if it's in a language they don't\n\t * happen to understand.\n\t */\n\tretval = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_MAX_WIDTH_MASK,\n\t    NULL, error, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n\t    errbuf, PCAP_ERRBUF_SIZE, NULL);\n\tif (retval == 0) {\n\t\t/*\n\t\t * Failed.\n\t\t */\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Couldn't get error message for error (%lu)\", error);\n\t\treturn;\n\t}\n\n\t/*\n\t * \"FormatMessage()\" \"helpfully\" sticks CR/LF at the end of the\n\t * message.  Get rid of it.\n\t *\n\t * XXX - still true with FORMAT_MESSAGE_MAX_WIDTH_MASK?\n\t */\n\terrlen = strlen(errbuf);\n\tif (errlen >= 2 &&\n\t    errbuf[errlen - 2] == '\\r' && errbuf[errlen - 1] == '\\n') {\n\t\terrbuf[errlen - 2] = '\\0';\n\t\terrbuf[errlen - 1] = '\\0';\n\t}\n\tp = strchr(errbuf, '\\0');\n\tpcap_snprintf(p, PCAP_ERRBUF_SIZE+1-(p-errbuf), \" (%lu)\", error);\n}",
          "fn_code_pos": [
            [
              138,
              0
            ],
            [
              185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_win32_err_to_str",
            "parameters": {
              "error": "DWORD",
              "errbuf": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include \"ftmacros.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <stddef.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <pcap/pcap.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include \"fmtutils.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/msdos/bin2c.c": {
      "fn_def_list": [
        {
          "fn_code": "static void Abort (const char *fmt,...)\n{\n  va_list args;\n  va_start (args, fmt);\n  vfprintf (stderr, fmt, args);\n  va_end (args);\n  exit (1);\n}",
          "fn_code_pos": [
            [
              5,
              0
            ],
            [
              12,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Abort",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main (int argc, char **argv)\n{\n  FILE  *inFile;\n  FILE  *outFile = stdout;\n  time_t now     = time (NULL);\n  int    ch, i;\n\n  if (argc != 2)\n     Abort (\"Usage: %s bin-file [> result]\", argv[0]);\n\n  if ((inFile = fopen(argv[1],\"rb\")) == NULL)\n     Abort (\"Cannot open %s\\n\", argv[1]);\n\n  fprintf (outFile,\n           \"/* data statements for file %s at %.24s */\\n\"\n           \"/* Generated by BIN2C, G. Vanem 1995 */\\n\",\n           argv[1], ctime(&now));\n\n  i = 0;\n  while ((ch = fgetc(inFile)) != EOF)\n  {\n    if (i++ % 12 == 0)\n       fputs (\"\\n  \", outFile);\n    fprintf (outFile, \"0x%02X,\", ch);\n  }\n  fputc ('\\n', outFile);\n  fclose (inFile);\n  return (0);\n}",
          "fn_code_pos": [
            [
              14,
              0
            ],
            [
              42,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ],
        [
          "#include <time.h>\n",
          [
            3,
            0
          ],
          [
            4,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/msdos/pktdrvr.c": {
      "fn_def_list": [
        {
          "fn_code": "LOCAL  struct {             /* internal statistics */\n       DWORD  tooSmall;     /* size < ETH_MIN */\n       DWORD  tooLarge;     /* size > ETH_MAX */\n       DWORD  badSync;      /* count_1 != count_2 */\n       DWORD  wrongHandle;  /* upcall to wrong handle */\n     }",
          "fn_code_pos": [
            [
              206,
              0
            ],
            [
              211,
              6
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "LOCAL"
          }
        },
        {
          "fn_code": "PUBLIC const char *PktGetErrorStr (int errNum)\n{\n  static const char *errStr[] = {\n                    \"\",\n                    \"Invalid handle number\",\n                    \"No interfaces of specified class found\",\n                    \"No interfaces of specified type found\",\n                    \"No interfaces of specified number found\",\n                    \"Bad packet type specified\",\n                    \"Interface does not support multicast\",\n                    \"Packet driver cannot terminate\",\n                    \"Invalid receiver mode specified\",\n                    \"Insufficient memory space\",\n                    \"Type previously accessed, and not released\",\n                    \"Command out of range, or not implemented\",\n                    \"Cannot send packet (usually hardware error)\",\n                    \"Cannot change hardware address ( > 1 handle open)\",\n                    \"Hardware address has bad length or format\",\n                    \"Cannot reset interface (more than 1 handle open)\",\n                    \"Bad Check-sum\",\n                    \"Bad size\",\n                    \"Bad sync\" ,\n                    \"Source hit\"\n                  };\n\n  if (errNum < 0 || errNum >= DIM(errStr))\n     return (\"Unknown driver error.\");\n  return (errStr [errNum]);\n}",
          "fn_code_pos": [
            [
              215,
              0
            ],
            [
              243,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktGetErrorStr",
            "parameters": {
              "errNum": "int"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "static BOOL PktSetAccess (void)\n{\n  reg.r_ax = 0x0200 + pktInfo.class;\n  reg.r_bx = 0xFFFF;\n  reg.r_dx = 0;\n  reg.r_cx = 0;\n\n#if (DOSX & PHARLAP)\n  reg.ds  = 0;\n  reg.esi = 0;\n  reg.es  = RP_SEG (realBase);\n  reg.edi = (WORD) &PktReceiver;\n\n#elif (DOSX & DJGPP)\n  reg.x.ds = 0;\n  reg.x.si = 0;\n  reg.x.es = rm_mem.rm_segment;\n  reg.x.di = PktReceiver;\n\n#elif (DOSX & DOS4GW)\n  reg.r_ds = 0;\n  reg.r_si = 0;\n  reg.r_es = rm_base_seg;\n  reg.r_di = PktReceiver;\n\n#else\n  reg.r_ds = 0;\n  reg.r_si = 0;\n  reg.r_es = FP_SEG (&PktReceiver);\n  reg.r_di = FP_OFF (&PktReceiver);\n#endif\n\n  if (!PktInterrupt())\n     return (FALSE);\n\n  pktInfo.handle = reg.r_ax;\n  return (TRUE);\n}",
          "fn_code_pos": [
            [
              393,
              0
            ],
            [
              430,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktSetAccess",
            "parameters": {},
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PUBLIC BOOL PktReleaseHandle (WORD handle)\n{\n  reg.r_ax = 0x0300;\n  reg.r_bx = handle;\n  return PktInterrupt();\n}",
          "fn_code_pos": [
            [
              434,
              0
            ],
            [
              439,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktReleaseHandle",
            "parameters": {
              "handle": "WORD"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC BOOL PktTransmit (const void *eth, int len)\n{\n  if (len > ETH_MTU)\n     return (FALSE);\n\n  reg.r_ax = 0x0400;             /* Function 4, send pkt */\n  reg.r_cx = len;                /* total size of frame  */\n\n#if (DOSX & DJGPP)\n  dosmemput (eth, len, realBase+pktTxBuf);\n  reg.x.ds = rm_mem.rm_segment;  /* DOS data segment and */\n  reg.x.si = pktTxBuf;           /* DOS offset to buffer */\n\n#elif (DOSX & DOS4GW)\n  memcpy ((void*)(realBase+pktTxBuf), eth, len);\n  reg.r_ds = rm_base_seg;\n  reg.r_si = pktTxBuf;\n\n#elif (DOSX & PHARLAP)\n  memcpy (&pktTxBuf, eth, len);\n  reg.r_ds = FP_SEG (&pktTxBuf);\n  reg.r_si = FP_OFF (&pktTxBuf);\n\n#else\n  reg.r_ds = FP_SEG (eth);\n  reg.r_si = FP_OFF (eth);\n#endif\n\n  return PktInterrupt();\n}",
          "fn_code_pos": [
            [
              443,
              0
            ],
            [
              472,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktTransmit",
            "parameters": {
              "eth": "void",
              "len": "int"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "LOCAL __inline BOOL CheckElement (RX_ELEMENT _far *rx)\n#endif\n{\n  WORD count_1, count_2;\n\n  /*\n   * We got an upcall to the same RMCB with wrong handle.\n   * This can happen if we failed to release handle at program exit\n   */\n  if (rx->handle != pktInfo.handle)\n  {\n    pktInfo.error = \"Wrong handle\";\n    intStat.wrongHandle++;\n    PktReleaseHandle (rx->handle);\n    return (FALSE);\n  }\n  count_1 = rx->firstCount;\n  count_2 = rx->secondCount;\n\n  if (count_1 != count_2)\n  {\n    pktInfo.error = \"Bad sync\";\n    intStat.badSync++;\n    return (FALSE);\n  }\n  if (count_1 > ETH_MAX)\n  {\n    pktInfo.error = \"Large esize\";\n    intStat.tooLarge++;\n    return (FALSE);\n  }\n#if 0\n  if (count_1 < ETH_MIN)\n  {\n    pktInfo.error = \"Small esize\";\n    intStat.tooSmall++;\n    return (FALSE);\n  }\n#endif\n  return (TRUE);\n}",
          "fn_code_pos": [
            [
              479,
              0
            ],
            [
              519,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckElement",
            "parameters": {
              "_far": "RX_ELEMENT"
            },
            "return_type": "LOCAL"
          }
        },
        {
          "fn_code": "PUBLIC BOOL PktTerminHandle (WORD handle)\n{\n  reg.r_ax = 0x0500;\n  reg.r_bx = handle;\n  return PktInterrupt();\n}",
          "fn_code_pos": [
            [
              523,
              0
            ],
            [
              528,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktTerminHandle",
            "parameters": {
              "handle": "WORD"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC BOOL PktResetInterface (WORD handle)\n{\n  reg.r_ax = 0x0700;\n  reg.r_bx = handle;\n  return PktInterrupt();\n}",
          "fn_code_pos": [
            [
              532,
              0
            ],
            [
              537,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktResetInterface",
            "parameters": {
              "handle": "WORD"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC BOOL PktSetReceiverMode (PKT_RX_MODE mode)\n{\n  if (pktInfo.class == PD_SLIP || pktInfo.class == PD_PPP)\n     return (TRUE);\n\n  reg.r_ax = 0x1400;\n  reg.r_bx = pktInfo.handle;\n  reg.r_cx = (WORD)mode;\n\n  if (!PktInterrupt())\n     return (FALSE);\n\n  receiveMode = mode;\n  return (TRUE);\n}",
          "fn_code_pos": [
            [
              541,
              0
            ],
            [
              555,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktSetReceiverMode",
            "parameters": {
              "mode": "PKT_RX_MODE"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC BOOL PktGetReceiverMode (PKT_RX_MODE *mode)\n{\n  reg.r_ax = 0x1500;\n  reg.r_bx = pktInfo.handle;\n\n  if (!PktInterrupt())\n     return (FALSE);\n\n  *mode = reg.r_ax;\n  return (TRUE);\n}",
          "fn_code_pos": [
            [
              559,
              0
            ],
            [
              569,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktGetReceiverMode",
            "parameters": {
              "mode": "PKT_RX_MODE"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC BOOL PktGetStatistics (WORD handle)\n{\n  reg.r_ax = 0x1800;\n  reg.r_bx = handle;\n\n  if (!PktInterrupt())\n     return (FALSE);\n\n#if (DOSX & PHARLAP)\n  ReadRealMem (&pktStat, DOS_ADDR(reg.ds,reg.esi), sizeof(pktStat));\n\n#elif (DOSX & DJGPP)\n  dosmemget (DOS_ADDR(reg.x.ds,reg.x.si), sizeof(pktStat), &pktStat);\n\n#elif (DOSX & DOS4GW)\n  memcpy (&pktStat, (void*)DOS_ADDR(reg.r_ds,reg.r_si), sizeof(pktStat));\n\n#else\n  _fmemcpy (&pktStat, MK_FP(reg.r_ds,reg.r_si), sizeof(pktStat));\n#endif\n\n  return (TRUE);\n}",
          "fn_code_pos": [
            [
              576,
              0
            ],
            [
              598,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktGetStatistics",
            "parameters": {
              "handle": "WORD"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC BOOL PktSessStatistics (WORD handle)\n{\n  if (!PktGetStatistics(pktInfo.handle))\n     return (FALSE);\n\n  if (resetStat)\n  {\n    pktStat.inPackets  -= initialStat.inPackets;\n    pktStat.outPackets -= initialStat.outPackets;\n    pktStat.inBytes    -= initialStat.inBytes;\n    pktStat.outBytes   -= initialStat.outBytes;\n    pktStat.inErrors   -= initialStat.inErrors;\n    pktStat.outErrors  -= initialStat.outErrors;\n    pktStat.outErrors  -= initialStat.outErrors;\n    pktStat.lost       -= initialStat.lost;\n  }\n  return (TRUE);\n}",
          "fn_code_pos": [
            [
              602,
              0
            ],
            [
              619,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktSessStatistics",
            "parameters": {
              "handle": "WORD"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC BOOL PktResetStatistics (WORD handle)\n{\n  if (!PktGetStatistics(pktInfo.handle))\n     return (FALSE);\n\n  memcpy (&initialStat, &pktStat, sizeof(initialStat));\n  resetStat = TRUE;\n  return (TRUE);\n}",
          "fn_code_pos": [
            [
              623,
              0
            ],
            [
              631,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktResetStatistics",
            "parameters": {
              "handle": "WORD"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC BOOL PktGetAddress (ETHER *addr)\n{\n  reg.r_ax = 0x0600;\n  reg.r_bx = pktInfo.handle;\n  reg.r_cx = sizeof (*addr);\n\n#if (DOSX & DJGPP)\n  reg.x.es = rm_mem.rm_segment;\n  reg.x.di = pktTemp;\n#elif (DOSX & DOS4GW)\n  reg.r_es = rm_base_seg;\n  reg.r_di = pktTemp;\n#else\n  reg.r_es = FP_SEG (&pktTemp);\n  reg.r_di = FP_OFF (&pktTemp);  /* ES:DI = address for result */\n#endif\n\n  if (!PktInterrupt())\n     return (FALSE);\n\n#if (DOSX & PHARLAP)\n  ReadRealMem (addr, realBase + (WORD)&pktTemp, sizeof(*addr));\n\n#elif (DOSX & DJGPP)\n  dosmemget (realBase+pktTemp, sizeof(*addr), addr);\n\n#elif (DOSX & DOS4GW)\n  memcpy (addr, (void*)(realBase+pktTemp), sizeof(*addr));\n\n#else\n  memcpy ((void*)addr, &pktTemp, sizeof(*addr));\n#endif\n\n  return (TRUE);\n}",
          "fn_code_pos": [
            [
              635,
              0
            ],
            [
              669,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktGetAddress",
            "parameters": {
              "addr": "ETHER"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC BOOL PktSetAddress (const ETHER *addr)\n{\n  /* copy addr to real-mode scrath area */\n\n#if (DOSX & PHARLAP)\n  WriteRealMem (realBase + (WORD)&pktTemp, (void*)addr, sizeof(*addr));\n\n#elif (DOSX & DJGPP)\n  dosmemput (addr, sizeof(*addr), realBase+pktTemp);\n\n#elif (DOSX & DOS4GW)\n  memcpy ((void*)(realBase+pktTemp), addr, sizeof(*addr));\n\n#else\n  memcpy (&pktTemp, (void*)addr, sizeof(*addr));\n#endif\n\n  reg.r_ax = 0x1900;\n  reg.r_cx = sizeof (*addr);      /* address length       */\n\n#if (DOSX & DJGPP)\n  reg.x.es = rm_mem.rm_segment;   /* DOS offset to param  */\n  reg.x.di = pktTemp;             /* DOS segment to param */\n#elif (DOSX & DOS4GW)\n  reg.r_es = rm_base_seg;\n  reg.r_di = pktTemp;\n#else\n  reg.r_es = FP_SEG (&pktTemp);\n  reg.r_di = FP_OFF (&pktTemp);\n#endif\n\n  return PktInterrupt();\n}",
          "fn_code_pos": [
            [
              673,
              0
            ],
            [
              705,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktSetAddress",
            "parameters": {
              "addr": "ETHER"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC BOOL PktGetDriverInfo (void)\n{\n  pktInfo.majVer = 0;\n  pktInfo.minVer = 0;\n  memset (&pktInfo.name, 0, sizeof(pktInfo.name));\n  reg.r_ax = 0x01FF;\n  reg.r_bx = 0;\n\n  if (!PktInterrupt())\n     return (FALSE);\n\n  pktInfo.number = reg.r_cx & 0xFF;\n  pktInfo.class  = reg.r_cx >> 8;\n#if 0\n  pktInfo.minVer = reg.r_bx % 10;\n  pktInfo.majVer = reg.r_bx / 10;\n#else\n  pktInfo.majVer = reg.r_bx;  // !!\n#endif\n  pktInfo.funcs  = reg.r_ax & 0xFF;\n  pktInfo.type   = reg.r_dx & 0xFF;\n\n#if (DOSX & PHARLAP)\n  ReadRealMem (&pktInfo.name, DOS_ADDR(reg.ds,reg.esi), sizeof(pktInfo.name));\n\n#elif (DOSX & DJGPP)\n  dosmemget (DOS_ADDR(reg.x.ds,reg.x.si), sizeof(pktInfo.name), &pktInfo.name);\n\n#elif (DOSX & DOS4GW)\n  memcpy (&pktInfo.name, (void*)DOS_ADDR(reg.r_ds,reg.r_si), sizeof(pktInfo.name));\n\n#else\n  _fmemcpy (&pktInfo.name, MK_FP(reg.r_ds,reg.r_si), sizeof(pktInfo.name));\n#endif\n  return (TRUE);\n}",
          "fn_code_pos": [
            [
              709,
              0
            ],
            [
              744,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktGetDriverInfo",
            "parameters": {},
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC BOOL PktGetDriverParam (void)\n{\n  reg.r_ax = 0x0A00;\n\n  if (!PktInterrupt())\n     return (FALSE);\n\n#if (DOSX & PHARLAP)\n  ReadRealMem (&pktInfo.majVer, DOS_ADDR(reg.es,reg.edi), PKT_PARAM_SIZE);\n\n#elif (DOSX & DJGPP)\n  dosmemget (DOS_ADDR(reg.x.es,reg.x.di), PKT_PARAM_SIZE, &pktInfo.majVer);\n\n#elif (DOSX & DOS4GW)\n  memcpy (&pktInfo.majVer, (void*)DOS_ADDR(reg.r_es,reg.r_di), PKT_PARAM_SIZE);\n\n#else\n  _fmemcpy (&pktInfo.majVer, MK_FP(reg.r_es,reg.r_di), PKT_PARAM_SIZE);\n#endif\n  return (TRUE);\n}",
          "fn_code_pos": [
            [
              748,
              0
            ],
            [
              768,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktGetDriverParam",
            "parameters": {},
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC int PktReceive (BYTE *buf, int max)\n  {\n    WORD inOfs  = *rxInOfsFp;\n    WORD outOfs = *rxOutOfsFp;\n\n    if (outOfs != inOfs)\n    {\n      RX_ELEMENT _far *head = (RX_ELEMENT _far*)(protBase+outOfs);\n      int size, len = max;\n\n      if (CheckElement(head))\n      {\n        size = min (head->firstCount, sizeof(RX_ELEMENT));\n        len  = min (size, max);\n        _fmemcpy (buf, &head->destin, len);\n      }\n      else\n        size = -1;\n\n      outOfs += sizeof (RX_ELEMENT);\n      if (outOfs > LAST_RX_BUF)\n          outOfs = FIRST_RX_BUF;\n      *rxOutOfsFp = outOfs;\n      return (size);\n    }\n    return (0);\n  }",
          "fn_code_pos": [
            [
              773,
              2
            ],
            [
              799,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktReceive",
            "parameters": {
              "buf": "BYTE",
              "max": "int"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC void PktQueueBusy (BOOL busy)\n  {\n    *rxOutOfsFp = busy ? (*rxInOfsFp + sizeof(RX_ELEMENT)) : *rxInOfsFp;\n    if (*rxOutOfsFp > LAST_RX_BUF)\n        *rxOutOfsFp = FIRST_RX_BUF;\n    *(DWORD _far*)(protBase + (WORD)&pktDrop) = 0;\n  }",
          "fn_code_pos": [
            [
              801,
              2
            ],
            [
              807,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktQueueBusy",
            "parameters": {
              "busy": "BOOL"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC WORD PktBuffersUsed (void)\n  {\n    WORD inOfs  = *rxInOfsFp;\n    WORD outOfs = *rxOutOfsFp;\n\n    if (inOfs >= outOfs)\n       return (inOfs - outOfs) / sizeof(RX_ELEMENT);\n    return (NUM_RX_BUF - (outOfs - inOfs) / sizeof(RX_ELEMENT));\n  }",
          "fn_code_pos": [
            [
              809,
              2
            ],
            [
              817,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktBuffersUsed",
            "parameters": {},
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC DWORD PktRxDropped (void)\n  {\n    return (*(DWORD _far*)(protBase + (WORD)&pktDrop));\n  }",
          "fn_code_pos": [
            [
              819,
              2
            ],
            [
              822,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktRxDropped",
            "parameters": {},
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC int PktReceive (BYTE *buf, int max)\n  {\n    WORD ofs = _farpeekw (_dos_ds, realBase+rxOutOfs);\n\n    if (ofs != _farpeekw (_dos_ds, realBase+rxInOfs))\n    {\n      RX_ELEMENT head;\n      int  size, len = max;\n\n      head.firstCount  = _farpeekw (_dos_ds, realBase+ofs);\n      head.secondCount = _farpeekw (_dos_ds, realBase+ofs+2);\n      head.handle      = _farpeekw (_dos_ds, realBase+ofs+4);\n\n      if (CheckElement(&head))\n      {\n        size = min (head.firstCount, sizeof(RX_ELEMENT));\n        len  = min (size, max);\n        dosmemget (realBase+ofs+6, len, buf);\n      }\n      else\n        size = -1;\n\n      ofs += sizeof (RX_ELEMENT);\n      if (ofs > LAST_RX_BUF)\n           _farpokew (_dos_ds, realBase+rxOutOfs, FIRST_RX_BUF);\n      else _farpokew (_dos_ds, realBase+rxOutOfs, ofs);\n      return (size);\n    }\n    return (0);\n  }",
          "fn_code_pos": [
            [
              825,
              2
            ],
            [
              854,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktReceive",
            "parameters": {
              "buf": "BYTE",
              "max": "int"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC void PktQueueBusy (BOOL busy)\n  {\n    WORD ofs;\n\n    disable();\n    ofs = _farpeekw (_dos_ds, realBase+rxInOfs);\n    if (busy)\n       ofs += sizeof (RX_ELEMENT);\n\n    if (ofs > LAST_RX_BUF)\n         _farpokew (_dos_ds, realBase+rxOutOfs, FIRST_RX_BUF);\n    else _farpokew (_dos_ds, realBase+rxOutOfs, ofs);\n    _farpokel (_dos_ds, realBase+pktDrop, 0UL);\n    enable();\n  }",
          "fn_code_pos": [
            [
              856,
              2
            ],
            [
              870,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktQueueBusy",
            "parameters": {
              "busy": "BOOL"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC WORD PktBuffersUsed (void)\n  {\n    WORD inOfs, outOfs;\n\n    disable();\n    inOfs  = _farpeekw (_dos_ds, realBase+rxInOfs);\n    outOfs = _farpeekw (_dos_ds, realBase+rxOutOfs);\n    enable();\n    if (inOfs >= outOfs)\n       return (inOfs - outOfs) / sizeof(RX_ELEMENT);\n    return (NUM_RX_BUF - (outOfs - inOfs) / sizeof(RX_ELEMENT));\n  }",
          "fn_code_pos": [
            [
              872,
              2
            ],
            [
              883,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktBuffersUsed",
            "parameters": {},
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC DWORD PktRxDropped (void)\n  {\n    return _farpeekl (_dos_ds, realBase+pktDrop);\n  }",
          "fn_code_pos": [
            [
              885,
              2
            ],
            [
              888,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktRxDropped",
            "parameters": {},
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC int PktReceive (BYTE *buf, int max)\n  {\n    WORD ofs = *(WORD*) (realBase+rxOutOfs);\n\n    if (ofs != *(WORD*) (realBase+rxInOfs))\n    {\n      RX_ELEMENT head;\n      int  size, len = max;\n\n      head.firstCount  = *(WORD*) (realBase+ofs);\n      head.secondCount = *(WORD*) (realBase+ofs+2);\n      head.handle      = *(WORD*) (realBase+ofs+4);\n\n      if (CheckElement(&head))\n      {\n        size = min (head.firstCount, sizeof(RX_ELEMENT));\n        len  = min (size, max);\n        memcpy (buf, (const void*)(realBase+ofs+6), len);\n      }\n      else\n        size = -1;\n\n      ofs += sizeof (RX_ELEMENT);\n      if (ofs > LAST_RX_BUF)\n           *(WORD*) (realBase+rxOutOfs) = FIRST_RX_BUF;\n      else *(WORD*) (realBase+rxOutOfs) = ofs;\n      return (size);\n    }\n    return (0);\n  }",
          "fn_code_pos": [
            [
              891,
              2
            ],
            [
              920,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktReceive",
            "parameters": {
              "buf": "BYTE",
              "max": "int"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC void PktQueueBusy (BOOL busy)\n  {\n    WORD ofs;\n\n    _disable();\n    ofs = *(WORD*) (realBase+rxInOfs);\n    if (busy)\n       ofs += sizeof (RX_ELEMENT);\n\n    if (ofs > LAST_RX_BUF)\n         *(WORD*) (realBase+rxOutOfs) = FIRST_RX_BUF;\n    else *(WORD*) (realBase+rxOutOfs) = ofs;\n    *(DWORD*) (realBase+pktDrop) = 0UL;\n    _enable();\n  }",
          "fn_code_pos": [
            [
              922,
              2
            ],
            [
              936,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktQueueBusy",
            "parameters": {
              "busy": "BOOL"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC WORD PktBuffersUsed (void)\n  {\n    WORD inOfs, outOfs;\n\n    _disable();\n    inOfs  = *(WORD*) (realBase+rxInOfs);\n    outOfs = *(WORD*) (realBase+rxOutOfs);\n    _enable();\n    if (inOfs >= outOfs)\n       return (inOfs - outOfs) / sizeof(RX_ELEMENT);\n    return (NUM_RX_BUF - (outOfs - inOfs) / sizeof(RX_ELEMENT));\n  }",
          "fn_code_pos": [
            [
              938,
              2
            ],
            [
              949,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktBuffersUsed",
            "parameters": {},
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC DWORD PktRxDropped (void)\n  {\n    return *(DWORD*) (realBase+pktDrop);\n  }",
          "fn_code_pos": [
            [
              951,
              2
            ],
            [
              954,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktRxDropped",
            "parameters": {},
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC int PktReceive (BYTE *buf, int max)\n  {\n    if (rxOutOfs != rxInOfs)\n    {\n      RX_ELEMENT far *head = (RX_ELEMENT far*) MK_FP (_DS,rxOutOfs);\n      int  size, len = max;\n\n      if (CheckElement(head))\n      {\n        size = min (head->firstCount, sizeof(RX_ELEMENT));\n        len  = min (size, max);\n        _fmemcpy (buf, &head->destin, len);\n      }\n      else\n        size = -1;\n\n      rxOutOfs += sizeof (RX_ELEMENT);\n      if (rxOutOfs > LAST_RX_BUF)\n          rxOutOfs = FIRST_RX_BUF;\n      return (size);\n    }\n    return (0);\n  }",
          "fn_code_pos": [
            [
              958,
              2
            ],
            [
              980,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktReceive",
            "parameters": {
              "buf": "BYTE",
              "max": "int"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC void PktQueueBusy (BOOL busy)\n  {\n    rxOutOfs = busy ? (rxInOfs + sizeof(RX_ELEMENT)) : rxInOfs;\n    if (rxOutOfs > LAST_RX_BUF)\n        rxOutOfs = FIRST_RX_BUF;\n    pktDrop = 0L;\n  }",
          "fn_code_pos": [
            [
              982,
              2
            ],
            [
              988,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktQueueBusy",
            "parameters": {
              "busy": "BOOL"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC WORD PktBuffersUsed (void)\n  {\n    WORD inOfs  = rxInOfs;\n    WORD outOfs = rxOutOfs;\n\n    if (inOfs >= outOfs)\n       return ((inOfs - outOfs) / sizeof(RX_ELEMENT));\n    return (NUM_RX_BUF - (outOfs - inOfs) / sizeof(RX_ELEMENT));\n  }",
          "fn_code_pos": [
            [
              990,
              2
            ],
            [
              998,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktBuffersUsed",
            "parameters": {},
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "PUBLIC DWORD PktRxDropped (void)\n  {\n    return (pktDrop);\n  }",
          "fn_code_pos": [
            [
              1000,
              2
            ],
            [
              1003,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktRxDropped",
            "parameters": {},
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "LOCAL __inline void PktFreeMem (void)\n{\n#if (DOSX & PHARLAP)\n  if (realSeg)\n  {\n    _dx_real_free (realSeg);\n    realSeg = 0;\n  }\n#elif (DOSX & DJGPP)\n  if (rm_mem.rm_segment)\n  {\n    unsigned ofs;  /* clear the DOS-mem to prevent further upcalls */\n\n    for (ofs = 0; ofs < 16 * rm_mem.size / 4; ofs += 4)\n       _farpokel (_dos_ds, realBase + ofs, 0);\n    _go32_dpmi_free_dos_memory (&rm_mem);\n    rm_mem.rm_segment = 0;\n  }\n#elif (DOSX & DOS4GW)\n  if (rm_base_sel)\n  {\n    dpmi_real_free (rm_base_sel);\n    rm_base_sel = 0;\n  }\n#endif\n}",
          "fn_code_pos": [
            [
              1008,
              0
            ],
            [
              1033,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktFreeMem",
            "parameters": {},
            "return_type": "LOCAL"
          }
        },
        {
          "fn_code": "PUBLIC BOOL PktExitDriver (void)\n{\n  if (pktInfo.handle)\n  {\n    if (!PktSetReceiverMode(PDRX_BROADCAST))\n       PUTS (\"Error restoring receiver mode.\");\n\n    if (!PktReleaseHandle(pktInfo.handle))\n       PUTS (\"Error releasing PKT-DRVR handle.\");\n\n    PktFreeMem();\n    pktInfo.handle = 0;\n  }\n\n  if (pcap_pkt_debug >= 1)\n     printf (\"Internal stats: too-small %lu, too-large %lu, bad-sync %lu, \"\n             \"wrong-handle %lu\\n\",\n             intStat.tooSmall, intStat.tooLarge,\n             intStat.badSync, intStat.wrongHandle);\n  return (TRUE);\n}",
          "fn_code_pos": [
            [
              1037,
              0
            ],
            [
              1057,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktExitDriver",
            "parameters": {},
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "static void dump_pkt_stub (void)\n{\n  int i;\n\n  fprintf (stderr, \"PktReceiver %lu, pkt_stub[PktReceiver] =\\n\",\n           PktReceiver);\n  for (i = 0; i < 15; i++)\n      fprintf (stderr, \"%02X, \", real_stub_array[i+PktReceiver]);\n  fputs (\"\\n\", stderr);\n}",
          "fn_code_pos": [
            [
              1060,
              0
            ],
            [
              1069,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_pkt_stub",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PUBLIC BOOL PktInitDriver (PKT_RX_MODE mode)\n{\n  PKT_RX_MODE rxMode;\n  BOOL   writeInfo = (pcap_pkt_debug >= 3);\n\n  pktInfo.quiet = (pcap_pkt_debug < 3);\n\n#if (DOSX & PHARLAP) && defined(__HIGHC__)\n  if (_mwenv != 2)\n  {\n    fprintf (stderr, \"Only Pharlap DOS extender supported.\\n\");\n    return (FALSE);\n  }\n#endif\n\n#if (DOSX & PHARLAP) && defined(__WATCOMC__)\n  if (_Extender != 1)\n  {\n    fprintf (stderr, \"Only DOS4GW style extenders supported.\\n\");\n    return (FALSE);\n  }\n#endif\n\n  if (!PktSearchDriver())\n  {\n    PUTS (\"Packet driver not found.\");\n    PktFreeMem();\n    return (FALSE);\n  }\n\n  if (!PktGetDriverInfo())\n  {\n    PUTS (\"Error getting pkt-drvr information.\");\n    PktFreeMem();\n    return (FALSE);\n  }\n\n#if (DOSX & PHARLAP)\n  if (RealCopy((ULONG)&rxOutOfs, (ULONG)&pktRxEnd,\n               &realBase, &protBase, (USHORT*)&realSeg))\n  {\n    rxOutOfsFp  = (WORD _far *) (protBase + (WORD) &rxOutOfs);\n    rxInOfsFp   = (WORD _far *) (protBase + (WORD) &rxInOfs);\n    *rxOutOfsFp = FIRST_RX_BUF;\n    *rxInOfsFp  = FIRST_RX_BUF;\n  }\n  else\n  {\n    PUTS (\"Cannot allocate real-mode stub.\");\n    return (FALSE);\n  }\n\n#elif (DOSX & (DJGPP|DOS4GW))\n  if (sizeof(real_stub_array) > 0xFFFF)\n  {\n    fprintf (stderr, \"`real_stub_array[]' too big.\\n\");\n    return (FALSE);\n  }\n#if (DOSX & DJGPP)\n  rm_mem.size = (sizeof(real_stub_array) + 15) / 16;\n\n  if (_go32_dpmi_allocate_dos_memory(&rm_mem) || rm_mem.rm_offset != 0)\n  {\n    PUTS (\"real-mode init failed.\");\n    return (FALSE);\n  }\n  realBase = (rm_mem.rm_segment << 4);\n  dosmemput (&real_stub_array, sizeof(real_stub_array), realBase);\n  _farpokel (_dos_ds, realBase+rxOutOfs, FIRST_RX_BUF);\n  _farpokel (_dos_ds, realBase+rxInOfs,  FIRST_RX_BUF);\n\n#elif (DOSX & DOS4GW)\n  rm_base_seg = dpmi_real_malloc (sizeof(real_stub_array), &rm_base_sel);\n  if (!rm_base_seg)\n  {\n    PUTS (\"real-mode init failed.\");\n    return (FALSE);\n  }\n  realBase = (rm_base_seg << 4);\n  memcpy ((void*)realBase, &real_stub_array, sizeof(real_stub_array));\n  *(WORD*) (realBase+rxOutOfs) = FIRST_RX_BUF;\n  *(WORD*) (realBase+rxInOfs)  = FIRST_RX_BUF;\n\n#endif\n  {\n    int pushf = PktReceiver;\n\n    while (real_stub_array[pushf++] != 0x9C &&    /* pushf */\n           real_stub_array[pushf]   != 0xFA)      /* cli   */\n    {\n      if (++para_skip > 16)\n      {\n        fprintf (stderr, \"Something wrong with `pkt_stub.inc'.\\n\");\n        para_skip = 0;\n        dump_pkt_stub();\n        return (FALSE);\n      }\n    }\n    if (*(WORD*)(real_stub_array + offsetof(PktRealStub,_dummy)) != 0xB800)\n    {\n      fprintf (stderr, \"`real_stub_array[]' is misaligned.\\n\");\n      return (FALSE);\n    }\n  }\n\n  if (pcap_pkt_debug > 2)\n      dump_pkt_stub();\n\n#else\n  rxOutOfs = FIRST_RX_BUF;\n  rxInOfs  = FIRST_RX_BUF;\n#endif\n\n  if (!PktSetAccess())\n  {\n    PUTS (\"Error setting pkt-drvr access.\");\n    PktFreeMem();\n    return (FALSE);\n  }\n\n  if (!PktGetAddress(&myAddress))\n  {\n    PUTS (\"Error fetching adapter address.\");\n    PktFreeMem();\n    return (FALSE);\n  }\n\n  if (!PktSetReceiverMode(mode))\n  {\n    PUTS (\"Error setting receiver mode.\");\n    PktFreeMem();\n    return (FALSE);\n  }\n\n  if (!PktGetReceiverMode(&rxMode))\n  {\n    PUTS (\"Error getting receiver mode.\");\n    PktFreeMem();\n    return (FALSE);\n  }\n\n  if (writeInfo)\n     printf (\"Pkt-driver information:\\n\"\n             \"  Version  : %d.%d\\n\"\n             \"  Name     : %.15s\\n\"\n             \"  Class    : %u (%s)\\n\"\n             \"  Type     : %u\\n\"\n             \"  Number   : %u\\n\"\n             \"  Funcs    : %u\\n\"\n             \"  Intr     : %Xh\\n\"\n             \"  Handle   : %u\\n\"\n             \"  Extended : %s\\n\"\n             \"  Hi-perf  : %s\\n\"\n             \"  RX mode  : %s\\n\"\n             \"  Eth-addr : %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n\n             pktInfo.majVer, pktInfo.minVer, pktInfo.name,\n             pktInfo.class,  PktGetClassName(pktInfo.class),\n             pktInfo.type,   pktInfo.number,\n             pktInfo.funcs,  pktInfo.intr,   pktInfo.handle,\n             pktInfo.funcs == 2 || pktInfo.funcs == 6 ? \"Yes\" : \"No\",\n             pktInfo.funcs == 5 || pktInfo.funcs == 6 ? \"Yes\" : \"No\",\n             PktRXmodeStr(rxMode),\n             myAddress[0], myAddress[1], myAddress[2],\n             myAddress[3], myAddress[4], myAddress[5]);\n\n#if defined(DEBUG) && (DOSX & PHARLAP)\n  if (writeInfo)\n  {\n    DWORD    rAdr = realBase + (WORD)&PktReceiver;\n    unsigned sel, ofs;\n\n    printf (\"\\nReceiver at   %04X:%04X\\n\", RP_SEG(rAdr),    RP_OFF(rAdr));\n    printf (\"Realbase    = %04X:%04X\\n\",   RP_SEG(realBase),RP_OFF(realBase));\n\n    sel = _FP_SEG (protBase);\n    ofs = _FP_OFF (protBase);\n    printf (\"Protbase    = %04X:%08X\\n\", sel,ofs);\n    printf (\"RealSeg     = %04X\\n\", realSeg);\n\n    sel = _FP_SEG (rxOutOfsFp);\n    ofs = _FP_OFF (rxOutOfsFp);\n    printf (\"rxOutOfsFp  = %04X:%08X\\n\", sel,ofs);\n\n    sel = _FP_SEG (rxInOfsFp);\n    ofs = _FP_OFF (rxInOfsFp);\n    printf (\"rxInOfsFp   = %04X:%08X\\n\", sel,ofs);\n\n    printf (\"Ready: *rxOutOfsFp = %04X *rxInOfsFp = %04X\\n\",\n            *rxOutOfsFp, *rxInOfsFp);\n\n    PktQueueBusy (TRUE);\n    printf (\"Busy:  *rxOutOfsFp = %04X *rxInOfsFp = %04X\\n\",\n            *rxOutOfsFp, *rxInOfsFp);\n  }\n#endif\n\n  memset (&pktStat, 0, sizeof(pktStat));  /* clear statistics */\n  PktQueueBusy (TRUE);\n  return (TRUE);\n}",
          "fn_code_pos": [
            [
              1075,
              0
            ],
            [
              1275,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktInitDriver",
            "parameters": {
              "mode": "PKT_RX_MODE"
            },
            "return_type": "PUBLIC"
          }
        },
        {
          "fn_code": "LOCAL DWORD dpmi_get_real_vector (int intr)\n{\n  union REGS r;\n\n  r.x.eax = 0x200;\n  r.x.ebx = (DWORD) intr;\n  int386 (0x31, &r, &r);\n  return ((r.w.cx << 4) + r.w.dx);\n}",
          "fn_code_pos": [
            [
              1282,
              0
            ],
            [
              1290,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dpmi_get_real_vector",
            "parameters": {
              "intr": "int"
            },
            "return_type": "LOCAL"
          }
        },
        {
          "fn_code": "LOCAL WORD dpmi_real_malloc (int size, WORD *selector)\n{\n  union REGS r;\n\n  r.x.eax = 0x0100;             /* DPMI allocate DOS memory */\n  r.x.ebx = (size + 15) / 16;   /* Number of paragraphs requested */\n  int386 (0x31, &r, &r);\n  if (r.w.cflag & 1)\n     return (0);\n\n  *selector = r.w.dx;\n  return (r.w.ax);              /* Return segment address */\n}",
          "fn_code_pos": [
            [
              1292,
              0
            ],
            [
              1304,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dpmi_real_malloc",
            "parameters": {
              "size": "int",
              "selector": "WORD"
            },
            "return_type": "LOCAL"
          }
        },
        {
          "fn_code": "LOCAL void dpmi_real_free (WORD selector)\n{\n  union REGS r;\n\n  r.x.eax = 0x101;              /* DPMI free DOS memory */\n  r.x.ebx = selector;           /* Selector to free */\n  int386 (0x31, &r, &r);\n}",
          "fn_code_pos": [
            [
              1306,
              0
            ],
            [
              1313,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dpmi_real_free",
            "parameters": {
              "selector": "WORD"
            },
            "return_type": "LOCAL"
          }
        },
        {
          "fn_code": "int RealCopy (ULONG    start_offs,\n              ULONG    end_offs,\n              REALPTR *real_basep,\n              FARPTR  *prot_basep,\n              USHORT  *rmem_adrp)\n{\n  ULONG   rm_base;    /* base real mode para addr for accessing */\n                      /* allocated conventional memory          */\n  UCHAR  *source;     /* source pointer for copy                */\n  FARPTR  destin;     /* destination pointer for copy           */\n  ULONG   len;        /* number of bytes to copy                */\n  ULONG   temp;\n  USHORT  stemp;\n\n  /* First check for valid inputs\n   */\n  if (start_offs >= end_offs || end_offs > 0x10000)\n     return (FALSE);\n\n  /* Round start_offs down to a paragraph (16-byte) boundary so we can set up\n   * the real mode pointer easily. Round up end_offs to make sure we allocate\n   * enough paragraphs\n   */\n  start_offs &= ~15;\n  end_offs = (15 + (end_offs << 4)) >> 4;\n\n  /* Allocate the conventional memory for our real mode code.  Remember to\n   * round byte count UP to 16-byte paragraph size.  We alloc it\n   * above the DOS data buffer so both the DOS data buffer and the appl\n   * conventional mem block can still be resized.\n   *\n   * First just try to alloc it;  if we can't get it, shrink the appl mem\n   * block down to the minimum, try to alloc the memory again, then grow the\n   * appl mem block back to the maximum.  (Don't try to shrink the DOS data\n   * buffer to free conventional memory;  it wouldn't be good for this routine\n   * to have the possible side effect of making file I/O run slower.)\n   */\n  len = ((end_offs - start_offs) + 15) >> 4;\n  if (_dx_real_above(len, rmem_adrp, &stemp) != _DOSE_NONE)\n  {\n    if (_dx_cmem_usage(0, 0, &temp, &temp) != _DOSE_NONE)\n       return (FALSE);\n\n    if (_dx_real_above(len, rmem_adrp, &stemp) != _DOSE_NONE)\n       *rmem_adrp = 0;\n\n    if (_dx_cmem_usage(0, 1, &temp, &temp) != _DOSE_NONE)\n    {\n      if (*rmem_adrp != 0)\n         _dx_real_free (*rmem_adrp);\n      return (FALSE);\n    }\n\n    if (*rmem_adrp == 0)\n       return (FALSE);\n  }\n\n  /* Construct real mode & protected mode pointers to access the allocated\n   * memory.  Note we know start_offs is aligned on a paragraph (16-byte)\n   * boundary, because we rounded it down.\n   *\n   * We make the offsets come out rights by backing off the real mode selector\n   * by start_offs.\n   */\n  rm_base = ((ULONG) *rmem_adrp) - (start_offs >> 4);\n  RP_SET (*real_basep, 0, rm_base);\n  FP_SET (*prot_basep, rm_base << 4, SS_DOSMEM);\n\n  /* Copy the real mode code/data to the allocated memory\n   */\n  source = (UCHAR *) start_offs;\n  destin = *prot_basep;\n  FP_SET (destin, FP_OFF(*prot_basep) + start_offs, FP_SEL(*prot_basep));\n  len = end_offs - start_offs;\n  WriteFarMem (destin, source, len);\n\n  return (TRUE);\n}",
          "fn_code_pos": [
            [
              1357,
              0
            ],
            [
              1434,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RealCopy",
            "parameters": {
              "start_offs": "ULONG",
              "end_offs": "ULONG",
              "real_basep": "REALPTR",
              "prot_basep": "FARPTR",
              "rmem_adrp": "USHORT"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "PktReceiver (void)",
          "fn_dec_pos": [
            [
              57,
              18
            ],
            [
              57,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktReceiver",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PktReceiver (void)",
          "fn_dec_pos": [
            [
              130,
              14
            ],
            [
              130,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktReceiver",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "RealCopy    (ULONG, ULONG, REALPTR*, FARPTR*, USHORT*)",
          "fn_dec_pos": [
            [
              131,
              14
            ],
            [
              131,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "RealCopy",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dpmi_get_real_vector (int intr)",
          "fn_dec_pos": [
            [
              175,
              14
            ],
            [
              175,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dpmi_get_real_vector",
            "parameters": {
              "intr": "int"
            },
            "return_type": "LOCAL"
          }
        },
        {
          "fn_code": "dpmi_real_malloc     (int size, WORD *selector)",
          "fn_dec_pos": [
            [
              176,
              14
            ],
            [
              176,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dpmi_real_malloc",
            "parameters": {
              "size": "int",
              "selector": "WORD"
            },
            "return_type": "LOCAL"
          }
        },
        {
          "fn_code": "dpmi_real_free       (WORD selector)",
          "fn_dec_pos": [
            [
              177,
              14
            ],
            [
              177,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dpmi_real_free",
            "parameters": {
              "selector": "WORD"
            },
            "return_type": "LOCAL"
          }
        },
        {
          "fn_code": "PktGetErrorStr (int errNum)",
          "fn_dec_pos": [
            [
              215,
              19
            ],
            [
              215,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktGetErrorStr",
            "parameters": {
              "errNum": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PktGetClassName (WORD class)",
          "fn_dec_pos": [
            [
              247,
              19
            ],
            [
              247,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktGetClassName",
            "parameters": {
              "class": "WORD"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PktRXmodeStr (PKT_RX_MODE mode)",
          "fn_dec_pos": [
            [
              288,
              19
            ],
            [
              288,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktRXmodeStr",
            "parameters": {
              "mode": "PKT_RX_MODE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PktInterrupt (void)",
          "fn_dec_pos": [
            [
              306,
              20
            ],
            [
              306,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktInterrupt",
            "parameters": {},
            "return_type": "LOCAL"
          }
        },
        {
          "fn_code": "CheckElement (RX_ELEMENT *rx)",
          "fn_dec_pos": [
            [
              477,
              20
            ],
            [
              477,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckElement",
            "parameters": {
              "rx": "RX_ELEMENT"
            },
            "return_type": "LOCAL"
          }
        }
      ],
      "class_node_list": {
        "99f8be57c6c3ad9bf62e66cebe719ae6fe2ccf586ee3dd146db44206679cfa1d": {
          "class_code": "class)\n  {\n    case PD_ETHER:\n         return (\"DIX-Ether\");\n    case PD_PRONET10:\n         return (\"ProNET-10\");\n    case PD_IEEE8025:\n         return (\"IEEE 802.5\");\n    case PD_OMNINET:\n         return (\"OmniNet\");\n    case PD_APPLETALK:\n         return (\"AppleTalk\");\n    case PD_SLIP:\n         return (\"SLIP\");\n    case PD_STARTLAN:\n         return (\"StartLAN\");\n    case PD_ARCNET:\n         return (\"ArcNet\");\n    case PD_AX25:\n         return (\"AX.25\");\n    case PD_KISS:\n         return (\"KISS\");\n    case PD_IEEE8023_2:\n         return (\"IEEE 802.3 w/802.2 hdr\");\n    case PD_FDDI8022:\n         return (\"FDDI w/802.2 hdr\");\n    case PD_X25:\n         return (\"X.25\");\n    case PD_LANstar:\n         return (\"LANstar\");\n    case PD_PPP:\n         return (\"PPP\");\n    default:\n         return (\"unknown\");\n  }",
          "class_name": null,
          "class_pos": [
            [
              249,
              10
            ],
            [
              283,
              3
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct DPMI_regs {\n         DWORD  r_di;\n         DWORD  r_si;\n         DWORD  r_bp;\n         DWORD  reserved;\n         DWORD  r_bx;\n         DWORD  r_dx;\n         DWORD  r_cx;\n         DWORD  r_ax;\n         WORD   r_flags;\n         WORD   r_es, r_ds, r_fs, r_gs;\n         WORD   r_ip, r_cs, r_sp, r_ss;\n       }",
          {
            "r_di": "DWORD",
            "r_si": "DWORD",
            "r_bp": "DWORD",
            "reserved": "DWORD",
            "r_bx": "DWORD",
            "r_dx": "DWORD",
            "r_cx": "DWORD",
            "r_ax": "DWORD",
            "r_flags": "WORD",
            "r_es": "WORD",
            "r_ip": "WORD"
          },
          "DPMI_regs",
          [
            64,
            2
          ],
          [
            76,
            8
          ]
        ],
        [
          "typedef struct  {          /* must match data/code in pkt_rx1.s */\n          WORD       _rxOutOfs;\n          WORD       _rxInOfs;\n          DWORD      _pktDrop;\n          BYTE       _pktTemp [20];\n          TX_ELEMENT _pktTxBuf[1];\n          RX_ELEMENT _pktRxBuf[NUM_RX_BUF];\n          WORD       _dummy[2];        /* screenSeg,newInOffset */\n          BYTE       _fanChars[4];\n          WORD       _fanIndex;\n          BYTE       _PktReceiver[15]; /* starts on a paragraph (16byte) */\n        } PktRealStub;",
          {
            "_rxOutOfs": "WORD",
            "_rxInOfs": "WORD",
            "_pktDrop": "DWORD",
            "_pktTemp [20]": "BYTE",
            "_pktTxBuf[1]": "TX_ELEMENT",
            "_pktRxBuf[NUM_RX_BUF]": "RX_ELEMENT",
            "_dummy[2]": "WORD",
            "_fanChars[4]": "BYTE",
            "_fanIndex": "WORD",
            "_PktReceiver[15]": "BYTE"
          },
          "PktRealStub",
          [
            80,
            2
          ],
          [
            91,
            22
          ]
        ],
        [
          "struct  {\n         WORD r_ax, r_bx, r_cx, r_dx, r_bp;\n         WORD r_si, r_di, r_ds, r_es, r_flags;\n       }",
          {
            "r_ax": "WORD",
            "r_si": "WORD"
          },
          "",
          [
            181,
            9
          ],
          [
            184,
            8
          ]
        ],
        [
          "struct DPMI_regs {\n         DWORD  r_di;\n         DWORD  r_si;\n         DWORD  r_bp;\n         DWORD  reserved;\n         DWORD  r_bx;\n         DWORD  r_dx;\n         DWORD  r_cx;\n         DWORD  r_ax;\n         WORD   r_flags;\n         WORD   r_es, r_ds, r_fs, r_gs;\n         WORD   r_ip, r_cs, r_sp, r_ss;\n       }",
          {
            "r_di": "DWORD",
            "r_si": "DWORD",
            "r_bp": "DWORD",
            "reserved": "DWORD",
            "r_bx": "DWORD",
            "r_dx": "DWORD",
            "r_cx": "DWORD",
            "r_ax": "DWORD",
            "r_flags": "WORD",
            "r_es": "WORD",
            "r_ip": "WORD"
          },
          "DPMI_regs",
          [
            64,
            2
          ],
          [
            76,
            8
          ]
        ],
        [
          "typedef struct  {          /* must match data/code in pkt_rx1.s */\n          WORD       _rxOutOfs;\n          WORD       _rxInOfs;\n          DWORD      _pktDrop;\n          BYTE       _pktTemp [20];\n          TX_ELEMENT _pktTxBuf[1];\n          RX_ELEMENT _pktRxBuf[NUM_RX_BUF];\n          WORD       _dummy[2];        /* screenSeg,newInOffset */\n          BYTE       _fanChars[4];\n          WORD       _fanIndex;\n          BYTE       _PktReceiver[15]; /* starts on a paragraph (16byte) */\n        } PktRealStub;",
          {
            "_rxOutOfs": "WORD",
            "_rxInOfs": "WORD",
            "_pktDrop": "DWORD",
            "_pktTemp [20]": "BYTE",
            "_pktTxBuf[1]": "TX_ELEMENT",
            "_pktRxBuf[NUM_RX_BUF]": "RX_ELEMENT",
            "_dummy[2]": "WORD",
            "_fanChars[4]": "BYTE",
            "_fanIndex": "WORD",
            "_PktReceiver[15]": "BYTE"
          },
          "PktRealStub",
          [
            80,
            2
          ],
          [
            91,
            22
          ]
        ],
        [
          "struct  {\n         WORD r_ax, r_bx, r_cx, r_dx, r_bp;\n         WORD r_si, r_di, r_ds, r_es, r_flags;\n       }",
          {
            "r_ax": "WORD",
            "r_si": "WORD"
          },
          "",
          [
            181,
            9
          ],
          [
            184,
            8
          ]
        ],
        [
          "struct REGPACK",
          {},
          "",
          [
            337,
            23
          ],
          [
            337,
            37
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include <dos.h>\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"pcap-dos.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"msdos/pktdrvr.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <stddef.h>\n",
          [
            45,
            2
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <dpmi.h>\n",
          [
            46,
            2
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <go32.h>\n",
          [
            47,
            2
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <pc.h>\n",
          [
            48,
            2
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <sys/farptr.h>\n",
          [
            49,
            2
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <i86.h>\n",
          [
            52,
            2
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <stddef.h>\n",
          [
            53,
            2
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <sys/pack_on.h>\n",
          [
            62,
            2
          ],
          [
            63,
            0
          ]
        ],
        [
          "#include <sys/pack_off.h>\n",
          [
            92,
            2
          ],
          [
            93,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/testprogs/opentest.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char **argv)\n{\n\tregister int op;\n\tregister char *cp, *device;\n\tint dorfmon, dopromisc, snaplen, useactivate, bufsize;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tpcap_if_t *devlist;\n\tpcap_t *pd;\n\tint status = 0;\n\n\tdevice = NULL;\n\tdorfmon = 0;\n\tdopromisc = 0;\n\tsnaplen = MAXIMUM_SNAPLEN;\n\tbufsize = 0;\n\tuseactivate = 0;\n\tif ((cp = strrchr(argv[0], '/')) != NULL)\n\t\tprogram_name = cp + 1;\n\telse\n\t\tprogram_name = argv[0];\n\n\topterr = 0;\n\twhile ((op = getopt(argc, argv, \"i:Ips:aB:\")) != -1) {\n\t\tswitch (op) {\n\n\t\tcase 'i':\n\t\t\tdevice = optarg;\n\t\t\tbreak;\n\n\t\tcase 'I':\n\t\t\tdorfmon = 1;\n\t\t\tuseactivate = 1;\t/* required for rfmon */\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tdopromisc = 1;\n\t\t\tbreak;\n\n\t\tcase 's': {\n\t\t\tchar *end;\n\t\t\tlong long_snaplen;\n\n\t\t\tlong_snaplen = strtol(optarg, &end, 0);\n\t\t\tif (optarg == end || *end != '\\0'\n\t\t\t    || long_snaplen < 0\n\t\t\t    || long_snaplen > MAXIMUM_SNAPLEN)\n\t\t\t\terror(\"invalid snaplen %s\", optarg);\n\t\t\telse {\n\t\t\t\tif (snaplen == 0)\n\t\t\t\t\tsnaplen = MAXIMUM_SNAPLEN;\n\t\t\t\telse\n\t\t\t\t\tsnaplen = (int)long_snaplen;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'B':\n\t\t\tbufsize = atoi(optarg)*1024;\n\t\t\tif (bufsize <= 0)\n\t\t\t\terror(\"invalid packet buffer size %s\", optarg);\n\t\t\tuseactivate = 1;\t/* required for bufsize */\n\t\t\tbreak;\n\n\t\tcase 'a':\n\t\t\tuseactivate = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tusage();\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\n\tif (device == NULL) {\n\t\tif (pcap_findalldevs(&devlist, ebuf) == -1)\n\t\t\terror(\"%s\", ebuf);\n\t\tif (devlist == NULL)\n\t\t\terror(\"no interfaces available for capture\");\n\t\tdevice = strdup(devlist->name);\n\t\tpcap_freealldevs(devlist);\n\t}\n\tif (useactivate) {\n\t\tpd = pcap_create(device, ebuf);\n\t\tif (pd == NULL)\n\t\t\terror(\"%s: pcap_create failed: %s\", device, ebuf);\n\t\tstatus = pcap_set_snaplen(pd, snaplen);\n\t\tif (status != 0)\n\t\t\terror(\"%s: pcap_set_snaplen failed: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t\tif (dopromisc) {\n\t\t\tstatus = pcap_set_promisc(pd, 1);\n\t\t\tif (status != 0)\n\t\t\t\terror(\"%s: pcap_set_promisc failed: %s\",\n\t\t\t\t    device, pcap_statustostr(status));\n\t\t}\n\t\tif (dorfmon) {\n\t\t\tstatus = pcap_set_rfmon(pd, 1);\n\t\t\tif (status != 0)\n\t\t\t\terror(\"%s: pcap_set_rfmon failed: %s\",\n\t\t\t\t    device, pcap_statustostr(status));\n\t\t}\n\t\tstatus = pcap_set_timeout(pd, 1000);\n\t\tif (status != 0)\n\t\t\terror(\"%s: pcap_set_timeout failed: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t\tif (bufsize != 0) {\n\t\t\tstatus = pcap_set_buffer_size(pd, bufsize);\n\t\t\tif (status != 0)\n\t\t\t\terror(\"%s: pcap_set_buffer_size failed: %s\",\n\t\t\t\t    device, pcap_statustostr(status));\n\t\t}\n\t\tstatus = pcap_activate(pd);\n\t\tif (status < 0) {\n\t\t\t/*\n\t\t\t * pcap_activate() failed.\n\t\t\t */\n\t\t\terror(\"%s: %s\\n(%s)\", device,\n\t\t\t    pcap_statustostr(status), pcap_geterr(pd));\n\t\t} else if (status > 0) {\n\t\t\t/*\n\t\t\t * pcap_activate() succeeded, but it's warning us\n\t\t\t * of a problem it had.\n\t\t\t */\n\t\t\twarning(\"%s: %s\\n(%s)\", device,\n\t\t\t    pcap_statustostr(status), pcap_geterr(pd));\n\t\t} else\n\t\t\tprintf(\"%s opened successfully\\n\", device);\n\t} else {\n\t\t*ebuf = '\\0';\n\t\tpd = pcap_open_live(device, 65535, 0, 1000, ebuf);\n\t\tif (pd == NULL)\n\t\t\terror(\"%s\", ebuf);\n\t\telse if (*ebuf)\n\t\t\twarning(\"%s\", ebuf);\n\t\telse\n\t\t\tprintf(\"%s opened successfully\\n\", device);\n\t}\n\tpcap_close(pd);\n\texit(status < 0 ? 1 : 0);\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              196,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\t(void)fprintf(stderr,\n\t    \"Usage: %s [ -Ipa ] [ -i interface ] [ -s snaplen ] [ -B bufsize ]\\n\",\n\t    program_name);\n\texit(1);\n}",
          "fn_code_pos": [
            [
              198,
              0
            ],
            [
              205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nerror(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n\texit(1);\n\t/* NOTREACHED */\n}",
          "fn_code_pos": [
            [
              208,
              0
            ],
            [
              224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "error",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nwarning(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: WARNING: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n}",
          "fn_code_pos": [
            [
              227,
              0
            ],
            [
              241,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "warning",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "PCAP_NORETURN usage(void)",
          "fn_dec_pos": [
            [
              52,
              12
            ],
            [
              52,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PCAP_NORETURN error(const char *, ...)",
          "fn_dec_pos": [
            [
              53,
              12
            ],
            [
              53,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN error",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "warning(const char *, ...)",
          "fn_dec_pos": [
            [
              54,
              12
            ],
            [
              54,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "warning",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"varattrs.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include <pcap.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"getopt.h\"\n",
          [
            35,
            2
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            37,
            2
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include \"pcap/funcattrs.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            44,
            2
          ],
          [
            45,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/testprogs/threadsignaltest.c": {
      "fn_def_list": [
        {
          "fn_code": "static const char *\nwin32_strerror(DWORD error)\n{\n  static char errbuf[ERRBUF_SIZE+1];\n  size_t errlen;\n\n  FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, error, 0, errbuf,\n                ERRBUF_SIZE, NULL);\n\n  /*\n   * \"FormatMessage()\" \"helpfully\" sticks CR/LF at the end of the\n   * message.  Get rid of it.\n   */\n  errlen = strlen(errbuf);\n  if (errlen >= 2) {\n    errbuf[errlen - 1] = '\\0';\n    errbuf[errlen - 2] = '\\0';\n    errlen -= 2;\n  }\n  return errbuf;\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              101,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_strerror",
            "parameters": {
              "error": "DWORD"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static void\ncatch_sigusr1(int sig _U_)\n{\n\tprintf(\"Got SIGUSR1\\n\");\n}",
          "fn_code_pos": [
            [
              103,
              0
            ],
            [
              107,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "catch_sigusr1",
            "parameters": {
              "sig": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nsleep_secs(int secs)\n{\n#ifdef _WIN32\n\tSleep(secs*1000);\n#else\n\tunsigned secs_remaining;\n\n\tif (secs <= 0)\n\t\treturn;\n\tsecs_remaining = secs;\n\twhile (secs_remaining != 0)\n\t\tsecs_remaining = sleep(secs_remaining);\n#endif\n}",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sleep_secs",
            "parameters": {
              "secs": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static THREAD_FUNC_RETURN_TYPE\ncapture_thread_func(THREAD_FUNC_ARG_TYPE arg)\n{\n\tchar *device = arg;\n\tint packet_count;\n\tint status;\n#ifndef _WIN32\n\tstruct sigaction action;\n\tsigset_t mask;\n#endif\n\n#ifndef _WIN32\n\tsigemptyset(&mask);\n\taction.sa_handler = catch_sigusr1;\n\taction.sa_mask = mask;\n\taction.sa_flags = 0;\n\tif (sigaction(SIGUSR1, &action, NULL) == -1)\n\t\terror(\"Can't catch SIGUSR1: %s\", strerror(errno));\n#endif\n\n\tprintf(\"Listening on %s\\n\", device);\n\tfor (;;) {\n\t\tpacket_count = 0;\n\t\tstatus = pcap_dispatch(pd, -1, countme,\n\t\t    (u_char *)&packet_count);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif (status != 0) {\n\t\t\tprintf(\"%d packets seen, %d packets counted after pcap_dispatch returns\\n\",\n\t\t\t    status, packet_count);\n\t\t} else\n\t\t\tprintf(\"No packets seen by pcap_dispatch\\n\");\n\t}\n\tif (status == -2) {\n\t\t/*\n\t\t * We got interrupted, so perhaps we didn't\n\t\t * manage to finish a line we were printing.\n\t\t * Print an extra newline, just in case.\n\t\t */\n\t\tputchar('\\n');\n\t\tprintf(\"Loop got broken\\n\");\n\t}\n\t(void)fflush(stdout);\n\tif (status == -1) {\n\t\t/*\n\t\t * Error.  Report it.\n\t\t */\n\t\t(void)fprintf(stderr, \"%s: pcap_loop: %s\\n\",\n\t\t    program_name, pcap_geterr(pd));\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              126,
              0
            ],
            [
              177,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "capture_thread_func",
            "parameters": {
              "arg": "THREAD_FUNC_ARG_TYPE"
            },
            "return_type": "THREAD_FUNC_RETURN_TYPE"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char **argv)\n{\n\tregister int op;\n\tregister char *cp, *cmdbuf, *device;\n\tint immediate = 0;\n\tpcap_if_t *devlist;\n\tbpf_u_int32 localnet, netmask;\n\tstruct bpf_program fcode;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tint status;\n\tTHREAD_HANDLE capture_thread;\n#ifndef _WIN32\n\tvoid *retval;\n#endif\n\n\tdevice = NULL;\n\tif ((cp = strrchr(argv[0], '/')) != NULL)\n\t\tprogram_name = cp + 1;\n\telse\n\t\tprogram_name = argv[0];\n\n\topterr = 0;\n\twhile ((op = getopt(argc, argv, \"i:\")) != -1) {\n\t\tswitch (op) {\n\n\t\tcase 'i':\n\t\t\tdevice = optarg;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tusage();\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\n\tif (device == NULL) {\n\t\tif (pcap_findalldevs(&devlist, ebuf) == -1)\n\t\t\terror(\"%s\", ebuf);\n\t\tif (devlist == NULL)\n\t\t\terror(\"no interfaces available for capture\");\n\t\tdevice = strdup(devlist->name);\n\t\tpcap_freealldevs(devlist);\n\t}\n\t*ebuf = '\\0';\n\tpd = pcap_create(device, ebuf);\n\tif (pd == NULL)\n\t\terror(\"%s\", ebuf);\n\tstatus = pcap_set_snaplen(pd, 65535);\n\tif (status != 0)\n\t\terror(\"%s: pcap_set_snaplen failed: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\tif (immediate) {\n\t\tstatus = pcap_set_immediate_mode(pd, 1);\n\t\tif (status != 0)\n\t\t\terror(\"%s: pcap_set_immediate_mode failed: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t}\n\tstatus = pcap_set_timeout(pd, 5*60*1000);\n\tif (status != 0)\n\t\terror(\"%s: pcap_set_timeout failed: %s\",\n\t\t    device, pcap_statustostr(status));\n\tstatus = pcap_activate(pd);\n\tif (status < 0) {\n\t\t/*\n\t\t * pcap_activate() failed.\n\t\t */\n\t\terror(\"%s: %s\\n(%s)\", device,\n\t\t    pcap_statustostr(status), pcap_geterr(pd));\n\t} else if (status > 0) {\n\t\t/*\n\t\t * pcap_activate() succeeded, but it's warning us\n\t\t * of a problem it had.\n\t\t */\n\t\twarning(\"%s: %s\\n(%s)\", device,\n\t\t    pcap_statustostr(status), pcap_geterr(pd));\n\t}\n\tif (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0) {\n\t\tlocalnet = 0;\n\t\tnetmask = 0;\n\t\twarning(\"%s\", ebuf);\n\t}\n\tcmdbuf = copy_argv(&argv[optind]);\n\n\tif (pcap_compile(pd, &fcode, cmdbuf, 1, netmask) < 0)\n\t\terror(\"%s\", pcap_geterr(pd));\n\n\tif (pcap_setfilter(pd, &fcode) < 0)\n\t\terror(\"%s\", pcap_geterr(pd));\n\n#ifdef _WIN32\n\tcapture_thread = CreateThread(NULL, 0, capture_thread_func, device,\n\t    0, NULL);\n\tif (capture_thread == NULL)\n\t\terror(\"Can't create capture thread: %s\",\n\t\t    win32_strerror(GetLastError()));\n#else\n\tstatus = pthread_create(&capture_thread, NULL, capture_thread_func,\n\t    device);\n\tif (status != 0)\n\t\terror(\"Can't create capture thread: %s\", strerror(status));\n#endif\n\tsleep_secs(60);\n\tpcap_breakloop(pd);\n#ifdef _WIN32\n\tprintf(\"Setting event\\n\");\n\tif (!SetEvent(pcap_getevent(pd)))\n\t\terror(\"Can't set event for pcap_t: %s\",\n\t\t    win32_strerror(GetLastError()));\n\tif (WaitForSingleObject(capture_thread, INFINITE) == WAIT_FAILED)\n\t\terror(\"Wait for thread termination failed: %s\",\n\t\t    win32_strerror(GetLastError()));\n\tCloseHandle(capture_thread);\n#else\n\tprintf(\"Sending SIGUSR1\\n\");\n\tstatus = pthread_kill(capture_thread, SIGUSR1);\n\tif (status != 0)\n\t\twarning(\"Can't interrupt capture thread: %s\", strerror(status));\n\tstatus = pthread_join(capture_thread, &retval);\n\tif (status != 0)\n\t\terror(\"Wait for thread termination failed: %s\",\n\t\t    strerror(status));\n#endif\n\n\tpcap_close(pd);\n\tpcap_freecode(&fcode);\n\texit(status == -1 ? 1 : 0);\n}",
          "fn_code_pos": [
            [
              179,
              0
            ],
            [
              306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ncountme(u_char *user, const struct pcap_pkthdr *h _U_, const u_char *sp _U_)\n{\n\tint *counterp = (int *)user;\n\n\t(*counterp)++;\n}",
          "fn_code_pos": [
            [
              308,
              0
            ],
            [
              314,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "countme",
            "parameters": {
              "user": "u_char",
              "h": "struct pcap_pkthdr",
              "sp": "u_char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\t(void)fprintf(stderr, \"Usage: %s [ -m ] [ -i interface ] [ -t timeout] [expression]\\n\",\n\t    program_name);\n\texit(1);\n}",
          "fn_code_pos": [
            [
              316,
              0
            ],
            [
              322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nerror(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n\texit(1);\n\t/* NOTREACHED */\n}",
          "fn_code_pos": [
            [
              325,
              0
            ],
            [
              341,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "error",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nwarning(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: WARNING: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n}",
          "fn_code_pos": [
            [
              344,
              0
            ],
            [
              358,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "warning",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static char *\ncopy_argv(register char **argv)\n{\n\tregister char **p;\n\tregister size_t len = 0;\n\tchar *buf;\n\tchar *src, *dst;\n\n\tp = argv;\n\tif (*p == 0)\n\t\treturn 0;\n\n\twhile (*p)\n\t\tlen += strlen(*p++) + 1;\n\n\tbuf = (char *)malloc(len);\n\tif (buf == NULL)\n\t\terror(\"copy_argv: malloc\");\n\n\tp = argv;\n\tdst = buf;\n\twhile ((src = *p++) != NULL) {\n\t\twhile ((*dst++ = *src++) != '\\0')\n\t\t\t;\n\t\tdst[-1] = ' ';\n\t}\n\tdst[-1] = '\\0';\n\n\treturn buf;\n}",
          "fn_code_pos": [
            [
              363,
              0
            ],
            [
              392,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy_argv",
            "parameters": {
              "argv": "char"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "countme(u_char *, const struct pcap_pkthdr *, const u_char *)",
          "fn_dec_pos": [
            [
              66,
              12
            ],
            [
              66,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "countme",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PCAP_NORETURN usage(void)",
          "fn_dec_pos": [
            [
              67,
              12
            ],
            [
              67,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PCAP_NORETURN error(const char *, ...)",
          "fn_dec_pos": [
            [
              68,
              12
            ],
            [
              68,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN error",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "warning(const char *, ...)",
          "fn_dec_pos": [
            [
              69,
              12
            ],
            [
              69,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "warning",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "copy_argv(char **)",
          "fn_dec_pos": [
            [
              70,
              13
            ],
            [
              70,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy_argv",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "win32_strerror(DWORD error)",
          "fn_dec_pos": [
            [
              82,
              0
            ],
            [
              82,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_strerror",
            "parameters": {
              "error": "DWORD"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "copy_argv(register char **argv)",
          "fn_dec_pos": [
            [
              364,
              0
            ],
            [
              364,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy_argv",
            "parameters": {
              "argv": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            66,
            36
          ],
          [
            66,
            54
          ]
        ],
        [
          "struct sigaction",
          {},
          "",
          [
            133,
            1
          ],
          [
            133,
            17
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            187,
            1
          ],
          [
            187,
            19
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            309,
            28
          ],
          [
            309,
            46
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"varattrs.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <winsock2.h>\n",
          [
            35,
            2
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <windows.h>\n",
          [
            36,
            2
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"getopt.h\"\n",
          [
            42,
            2
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <pthread.h>\n",
          [
            44,
            2
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <signal.h>\n",
          [
            45,
            2
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            46,
            2
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <pcap.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include \"pcap/funcattrs.h\"\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            60,
            2
          ],
          [
            61,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/testprogs/capturetest.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char **argv)\n{\n\tregister int op;\n\tregister char *cp, *cmdbuf, *device;\n\tlong longarg;\n\tchar *p;\n\tint timeout = 1000;\n\tint immediate = 0;\n\tint nonblock = 0;\n\tpcap_if_t *devlist;\n\tbpf_u_int32 localnet, netmask;\n\tstruct bpf_program fcode;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tint status;\n\tint packet_count;\n\n\tdevice = NULL;\n\tif ((cp = strrchr(argv[0], '/')) != NULL)\n\t\tprogram_name = cp + 1;\n\telse\n\t\tprogram_name = argv[0];\n\n\topterr = 0;\n\twhile ((op = getopt(argc, argv, \"i:mnt:\")) != -1) {\n\t\tswitch (op) {\n\n\t\tcase 'i':\n\t\t\tdevice = optarg;\n\t\t\tbreak;\n\n\t\tcase 'm':\n\t\t\timmediate = 1;\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tnonblock = 1;\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\tlongarg = strtol(optarg, &p, 10);\n\t\t\tif (p == optarg || *p != '\\0') {\n\t\t\t\terror(\"Timeout value \\\"%s\\\" is not a number\",\n\t\t\t\t    optarg);\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\tif (longarg < 0) {\n\t\t\t\terror(\"Timeout value %ld is negative\", longarg);\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\tif (longarg > INT_MAX) {\n\t\t\t\terror(\"Timeout value %ld is too large (> %d)\",\n\t\t\t\t    longarg, INT_MAX);\n\t\t\t\t/* NOTREACHED */\n\t\t\t}\n\t\t\ttimeout = (int)longarg;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tusage();\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\n\tif (device == NULL) {\n\t\tif (pcap_findalldevs(&devlist, ebuf) == -1)\n\t\t\terror(\"%s\", ebuf);\n\t\tif (devlist == NULL)\n\t\t\terror(\"no interfaces available for capture\");\n\t\tdevice = strdup(devlist->name);\n\t\tpcap_freealldevs(devlist);\n\t}\n\t*ebuf = '\\0';\n\tpd = pcap_create(device, ebuf);\n\tif (pd == NULL)\n\t\terror(\"%s\", ebuf);\n\tstatus = pcap_set_snaplen(pd, 65535);\n\tif (status != 0)\n\t\terror(\"%s: pcap_set_snaplen failed: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\tif (immediate) {\n\t\tstatus = pcap_set_immediate_mode(pd, 1);\n\t\tif (status != 0)\n\t\t\terror(\"%s: pcap_set_immediate_mode failed: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t}\n\tstatus = pcap_set_timeout(pd, timeout);\n\tif (status != 0)\n\t\terror(\"%s: pcap_set_timeout failed: %s\",\n\t\t    device, pcap_statustostr(status));\n\tstatus = pcap_activate(pd);\n\tif (status < 0) {\n\t\t/*\n\t\t * pcap_activate() failed.\n\t\t */\n\t\terror(\"%s: %s\\n(%s)\", device,\n\t\t    pcap_statustostr(status), pcap_geterr(pd));\n\t} else if (status > 0) {\n\t\t/*\n\t\t * pcap_activate() succeeded, but it's warning us\n\t\t * of a problem it had.\n\t\t */\n\t\twarning(\"%s: %s\\n(%s)\", device,\n\t\t    pcap_statustostr(status), pcap_geterr(pd));\n\t}\n\tif (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0) {\n\t\tlocalnet = 0;\n\t\tnetmask = 0;\n\t\twarning(\"%s\", ebuf);\n\t}\n\tcmdbuf = copy_argv(&argv[optind]);\n\n\tif (pcap_compile(pd, &fcode, cmdbuf, 1, netmask) < 0)\n\t\terror(\"%s\", pcap_geterr(pd));\n\n\tif (pcap_setfilter(pd, &fcode) < 0)\n\t\terror(\"%s\", pcap_geterr(pd));\n\tif (pcap_setnonblock(pd, nonblock, ebuf) == -1)\n\t\terror(\"pcap_setnonblock failed: %s\", ebuf);\n\tprintf(\"Listening on %s\\n\", device);\n\tfor (;;) {\n\t\tpacket_count = 0;\n\t\tstatus = pcap_dispatch(pd, -1, countme,\n\t\t    (u_char *)&packet_count);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tif (status != 0) {\n\t\t\tprintf(\"%d packets seen, %d packets counted after pcap_dispatch returns\\n\",\n\t\t\t    status, packet_count);\n\t\t}\n\t}\n\tif (status == -2) {\n\t\t/*\n\t\t * We got interrupted, so perhaps we didn't\n\t\t * manage to finish a line we were printing.\n\t\t * Print an extra newline, just in case.\n\t\t */\n\t\tputchar('\\n');\n\t}\n\t(void)fflush(stdout);\n\tif (status == -1) {\n\t\t/*\n\t\t * Error.  Report it.\n\t\t */\n\t\t(void)fprintf(stderr, \"%s: pcap_loop: %s\\n\",\n\t\t    program_name, pcap_geterr(pd));\n\t}\n\tpcap_close(pd);\n\tpcap_freecode(&fcode);\n\tfree(cmdbuf);\n\texit(status == -1 ? 1 : 0);\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              212,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ncountme(u_char *user, const struct pcap_pkthdr *h _U_, const u_char *sp _U_)\n{\n\tint *counterp = (int *)user;\n\n\t(*counterp)++;\n}",
          "fn_code_pos": [
            [
              214,
              0
            ],
            [
              220,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "countme",
            "parameters": {
              "user": "u_char",
              "h": "struct pcap_pkthdr",
              "sp": "u_char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\t(void)fprintf(stderr, \"Usage: %s [ -mn ] [ -i interface ] [ -t timeout] [expression]\\n\",\n\t    program_name);\n\texit(1);\n}",
          "fn_code_pos": [
            [
              222,
              0
            ],
            [
              228,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nerror(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n\texit(1);\n\t/* NOTREACHED */\n}",
          "fn_code_pos": [
            [
              231,
              0
            ],
            [
              247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "error",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nwarning(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: WARNING: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n}",
          "fn_code_pos": [
            [
              250,
              0
            ],
            [
              264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "warning",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static char *\ncopy_argv(register char **argv)\n{\n\tregister char **p;\n\tregister size_t len = 0;\n\tchar *buf;\n\tchar *src, *dst;\n\n\tp = argv;\n\tif (*p == 0)\n\t\treturn 0;\n\n\twhile (*p)\n\t\tlen += strlen(*p++) + 1;\n\n\tbuf = (char *)malloc(len);\n\tif (buf == NULL)\n\t\terror(\"copy_argv: malloc\");\n\n\tp = argv;\n\tdst = buf;\n\twhile ((src = *p++) != NULL) {\n\t\twhile ((*dst++ = *src++) != '\\0')\n\t\t\t;\n\t\tdst[-1] = ' ';\n\t}\n\tdst[-1] = '\\0';\n\n\treturn buf;\n}",
          "fn_code_pos": [
            [
              269,
              0
            ],
            [
              298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy_argv",
            "parameters": {
              "argv": "char"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "countme(u_char *, const struct pcap_pkthdr *, const u_char *)",
          "fn_dec_pos": [
            [
              53,
              12
            ],
            [
              53,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "countme",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PCAP_NORETURN usage(void)",
          "fn_dec_pos": [
            [
              54,
              12
            ],
            [
              54,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PCAP_NORETURN error(const char *, ...)",
          "fn_dec_pos": [
            [
              55,
              12
            ],
            [
              55,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN error",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "warning(const char *, ...)",
          "fn_dec_pos": [
            [
              56,
              12
            ],
            [
              56,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "warning",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "copy_argv(char **)",
          "fn_dec_pos": [
            [
              57,
              13
            ],
            [
              57,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy_argv",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "copy_argv(register char **argv)",
          "fn_dec_pos": [
            [
              270,
              0
            ],
            [
              270,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy_argv",
            "parameters": {
              "argv": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            53,
            36
          ],
          [
            53,
            54
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            73,
            1
          ],
          [
            73,
            19
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            215,
            28
          ],
          [
            215,
            46
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"varattrs.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"getopt.h\"\n",
          [
            35,
            2
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            37,
            2
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <pcap.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"pcap/funcattrs.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            47,
            2
          ],
          [
            48,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/testprogs/filtertest.c": {
      "fn_def_list": [
        {
          "fn_code": "static char *\nread_infile(char *fname)\n{\n\tregister int i, fd, cc;\n\tregister char *cp;\n\tstruct stat buf;\n\n\tfd = open(fname, O_RDONLY|O_BINARY);\n\tif (fd < 0)\n\t\terror(\"can't open %s: %s\", fname, pcap_strerror(errno));\n\n\tif (fstat(fd, &buf) < 0)\n\t\terror(\"can't stat %s: %s\", fname, pcap_strerror(errno));\n\n\t/*\n\t * _read(), on Windows, has an unsigned int byte count and an\n\t * int return value, so we can't handle a file bigger than\n\t * INT_MAX - 1 bytes (and have no reason to do so; a filter *that*\n\t * big will take forever to compile).  (The -1 is for the '\\0' at\n\t * the end of the string.)\n\t */\n\tif (buf.st_size > INT_MAX - 1)\n\t\terror(\"%s is larger than %d bytes; that's too large\", fname,\n\t\t    INT_MAX - 1);\n\tcp = malloc((u_int)buf.st_size + 1);\n\tif (cp == NULL)\n\t\terror(\"malloc(%d) for %s: %s\", (u_int)buf.st_size + 1,\n\t\t\tfname, pcap_strerror(errno));\n\tcc = (int)read(fd, cp, (u_int)buf.st_size);\n\tif (cc < 0)\n\t\terror(\"read %s: %s\", fname, pcap_strerror(errno));\n\tif (cc != buf.st_size)\n\t\terror(\"short read %s (%d != %d)\", fname, cc, (int)buf.st_size);\n\n\tclose(fd);\n\t/* replace \"# comment\" with spaces */\n\tfor (i = 0; i < cc; i++) {\n\t\tif (cp[i] == '#')\n\t\t\twhile (i < cc && cp[i] != '\\n')\n\t\t\t\tcp[i++] = ' ';\n\t}\n\tcp[cc] = '\\0';\n\treturn (cp);\n}",
          "fn_code_pos": [
            [
              90,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_infile",
            "parameters": {
              "fname": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static void\nerror(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n\texit(1);\n\t/* NOTREACHED */\n}",
          "fn_code_pos": [
            [
              136,
              0
            ],
            [
              152,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "error",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nwarn(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: WARNING: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n}",
          "fn_code_pos": [
            [
              155,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "warn",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static char *\ncopy_argv(register char **argv)\n{\n\tregister char **p;\n\tregister size_t len = 0;\n\tchar *buf;\n\tchar *src, *dst;\n\n\tp = argv;\n\tif (*p == 0)\n\t\treturn 0;\n\n\twhile (*p)\n\t\tlen += strlen(*p++) + 1;\n\n\tbuf = (char *)malloc(len);\n\tif (buf == NULL)\n\t\terror(\"copy_argv: malloc\");\n\n\tp = argv;\n\tdst = buf;\n\twhile ((src = *p++) != NULL) {\n\t\twhile ((*dst++ = *src++) != '\\0')\n\t\t\t;\n\t\tdst[-1] = ' ';\n\t}\n\tdst[-1] = '\\0';\n\n\treturn buf;\n}",
          "fn_code_pos": [
            [
              174,
              0
            ],
            [
              203,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy_argv",
            "parameters": {
              "argv": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char **argv)\n{\n\tchar *cp;\n\tint op;\n\tint dflag;\n#ifdef BDEBUG\n\tint gflag;\n#endif\n\tchar *infile;\n\tint Oflag;\n\tint snaplen;\n\tchar *p;\n\tint dlt;\n\tint have_fcode = 0;\n\tbpf_u_int32 netmask = PCAP_NETMASK_UNKNOWN;\n\tchar *cmdbuf;\n\tpcap_t *pd;\n\tstruct bpf_program fcode;\n\n#ifdef _WIN32\n\tif (pcap_wsockinit() != 0)\n\t\treturn 1;\n#endif /* _WIN32 */\n\n\tdflag = 1;\n#ifdef BDEBUG\n\tgflag = 0;\n#endif\n\n\tinfile = NULL;\n\tOflag = 1;\n\tsnaplen = MAXIMUM_SNAPLEN;\n\n\tif ((cp = strrchr(argv[0], '/')) != NULL)\n\t\tprogram_name = cp + 1;\n\telse\n\t\tprogram_name = argv[0];\n\n\topterr = 0;\n\twhile ((op = getopt(argc, argv, \"dF:gm:Os:\")) != -1) {\n\t\tswitch (op) {\n\n\t\tcase 'd':\n\t\t\t++dflag;\n\t\t\tbreak;\n\n\t\tcase 'g':\n#ifdef BDEBUG\n\t\t\t++gflag;\n#else\n\t\t\terror(\"libpcap and filtertest not built with optimizer debugging enabled\");\n#endif\n\t\t\tbreak;\n\n\t\tcase 'F':\n\t\t\tinfile = optarg;\n\t\t\tbreak;\n\n\t\tcase 'O':\n\t\t\tOflag = 0;\n\t\t\tbreak;\n\n\t\tcase 'm': {\n\t\t\tbpf_u_int32 addr;\n\n\t\t\tswitch (inet_pton(AF_INET, optarg, &addr)) {\n\n\t\t\tcase 0:\n\t\t\t\terror(\"invalid netmask %s\", optarg);\n\t\t\t\tbreak;\n\n\t\t\tcase -1:\n\t\t\t\terror(\"invalid netmask %s: %s\", optarg,\n\t\t\t\t    pcap_strerror(errno));\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tnetmask = addr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 's': {\n\t\t\tchar *end;\n\t\t\tlong long_snaplen;\n\n\t\t\tlong_snaplen = strtol(optarg, &end, 0);\n\t\t\tif (optarg == end || *end != '\\0'\n\t\t\t    || long_snaplen < 0\n\t\t\t    || long_snaplen > MAXIMUM_SNAPLEN)\n\t\t\t\terror(\"invalid snaplen %s\", optarg);\n\t\t\telse {\n\t\t\t\tif (snaplen == 0)\n\t\t\t\t\tsnaplen = MAXIMUM_SNAPLEN;\n\t\t\t\telse\n\t\t\t\t\tsnaplen = (int)long_snaplen;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tusage();\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\n\tif (optind >= argc) {\n\t\tusage();\n\t\t/* NOTREACHED */\n\t}\n\n\tdlt = pcap_datalink_name_to_val(argv[optind]);\n\tif (dlt < 0) {\n\t\tdlt = (int)strtol(argv[optind], &p, 10);\n\t\tif (p == argv[optind] || *p != '\\0')\n\t\t\terror(\"invalid data link type %s\", argv[optind]);\n\t}\n\n\tif (infile)\n\t\tcmdbuf = read_infile(infile);\n\telse\n\t\tcmdbuf = copy_argv(&argv[optind+1]);\n\n#ifdef BDEBUG\n\tpcap_set_optimizer_debug(dflag);\n\tpcap_set_print_dot_graph(gflag);\n#endif\n\n\tpd = pcap_open_dead(dlt, snaplen);\n\tif (pd == NULL)\n\t\terror(\"Can't open fake pcap_t\");\n\n\tif (pcap_compile(pd, &fcode, cmdbuf, Oflag, netmask) < 0)\n\t\terror(\"%s\", pcap_geterr(pd));\n\n\thave_fcode = 1;\n\tif (!bpf_validate(fcode.bf_insns, fcode.bf_len))\n\t\twarn(\"Filter doesn't pass validation\");\n\n#ifdef BDEBUG\n\tif (cmdbuf != NULL) {\n\t\t// replace line feed with space\n\t\tfor (cp = cmdbuf; *cp != '\\0'; ++cp) {\n\t\t\tif (*cp == '\\r' || *cp == '\\n') {\n\t\t\t\t*cp = ' ';\n\t\t\t}\n\t\t}\n\t\t// only show machine code if BDEBUG defined, since dflag > 3\n\t\tprintf(\"machine codes for filter: %s\\n\", cmdbuf);\n\t} else\n\t\tprintf(\"machine codes for empty filter:\\n\");\n#endif\n\n\tbpf_dump(&fcode, dflag);\n\tfree(cmdbuf);\n\tif (have_fcode)\n\t\tpcap_freecode (&fcode);\n\tpcap_close(pd);\n\texit(0);\n}",
          "fn_code_pos": [
            [
              205,
              0
            ],
            [
              366,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\t(void)fprintf(stderr, \"%s, with %s\\n\", program_name,\n\t    pcap_lib_version());\n\t(void)fprintf(stderr,\n#ifdef BDEBUG\n\t    \"Usage: %s [-dgO] [ -F file ] [ -m netmask] [ -s snaplen ] dlt [ expression ]\\n\",\n#else\n\t    \"Usage: %s [-dO] [ -F file ] [ -m netmask] [ -s snaplen ] dlt [ expression ]\\n\",\n#endif\n\t    program_name);\n\texit(1);\n}",
          "fn_code_pos": [
            [
              368,
              0
            ],
            [
              381,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "pcap_set_optimizer_debug(int)",
          "fn_dec_pos": [
            [
              69,
              14
            ],
            [
              69,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_optimizer_debug",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_set_print_dot_graph(int)",
          "fn_dec_pos": [
            [
              70,
              14
            ],
            [
              70,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_print_dot_graph",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "PCAP_NORETURN usage(void)",
          "fn_dec_pos": [
            [
              76,
              12
            ],
            [
              76,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PCAP_NORETURN error(const char *, ...)",
          "fn_dec_pos": [
            [
              77,
              12
            ],
            [
              77,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN error",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "warn(const char *, ...)",
          "fn_dec_pos": [
            [
              78,
              12
            ],
            [
              78,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "warn",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "read_infile(char *fname)",
          "fn_dec_pos": [
            [
              91,
              0
            ],
            [
              91,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_infile",
            "parameters": {
              "fname": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "copy_argv(register char **argv)",
          "fn_dec_pos": [
            [
              175,
              0
            ],
            [
              175,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy_argv",
            "parameters": {
              "argv": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct stat",
          {},
          "",
          [
            95,
            1
          ],
          [
            95,
            12
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            223,
            1
          ],
          [
            223,
            19
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"varattrs.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include <config.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <pcap.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include \"getopt.h\"\n",
          [
            40,
            2
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"unix.h\"\n",
          [
            41,
            2
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            43,
            2
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <winsock2.h>\n",
          [
            48,
            2
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <ws2tcpip.h>\n",
          [
            49,
            2
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            51,
            2
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include <arpa/inet.h>\n",
          [
            52,
            2
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <sys/stat.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include \"pcap/funcattrs.h\"\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/testprogs/valgrindtest.c": {
      "fn_def_list": [
        {
          "fn_code": "static char *\nread_infile(char *fname)\n{\n\tregister int i, fd, cc;\n\tregister char *cp;\n\tstruct stat buf;\n\n\tfd = open(fname, O_RDONLY|O_BINARY);\n\tif (fd < 0)\n\t\terror(\"can't open %s: %s\", fname, pcap_strerror(errno));\n\n\tif (fstat(fd, &buf) < 0)\n\t\terror(\"can't stat %s: %s\", fname, pcap_strerror(errno));\n\n\t/*\n\t * _read(), on Windows, has an unsigned int byte count and an\n\t * int return value, so we can't handle a file bigger than\n\t * INT_MAX - 1 bytes (and have no reason to do so; a filter *that*\n\t * big will take forever to compile).  (The -1 is for the '\\0' at\n\t * the end of the string.)\n\t */\n\tif (buf.st_size > INT_MAX - 1)\n\t\terror(\"%s is larger than %d bytes; that's too large\", fname,\n\t\t    INT_MAX - 1);\n\tcp = malloc((u_int)buf.st_size + 1);\n\tif (cp == NULL)\n\t\terror(\"malloc(%d) for %s: %s\", (u_int)buf.st_size + 1,\n\t\t\tfname, pcap_strerror(errno));\n\tcc = (int)read(fd, cp, (u_int)buf.st_size);\n\tif (cc < 0)\n\t\terror(\"read %s: %s\", fname, pcap_strerror(errno));\n\tif (cc != buf.st_size)\n\t\terror(\"short read %s (%d != %d)\", fname, cc, (int)buf.st_size);\n\n\tclose(fd);\n\t/* replace \"# comment\" with spaces */\n\tfor (i = 0; i < cc; i++) {\n\t\tif (cp[i] == '#')\n\t\t\twhile (i < cc && cp[i] != '\\n')\n\t\t\t\tcp[i++] = ' ';\n\t}\n\tcp[cc] = '\\0';\n\treturn (cp);\n}",
          "fn_code_pos": [
            [
              138,
              0
            ],
            [
              181,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_infile",
            "parameters": {
              "fname": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static void\nerror(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n\texit(1);\n\t/* NOTREACHED */\n}",
          "fn_code_pos": [
            [
              184,
              0
            ],
            [
              200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "error",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nwarning(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: WARNING: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              217,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "warning",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static char *\ncopy_argv(register char **argv)\n{\n\tregister char **p;\n\tregister size_t len = 0;\n\tchar *buf;\n\tchar *src, *dst;\n\n\tp = argv;\n\tif (*p == 0)\n\t\treturn 0;\n\n\twhile (*p)\n\t\tlen += strlen(*p++) + 1;\n\n\tbuf = (char *)malloc(len);\n\tif (buf == NULL)\n\t\terror(\"copy_argv: malloc\");\n\n\tp = argv;\n\tdst = buf;\n\twhile ((src = *p++) != NULL) {\n\t\twhile ((*dst++ = *src++) != '\\0')\n\t\t\t;\n\t\tdst[-1] = ' ';\n\t}\n\tdst[-1] = '\\0';\n\n\treturn buf;\n}",
          "fn_code_pos": [
            [
              222,
              0
            ],
            [
              251,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy_argv",
            "parameters": {
              "argv": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char **argv)\n{\n\tchar *cp, *device;\n\tint op;\n\tint dorfmon, useactivate;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tchar *infile;\n\tconst char *cmdbuf;\n\tpcap_if_t *devlist;\n\tpcap_t *pd;\n\tint status = 0;\n\tint pcap_fd;\n#if defined(USE_BPF)\n\tstruct bpf_program bad_fcode;\n\tstruct bpf_insn uninitialized[INSN_COUNT];\n#elif defined(USE_SOCKET_FILTERS)\n\tstruct sock_fprog bad_fcode;\n\tstruct sock_filter uninitialized[INSN_COUNT];\n#endif\n\tstruct bpf_program fcode;\n\n\tdevice = NULL;\n\tdorfmon = 0;\n\tuseactivate = 0;\n\tinfile = NULL;\n\n\tif ((cp = strrchr(argv[0], '/')) != NULL)\n\t\tprogram_name = cp + 1;\n\telse\n\t\tprogram_name = argv[0];\n\n\topterr = 0;\n\twhile ((op = getopt(argc, argv, \"aF:i:I\")) != -1) {\n\t\tswitch (op) {\n\n\t\tcase 'a':\n\t\t\tuseactivate = 1;\n\t\t\tbreak;\n\n\t\tcase 'F':\n\t\t\tinfile = optarg;\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\tdevice = optarg;\n\t\t\tbreak;\n\n\t\tcase 'I':\n\t\t\tdorfmon = 1;\n\t\t\tuseactivate = 1;\t/* required for rfmon */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tusage();\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\n\tif (device == NULL) {\n\t\t/*\n\t\t * No interface specified; get whatever pcap_lookupdev()\n\t\t * finds.\n\t\t */\n\t\tif (pcap_findalldevs(&devlist, ebuf) == -1)\n\t\t\terror(\"%s\", ebuf);\n\t\tif (devlist == NULL)\n\t\t\terror(\"no interfaces available for capture\");\n\t\tdevice = strdup(devlist->name);\n\t\tpcap_freealldevs(devlist);\n\t}\n\n\tif (infile != NULL) {\n\t\t/*\n\t\t * Filter specified with \"-F\" and a file containing\n\t\t * a filter.\n\t\t */\n\t\tcmdbuf = read_infile(infile);\n\t} else {\n\t\tif (optind < argc) {\n\t\t\t/*\n\t\t\t * Filter specified with arguments on the\n\t\t\t * command line.\n\t\t\t */\n\t\t\tcmdbuf = copy_argv(&argv[optind+1]);\n\t\t} else {\n\t\t\t/*\n\t\t\t * No filter specified; use an empty string, which\n\t\t\t * compiles to an \"accept all\" filter.\n\t\t\t */\n\t\t\tcmdbuf = \"\";\n\t\t}\n\t}\n\n\tif (useactivate) {\n\t\tpd = pcap_create(device, ebuf);\n\t\tif (pd == NULL)\n\t\t\terror(\"%s: pcap_create() failed: %s\", device, ebuf);\n\t\tstatus = pcap_set_snaplen(pd, 65535);\n\t\tif (status != 0)\n\t\t\terror(\"%s: pcap_set_snaplen failed: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t\tstatus = pcap_set_promisc(pd, 1);\n\t\tif (status != 0)\n\t\t\terror(\"%s: pcap_set_promisc failed: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t\tif (dorfmon) {\n\t\t\tstatus = pcap_set_rfmon(pd, 1);\n\t\t\tif (status != 0)\n\t\t\t\terror(\"%s: pcap_set_rfmon failed: %s\",\n\t\t\t\t    device, pcap_statustostr(status));\n\t\t}\n\t\tstatus = pcap_set_timeout(pd, 1000);\n\t\tif (status != 0)\n\t\t\terror(\"%s: pcap_set_timeout failed: %s\",\n\t\t\t    device, pcap_statustostr(status));\n\t\tstatus = pcap_activate(pd);\n\t\tif (status < 0) {\n\t\t\t/*\n\t\t\t * pcap_activate() failed.\n\t\t\t */\n\t\t\terror(\"%s: %s\\n(%s)\", device,\n\t\t\t    pcap_statustostr(status), pcap_geterr(pd));\n\t\t} else if (status > 0) {\n\t\t\t/*\n\t\t\t * pcap_activate() succeeded, but it's warning us\n\t\t\t * of a problem it had.\n\t\t\t */\n\t\t\twarning(\"%s: %s\\n(%s)\", device,\n\t\t\t    pcap_statustostr(status), pcap_geterr(pd));\n\t\t}\n\t} else {\n\t\t*ebuf = '\\0';\n\t\tpd = pcap_open_live(device, 65535, 1, 1000, ebuf);\n\t\tif (pd == NULL)\n\t\t\terror(\"%s\", ebuf);\n\t\telse if (*ebuf)\n\t\t\twarning(\"%s\", ebuf);\n\t}\n\n\tpcap_fd = pcap_fileno(pd);\n\n\t/*\n\t * Try setting a filter with an uninitialized bpf_program\n\t * structure.  This should cause valgrind to report a\n\t * problem.\n\t *\n\t * We don't check for errors, because it could get an\n\t * error due to a bad pointer or count.\n\t */\n#if defined(USE_BPF)\n\tioctl(pcap_fd, BIOCSETF, &bad_fcode);\n#elif defined(USE_SOCKET_FILTERS)\n\tsetsockopt(pcap_fd, SOL_SOCKET, SO_ATTACH_FILTER, &bad_fcode,\n\t    sizeof(bad_fcode));\n#endif\n\n\t/*\n\t * Try setting a filter with an initialized bpf_program\n\t * structure that points to an uninitialized program.\n\t * That should also cause valgrind to report a problem.\n\t *\n\t * We don't check for errors, because it could get an\n\t * error due to a bad pointer or count.\n\t */\n#if defined(USE_BPF)\n\tbad_fcode.bf_len = INSN_COUNT;\n\tbad_fcode.bf_insns = uninitialized;\n\tioctl(pcap_fd, BIOCSETF, &bad_fcode);\n#elif defined(USE_SOCKET_FILTERS)\n\tbad_fcode.len = INSN_COUNT;\n\tbad_fcode.filter = uninitialized;\n\tsetsockopt(pcap_fd, SOL_SOCKET, SO_ATTACH_FILTER, &bad_fcode,\n\t    sizeof(bad_fcode));\n#endif\n\n\t/*\n\t * Now compile a filter and set the filter with that.\n\t * That should *not* cause valgrind to report a\n\t * problem.\n\t */\n\tif (pcap_compile(pd, &fcode, cmdbuf, 1, 0) < 0)\n\t\terror(\"can't compile filter: %s\", pcap_geterr(pd));\n\tif (pcap_setfilter(pd, &fcode) < 0)\n\t\terror(\"can't set filter: %s\", pcap_geterr(pd));\n\n\tpcap_close(pd);\n\texit(status < 0 ? 1 : 0);\n}",
          "fn_code_pos": [
            [
              255,
              0
            ],
            [
              443,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\t(void)fprintf(stderr, \"%s, with %s\\n\", program_name,\n\t    pcap_lib_version());\n\t(void)fprintf(stderr,\n\t    \"Usage: %s [-aI] [ -F file ] [ -I interface ] [ expression ]\\n\",\n\t    program_name);\n\texit(1);\n}",
          "fn_code_pos": [
            [
              445,
              0
            ],
            [
              454,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "PCAP_NORETURN usage(void)",
          "fn_dec_pos": [
            [
              124,
              12
            ],
            [
              124,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PCAP_NORETURN error(const char *, ...)",
          "fn_dec_pos": [
            [
              125,
              12
            ],
            [
              125,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN error",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "warning(const char *, ...)",
          "fn_dec_pos": [
            [
              126,
              12
            ],
            [
              126,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "warning",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "read_infile(char *fname)",
          "fn_dec_pos": [
            [
              139,
              0
            ],
            [
              139,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_infile",
            "parameters": {
              "fname": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "copy_argv(register char **argv)",
          "fn_dec_pos": [
            [
              223,
              0
            ],
            [
              223,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy_argv",
            "parameters": {
              "argv": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct stat",
          {},
          "",
          [
            143,
            1
          ],
          [
            143,
            12
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            269,
            1
          ],
          [
            269,
            19
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            270,
            1
          ],
          [
            270,
            16
          ]
        ],
        [
          "struct sock_fprog",
          {},
          "",
          [
            272,
            1
          ],
          [
            272,
            18
          ]
        ],
        [
          "struct sock_filter",
          {},
          "",
          [
            273,
            1
          ],
          [
            273,
            19
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            275,
            1
          ],
          [
            275,
            19
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"varattrs.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include <config.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            62,
            0
          ],
          [
            63,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ],
        [
          "#include <arpa/inet.h>\n",
          [
            65,
            0
          ],
          [
            66,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            66,
            0
          ],
          [
            67,
            0
          ]
        ],
        [
          "#include <sys/stat.h>\n",
          [
            67,
            0
          ],
          [
            68,
            0
          ]
        ],
        [
          "#include \"pcap/funcattrs.h\"\n",
          [
            69,
            0
          ],
          [
            70,
            0
          ]
        ],
        [
          "#include <sys/ioctl.h>\n",
          [
            83,
            0
          ],
          [
            84,
            0
          ]
        ],
        [
          "#include <net/bpf.h>\n",
          [
            84,
            0
          ],
          [
            85,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            96,
            0
          ],
          [
            97,
            0
          ]
        ],
        [
          "#include <linux/types.h>\n",
          [
            97,
            0
          ],
          [
            98,
            0
          ]
        ],
        [
          "#include <linux/filter.h>\n",
          [
            98,
            0
          ],
          [
            99,
            0
          ]
        ],
        [
          "#include <pcap.h>\n",
          [
            119,
            0
          ],
          [
            120,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/testprogs/selpolltest.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char **argv)\n{\n\tregister int op;\n\tbpf_u_int32 localnet, netmask;\n\tregister char *cp, *cmdbuf, *device;\n\tint doselect, dopoll, dotimeout, dononblock;\n\tconst char *mechanism;\n\tstruct bpf_program fcode;\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tpcap_if_t *devlist;\n\tint selectable_fd;\n\tstruct timeval *required_timeout;\n\tint status;\n\tint packet_count;\n\n\tdevice = NULL;\n\tdoselect = 0;\n\tdopoll = 0;\n\tmechanism = NULL;\n\tdotimeout = 0;\n\tdononblock = 0;\n\tif ((cp = strrchr(argv[0], '/')) != NULL)\n\t\tprogram_name = cp + 1;\n\telse\n\t\tprogram_name = argv[0];\n\n\topterr = 0;\n\twhile ((op = getopt(argc, argv, \"i:sptn\")) != -1) {\n\t\tswitch (op) {\n\n\t\tcase 'i':\n\t\t\tdevice = optarg;\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tdoselect = 1;\n\t\t\tmechanism = \"select() and pcap_dispatch()\";\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tdopoll = 1;\n\t\t\tmechanism = \"poll() and pcap_dispatch()\";\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\tdotimeout = 1;\n\t\t\tbreak;\n\n\t\tcase 'n':\n\t\t\tdononblock = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tusage();\n\t\t\t/* NOTREACHED */\n\t\t}\n\t}\n\n\tif (doselect && dopoll) {\n\t\tfprintf(stderr, \"selpolltest: choose select (-s) or poll (-p), but not both\\n\");\n\t\treturn 1;\n\t}\n\tif (dotimeout && !doselect && !dopoll) {\n\t\tfprintf(stderr, \"selpolltest: timeout (-t) requires select (-s) or poll (-p)\\n\");\n\t\treturn 1;\n\t}\n\tif (device == NULL) {\n\t\tif (pcap_findalldevs(&devlist, ebuf) == -1)\n\t\t\terror(\"%s\", ebuf);\n\t\tif (devlist == NULL)\n\t\t\terror(\"no interfaces available for capture\");\n\t\tdevice = strdup(devlist->name);\n\t\tpcap_freealldevs(devlist);\n\t}\n\t*ebuf = '\\0';\n\tpd = pcap_open_live(device, 65535, 0, 1000, ebuf);\n\tif (pd == NULL)\n\t\terror(\"%s\", ebuf);\n\telse if (*ebuf)\n\t\twarning(\"%s\", ebuf);\n\tif (pcap_lookupnet(device, &localnet, &netmask, ebuf) < 0) {\n\t\tlocalnet = 0;\n\t\tnetmask = 0;\n\t\twarning(\"%s\", ebuf);\n\t}\n\tcmdbuf = copy_argv(&argv[optind]);\n\n\tif (pcap_compile(pd, &fcode, cmdbuf, 1, netmask) < 0)\n\t\terror(\"%s\", pcap_geterr(pd));\n\tif (pcap_setfilter(pd, &fcode) < 0)\n\t\terror(\"%s\", pcap_geterr(pd));\n\n\tif (doselect || dopoll) {\n\t\t/*\n\t\t * We need either an FD on which to do select()/poll()\n\t\t * or, if there isn't one, a timeout to use in select()/\n\t\t * poll().\n\t\t */\n\t\tselectable_fd = pcap_get_selectable_fd(pd);\n\t\tif (selectable_fd == -1) {\n\t\t\tprintf(\"Listening on %s, using %s, with a timeout\\n\",\n\t\t\t    device, mechanism);\n\t\t\trequired_timeout = pcap_get_required_select_timeout(pd);\n\t\t\tif (required_timeout == NULL)\n\t\t\t\terror(\"select()/poll() isn't supported on %s, even with a timeout\",\n\t\t\t\t    device);\n\n\t\t\t/*\n\t\t\t * As we won't be notified by select() or poll()\n\t\t\t * that a read can be done, we'll have to periodically\n\t\t\t * try reading from the device every time the required\n\t\t\t * timeout expires, and we don't want those attempts\n\t\t\t * to block if nothing has arrived in that interval,\n\t\t\t * so we want to force non-blocking mode.\n\t\t\t */\n\t\t\tdononblock = 1;\n\t\t} else {\n\t\t\tprintf(\"Listening on %s, using %s\\n\", device,\n\t\t\t    mechanism);\n\t\t\trequired_timeout = NULL;\n\t\t}\n\t} else\n\t\tprintf(\"Listening on %s, using pcap_dispatch()\\n\", device);\n\n\tif (dononblock) {\n\t\tif (pcap_setnonblock(pd, 1, ebuf) == -1)\n\t\t\terror(\"pcap_setnonblock failed: %s\", ebuf);\n\t}\n\tif (doselect) {\n\t\tfor (;;) {\n\t\t\tfd_set setread, setexcept;\n\t\t\tstruct timeval seltimeout;\n\n\t\t\tFD_ZERO(&setread);\n\t\t\tif (selectable_fd != -1) {\n\t\t\t\tFD_SET(selectable_fd, &setread);\n\t\t\t\tFD_ZERO(&setexcept);\n\t\t\t\tFD_SET(selectable_fd, &setexcept);\n\t\t\t}\n\t\t\tif (dotimeout) {\n\t\t\t\tseltimeout.tv_sec = 0;\n\t\t\t\tif (required_timeout != NULL &&\n\t\t\t\t    required_timeout->tv_usec < 1000)\n\t\t\t\t\tseltimeout.tv_usec = required_timeout->tv_usec;\n\t\t\t\telse\n\t\t\t\t\tseltimeout.tv_usec = 1000;\n\t\t\t\tstatus = select(selectable_fd + 1, &setread,\n\t\t\t\t    NULL, &setexcept, &seltimeout);\n\t\t\t} else if (required_timeout != NULL) {\n\t\t\t\tseltimeout = *required_timeout;\n\t\t\t\tstatus = select(selectable_fd + 1, &setread,\n\t\t\t\t    NULL, &setexcept, &seltimeout);\n\t\t\t} else {\n\t\t\t\tstatus = select((selectable_fd == -1) ?\n\t\t\t\t    0 : selectable_fd + 1, &setread,\n\t\t\t\t    NULL, &setexcept, NULL);\n\t\t\t}\n\t\t\tif (status == -1) {\n\t\t\t\tprintf(\"Select returns error (%s)\\n\",\n\t\t\t\t    strerror(errno));\n\t\t\t} else {\n\t\t\t\tif (selectable_fd == -1) {\n\t\t\t\t\tif (status != 0)\n\t\t\t\t\t\tprintf(\"Select returned a descriptor\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (status == 0)\n\t\t\t\t\t\tprintf(\"Select timed out: \");\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"Select returned a descriptor: \");\n\t\t\t\t\tif (FD_ISSET(selectable_fd, &setread))\n\t\t\t\t\t\tprintf(\"readable, \");\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"not readable, \");\n\t\t\t\t\tif (FD_ISSET(selectable_fd, &setexcept))\n\t\t\t\t\t\tprintf(\"exceptional condition\\n\");\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\"no exceptional condition\\n\");\n\t\t\t\t}\n\t\t\t\tpacket_count = 0;\n\t\t\t\tstatus = pcap_dispatch(pd, -1, countme,\n\t\t\t\t    (u_char *)&packet_count);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\t/*\n\t\t\t\t * Don't report this if we're using a\n\t\t\t\t * required timeout and we got no packets,\n\t\t\t\t * because that could be a very short timeout,\n\t\t\t\t * and we don't want to spam the user with\n\t\t\t\t * a ton of \"no packets\" reports.\n\t\t\t\t */\n\t\t\t\tif (status != 0 || packet_count != 0 ||\n\t\t\t\t    required_timeout != NULL) {\n\t\t\t\t\tprintf(\"%d packets seen, %d packets counted after select returns\\n\",\n\t\t\t\t\t    status, packet_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (dopoll) {\n\t\tfor (;;) {\n\t\t\tstruct pollfd fd;\n\t\t\tint polltimeout;\n\n\t\t\tfd.fd = selectable_fd;\n\t\t\tfd.events = POLLIN;\n\t\t\tif (dotimeout)\n\t\t\t\tpolltimeout = 1;\n\t\t\telse if (required_timeout != NULL &&\n\t\t\t    required_timeout->tv_usec >= 1000)\n\t\t\t\tpolltimeout = (int)(required_timeout->tv_usec/1000);\n\t\t\telse\n\t\t\t\tpolltimeout = -1;\n\t\t\tstatus = poll(&fd, (selectable_fd == -1) ? 0 : 1, polltimeout);\n\t\t\tif (status == -1) {\n\t\t\t\tprintf(\"Poll returns error (%s)\\n\",\n\t\t\t\t    strerror(errno));\n\t\t\t} else {\n\t\t\t\tif (selectable_fd == -1) {\n\t\t\t\t\tif (status != 0)\n\t\t\t\t\t\tprintf(\"Poll returned a descriptor\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (status == 0)\n\t\t\t\t\t\tprintf(\"Poll timed out\\n\");\n\t\t\t\t\telse {\n\t\t\t\t\t\tprintf(\"Poll returned a descriptor: \");\n\t\t\t\t\t\tif (fd.revents & POLLIN)\n\t\t\t\t\t\t\tprintf(\"readable, \");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tprintf(\"not readable, \");\n\t\t\t\t\t\tif (fd.revents & POLLERR)\n\t\t\t\t\t\t\tprintf(\"exceptional condition, \");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tprintf(\"no exceptional condition, \");\n\t\t\t\t\t\tif (fd.revents & POLLHUP)\n\t\t\t\t\t\t\tprintf(\"disconnect, \");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tprintf(\"no disconnect, \");\n\t\t\t\t\t\tif (fd.revents & POLLNVAL)\n\t\t\t\t\t\t\tprintf(\"invalid\\n\");\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tprintf(\"not invalid\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpacket_count = 0;\n\t\t\t\tstatus = pcap_dispatch(pd, -1, countme,\n\t\t\t\t    (u_char *)&packet_count);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tbreak;\n\t\t\t\t/*\n\t\t\t\t * Don't report this if we're using a\n\t\t\t\t * required timeout and we got no packets,\n\t\t\t\t * because that could be a very short timeout,\n\t\t\t\t * and we don't want to spam the user with\n\t\t\t\t * a ton of \"no packets\" reports.\n\t\t\t\t */\n\t\t\t\tif (status != 0 || packet_count != 0 ||\n\t\t\t\t    required_timeout != NULL) {\n\t\t\t\t\tprintf(\"%d packets seen, %d packets counted after poll returns\\n\",\n\t\t\t\t\t    status, packet_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (;;) {\n\t\t\tpacket_count = 0;\n\t\t\tstatus = pcap_dispatch(pd, -1, countme,\n\t\t\t    (u_char *)&packet_count);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t\tprintf(\"%d packets seen, %d packets counted after pcap_dispatch returns\\n\",\n\t\t\t    status, packet_count);\n\t\t}\n\t}\n\tif (status == -2) {\n\t\t/*\n\t\t * We got interrupted, so perhaps we didn't\n\t\t * manage to finish a line we were printing.\n\t\t * Print an extra newline, just in case.\n\t\t */\n\t\tputchar('\\n');\n\t}\n\t(void)fflush(stdout);\n\tif (status == -1) {\n\t\t/*\n\t\t * Error.  Report it.\n\t\t */\n\t\t(void)fprintf(stderr, \"%s: pcap_loop: %s\\n\",\n\t\t    program_name, pcap_geterr(pd));\n\t}\n\tpcap_close(pd);\n\texit(status == -1 ? 1 : 0);\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              356,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ncountme(u_char *user, const struct pcap_pkthdr *h _U_, const u_char *sp _U_)\n{\n\tint *counterp = (int *)user;\n\n\t(*counterp)++;\n}",
          "fn_code_pos": [
            [
              358,
              0
            ],
            [
              364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "countme",
            "parameters": {
              "user": "u_char",
              "h": "struct pcap_pkthdr",
              "sp": "u_char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\t(void)fprintf(stderr, \"Usage: %s [ -sptn ] [ -i interface ] [expression]\\n\",\n\t    program_name);\n\texit(1);\n}",
          "fn_code_pos": [
            [
              366,
              0
            ],
            [
              372,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nerror(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n\texit(1);\n\t/* NOTREACHED */\n}",
          "fn_code_pos": [
            [
              375,
              0
            ],
            [
              391,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "error",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nwarning(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: WARNING: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n}",
          "fn_code_pos": [
            [
              394,
              0
            ],
            [
              408,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "warning",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static char *\ncopy_argv(register char **argv)\n{\n\tregister char **p;\n\tregister size_t len = 0;\n\tchar *buf;\n\tchar *src, *dst;\n\n\tp = argv;\n\tif (*p == 0)\n\t\treturn 0;\n\n\twhile (*p)\n\t\tlen += strlen(*p++) + 1;\n\n\tbuf = (char *)malloc(len);\n\tif (buf == NULL)\n\t\terror(\"copy_argv: malloc\");\n\n\tp = argv;\n\tdst = buf;\n\twhile ((src = *p++) != NULL) {\n\t\twhile ((*dst++ = *src++) != '\\0')\n\t\t\t;\n\t\tdst[-1] = ' ';\n\t}\n\tdst[-1] = '\\0';\n\n\treturn buf;\n}",
          "fn_code_pos": [
            [
              413,
              0
            ],
            [
              442,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy_argv",
            "parameters": {
              "argv": "char"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "countme(u_char *, const struct pcap_pkthdr *, const u_char *)",
          "fn_dec_pos": [
            [
              57,
              12
            ],
            [
              57,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "countme",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PCAP_NORETURN usage(void)",
          "fn_dec_pos": [
            [
              58,
              12
            ],
            [
              58,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PCAP_NORETURN error(const char *, ...)",
          "fn_dec_pos": [
            [
              59,
              12
            ],
            [
              59,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN error",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "warning(const char *, ...)",
          "fn_dec_pos": [
            [
              60,
              12
            ],
            [
              60,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "warning",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "copy_argv(char **)",
          "fn_dec_pos": [
            [
              61,
              13
            ],
            [
              61,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy_argv",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "copy_argv(register char **argv)",
          "fn_dec_pos": [
            [
              414,
              0
            ],
            [
              414,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copy_argv",
            "parameters": {
              "argv": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            57,
            36
          ],
          [
            57,
            54
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            73,
            1
          ],
          [
            73,
            19
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            77,
            1
          ],
          [
            77,
            15
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            197,
            3
          ],
          [
            197,
            17
          ]
        ],
        [
          "struct pollfd",
          {},
          "",
          [
            265,
            3
          ],
          [
            265,
            16
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            359,
            28
          ],
          [
            359,
            46
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"varattrs.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include <pcap.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <sys/select.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <sys/time.h>\t/* older UN*Xes */\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <poll.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include \"pcap/funcattrs.h\"\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/testprogs/findalldevstest.c": {
      "fn_def_list": [
        {
          "fn_code": "static const char *\nwin32_strerror(DWORD error)\n{\n  static char errbuf[ERRBUF_SIZE+1];\n  size_t errlen;\n\n  FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, error, 0, errbuf,\n                ERRBUF_SIZE, NULL);\n\n  /*\n   * \"FormatMessage()\" \"helpfully\" sticks CR/LF at the end of the\n   * message.  Get rid of it.\n   */\n  errlen = strlen(errbuf);\n  if (errlen >= 2) {\n    errbuf[errlen - 1] = '\\0';\n    errbuf[errlen - 2] = '\\0';\n    errlen -= 2;\n  }\n  return errbuf;\n}",
          "fn_code_pos": [
            [
              36,
              0
            ],
            [
              56,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_strerror",
            "parameters": {
              "error": "DWORD"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static char *\ngetpass(const char *prompt)\n{\n  HANDLE console_handle = GetStdHandle(STD_INPUT_HANDLE);\n  DWORD console_mode, save_console_mode;\n  static char password[128+1];\n  char *p;\n\n  fprintf(stderr, \"%s\", prompt);\n\n  /*\n   * Turn off echoing.\n   */\n  if (!GetConsoleMode(console_handle, &console_mode)) {\n    fprintf(stderr, \"Can't get console mode: %s\\n\",\n            win32_strerror(GetLastError()));\n    exit(1);\n  }\n  save_console_mode = console_mode;\n  console_mode &= ~ENABLE_ECHO_INPUT;\n  if (!SetConsoleMode(console_handle, console_mode)) {\n    fprintf(stderr, \"Can't set console mode: %s\\n\",\n            win32_strerror(GetLastError()));\n    exit(1);\n  }\n  if (fgets(password, sizeof password, stdin) == NULL) {\n    fprintf(stderr, \"\\n\");\n    SetConsoleMode(console_handle, save_console_mode);\n    exit(1);\n  }\n  fprintf(stderr, \"\\n\");\n  SetConsoleMode(console_handle, save_console_mode);\n  p = strchr(password, '\\n');\n  if (p != NULL)\n    *p = '\\0';\n return password;\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              94,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getpass",
            "parameters": {
              "prompt": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int main(int argc _U_, char **argv _U_)\n#endif\n{\n  pcap_if_t *alldevs;\n  pcap_if_t *d;\n  bpf_u_int32 net, mask;\n  int exit_status = 0;\n  char errbuf[PCAP_ERRBUF_SIZE+1];\n#ifdef ENABLE_REMOTE\n  struct pcap_rmtauth auth;\n  char username[128+1];\n  char *p;\n  char *password;\n#endif\n\n#ifdef ENABLE_REMOTE\n  if (argc >= 2)\n  {\n    if (pcap_findalldevs_ex(argv[1], NULL, &alldevs, errbuf) == -1)\n    {\n      /*\n       * OK, try it with a user name and password.\n       */\n      fprintf(stderr, \"User name: \");\n      if (fgets(username, sizeof username, stdin) == NULL)\n        exit(1);\n      p = strchr(username, '\\n');\n      if (p != NULL)\n        *p = '\\0';\n      password = getpass(\"Password: \");\n      auth.type = RPCAP_RMTAUTH_PWD;\n      auth.username = username;\n      auth.password = password;\n      if (pcap_findalldevs_ex(argv[1], &auth, &alldevs, errbuf) == -1)\n      {\n        fprintf(stderr,\"Error in pcap_findalldevs: %s\\n\",errbuf);\n        exit(1);\n      }\n    }\n  }\n  else\n#endif\n  {\n    if (pcap_findalldevs(&alldevs, errbuf) == -1)\n    {\n      fprintf(stderr,\"Error in pcap_findalldevs: %s\\n\",errbuf);\n      exit(1);\n    }\n  }\n  for(d=alldevs;d;d=d->next)\n  {\n    if (!ifprint(d))\n      exit_status = 2;\n  }\n\n  if (alldevs != NULL)\n  {\n    if (pcap_lookupnet(alldevs->name, &net, &mask, errbuf) < 0)\n    {\n      fprintf(stderr,\"Error in pcap_lookupnet: %s\\n\",errbuf);\n      exit_status = 2;\n    }\n    else\n    {\n      printf(\"Preferred device is on network: %s/%s\\n\",iptos(net), iptos(mask));\n    }\n  }\n\n  pcap_freealldevs(alldevs);\n  exit(exit_status);\n}",
          "fn_code_pos": [
            [
              100,
              0
            ],
            [
              170,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int ifprint(pcap_if_t *d)\n{\n  pcap_addr_t *a;\n  char ipv4_buf[INET_ADDRSTRLEN];\n  char ipv6_buf[INET6_ADDRSTRLEN];\n  const char *sep;\n  int status = 1; /* success */\n\n  printf(\"%s\\n\",d->name);\n  if (d->description)\n    printf(\"\\tDescription: %s\\n\",d->description);\n  printf(\"\\tFlags: \");\n  sep = \"\";\n  if (d->flags & PCAP_IF_UP) {\n    printf(\"%sUP\", sep);\n    sep = \", \";\n  }\n  if (d->flags & PCAP_IF_RUNNING) {\n    printf(\"%sRUNNING\", sep);\n    sep = \", \";\n  }\n  if (d->flags & PCAP_IF_LOOPBACK) {\n    printf(\"%sLOOPBACK\", sep);\n    sep = \", \";\n  }\n  if (d->flags & PCAP_IF_WIRELESS) {\n    printf(\"%sWIRELESS\", sep);\n    switch (d->flags & PCAP_IF_CONNECTION_STATUS) {\n\n    case PCAP_IF_CONNECTION_STATUS_UNKNOWN:\n      printf(\" (association status unknown)\");\n      break;\n\n    case PCAP_IF_CONNECTION_STATUS_CONNECTED:\n      printf(\" (associated)\");\n      break;\n\n    case PCAP_IF_CONNECTION_STATUS_DISCONNECTED:\n      printf(\" (not associated)\");\n      break;\n\n    case PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE:\n      break;\n    }\n  } else {\n    switch (d->flags & PCAP_IF_CONNECTION_STATUS) {\n\n    case PCAP_IF_CONNECTION_STATUS_UNKNOWN:\n      printf(\" (connection status unknown)\");\n      break;\n\n    case PCAP_IF_CONNECTION_STATUS_CONNECTED:\n      printf(\" (connected)\");\n      break;\n\n    case PCAP_IF_CONNECTION_STATUS_DISCONNECTED:\n      printf(\" (disconnected)\");\n      break;\n\n    case PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE:\n      break;\n    }\n  }\n  sep = \", \";\n  printf(\"\\n\");\n\n  for(a=d->addresses;a;a=a->next) {\n    if (a->addr != NULL)\n      switch(a->addr->sa_family) {\n      case AF_INET:\n        printf(\"\\tAddress Family: AF_INET\\n\");\n        if (a->addr)\n          printf(\"\\t\\tAddress: %s\\n\",\n            inet_ntop(AF_INET,\n               &((struct sockaddr_in *)(a->addr))->sin_addr,\n               ipv4_buf, sizeof ipv4_buf));\n        if (a->netmask)\n          printf(\"\\t\\tNetmask: %s\\n\",\n            inet_ntop(AF_INET,\n               &((struct sockaddr_in *)(a->netmask))->sin_addr,\n               ipv4_buf, sizeof ipv4_buf));\n        if (a->broadaddr)\n          printf(\"\\t\\tBroadcast Address: %s\\n\",\n            inet_ntop(AF_INET,\n               &((struct sockaddr_in *)(a->broadaddr))->sin_addr,\n               ipv4_buf, sizeof ipv4_buf));\n        if (a->dstaddr)\n          printf(\"\\t\\tDestination Address: %s\\n\",\n            inet_ntop(AF_INET,\n               &((struct sockaddr_in *)(a->dstaddr))->sin_addr,\n               ipv4_buf, sizeof ipv4_buf));\n        break;\n#ifdef INET6\n      case AF_INET6:\n        printf(\"\\tAddress Family: AF_INET6\\n\");\n        if (a->addr)\n          printf(\"\\t\\tAddress: %s\\n\",\n            inet_ntop(AF_INET6,\n               ((struct sockaddr_in6 *)(a->addr))->sin6_addr.s6_addr,\n               ipv6_buf, sizeof ipv6_buf));\n        if (a->netmask)\n          printf(\"\\t\\tNetmask: %s\\n\",\n            inet_ntop(AF_INET6,\n              ((struct sockaddr_in6 *)(a->netmask))->sin6_addr.s6_addr,\n               ipv6_buf, sizeof ipv6_buf));\n        if (a->broadaddr)\n          printf(\"\\t\\tBroadcast Address: %s\\n\",\n            inet_ntop(AF_INET6,\n              ((struct sockaddr_in6 *)(a->broadaddr))->sin6_addr.s6_addr,\n               ipv6_buf, sizeof ipv6_buf));\n        if (a->dstaddr)\n          printf(\"\\t\\tDestination Address: %s\\n\",\n            inet_ntop(AF_INET6,\n              ((struct sockaddr_in6 *)(a->dstaddr))->sin6_addr.s6_addr,\n               ipv6_buf, sizeof ipv6_buf));\n        break;\n#endif\n      default:\n        printf(\"\\tAddress Family: Unknown (%d)\\n\", a->addr->sa_family);\n        break;\n      }\n    else\n    {\n      fprintf(stderr, \"\\tWarning: a->addr is NULL, skipping this address.\\n\");\n      status = 0;\n    }\n  }\n  printf(\"\\n\");\n  return status;\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              301,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ifprint",
            "parameters": {
              "d": "pcap_if_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static char *iptos(bpf_u_int32 in)\n{\n\tstatic char output[IPTOSBUFFERS][3*4+3+1];\n\tstatic short which;\n\tu_char *p;\n\n\tp = (u_char *)&in;\n\twhich = (which + 1 == IPTOSBUFFERS ? 0 : which + 1);\n\tsprintf(output[which], \"%d.%d.%d.%d\", p[0], p[1], p[2], p[3]);\n\treturn output[which];\n}",
          "fn_code_pos": [
            [
              305,
              0
            ],
            [
              315,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iptos",
            "parameters": {
              "in": "bpf_u_int32"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ifprint(pcap_if_t *d)",
          "fn_dec_pos": [
            [
              24,
              11
            ],
            [
              24,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ifprint",
            "parameters": {
              "d": "pcap_if_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "iptos(bpf_u_int32 in)",
          "fn_dec_pos": [
            [
              25,
              13
            ],
            [
              25,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iptos",
            "parameters": {
              "in": "bpf_u_int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "win32_strerror(DWORD error)",
          "fn_dec_pos": [
            [
              37,
              0
            ],
            [
              37,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_strerror",
            "parameters": {
              "error": "DWORD"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "getpass(const char *prompt)",
          "fn_dec_pos": [
            [
              59,
              0
            ],
            [
              59,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getpass",
            "parameters": {
              "prompt": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "main(int argc, char **argv)",
          "fn_dec_pos": [
            [
              98,
              4
            ],
            [
              98,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "iptos(bpf_u_int32 in)",
          "fn_dec_pos": [
            [
              305,
              13
            ],
            [
              305,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iptos",
            "parameters": {
              "in": "bpf_u_int32"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_rmtauth",
          {},
          "",
          [
            109,
            2
          ],
          [
            109,
            21
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            246,
            18
          ],
          [
            246,
            36
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            251,
            18
          ],
          [
            251,
            36
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            256,
            18
          ],
          [
            256,
            36
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            261,
            18
          ],
          [
            261,
            36
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            270,
            17
          ],
          [
            270,
            36
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            275,
            16
          ],
          [
            275,
            35
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            280,
            16
          ],
          [
            280,
            35
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            285,
            16
          ],
          [
            285,
            35
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            4,
            0
          ],
          [
            5,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            6,
            0
          ],
          [
            7,
            0
          ]
        ],
        [
          "#include <winsock2.h>\n",
          [
            8,
            2
          ],
          [
            9,
            0
          ]
        ],
        [
          "#include <ws2tcpip.h>\n",
          [
            9,
            2
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <windows.h>\n",
          [
            10,
            2
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            12,
            2
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\n",
          [
            13,
            2
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <arpa/inet.h>\n",
          [
            14,
            2
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include <netdb.h>\n",
          [
            15,
            2
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            16,
            2
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include <pcap.h>\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include \"varattrs.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"pcap/funcattrs.h\"\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/testprogs/reactivatetest.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(void)\n{\n\tchar ebuf[PCAP_ERRBUF_SIZE];\n\tpcap_t *pd;\n\tint status = 0;\n\n\tpd = pcap_open_live(\"lo0\", 65535, 0, 1000, ebuf);\n\tif (pd == NULL) {\n\t\tpd = pcap_open_live(\"lo\", 65535, 0, 1000, ebuf);\n\t\tif (pd == NULL) {\n\t\t\terror(\"Neither lo0 nor lo could be opened: %s\",\n\t\t\t    ebuf);\n\t\t}\n\t}\n\tstatus = pcap_activate(pd);\n\tif (status != PCAP_ERROR_ACTIVATED) {\n\t\tif (status == 0)\n\t\t\terror(\"pcap_activate() of opened pcap_t succeeded\");\n\t\telse if (status == PCAP_ERROR)\n\t\t\terror(\"pcap_activate() of opened pcap_t failed with %s, not PCAP_ERROR_ACTIVATED\",\n\t\t\t    pcap_geterr(pd));\n\t\telse\n\t\t\terror(\"pcap_activate() of opened pcap_t failed with %s, not PCAP_ERROR_ACTIVATED\",\n\t\t\t    pcap_statustostr(status));\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nerror(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"reactivatetest: \");\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n\texit(1);\n\t/* NOTREACHED */\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "error",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "PCAP_NORETURN error(PCAP_FORMAT_STRING(const char *), ...)",
          "fn_dec_pos": [
            [
              38,
              12
            ],
            [
              38,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PCAP_NORETURN error",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"varattrs.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include <pcap.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"pcap/funcattrs.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/testprogs/fuzz/fuzz_both.c": {
      "fn_def_list": [
        {
          "fn_code": "static int bufferToFile(const char * name, const uint8_t *Data, size_t Size) {\n    FILE * fd;\n    if (remove(name) != 0) {\n        if (errno != ENOENT) {\n            printf(\"failed remove, errno=%d\\n\", errno);\n            return -1;\n        }\n    }\n    fd = fopen(name, \"wb\");\n    if (fd == NULL) {\n        printf(\"failed open, errno=%d\\n\", errno);\n        return -2;\n    }\n    if (fwrite (Data, 1, Size, fd) != Size) {\n        fclose(fd);\n        return -3;\n    }\n    fclose(fd);\n    return 0;\n}",
          "fn_code_pos": [
            [
              10,
              0
            ],
            [
              29,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bufferToFile",
            "parameters": {
              "name": "char",
              "Data": "uint8_t",
              "Size": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void fuzz_openFile(const char * name) {\n    if (outfile != NULL) {\n        fclose(outfile);\n    }\n    outfile = fopen(name, \"w\");\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              36,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fuzz_openFile",
            "parameters": {
              "name": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n    pcap_t * pkts;\n    char errbuf[PCAP_ERRBUF_SIZE];\n    const u_char *pkt;\n    struct pcap_pkthdr *header;\n    int r;\n    size_t filterSize;\n    char * filter;\n    struct bpf_program bpf;\n\n\n    //initialize output file\n    if (outfile == NULL) {\n        outfile = fopen(\"/dev/null\", \"w\");\n        if (outfile == NULL) {\n            return 0;\n        }\n    }\n\n    if (Size < 1) {\n        return 0;\n    }\n    filterSize = Data[0];\n    if (Size < 1+filterSize || filterSize == 0) {\n        return 0;\n    }\n\n    //rewrite buffer to a file as libpcap does not have buffer inputs\n    if (bufferToFile(\"/tmp/fuzz.pcap\", Data+1+filterSize, Size-(1+filterSize)) < 0) {\n        return 0;\n    }\n\n    //initialize structure\n    pkts = pcap_open_offline(\"/tmp/fuzz.pcap\", errbuf);\n    if (pkts == NULL) {\n        fprintf(outfile, \"Couldn't open pcap file %s\\n\", errbuf);\n        return 0;\n    }\n\n    filter = malloc(filterSize);\n    memcpy(filter, Data+1, filterSize);\n    //null terminate string\n    filter[filterSize-1] = 0;\n\n    if (pcap_compile(pkts, &bpf, filter, 1, PCAP_NETMASK_UNKNOWN) == 0) {\n        //loop over packets\n        r = pcap_next_ex(pkts, &header, &pkt);\n        while (r > 0) {\n            //checks filter\n            fprintf(outfile, \"packet length=%d/%d filter=%d\\n\",header->caplen, header->len, pcap_offline_filter(&bpf, header, pkt));\n            r = pcap_next_ex(pkts, &header, &pkt);\n        }\n        //close structure\n        pcap_close(pkts);\n        pcap_freecode(&bpf);\n    }\n    else {\n        pcap_close(pkts);\n    }\n    free(filter);\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "Data": "uint8_t",
              "Size": "size_t"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            42,
            4
          ],
          [
            42,
            22
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            46,
            4
          ],
          [
            46,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            3,
            0
          ],
          [
            4,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            4,
            0
          ],
          [
            5,
            0
          ]
        ],
        [
          "#include <pcap/pcap.h>\n",
          [
            6,
            0
          ],
          [
            7,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/testprogs/fuzz/fuzz_filter.c": {
      "fn_def_list": [
        {
          "fn_code": "void fuzz_openFile(const char * name){\n    //do nothing\n}",
          "fn_code_pos": [
            [
              6,
              0
            ],
            [
              8,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fuzz_openFile",
            "parameters": {
              "name": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n    pcap_t * pkts;\n    struct bpf_program bpf;\n    char * filter;\n\n    //we need at least 1 byte for linktype\n    if (Size < 1) {\n        return 0;\n    }\n\n    //initialize structure snaplen = 65535\n    pkts = pcap_open_dead(Data[Size-1], 0xFFFF);\n    if (pkts == NULL) {\n        printf(\"pcap_open_dead failed\\n\");\n        return 0;\n    }\n    filter = malloc(Size);\n    memcpy(filter, Data, Size);\n    //null terminate string\n    filter[Size-1] = 0;\n\n    if (pcap_compile(pkts, &bpf, filter, 1, PCAP_NETMASK_UNKNOWN) == 0) {\n        pcap_setfilter(pkts, &bpf);\n        pcap_close(pkts);\n        pcap_freecode(&bpf);\n    }\n    else {\n        pcap_close(pkts);\n    }\n    free(filter);\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              10,
              0
            ],
            [
              42,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "Data": "uint8_t",
              "Size": "size_t"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct bpf_program",
          {},
          "",
          [
            12,
            4
          ],
          [
            12,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ],
        [
          "#include <pcap/pcap.h>\n",
          [
            4,
            0
          ],
          [
            5,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/testprogs/fuzz/fuzz_pcap.c": {
      "fn_def_list": [
        {
          "fn_code": "static int bufferToFile(const char * name, const uint8_t *Data, size_t Size) {\n    FILE * fd;\n    if (remove(name) != 0) {\n        if (errno != ENOENT) {\n            printf(\"failed remove, errno=%d\\n\", errno);\n            return -1;\n        }\n    }\n    fd = fopen(name, \"wb\");\n    if (fd == NULL) {\n        printf(\"failed open, errno=%d\\n\", errno);\n        return -2;\n    }\n    if (fwrite (Data, 1, Size, fd) != Size) {\n        fclose(fd);\n        return -3;\n    }\n    fclose(fd);\n    return 0;\n}",
          "fn_code_pos": [
            [
              9,
              0
            ],
            [
              28,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bufferToFile",
            "parameters": {
              "name": "char",
              "Data": "uint8_t",
              "Size": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void fuzz_openFile(const char * name) {\n    if (outfile != NULL) {\n        fclose(outfile);\n    }\n    outfile = fopen(name, \"w\");\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              35,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fuzz_openFile",
            "parameters": {
              "name": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n    pcap_t * pkts;\n    char errbuf[PCAP_ERRBUF_SIZE];\n    const u_char *pkt;\n    struct pcap_pkthdr *header;\n    struct pcap_stat stats;\n    int r;\n\n    //initialize output file\n    if (outfile == NULL) {\n        outfile = fopen(\"/dev/null\", \"w\");\n        if (outfile == NULL) {\n            return 0;\n        }\n    }\n\n    //rewrite buffer to a file as libpcap does not have buffer inputs\n    if (bufferToFile(\"/tmp/fuzz.pcap\", Data, Size) < 0) {\n        return 0;\n    }\n\n    //initialize structure\n    pkts = pcap_open_offline(\"/tmp/fuzz.pcap\", errbuf);\n    if (pkts == NULL) {\n        fprintf(outfile, \"Couldn't open pcap file %s\\n\", errbuf);\n        return 0;\n    }\n\n    //loop over packets\n    r = pcap_next_ex(pkts, &header, &pkt);\n    while (r > 0) {\n        //TODO pcap_offline_filter\n        fprintf(outfile, \"packet length=%d/%d\\n\",header->caplen, header->len);\n        r = pcap_next_ex(pkts, &header, &pkt);\n    }\n    if (pcap_stats(pkts, &stats) == 0) {\n        fprintf(outfile, \"number of packets=%d\\n\", stats.ps_recv);\n    }\n    //close structure\n    pcap_close(pkts);\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              37,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "Data": "uint8_t",
              "Size": "size_t"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            41,
            4
          ],
          [
            41,
            22
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            42,
            4
          ],
          [
            42,
            20
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            3,
            0
          ],
          [
            4,
            0
          ]
        ],
        [
          "#include <pcap/pcap.h>\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/testprogs/fuzz/onefile.c": {
      "fn_def_list": [
        {
          "fn_code": "int main(int argc, char** argv)\n{\n    FILE * fp;\n    uint8_t *Data;\n    size_t Size;\n\n    if (argc == 3) {\n        fuzz_openFile(argv[2]);\n    } else if (argc != 2) {\n        return 1;\n    }\n    //opens the file, get its size, and reads it into a buffer\n    fp = fopen(argv[1], \"rb\");\n    if (fp == NULL) {\n        return 2;\n    }\n    if (fseek(fp, 0L, SEEK_END) != 0) {\n        fclose(fp);\n        return 2;\n    }\n    Size = ftell(fp);\n    if (Size == (size_t) -1) {\n        fclose(fp);\n        return 2;\n    }\n    if (fseek(fp, 0L, SEEK_SET) != 0) {\n        fclose(fp);\n        return 2;\n    }\n    Data = malloc(Size);\n    if (Data == NULL) {\n        fclose(fp);\n        return 2;\n    }\n    if (fread(Data, Size, 1, fp) != 1) {\n        fclose(fp);\n        free(Data);\n        return 2;\n    }\n\n    //lauch fuzzer\n    LLVMFuzzerTestOneInput(Data, Size);\n    free(Data);\n    fclose(fp);\n    return 0;\n}",
          "fn_code_pos": [
            [
              7,
              0
            ],
            [
              52,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size)",
          "fn_dec_pos": [
            [
              4,
              4
            ],
            [
              4,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "Data": "uint8_t",
              "Size": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "fuzz_openFile(const char * name)",
          "fn_dec_pos": [
            [
              5,
              5
            ],
            [
              5,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fuzz_openFile",
            "parameters": {
              "name": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdint.h>\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/cmake/have_siocglifconf.c": {
      "fn_def_list": [
        {
          "fn_code": "int main() {\n    ioctl(0, SIOCGLIFCONF, (char *)0);\n}",
          "fn_code_pos": [
            [
              3,
              0
            ],
            [
              5,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <sys/ioctl.h>\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include <sys/sockio.h>\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/rpcapd/daemon.c": {
      "fn_def_list": [
        {
          "fn_code": "int\ndaemon_serviceloop(SOCKET sockctrl, int isactive, char *passiveClients,\n    int nullAuthAllowed, int uses_ssl)\n{\n\tuint8 first_octet;\n\tstruct tls_record_header tls_header;\n\tstruct tls_alert tls_alert;\n\tstruct daemon_slpars pars;\t\t// service loop parameters\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\t// keeps the error string, prior to be printed\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE + 1];\t// buffer for errors to send to the client\n\tint host_port_check_status;\n\tSSL *ssl = NULL;\n\tint nrecv;\n\tstruct rpcap_header header;\t\t// RPCAP message general header\n\tuint32 plen;\t\t\t\t// payload length from header\n\tint authenticated = 0;\t\t\t// 1 if the client has successfully authenticated\n\tchar source[PCAP_BUF_SIZE+1];\t\t// keeps the string that contains the interface to open\n\tint got_source = 0;\t\t\t// 1 if we've gotten the source from an open request\n#ifndef _WIN32\n\tstruct sigaction action;\n#endif\n\tstruct session *session = NULL;\t\t// struct session main variable\n\tconst char *msg_type_string;\t\t// string for message type\n\tint client_told_us_to_close = 0;\t// 1 if the client told us to close the capture\n\n\t// needed to save the values of the statistics\n\tstruct pcap_stat stats;\n\tunsigned int svrcapt;\n\n\tstruct rpcap_sampling samp_param;\t// in case sampling has been requested\n\n\t// Structures needed for the select() call\n\tfd_set rfds;\t\t\t\t// set of socket descriptors we have to check\n\tstruct timeval tv;\t\t\t// maximum time the select() can block waiting for data\n\tint retval;\t\t\t\t// select() return value\n\n\t*errbuf = 0;\t// Initialize errbuf\n\n\t//\n\t// Peek into the socket to determine whether the client sent us\n\t// a TLS handshake message or a non-TLS rpcapd message.\n\t//\n\t// The first byte of an rpcapd request is the version number;\n\t// the first byte of a TLS handshake message is 22.  The\n\t// first request to an rpcapd server must be an authentication\n\t// request or a close request, and must have a version number\n\t// of 0, so it will be possible to distinguish between an\n\t// initial plaintext request to a server and an initial TLS\n\t// handshake message.\n\t//\n\tnrecv = sock_recv(sockctrl, NULL, (char *)&first_octet, 1,\n\t    SOCK_EOF_ISNT_ERROR|SOCK_MSG_PEEK, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nrecv == -1)\n\t{\n\t\t// Fatal error.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Peek from client failed: %s\", errbuf);\n\t\tgoto end;\n\t}\n\tif (nrecv == 0)\n\t{\n\t\t// Client closed the connection.\n\t\tgoto end;\n\t}\n\n#ifdef HAVE_OPENSSL\n\t//\n\t// We have to upgrade to TLS as soon as possible, so that the\n\t// whole protocol goes through the encrypted tunnel, including\n\t// early error messages.\n\t//\n\t// Even in active mode, the other end has to initiate the TLS\n\t// handshake as we still are the server as far as TLS is concerned,\n\t// so we don't check isactive.\n\t//\n\tif (uses_ssl)\n\t{\n\t\t//\n\t\t// We're expecting a TLS handshake message.  If this\n\t\t// isn't one, assume it's a non-TLS rpcapd message.\n\t\t//\n\t\t// The first octet of a TLS handshake is\n\t\t// TLS_RECORD_TYPE_HANDSHAKE.\n\t\t//\n\t\tif (first_octet != TLS_RECORD_TYPE_HANDSHAKE)\n\t\t{\n\t\t\t//\n\t\t\t// We assume this is a non-TLS rpcapd message.\n\t\t\t//\n\t\t\t// Read the message header from the client.\n\t\t\t//\n\t\t\tnrecv = rpcapd_recv_msg_header(sockctrl, NULL, &header);\n\t\t\tif (nrecv == -1)\n\t\t\t{\n\t\t\t\t// Fatal error.\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tif (nrecv == -2)\n\t\t\t{\n\t\t\t\t// Client closed the connection.\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tplen = header.plen;\n\n\t\t\t// Discard the rest of the message.\n\t\t\tif (rpcapd_discard(sockctrl, NULL, plen) == -1)\n\t\t\t{\n\t\t\t\t// Network error.\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Send an authentication error, indicating\n\t\t\t// that we require TLS.\n\t\t\t//\n\t\t\tif (rpcap_senderror(sockctrl, NULL, header.ver,\n\t\t\t    PCAP_ERR_TLS_REQUIRED,\n\t\t\t    \"TLS is required by this server\", errbuf) == -1)\n\t\t\t{\n\t\t\t\t// That failed; log a message and give up.\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t// Shut the session down.\n\t\t\tgoto end;\n\t\t}\n\t\tssl = ssl_promotion(1, sockctrl, errbuf, PCAP_ERRBUF_SIZE);\n\t\tif (! ssl)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"TLS handshake on control connection failed: %s\",\n\t\t\t    errbuf);\n\t\t\tgoto end;\n\t\t}\n\t}\n\telse\n#endif\n\t{\n\t\t//\n\t\t// We're expecting a non-TLS rpcapd message.  If this\n\t\t// looks, instead, like a TLS handshake message, send\n\t\t// a TLS handshake_failed alert.\n\t\t//\n\t\t// The first octet of a TLS handshake is\n\t\t// TLS_RECORD_TYPE_HANDSHAKE.\n\t\t//\n\t\tif (first_octet == TLS_RECORD_TYPE_HANDSHAKE)\n\t\t{\n\t\t\t//\n\t\t\t// TLS handshake.\n\t\t\t// Read the record header.\n\t\t\t//\n\t\t\tnrecv = sock_recv(sockctrl, ssl, (char *) &tls_header,\n\t\t\t    sizeof tls_header, SOCK_RECEIVEALL_YES|SOCK_EOF_ISNT_ERROR,\n\t\t\t    errbuf, PCAP_ERRBUF_SIZE);\n\t\t\tif (nrecv == -1)\n\t\t\t{\n\t\t\t\t// Network error.\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tif (nrecv == 0)\n\t\t\t{\n\t\t\t\t// Immediate EOF\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tplen = (tls_header.length_hi << 8) | tls_header.length_lo;\n\n\t\t\t// Discard the rest of the message.\n\t\t\tif (rpcapd_discard(sockctrl, NULL, plen) == -1)\n\t\t\t{\n\t\t\t\t// Network error.\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Send a TLS handshake failure alert.\n\t\t\t// Use the same version the client sent us.\n\t\t\t//\n\t\t\ttls_header.type = TLS_RECORD_TYPE_ALERT;\n\t\t\ttls_header.length_hi = 0;\n\t\t\ttls_header.length_lo = TLS_ALERT_LEN;\n\n\t\t\tif (sock_send(sockctrl, NULL, (char *) &tls_header,\n\t\t\t    TLS_RECORD_HEADER_LEN, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t{\n\t\t\t\t// That failed; log a messsage and give up.\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\ttls_alert.alert_level = TLS_ALERT_LEVEL_FATAL;\n\t\t\ttls_alert.alert_description = TLS_ALERT_HANDSHAKE_FAILURE;\n\t\t\tif (sock_send(sockctrl, NULL, (char *) &tls_alert,\n\t\t\t    TLS_ALERT_LEN, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t{\n\t\t\t\t// That failed; log a messsage and give up.\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\t//\n\t\t\t// Give up anyway.\n\t\t\t//\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\t// Set parameters structure\n\tpars.sockctrl = sockctrl;\n\tpars.ssl = ssl;\n\tpars.isactive = isactive;\t\t// active mode\n\tpars.nullAuthAllowed = nullAuthAllowed;\n\n\t//\n\t// We have a connection.\n\t//\n\t// If it's a passive mode connection, check whether the connecting\n\t// host is among the ones allowed.\n\t//\n\t// In either case, we were handed a copy of the host list; free it\n\t// as soon as we're done with it.\n\t//\n\tif (pars.isactive)\n\t{\n\t\t// Nothing to do.\n\t\tfree(passiveClients);\n\t\tpassiveClients = NULL;\n\t}\n\telse\n\t{\n\t\tstruct sockaddr_storage from;\n\t\tsocklen_t fromlen;\n\n\t\t//\n\t\t// Get the address of the other end of the connection.\n\t\t//\n\t\tfromlen = sizeof(struct sockaddr_storage);\n\t\tif (getpeername(pars.sockctrl, (struct sockaddr *)&from,\n\t\t    &fromlen) == -1)\n\t\t{\n\t\t\tsock_geterror(\"getpeername(): \", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\tif (rpcap_senderror(pars.sockctrl, pars.ssl, 0, PCAP_ERR_NETW, errmsgbuf, errbuf) == -1)\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\tgoto end;\n\t\t}\n\n\t\t//\n\t\t// Are they in the list of host/port combinations we allow?\n\t\t//\n\t\thost_port_check_status = sock_check_hostlist(passiveClients, RPCAP_HOSTLIST_SEP, &from, errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\tfree(passiveClients);\n\t\tpassiveClients = NULL;\n\t\tif (host_port_check_status < 0)\n\t\t{\n\t\t\tif (host_port_check_status == -2) {\n\t\t\t\t//\n\t\t\t\t// We got an error; log it.\n\t\t\t\t//\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"%s\", errmsgbuf);\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Sorry, we can't let you in.\n\t\t\t//\n\t\t\tif (rpcap_senderror(pars.sockctrl, pars.ssl, 0, PCAP_ERR_HOSTNOAUTH, errmsgbuf, errbuf) == -1)\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\tgoto end;\n\t\t}\n\t}\n\n#ifndef _WIN32\n\t//\n\t// Catch SIGUSR1, but do nothing.  We use it to interrupt the\n\t// capture thread to break it out of a loop in which it's\n\t// blocked waiting for packets to arrive.\n\t//\n\t// We don't want interrupted system calls to restart, so that\n\t// the read routine for the pcap_t gets EINTR rather than\n\t// restarting if it's blocked in a system call.\n\t//\n\tmemset(&action, 0, sizeof (action));\n\taction.sa_handler = noop_handler;\n\taction.sa_flags = 0;\n\tsigemptyset(&action.sa_mask);\n\tsigaction(SIGUSR1, &action, NULL);\n#endif\n\n\t//\n\t// The client must first authenticate; loop until they send us a\n\t// message with a version we support and credentials we accept,\n\t// they send us a close message indicating that they're giving up,\n\t// or we get a network error or other fatal error.\n\t//\n\twhile (!authenticated)\n\t{\n\t\t//\n\t\t// If we're not in active mode, we use select(), with a\n\t\t// timeout, to wait for an authentication request; if\n\t\t// the timeout expires, we drop the connection, so that\n\t\t// a client can't just connect to us and leave us\n\t\t// waiting forever.\n\t\t//\n\t\tif (!pars.isactive)\n\t\t{\n\t\t\tFD_ZERO(&rfds);\n\t\t\t// We do not have to block here\n\t\t\ttv.tv_sec = RPCAP_TIMEOUT_INIT;\n\t\t\ttv.tv_usec = 0;\n\n\t\t\tFD_SET(pars.sockctrl, &rfds);\n\n\t\t\tretval = select((int)pars.sockctrl + 1, &rfds, NULL, NULL, &tv);\n\t\t\tif (retval == -1)\n\t\t\t{\n\t\t\t\tsock_geterror(\"select failed: \", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, pars.ssl, 0, PCAP_ERR_NETW, errmsgbuf, errbuf) == -1)\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t// The timeout has expired\n\t\t\t// So, this was a fake connection. Drop it down\n\t\t\tif (retval == 0)\n\t\t\t{\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, pars.ssl, 0, PCAP_ERR_INITTIMEOUT, \"The RPCAP initial timeout has expired\", errbuf) == -1)\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Read the message header from the client.\n\t\t//\n\t\tnrecv = rpcapd_recv_msg_header(pars.sockctrl, pars.ssl, &header);\n\t\tif (nrecv == -1)\n\t\t{\n\t\t\t// Fatal error.\n\t\t\tgoto end;\n\t\t}\n\t\tif (nrecv == -2)\n\t\t{\n\t\t\t// Client closed the connection.\n\t\t\tgoto end;\n\t\t}\n\n\t\tplen = header.plen;\n\n\t\t//\n\t\t// While we're in the authentication pharse, all requests\n\t\t// must use version 0.\n\t\t//\n\t\tif (header.ver != 0)\n\t\t{\n\t\t\t//\n\t\t\t// Send it back to them with their version.\n\t\t\t//\n\t\t\tif (rpcap_senderror(pars.sockctrl, pars.ssl, header.ver,\n\t\t\t    PCAP_ERR_WRONGVER,\n\t\t\t    \"RPCAP version in requests in the authentication phase must be 0\",\n\t\t\t    errbuf) == -1)\n\t\t\t{\n\t\t\t\t// That failed; log a message and give up.\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t// Discard the rest of the message and drop the\n\t\t\t// connection.\n\t\t\t(void)rpcapd_discard(pars.sockctrl, pars.ssl, plen);\n\t\t\tgoto end;\n\t\t}\n\n\t\tswitch (header.type)\n\t\t{\n\t\t\tcase RPCAP_MSG_AUTH_REQ:\n\t\t\t\tretval = daemon_msg_auth_req(&pars, plen);\n\t\t\t\tif (retval == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tif (retval == -2)\n\t\t\t\t{\n\t\t\t\t\t// Non-fatal error; we sent back\n\t\t\t\t\t// an error message, so let them\n\t\t\t\t\t// try again.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// OK, we're authenticated; we sent back\n\t\t\t\t// a reply, so start serving requests.\n\t\t\t\tauthenticated = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase RPCAP_MSG_CLOSE:\n\t\t\t\t//\n\t\t\t\t// The client is giving up.\n\t\t\t\t// Discard the rest of the message, if\n\t\t\t\t// there is anything more.\n\t\t\t\t//\n\t\t\t\t(void)rpcapd_discard(pars.sockctrl, pars.ssl, plen);\n\t\t\t\t// We're done with this client.\n\t\t\t\tgoto end;\n\n\t\t\tcase RPCAP_MSG_ERROR:\n\t\t\t\t// Log this and close the connection?\n\t\t\t\t// XXX - is this what happens in active\n\t\t\t\t// mode, where *we* initiate the\n\t\t\t\t// connection, and the client gives us\n\t\t\t\t// an error message rather than a \"let\n\t\t\t\t// me log in\" message, indicating that\n\t\t\t\t// we're not allowed to connect to them?\n\t\t\t\t(void)daemon_msg_err(pars.sockctrl, pars.ssl, plen);\n\t\t\t\tgoto end;\n\n\t\t\tcase RPCAP_MSG_FINDALLIF_REQ:\n\t\t\tcase RPCAP_MSG_OPEN_REQ:\n\t\t\tcase RPCAP_MSG_STARTCAP_REQ:\n\t\t\tcase RPCAP_MSG_UPDATEFILTER_REQ:\n\t\t\tcase RPCAP_MSG_STATS_REQ:\n\t\t\tcase RPCAP_MSG_ENDCAP_REQ:\n\t\t\tcase RPCAP_MSG_SETSAMPLING_REQ:\n\t\t\t\t//\n\t\t\t\t// These requests can't be sent until\n\t\t\t\t// the client is authenticated.\n\t\t\t\t//\n\t\t\t\tmsg_type_string = rpcap_msg_type_string(header.type);\n\t\t\t\tif (msg_type_string != NULL)\n\t\t\t\t{\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"%s request sent before authentication was completed\", msg_type_string);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Message of type %u sent before authentication was completed\", header.type);\n\t\t\t\t}\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, pars.ssl,\n\t\t\t\t    header.ver, PCAP_ERR_WRONGMSG,\n\t\t\t\t    errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Network error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase RPCAP_MSG_PACKET:\n\t\t\tcase RPCAP_MSG_FINDALLIF_REPLY:\n\t\t\tcase RPCAP_MSG_OPEN_REPLY:\n\t\t\tcase RPCAP_MSG_STARTCAP_REPLY:\n\t\t\tcase RPCAP_MSG_UPDATEFILTER_REPLY:\n\t\t\tcase RPCAP_MSG_AUTH_REPLY:\n\t\t\tcase RPCAP_MSG_STATS_REPLY:\n\t\t\tcase RPCAP_MSG_ENDCAP_REPLY:\n\t\t\tcase RPCAP_MSG_SETSAMPLING_REPLY:\n\t\t\t\t//\n\t\t\t\t// These are server-to-client messages.\n\t\t\t\t//\n\t\t\t\tmsg_type_string = rpcap_msg_type_string(header.type);\n\t\t\t\tif (msg_type_string != NULL)\n\t\t\t\t{\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Server-to-client message %s received from client\", msg_type_string);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Server-to-client message of type %u received from client\", header.type);\n\t\t\t\t}\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, pars.ssl,\n\t\t\t\t    header.ver, PCAP_ERR_WRONGMSG,\n\t\t\t\t    errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t//\n\t\t\t\t// Unknown message type.\n\t\t\t\t//\n\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Unknown message type %u\", header.type);\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, pars.ssl,\n\t\t\t\t    header.ver, PCAP_ERR_WRONGMSG,\n\t\t\t\t    errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t//\n\t// OK, the client has authenticated itself, and we can start\n\t// processing regular requests from it.\n\t//\n\n\t//\n\t// We don't have any statistics yet.\n\t//\n\tstats.ps_ifdrop = 0;\n\tstats.ps_recv = 0;\n\tstats.ps_drop = 0;\n\tsvrcapt = 0;\n\n\t//\n\t// Service requests.\n\t//\n\tfor (;;)\n\t{\n\t\terrbuf[0] = 0;\t// clear errbuf\n\n\t\t// Avoid zombies connections; check if the connection is opens but no commands are performed\n\t\t// from more than RPCAP_TIMEOUT_RUNTIME\n\t\t// Conditions:\n\t\t// - I have to be in normal mode (no active mode)\n\t\t// - if the device is open, I don't have to be in the middle of a capture (session->sockdata)\n\t\t// - if the device is closed, I have always to check if a new command arrives\n\t\t//\n\t\t// Be carefully: the capture can have been started, but an error occurred (so session != NULL, but\n\t\t//  sockdata is 0\n\t\tif ((!pars.isactive) &&  ((session == NULL) || ((session != NULL) && (session->sockdata == 0))))\n\t\t{\n\t\t\t// Check for the initial timeout\n\t\t\tFD_ZERO(&rfds);\n\t\t\t// We do not have to block here\n\t\t\ttv.tv_sec = RPCAP_TIMEOUT_RUNTIME;\n\t\t\ttv.tv_usec = 0;\n\n\t\t\tFD_SET(pars.sockctrl, &rfds);\n\n\t\t\tretval = select((int)pars.sockctrl + 1, &rfds, NULL, NULL, &tv);\n\t\t\tif (retval == -1)\n\t\t\t{\n\t\t\t\tsock_geterror(\"select failed: \", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, pars.ssl,\n\t\t\t\t    0, PCAP_ERR_NETW,\n\t\t\t\t    errmsgbuf, errbuf) == -1)\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t// The timeout has expired\n\t\t\t// So, this was a fake connection. Drop it down\n\t\t\tif (retval == 0)\n\t\t\t{\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, pars.ssl,\n\t\t\t\t    0, PCAP_ERR_INITTIMEOUT,\n\t\t\t\t    \"The RPCAP initial timeout has expired\",\n\t\t\t\t    errbuf) == -1)\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Read the message header from the client.\n\t\t//\n\t\tnrecv = rpcapd_recv_msg_header(pars.sockctrl, pars.ssl, &header);\n\t\tif (nrecv == -1)\n\t\t{\n\t\t\t// Fatal error.\n\t\t\tgoto end;\n\t\t}\n\t\tif (nrecv == -2)\n\t\t{\n\t\t\t// Client closed the connection.\n\t\t\tgoto end;\n\t\t}\n\n\t\tplen = header.plen;\n\n\t\t//\n\t\t// Did the client specify a protocol version that we\n\t\t// support?\n\t\t//\n\t\tif (!RPCAP_VERSION_IS_SUPPORTED(header.ver))\n\t\t{\n\t\t\t//\n\t\t\t// Tell them it's not a supported version.\n\t\t\t// Send the error message with their version,\n\t\t\t// so they don't reject it as having the wrong\n\t\t\t// version.\n\t\t\t//\n\t\t\tif (rpcap_senderror(pars.sockctrl, pars.ssl,\n\t\t\t    header.ver, PCAP_ERR_WRONGVER,\n\t\t\t    \"RPCAP version in message isn't supported by the server\",\n\t\t\t    errbuf) == -1)\n\t\t\t{\n\t\t\t\t// That failed; log a message and give up.\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t// Discard the rest of the message.\n\t\t\t(void)rpcapd_discard(pars.sockctrl, pars.ssl, plen);\n\t\t\t// Give up on them.\n\t\t\tgoto end;\n\t\t}\n\n\t\tswitch (header.type)\n\t\t{\n\t\t\tcase RPCAP_MSG_ERROR:\t\t// The other endpoint reported an error\n\t\t\t{\n\t\t\t\t(void)daemon_msg_err(pars.sockctrl, pars.ssl, plen);\n\t\t\t\t// Do nothing; just exit; the error code is already into the errbuf\n\t\t\t\t// XXX - actually exit....\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_FINDALLIF_REQ:\n\t\t\t{\n\t\t\t\tif (daemon_msg_findallif_req(header.ver, &pars, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_OPEN_REQ:\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Process the open request, and keep\n\t\t\t\t// the source from it, for use later\n\t\t\t\t// when the capture is started.\n\t\t\t\t//\n\t\t\t\t// XXX - we don't care if the client sends\n\t\t\t\t// us multiple open requests, the last\n\t\t\t\t// one wins.\n\t\t\t\t//\n\t\t\t\tretval = daemon_msg_open_req(header.ver, &pars,\n\t\t\t\t    plen, source, sizeof(source));\n\t\t\t\tif (retval == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tgot_source = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_STARTCAP_REQ:\n\t\t\t{\n\t\t\t\tif (!got_source)\n\t\t\t\t{\n\t\t\t\t\t// They never told us what device\n\t\t\t\t\t// to capture on!\n\t\t\t\t\tif (rpcap_senderror(pars.sockctrl, pars.ssl,\n\t\t\t\t\t    header.ver,\n\t\t\t\t\t    PCAP_ERR_STARTCAPTURE,\n\t\t\t\t\t    \"No capture device was specified\",\n\t\t\t\t\t    errbuf) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Fatal error; log an\n\t\t\t\t\t\t// error and  give up.\n\t\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tif (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (daemon_msg_startcap_req(header.ver, &pars,\n\t\t\t\t    plen, source, &session, &samp_param,\n\t\t\t\t    uses_ssl) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_UPDATEFILTER_REQ:\n\t\t\t{\n\t\t\t\tif (session)\n\t\t\t\t{\n\t\t\t\t\tif (daemon_msg_updatefilter_req(header.ver,\n\t\t\t\t\t    &pars, session, plen) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (rpcap_senderror(pars.sockctrl, pars.ssl,\n\t\t\t\t\t    header.ver,\n\t\t\t\t\t    PCAP_ERR_UPDATEFILTER,\n\t\t\t\t\t    \"Device not opened. Cannot update filter\",\n\t\t\t\t\t    errbuf) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t// That failed; log a message and give up.\n\t\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_CLOSE:\t\t// The other endpoint close the pcap session\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Indicate to our caller that the client\n\t\t\t\t// closed the control connection.\n\t\t\t\t// This is used only in case of active mode.\n\t\t\t\t//\n\t\t\t\tclient_told_us_to_close = 1;\n\t\t\t\trpcapd_log(LOGPRIO_DEBUG, \"The other end system asked to close the connection.\");\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_STATS_REQ:\n\t\t\t{\n\t\t\t\tif (daemon_msg_stats_req(header.ver, &pars,\n\t\t\t\t    session, plen, &stats, svrcapt) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_ENDCAP_REQ:\t\t// The other endpoint close the current capture session\n\t\t\t{\n\t\t\t\tif (session)\n\t\t\t\t{\n\t\t\t\t\t// Save statistics (we can need them in the future)\n\t\t\t\t\tif (pcap_stats(session->fp, &stats))\n\t\t\t\t\t{\n\t\t\t\t\t\tsvrcapt = session->TotCapt;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstats.ps_ifdrop = 0;\n\t\t\t\t\t\tstats.ps_recv = 0;\n\t\t\t\t\t\tstats.ps_drop = 0;\n\t\t\t\t\t\tsvrcapt = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (daemon_msg_endcap_req(header.ver,\n\t\t\t\t\t    &pars, session) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tfree(session);\n\t\t\t\t\t\tsession = NULL;\n\t\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t\tfree(session);\n\t\t\t\t\tsession = NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trpcap_senderror(pars.sockctrl, pars.ssl,\n\t\t\t\t\t    header.ver,\n\t\t\t\t\t    PCAP_ERR_ENDCAPTURE,\n\t\t\t\t\t    \"Device not opened. Cannot close the capture\",\n\t\t\t\t\t    errbuf);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_SETSAMPLING_REQ:\n\t\t\t{\n\t\t\t\tif (daemon_msg_setsampling_req(header.ver,\n\t\t\t\t    &pars, plen, &samp_param) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error; a message has\n\t\t\t\t\t// been logged, so just give up.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase RPCAP_MSG_AUTH_REQ:\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// We're already authenticated; you don't\n\t\t\t\t// get to reauthenticate.\n\t\t\t\t//\n\t\t\t\trpcapd_log(LOGPRIO_INFO, \"The client sent an RPCAP_MSG_AUTH_REQ message after authentication was completed\");\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, pars.ssl,\n\t\t\t\t    header.ver,\n\t\t\t\t    PCAP_ERR_WRONGMSG,\n\t\t\t\t    \"RPCAP_MSG_AUTH_REQ request sent after authentication was completed\",\n\t\t\t\t    errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tgoto end;\n\n\t\t\tcase RPCAP_MSG_PACKET:\n\t\t\tcase RPCAP_MSG_FINDALLIF_REPLY:\n\t\t\tcase RPCAP_MSG_OPEN_REPLY:\n\t\t\tcase RPCAP_MSG_STARTCAP_REPLY:\n\t\t\tcase RPCAP_MSG_UPDATEFILTER_REPLY:\n\t\t\tcase RPCAP_MSG_AUTH_REPLY:\n\t\t\tcase RPCAP_MSG_STATS_REPLY:\n\t\t\tcase RPCAP_MSG_ENDCAP_REPLY:\n\t\t\tcase RPCAP_MSG_SETSAMPLING_REPLY:\n\t\t\t\t//\n\t\t\t\t// These are server-to-client messages.\n\t\t\t\t//\n\t\t\t\tmsg_type_string = rpcap_msg_type_string(header.type);\n\t\t\t\tif (msg_type_string != NULL)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_INFO, \"The client sent a %s server-to-client message\", msg_type_string);\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Server-to-client message %s received from client\", msg_type_string);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_INFO, \"The client sent a server-to-client message of type %u\", header.type);\n\t\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Server-to-client message of type %u received from client\", header.type);\n\t\t\t\t}\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, pars.ssl,\n\t\t\t\t    header.ver, PCAP_ERR_WRONGMSG,\n\t\t\t\t    errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tgoto end;\n\n\t\t\tdefault:\n\t\t\t\t//\n\t\t\t\t// Unknown message type.\n\t\t\t\t//\n\t\t\t\trpcapd_log(LOGPRIO_INFO, \"The client sent a message of type %u\", header.type);\n\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Unknown message type %u\", header.type);\n\t\t\t\tif (rpcap_senderror(pars.sockctrl, pars.ssl,\n\t\t\t\t    header.ver, PCAP_ERR_WRONGMSG,\n\t\t\t\t    errbuf, errmsgbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\t// Discard the rest of the message.\n\t\t\t\tif (rpcapd_discard(pars.sockctrl, pars.ssl, plen) == -1)\n\t\t\t\t{\n\t\t\t\t\t// Fatal error.\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t}\n\nend:\n\t// The service loop is finishing up.\n\t// If we have a capture session running, close it.\n\tif (session)\n\t{\n\t\tsession_close(session);\n\t\tfree(session);\n\t\tsession = NULL;\n\t}\n\n\t//\n\t// Finish using the SSL handle for the control socket, if we\n\t// have an SSL connection, and close the control socket.\n\t//\n#ifdef HAVE_OPENSSL\n\tif (ssl)\n\t{\n\t\t// Finish using the SSL handle for the socket.\n\t\t// This must be done *before* the socket is closed.\n\t\tssl_finish(ssl);\n\t}\n#endif\n\tsock_close(sockctrl, NULL, 0);\n\n\t// Print message and return\n\trpcapd_log(LOGPRIO_DEBUG, \"I'm exiting from the child loop\");\n\n\treturn client_told_us_to_close;\n}",
          "fn_code_pos": [
            [
              199,
              0
            ],
            [
              1112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_serviceloop",
            "parameters": {
              "sockctrl": "SOCKET",
              "isactive": "int",
              "passiveClients": "char",
              "nullAuthAllowed": "int",
              "uses_ssl": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndaemon_msg_err(SOCKET sockctrl, SSL *ssl, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\tchar remote_errbuf[PCAP_ERRBUF_SIZE];\n\n\tif (plen >= PCAP_ERRBUF_SIZE)\n\t{\n\t\t/*\n\t\t * Message is too long; just read as much of it as we\n\t\t * can into the buffer provided, and discard the rest.\n\t\t */\n\t\tif (sock_recv(sockctrl, ssl, remote_errbuf, PCAP_ERRBUF_SIZE - 1,\n\t\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\t\treturn -1;\n\t\t}\n\t\tif (rpcapd_discard(sockctrl, ssl, plen - (PCAP_ERRBUF_SIZE - 1)) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Null-terminate it.\n\t\t */\n\t\tremote_errbuf[PCAP_ERRBUF_SIZE - 1] = '\\0';\n\t}\n\telse if (plen == 0)\n\t{\n\t\t/* Empty error string. */\n\t\tremote_errbuf[0] = '\\0';\n\t}\n\telse\n\t{\n\t\tif (sock_recv(sockctrl, ssl, remote_errbuf, plen,\n\t\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Null-terminate it.\n\t\t */\n\t\tremote_errbuf[plen] = '\\0';\n\t}\n\t// Log the message\n\trpcapd_log(LOGPRIO_ERROR, \"Error from client: %s\", remote_errbuf);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1117,
              0
            ],
            [
              1172,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_err",
            "parameters": {
              "sockctrl": "SOCKET",
              "ssl": "SSL",
              "plen": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndaemon_msg_auth_req(struct daemon_slpars *pars, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tint status;\n\tstruct rpcap_auth auth;\t\t\t// RPCAP authentication header\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_authreply *authreply;\t// authentication reply message\n\n\tstatus = rpcapd_recv(pars->sockctrl, pars->ssl, (char *) &auth, sizeof(struct rpcap_auth), &plen, errmsgbuf);\n\tif (status == -1)\n\t{\n\t\treturn -1;\n\t}\n\tif (status == -2)\n\t{\n\t\tgoto error;\n\t}\n\n\tswitch (ntohs(auth.type))\n\t{\n\t\tcase RPCAP_RMTAUTH_NULL:\n\t\t{\n\t\t\tif (!pars->nullAuthAllowed)\n\t\t\t{\n\t\t\t\t// Send the client an error reply.\n\t\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Authentication failed; NULL authentication not permitted.\");\n\t\t\t\tif (rpcap_senderror(pars->sockctrl, pars->ssl,\n\t\t\t\t    0, PCAP_ERR_AUTH_FAILED, errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\t// That failed; log a message and give up.\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tgoto error_noreply;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase RPCAP_RMTAUTH_PWD:\n\t\t{\n\t\t\tchar *username, *passwd;\n\t\t\tuint32 usernamelen, passwdlen;\n\n\t\t\tusernamelen = ntohs(auth.slen1);\n\t\t\tusername = (char *) malloc (usernamelen + 1);\n\t\t\tif (username == NULL)\n\t\t\t{\n\t\t\t\tpcap_fmt_errmsg_for_errno(errmsgbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc() failed\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tstatus = rpcapd_recv(pars->sockctrl, pars->ssl, username, usernamelen, &plen, errmsgbuf);\n\t\t\tif (status == -1)\n\t\t\t{\n\t\t\t\tfree(username);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (status == -2)\n\t\t\t{\n\t\t\t\tfree(username);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tusername[usernamelen] = '\\0';\n\n\t\t\tpasswdlen = ntohs(auth.slen2);\n\t\t\tpasswd = (char *) malloc (passwdlen + 1);\n\t\t\tif (passwd == NULL)\n\t\t\t{\n\t\t\t\tpcap_fmt_errmsg_for_errno(errmsgbuf,\n\t\t\t\t    PCAP_ERRBUF_SIZE, errno, \"malloc() failed\");\n\t\t\t\tfree(username);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tstatus = rpcapd_recv(pars->sockctrl, pars->ssl, passwd, passwdlen, &plen, errmsgbuf);\n\t\t\tif (status == -1)\n\t\t\t{\n\t\t\t\tfree(username);\n\t\t\t\tfree(passwd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (status == -2)\n\t\t\t{\n\t\t\t\tfree(username);\n\t\t\t\tfree(passwd);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tpasswd[passwdlen] = '\\0';\n\n\t\t\tif (daemon_AuthUserPwd(username, passwd, errmsgbuf))\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Authentication failed.  Let the client\n\t\t\t\t// know.\n\t\t\t\t//\n\t\t\t\tfree(username);\n\t\t\t\tfree(passwd);\n\t\t\t\tif (rpcap_senderror(pars->sockctrl, pars->ssl,\n\t\t\t\t    0, PCAP_ERR_AUTH_FAILED, errmsgbuf, errbuf) == -1)\n\t\t\t\t{\n\t\t\t\t\t// That failed; log a message and give up.\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// Suspend for 1 second, so that they can't\n\t\t\t\t// hammer us with repeated tries with an\n\t\t\t\t// attack such as a dictionary attack.\n\t\t\t\t//\n\t\t\t\t// WARNING: this delay is inserted only\n\t\t\t\t// at this point; if the client closes the\n\t\t\t\t// connection and reconnects, the suspension\n\t\t\t\t// time does not have any effect.\n\t\t\t\t//\n\t\t\t\tsleep_secs(RPCAP_SUSPEND_WRONGAUTH);\n\t\t\t\tgoto error_noreply;\n\t\t\t}\n\n\t\t\tfree(username);\n\t\t\tfree(passwd);\n\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"Authentication type not recognized.\");\n\t\t\tif (rpcap_senderror(pars->sockctrl, pars->ssl,\n\t\t\t    0, PCAP_ERR_AUTH_TYPE_NOTSUP, errmsgbuf, errbuf) == -1)\n\t\t\t{\n\t\t\t\t// That failed; log a message and give up.\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tgoto error_noreply;\n\t}\n\n\t// The authentication succeeded; let the client know.\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, 0,\n\t    RPCAP_MSG_AUTH_REPLY, 0, sizeof(struct rpcap_authreply));\n\n\tauthreply = (struct rpcap_authreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_authreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\t//\n\t// Indicate to our peer what versions we support.\n\t//\n\tmemset(authreply, 0, sizeof(struct rpcap_authreply));\n\tauthreply->minvers = RPCAP_MIN_VERSION;\n\tauthreply->maxvers = RPCAP_MAX_VERSION;\n\n\t// Send the reply.\n\tif (sock_send(pars->sockctrl, pars->ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\t// That failed; log a messsage and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, pars->ssl, 0, PCAP_ERR_AUTH,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\nerror_noreply:\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn -2;\n}",
          "fn_code_pos": [
            [
              1196,
              0
            ],
            [
              1390,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_auth_req",
            "parameters": {
              "pars": "struct daemon_slpars",
              "plen": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndaemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\t/*\n\t * Warning: the user which launches the process must have the\n\t * SE_TCB_NAME right.\n\t * This corresponds to have the \"Act as part of the Operating System\"\n\t * turned on (administrative tools, local security settings, local\n\t * policies, user right assignment)\n\t * However, it seems to me that if you run it as a service, this\n\t * right should be provided by default.\n\t *\n\t * XXX - hopefully, this returns errors such as ERROR_LOGON_FAILURE,\n\t * which merely indicates that the user name or password is\n\t * incorrect, not whether it's the user name or the password\n\t * that's incorrect, so a client that's trying to brute-force\n\t * accounts doesn't know whether it's the user name or the\n\t * password that's incorrect, so it doesn't know whether to\n\t * stop trying to log in with a given user name and move on\n\t * to another user name.\n\t */\n\tHANDLE Token;\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_win32_err_to_str(GetLastError(), errbuf);\n\t\treturn -1;\n\t}\n\n\t// This call should change the current thread to the selected user.\n\t// I didn't test it.\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_win32_err_to_str(GetLastError(), errbuf);\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\n\tCloseHandle(Token);\n\treturn 0;\n\n#else\n\t/*\n\t * See\n\t *\n\t *\thttp://www.unixpapa.com/incnote/passwd.html\n\t *\n\t * We use the Solaris/Linux shadow password authentication if\n\t * we have getspnam(), otherwise we just do traditional\n\t * authentication, which, on some platforms, might work, even\n\t * with shadow passwords, if we're running as root.  Traditional\n\t * authenticaion won't work if we're not running as root, as\n\t * I think these days all UN*Xes either won't return the password\n\t * at all with getpwnam() or will only do so if you're root.\n\t *\n\t * XXX - perhaps what we *should* be using is PAM, if we have\n\t * it.  That might hide all the details of username/password\n\t * authentication, whether it's done with a visible-to-root-\n\t * only password database or some other authentication mechanism,\n\t * behind its API.\n\t */\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\n\t// This call is needed to get the uid\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\n#ifdef HAVE_GETSPNAM\n\t// This call is needed to get the password; otherwise 'x' is returned\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\t/*\n\t * XXX - what about other platforms?\n\t * The unixpapa.com page claims this Just Works on *BSD if you're\n\t * running as root - it's from 2000, so it doesn't indicate whether\n\t * macOS (which didn't come out until 2001, under the name Mac OS\n\t * X) behaves like the *BSDs or not, and might also work on AIX.\n\t * HP-UX does something else.\n\t *\n\t * Again, hopefully PAM hides all that.\n\t */\n\tuser_password = user->pw_passwd;\n#endif\n\n\tif (strcmp(user_password, (char *) crypt(password, user_password)) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\n\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}\n\n/*\tif (setgid(user->pw_gid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setgid\");\n\t\treturn -1;\n\t}\n*/\n\treturn 0;\n\n#endif\n\n}",
          "fn_code_pos": [
            [
              1392,
              0
            ],
            [
              1512,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_AuthUserPwd",
            "parameters": {
              "username": "char",
              "password": "char",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndaemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tpcap_if_t *alldevs = NULL;\t\t// pointer to the header of the interface chain\n\tpcap_if_t *d;\t\t\t\t// temp pointer needed to scan the interface chain\n\tstruct pcap_addr *address;\t\t// pcap structure that keeps a network address of an interface\n\tstruct rpcap_findalldevs_if *findalldevs_if;// rpcap structure that packet all the data of an interface together\n\tuint16 nif = 0;\t\t\t\t// counts the number of interface listed\n\n\t// Discard the rest of the message; there shouldn't be any payload.\n\tif (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\t// Retrieve the device list\n\tif (pcap_findalldevs(&alldevs, errmsgbuf) == -1)\n\t\tgoto error;\n\n\tif (alldevs == NULL)\n\t{\n\t\tif (rpcap_senderror(pars->sockctrl, pars->ssl, ver,\n\t\t\tPCAP_ERR_NOREMOTEIF,\n\t\t\t\"No interfaces found! Make sure libpcap/WinPcap is properly installed\"\n\t\t\t\" and you have the right to access to the remote device.\",\n\t\t\terrbuf) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// checks the number of interfaces and it computes the total length of the payload\n\tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tnif++;\n\n\t\tif (d->description)\n\t\t\tplen+= strlen(d->description);\n\t\tif (d->name)\n\t\t\tplen+= strlen(d->name);\n\n\t\tplen+= sizeof(struct rpcap_findalldevs_if);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tplen+= (sizeof(struct rpcap_sockaddr) * 4);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// RPCAP findalldevs command\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf,\n\t    PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_FINDALLIF_REPLY, nif, plen);\n\n\t// send the interface list\n\tfor (d = alldevs; d != NULL; d = d->next)\n\t{\n\t\tuint16 lname, ldescr;\n\n\t\tfindalldevs_if = (struct rpcap_findalldevs_if *) &sendbuf[sendbufidx];\n\n\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_findalldevs_if), NULL,\n\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tmemset(findalldevs_if, 0, sizeof(struct rpcap_findalldevs_if));\n\n\t\tif (d->description) ldescr = (short) strlen(d->description);\n\t\telse ldescr = 0;\n\t\tif (d->name) lname = (short) strlen(d->name);\n\t\telse lname = 0;\n\n\t\tfindalldevs_if->desclen = htons(ldescr);\n\t\tfindalldevs_if->namelen = htons(lname);\n\t\tfindalldevs_if->flags = htonl(d->flags);\n\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tfindalldevs_if->naddr++;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfindalldevs_if->naddr = htons(findalldevs_if->naddr);\n\n\t\tif (sock_bufferize(d->name, lname, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tif (sock_bufferize(d->description, ldescr, sendbuf, &sendbufidx,\n\t\t    RPCAP_NETBUF_SIZE, SOCKBUF_BUFFERIZE, errmsgbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\t// send all addresses\n\t\tfor (address = d->addresses; address != NULL; address = address->next)\n\t\t{\n\t\t\tstruct rpcap_sockaddr *sockaddr;\n\n\t\t\t/*\n\t\t\t * Send only IPv4 and IPv6 addresses over the wire.\n\t\t\t */\n\t\t\tswitch (address->addr->sa_family)\n\t\t\t{\n\t\t\tcase AF_INET:\n#ifdef AF_INET6\n\t\t\tcase AF_INET6:\n#endif\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->addr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->netmask, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->broadaddr, sockaddr);\n\n\t\t\t\tsockaddr = (struct rpcap_sockaddr *) &sendbuf[sendbufidx];\n\t\t\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_sockaddr), NULL,\n\t\t\t\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\t\t\tgoto error;\n\t\t\t\tdaemon_seraddr((struct sockaddr_storage *) address->dstaddr, sockaddr);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// We no longer need the device list. Free it.\n\tpcap_freealldevs(alldevs);\n\n\t// Send a final command that says \"now send it!\"\n\tif (sock_send(pars->sockctrl, pars->ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (alldevs)\n\t\tpcap_freealldevs(alldevs);\n\n\tif (rpcap_senderror(pars->sockctrl, pars->ssl, ver,\n\t    PCAP_ERR_FINDALLIF, errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1514,
              0
            ],
            [
              1713,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_findallif_req",
            "parameters": {
              "ver": "uint8",
              "pars": "struct daemon_slpars",
              "plen": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndaemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, size_t sourcelen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tpcap_t *fp;\t\t\t\t// pcap_t main variable\n\tint nread;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_openreply *openreply;\t// open reply message\n\n\tif (plen > sourcelen - 1)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string too long\");\n\t\tgoto error;\n\t}\n\n\tnread = sock_recv(pars->sockctrl, pars->ssl, source, plen,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\tsource[nread] = '\\0';\n\tplen -= nread;\n\n\t// XXX - make sure it's *not* a URL; we don't support opening\n\t// remote devices here.\n\n\t// Open the selected device\n\t// This is a fake open, since we do that only to get the needed parameters, then we close the device again\n\tif ((fp = pcap_open_live(source,\n\t\t\t1500 /* fake snaplen */,\n\t\t\t0 /* no promis */,\n\t\t\t1000 /* fake timeout */,\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n\t// Now, I can send a RPCAP open reply message\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));\n\n\topenreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(openreply, 0, sizeof(struct rpcap_openreply));\n\topenreply->linktype = htonl(pcap_datalink(fp));\n\t/*\n\t * This is always 0 for live captures; we no longer support it\n\t * as something we read from capture files and supply to\n\t * clients, but we have to send it over the wire, as open\n\t * replies are expected to have 8 bytes of payload by\n\t * existing clients.\n\t */\n\topenreply->tzoff = 0;\n\n\t// We're done with the pcap_t.\n\tpcap_close(fp);\n\n\t// Send the reply.\n\tif (sock_send(pars->sockctrl, pars->ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, pars->ssl, ver, PCAP_ERR_OPEN,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1719,
              0
            ],
            [
              1810,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_open_req",
            "parameters": {
              "ver": "uint8",
              "pars": "struct daemon_slpars",
              "plen": "uint32",
              "source": "char",
              "sourcelen": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndaemon_msg_startcap_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, struct session **sessionp,\n    struct rpcap_sampling *samp_param _U_, int uses_ssl)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tchar portdata[PCAP_BUF_SIZE];\t\t// temp variable needed to derive the data port\n\tchar peerhost[PCAP_BUF_SIZE];\t\t// temp variable needed to derive the host name of our peer\n\tstruct session *session = NULL;\t\t// saves state of session\n\tint status;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\n\t// socket-related variables\n\tstruct addrinfo hints;\t\t\t// temp, needed to open a socket connection\n\tstruct addrinfo *addrinfo;\t\t// temp, needed to open a socket connection\n\tstruct sockaddr_storage saddr;\t\t// temp, needed to retrieve the network data port chosen on the local machine\n\tsocklen_t saddrlen;\t\t\t// temp, needed to retrieve the network data port chosen on the local machine\n\tint ret;\t\t\t\t// return value from functions\n\n\t// RPCAP-related variables\n\tstruct rpcap_startcapreq startcapreq;\t\t// start capture request message\n\tstruct rpcap_startcapreply *startcapreply;\t// start capture reply message\n\tint serveropen_dp;\t\t\t\t\t\t\t// keeps who is going to open the data connection\n\n\taddrinfo = NULL;\n\n\tstatus = rpcapd_recv(pars->sockctrl, pars->ssl, (char *) &startcapreq,\n\t    sizeof(struct rpcap_startcapreq), &plen, errmsgbuf);\n\tif (status == -1)\n\t{\n\t\tgoto fatal_error;\n\t}\n\tif (status == -2)\n\t{\n\t\tgoto error;\n\t}\n\n\tstartcapreq.flags = ntohs(startcapreq.flags);\n\n\t// Check that the client does not ask for UDP is the server has been asked\n\t// to enforce encryption, as SSL is not supported yet with UDP:\n\tif (uses_ssl && (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_DGRAM))\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"SSL not supported with UDP forward of remote packets\");\n\t\tgoto error;\n\t}\n\n\t// Create a session structure\n\tsession = malloc(sizeof(struct session));\n\tif (session == NULL)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Can't allocate session structure\");\n\t\tgoto error;\n\t}\n\n\tsession->sockdata = INVALID_SOCKET;\n\tsession->ctrl_ssl = session->data_ssl = NULL;\n\t// We don't have a thread yet.\n\tsession->have_thread = 0;\n\t//\n\t// We *shouldn't* have to initialize the thread indicator\n\t// itself, because the compiler *should* realize that we\n\t// only use this if have_thread isn't 0, but we *do* have\n\t// to do it, because not all compilers *do* realize that.\n\t//\n\t// There is no \"invalid thread handle\" value for a UN*X\n\t// pthread_t, so we just zero it out.\n\t//\n#ifdef _WIN32\n\tsession->thread = INVALID_HANDLE_VALUE;\n#else\n\tmemset(&session->thread, 0, sizeof(session->thread));\n#endif\n\n\t// Open the selected device\n\tif ((session->fp = pcap_open_live(source,\n\t\t\tntohl(startcapreq.snaplen),\n\t\t\t(startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_PROMISC) ? 1 : 0 /* local device, other flags not needed */,\n\t\t\tntohl(startcapreq.read_timeout),\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n#if 0\n\t// Apply sampling parameters\n\tfp->rmt_samp.method = samp_param->method;\n\tfp->rmt_samp.value = samp_param->value;\n#endif\n\n\t/*\n\tWe're in active mode if:\n\t- we're using TCP, and the user wants us to be in active mode\n\t- we're using UDP\n\t*/\n\tserveropen_dp = (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_SERVEROPEN) || (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_DGRAM) || pars->isactive;\n\n\t/*\n\tGets the sockaddr structure referred to the other peer in the ctrl connection\n\n\tWe need that because:\n\t- if we're in passive mode, we need to know the address family we want to use\n\t(the same used for the ctrl socket)\n\t- if we're in active mode, we need to know the network address of the other host\n\twe want to connect to\n\t*/\n\tsaddrlen = sizeof(struct sockaddr_storage);\n\tif (getpeername(pars->sockctrl, (struct sockaddr *) &saddr, &saddrlen) == -1)\n\t{\n\t\tsock_geterror(\"getpeername(): \", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\tgoto error;\n\t}\n\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_socktype = (startcapreq.flags & RPCAP_STARTCAPREQ_FLAG_DGRAM) ? SOCK_DGRAM : SOCK_STREAM;\n\thints.ai_family = saddr.ss_family;\n\n\t// Now we have to create a new socket to send packets\n\tif (serveropen_dp)\t\t// Data connection is opened by the server toward the client\n\t{\n\t\tpcap_snprintf(portdata, sizeof portdata, \"%d\", ntohs(startcapreq.portdata));\n\n\t\t// Get the name of the other peer (needed to connect to that specific network address)\n\t\tif (getnameinfo((struct sockaddr *) &saddr, saddrlen, peerhost,\n\t\t\t\tsizeof(peerhost), NULL, 0, NI_NUMERICHOST))\n\t\t{\n\t\t\tsock_geterror(\"getnameinfo(): \", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sock_initaddress(peerhost, portdata, &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tif ((session->sockdata = sock_open(addrinfo, SOCKOPEN_CLIENT, 0, errmsgbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n\t\t\tgoto error;\n\t}\n\telse\t\t// Data connection is opened by the client toward the server\n\t{\n\t\thints.ai_flags = AI_PASSIVE;\n\n\t\t// Let's the server socket pick up a free network port for us\n\t\tif (sock_initaddress(NULL, \"0\", &hints, &addrinfo, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t\tgoto error;\n\n\t\tif ((session->sockdata = sock_open(addrinfo, SOCKOPEN_SERVER, 1 /* max 1 connection in queue */, errmsgbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n\t\t\tgoto error;\n\n\t\t// get the complete sockaddr structure used in the data connection\n\t\tsaddrlen = sizeof(struct sockaddr_storage);\n\t\tif (getsockname(session->sockdata, (struct sockaddr *) &saddr, &saddrlen) == -1)\n\t\t{\n\t\t\tsock_geterror(\"getsockname(): \", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\tgoto error;\n\t\t}\n\n\t\t// Get the local port the system picked up\n\t\tif (getnameinfo((struct sockaddr *) &saddr, saddrlen, NULL,\n\t\t\t\t0, portdata, sizeof(portdata), NI_NUMERICSERV))\n\t\t{\n\t\t\tsock_geterror(\"getnameinfo(): \", errmsgbuf, PCAP_ERRBUF_SIZE);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t// addrinfo is no longer used\n\tfreeaddrinfo(addrinfo);\n\taddrinfo = NULL;\n\n\t// Needed to send an error on the ctrl connection\n\tsession->sockctrl = pars->sockctrl;\n\tsession->ctrl_ssl = pars->ssl;\n\tsession->protocol_version = ver;\n\n\t// Now I can set the filter\n\tret = daemon_unpackapplyfilter(pars->sockctrl, pars->ssl, session, &plen, errmsgbuf);\n\tif (ret == -1)\n\t{\n\t\t// Fatal error.  A message has been logged; just give up.\n\t\tgoto fatal_error;\n\t}\n\tif (ret == -2)\n\t{\n\t\t// Non-fatal error.  Send an error message to the client.\n\t\tgoto error;\n\t}\n\n\t// Now, I can send a RPCAP start capture reply message\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_STARTCAP_REPLY, 0, sizeof(struct rpcap_startcapreply));\n\n\tstartcapreply = (struct rpcap_startcapreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_startcapreply), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(startcapreply, 0, sizeof(struct rpcap_startcapreply));\n\tstartcapreply->bufsize = htonl(pcap_bufsize(session->fp));\n\n\tif (!serveropen_dp)\n\t{\n\t\tunsigned short port = (unsigned short)strtoul(portdata,NULL,10);\n\t\tstartcapreply->portdata = htons(port);\n\t}\n\n\tif (sock_send(pars->sockctrl, pars->ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\tgoto fatal_error;\n\t}\n\n\tif (!serveropen_dp)\n\t{\n\t\tSOCKET socktemp;\t// We need another socket, since we're going to accept() a connection\n\n\t\t// Connection creation\n\t\tsaddrlen = sizeof(struct sockaddr_storage);\n\n\t\tsocktemp = accept(session->sockdata, (struct sockaddr *) &saddr, &saddrlen);\n\n\t\tif (socktemp == INVALID_SOCKET)\n\t\t{\n\t\t\tsock_geterror(\"accept(): \", errbuf, PCAP_ERRBUF_SIZE);\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Accept of data connection failed: %s\",\n\t\t\t    errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\t// Now that I accepted the connection, the server socket is no longer needed\n\t\tsock_close(session->sockdata, NULL, 0);\n\t\tsession->sockdata = socktemp;\n\t}\n\n\tSSL *ssl = NULL;\n\tif (uses_ssl)\n\t{\n#ifdef HAVE_OPENSSL\n\t\t/* In both active or passive cases, wait for the client to initiate the\n\t\t * TLS handshake. Yes during that time the control socket will not be\n\t\t * served, but the same was true from the above call to accept(). */\n\t\tssl = ssl_promotion(1, session->sockdata, errbuf, PCAP_ERRBUF_SIZE);\n\t\tif (! ssl)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"TLS handshake failed: %s\", errbuf);\n\t\t\tgoto error;\n\t\t}\n#endif\n\t}\n\tsession->data_ssl = ssl;\n\n\t// Now we have to create a new thread to receive packets\n#ifdef _WIN32\n\tsession->thread = (HANDLE)_beginthreadex(NULL, 0, daemon_thrdatamain,\n\t    (void *) session, 0, NULL);\n\tif (session->thread == 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Error creating the data thread\");\n\t\tgoto error;\n\t}\n#else\n\tret = pthread_create(&session->thread, NULL, daemon_thrdatamain,\n\t    (void *) session);\n\tif (ret != 0)\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    ret, \"Error creating the data thread\");\n\t\tgoto error;\n\t}\n#endif\n\tsession->have_thread = 1;\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)\n\t\tgoto fatal_error;\n\n\t*sessionp = session;\n\treturn 0;\n\nerror:\n\t//\n\t// Not a fatal error, so send the client an error message and\n\t// keep serving client requests.\n\t//\n\t*sessionp = NULL;\n\n\tif (addrinfo)\n\t\tfreeaddrinfo(addrinfo);\n\n\tif (session)\n\t{\n\t\tsession_close(session);\n\t\tfree(session);\n\t}\n\n\tif (rpcap_senderror(pars->sockctrl, pars->ssl, ver,\n\t    PCAP_ERR_STARTCAPTURE, errmsgbuf, errbuf) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nfatal_error:\n\t//\n\t// Fatal network error, so don't try to communicate with\n\t// the client, just give up.\n\t//\n\t*sessionp = NULL;\n\n\tif (session)\n\t{\n\t\tsession_close(session);\n\t\tfree(session);\n\t}\n\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              1816,
              0
            ],
            [
              2147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_startcap_req",
            "parameters": {
              "ver": "uint8",
              "pars": "struct daemon_slpars",
              "plen": "uint32",
              "source": "char",
              "sessionp": "struct session",
              "samp_param": "struct rpcap_sampling",
              "uses_ssl": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndaemon_msg_endcap_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tstruct rpcap_header header;\n\n\tsession_close(session);\n\n\trpcap_createhdr(&header, ver, RPCAP_MSG_ENDCAP_REPLY, 0, 0);\n\n\tif (sock_send(pars->sockctrl, pars->ssl, (char *) &header, sizeof(struct rpcap_header), errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              2149,
              0
            ],
            [
              2168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_endcap_req",
            "parameters": {
              "ver": "uint8",
              "pars": "struct daemon_slpars",
              "session": "struct session"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndaemon_unpackapplyfilter(SOCKET sockctrl, SSL *ctrl_ssl, struct session *session, uint32 *plenp, char *errmsgbuf)\n{\n\tint status;\n\tstruct rpcap_filter filter;\n\tstruct rpcap_filterbpf_insn insn;\n\tstruct bpf_insn *bf_insn;\n\tstruct bpf_program bf_prog;\n\tunsigned int i;\n\n\tstatus = rpcapd_recv(sockctrl, ctrl_ssl, (char *) &filter,\n\t    sizeof(struct rpcap_filter), plenp, errmsgbuf);\n\tif (status == -1)\n\t{\n\t\treturn -1;\n\t}\n\tif (status == -2)\n\t{\n\t\treturn -2;\n\t}\n\n\tbf_prog.bf_len = ntohl(filter.nitems);\n\n\tif (ntohs(filter.filtertype) != RPCAP_UPDATEFILTER_BPF)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Only BPF/NPF filters are currently supported\");\n\t\treturn -2;\n\t}\n\n\tbf_insn = (struct bpf_insn *) malloc (sizeof(struct bpf_insn) * bf_prog.bf_len);\n\tif (bf_insn == NULL)\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errmsgbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"malloc() failed\");\n\t\treturn -2;\n\t}\n\n\tbf_prog.bf_insns = bf_insn;\n\n\tfor (i = 0; i < bf_prog.bf_len; i++)\n\t{\n\t\tstatus = rpcapd_recv(sockctrl, ctrl_ssl, (char *) &insn,\n\t\t    sizeof(struct rpcap_filterbpf_insn), plenp, errmsgbuf);\n\t\tif (status == -1)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\tif (status == -2)\n\t\t{\n\t\t\treturn -2;\n\t\t}\n\n\t\tbf_insn->code = ntohs(insn.code);\n\t\tbf_insn->jf = insn.jf;\n\t\tbf_insn->jt = insn.jt;\n\t\tbf_insn->k = ntohl(insn.k);\n\n\t\tbf_insn++;\n\t}\n\n\t//\n\t// XXX - pcap_setfilter() should do the validation for us.\n\t//\n\tif (bpf_validate(bf_prog.bf_insns, bf_prog.bf_len) == 0)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"The filter contains bogus instructions\");\n\t\treturn -2;\n\t}\n\n\tif (pcap_setfilter(session->fp, &bf_prog))\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"RPCAP error: %s\", pcap_geterr(session->fp));\n\t\treturn -2;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              2170,
              0
            ],
            [
              2246,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_unpackapplyfilter",
            "parameters": {
              "sockctrl": "SOCKET",
              "ctrl_ssl": "SSL",
              "session": "struct session",
              "plenp": "uint32",
              "errmsgbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndaemon_msg_updatefilter_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session, uint32 plen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tint ret;\t\t\t\t// status of daemon_unpackapplyfilter()\n\tstruct rpcap_header header;\t\t// keeps the answer to the updatefilter command\n\n\tret = daemon_unpackapplyfilter(pars->sockctrl, pars->ssl, session, &plen, errmsgbuf);\n\tif (ret == -1)\n\t{\n\t\t// Fatal error.  A message has been logged; just give up.\n\t\treturn -1;\n\t}\n\tif (ret == -2)\n\t{\n\t\t// Non-fatal error.  Send an error reply to the client.\n\t\tgoto error;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\t// A response is needed, otherwise the other host does not know that everything went well\n\trpcap_createhdr(&header, ver, RPCAP_MSG_UPDATEFILTER_REPLY, 0, 0);\n\n\tif (sock_send(pars->sockctrl, pars->ssl, (char *) &header, sizeof (struct rpcap_header), pcap_geterr(session->fp), PCAP_ERRBUF_SIZE))\n\t{\n\t\t// That failed; log a messsage and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\trpcap_senderror(pars->sockctrl, pars->ssl, ver, PCAP_ERR_UPDATEFILTER,\n\t    errmsgbuf, NULL);\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              2248,
              0
            ],
            [
              2297,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_updatefilter_req",
            "parameters": {
              "ver": "uint8",
              "pars": "struct daemon_slpars",
              "session": "struct session",
              "plen": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndaemon_msg_setsampling_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    struct rpcap_sampling *samp_param)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\n\tstruct rpcap_header header;\n\tstruct rpcap_sampling rpcap_samp;\n\tint status;\n\n\tstatus = rpcapd_recv(pars->sockctrl, pars->ssl, (char *) &rpcap_samp, sizeof(struct rpcap_sampling), &plen, errmsgbuf);\n\tif (status == -1)\n\t{\n\t\treturn -1;\n\t}\n\tif (status == -2)\n\t{\n\t\tgoto error;\n\t}\n\n\t// Save these settings in the pcap_t\n\tsamp_param->method = rpcap_samp.method;\n\tsamp_param->value = ntohl(rpcap_samp.value);\n\n\t// A response is needed, otherwise the other host does not know that everything went well\n\trpcap_createhdr(&header, ver, RPCAP_MSG_SETSAMPLING_REPLY, 0, 0);\n\n\tif (sock_send(pars->sockctrl, pars->ssl, (char *) &header, sizeof (struct rpcap_header), errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\t// That failed; log a messsage and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\tif (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, pars->ssl, ver, PCAP_ERR_SETSAMPLING,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\t// That failed; log a message and give up.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\t// Check if all the data has been read; if not, discard the data in excess\n\tif (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              2302,
              0
            ],
            [
              2359,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_setsampling_req",
            "parameters": {
              "ver": "uint8",
              "pars": "struct daemon_slpars",
              "plen": "uint32",
              "samp_param": "struct rpcap_sampling"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ndaemon_msg_stats_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session, uint32 plen, struct pcap_stat *stats,\n    unsigned int svrcapt)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_stats *netstats;\t\t// statistics sent on the network\n\n\t// Checks that the header does not contain other data; if so, discard it\n\tif (rpcapd_discard(pars->sockctrl, pars->ssl, plen) == -1)\n\t{\n\t\t// Network error.\n\t\treturn -1;\n\t}\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_STATS_REPLY, 0, (uint16) sizeof(struct rpcap_stats));\n\n\tnetstats = (struct rpcap_stats *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_stats), NULL,\n\t    &sendbufidx, RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tif (session && session->fp)\n\t{\n\t\tif (pcap_stats(session->fp, stats) == -1)\n\t\t{\n\t\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"%s\", pcap_geterr(session->fp));\n\t\t\tgoto error;\n\t\t}\n\n\t\tnetstats->ifdrop = htonl(stats->ps_ifdrop);\n\t\tnetstats->ifrecv = htonl(stats->ps_recv);\n\t\tnetstats->krnldrop = htonl(stats->ps_drop);\n\t\tnetstats->svrcapt = htonl(session->TotCapt);\n\t}\n\telse\n\t{\n\t\t// We have to keep compatibility with old applications,\n\t\t// which ask for statistics also when the capture has\n\t\t// already stopped.\n\t\tnetstats->ifdrop = htonl(stats->ps_ifdrop);\n\t\tnetstats->ifrecv = htonl(stats->ps_recv);\n\t\tnetstats->krnldrop = htonl(stats->ps_drop);\n\t\tnetstats->svrcapt = htonl(svrcapt);\n\t}\n\n\t// Send the packet\n\tif (sock_send(pars->sockctrl, pars->ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n\nerror:\n\trpcap_senderror(pars->sockctrl, pars->ssl, ver, PCAP_ERR_GETSTATS,\n\t    errmsgbuf, NULL);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              2361,
              0
            ],
            [
              2429,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_stats_req",
            "parameters": {
              "ver": "uint8",
              "pars": "struct daemon_slpars",
              "session": "struct session",
              "plen": "uint32",
              "stats": "struct pcap_stat",
              "svrcapt": "unsigned int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void *\n#endif\ndaemon_thrdatamain(void *ptr)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\t// error buffer\n\tstruct session *session;\t\t// pointer to the struct session for this session\n\tint retval;\t\t\t\t\t\t\t// general variable used to keep the return value of other functions\n\tstruct rpcap_pkthdr *net_pkt_header;// header of the packet\n\tstruct pcap_pkthdr *pkt_header;\t\t// pointer to the buffer that contains the header of the current packet\n\tu_char *pkt_data;\t\t\t\t\t// pointer to the buffer that contains the current packet\n\tsize_t sendbufsize;\t\t\t// size for the send buffer\n\tchar *sendbuf;\t\t\t\t\t\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx;\t\t\t\t\t\t// index which keeps the number of bytes currently buffered\n\tint status;\n#ifndef _WIN32\n\tsigset_t sigusr1;\t\t\t// signal set with just SIGUSR1\n#endif\n\n\tsession = (struct session *) ptr;\n\n\tsession->TotCapt = 0;\t\t\t// counter which is incremented each time a packet is received\n\n\t// Initialize errbuf\n\tmemset(errbuf, 0, sizeof(errbuf));\n\n\t//\n\t// We need a buffer large enough to hold a buffer large enough\n\t// for a maximum-size packet for this pcap_t.\n\t//\n\tif (pcap_snapshot(session->fp) < 0)\n\t{\n\t\t//\n\t\t// The snapshot length is negative.\n\t\t// This \"should not happen\".\n\t\t//\n\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t    \"Unable to allocate the buffer for this child thread: snapshot length of %d is negative\",\n\t\t        pcap_snapshot(session->fp));\n\t\tsendbuf = NULL;\t// we can't allocate a buffer, so nothing to free\n\t\tgoto error;\n\t}\n\t//\n\t// size_t is unsigned, and the result of pcap_snapshot() is signed;\n\t// on no platform that we support is int larger than size_t.\n\t// This means that, unless the extra information we prepend to\n\t// a maximum-sized packet is impossibly large, the sum of the\n\t// snapshot length and the size of that extra information will\n\t// fit in a size_t.\n\t//\n\t// So we don't need to make sure that sendbufsize will overflow.\n\t//\n\t// However, we *do* need to make sure its value fits in an int,\n\t// because sock_send() can't send more than INT_MAX bytes (it could\n\t// do so on 64-bit UN*Xes, but can't do so on Windows, not even\n\t// 64-bit Windows, as the send() buffer size argument is an int\n\t// in Winsock).\n\t//\n\tsendbufsize = sizeof(struct rpcap_header) + sizeof(struct rpcap_pkthdr) + pcap_snapshot(session->fp);\n\tif (sendbufsize > INT_MAX)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t    \"Buffer size for this child thread would be larger than %d\",\n\t\t    INT_MAX);\n\t\tsendbuf = NULL;\t// we haven't allocated a buffer, so nothing to free\n\t\tgoto error;\n\t}\n\tsendbuf = (char *) malloc (sendbufsize);\n\tif (sendbuf == NULL)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t    \"Unable to allocate the buffer for this child thread\");\n\t\tgoto error;\n\t}\n\n#ifndef _WIN32\n\t//\n\t// Set the signal set to include just SIGUSR1, and block that\n\t// signal; we only want it unblocked when we're reading\n\t// packets - we dn't want any other system calls, such as\n\t// ones being used to send to the client or to log messages,\n\t// to be interrupted.\n\t//\n\tsigemptyset(&sigusr1);\n\tsigaddset(&sigusr1, SIGUSR1);\n\tpthread_sigmask(SIG_BLOCK, &sigusr1, NULL);\n#endif\n\n\t// Retrieve the packets\n\tfor (;;)\n\t{\n#ifndef _WIN32\n\t\t//\n\t\t// Unblock SIGUSR1 while we might be waiting for packets.\n\t\t//\n\t\tpthread_sigmask(SIG_UNBLOCK, &sigusr1, NULL);\n#endif\n\t\tretval = pcap_next_ex(session->fp, &pkt_header, (const u_char **) &pkt_data);\t// cast to avoid a compiler warning\n#ifndef _WIN32\n\t\t//\n\t\t// Now block it again.\n\t\t//\n\t\tpthread_sigmask(SIG_BLOCK, &sigusr1, NULL);\n#endif\n\t\tif (retval < 0)\n\t\t\tbreak;\t\t// error\n\t\tif (retval == 0)\t// Read timeout elapsed\n\t\t\tcontinue;\n\n\t\tsendbufidx = 0;\n\n\t\t// Bufferize the general header\n\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL,\n\t\t    &sendbufidx, (int)sendbufsize, SOCKBUF_CHECKONLY, errbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t    \"sock_bufferize() error sending packet message: %s\",\n\t\t\t    errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\trpcap_createhdr((struct rpcap_header *) sendbuf,\n\t\t    session->protocol_version, RPCAP_MSG_PACKET, 0,\n\t\t    (uint16) (sizeof(struct rpcap_pkthdr) + pkt_header->caplen));\n\n\t\tnet_pkt_header = (struct rpcap_pkthdr *) &sendbuf[sendbufidx];\n\n\t\t// Bufferize the pkt header\n\t\tif (sock_bufferize(NULL, sizeof(struct rpcap_pkthdr), NULL,\n\t\t    &sendbufidx, (int)sendbufsize, SOCKBUF_CHECKONLY, errbuf,\n\t\t    PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t    \"sock_bufferize() error sending packet message: %s\",\n\t\t\t    errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tnet_pkt_header->caplen = htonl(pkt_header->caplen);\n\t\tnet_pkt_header->len = htonl(pkt_header->len);\n\t\tnet_pkt_header->npkt = htonl(++(session->TotCapt));\n\t\t//\n\t\t// This protocol needs to be updated with a new version\n\t\t// before 2038-01-19 03:14:07 UTC.\n\t\t//\n\t\tnet_pkt_header->timestamp_sec = htonl((uint32)pkt_header->ts.tv_sec);\n\t\tnet_pkt_header->timestamp_usec = htonl((uint32)pkt_header->ts.tv_usec);\n\n\t\t// Bufferize the pkt data\n\t\tif (sock_bufferize((char *) pkt_data, pkt_header->caplen,\n\t\t    sendbuf, &sendbufidx, (int)sendbufsize, SOCKBUF_BUFFERIZE,\n\t\t    errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t    \"sock_bufferize() error sending packet message: %s\",\n\t\t\t    errbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\t// Send the packet\n\t\t// If the client dropped the connection, don't report an\n\t\t// error, just quit.\n\t\tstatus = sock_send(session->sockdata, session->data_ssl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE);\n\t\tif (status < 0)\n\t\t{\n\t\t\tif (status == -1)\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Error other than \"client closed the\n\t\t\t\t// connection out from under us\"; report\n\t\t\t\t// it.\n\t\t\t\t//\n\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t    \"Send of packet to client failed: %s\",\n\t\t\t\t    errbuf);\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Give up in either case.\n\t\t\t//\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (retval < 0 && retval != PCAP_ERROR_BREAK)\n\t{\n\t\t//\n\t\t// Failed with an error other than \"we were told to break\n\t\t// out of the loop\".\n\t\t//\n\t\t// The latter just means that the client told us to stop\n\t\t// capturing, so there's no error to report.\n\t\t//\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Error reading the packets: %s\", pcap_geterr(session->fp));\n\t\trpcap_senderror(session->sockctrl, session->ctrl_ssl, session->protocol_version,\n\t\t    PCAP_ERR_READEX, errbuf, NULL);\n\t}\n\nerror:\n\t//\n\t// The main thread will clean up the session structure.\n\t//\n\tfree(sendbuf);\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              2434,
              0
            ],
            [
              2639,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_thrdatamain",
            "parameters": {
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void noop_handler(int sign _U_)\n{\n}",
          "fn_code_pos": [
            [
              2647,
              0
            ],
            [
              2649,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "noop_handler",
            "parameters": {
              "sign": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ndaemon_seraddr(struct sockaddr_storage *sockaddrin, struct rpcap_sockaddr *sockaddrout)\n{\n\tmemset(sockaddrout, 0, sizeof(struct sockaddr_storage));\n\n\t// There can be the case in which the sockaddrin is not available\n\tif (sockaddrin == NULL) return;\n\n\t// Warning: we support only AF_INET and AF_INET6\n\tswitch (sockaddrin->ss_family)\n\t{\n\tcase AF_INET:\n\t\t{\n\t\tstruct sockaddr_in *sockaddrin_ipv4;\n\t\tstruct rpcap_sockaddr_in *sockaddrout_ipv4;\n\n\t\tsockaddrin_ipv4 = (struct sockaddr_in *) sockaddrin;\n\t\tsockaddrout_ipv4 = (struct rpcap_sockaddr_in *) sockaddrout;\n\t\tsockaddrout_ipv4->family = htons(RPCAP_AF_INET);\n\t\tsockaddrout_ipv4->port = htons(sockaddrin_ipv4->sin_port);\n\t\tmemcpy(&sockaddrout_ipv4->addr, &sockaddrin_ipv4->sin_addr, sizeof(sockaddrout_ipv4->addr));\n\t\tmemset(sockaddrout_ipv4->zero, 0, sizeof(sockaddrout_ipv4->zero));\n\t\tbreak;\n\t\t}\n\n#ifdef AF_INET6\n\tcase AF_INET6:\n\t\t{\n\t\tstruct sockaddr_in6 *sockaddrin_ipv6;\n\t\tstruct rpcap_sockaddr_in6 *sockaddrout_ipv6;\n\n\t\tsockaddrin_ipv6 = (struct sockaddr_in6 *) sockaddrin;\n\t\tsockaddrout_ipv6 = (struct rpcap_sockaddr_in6 *) sockaddrout;\n\t\tsockaddrout_ipv6->family = htons(RPCAP_AF_INET6);\n\t\tsockaddrout_ipv6->port = htons(sockaddrin_ipv6->sin6_port);\n\t\tsockaddrout_ipv6->flowinfo = htonl(sockaddrin_ipv6->sin6_flowinfo);\n\t\tmemcpy(&sockaddrout_ipv6->addr, &sockaddrin_ipv6->sin6_addr, sizeof(sockaddrout_ipv6->addr));\n\t\tsockaddrout_ipv6->scope_id = htonl(sockaddrin_ipv6->sin6_scope_id);\n\t\tbreak;\n\t\t}\n#endif\n\t}\n}",
          "fn_code_pos": [
            [
              2667,
              0
            ],
            [
              2709,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_seraddr",
            "parameters": {
              "sockaddrin": "struct sockaddr_storage",
              "sockaddrout": "struct rpcap_sockaddr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void sleep_secs(int secs)\n{\n#ifdef _WIN32\n\tSleep(secs*1000);\n#else\n\tunsigned secs_remaining;\n\n\tif (secs <= 0)\n\t\treturn;\n\tsecs_remaining = secs;\n\twhile (secs_remaining != 0)\n\t\tsecs_remaining = sleep(secs_remaining);\n#endif\n}",
          "fn_code_pos": [
            [
              2715,
              0
            ],
            [
              2728,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sleep_secs",
            "parameters": {
              "secs": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nrpcapd_recv_msg_header(SOCKET sock, SSL *ssl, struct rpcap_header *headerp)\n{\n\tint nread;\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\n\tnread = sock_recv(sock, ssl, (char *) headerp, sizeof(struct rpcap_header),\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_ISNT_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\t// Network error.\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\tif (nread == 0)\n\t{\n\t\t// Immediate EOF; that's treated like a close message.\n\t\treturn -2;\n\t}\n\theaderp->plen = ntohl(headerp->plen);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              2733,
              0
            ],
            [
              2754,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcapd_recv_msg_header",
            "parameters": {
              "sock": "SOCKET",
              "ssl": "SSL",
              "headerp": "struct rpcap_header"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nrpcapd_recv(SOCKET sock, SSL *ssl, char *buffer, size_t toread, uint32 *plen, char *errmsgbuf)\n{\n\tint nread;\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\n\tif (toread > *plen)\n\t{\n\t\t// Tell the client and continue.\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Message payload is too short\");\n\t\treturn -2;\n\t}\n\tnread = sock_recv(sock, ssl, buffer, toread,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\t*plen -= nread;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              2765,
              0
            ],
            [
              2786,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcapd_recv",
            "parameters": {
              "sock": "SOCKET",
              "ssl": "SSL",
              "buffer": "char",
              "toread": "size_t",
              "plen": "uint32",
              "errmsgbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nrpcapd_discard(SOCKET sock, SSL *ssl, uint32 len)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\t// keeps the error string, prior to be printed\n\n\tif (len != 0)\n\t{\n\t\tif (sock_discard(sock, ssl, len, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\t// Network error.\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              2794,
              0
            ],
            [
              2809,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcapd_discard",
            "parameters": {
              "sock": "SOCKET",
              "ssl": "SSL",
              "len": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void session_close(struct session *session)\n{\n\tif (session->have_thread)\n\t{\n\t\t//\n\t\t// Tell the data connection thread main capture loop to\n\t\t// break out of that loop.\n\t\t//\n\t\t// This may be sufficient to wake up a blocked thread,\n\t\t// but it's not guaranteed to be sufficient.\n\t\t//\n\t\tpcap_breakloop(session->fp);\n\n#ifdef _WIN32\n\t\t//\n\t\t// Set the event on which a read would block, so that,\n\t\t// if it's currently blocked waiting for packets to\n\t\t// arrive, it'll wake up, so it can see the \"break\n\t\t// out of the loop\" indication.  (pcap_breakloop()\n\t\t// might do this, but older versions don't.  Setting\n\t\t// it twice should, at worst, cause an extra wakeup,\n\t\t// which shouldn't be a problem.)\n\t\t//\n\t\t// XXX - what about modules other than NPF?\n\t\t//\n\t\tSetEvent(pcap_getevent(session->fp));\n\n\t\t//\n\t\t// Wait for the thread to exit, so we don't close\n\t\t// sockets out from under it.\n\t\t//\n\t\t// XXX - have a timeout, so we don't wait forever?\n\t\t//\n\t\tWaitForSingleObject(session->thread, INFINITE);\n\n\t\t//\n\t\t// Release the thread handle, as we're done with\n\t\t// it.\n\t\t//\n\t\tCloseHandle(session->thread);\n\t\tsession->have_thread = 0;\n\t\tsession->thread = INVALID_HANDLE_VALUE;\n#else\n\t\t//\n\t\t// Send a SIGUSR1 signal to the thread, so that, if\n\t\t// it's currently blocked waiting for packets to arrive,\n\t\t// it'll wake up (we've turned off SA_RESTART for\n\t\t// SIGUSR1, so that the system call in which it's blocked\n\t\t// should return EINTR rather than restarting).\n\t\t//\n\t\tpthread_kill(session->thread, SIGUSR1);\n\n\t\t//\n\t\t// Wait for the thread to exit, so we don't close\n\t\t// sockets out from under it.\n\t\t//\n\t\t// XXX - have a timeout, so we don't wait forever?\n\t\t//\n\t\tpthread_join(session->thread, NULL);\n\t\tsession->have_thread = 0;\n\t\tmemset(&session->thread, 0, sizeof(session->thread));\n#endif\n\t}\n\n#ifdef HAVE_OPENSSL\n\tif (session->data_ssl)\n\t{\n\t\t// Finish using the SSL handle for the socket.\n\t\t// This must be done *before* the socket is closed.\n\t\tssl_finish(session->data_ssl);\n\t\tsession->data_ssl = NULL;\n\t}\n#endif\n\n\tif (session->sockdata != INVALID_SOCKET)\n\t{\n\t\tsock_close(session->sockdata, NULL, 0);\n\t\tsession->sockdata = INVALID_SOCKET;\n\t}\n\n\tif (session->fp)\n\t{\n\t\tpcap_close(session->fp);\n\t\tsession->fp = NULL;\n\t}\n}",
          "fn_code_pos": [
            [
              2820,
              0
            ],
            [
              2905,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "session_close",
            "parameters": {
              "session": "struct session"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "daemon_msg_err(SOCKET sockctrl, SSL *, uint32 plen)",
          "fn_dec_pos": [
            [
              127,
              11
            ],
            [
              127,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_err",
            "parameters": {
              "sockctrl": "SOCKET",
              "plen": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "daemon_msg_auth_req(struct daemon_slpars *pars, uint32 plen)",
          "fn_dec_pos": [
            [
              128,
              11
            ],
            [
              128,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_auth_req",
            "parameters": {
              "pars": "struct daemon_slpars",
              "plen": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "daemon_AuthUserPwd(char *username, char *password, char *errbuf)",
          "fn_dec_pos": [
            [
              129,
              11
            ],
            [
              129,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_AuthUserPwd",
            "parameters": {
              "username": "char",
              "password": "char",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "daemon_msg_findallif_req(uint8 ver, struct daemon_slpars *pars,\n    uint32 plen)",
          "fn_dec_pos": [
            [
              131,
              11
            ],
            [
              132,
              16
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_findallif_req",
            "parameters": {
              "ver": "uint8",
              "pars": "struct daemon_slpars",
              "plen": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "daemon_msg_open_req(uint8 ver, struct daemon_slpars *pars,\n    uint32 plen, char *source, size_t sourcelen)",
          "fn_dec_pos": [
            [
              134,
              11
            ],
            [
              135,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_open_req",
            "parameters": {
              "ver": "uint8",
              "pars": "struct daemon_slpars",
              "plen": "uint32",
              "source": "char",
              "sourcelen": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "daemon_msg_startcap_req(uint8 ver, struct daemon_slpars *pars,\n    uint32 plen, char *source, struct session **sessionp,\n    struct rpcap_sampling *samp_param, int uses_ssl)",
          "fn_dec_pos": [
            [
              136,
              11
            ],
            [
              138,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_startcap_req",
            "parameters": {
              "ver": "uint8",
              "pars": "struct daemon_slpars",
              "plen": "uint32",
              "source": "char",
              "sessionp": "struct session",
              "samp_param": "struct rpcap_sampling",
              "uses_ssl": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "daemon_msg_endcap_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session)",
          "fn_dec_pos": [
            [
              139,
              11
            ],
            [
              140,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_endcap_req",
            "parameters": {
              "ver": "uint8",
              "pars": "struct daemon_slpars",
              "session": "struct session"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "daemon_msg_updatefilter_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session, uint32 plen)",
          "fn_dec_pos": [
            [
              142,
              11
            ],
            [
              143,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_updatefilter_req",
            "parameters": {
              "ver": "uint8",
              "pars": "struct daemon_slpars",
              "session": "struct session",
              "plen": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "daemon_unpackapplyfilter(SOCKET sockctrl, SSL *, struct session *session, uint32 *plenp, char *errbuf)",
          "fn_dec_pos": [
            [
              144,
              11
            ],
            [
              144,
              113
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_unpackapplyfilter",
            "parameters": {
              "sockctrl": "SOCKET",
              "session": "struct session",
              "plenp": "uint32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "daemon_msg_stats_req(uint8 ver, struct daemon_slpars *pars,\n    struct session *session, uint32 plen, struct pcap_stat *stats,\n    unsigned int svrcapt)",
          "fn_dec_pos": [
            [
              146,
              11
            ],
            [
              148,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_stats_req",
            "parameters": {
              "ver": "uint8",
              "pars": "struct daemon_slpars",
              "session": "struct session",
              "plen": "uint32",
              "stats": "struct pcap_stat",
              "svrcapt": "unsigned int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "daemon_msg_setsampling_req(uint8 ver, struct daemon_slpars *pars,\n    uint32 plen, struct rpcap_sampling *samp_param)",
          "fn_dec_pos": [
            [
              150,
              11
            ],
            [
              151,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_msg_setsampling_req",
            "parameters": {
              "ver": "uint8",
              "pars": "struct daemon_slpars",
              "plen": "uint32",
              "samp_param": "struct rpcap_sampling"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "daemon_seraddr(struct sockaddr_storage *sockaddrin, struct rpcap_sockaddr *sockaddrout)",
          "fn_dec_pos": [
            [
              153,
              12
            ],
            [
              153,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_seraddr",
            "parameters": {
              "sockaddrin": "struct sockaddr_storage",
              "sockaddrout": "struct rpcap_sockaddr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "daemon_thrdatamain(void *ptr)",
          "fn_dec_pos": [
            [
              155,
              26
            ],
            [
              155,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_thrdatamain",
            "parameters": {
              "ptr": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "daemon_thrdatamain(void *ptr)",
          "fn_dec_pos": [
            [
              157,
              13
            ],
            [
              157,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_thrdatamain",
            "parameters": {
              "ptr": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "noop_handler(int sign)",
          "fn_dec_pos": [
            [
              158,
              12
            ],
            [
              158,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "noop_handler",
            "parameters": {
              "sign": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "rpcapd_recv_msg_header(SOCKET sock, SSL *, struct rpcap_header *headerp)",
          "fn_dec_pos": [
            [
              161,
              11
            ],
            [
              161,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcapd_recv_msg_header",
            "parameters": {
              "sock": "SOCKET",
              "headerp": "struct rpcap_header"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "rpcapd_recv(SOCKET sock, SSL *, char *buffer, size_t toread, uint32 *plen, char *errmsgbuf)",
          "fn_dec_pos": [
            [
              162,
              11
            ],
            [
              162,
              102
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcapd_recv",
            "parameters": {
              "sock": "SOCKET",
              "buffer": "char",
              "toread": "size_t",
              "plen": "uint32",
              "errmsgbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "rpcapd_discard(SOCKET sock, SSL *, uint32 len)",
          "fn_dec_pos": [
            [
              163,
              11
            ],
            [
              163,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcapd_discard",
            "parameters": {
              "sock": "SOCKET",
              "len": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "session_close(struct session *)",
          "fn_dec_pos": [
            [
              164,
              12
            ],
            [
              164,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "session_close",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "daemon_thrdatamain(void *ptr)",
          "fn_dec_pos": [
            [
              2436,
              0
            ],
            [
              2436,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_thrdatamain",
            "parameters": {
              "ptr": "void"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct daemon_slpars\n{\n\tSOCKET sockctrl;\t//!< SOCKET ID of the control connection\n\tSSL *ssl;\t\t//!< Optional SSL handler for the controlling sockets\n\tint isactive;\t\t//!< Not null if the daemon has to run in active mode\n\tint nullAuthAllowed;\t//!< '1' if we permit NULL authentication, '0' otherwise\n}",
          {
            "sockctrl": "SOCKET",
            "*ssl": "SSL",
            "isactive": "int",
            "nullAuthAllowed": "int"
          },
          "daemon_slpars",
          [
            95,
            0
          ],
          [
            101,
            1
          ]
        ],
        [
          "struct session {\n\tSOCKET sockctrl;\n\tSOCKET sockdata;\n\tSSL *ctrl_ssl, *data_ssl; // optional SSL handlers for sockctrl and sockdata.\n\tuint8 protocol_version;\n\tpcap_t *fp;\n\tunsigned int TotCapt;\n\tint\thave_thread;\n#ifdef _WIN32\n\tHANDLE thread;\n#else\n\tpthread_t thread;\n#endif\n}",
          {
            "sockctrl": "SOCKET",
            "sockdata": "SOCKET",
            "*ctrl_ssl": "SSL",
            "protocol_version": "uint8",
            "*fp": "pcap_t",
            "TotCapt": "unsigned int",
            "have_thread": "int",
            "thread": "pthread_t"
          },
          "session",
          [
            111,
            0
          ],
          [
            124,
            1
          ]
        ],
        [
          "struct tls_record_header {\n\tuint8 type;\t\t// ContentType - will be 22, for Handshake\n\tuint8 version_major;\t// TLS protocol major version\n\tuint8 version_injor;\t// TLS protocol minor version\n\t// This is *not* aligned on a 2-byte boundary; we just\n\t// declare it as two bytes.  Don't assume any particular\n\t// compiler's mechanism for saying \"packed\"!\n\tuint8 length_hi;\t// Upper 8 bits of payload length\n\tuint8 length_lo;\t// Low 8 bits of payload length\n}",
          {
            "type": "uint8",
            "version_major": "uint8",
            "version_injor": "uint8",
            "length_hi": "uint8",
            "length_lo": "uint8"
          },
          "tls_record_header",
          [
            170,
            0
          ],
          [
            179,
            1
          ]
        ],
        [
          "struct tls_alert {\n\tuint8 alert_level;\n\tuint8 alert_description;\n}",
          {
            "alert_level": "uint8",
            "alert_description": "uint8"
          },
          "tls_alert",
          [
            189,
            0
          ],
          [
            192,
            1
          ]
        ],
        [
          "struct daemon_slpars\n{\n\tSOCKET sockctrl;\t//!< SOCKET ID of the control connection\n\tSSL *ssl;\t\t//!< Optional SSL handler for the controlling sockets\n\tint isactive;\t\t//!< Not null if the daemon has to run in active mode\n\tint nullAuthAllowed;\t//!< '1' if we permit NULL authentication, '0' otherwise\n}",
          {
            "sockctrl": "SOCKET",
            "*ssl": "SSL",
            "isactive": "int",
            "nullAuthAllowed": "int"
          },
          "daemon_slpars",
          [
            95,
            0
          ],
          [
            101,
            1
          ]
        ],
        [
          "struct session {\n\tSOCKET sockctrl;\n\tSOCKET sockdata;\n\tSSL *ctrl_ssl, *data_ssl; // optional SSL handlers for sockctrl and sockdata.\n\tuint8 protocol_version;\n\tpcap_t *fp;\n\tunsigned int TotCapt;\n\tint\thave_thread;\n#ifdef _WIN32\n\tHANDLE thread;\n#else\n\tpthread_t thread;\n#endif\n}",
          {
            "sockctrl": "SOCKET",
            "sockdata": "SOCKET",
            "*ctrl_ssl": "SSL",
            "protocol_version": "uint8",
            "*fp": "pcap_t",
            "TotCapt": "unsigned int",
            "have_thread": "int",
            "thread": "pthread_t"
          },
          "session",
          [
            111,
            0
          ],
          [
            124,
            1
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            128,
            31
          ],
          [
            128,
            51
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            131,
            47
          ],
          [
            131,
            67
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            134,
            42
          ],
          [
            134,
            62
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            136,
            46
          ],
          [
            136,
            66
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            137,
            31
          ],
          [
            137,
            45
          ]
        ],
        [
          "struct rpcap_sampling",
          {},
          "",
          [
            138,
            4
          ],
          [
            138,
            25
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            139,
            44
          ],
          [
            139,
            64
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            140,
            4
          ],
          [
            140,
            18
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            142,
            50
          ],
          [
            142,
            70
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            143,
            4
          ],
          [
            143,
            18
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            144,
            60
          ],
          [
            144,
            74
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            146,
            43
          ],
          [
            146,
            63
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            147,
            4
          ],
          [
            147,
            18
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            147,
            42
          ],
          [
            147,
            58
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            150,
            49
          ],
          [
            150,
            69
          ]
        ],
        [
          "struct rpcap_sampling",
          {},
          "",
          [
            151,
            17
          ],
          [
            151,
            38
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            153,
            27
          ],
          [
            153,
            50
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            153,
            64
          ],
          [
            153,
            85
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            161,
            54
          ],
          [
            161,
            73
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            164,
            26
          ],
          [
            164,
            40
          ]
        ],
        [
          "struct tls_record_header {\n\tuint8 type;\t\t// ContentType - will be 22, for Handshake\n\tuint8 version_major;\t// TLS protocol major version\n\tuint8 version_injor;\t// TLS protocol minor version\n\t// This is *not* aligned on a 2-byte boundary; we just\n\t// declare it as two bytes.  Don't assume any particular\n\t// compiler's mechanism for saying \"packed\"!\n\tuint8 length_hi;\t// Upper 8 bits of payload length\n\tuint8 length_lo;\t// Low 8 bits of payload length\n}",
          {
            "type": "uint8",
            "version_major": "uint8",
            "version_injor": "uint8",
            "length_hi": "uint8",
            "length_lo": "uint8"
          },
          "tls_record_header",
          [
            170,
            0
          ],
          [
            179,
            1
          ]
        ],
        [
          "struct tls_alert {\n\tuint8 alert_level;\n\tuint8 alert_description;\n}",
          {
            "alert_level": "uint8",
            "alert_description": "uint8"
          },
          "tls_alert",
          [
            189,
            0
          ],
          [
            192,
            1
          ]
        ],
        [
          "struct tls_record_header",
          {},
          "",
          [
            204,
            1
          ],
          [
            204,
            25
          ]
        ],
        [
          "struct tls_alert",
          {},
          "",
          [
            205,
            1
          ],
          [
            205,
            17
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            206,
            1
          ],
          [
            206,
            21
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            212,
            1
          ],
          [
            212,
            20
          ]
        ],
        [
          "struct sigaction",
          {},
          "",
          [
            218,
            1
          ],
          [
            218,
            17
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            220,
            1
          ],
          [
            220,
            15
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            225,
            1
          ],
          [
            225,
            17
          ]
        ],
        [
          "struct rpcap_sampling",
          {},
          "",
          [
            228,
            1
          ],
          [
            228,
            22
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            232,
            1
          ],
          [
            232,
            15
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            428,
            2
          ],
          [
            428,
            25
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            434,
            19
          ],
          [
            434,
            42
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            435,
            34
          ],
          [
            435,
            49
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            1197,
            20
          ],
          [
            1197,
            40
          ]
        ],
        [
          "struct rpcap_auth",
          {},
          "",
          [
            1202,
            1
          ],
          [
            1202,
            18
          ]
        ],
        [
          "struct rpcap_authreply",
          {},
          "",
          [
            1205,
            1
          ],
          [
            1205,
            23
          ]
        ],
        [
          "struct rpcap_auth",
          {},
          "",
          [
            1207,
            72
          ],
          [
            1207,
            89
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1337,
            33
          ],
          [
            1337,
            52
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1341,
            18
          ],
          [
            1341,
            37
          ]
        ],
        [
          "struct rpcap_authreply",
          {},
          "",
          [
            1342,
            37
          ],
          [
            1342,
            59
          ]
        ],
        [
          "struct rpcap_authreply",
          {},
          "",
          [
            1344,
            14
          ],
          [
            1344,
            36
          ]
        ],
        [
          "struct rpcap_authreply",
          {},
          "",
          [
            1346,
            33
          ],
          [
            1346,
            55
          ]
        ],
        [
          "struct rpcap_authreply",
          {},
          "",
          [
            1353,
            29
          ],
          [
            1353,
            51
          ]
        ],
        [
          "struct passwd",
          {},
          "",
          [
            1453,
            1
          ],
          [
            1453,
            14
          ]
        ],
        [
          "struct spwd",
          {},
          "",
          [
            1456,
            1
          ],
          [
            1456,
            12
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            1515,
            36
          ],
          [
            1515,
            56
          ]
        ],
        [
          "struct pcap_addr",
          {},
          "",
          [
            1523,
            1
          ],
          [
            1523,
            17
          ]
        ],
        [
          "struct rpcap_findalldevs_if",
          {},
          "",
          [
            1524,
            1
          ],
          [
            1524,
            28
          ]
        ],
        [
          "struct rpcap_findalldevs_if",
          {},
          "",
          [
            1562,
            16
          ],
          [
            1562,
            43
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            1575,
            19
          ],
          [
            1575,
            40
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1585,
            33
          ],
          [
            1585,
            52
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1590,
            18
          ],
          [
            1590,
            37
          ]
        ],
        [
          "struct rpcap_findalldevs_if",
          {},
          "",
          [
            1598,
            20
          ],
          [
            1598,
            47
          ]
        ],
        [
          "struct rpcap_findalldevs_if",
          {},
          "",
          [
            1600,
            34
          ],
          [
            1600,
            61
          ]
        ],
        [
          "struct rpcap_findalldevs_if",
          {},
          "",
          [
            1604,
            35
          ],
          [
            1604,
            62
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            1648,
            3
          ],
          [
            1648,
            24
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            1659,
            16
          ],
          [
            1659,
            37
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            1660,
            36
          ],
          [
            1660,
            57
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1663,
            20
          ],
          [
            1663,
            43
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            1665,
            16
          ],
          [
            1665,
            37
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            1666,
            36
          ],
          [
            1666,
            57
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1669,
            20
          ],
          [
            1669,
            43
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            1671,
            16
          ],
          [
            1671,
            37
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            1672,
            36
          ],
          [
            1672,
            57
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1675,
            20
          ],
          [
            1675,
            43
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            1677,
            16
          ],
          [
            1677,
            37
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            1678,
            36
          ],
          [
            1678,
            57
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1681,
            20
          ],
          [
            1681,
            43
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            1720,
            31
          ],
          [
            1720,
            51
          ]
        ],
        [
          "struct rpcap_openreply",
          {},
          "",
          [
            1729,
            1
          ],
          [
            1729,
            23
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1760,
            33
          ],
          [
            1760,
            52
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            1764,
            18
          ],
          [
            1764,
            37
          ]
        ],
        [
          "struct rpcap_openreply",
          {},
          "",
          [
            1765,
            37
          ],
          [
            1765,
            59
          ]
        ],
        [
          "struct rpcap_openreply",
          {},
          "",
          [
            1767,
            14
          ],
          [
            1767,
            36
          ]
        ],
        [
          "struct rpcap_openreply",
          {},
          "",
          [
            1769,
            33
          ],
          [
            1769,
            55
          ]
        ],
        [
          "struct rpcap_openreply",
          {},
          "",
          [
            1773,
            29
          ],
          [
            1773,
            51
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            1817,
            35
          ],
          [
            1817,
            55
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            1818,
            18
          ],
          [
            1818,
            32
          ]
        ],
        [
          "struct rpcap_sampling",
          {},
          "",
          [
            1819,
            4
          ],
          [
            1819,
            25
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            1825,
            1
          ],
          [
            1825,
            15
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            1831,
            1
          ],
          [
            1831,
            16
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            1832,
            1
          ],
          [
            1832,
            16
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1833,
            1
          ],
          [
            1833,
            24
          ]
        ],
        [
          "struct rpcap_startcapreq",
          {},
          "",
          [
            1838,
            1
          ],
          [
            1838,
            25
          ]
        ],
        [
          "struct rpcap_startcapreply",
          {},
          "",
          [
            1839,
            1
          ],
          [
            1839,
            27
          ]
        ],
        [
          "struct rpcap_startcapreq",
          {},
          "",
          [
            1845,
            12
          ],
          [
            1845,
            36
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            1867,
            25
          ],
          [
            1867,
            39
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1923,
            19
          ],
          [
            1923,
            42
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1924,
            34
          ],
          [
            1924,
            49
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            1930,
            26
          ],
          [
            1930,
            41
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1940,
            19
          ],
          [
            1940,
            34
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1965,
            20
          ],
          [
            1965,
            43
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1966,
            38
          ],
          [
            1966,
            53
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1973,
            19
          ],
          [
            1973,
            34
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2004,
            33
          ],
          [
            2004,
            52
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2008,
            18
          ],
          [
            2008,
            37
          ]
        ],
        [
          "struct rpcap_startcapreply",
          {},
          "",
          [
            2009,
            41
          ],
          [
            2009,
            67
          ]
        ],
        [
          "struct rpcap_startcapreply",
          {},
          "",
          [
            2011,
            18
          ],
          [
            2011,
            44
          ]
        ],
        [
          "struct rpcap_startcapreply",
          {},
          "",
          [
            2013,
            33
          ],
          [
            2013,
            59
          ]
        ],
        [
          "struct rpcap_startcapreply",
          {},
          "",
          [
            2017,
            33
          ],
          [
            2017,
            59
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            2038,
            20
          ],
          [
            2038,
            43
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            2040,
            40
          ],
          [
            2040,
            55
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            2150,
            33
          ],
          [
            2150,
            53
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            2151,
            4
          ],
          [
            2151,
            18
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2154,
            1
          ],
          [
            2154,
            20
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2160,
            67
          ],
          [
            2160,
            86
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            2171,
            57
          ],
          [
            2171,
            71
          ]
        ],
        [
          "struct rpcap_filter",
          {},
          "",
          [
            2174,
            1
          ],
          [
            2174,
            20
          ]
        ],
        [
          "struct rpcap_filterbpf_insn",
          {},
          "",
          [
            2175,
            1
          ],
          [
            2175,
            28
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            2176,
            1
          ],
          [
            2176,
            16
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            2177,
            1
          ],
          [
            2177,
            19
          ]
        ],
        [
          "struct rpcap_filter",
          {},
          "",
          [
            2181,
            12
          ],
          [
            2181,
            31
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            2199,
            12
          ],
          [
            2199,
            27
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            2199,
            46
          ],
          [
            2199,
            61
          ]
        ],
        [
          "struct rpcap_filterbpf_insn",
          {},
          "",
          [
            2212,
            13
          ],
          [
            2212,
            40
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            2249,
            39
          ],
          [
            2249,
            59
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            2250,
            4
          ],
          [
            2250,
            18
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2255,
            1
          ],
          [
            2255,
            20
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2279,
            68
          ],
          [
            2279,
            87
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            2303,
            38
          ],
          [
            2303,
            58
          ]
        ],
        [
          "struct rpcap_sampling",
          {},
          "",
          [
            2304,
            4
          ],
          [
            2304,
            25
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2308,
            1
          ],
          [
            2308,
            20
          ]
        ],
        [
          "struct rpcap_sampling",
          {},
          "",
          [
            2309,
            1
          ],
          [
            2309,
            22
          ]
        ],
        [
          "struct rpcap_sampling",
          {},
          "",
          [
            2312,
            78
          ],
          [
            2312,
            99
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2329,
            68
          ],
          [
            2329,
            87
          ]
        ],
        [
          "struct daemon_slpars",
          {},
          "",
          [
            2362,
            32
          ],
          [
            2362,
            52
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            2363,
            4
          ],
          [
            2363,
            18
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            2363,
            42
          ],
          [
            2363,
            58
          ]
        ],
        [
          "struct rpcap_stats",
          {},
          "",
          [
            2370,
            1
          ],
          [
            2370,
            19
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2379,
            33
          ],
          [
            2379,
            52
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2383,
            18
          ],
          [
            2383,
            37
          ]
        ],
        [
          "struct rpcap_stats",
          {},
          "",
          [
            2384,
            47
          ],
          [
            2384,
            65
          ]
        ],
        [
          "struct rpcap_stats",
          {},
          "",
          [
            2386,
            13
          ],
          [
            2386,
            31
          ]
        ],
        [
          "struct rpcap_stats",
          {},
          "",
          [
            2388,
            33
          ],
          [
            2388,
            51
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            2439,
            1
          ],
          [
            2439,
            15
          ]
        ],
        [
          "struct rpcap_pkthdr",
          {},
          "",
          [
            2441,
            1
          ],
          [
            2441,
            20
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            2442,
            1
          ],
          [
            2442,
            19
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            2452,
            12
          ],
          [
            2452,
            26
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2491,
            22
          ],
          [
            2491,
            41
          ]
        ],
        [
          "struct rpcap_pkthdr",
          {},
          "",
          [
            2491,
            52
          ],
          [
            2491,
            71
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2545,
            34
          ],
          [
            2545,
            53
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2555,
            19
          ],
          [
            2555,
            38
          ]
        ],
        [
          "struct rpcap_pkthdr",
          {},
          "",
          [
            2557,
            23
          ],
          [
            2557,
            42
          ]
        ],
        [
          "struct rpcap_pkthdr",
          {},
          "",
          [
            2559,
            20
          ],
          [
            2559,
            39
          ]
        ],
        [
          "struct rpcap_pkthdr",
          {},
          "",
          [
            2562,
            34
          ],
          [
            2562,
            53
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            2668,
            15
          ],
          [
            2668,
            38
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            2668,
            52
          ],
          [
            2668,
            73
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            2670,
            31
          ],
          [
            2670,
            54
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            2680,
            2
          ],
          [
            2680,
            20
          ]
        ],
        [
          "struct rpcap_sockaddr_in",
          {},
          "",
          [
            2681,
            2
          ],
          [
            2681,
            26
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            2683,
            21
          ],
          [
            2683,
            39
          ]
        ],
        [
          "struct rpcap_sockaddr_in",
          {},
          "",
          [
            2684,
            22
          ],
          [
            2684,
            46
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            2695,
            2
          ],
          [
            2695,
            21
          ]
        ],
        [
          "struct rpcap_sockaddr_in6",
          {},
          "",
          [
            2696,
            2
          ],
          [
            2696,
            27
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            2698,
            21
          ],
          [
            2698,
            40
          ]
        ],
        [
          "struct rpcap_sockaddr_in6",
          {},
          "",
          [
            2699,
            22
          ],
          [
            2699,
            47
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2734,
            46
          ],
          [
            2734,
            65
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            2739,
            55
          ],
          [
            2739,
            74
          ]
        ],
        [
          "struct session",
          {},
          "",
          [
            2820,
            26
          ],
          [
            2820,
            40
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include \"ftmacros.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"varattrs.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <errno.h>\t\t// for the errno variable\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <stdlib.h>\t\t// for malloc(), free(), ...\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <string.h>\t\t// for strlen(), ...\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <limits.h>\t\t// for INT_MAX\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <process.h>\t\t// for threads\n",
          [
            44,
            2
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            46,
            2
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <pthread.h>\n",
          [
            47,
            2
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <signal.h>\n",
          [
            48,
            2
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            49,
            2
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <sys/types.h>\t// for select() and such\n",
          [
            50,
            2
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include <pwd.h>\t\t// for password management\n",
          [
            51,
            2
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include <shadow.h>\t\t// for password management\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include <pcap.h>\t\t// for libpcap/WinPcap calls\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include \"fmtutils.h\"\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include \"sockutils.h\"\t\t// for socket calls\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            62,
            0
          ],
          [
            63,
            0
          ]
        ],
        [
          "#include \"rpcap-protocol.h\"\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include \"daemon.h\"\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ],
        [
          "#include \"log.h\"\n",
          [
            65,
            0
          ],
          [
            66,
            0
          ]
        ],
        [
          "#include <openssl/ssl.h>\n",
          [
            68,
            0
          ],
          [
            69,
            0
          ]
        ],
        [
          "#include \"sslutils.h\"\n",
          [
            69,
            0
          ],
          [
            70,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/rpcapd/fileconf.c": {
      "fn_def_list": [
        {
          "fn_code": "void fileconf_read(void)\n{\n\tFILE *fp;\n\tunsigned int num_active_clients;\n\n\tif ((fp = fopen(loadfile, \"r\")) != NULL)\n\t{\n\t\tchar line[MAX_LINE + 1];\n\t\tunsigned int lineno;\n\n\t\thostlist[0] = 0;\n\t\tnum_active_clients = 0;\n\t\tlineno = 0;\n\n\t\twhile (fgets(line, MAX_LINE, fp) != NULL)\n\t\t{\n\t\t\tsize_t linelen;\n\t\t\tchar *ptr;\n\t\t\tchar *param;\n\t\t\tsize_t result;\n\t\t\tsize_t toklen;\n\n\t\t\tlineno++;\n\n\t\t\tlinelen = strlen(line);\n\t\t\tif (line[linelen - 1] != '\\n')\n\t\t\t{\n\t\t\t\tint c;\n\n\t\t\t\t//\n\t\t\t\t// Either the line doesn't fit in\n\t\t\t\t// the buffer, or we got an EOF\n\t\t\t\t// before the EOL.  Assume it's the\n\t\t\t\t// former.\n\t\t\t\t//\n\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t    \"%s, line %u is longer than %u characters\",\n\t\t\t\t    loadfile, lineno, MAX_LINE);\n\n\t\t\t\t//\n\t\t\t\t// Eat characters until we get an NL.\n\t\t\t\t//\n\t\t\t\twhile ((c = getc(fp)) != '\\n')\n\t\t\t\t{\n\t\t\t\t\tif (c == EOF)\n\t\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// Try the next line.\n\t\t\t\t//\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tptr = line;\n\n\t\t\t//\n\t\t\t// Skip leading white space, if any.\n\t\t\t//\n\t\t\tptr = skipws(ptr);\n\t\t\tif (ptr == NULL)\n\t\t\t{\n\t\t\t\t// Blank line.\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Is the next character a \"#\"?  If so, this\n\t\t\t// line is a comment; skip to the next line.\n\t\t\t//\n\t\t\tif (*ptr == '#')\n\t\t\t\tcontinue;\n\n\t\t\t//\n\t\t\t// Is the next character alphabetic?  If not,\n\t\t\t// this isn't a valid parameter name.\n\t\t\t//\n\t\t\tif (!isascii((unsigned char)*ptr) ||\n\t\t\t    !isalpha((unsigned char)*ptr))\n\t\t\t{\n\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t    \"%s, line %u doesn't have a valid parameter name\",\n\t\t\t\t    loadfile, lineno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Grab the first token, which is made of\n\t\t\t// alphanumerics, underscores, and hyphens.\n\t\t\t// That's the name of the parameter being set.\n\t\t\t//\n\t\t\tparam = ptr;\n\t\t\twhile (isascii((unsigned char)*ptr) &&\n\t\t\t    (isalnum((unsigned char)*ptr) || *ptr == '-' || *ptr == '_'))\n\t\t\t\tptr++;\n\n\t\t\t//\n\t\t\t// Skip over white space, if any.\n\t\t\t//\n\t\t\tptr = skipws(ptr);\n\t\t\tif (ptr == NULL || *ptr != '=')\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// We hit the end of the line before\n\t\t\t\t// finding a non-white space character,\n\t\t\t\t// or we found one but it's not an \"=\".\n\t\t\t\t// That means there's no \"=\", so this\n\t\t\t\t// line is invalid.  Complain and skip\n\t\t\t\t// this line.\n\t\t\t\t//\n\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t    \"%s, line %u has a parameter but no =\",\n\t\t\t\t    loadfile, lineno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// We found the '='; set it to '\\0', and skip\n\t\t\t// past it.\n\t\t\t//\n\t\t\t*ptr++ = '\\0';\n\n\t\t\t//\n\t\t\t// Skip past any white space after the \"=\".\n\t\t\t//\n\t\t\tptr = skipws(ptr);\n\t\t\tif (ptr == NULL)\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// The value is empty.\n\t\t\t\t//\n\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t    \"%s, line %u has a parameter but no value\",\n\t\t\t\t    loadfile, lineno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// OK, what parameter is this?\n\t\t\t//\n\t\t\tif (strcmp(param, PARAM_ACTIVECLIENT) == 0) {\n\t\t\t\t//\n\t\t\t\t// Add this to the list of active clients.\n\t\t\t\t//\n\t\t\t\tchar *address, *port;\n\n\t\t\t\t//\n\t\t\t\t// We can't have more than MAX_ACTIVE_LIST\n\t\t\t\t// active clients.\n\t\t\t\t//\n\t\t\t\tif (num_active_clients >= MAX_ACTIVE_LIST)\n\t\t\t\t{\n\t\t\t\t\t//\n\t\t\t\t\t// Too many entries for the active\n\t\t\t\t\t// client list.  Complain and\n\t\t\t\t\t// ignore it.\n\t\t\t\t\t//\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t\t    \"%s, line %u has an %s parameter, but we already have %u active clients\",\n\t\t\t\t\t    loadfile, lineno, PARAM_ACTIVECLIENT,\n\t\t\t\t\t    MAX_ACTIVE_LIST);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// Get the address.\n\t\t\t\t// It's terminated by a host list separator\n\t\t\t\t// *or* a #; there *shouldn't* be a #, as\n\t\t\t\t// that starts a comment, and that would\n\t\t\t\t// mean that we have no port.\n\t\t\t\t//\n\t\t\t\taddress = ptr;\n\t\t\t\ttoklen = strcspn(ptr, RPCAP_HOSTLIST_SEP \"#\");\n\t\t\t\tptr += toklen;\t// skip to the terminator\n\t\t\t\tif (toklen == 0)\n\t\t\t\t{\n\t\t\t\t\tif (isascii((unsigned char)*ptr) &&\n\t\t\t\t\t    (isspace((unsigned char)*ptr) || *ptr == '#' || *ptr == '\\0'))\n\t\t\t\t\t{\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// The first character it saw\n\t\t\t\t\t\t// was a whitespace character\n\t\t\t\t\t\t// or a comment character.\n\t\t\t\t\t\t// This means that there's\n\t\t\t\t\t\t// no value.\n\t\t\t\t\t\t//\n\t\t\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t\t\t    \"%s, line %u has a parameter but no value\",\n\t\t\t\t\t\t    loadfile, lineno);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// This means that the first\n\t\t\t\t\t\t// character it saw was a\n\t\t\t\t\t\t// separator.  This means that\n\t\t\t\t\t\t// there's no address in the\n\t\t\t\t\t\t// value, just a port.\n\t\t\t\t\t\t//\n\t\t\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t\t\t    \"%s, line %u has an %s parameter with a value containing no address\",\n\t\t\t\t\t\t    loadfile, lineno, PARAM_ACTIVECLIENT);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// Null-terminate the address, and skip past\n\t\t\t\t// it.\n\t\t\t\t//\n\t\t\t\t*ptr++ = '\\0';\n\n\t\t\t\t//\n\t\t\t\t// Skip any white space following the\n\t\t\t\t// separating character.\n\t\t\t\t//\n\t\t\t\tptr = skipws(ptr);\n\t\t\t\tif (ptr == NULL)\n\t\t\t\t{\n\t\t\t\t\t//\n\t\t\t\t\t// The value is empty, so there's\n\t\t\t\t\t// no port in the value.\n\t\t\t\t\t//\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t\t    \"%s, line %u has an %s parameter with a value containing no port\",\n\t\t\t\t\t    loadfile, lineno, PARAM_ACTIVECLIENT);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// Get the port.\n\t\t\t\t// We look for a white space character\n\t\t\t\t// or a # as a terminator; the # introduces\n\t\t\t\t// a comment that runs to the end of the\n\t\t\t\t// line.\n\t\t\t\t//\n\t\t\t\tport = ptr;\n\t\t\t\ttoklen = strcspn(ptr, \" \\t#\\r\\n\");\n\t\t\t\tptr += toklen;\n\t\t\t\tif (toklen == 0)\n\t\t\t\t{\n\t\t\t\t\t//\n\t\t\t\t\t// The value is empty, so there's\n\t\t\t\t\t// no port in the value.\n\t\t\t\t\t//\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t\t    \"%s, line %u has an %s parameter with a value containing no port\",\n\t\t\t\t\t    loadfile, lineno, PARAM_ACTIVECLIENT);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// Null-terminate the port, and skip past\n\t\t\t\t// it.\n\t\t\t\t//\n\t\t\t\t*ptr++ = '\\0';\n\t\t\t\tresult = pcap_strlcpy(activelist[num_active_clients].address, address, sizeof(activelist[num_active_clients].address));\n\t\t\t\tif (result >= sizeof(activelist[num_active_clients].address))\n\t\t\t\t{\n\t\t\t\t\t//\n\t\t\t\t\t// It didn't fit.\n\t\t\t\t\t//\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t\t    \"%s, line %u has an %s parameter with an address with more than %u characters\",\n\t\t\t\t\t    loadfile, lineno, PARAM_ACTIVECLIENT,\n\t\t\t\t\t    (unsigned int)(sizeof(activelist[num_active_clients].address) - 1));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (strcmp(port, \"DEFAULT\") == 0) // the user choose a custom port\n\t\t\t\t\tresult = pcap_strlcpy(activelist[num_active_clients].port, RPCAP_DEFAULT_NETPORT_ACTIVE, sizeof(activelist[num_active_clients].port));\n\t\t\t\telse\n\t\t\t\t\tresult = pcap_strlcpy(activelist[num_active_clients].port, port, sizeof(activelist[num_active_clients].port));\n\t\t\t\tif (result >= sizeof(activelist[num_active_clients].address))\n\t\t\t\t{\n\t\t\t\t\t//\n\t\t\t\t\t// It didn't fit.\n\t\t\t\t\t//\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t\t    \"%s, line %u has an %s parameter with an port with more than %u characters\",\n\t\t\t\t\t    loadfile, lineno, PARAM_ACTIVECLIENT,\n\t\t\t\t\t    (unsigned int)(sizeof(activelist[num_active_clients].port) - 1));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnum_active_clients++;\n\t\t\t}\n\t\t\telse if (strcmp(param, PARAM_PASSIVECLIENT) == 0)\n\t\t\t{\n\t\t\t\tchar *eos;\n\t\t\t\tchar *host;\n\n\t\t\t\t//\n\t\t\t\t// Get the host.\n\t\t\t\t// We look for a white space character\n\t\t\t\t// or a # as a terminator; the # introduces\n\t\t\t\t// a comment that runs to the end of the\n\t\t\t\t// line.\n\t\t\t\t//\n\t\t\t\thost = ptr;\n\t\t\t\ttoklen = strcspn(ptr, \" \\t#\\r\\n\");\n\t\t\t\tif (toklen == 0)\n\t\t\t\t{\n\t\t\t\t\t//\n\t\t\t\t\t// The first character it saw\n\t\t\t\t\t// was a whitespace character\n\t\t\t\t\t// or a comment character.\n\t\t\t\t\t// This means that there's\n\t\t\t\t\t// no value.\n\t\t\t\t\t//\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t\t    \"%s, line %u has a parameter but no value\",\n\t\t\t\t\t    loadfile, lineno);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tptr += toklen;\n\t\t\t\t*ptr++ = '\\0';\n\n\t\t\t\t//\n\t\t\t\t// Append this to the host list.\n\t\t\t\t// Save the curren end-of-string for the\n\t\t\t\t// host list, in case the new host doesn't\n\t\t\t\t// fit, so that we can discard the partially-\n\t\t\t\t// copied host name.\n\t\t\t\t//\n\t\t\t\teos = hostlist + strlen(hostlist);\n\t\t\t\tif (eos != hostlist)\n\t\t\t\t{\n\t\t\t\t\t//\n\t\t\t\t\t// The list is not empty, so prepend\n\t\t\t\t\t// a comma before adding this host.\n\t\t\t\t\t//\n\t\t\t\t\tresult = pcap_strlcat(hostlist, \",\", sizeof(hostlist));\n\t\t\t\t\tif (result >= sizeof(hostlist))\n\t\t\t\t\t{\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// It didn't fit.  Discard\n\t\t\t\t\t\t// the comma (which wasn't\n\t\t\t\t\t\t// added, but...), complain,\n\t\t\t\t\t\t// and ignore this line.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t*eos = '\\0';\n\t\t\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t\t\t    \"%s, line %u has a %s parameter with a host name that doesn't fit\",\n\t\t\t\t\t\t    loadfile, lineno, PARAM_PASSIVECLIENT);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult = pcap_strlcat(hostlist, host, sizeof(hostlist));\n\t\t\t\tif (result >= sizeof(hostlist))\n\t\t\t\t{\n\t\t\t\t\t//\n\t\t\t\t\t// It didn't fit.  Discard the comma,\n\t\t\t\t\t// complain, and ignore this line.\n\t\t\t\t\t//\n\t\t\t\t\t*eos = '\\0';\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t\t    \"%s, line %u has a %s parameter with a host name that doesn't fit\",\n\t\t\t\t\t    loadfile, lineno, PARAM_PASSIVECLIENT);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (strcmp(param, PARAM_NULLAUTHPERMIT) == 0)\n\t\t\t{\n\t\t\t\tchar *setting;\n\n\t\t\t\t//\n\t\t\t\t// Get the setting.\n\t\t\t\t// We look for a white space character\n\t\t\t\t// or a # as a terminator; the # introduces\n\t\t\t\t// a comment that runs to the end of the\n\t\t\t\t// line.\n\t\t\t\t//\n\t\t\t\tsetting = ptr;\n\t\t\t\ttoklen = strcspn(ptr, \" \\t#\\r\\n\");\n\t\t\t\tptr += toklen;\n\t\t\t\tif (toklen == 0)\n\t\t\t\t{\n\t\t\t\t\t//\n\t\t\t\t\t// The first character it saw\n\t\t\t\t\t// was a whitespace character\n\t\t\t\t\t// or a comment character.\n\t\t\t\t\t// This means that there's\n\t\t\t\t\t// no value.\n\t\t\t\t\t//\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t\t    \"%s, line %u has a parameter but no value\",\n\t\t\t\t\t    loadfile, lineno);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t*ptr++ = '\\0';\n\n\t\t\t\t//\n\t\t\t\t// XXX - should we complain if it's\n\t\t\t\t// neither \"yes\" nor \"no\"?\n\t\t\t\t//\n\t\t\t\tif (strcmp(setting, \"YES\") == 0)\n\t\t\t\t\tnullAuthAllowed = 1;\n\t\t\t\telse\n\t\t\t\t\tnullAuthAllowed = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t\t\t    \"%s, line %u has an unknown parameter %s\",\n\t\t\t\t    loadfile, lineno, param);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ndone:\n\t\t// clear the remaining fields of the active list\n\t\tfor (int i = num_active_clients; i < MAX_ACTIVE_LIST; i++)\n\t\t{\n\t\t\tactivelist[i].address[0] = 0;\n\t\t\tactivelist[i].port[0] = 0;\n\t\t\tnum_active_clients++;\n\t\t}\n\n\t\trpcapd_log(LOGPRIO_DEBUG, \"New passive host list: %s\", hostlist);\n\t\tfclose(fp);\n\t}\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              481,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fileconf_read",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int fileconf_save(const char *savefile)\n{\n\tFILE *fp;\n\n\tif ((fp = fopen(savefile, \"w\")) != NULL)\n\t{\n\t\tchar *token; /*, *port;*/\t\t\t\t\t// temp, needed to separate items into the hostlist\n\t\tchar temphostlist[MAX_HOST_LIST + 1];\n\t\tint i = 0;\n\t\tchar *lasts;\n\n\t\tfprintf(fp, \"# Configuration file help.\\n\\n\");\n\n\t\t// Save list of clients which are allowed to connect to us in passive mode\n\t\tfprintf(fp, \"# Hosts which are allowed to connect to this server (passive mode)\\n\");\n\t\tfprintf(fp, \"# Format: PassiveClient = <name or address>\\n\\n\");\n\n\t\tstrncpy(temphostlist, hostlist, MAX_HOST_LIST);\n\t\ttemphostlist[MAX_HOST_LIST] = 0;\n\n\t\ttoken = pcap_strtok_r(temphostlist, RPCAP_HOSTLIST_SEP, &lasts);\n\t\twhile(token != NULL)\n\t\t{\n\t\t\tfprintf(fp, \"%s = %s\\n\", PARAM_PASSIVECLIENT, token);\n\t\t\ttoken = pcap_strtok_r(NULL, RPCAP_HOSTLIST_SEP, &lasts);\n\t\t}\n\n\n\t\t// Save list of clients which are allowed to connect to us in active mode\n\t\tfprintf(fp, \"\\n\\n\");\n\t\tfprintf(fp, \"# Hosts to which this server is trying to connect to (active mode)\\n\");\n\t\tfprintf(fp, \"# Format: ActiveClient = <name or address>, <port | DEFAULT>\\n\\n\");\n\n\n\t\twhile ((i < MAX_ACTIVE_LIST) && (activelist[i].address[0] != 0))\n\t\t{\n\t\t\tfprintf(fp, \"%s = %s, %s\\n\", PARAM_ACTIVECLIENT,\n\t\t\t    activelist[i].address, activelist[i].port);\n\t\t\ti++;\n\t\t}\n\n\t\t// Save if we want to permit NULL authentication\n\t\tfprintf(fp, \"\\n\\n\");\n\t\tfprintf(fp, \"# Permit NULL authentication: YES or NO\\n\\n\");\n\n\t\tfprintf(fp, \"%s = %s\\n\", PARAM_NULLAUTHPERMIT,\n\t\t    nullAuthAllowed ? \"YES\" : \"NO\");\n\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn -1;\n\t}\n\n}",
          "fn_code_pos": [
            [
              483,
              0
            ],
            [
              539,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fileconf_save",
            "parameters": {
              "savefile": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static char *skipws(char *ptr)\n{\n\twhile (isascii((unsigned char)*ptr) && isspace((unsigned char)*ptr)) {\n\t\tif (*ptr == '\\r' || *ptr == '\\n')\n\t\t\treturn NULL;\n\t\t*ptr++ = '\\0';\n\t}\n\treturn ptr;\n}",
          "fn_code_pos": [
            [
              548,
              0
            ],
            [
              556,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "skipws",
            "parameters": {
              "ptr": "char"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "skipws(char *ptr)",
          "fn_dec_pos": [
            [
              59,
              13
            ],
            [
              59,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "skipws",
            "parameters": {
              "ptr": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "skipws(char *ptr)",
          "fn_dec_pos": [
            [
              548,
              13
            ],
            [
              548,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "skipws",
            "parameters": {
              "ptr": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include \"ftmacros.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <signal.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <pcap.h>\t\t// for PCAP_ERRBUF_SIZE\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include \"rpcapd.h\"\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include \"config_params.h\"\t// configuration file parameters\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"fileconf.h\"\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include \"rpcap-protocol.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include \"log.h\"\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/rpcapd/rpcapd.c": {
      "fn_def_list": [
        {
          "fn_code": "static void printusage(void)\n{\n\tconst char *usagetext =\n\t\"USAGE:\"\n\t\" \"  PROGRAM_NAME \" [-b <address>] [-p <port>] [-4] [-l <host_list>] [-a <host,port>]\\n\"\n\t\"              [-n] [-v] [-d] \"\n#ifndef _WIN32\n\t\"[-i] \"\n#endif\n        \"[-D] [-s <config_file>] [-f <config_file>]\\n\\n\"\n\t\"  -b <address>    the address to bind to (either numeric or literal).\\n\"\n\t\"                  Default: binds to all local IPv4 and IPv6 addresses\\n\\n\"\n\t\"  -p <port>       the port to bind to.\\n\"\n\t\"                  Default: binds to port \" RPCAP_DEFAULT_NETPORT \"\\n\\n\"\n\t\"  -4              use only IPv4.\\n\"\n\t\"                  Default: use both IPv4 and IPv6 waiting sockets\\n\\n\"\n\t\"  -l <host_list>  a file that contains a list of hosts that are allowed\\n\"\n\t\"                  to connect to this server (if more than one, list them one\\n\"\n\t\"                  per line).\\n\"\n\t\"                  We suggest to use literal names (instead of numeric ones)\\n\"\n\t\"                  in order to avoid problems with different address families.\\n\\n\"\n\t\"  -n              permit NULL authentication (usually used with '-l')\\n\\n\"\n\t\"  -a <host,port>  run in active mode when connecting to 'host' on port 'port'\\n\"\n\t\"                  In case 'port' is omitted, the default port (\" RPCAP_DEFAULT_NETPORT_ACTIVE \") is used\\n\\n\"\n\t\"  -v              run in active mode only (default: if '-a' is specified, it\\n\"\n\t\"                  accepts passive connections as well)\\n\\n\"\n\t\"  -d              run in daemon mode (UNIX only) or as a service (Win32 only)\\n\"\n\t\"                  Warning (Win32): this switch is provided automatically when\\n\"\n\t\"                  the service is started from the control panel\\n\\n\"\n#ifndef _WIN32\n\t\"  -i              run in inetd mode (UNIX only)\\n\\n\"\n#endif\n\t\"  -D              log debugging messages\\n\\n\"\n#ifdef HAVE_OPENSSL\n\t\"  -S              encrypt all communication with SSL (implements rpcaps://)\\n\"\n\t\"  -C              enable compression\\n\"\n\t\"  -K <pem_file>   uses the SSL private key in this file (default: key.pem)\\n\"\n\t\"  -X <pem_file>   uses the certificate from this file (default: cert.pem)\\n\"\n#endif\n\t\"  -s <config_file> save the current configuration to file\\n\\n\"\n\t\"  -f <config_file> load the current configuration from file; all switches\\n\"\n\t\"                  specified from the command line are ignored\\n\\n\"\n\t\"  -h              print this help screen\\n\\n\";\n\n\t(void)fprintf(stderr, \"RPCAPD, a remote packet capture daemon.\\n\"\n\t\"Compiled with %s\\n\\n\", pcap_lib_version());\n\tprintf(\"%s\", usagetext);\n}",
          "fn_code_pos": [
            [
              119,
              0
            ],
            [
              166,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "printusage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[])\n{\n\tchar savefile[MAX_LINE + 1];\t\t// name of the file on which we have to save the configuration\n\tint log_to_systemlog = 0;\t\t// Non-zero if we should log to the \"system log\" rather than the standard error\n\tint isdaemon = 0;\t\t\t// Non-zero if the user wants to run this program as a daemon\n#ifndef _WIN32\n\tint isrunbyinetd = 0;\t\t\t// Non-zero if this is being run by inetd or something inetd-like\n#endif\n\tint log_debug_messages = 0;\t\t// Non-zero if the user wants debug messages logged\n\tint retval;\t\t\t\t// keeps the returning value from several functions\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\t// keeps the error string, prior to be printed\n#ifndef _WIN32\n\tstruct sigaction action;\n#endif\n#ifdef HAVE_OPENSSL\n\tint enable_compression = 0;\n#endif\n\n\tsavefile[0] = 0;\n\tloadfile[0] = 0;\n\thostlist[0] = 0;\n\n\t// Initialize errbuf\n\tmemset(errbuf, 0, sizeof(errbuf));\n\n\tstrncpy(address, RPCAP_DEFAULT_NETADDR, MAX_LINE);\n\tstrncpy(port, RPCAP_DEFAULT_NETPORT, MAX_LINE);\n\n\t// Prepare to open a new server socket\n\tmemset(&mainhints, 0, sizeof(struct addrinfo));\n\n\tmainhints.ai_family = PF_UNSPEC;\n\tmainhints.ai_flags = AI_PASSIVE;\t// Ready to a bind() socket\n\tmainhints.ai_socktype = SOCK_STREAM;\n\n\t// Getting the proper command line options\n#\tifdef HAVE_OPENSSL\n#\t\tdefine SSL_CLOPTS  \"SK:X:C\"\n#\telse\n#\t\tdefine SSL_CLOPTS \"\"\n#\tendif\n\n#\tdefine CLOPTS \"b:dDhip:4l:na:s:f:v\" SSL_CLOPTS\n\n\twhile ((retval = getopt(argc, argv, CLOPTS)) != -1)\n\t{\n\t\tswitch (retval)\n\t\t{\n\t\t\tcase 'D':\n\t\t\t\tlog_debug_messages = 1;\n\t\t\t\trpcapd_log_set(log_to_systemlog, log_debug_messages);\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tstrncpy(address, optarg, MAX_LINE);\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tstrncpy(port, optarg, MAX_LINE);\n\t\t\t\tbreak;\n\t\t\tcase '4':\n\t\t\t\tmainhints.ai_family = PF_INET;\t\t// IPv4 server only\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tisdaemon = 1;\n\t\t\t\tlog_to_systemlog = 1;\n\t\t\t\trpcapd_log_set(log_to_systemlog, log_debug_messages);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n#ifdef _WIN32\n\t\t\t\tprintusage();\n\t\t\t\texit(1);\n#else\n\t\t\t\tisrunbyinetd = 1;\n\t\t\t\tlog_to_systemlog = 1;\n\t\t\t\trpcapd_log_set(log_to_systemlog, log_debug_messages);\n#endif\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tnullAuthAllowed = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tpassivemode = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t{\n\t\t\t\tstrncpy(hostlist, optarg, sizeof(hostlist));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'a':\n\t\t\t{\n\t\t\t\tchar *tmpaddress, *tmpport;\n\t\t\t\tchar *lasts;\n\t\t\t\tint i = 0;\n\n\t\t\t\ttmpaddress = pcap_strtok_r(optarg, RPCAP_HOSTLIST_SEP, &lasts);\n\n\t\t\t\twhile ((tmpaddress != NULL) && (i < MAX_ACTIVE_LIST))\n\t\t\t\t{\n\t\t\t\t\ttmpport = pcap_strtok_r(NULL, RPCAP_HOSTLIST_SEP, &lasts);\n\n\t\t\t\t\tpcap_strlcpy(activelist[i].address, tmpaddress, MAX_LINE);\n\n\t\t\t\t\tif ((tmpport == NULL) || (strcmp(tmpport, \"DEFAULT\") == 0)) // the user choose a custom port\n\t\t\t\t\t\tpcap_strlcpy(activelist[i].port, RPCAP_DEFAULT_NETPORT_ACTIVE, MAX_LINE);\n\t\t\t\t\telse\n\t\t\t\t\t\tpcap_strlcpy(activelist[i].port, tmpport, MAX_LINE);\n\n\t\t\t\t\ttmpaddress = pcap_strtok_r(NULL, RPCAP_HOSTLIST_SEP, &lasts);\n\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\tif (i > MAX_ACTIVE_LIST)\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Only MAX_ACTIVE_LIST active connections are currently supported.\");\n\n\t\t\t\t// I don't initialize the remaining part of the structure, since\n\t\t\t\t// it is already zeroed (it is a global var)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'f':\n\t\t\t\tpcap_strlcpy(loadfile, optarg, MAX_LINE);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tpcap_strlcpy(savefile, optarg, MAX_LINE);\n\t\t\t\tbreak;\n#ifdef HAVE_OPENSSL\n\t\t\tcase 'S':\n\t\t\t\tuses_ssl = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tenable_compression = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'K':\n\t\t\t\tssl_set_keyfile(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\tssl_set_certfile(optarg);\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'h':\n\t\t\t\tprintusage();\n\t\t\t\texit(0);\n\t\t\t\t/*NOTREACHED*/\n\t\t\tdefault:\n\t\t\t\texit(1);\n\t\t\t\t/*NOTREACHED*/\n\t\t}\n\t}\n\n#ifndef _WIN32\n\tif (isdaemon && isrunbyinetd)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"rpcapd: -d and -i can't be used together\");\n\t\texit(1);\n\t}\n#endif\n\n\tif (sock_init(errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"%s\", errbuf);\n\t\texit(-1);\n\t}\n\n\tif (savefile[0] && fileconf_save(savefile))\n\t\trpcapd_log(LOGPRIO_DEBUG, \"Error when saving the configuration to file\");\n\n\t// If the file does not exist, it keeps the settings provided by the command line\n\tif (loadfile[0])\n\t\tfileconf_read();\n\n#ifdef WIN32\n\t//\n\t// Create a handle to signal the main loop to tell it to do\n\t// something.\n\t//\n\tstate_change_event = CreateEvent(NULL, FALSE, FALSE, NULL);\n\tif (state_change_event == NULL)\n\t{\n\t\tsock_geterror(NULL, errbuf, PCAP_ERRBUF_SIZE);\n\t\trpcapd_log(LOGPRIO_ERROR, \"Can't create state change event: %s\",\n\t\t    errbuf);\n\t\texit(2);\n\t}\n\n\t//\n\t// Catch control signals.\n\t//\n\tif (!SetConsoleCtrlHandler(main_ctrl_event, TRUE))\n\t{\n\t\tsock_geterror(NULL, errbuf, PCAP_ERRBUF_SIZE);\n\t\trpcapd_log(LOGPRIO_ERROR, \"Can't set control handler: %s\",\n\t\t    errbuf);\n\t\texit(2);\n\t}\n#else\n\tmemset(&action, 0, sizeof (action));\n\taction.sa_handler = main_terminate;\n\taction.sa_flags = 0;\n\tsigemptyset(&action.sa_mask);\n\tsigaction(SIGTERM, &action, NULL);\n\tmemset(&action, 0, sizeof (action));\n\taction.sa_handler = main_reap_children;\n\taction.sa_flags = 0;\n\tsigemptyset(&action.sa_mask);\n\tsigaction(SIGCHLD, &action, NULL);\n\t// Ignore SIGPIPE - we'll get EPIPE when trying to write to a closed\n\t// connection, we don't want to get killed by a signal in that case\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\n# ifdef HAVE_OPENSSL\n\tif (uses_ssl) {\n\t\tif (ssl_init_once(1, enable_compression, errbuf, PCAP_ERRBUF_SIZE) < 0)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Can't initialize SSL: %s\",\n\t\t\t    errbuf);\n\t\t\texit(2);\n\t\t}\n\t}\n# endif\n\n#ifndef _WIN32\n\tif (isrunbyinetd)\n\t{\n\t\t//\n\t\t// -i was specified, indicating that this is being run\n\t\t// by inetd or something that can run network daemons\n\t\t// as if it were inetd (xinetd, launchd, systemd, etc.).\n\t\t//\n\t\t// We assume that the program that launched us just\n\t\t// duplicated a single socket for the connection\n\t\t// to our standard input, output, and error, so we\n\t\t// can just use the standard input as our control\n\t\t// socket.\n\t\t//\n\t\tint sockctrl;\n\t\tint devnull_fd;\n\n\t\t//\n\t\t// Duplicate the standard input as the control socket.\n\t\t//\n\t\tsockctrl = dup(0);\n\t\tif (sockctrl == -1)\n\t\t{\n\t\t\tsock_geterror(NULL, errbuf, PCAP_ERRBUF_SIZE);\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Can't dup standard input: %s\",\n\t\t\t    errbuf);\n\t\t\texit(2);\n\t\t}\n\n\t\t//\n\t\t// Try to set the standard input, output, and error\n\t\t// to /dev/null.\n\t\t//\n\t\tdevnull_fd = open(\"/dev/null\", O_RDWR);\n\t\tif (devnull_fd != -1)\n\t\t{\n\t\t\t//\n\t\t\t// If this fails, just drive on.\n\t\t\t//\n\t\t\t(void)dup2(devnull_fd, 0);\n\t\t\t(void)dup2(devnull_fd, 1);\n\t\t\t(void)dup2(devnull_fd, 2);\n\t\t\tclose(devnull_fd);\n\t\t}\n\n\t\t//\n\t\t// Handle this client.\n\t\t// This is passive mode, so we don't care whether we were\n\t\t// told by the client to close.\n\t\t//\n\t\tchar *hostlist_copy = strdup(hostlist);\n\t\tif (hostlist_copy == NULL)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Out of memory copying the host/port list\");\n\t\t\texit(0);\n\t\t}\n\t\t(void)daemon_serviceloop(sockctrl, 0, hostlist_copy,\n\t\t    nullAuthAllowed, uses_ssl);\n\n\t\t//\n\t\t// Nothing more to do.\n\t\t//\n\t\texit(0);\n\t}\n#endif\n\n\tif (isdaemon)\n\t{\n\t\t//\n\t\t// This is being run as a daemon.\n\t\t// On UN*X, it might be manually run, or run from an\n\t\t// rc file.\n\t\t//\n#ifndef _WIN32\n\t\tint pid;\n\n\t\t//\n\t\t// Daemonize ourselves.\n\t\t//\n\t\t// Unix Network Programming, pg 336\n\t\t//\n\t\tif ((pid = fork()) != 0)\n\t\t\texit(0);\t\t// Parent terminates\n\n\t\t// First child continues\n\t\t// Set daemon mode\n\t\tsetsid();\n\n\t\t// generated under unix with 'kill -HUP', needed to reload the configuration\n\t\tmemset(&action, 0, sizeof (action));\n\t\taction.sa_handler = main_reread_config;\n\t\taction.sa_flags = 0;\n\t\tsigemptyset(&action.sa_mask);\n\t\tsigaction(SIGHUP, &action, NULL);\n\n\t\tif ((pid = fork()) != 0)\n\t\t\texit(0);\t\t// First child terminates\n\n\t\t// LINUX WARNING: the current linux implementation of pthreads requires a management thread\n\t\t// to handle some hidden stuff. So, as soon as you create the first thread, two threads are\n\t\t// created. Fom this point on, the number of threads active are always one more compared\n\t\t// to the number you're expecting\n\n\t\t// Second child continues\n//\t\tumask(0);\n//\t\tchdir(\"/\");\n#else\n\t\t//\n\t\t// This is being run as a service on Windows.\n\t\t//\n\t\t// If this call succeeds, it is blocking on Win32\n\t\t//\n\t\tif (svc_start() != 1)\n\t\t\trpcapd_log(LOGPRIO_DEBUG, \"Unable to start the service\");\n\n\t\t// When the previous call returns, the entire application has to be stopped.\n\t\texit(0);\n#endif\n\t}\n\telse\t// Console mode\n\t{\n#ifndef _WIN32\n\t\t// Enable the catching of Ctrl+C\n\t\tmemset(&action, 0, sizeof (action));\n\t\taction.sa_handler = main_terminate;\n\t\taction.sa_flags = 0;\n\t\tsigemptyset(&action.sa_mask);\n\t\tsigaction(SIGINT, &action, NULL);\n\n\t\t// generated under unix with 'kill -HUP', needed to reload the configuration\n\t\t// We do not have this kind of signal in Win32\n\t\tmemset(&action, 0, sizeof (action));\n\t\taction.sa_handler = main_reread_config;\n\t\taction.sa_flags = 0;\n\t\tsigemptyset(&action.sa_mask);\n\t\tsigaction(SIGHUP, &action, NULL);\n#endif\n\n\t\tprintf(\"Press CTRL + C to stop the server...\\n\");\n\t}\n\n\t// If we're a Win32 service, we have already called this function in the service_main\n\tmain_startup();\n\n\t// The code should never arrive here (since the main_startup is blocking)\n\t//  however this avoids a compiler warning\n\texit(0);\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              538,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void main_startup(void)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\t// keeps the error string, prior to be printed\n\tstruct addrinfo *addrinfo;\t\t// keeps the addrinfo chain; required to open a new socket\n\tint i;\n#ifdef _WIN32\n\tHANDLE threadId;\t\t\t// handle for the subthread\n#else\n\tpid_t pid;\n#endif\n\n\ti = 0;\n\taddrinfo = NULL;\n\tmemset(errbuf, 0, sizeof(errbuf));\n\n\t// Starts all the active threads\n\twhile ((i < MAX_ACTIVE_LIST) && (activelist[i].address[0] != 0))\n\t{\n\t\tactivelist[i].ai_family = mainhints.ai_family;\n\n#ifdef _WIN32\n\t\tthreadId = (HANDLE)_beginthreadex(NULL, 0, main_active,\n\t\t    (void *)&activelist[i], 0, NULL);\n\t\tif (threadId == 0)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_DEBUG, \"Error creating the active child threads\");\n\t\t\tcontinue;\n\t\t}\n\t\tCloseHandle(threadId);\n#else\n\t\tif ((pid = fork()) == 0)\t// I am the child\n\t\t{\n\t\t\tmain_active((void *) &activelist[i]);\n\t\t\texit(0);\n\t\t}\n#endif\n\t\ti++;\n\t}\n\n\t/*\n\t * The code that manages the active connections is not blocking;\n\t * the code that manages the passive connection is blocking.\n\t * So, if the user does not want to run in passive mode, we have\n\t * to block the main thread here, otherwise the program ends and\n\t * all threads are stopped.\n\t *\n\t * WARNING: this means that in case we have only active mode,\n\t * the program does not terminate even if all the child thread\n\t * terminates. The user has always to press Ctrl+C (or send a\n\t * SIGTERM) to terminate the program.\n\t */\n\tif (passivemode)\n\t{\n\t\tstruct addrinfo *tempaddrinfo;\n\n\t\t//\n\t\t// Get a list of sockets on which to listen.\n\t\t//\n\t\tif (sock_initaddress((address[0]) ? address : NULL, port, &mainhints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_DEBUG, \"%s\", errbuf);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (tempaddrinfo = addrinfo; tempaddrinfo;\n\t\t     tempaddrinfo = tempaddrinfo->ai_next)\n\t\t{\n\t\t\tSOCKET sock;\n\t\t\tstruct listen_sock *sock_info;\n\n\t\t\tif ((sock = sock_open(tempaddrinfo, SOCKOPEN_SERVER, SOCKET_MAXCONN, errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n\t\t\t{\n\t\t\t\tswitch (tempaddrinfo->ai_family)\n\t\t\t\t{\n\t\t\t\tcase AF_INET:\n\t\t\t\t{\n\t\t\t\t\tstruct sockaddr_in *in;\n\t\t\t\t\tchar addrbuf[INET_ADDRSTRLEN];\n\n\t\t\t\t\tin = (struct sockaddr_in *)tempaddrinfo->ai_addr;\n\t\t\t\t\trpcapd_log(LOGPRIO_WARNING, \"Can't listen on socket for %s:%u: %s\",\n\t\t\t\t\t    inet_ntop(AF_INET, &in->sin_addr,\n\t\t\t\t\t\taddrbuf, sizeof (addrbuf)),\n\t\t\t\t\t    ntohs(in->sin_port),\n\t\t\t\t\t    errbuf);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase AF_INET6:\n\t\t\t\t{\n\t\t\t\t\tstruct sockaddr_in6 *in6;\n\t\t\t\t\tchar addrbuf[INET6_ADDRSTRLEN];\n\n\t\t\t\t\tin6 = (struct sockaddr_in6 *)tempaddrinfo->ai_addr;\n\t\t\t\t\trpcapd_log(LOGPRIO_WARNING, \"Can't listen on socket for %s:%u: %s\",\n\t\t\t\t\t    inet_ntop(AF_INET6, &in6->sin6_addr,\n\t\t\t\t\t\taddrbuf, sizeof (addrbuf)),\n\t\t\t\t\t    ntohs(in6->sin6_port),\n\t\t\t\t\t    errbuf);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\trpcapd_log(LOGPRIO_WARNING, \"Can't listen on socket for address family %u: %s\",\n\t\t\t\t\t    tempaddrinfo->ai_family,\n\t\t\t\t\t    errbuf);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsock_info = (struct listen_sock *) malloc(sizeof (struct listen_sock));\n\t\t\tif (sock_info == NULL)\n\t\t\t{\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Can't allocate structure for listen socket\");\n\t\t\t\texit(2);\n\t\t\t}\n\t\t\tsock_info->sock = sock;\n\t\t\tsock_info->next = listen_socks;\n\t\t\tlisten_socks = sock_info;\n\t\t}\n\n\t\tfreeaddrinfo(addrinfo);\n\n\t\tif (listen_socks == NULL)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Can't listen on any address\");\n\t\t\texit(2);\n\t\t}\n\n\t\t//\n\t\t// Now listen on all of them, waiting for connections.\n\t\t//\n\t\taccept_connections();\n\t}\n\n\t//\n\t// We're done; exit.\n\t//\n\trpcapd_log(LOGPRIO_DEBUG, PROGRAM_NAME \" is closing.\\n\");\n\n#ifndef _WIN32\n\t//\n\t// Sends a KILL signal to all the processes in this process's\n\t// process group; i.e., it kills all the child processes\n\t// we've created.\n\t//\n\t// XXX - that also includes us, so we will be killed as well;\n\t// that may cause a message to be printed or logged.\n\t//\n\tkill(0, SIGKILL);\n#endif\n\n\t//\n\t// Just leave.  We shouldn't need to clean up sockets or\n\t// anything else, and if we try to do so, we'll could end\n\t// up closing sockets, or shutting Winsock down, out from\n\t// under service loops, causing all sorts of noisy error\n\t// messages.\n\t//\n\t// We shouldn't need to worry about cleaning up any resources\n\t// such as handles, sockets, threads, etc. - exit() should\n\t// terminate the process, causing all those resources to be\n\t// cleaned up (including the threads; Microsoft claims in the\n\t// ExitProcess() documentation that, if ExitProcess() is called,\n\t// \"If a thread is waiting on a kernel object, it will not be\n\t// terminated until the wait has completed.\", but claims in the\n\t// _beginthread()/_beginthreadex() documentation that \"All threads\n\t// are terminated if any thread calls abort, exit, _exit, or\n\t// ExitProcess.\" - the latter appears to be the case, even for\n\t// threads waiting on the event for a pcap_t).\n\t//\n\texit(0);\n}",
          "fn_code_pos": [
            [
              540,
              0
            ],
            [
              713,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main_startup",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nsend_state_change_event(void)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\t// keeps the error string, prior to be printed\n\n\tif (!SetEvent(state_change_event))\n\t{\n\t\tsock_geterror(NULL, errbuf, PCAP_ERRBUF_SIZE);\n\t\trpcapd_log(LOGPRIO_ERROR, \"SetEvent on shutdown event failed: %s\", errbuf);\n\t}\n}",
          "fn_code_pos": [
            [
              716,
              0
            ],
            [
              726,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "send_state_change_event",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nsend_shutdown_notification(void)\n{\n\t//\n\t// Indicate that the server should shut down.\n\t//\n\tshutdown_server = 1;\n\n\t//\n\t// Send a state change event, to wake up WSAWaitForMultipleEvents().\n\t//\n\tsend_state_change_event();\n}",
          "fn_code_pos": [
            [
              728,
              0
            ],
            [
              740,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "send_shutdown_notification",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nsend_reread_configuration_notification(void)\n{\n\t//\n\t// Indicate that the server should re-read its configuration file.\n\t//\n\treread_config = 1;\n\n\t//\n\t// Send a state change event, to wake up WSAWaitForMultipleEvents().\n\t//\n\tsend_state_change_event();\n}",
          "fn_code_pos": [
            [
              742,
              0
            ],
            [
              754,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "send_reread_configuration_notification",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static BOOL WINAPI main_ctrl_event(DWORD ctrltype)\n{\n\t//\n\t// ctrltype is one of:\n\t//\n\t// CTRL_C_EVENT - we got a ^C; this is like SIGINT\n\t// CTRL_BREAK_EVENT - we got Ctrl+Break\n\t// CTRL_CLOSE_EVENT - the console was closed; this is like SIGHUP\n\t// CTRL_LOGOFF_EVENT - a user is logging off; this is received\n\t//   only by services\n\t// CTRL_SHUTDOWN_EVENT - the systemis shutting down; this is\n\t//   received only by services\n\t//\n\t// For now, we treat all but CTRL_LOGOFF_EVENT as indications\n\t// that we should shut down.\n\t//\n\tswitch (ctrltype)\n\t{\n\t\tcase CTRL_C_EVENT:\n\t\tcase CTRL_BREAK_EVENT:\n\t\tcase CTRL_CLOSE_EVENT:\n\t\tcase CTRL_SHUTDOWN_EVENT:\n\t\t\t//\n\t\t\t// Set a shutdown notification.\n\t\t\t//\n\t\t\tsend_shutdown_notification();\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\t//\n\t// We handled this.\n\t//\n\treturn TRUE;\n}",
          "fn_code_pos": [
            [
              756,
              0
            ],
            [
              792,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main_ctrl_event",
            "parameters": {
              "ctrltype": "DWORD"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "static void main_terminate(int sign _U_)\n{\n\t//\n\t// Note that the server should shut down.\n\t// select() should get an EINTR error when we return,\n\t// so it will wake up and know it needs to check the flag.\n\t//\n\tshutdown_server = 1;\n}",
          "fn_code_pos": [
            [
              794,
              0
            ],
            [
              802,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main_terminate",
            "parameters": {
              "sign": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void main_reread_config(int sign _U_)\n{\n\t//\n\t// Note that the server should re-read its configuration file.\n\t// select() should get an EINTR error when we return,\n\t// so it will wake up and know it needs to check the flag.\n\t//\n\treread_config = 1;\n}",
          "fn_code_pos": [
            [
              804,
              0
            ],
            [
              812,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main_reread_config",
            "parameters": {
              "sign": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void main_reap_children(int sign _U_)\n{\n\tpid_t pid;\n\tint exitstat;\n\n\t// Reap all child processes that have exited.\n\t// For reference, Stevens, pg 128\n\n\twhile ((pid = waitpid(-1, &exitstat, WNOHANG)) > 0)\n\t\trpcapd_log(LOGPRIO_DEBUG, \"Child terminated\");\n\n\treturn;\n}",
          "fn_code_pos": [
            [
              814,
              0
            ],
            [
              826,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main_reap_children",
            "parameters": {
              "sign": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\naccept_connections(void)\n{\n#ifdef _WIN32\n\tstruct listen_sock *sock_info;\n\tDWORD num_events;\n\tWSAEVENT *events;\n\tint i;\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\t// keeps the error string, prior to be printed\n\n\t//\n\t// How big does the set of events need to be?\n\t// One for the shutdown event, plus one for every socket on which\n\t// we'll be listening.\n\t//\n\tnum_events = 1;\t\t// shutdown event\n\tfor (sock_info = listen_socks; sock_info;\n\t    sock_info = sock_info->next)\n\t{\n\t\tif (num_events == WSA_MAXIMUM_WAIT_EVENTS)\n\t\t{\n\t\t\t//\n\t\t\t// WSAWaitForMultipleEvents() doesn't support\n\t\t\t// more than WSA_MAXIMUM_WAIT_EVENTS events\n\t\t\t// on which to wait.\n\t\t\t//\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Too many sockets on which to listen\");\n\t\t\texit(2);\n\t\t}\n\t\tnum_events++;\n\t}\n\n\t//\n\t// Allocate the array of events.\n\t//\n\tevents = (WSAEVENT *) malloc(num_events * sizeof (WSAEVENT));\n\tif (events == NULL)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Can't allocate array of events which to listen\");\n\t\texit(2);\n\t}\n\n\t//\n\t// Fill it in.\n\t//\n\tevents[0] = state_change_event;\t// state change event first\n\tfor (sock_info = listen_socks, i = 1; sock_info;\n\t    sock_info = sock_info->next, i++)\n\t{\n\t\tWSAEVENT event;\n\n\t\t//\n\t\t// Create an event that is signaled if there's a connection\n\t\t// to accept on the socket in question.\n\t\t//\n\t\tevent = WSACreateEvent();\n\t\tif (event == WSA_INVALID_EVENT)\n\t\t{\n\t\t\tsock_geterror(NULL, errbuf, PCAP_ERRBUF_SIZE);\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Can't create socket event: %s\", errbuf);\n\t\t\texit(2);\n\t\t}\n\t\tif (WSAEventSelect(sock_info->sock, event, FD_ACCEPT) == SOCKET_ERROR)\n\t\t{\n\t\t\tsock_geterror(NULL, errbuf, PCAP_ERRBUF_SIZE);\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Can't setup socket event: %s\", errbuf);\n\t\t\texit(2);\n\t\t}\n\t\tevents[i] = event;\n\t}\n\n\tfor (;;)\n\t{\n\t\t//\n\t\t// Wait for incoming connections.\n\t\t//\n\t\tDWORD ret;\n\n\t\tret = WSAWaitForMultipleEvents(num_events, events, FALSE,\n\t\t    WSA_INFINITE, FALSE);\n\t\tif (ret == WSA_WAIT_FAILED)\n\t\t{\n\t\t\tsock_geterror(NULL, errbuf, PCAP_ERRBUF_SIZE);\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"WSAWaitForMultipleEvents failed: %s\", errbuf);\n\t\t\texit(2);\n\t\t}\n\n\t\tif (ret == WSA_WAIT_EVENT_0)\n\t\t{\n\t\t\t//\n\t\t\t// The state change event was set.\n\t\t\t//\n\t\t\tif (shutdown_server)\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Time to quit. Exit the loop.\n\t\t\t\t//\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (reread_config)\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// We should re-read the configuration\n\t\t\t\t// file.\n\t\t\t\t//\n\t\t\t\treread_config = 0;\t// clear the indicator\n\t\t\t\tfileconf_read();\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Check each socket.\n\t\t//\n\t\tfor (sock_info = listen_socks, i = 1; sock_info;\n\t\t    sock_info = sock_info->next, i++)\n\t\t{\n\t\t\tWSANETWORKEVENTS network_events;\n\n\t\t\tif (WSAEnumNetworkEvents(sock_info->sock,\n\t\t\t    events[i], &network_events) == SOCKET_ERROR)\n\t\t\t{\n\t\t\t\tsock_geterror(NULL, errbuf, PCAP_ERRBUF_SIZE);\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"WSAEnumNetworkEvents failed: %s\", errbuf);\n\t\t\t\texit(2);\n\t\t\t}\n\t\t\tif (network_events.lNetworkEvents & FD_ACCEPT)\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Did an error occur?\n\t\t\t\t//\n\t\t\t \tif (network_events.iErrorCode[FD_ACCEPT_BIT] != 0)\n\t\t\t \t{\n\t\t\t\t\t//\n\t\t\t\t\t// Yes - report it and keep going.\n\t\t\t\t\t//\n\t\t\t\t\tsock_fmterror(NULL,\n\t\t\t\t\t    network_events.iErrorCode[FD_ACCEPT_BIT],\n\t\t\t\t\t    errbuf,\n\t\t\t\t\t    PCAP_ERRBUF_SIZE);\n\t\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Socket error: %s\", errbuf);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// Accept the connection.\n\t\t\t\t//\n\t\t\t\taccept_connection(sock_info->sock);\n\t\t\t}\n\t\t}\n\t}\n#else\n\tstruct listen_sock *sock_info;\n\tint num_sock_fds;\n\n\t//\n\t// How big does the bitset of sockets on which to select() have\n\t// to be?\n\t//\n\tnum_sock_fds = 0;\n\tfor (sock_info = listen_socks; sock_info; sock_info = sock_info->next)\n\t{\n\t\tif (sock_info->sock + 1 > num_sock_fds)\n\t\t{\n\t\t\tif ((unsigned int)(sock_info->sock + 1) >\n\t\t\t    (unsigned int)FD_SETSIZE)\n\t\t\t{\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"Socket FD is too bit for an fd_set\");\n\t\t\t\texit(2);\n\t\t\t}\n\t\t\tnum_sock_fds = sock_info->sock + 1;\n\t\t}\n\t}\n\n\tfor (;;)\n\t{\n\t\tfd_set sock_fds;\n\t\tint ret;\n\n\t\t//\n\t\t// Set up an fd_set for all the sockets on which we're\n\t\t// listening.\n\t\t//\n\t\t// This set is modified by select(), so we have to\n\t\t// construct it anew each time.\n\t\t//\n\t\tFD_ZERO(&sock_fds);\n\t\tfor (sock_info = listen_socks; sock_info;\n\t\t    sock_info = sock_info->next)\n\t\t{\n\t\t\tFD_SET(sock_info->sock, &sock_fds);\n\t\t}\n\n\t\t//\n\t\t// Wait for incoming connections.\n\t\t//\n\t\tret = select(num_sock_fds, &sock_fds, NULL, NULL, NULL);\n\t\tif (ret == -1)\n\t\t{\n\t\t\tif (errno == EINTR)\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// If this is a \"terminate the\n\t\t\t\t// server\" signal, exit the loop,\n\t\t\t\t// otherwise just keep trying.\n\t\t\t\t//\n\t\t\t\tif (shutdown_server)\n\t\t\t\t{\n\t\t\t\t\t//\n\t\t\t\t\t// Time to quit.  Exit the loop.\n\t\t\t\t\t//\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (reread_config)\n\t\t\t\t{\n\t\t\t\t\t//\n\t\t\t\t\t// We should re-read the configuration\n\t\t\t\t\t// file.\n\t\t\t\t\t//\n\t\t\t\t\treread_config = 0;\t// clear the indicator\n\t\t\t\t\tfileconf_read();\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// Go back and wait again.\n\t\t\t\t//\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trpcapd_log(LOGPRIO_ERROR, \"select failed: %s\",\n\t\t\t\t    strerror(errno));\n\t\t\t\texit(2);\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// Check each socket.\n\t\t//\n\t\tfor (sock_info = listen_socks; sock_info;\n\t\t    sock_info = sock_info->next)\n\t\t{\n\t\t\tif (FD_ISSET(sock_info->sock, &sock_fds))\n\t\t\t{\n\t\t\t\t//\n\t\t\t\t// Accept the connection.\n\t\t\t\t//\n\t\t\t\taccept_connection(sock_info->sock);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\t//\n\t// Close all the listen sockets.\n\t//\n\tfor (sock_info = listen_socks; sock_info; sock_info = sock_info->next)\n\t{\n\t\tclosesocket(sock_info->sock);\n\t}\n\tsock_cleanup();\n}",
          "fn_code_pos": [
            [
              832,
              0
            ],
            [
              1092,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "accept_connections",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\naccept_connection(SOCKET listen_sock)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\t// keeps the error string, prior to be printed\n\tSOCKET sockctrl;\t\t\t// keeps the socket ID for this control connection\n\tstruct sockaddr_storage from;\t\t// generic sockaddr_storage variable\n\tsocklen_t fromlen;\t\t\t// keeps the length of the sockaddr_storage variable\n\n#ifdef _WIN32\n\tHANDLE threadId;\t\t\t// handle for the subthread\n\tu_long off = 0;\n\tstruct params_copy *params_copy = NULL;\n#else\n\tpid_t pid;\n#endif\n\n\t// Initialize errbuf\n\tmemset(errbuf, 0, sizeof(errbuf));\n\n\tfor (;;)\n\t{\n\t\t// Accept the connection\n\t\tfromlen = sizeof(struct sockaddr_storage);\n\n\t\tsockctrl = accept(listen_sock, (struct sockaddr *) &from, &fromlen);\n\n\t\tif (sockctrl != INVALID_SOCKET)\n\t\t{\n\t\t\t// Success.\n\t\t\tbreak;\n\t\t}\n\n\t\t// The accept() call can return this error when a signal is catched\n\t\t// In this case, we have simply to ignore this error code\n\t\t// Stevens, pg 124\n#ifdef _WIN32\n\t\tif (WSAGetLastError() == WSAEINTR)\n#else\n\t\tif (errno == EINTR)\n#endif\n\t\t\tcontinue;\n\n\t\t// Don't check for errors here, since the error can be due to the fact that the thread\n\t\t// has been killed\n\t\tsock_geterror(\"accept(): \", errbuf, PCAP_ERRBUF_SIZE);\n\t\trpcapd_log(LOGPRIO_ERROR, \"Accept of control connection from client failed: %s\",\n\t\t    errbuf);\n\t\treturn;\n\t}\n\n#ifdef _WIN32\n\t//\n\t// Put the socket back into blocking mode; doing WSAEventSelect()\n\t// on the listen socket makes that socket non-blocking, and it\n\t// appears that sockets returned from an accept() on that socket\n\t// are also non-blocking.\n\t//\n\t// First, we have to un-WSAEventSelect() this socket, and then\n\t// we can turn non-blocking mode off.\n\t//\n\t// If this fails, we aren't guaranteed that, for example, any\n\t// of the error message will be sent - if it can't be put in\n\t// the socket queue, the send will just fail.\n\t//\n\t// So we just log the message and close the connection.\n\t//\n\tif (WSAEventSelect(sockctrl, NULL, 0) == SOCKET_ERROR)\n\t{\n\t\tsock_geterror(\"WSAEventSelect: \", errbuf, PCAP_ERRBUF_SIZE);\n\t\trpcapd_log(LOGPRIO_ERROR, \"%s\", errbuf);\n\t\tsock_close(sockctrl, NULL, 0);\n\t\treturn;\n\t}\n\tif (ioctlsocket(sockctrl, FIONBIO, &off) == SOCKET_ERROR)\n\t{\n\t\tsock_geterror(\"ioctlsocket(FIONBIO): \", errbuf, PCAP_ERRBUF_SIZE);\n\t\trpcapd_log(LOGPRIO_ERROR, \"%s\", errbuf);\n\t\tsock_close(sockctrl, NULL, 0);\n\t\treturn;\n\t}\n\n\t//\n\t// Make a copy of the host list to pass to the new thread, so that\n\t// if we update it in the main thread, it won't catch us in the\n\t// middle of updating it.\n\t//\n\t// daemon_serviceloop() will free it once it's done with it.\n\t//\n\tchar *hostlist_copy = strdup(hostlist);\n\tif (hostlist_copy == NULL)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Out of memory copying the host/port list\");\n\t\tsock_close(sockctrl, NULL, 0);\n\t\treturn;\n\t}\n\n\t//\n\t// Allocate a location to hold the values of sockctrl.\n\t// It will be freed in the newly-created thread once it's\n\t// finished with it.\n\t//\n\tparams_copy = malloc(sizeof(*params_copy));\n\tif (params_copy == NULL)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Out of memory allocating the parameter copy structure\");\n\t\tfree(hostlist_copy);\n\t\tsock_close(sockctrl, NULL, 0);\n\t\treturn;\n\t}\n\tparams_copy->sockctrl = sockctrl;\n\tparams_copy->hostlist = hostlist_copy;\n\n\tthreadId = (HANDLE)_beginthreadex(NULL, 0,\n\t    main_passive_serviceloop_thread, (void *) params_copy, 0, NULL);\n\tif (threadId == 0)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Error creating the child thread\");\n\t\tfree(params_copy);\n\t\tfree(hostlist_copy);\n\t\tsock_close(sockctrl, NULL, 0);\n\t\treturn;\n\t}\n\tCloseHandle(threadId);\n#else /* _WIN32 */\n\tpid = fork();\n\tif (pid == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Error creating the child process: %s\",\n\t\t    strerror(errno));\n\t\tsock_close(sockctrl, NULL, 0);\n\t\treturn;\n\t}\n\tif (pid == 0)\n\t{\n\t\t//\n\t\t// Child process.\n\t\t//\n\t\t// Close the socket on which we're listening (must\n\t\t// be open only in the parent).\n\t\t//\n\t\tclosesocket(listen_sock);\n\n#if 0\n\t\t//\n\t\t// Modify thread params so that it can be killed at any time\n\t\t// XXX - is this necessary?  This is the main and, currently,\n\t\t// only thread in the child process, and nobody tries to\n\t\t// cancel us, although *we* may cancel the thread that's\n\t\t// handling the capture loop.\n\t\t//\n\t\tif (pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL))\n\t\t\tgoto end;\n\t\tif (pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL))\n\t\t\tgoto end;\n#endif\n\n\t\t//\n\t\t// Run the service loop.\n\t\t// This is passive mode, so we don't care whether we were\n\t\t// told by the client to close.\n\t\t//\n\t\tchar *hostlist_copy = strdup(hostlist);\n\t\tif (hostlist_copy == NULL)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Out of memory copying the host/port list\");\n\t\t\texit(0);\n\t\t}\n\t\t(void)daemon_serviceloop(sockctrl, 0, hostlist_copy,\n\t\t    nullAuthAllowed, uses_ssl);\n\n\t\texit(0);\n\t}\n\n\t// I am the parent\n\t// Close the socket for this session (must be open only in the child)\n\tclosesocket(sockctrl);\n#endif /* _WIN32 */\n}",
          "fn_code_pos": [
            [
              1112,
              0
            ],
            [
              1289,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "accept_connection",
            "parameters": {
              "listen_sock": "SOCKET"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void *\n#endif\nmain_active(void *ptr)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\t// keeps the error string, prior to be printed\n\tSOCKET sockctrl;\t\t\t// keeps the socket ID for this control connection\n\tstruct addrinfo hints;\t\t\t// temporary struct to keep settings needed to open the new socket\n\tstruct addrinfo *addrinfo;\t\t// keeps the addrinfo chain; required to open a new socket\n\tstruct active_pars *activepars;\n\n\tactivepars = (struct active_pars *) ptr;\n\n\t// Prepare to open a new server socket\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\t\t\t\t\t// WARNING Currently it supports only ONE socket family among IPv4 and IPv6\n\thints.ai_family = AF_INET;\t\t// PF_UNSPEC to have both IPv4 and IPv6 server\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_family = activepars->ai_family;\n\n\trpcapd_log(LOGPRIO_DEBUG, \"Connecting to host %s, port %s, using protocol %s\",\n\t    activepars->address, activepars->port, (hints.ai_family == AF_INET) ? \"IPv4\":\n\t    (hints.ai_family == AF_INET6) ? \"IPv6\" : \"Unspecified\");\n\n\t// Initialize errbuf\n\tmemset(errbuf, 0, sizeof(errbuf));\n\n\t// Do the work\n\tif (sock_initaddress(activepars->address, activepars->port, &hints, &addrinfo, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_DEBUG, \"%s\", errbuf);\n\t\treturn 0;\n\t}\n\n\tfor (;;)\n\t{\n\t\tint activeclose;\n\n\t\tif ((sockctrl = sock_open(addrinfo, SOCKOPEN_CLIENT, 0, errbuf, PCAP_ERRBUF_SIZE)) == INVALID_SOCKET)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_DEBUG, \"%s\", errbuf);\n\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Error connecting to host %s, port %s, using protocol %s\",\n\t\t\t\t\tactivepars->address, activepars->port, (hints.ai_family == AF_INET) ? \"IPv4\":\n\t\t\t\t\t(hints.ai_family == AF_INET6) ? \"IPv6\" : \"Unspecified\");\n\n\t\t\trpcapd_log(LOGPRIO_DEBUG, \"%s\", errbuf);\n\n\t\t\tsleep_secs(RPCAP_ACTIVE_WAIT);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *hostlist_copy = strdup(hostlist);\n\t\tif (hostlist_copy == NULL)\n\t\t{\n\t\t\trpcapd_log(LOGPRIO_ERROR, \"Out of memory copying the host/port list\");\n\t\t\tactiveclose = 0;\n\t\t\tsock_close(sockctrl, NULL, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//\n\t\t\t// daemon_serviceloop() will free the copy.\n\t\t\t//\n\t\t\tactiveclose = daemon_serviceloop(sockctrl, 1,\n\t\t\t    hostlist_copy, nullAuthAllowed, uses_ssl);\n\t\t}\n\n\t\t// If the connection is closed by the user explicitely, don't try to connect to it again\n\t\t// just exit the program\n\t\tif (activeclose == 1)\n\t\t\tbreak;\n\t}\n\n\tfreeaddrinfo(addrinfo);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1303,
              0
            ],
            [
              1379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main_active",
            "parameters": {
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned __stdcall main_passive_serviceloop_thread(void *ptr)\n{\n\tstruct params_copy params = *(struct params_copy *)ptr;\n\tfree(ptr);\n\n\t//\n\t// Handle this client.\n\t// This is passive mode, so we don't care whether we were\n\t// told by the client to close.\n\t//\n\t(void)daemon_serviceloop(params.sockctrl, 0, params.hostlist,\n\t    nullAuthAllowed, uses_ssl);\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1385,
              0
            ],
            [
              1399,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main_passive_serviceloop_thread",
            "parameters": {
              "ptr": "void"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "main_active(void *ptr)",
          "fn_dec_pos": [
            [
              98,
              26
            ],
            [
              98,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main_active",
            "parameters": {
              "ptr": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "main_ctrl_event(DWORD)",
          "fn_dec_pos": [
            [
              99,
              19
            ],
            [
              99,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main_ctrl_event",
            "parameters": {},
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "main_active(void *ptr)",
          "fn_dec_pos": [
            [
              101,
              13
            ],
            [
              101,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main_active",
            "parameters": {
              "ptr": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "main_terminate(int sign)",
          "fn_dec_pos": [
            [
              102,
              12
            ],
            [
              102,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main_terminate",
            "parameters": {
              "sign": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "main_reread_config(int sign)",
          "fn_dec_pos": [
            [
              103,
              12
            ],
            [
              103,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main_reread_config",
            "parameters": {
              "sign": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "accept_connections(void)",
          "fn_dec_pos": [
            [
              105,
              12
            ],
            [
              105,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "accept_connections",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "accept_connection(SOCKET listen_sock)",
          "fn_dec_pos": [
            [
              106,
              12
            ],
            [
              106,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "accept_connection",
            "parameters": {
              "listen_sock": "SOCKET"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "main_reap_children(int sign)",
          "fn_dec_pos": [
            [
              108,
              12
            ],
            [
              108,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main_reap_children",
            "parameters": {
              "sign": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "main_passive_serviceloop_thread(void *ptr)",
          "fn_dec_pos": [
            [
              111,
              26
            ],
            [
              111,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main_passive_serviceloop_thread",
            "parameters": {
              "ptr": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "main_active(void *ptr)",
          "fn_dec_pos": [
            [
              1305,
              0
            ],
            [
              1305,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main_active",
            "parameters": {
              "ptr": "void"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct listen_sock {\n\tstruct listen_sock *next;\n\tSOCKET sock;\n}",
          {
            "*next": "struct listen_sock",
            "sock": "SOCKET"
          },
          "listen_sock",
          [
            72,
            0
          ],
          [
            75,
            1
          ]
        ],
        [
          "struct params_copy {\n\tSOCKET sockctrl;\n\tchar *hostlist;\n}",
          {
            "sockctrl": "SOCKET",
            "*hostlist": "char"
          },
          "params_copy",
          [
            1102,
            0
          ],
          [
            1105,
            1
          ]
        ],
        [
          "struct listen_sock {\n\tstruct listen_sock *next;\n\tSOCKET sock;\n}",
          {
            "*next": "struct listen_sock",
            "sock": "SOCKET"
          },
          "listen_sock",
          [
            72,
            0
          ],
          [
            75,
            1
          ]
        ],
        [
          "struct listen_sock",
          {},
          "",
          [
            73,
            1
          ],
          [
            73,
            19
          ]
        ],
        [
          "struct active_pars",
          {},
          "",
          [
            79,
            0
          ],
          [
            79,
            18
          ]
        ],
        [
          "struct listen_sock",
          {},
          "",
          [
            81,
            7
          ],
          [
            81,
            25
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            84,
            7
          ],
          [
            84,
            22
          ]
        ],
        [
          "struct sigaction",
          {},
          "",
          [
            183,
            1
          ],
          [
            183,
            17
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            200,
            30
          ],
          [
            200,
            45
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            543,
            1
          ],
          [
            543,
            16
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            593,
            2
          ],
          [
            593,
            17
          ]
        ],
        [
          "struct listen_sock",
          {},
          "",
          [
            608,
            3
          ],
          [
            608,
            21
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            616,
            5
          ],
          [
            616,
            23
          ]
        ],
        [
          "struct sockaddr_in",
          {},
          "",
          [
            619,
            11
          ],
          [
            619,
            29
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            630,
            5
          ],
          [
            630,
            24
          ]
        ],
        [
          "struct sockaddr_in6",
          {},
          "",
          [
            633,
            12
          ],
          [
            633,
            31
          ]
        ],
        [
          "struct listen_sock",
          {},
          "",
          [
            651,
            16
          ],
          [
            651,
            34
          ]
        ],
        [
          "struct listen_sock",
          {},
          "",
          [
            651,
            53
          ],
          [
            651,
            71
          ]
        ],
        [
          "struct listen_sock",
          {},
          "",
          [
            836,
            1
          ],
          [
            836,
            19
          ]
        ],
        [
          "struct listen_sock",
          {},
          "",
          [
            983,
            1
          ],
          [
            983,
            19
          ]
        ],
        [
          "struct params_copy {\n\tSOCKET sockctrl;\n\tchar *hostlist;\n}",
          {
            "sockctrl": "SOCKET",
            "*hostlist": "char"
          },
          "params_copy",
          [
            1102,
            0
          ],
          [
            1105,
            1
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1117,
            1
          ],
          [
            1117,
            24
          ]
        ],
        [
          "struct params_copy",
          {},
          "",
          [
            1123,
            1
          ],
          [
            1123,
            19
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            1134,
            19
          ],
          [
            1134,
            42
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            1136,
            34
          ],
          [
            1136,
            49
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            1309,
            1
          ],
          [
            1309,
            16
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            1310,
            1
          ],
          [
            1310,
            16
          ]
        ],
        [
          "struct active_pars",
          {},
          "",
          [
            1311,
            1
          ],
          [
            1311,
            19
          ]
        ],
        [
          "struct active_pars",
          {},
          "",
          [
            1313,
            15
          ],
          [
            1313,
            33
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            1316,
            26
          ],
          [
            1316,
            41
          ]
        ],
        [
          "struct params_copy",
          {},
          "",
          [
            1387,
            1
          ],
          [
            1387,
            19
          ]
        ],
        [
          "struct params_copy",
          {},
          "",
          [
            1387,
            31
          ],
          [
            1387,
            49
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"ftmacros.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <errno.h>\t\t// for the errno variable\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <string.h>\t\t// for strtok, etc\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <stdlib.h>\t\t// for malloc(), free(), ...\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <pcap.h>\t\t// for PCAP_ERRBUF_SIZE\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <signal.h>\t\t// for signal()\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include \"fmtutils.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"sockutils.h\"\t\t// for socket calls\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include \"varattrs.h\"\t\t// for _U_\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"rpcapd.h\"\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include \"config_params.h\"\t// configuration file parameters\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include \"fileconf.h\"\t\t// for the configuration file management\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include \"rpcap-protocol.h\"\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include \"daemon.h\"\t\t// the true main() method of this daemon\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include \"log.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include \"sslutils.h\"\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include <process.h>\t\t// for thread stuff\n",
          [
            60,
            2
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include \"win32-svc.h\"\t// for Win32 service stuff\n",
          [
            61,
            2
          ],
          [
            62,
            0
          ]
        ],
        [
          "#include \"getopt.h\"\t\t// for getopt()-for-Windows\n",
          [
            62,
            2
          ],
          [
            63,
            0
          ]
        ],
        [
          "#include <fcntl.h>\t\t// for open()\n",
          [
            64,
            2
          ],
          [
            65,
            0
          ]
        ],
        [
          "#include <unistd.h>\t\t// for exit()\n",
          [
            65,
            2
          ],
          [
            66,
            0
          ]
        ],
        [
          "#include <sys/wait.h>\t\t// waitpid()\n",
          [
            66,
            2
          ],
          [
            67,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/rpcapd/log.c": {
      "fn_def_list": [
        {
          "fn_code": "static void rpcapd_vlog_stderr(log_priority priority, const char *message, va_list ap)\n{\n\tconst char *tag;\n\n\t/*\n\t * Squelch warnings from compilers that *don't* assume that\n\t * priority always has a valid enum value and therefore don't\n\t * assume that we'll always go through one of the case arms.\n\t *\n\t * If we have a default case, compilers that *do* assume that\n\t * will then complain about the default case code being\n\t * unreachable.\n\t *\n\t * Damned if you do, damned if you don't.\n\t */\n\ttag = \"\";\n\n\tswitch (priority) {\n\n\tcase LOGPRIO_DEBUG:\n\t\ttag = \"DEBUG: \";\n\t\tbreak;\n\n\tcase LOGPRIO_INFO:\n\t\ttag = \"\";\n\t\tbreak;\n\n\tcase LOGPRIO_WARNING:\n\t\ttag = \"warning: \";\n\t\tbreak;\n\n\tcase LOGPRIO_ERROR:\n\t\ttag = \"error: \";\n\t\tbreak;\n\t}\n\n\tfprintf(stderr, \"rpcapd: %s\", tag);\n\tvfprintf(stderr, message, ap);\n\tputc('\\n', stderr);\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcapd_vlog_stderr",
            "parameters": {
              "priority": "log_priority",
              "message": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void rpcapd_vlog_systemlog(log_priority priority, const char *message,\n    va_list ap)\n{\n#if 0\n\tstatic int initialized = 0;\n\tHKEY hey_handle;\n\tstatic HANDLE log_handle;\n\tWORD eventlog_type;\n\tDWORD event_id;\n\tchar msgbuf[1024];\n\tchar *strings[1];\n\n\tif (!initialized) {\n\t\t/*\n\t\t * Register our message stuff in the Registry.\n\t\t *\n\t\t * First, create the registry key for us.  If the key\n\t\t * already exists, this succeeds and returns a handle\n\t\t * for it.\n\t\t */\n\t\tif (RegCreateKey(HKEY_LOCAL_MACHINE, MESSAGE_SUBKEY,\n\t\t    &key_handle) != ERROR_SUCCESS) {\n\t\t\t/*\n\t\t\t * Failed - give up and just log this message,\n\t\t\t * and all subsequent messages, to the\n\t\t\t * standard error.\n\t\t\t */\n\t\t\tlog_to_systemlog = 0;\n\t\t\tinitialized = 1;\n\t\t\trpcapd_vlog_stderr(priority, message, ap);\n\t\t\treturn;\n\t\t}\n\t\tlog_handle = RegisterEventSource(NULL, \"rpcapd\");\n\t\tinitialized = 1;\n\t}\n\n\tswitch (priority) {\n\n\tcase LOGPRIO_DEBUG:\n\t\t//\n\t\t// XXX - what *should* we do about debug messages?\n\t\t//\n\t\teventlog_type = EVENTLOG_INFORMATION_TYPE;\n\t\tevent_id = RPCAPD_INFO_ID;\n\t\tbreak;\n\n\tcase LOGPRIO_INFO:\n\t\teventlog_type = EVENTLOG_INFORMATION_TYPE;\n\t\tevent_id = RPCAPD_INFO_ID;\n\t\tbreak;\n\n\tcase LOGPRIO_WARNING:\n\t\teventlog_type = EVENTLOG_WARNING_TYPE;\n\t\tevent_id = RPCAPD_WARNING_ID;\n\t\tbreak;\n\n\tcase LOGPRIO_ERROR:\n\t\teventlog_type = EVENTLOG_ERROR_TYPE;\n\t\tevent_id = RPCAPD_ERROR_ID;\n\t\tbreak;\n\n\tdefault:\n\t\t/* Don't do this. */\n\t\treturn;\n\t}\n\n\tvsprintf(msgbuf, message, ap);\n\n\tstrings[0] = msgbuf;\n\t/*\n\t * If this fails, how are we going to report it?\n\t */\n\t(void) ReportEvent(log_handle, eventlog_type, 0, event_id, NULL, 1, 0,\n\t    strings, NULL);\n#else\n\trpcapd_vlog_stderr(priority, message, ap);\n#endif\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              170,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcapd_vlog_systemlog",
            "parameters": {
              "priority": "log_priority",
              "message": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void rpcapd_vlog_systemlog(log_priority priority, const char *message,\n    va_list ap)\n{\n\tstatic int initialized = 0;\n\tint syslog_priority;\n\n\tif (!initialized) {\n\t\t//\n\t\t// Open the log.\n\t\t//\n\t\topenlog(\"rpcapd\", LOG_PID, LOG_DAEMON);\n\t\tinitialized = 1;\n\t}\n\n\tswitch (priority) {\n\n\tcase LOGPRIO_DEBUG:\n\t\tsyslog_priority = LOG_DEBUG;\n\t\tbreak;\n\n\tcase LOGPRIO_INFO:\n\t\tsyslog_priority = LOG_INFO;\n\t\tbreak;\n\n\tcase LOGPRIO_WARNING:\n\t\tsyslog_priority = LOG_WARNING;\n\t\tbreak;\n\n\tcase LOGPRIO_ERROR:\n\t\tsyslog_priority = LOG_ERR;\n\t\tbreak;\n\n\tdefault:\n\t\t/* Don't do this. */\n\t\treturn;\n\t}\n\n#ifdef HAVE_VSYSLOG\n\tvsyslog(syslog_priority, message, ap);\n#else\n\t/*\n\t * Thanks, IBM, for not providing vsyslog() in AIX!\n\t *\n\t * They also warn that the syslog functions shouldn't\n\t * be used in multithreaded programs, but the only thing\n\t * obvious that seems to make the syslog_r functions\n\t * better is that they have an additional argument\n\t * that points to the information that's static to\n\t * the syslog code in non-thread-safe versions.  Most\n\t * of that data is set by openlog(); since we already\n\t * do an openlog before doing logging, and don't\n\t * change that data afterwards, I suspect that, in\n\t * practice, the regular syslog routines are OK for\n\t * us (especially given that we'd end up having one\n\t * static struct syslog_data anyway, which means we'd\n\t * just be like the non-thread-safe version).\n\t */\n\tchar logbuf[1024+1];\n\n\tpcap_vsnprintf(logbuf, sizeof logbuf, message, ap);\n\tsyslog(syslog_priority, \"%s\", logbuf);\n#endif\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              234,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcapd_vlog_systemlog",
            "parameters": {
              "priority": "log_priority",
              "message": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void rpcapd_log_set(int log_to_systemlog_arg, int log_debug_messages_arg)\n{\n\tlog_debug_messages = log_debug_messages_arg;\n\tlog_to_systemlog = log_to_systemlog_arg;\n}",
          "fn_code_pos": [
            [
              237,
              0
            ],
            [
              241,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcapd_log_set",
            "parameters": {
              "log_to_systemlog_arg": "int",
              "log_debug_messages_arg": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void rpcapd_log(log_priority priority, const char *message, ...)\n{\n\tva_list ap;\n\n\tif (priority != LOGPRIO_DEBUG || log_debug_messages) {\n\t\tva_start(ap, message);\n\t\tif (log_to_systemlog)\n\t\t{\n\t\t\trpcapd_vlog_systemlog(priority, message, ap);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trpcapd_vlog_stderr(priority, message, ap);\n\t\t}\n\t\tva_end(ap);\n\t}\n}",
          "fn_code_pos": [
            [
              243,
              0
            ],
            [
              259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcapd_log",
            "parameters": {
              "priority": "log_priority",
              "message": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "rpcapd_vlog_stderr(log_priority,\n    PCAP_FORMAT_STRING(const char *), va_list)",
          "fn_dec_pos": [
            [
              42,
              12
            ],
            [
              43,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcapd_vlog_stderr",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "rpcapd_vlog_systemlog(log_priority,\n    PCAP_FORMAT_STRING(const char *), va_list)",
          "fn_dec_pos": [
            [
              86,
              12
            ],
            [
              87,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcapd_vlog_systemlog",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <windows.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <syslog.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"log.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/rpcapd/win32-svc.c": {
      "fn_def_list": [
        {
          "fn_code": "int svc_start(void)\n{\n\tint rc;\n\tSERVICE_TABLE_ENTRY ste[] =\n\t{\n\t\t{ PROGRAM_NAME, svc_main },\n\t\t{ NULL, NULL }\n\t};\n\tchar string[PCAP_ERRBUF_SIZE];\n\n\t// This call is blocking. A new thread is created which will launch\n\t// the svc_main() function\n\tif ((rc = StartServiceCtrlDispatcher(ste)) == 0) {\n\t\tpcap_win32_err_to_str(GetLastError(), string);\n\t\trpcapd_log(LOGPRIO_ERROR,\n\t\t    \"StartServiceCtrlDispatcher() failed: %s\", string);\n\t}\n\n\treturn rc; // FALSE if this is not started as a service\n}",
          "fn_code_pos": [
            [
              46,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "svc_start",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "void WINAPI svc_control_handler(DWORD Opcode)\n{\n\tswitch(Opcode)\n\t{\n\t\tcase SERVICE_CONTROL_STOP:\n\t\t\t//\n\t\t\t// XXX - is this sufficient to clean up the service?\n\t\t\t// To be really honest, only the main socket and\n\t\t\t// such these stuffs are cleared; however the threads\n\t\t\t// that are running are not stopped.\n\t\t\t// This can be seen by placing a breakpoint at the\n\t\t\t// end of svc_main(), in which you will see that is\n\t\t\t// never reached. However, as soon as you set the\n\t\t\t// service status to \"stopped\",\tthe\n\t\t\t// StartServiceCtrlDispatcher() returns and the main\n\t\t\t// thread ends. Then, Win32 has a good automatic\n\t\t\t// cleanup, so that all the threads which are still\n\t\t\t// running are stopped when the main thread ends.\n\t\t\t//\n\t\t\tsend_shutdown_notification();\n\n\t\t\tupdate_svc_status(SERVICE_STOP_PENDING, 0);\n\t\t\tbreak;\n\n\t\t/*\n\t\t\tPause and Continue have an usual meaning and they are used just to be able\n\t\t\tto change the running parameters at run-time. In other words, they act\n\t\t\tlike the SIGHUP signal on UNIX. All the running threads continue to run and\n\t\t\tthey are not paused at all.\n\t\t\tParticularly,\n\t\t\t- PAUSE does nothing\n\t\t\t- CONTINUE re-reads the configuration file and creates the new threads that\n\t\t\tcan be needed according to the new configuration.\n\t\t*/\n\t\tcase SERVICE_CONTROL_PAUSE:\n\t\t\tupdate_svc_status(SERVICE_PAUSED, 0);\n\t\t\tbreak;\n\n\t\tcase SERVICE_CONTROL_CONTINUE:\n\t\t\tupdate_svc_status(SERVICE_RUNNING, 0);\n\t\t\t//\n\t\t\t// Tell the main loop to re-read the configuration.\n\t\t\t//\n\t\t\tsend_reread_configuration_notification();\n\t\t\tbreak;\n\n\t\tcase SERVICE_CONTROL_INTERROGATE:\n\t\t\t// Fall through to send current status.\n\t\t\t//\tWARNING: not implemented\n\t\t\tupdate_svc_status(SERVICE_RUNNING, 0);\n\t\t\tMessageBox(NULL, \"Not implemented\", \"warning\", MB_OK);\n\t\t\tbreak;\n\n\t\tcase SERVICE_CONTROL_PARAMCHANGE:\n\t\t\t//\n\t\t\t// Tell the main loop to re-read the configuration.\n\t\t\t//\n\t\t\tsend_reread_configuration_notification();\n\t\t\tbreak;\n\t}\n\n\t// Send current status.\n\treturn;\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "svc_control_handler",
            "parameters": {
              "Opcode": "DWORD"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void WINAPI svc_main(DWORD argc, char **argv)\n{\n\tservice_status_handle = RegisterServiceCtrlHandler(PROGRAM_NAME, svc_control_handler);\n\n\tif (!service_status_handle)\n\t\treturn;\n\n\tservice_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS;\n\tservice_status.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE | SERVICE_ACCEPT_PARAMCHANGE;\n\t// | SERVICE_ACCEPT_SHUTDOWN ;\n\tupdate_svc_status(SERVICE_RUNNING, 0);\n\n\t//\n\t// Service requests until we're told to stop.\n\t//\n\tmain_startup();\n\n\t//\n\t// It returned, so we were told to stop.\n\t//\n\tupdate_svc_status(SERVICE_STOPPED, 0);\n}",
          "fn_code_pos": [
            [
              132,
              0
            ],
            [
              153,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "svc_main",
            "parameters": {
              "argc": "DWORD",
              "argv": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nupdate_svc_status(DWORD state, DWORD progress_indicator)\n{\n\tservice_status.dwWin32ExitCode = NO_ERROR;\n\tservice_status.dwCurrentState = state;\n\tservice_status.dwCheckPoint = progress_indicator;\n\tservice_status.dwWaitHint = 0;\n\tSetServiceStatus(service_status_handle, &service_status);\n}",
          "fn_code_pos": [
            [
              155,
              0
            ],
            [
              163,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "update_svc_status",
            "parameters": {
              "state": "DWORD",
              "progress_indicator": "DWORD"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "svc_main(DWORD argc, char **argv)",
          "fn_dec_pos": [
            [
              43,
              19
            ],
            [
              43,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "svc_main",
            "parameters": {
              "argc": "DWORD",
              "argv": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "update_svc_status(DWORD state, DWORD progress_indicator)",
          "fn_dec_pos": [
            [
              44,
              12
            ],
            [
              44,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "update_svc_status",
            "parameters": {
              "state": "DWORD",
              "progress_indicator": "DWORD"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"rpcapd.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <pcap.h>\t\t// for PCAP_ERRBUF_SIZE\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include \"fmtutils.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"fileconf.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"log.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/missing/asprintf.c": {
      "fn_def_list": [
        {
          "fn_code": "int\npcap_vasprintf(char **strp, const char *format, va_list args)\n{\n\tchar buf;\n\tint len;\n\tsize_t str_size;\n\tchar *str;\n\tint ret;\n\n\t/*\n\t * XXX - the C99 standard says, in section 7.19.6.5 \"Thes\n\t * nprintf function\":\n\t *\n\t *    The snprintf function is equivalent to fprintf, except that\n\t *    the output is written into an array (specified by argument s)\n\t *    rather than to a stream.  If n is zero, nothing is written,\n\t *    and s may be a null pointer.  Otherwise, output characters\n\t *    beyond the n-1st are discarded rather than being written\n\t *    to the array, and a null character is written at the end\n\t *    of the characters actually written into the array.\n\t *\n\t *        ...\n\t *\n\t *    The snprintf function returns the number of characters that\n\t *    would have been written had n been sufficiently large, not\n\t *    counting the terminating null character, or a negative value\n\t *    if an encoding error occurred. Thus, the null-terminated\n\t *    output has been completely written if and only if the returned\n\t *    value is nonnegative and less than n.\n\t *\n\t * That doesn't make it entirely clear whether, if a null buffer\n\t * pointer and a zero count are passed, it will return the number\n\t * of characters that would have been written had a buffer been\n\t * passed.\n\t *\n\t * And, even if C99 *does*, in fact, say it has to work, it\n\t * doesn't work in Solaris 8, for example - it returns -1 for\n\t * NULL/0, but returns the correct character count for a 1-byte\n\t * buffer.\n\t *\n\t * So we pass a one-character pointer in order to find out how\n\t * many characters this format and those arguments will need\n\t * without actually generating any more of those characters\n\t * than we need.\n\t *\n\t * (The fact that it might happen to work with GNU libc or with\n\t * various BSD libcs is completely uninteresting, as those tend\n\t * to have asprintf() already and thus don't even *need* this\n\t * code; this is for use in those UN*Xes that *don't* have\n\t * asprintf().)\n\t */\n\tlen = vsnprintf(&buf, sizeof buf, format, args);\n\tif (len == -1) {\n\t\t*strp = NULL;\n\t\treturn (-1);\n\t}\n\tstr_size = len + 1;\n\tstr = malloc(str_size);\n\tif (str == NULL) {\n\t\t*strp = NULL;\n\t\treturn (-1);\n\t}\n\tret = vsnprintf(str, str_size, format, args);\n\tif (ret == -1) {\n\t\tfree(str);\n\t\t*strp = NULL;\n\t\treturn (-1);\n\t}\n\t*strp = str;\n\t/*\n\t * vsnprintf() shouldn't truncate the string, as we have\n\t * allocated a buffer large enough to hold the string, so its\n\t * return value should be the number of characters written.\n\t */\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              12,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_vasprintf",
            "parameters": {
              "strp": "char",
              "format": "char",
              "args": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_asprintf(char **strp, const char *format, ...)\n{\n\tva_list args;\n\tint ret;\n\n\tva_start(args, format);\n\tret = pcap_vasprintf(strp, format, args);\n\tva_end(args);\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_asprintf",
            "parameters": {
              "strp": "char",
              "format": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            4,
            0
          ],
          [
            5,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/missing/getopt.c": {
      "fn_def_list": [
        {
          "fn_code": "int\ngetopt(int nargc, char * const *nargv, const char *ostr)\n{\n\tchar *cp;\n\tstatic char *__progname;\n\tstatic char *place = EMSG;\t\t/* option letter processing */\n\tchar *oli;\t\t\t\t/* option letter list index */\n\n\tif (__progname == NULL) {\n\t\tif ((cp = strrchr(nargv[0], '/')) != NULL)\n\t\t\t__progname = cp + 1;\n\t\telse\n\t\t\t__progname = nargv[0];\n\t}\n\tif (optreset || !*place) {\t\t/* update scanning pointer */\n\t\toptreset = 0;\n\t\tif (optind >= nargc || *(place = nargv[optind]) != '-') {\n\t\t\tplace = EMSG;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (place[1] && *++place == '-') {\t/* found \"--\" */\n\t\t\t++optind;\n\t\t\tplace = EMSG;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\toptopt = (int)*place++;\n\tif (optopt == (int)':') {\t\t/* option letter okay? */\n\t\tif (!*place)\n\t\t\t++optind;\n\t\tif (opterr && *ostr != ':')\n\t\t\t(void)fprintf(stderr,\n\t\t\t    \"%s: illegal option -- %c\\n\", __progname, optopt);\n\t\treturn (BADCH);\n\t}\n\toli = strchr(ostr, optopt);\n\tif (!oli) {\n\t\t/*\n\t\t * if the user didn't specify '-' as an option,\n\t\t * assume it means -1.\n\t\t */\n\t\tif (optopt == (int)'-')\n\t\t\treturn (-1);\n\t\tif (!*place)\n\t\t\t++optind;\n\t\tif (opterr && *ostr != ':')\n\t\t\t(void)fprintf(stderr,\n\t\t\t    \"%s: illegal option -- %c\\n\", __progname, optopt);\n\t\treturn (BADCH);\n\t}\n\tif (*++oli != ':') {\t\t\t/* don't need argument */\n\t\toptarg = NULL;\n\t\tif (!*place)\n\t\t\t++optind;\n\t}\n\telse {\t\t\t\t\t/* need an argument */\n\t\tif (*place)\t\t\t/* no white space */\n\t\t\toptarg = place;\n\t\telse if (nargc <= ++optind) {\t/* no arg */\n\t\t\tplace = EMSG;\n\t\t\tif (*ostr == ':')\n\t\t\t\treturn (BADARG);\n\t\t\tif (opterr)\n\t\t\t\t(void)fprintf(stderr,\n\t\t\t\t    \"%s: option requires an argument -- %c\\n\",\n\t\t\t\t    __progname, optopt);\n\t\t\treturn (BADCH);\n\t\t}\n\t \telse\t\t\t\t/* white space */\n\t\t\toptarg = nargv[optind];\n\t\tplace = EMSG;\n\t\t++optind;\n\t}\n\treturn (optopt);\t\t\t/* dump back option letter */\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              131,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {
              "nargc": "int",
              "nargv": "char",
              "ostr": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include \"getopt.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/missing/win_asprintf.c": {
      "fn_def_list": [
        {
          "fn_code": "int\npcap_vasprintf(char **strp, const char *format, va_list args)\n{\n\tint len;\n\tsize_t str_size;\n\tchar *str;\n\tint ret;\n\n\tlen = _vscprintf(format, args);\n\tif (len == -1) {\n\t\t*strp = NULL;\n\t\treturn (-1);\n\t}\n\tstr_size = len + 1;\n\tstr = malloc(str_size);\n\tif (str == NULL) {\n\t\t*strp = NULL;\n\t\treturn (-1);\n\t}\n\tret = pcap_vsnprintf(str, str_size, format, args);\n\tif (ret == -1) {\n\t\tfree(str);\n\t\t*strp = NULL;\n\t\treturn (-1);\n\t}\n\t*strp = str;\n\t/*\n\t * pcap_vsnprintf() shouldn't truncate the string, as we have\n\t * allocated a buffer large enough to hold the string, so its\n\t * return value should be the number of characters printed.\n\t */\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              6,
              0
            ],
            [
              38,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_vasprintf",
            "parameters": {
              "strp": "char",
              "format": "char",
              "args": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_asprintf(char **strp, const char *format, ...)\n{\n\tva_list args;\n\tint ret;\n\n\tva_start(args, format);\n\tret = pcap_vasprintf(strp, format, args);\n\tva_end(args);\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_asprintf",
            "parameters": {
              "strp": "char",
              "format": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            4,
            0
          ],
          [
            5,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/missing/snprintf.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nsn_reserve (struct state *state, size_t n)\n{\n  return state->s + n > state->theend;\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              78,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sn_reserve",
            "parameters": {
              "state": "struct state",
              "n": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nsn_append_char (struct state *state, unsigned char c)\n{\n  if (sn_reserve (state, 1)) {\n    return 1;\n  } else {\n    *state->s++ = c;\n    return 0;\n  }\n}",
          "fn_code_pos": [
            [
              80,
              0
            ],
            [
              89,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sn_append_char",
            "parameters": {
              "state": "struct state",
              "c": "unsigned char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nas_reserve (struct state *state, size_t n)\n{\n  if (state->s + n > state->theend) {\n    int off = state->s - state->str;\n    unsigned char *tmp;\n\n    if (state->max_sz && state->sz >= state->max_sz)\n      return 1;\n\n    state->sz = max(state->sz * 2, state->sz + n);\n    if (state->max_sz)\n      state->sz = min(state->sz, state->max_sz);\n    tmp = realloc (state->str, state->sz);\n    if (tmp == NULL)\n      return 1;\n    state->str = tmp;\n    state->s = state->str + off;\n    state->theend = state->str + state->sz - 1;\n  }\n  return 0;\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "as_reserve",
            "parameters": {
              "state": "struct state",
              "n": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nas_append_char (struct state *state, unsigned char c)\n{\n  if(as_reserve (state, 1))\n    return 1;\n  else {\n    *state->s++ = c;\n    return 0;\n  }\n}",
          "fn_code_pos": [
            [
              116,
              0
            ],
            [
              125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "as_append_char",
            "parameters": {
              "state": "struct state",
              "c": "unsigned char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nappend_number(struct state *state,\n\t      unsigned long num, unsigned base, char *rep,\n\t      int width, int prec, int flags, int minusp)\n{\n  int len = 0;\n  int i;\n\n  /* given precision, ignore zero flag */\n  if(prec != -1)\n    flags &= ~zero_flag;\n  else\n    prec = 1;\n  /* zero value with zero precision -> \"\" */\n  if(prec == 0 && num == 0)\n    return 0;\n  do{\n    if((*state->append_char)(state, rep[num % base]))\n      return 1;\n    len++;\n    num /= base;\n  }while(num);\n  prec -= len;\n  /* pad with prec zeros */\n  while(prec-- > 0){\n    if((*state->append_char)(state, '0'))\n      return 1;\n    len++;\n  }\n  /* add length of alternate prefix (added later) to len */\n  if(flags & alternate_flag && (base == 16 || base == 8))\n    len += base / 8;\n  /* pad with zeros */\n  if(flags & zero_flag){\n    width -= len;\n    if(minusp || (flags & space_flag) || (flags & plus_flag))\n      width--;\n    while(width-- > 0){\n      if((*state->append_char)(state, '0'))\n\treturn 1;\n      len++;\n    }\n  }\n  /* add alternate prefix */\n  if(flags & alternate_flag && (base == 16 || base == 8)){\n    if(base == 16)\n      if((*state->append_char)(state, rep[10] + 23)) /* XXX */\n\treturn 1;\n    if((*state->append_char)(state, '0'))\n      return 1;\n  }\n  /* add sign */\n  if(minusp){\n    if((*state->append_char)(state, '-'))\n      return 1;\n    len++;\n  } else if(flags & plus_flag) {\n    if((*state->append_char)(state, '+'))\n      return 1;\n    len++;\n  } else if(flags & space_flag) {\n    if((*state->append_char)(state, ' '))\n      return 1;\n    len++;\n  }\n  if(flags & minus_flag)\n    /* swap before padding with spaces */\n    for(i = 0; i < len / 2; i++){\n      char c = state->s[-i-1];\n      state->s[-i-1] = state->s[-len+i];\n      state->s[-len+i] = c;\n    }\n  width -= len;\n  while(width-- > 0){\n    if((*state->append_char)(state,  ' '))\n      return 1;\n    len++;\n  }\n  if(!(flags & minus_flag))\n    /* swap after padding with spaces */\n    for(i = 0; i < len / 2; i++){\n      char c = state->s[-i-1];\n      state->s[-i-1] = state->s[-len+i];\n      state->s[-len+i] = c;\n    }\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              215,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "append_number",
            "parameters": {
              "state": "struct state",
              "num": "unsigned long",
              "base": "unsigned",
              "rep": "char",
              "width": "int",
              "prec": "int",
              "flags": "int",
              "minusp": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nappend_string (struct state *state,\n\t       unsigned char *arg,\n\t       int width,\n\t       int prec,\n\t       int flags)\n{\n  if(prec != -1)\n    width -= prec;\n  else\n    width -= strlen((char *)arg);\n  if(!(flags & minus_flag))\n    while(width-- > 0)\n      if((*state->append_char) (state, ' '))\n\treturn 1;\n  if (prec != -1) {\n    while (*arg && prec--)\n      if ((*state->append_char) (state, *arg++))\n\treturn 1;\n  } else {\n    while (*arg)\n      if ((*state->append_char) (state, *arg++))\n\treturn 1;\n  }\n  if(flags & minus_flag)\n    while(width-- > 0)\n      if((*state->append_char) (state, ' '))\n\treturn 1;\n  return 0;\n}",
          "fn_code_pos": [
            [
              217,
              0
            ],
            [
              246,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "append_string",
            "parameters": {
              "state": "struct state",
              "arg": "unsigned char",
              "width": "int",
              "prec": "int",
              "flags": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nappend_char(struct state *state,\n\t    unsigned char arg,\n\t    int width,\n\t    int flags)\n{\n  while(!(flags & minus_flag) && --width > 0)\n    if((*state->append_char) (state, ' '))\n      return 1;\n\n  if((*state->append_char) (state, arg))\n    return 1;\n  while((flags & minus_flag) && --width > 0)\n    if((*state->append_char) (state, ' '))\n      return 1;\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              248,
              0
            ],
            [
              265,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "append_char",
            "parameters": {
              "state": "struct state",
              "arg": "unsigned char",
              "width": "int",
              "flags": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nxyzprintf (struct state *state, const char *char_format, va_list ap)\n{\n  const unsigned char *format = (const unsigned char *)char_format;\n  unsigned char c;\n\n  while((c = *format++)) {\n    if (c == '%') {\n      int flags      = 0;\n      int width      = 0;\n      int prec       = -1;\n      int long_flag  = 0;\n      int short_flag = 0;\n\n      /* flags */\n      while((c = *format++)){\n\tif(c == '-')\n\t  flags |= minus_flag;\n\telse if(c == '+')\n\t  flags |= plus_flag;\n\telse if(c == ' ')\n\t  flags |= space_flag;\n\telse if(c == '#')\n\t  flags |= alternate_flag;\n\telse if(c == '0')\n\t  flags |= zero_flag;\n\telse\n\t  break;\n      }\n\n      if((flags & space_flag) && (flags & plus_flag))\n\tflags ^= space_flag;\n\n      if((flags & minus_flag) && (flags & zero_flag))\n\tflags ^= zero_flag;\n\n      /* width */\n      if (isdigit(c))\n\tdo {\n\t  width = width * 10 + c - '0';\n\t  c = *format++;\n\t} while(isdigit(c));\n      else if(c == '*') {\n\twidth = va_arg(ap, int);\n\tc = *format++;\n      }\n\n      /* precision */\n      if (c == '.') {\n\tprec = 0;\n\tc = *format++;\n\tif (isdigit(c))\n\t  do {\n\t    prec = prec * 10 + c - '0';\n\t    c = *format++;\n\t  } while(isdigit(c));\n\telse if (c == '*') {\n\t  prec = va_arg(ap, int);\n\t  c = *format++;\n\t}\n      }\n\n      /* size */\n\n      if (c == 'h') {\n\tshort_flag = 1;\n\tc = *format++;\n      } else if (c == 'l') {\n\tlong_flag = 1;\n\tc = *format++;\n      }\n\n      switch (c) {\n      case 'c' :\n\tif(append_char(state, va_arg(ap, int), width, flags))\n\t  return -1;\n\tbreak;\n      case 's' :\n\tif (append_string(state,\n\t\t\t  va_arg(ap, unsigned char*),\n\t\t\t  width,\n\t\t\t  prec,\n\t\t\t  flags))\n\t  return -1;\n\tbreak;\n      case 'd' :\n      case 'i' : {\n\tlong arg;\n\tunsigned long num;\n\tint minusp = 0;\n\n\tPARSE_INT_FORMAT(arg, ap, signed);\n\n\tif (arg < 0) {\n\t  minusp = 1;\n\t  num = -arg;\n\t} else\n\t  num = arg;\n\n\tif (append_number (state, num, 10, \"0123456789\",\n\t\t\t   width, prec, flags, minusp))\n\t  return -1;\n\tbreak;\n      }\n      case 'u' : {\n\tunsigned long arg;\n\n\tPARSE_INT_FORMAT(arg, ap, unsigned);\n\n\tif (append_number (state, arg, 10, \"0123456789\",\n\t\t\t   width, prec, flags, 0))\n\t  return -1;\n\tbreak;\n      }\n      case 'o' : {\n\tunsigned long arg;\n\n\tPARSE_INT_FORMAT(arg, ap, unsigned);\n\n\tif (append_number (state, arg, 010, \"01234567\",\n\t\t\t   width, prec, flags, 0))\n\t  return -1;\n\tbreak;\n      }\n      case 'x' : {\n\tunsigned long arg;\n\n\tPARSE_INT_FORMAT(arg, ap, unsigned);\n\n\tif (append_number (state, arg, 0x10, \"0123456789abcdef\",\n\t\t\t   width, prec, flags, 0))\n\t  return -1;\n\tbreak;\n      }\n      case 'X' :{\n\tunsigned long arg;\n\n\tPARSE_INT_FORMAT(arg, ap, unsigned);\n\n\tif (append_number (state, arg, 0x10, \"0123456789ABCDEF\",\n\t\t\t   width, prec, flags, 0))\n\t  return -1;\n\tbreak;\n      }\n      case 'p' : {\n\tunsigned long arg = (unsigned long)va_arg(ap, void*);\n\n\tif (append_number (state, arg, 0x10, \"0123456789ABCDEF\",\n\t\t\t   width, prec, flags, 0))\n\t  return -1;\n\tbreak;\n      }\n      case 'n' : {\n\tint *arg = va_arg(ap, int*);\n\t*arg = state->s - state->str;\n\tbreak;\n      }\n      case '\\0' :\n\t  --format;\n\t  /* FALLTHROUGH */\n      case '%' :\n\tif ((*state->append_char)(state, c))\n\t  return -1;\n\tbreak;\n      default :\n\tif (   (*state->append_char)(state, '%')\n\t    || (*state->append_char)(state, c))\n\t  return -1;\n\tbreak;\n      }\n    } else\n      if ((*state->append_char) (state, c))\n\treturn -1;\n  }\n  return 0;\n}",
          "fn_code_pos": [
            [
              283,
              0
            ],
            [
              458,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "xyzprintf",
            "parameters": {
              "state": "struct state",
              "char_format": "char",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_snprintf (char *str, size_t sz, const char *format, ...)\n{\n  va_list args;\n  int ret;\n\n  va_start(args, format);\n  ret = pcap_vsnprintf (str, sz, format, args);\n\n#ifdef PARANOIA\n  {\n    int ret2;\n    char *tmp;\n\n    tmp = malloc (sz);\n    if (tmp == NULL)\n      abort ();\n\n    ret2 = pcap_vsprintf (tmp, format, args);\n    if (ret != ret2 || strcmp(str, tmp))\n      abort ();\n    free (tmp);\n  }\n#endif\n\n  va_end(args);\n  return ret;\n}",
          "fn_code_pos": [
            [
              461,
              0
            ],
            [
              488,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_snprintf",
            "parameters": {
              "str": "char",
              "sz": "size_t",
              "format": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nasprintf (char **ret, const char *format, ...)\n{\n  va_list args;\n  int val;\n\n  va_start(args, format);\n  val = vasprintf (ret, format, args);\n\n#ifdef PARANOIA\n  {\n    int ret2;\n    char *tmp;\n    tmp = malloc (val + 1);\n    if (tmp == NULL)\n      abort ();\n\n    ret2 = vsprintf (tmp, format, args);\n    if (val != ret2 || strcmp(*ret, tmp))\n      abort ();\n    free (tmp);\n  }\n#endif\n\n  va_end(args);\n  return val;\n}",
          "fn_code_pos": [
            [
              493,
              0
            ],
            [
              519,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "asprintf",
            "parameters": {
              "ret": "char",
              "format": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_asnprintf (char **ret, size_t max_sz, const char *format, ...)\n{\n  va_list args;\n  int val;\n\n  va_start(args, format);\n  val = pcap_vasnprintf (ret, max_sz, format, args);\n  va_end(args);\n\n#ifdef PARANOIA\n  {\n    int ret2;\n    char *tmp;\n    tmp = malloc (val + 1);\n    if (tmp == NULL)\n      abort ();\n\n    va_start(args, format);\n    ret2 = pcap_vsprintf (tmp, format, args);\n    va_end(args);\n    if (val != ret2 || strcmp(*ret, tmp))\n      abort ();\n    free (tmp);\n  }\n#endif\n\n  return val;\n}",
          "fn_code_pos": [
            [
              523,
              0
            ],
            [
              551,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_asnprintf",
            "parameters": {
              "ret": "char",
              "max_sz": "size_t",
              "format": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_vasprintf (char **ret, const char *format, va_list args)\n{\n  return pcap_vasnprintf (ret, 0, format, args);\n}",
          "fn_code_pos": [
            [
              555,
              0
            ],
            [
              559,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_vasprintf",
            "parameters": {
              "ret": "char",
              "format": "char",
              "args": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_vasnprintf (char **ret, size_t max_sz, const char *format, va_list args)\n{\n  int st;\n  size_t len;\n  struct state state;\n\n  state.max_sz = max_sz;\n  state.sz     = 1;\n  state.str    = malloc(state.sz);\n  if (state.str == NULL) {\n    *ret = NULL;\n    return -1;\n  }\n  state.s = state.str;\n  state.theend = state.s + state.sz - 1;\n  state.append_char = as_append_char;\n  state.reserve     = as_reserve;\n\n  st = xyzprintf (&state, format, args);\n  if (st) {\n    free (state.str);\n    *ret = NULL;\n    return -1;\n  } else {\n    char *tmp;\n\n    *state.s = '\\0';\n    len = state.s - state.str;\n    tmp = realloc (state.str, len+1);\n    if (tmp == NULL) {\n      free (state.str);\n      *ret = NULL;\n      return -1;\n    }\n    *ret = tmp;\n    return len;\n  }\n}",
          "fn_code_pos": [
            [
              564,
              0
            ],
            [
              602,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_vasnprintf",
            "parameters": {
              "ret": "char",
              "max_sz": "size_t",
              "format": "char",
              "args": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_vsnprintf (char *str, size_t sz, const char *format, va_list args)\n{\n  struct state state;\n  int ret;\n  unsigned char *ustr = (unsigned char *)str;\n\n  state.max_sz = 0;\n  state.sz     = sz;\n  state.str    = ustr;\n  state.s      = ustr;\n  state.theend = ustr + sz - 1;\n  state.append_char = sn_append_char;\n  state.reserve     = sn_reserve;\n\n  ret = xyzprintf (&state, format, args);\n  *state.s = '\\0';\n  if (ret)\n    return sz;\n  else\n    return state.s - state.str;\n}",
          "fn_code_pos": [
            [
              607,
              0
            ],
            [
              628,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_vsnprintf",
            "parameters": {
              "str": "char",
              "sz": "size_t",
              "format": "char",
              "args": "va_list"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*append_char)(struct state *, unsigned char)",
          "fn_dec_pos": [
            [
              68,
              6
            ],
            [
              68,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*reserve)(struct state *, size_t)",
          "fn_dec_pos": [
            [
              69,
              6
            ],
            [
              69,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct state {\n  unsigned char *str;\n  unsigned char *s;\n  unsigned char *theend;\n  size_t sz;\n  size_t max_sz;\n  int (*append_char)(struct state *, unsigned char);\n  int (*reserve)(struct state *, size_t);\n  /* XXX - methods */\n}",
          {
            "*str": "unsigned char",
            "*s": "unsigned char",
            "*theend": "unsigned char",
            "sz": "size_t",
            "max_sz": "size_t",
            "(*append_char)(struct state *, unsigned char)": "int",
            "(*reserve)(struct state *, size_t)": "int"
          },
          "state",
          [
            62,
            0
          ],
          [
            71,
            1
          ]
        ],
        [
          "struct state {\n  unsigned char *str;\n  unsigned char *s;\n  unsigned char *theend;\n  size_t sz;\n  size_t max_sz;\n  int (*append_char)(struct state *, unsigned char);\n  int (*reserve)(struct state *, size_t);\n  /* XXX - methods */\n}",
          {
            "*str": "unsigned char",
            "*s": "unsigned char",
            "*theend": "unsigned char",
            "sz": "size_t",
            "max_sz": "size_t",
            "(*append_char)(struct state *, unsigned char)": "int",
            "(*reserve)(struct state *, size_t)": "int"
          },
          "state",
          [
            62,
            0
          ],
          [
            71,
            1
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            68,
            21
          ],
          [
            68,
            33
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            69,
            17
          ],
          [
            69,
            29
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            75,
            12
          ],
          [
            75,
            24
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            81,
            16
          ],
          [
            81,
            28
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            94,
            12
          ],
          [
            94,
            24
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            117,
            16
          ],
          [
            117,
            28
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            129,
            14
          ],
          [
            129,
            26
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            218,
            15
          ],
          [
            218,
            27
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            249,
            12
          ],
          [
            249,
            24
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            284,
            11
          ],
          [
            284,
            23
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            569,
            2
          ],
          [
            569,
            14
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            610,
            2
          ],
          [
            610,
            14
          ]
        ]
      ],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "enum format_flags {\n    minus_flag     =  1,\n    plus_flag      =  2,\n    space_flag     =  4,\n    alternate_flag =  8,\n    zero_flag      = 16\n}",
          {
            "minus_flag": "",
            "plus_flag": "",
            "space_flag": "",
            "alternate_flag": "",
            "zero_flag": ""
          },
          "format_flags",
          [
            50,
            0
          ],
          [
            56,
            1
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/missing/strlcpy.c": {
      "fn_def_list": [
        {
          "fn_code": "size_t\npcap_strlcpy(char * restrict dst, const char * restrict src, size_t dsize)\n{\n\tconst char *osrc = src;\n\tsize_t nleft = dsize;\n\n\t/* Copy as many bytes as will fit. */\n\tif (nleft != 0) {\n\t\twhile (--nleft != 0) {\n\t\t\tif ((*dst++ = *src++) == '\\0')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Not enough room in dst, add NUL and traverse rest of src. */\n\tif (nleft == 0) {\n\t\tif (dsize != 0)\n\t\t\t*dst = '\\0';\t\t/* NUL-terminate dst */\n\t\twhile (*src++)\n\t\t\t;\n\t}\n\n\treturn(src - osrc - 1);\t/* count does not include NUL */\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_strlcpy",
            "parameters": {
              "dst": "char",
              "src": "char",
              "dsize": "size_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include <stddef.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/missing/win_snprintf.c": {
      "fn_def_list": [
        {
          "fn_code": "int\npcap_vsnprintf(char *str, size_t str_size, const char *format, va_list args)\n{\n\tint ret;\n\n\tret = _vsnprintf_s(str, str_size, _TRUNCATE, format, args);\n\n\t/*\n\t * XXX - _vsnprintf() and _snprintf() do *not* guarantee\n\t * that str is null-terminated, but C99's vsnprintf()\n\t * and snprintf() do, and we want to offer C99 behavior,\n\t * so forcibly null-terminate the string.\n\t *\n\t * We don't, however, offer C99 behavior for the return\n\t * value; _vsnprintf_s() returns -1, not the number of\n\t * characters that would have been put into the buffer\n\t * had it been large enough, if the string is truncated.\n\t * The only way to get that value is to use _vscprintf();\n\t * getting that count isn't worth the re-formatting.\n\t *\n\t * XXX - does _vsnprintf_s() return -1 on a formatting\n\t * error?\n\t */\n\tstr[str_size - 1] = '\\0';\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              5,
              0
            ],
            [
              30,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_vsnprintf",
            "parameters": {
              "str": "char",
              "str_size": "size_t",
              "format": "char",
              "args": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_snprintf(char *str, size_t str_size, const char *format, ...)\n{\n\tva_list args;\n\tint ret;\n\n\tva_start(args, format);\n\tret = pcap_vsnprintf(str, str_size, format, args);\n\tva_end(args);\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              42,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_snprintf",
            "parameters": {
              "str": "char",
              "str_size": "size_t",
              "format": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            3,
            0
          ],
          [
            4,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/missing/strlcat.c": {
      "fn_def_list": [
        {
          "fn_code": "size_t\npcap_strlcat(char * restrict dst, const char * restrict src, size_t dsize)\n{\n\tconst char *odst = dst;\n\tconst char *osrc = src;\n\tsize_t n = dsize;\n\tsize_t dlen;\n\n\t/* Find the end of dst and adjust bytes left but don't go past end. */\n\twhile (n-- != 0 && *dst != '\\0')\n\t\tdst++;\n\tdlen = dst - odst;\n\tn = dsize - dlen;\n\n\tif (n-- == 0)\n\t\treturn(dlen + strlen(src));\n\twhile (*src != '\\0') {\n\t\tif (n != 0) {\n\t\t\t*dst++ = *src;\n\t\t\tn--;\n\t\t}\n\t\tsrc++;\n\t}\n\t*dst = '\\0';\n\n\treturn(dlen + (src - osrc));\t/* count does not include NUL */\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_strlcat",
            "parameters": {
              "dst": "char",
              "src": "char",
              "dsize": "size_t"
            },
            "return_type": "size_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include <stddef.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/missing/strtok_r.c": {
      "fn_def_list": [
        {
          "fn_code": "char *\npcap_strtok_r(char *s, const char *delim, char **last)\n{\n\tchar *spanp, *tok;\n\tint c, sc;\n\n\tif (s == NULL && (s = *last) == NULL)\n\t\treturn (NULL);\n\n\t/*\n\t * Skip (span) leading delimiters (s += strspn(s, delim), sort of).\n\t */\ncont:\n\tc = *s++;\n\tfor (spanp = (char *)delim; (sc = *spanp++) != 0;) {\n\t\tif (c == sc)\n\t\t\tgoto cont;\n\t}\n\n\tif (c == 0) {\t\t/* no non-delimiter characters */\n\t\t*last = NULL;\n\t\treturn (NULL);\n\t}\n\ttok = s - 1;\n\n\t/*\n\t * Scan token (scan for delimiters: s += strcspn(s, delim), sort of).\n\t * Note that delim must have one NUL; we stop if we see that, too.\n\t */\n\tfor (;;) {\n\t\tc = *s++;\n\t\tspanp = (char *)delim;\n\t\tdo {\n\t\t\tif ((sc = *spanp++) == c) {\n\t\t\t\tif (c == 0)\n\t\t\t\t\ts = NULL;\n\t\t\t\telse\n\t\t\t\t\ts[-1] = '\\0';\n\t\t\t\t*last = s;\n\t\t\t\treturn (tok);\n\t\t\t}\n\t\t} while (sc != 0);\n\t}\n\t/* NOTREACHED */\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_strtok_r",
            "parameters": {
              "s": "char",
              "delim": "char",
              "last": "char"
            },
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "pcap_strtok_r(char *s, const char *delim, char **last)",
          "fn_dec_pos": [
            [
              43,
              0
            ],
            [
              43,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_strtok_r",
            "parameters": {
              "s": "char",
              "delim": "char",
              "last": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-haiku.cpp": {
      "fn_def_list": [
        {
          "fn_code": "bool\nprepare_request(struct ifreq& request, const char* name)\n{\n\tif (strlen(name) >= IF_NAMESIZE)\n\t\treturn false;\n\n\tstrcpy(request.ifr_name, name);\n\treturn true;\n}",
          "fn_code_pos": [
            [
              37,
              0
            ],
            [
              45,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "prepare_request",
            "parameters": {
              "request": "struct ifreq",
              "name": "char"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "static int\npcap_read_haiku(pcap_t* handle, int maxPackets, pcap_handler callback,\n\tu_char* userdata)\n{\n\t// Receive a single packet\n\n\tstruct pcap_haiku* handlep = (struct pcap_haiku*)handle->priv;\n\tu_char* buffer = (u_char*)handle->buffer + handle->offset;\n\tstruct sockaddr_dl from;\n\tssize_t bytesReceived;\n\tdo {\n\t\tif (handle->break_loop) {\n\t\t\t// Clear the break loop flag, and return -2 to indicate our\n\t\t\t// reasoning\n\t\t\thandle->break_loop = 0;\n\t\t\treturn -2;\n\t\t}\n\n\t\tsocklen_t fromLength = sizeof(from);\n\t\tbytesReceived = recvfrom(handle->fd, buffer, handle->bufsize, MSG_TRUNC,\n\t\t\t(struct sockaddr*)&from, &fromLength);\n\t} while (bytesReceived < 0 && errno == B_INTERRUPTED);\n\n\tif (bytesReceived < 0) {\n\t\tif (errno == B_WOULD_BLOCK) {\n\t\t\t// there is no packet for us\n\t\t\treturn 0;\n\t\t}\n\n\t\tsnprintf(handle->errbuf, sizeof(handle->errbuf),\n\t\t\t\"recvfrom: %s\", strerror(errno));\n\t\treturn -1;\n\t}\n\n\tint32 captureLength = bytesReceived;\n\tif (captureLength > handle->snapshot)\n\t\tcaptureLength = handle->snapshot;\n\n/*\n\t// run the packet filter\n\tif (!handle->md.use_bpf && handle->fcode.bf_insns) {\n\t\tif (bpf_filter(handle->fcode.bf_insns, buffer, bytesReceived,\n\t\t\t\tcaptureLength) == 0) {\n\t\t\t// packet got rejected\n\t\t\treturn 0;\n\t\t}\n\t}\n*/\n\n\t// fill in pcap_header\n\n\tpcap_pkthdr header;\n\theader.caplen = captureLength;\n\theader.len = bytesReceived;\n\theader.ts.tv_usec = system_time() % 1000000;\n\theader.ts.tv_sec = system_time() / 1000000;\n\t\t// TODO: get timing from packet!!!\n\n\t/* Call the user supplied callback function */\n\tcallback(userdata, &header, buffer);\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_read_haiku",
            "parameters": {
              "handle": "pcap_t",
              "maxPackets": "int",
              "callback": "pcap_handler",
              "userdata": "u_char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_inject_haiku(pcap_t *handle, const void *buffer, int size)\n{\n\t// we don't support injecting packets yet\n\t// TODO: use the AF_LINK protocol (we need another socket for this) to\n\t// inject the packets\n\tstrlcpy(handle->errbuf, \"Sending packets isn't supported yet\",\n\t\tPCAP_ERRBUF_SIZE);\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              121,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject_haiku",
            "parameters": {
              "handle": "pcap_t",
              "buffer": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_setfilter_haiku(pcap_t *handle, struct bpf_program *filter)\n{\n\t// Make our private copy of the filter\n\tif (install_bpf_program(handle, filter) < 0) {\n\t\t// install_bpf_program() filled in errbuf\n\t\treturn -1;\n\t}\n\n\t// we don't support kernel filters at all\n\t//handle->md.use_bpf = 0;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              124,
              0
            ],
            [
              136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter_haiku",
            "parameters": {
              "handle": "pcap_t",
              "filter": "struct bpf_program"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_stats_haiku(pcap_t *handle, struct pcap_stat *stats)\n{\n\tstruct pcap_haiku* handlep = (struct pcap_haiku*)handle->priv;\n\tifreq request;\n\tint socket = ::socket(AF_INET, SOCK_DGRAM, 0);\n\tif (socket < 0) {\n\t\treturn -1;\n\t}\n\tprepare_request(request, handlep->device);\n\tif (ioctl(socket, SIOCGIFSTATS, &request, sizeof(struct ifreq)) < 0) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"pcap_stats: %s\",\n\t\t\tstrerror(errno));\n\t\tclose(socket);\n\t\treturn -1;\n\t}\n\n\tclose(socket);\n\thandlep->stat.ps_recv += request.ifr_stats.receive.packets;\n\thandlep->stat.ps_drop += request.ifr_stats.receive.dropped;\n\t*stats = handlep->stat;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              139,
              0
            ],
            [
              161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_haiku",
            "parameters": {
              "handle": "pcap_t",
              "stats": "struct pcap_stat"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\npcap_activate_haiku(pcap_t *handle)\n{\n\tstruct pcap_haiku* handlep = (struct pcap_haiku*)handle->priv;\n\n\tconst char* device = handle->opt.device;\n\n\thandle->read_op = pcap_read_haiku;\n\thandle->setfilter_op = pcap_setfilter_haiku;\n\thandle->inject_op = pcap_inject_haiku;\n\thandle->stats_op = pcap_stats_haiku;\n\n\t// use default hooks where possible\n\thandle->getnonblock_op = pcap_getnonblock_fd;\n\thandle->setnonblock_op = pcap_setnonblock_fd;\n\t//handle->close_op = pcap_close_common;\n\n\thandlep->device\t= strdup(device);\n\tif (handlep->device == NULL) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"strdup: %s\",\n\t\t\t pcap_strerror(errno) );\n\t\treturn PCAP_ERROR;\n\t}\n\t\n\thandle->bufsize = 65536;\n\t\t// TODO: should be determined by interface MTU\n\n\t// allocate buffer for monitoring the device\n\thandle->buffer = (u_char*)malloc(handle->bufsize);\n\tif (handle->buffer == NULL) {\n\t\tsnprintf(handle->errbuf, PCAP_ERRBUF_SIZE, \"buffer malloc: %s\",\n\t\t\tstrerror(errno));\n\t\treturn PCAP_ERROR;\n\t}\n\n\thandle->offset = 0;\n\thandle->linktype = DLT_EN10MB;\n\t\t// TODO: check interface type!\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              164,
              0
            ],
            [
              204,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_activate_haiku",
            "parameters": {
              "handle": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_t *\npcap_create_interface(const char *device, char *errorBuffer)\n{\n\t// TODO: handle promiscous mode!\n\n\t// we need a socket to talk to the networking stack\n\tint socket = ::socket(AF_INET, SOCK_DGRAM, 0);\n\tif (socket < 0) {\n\t\tsnprintf(errorBuffer, PCAP_ERRBUF_SIZE,\n\t\t\t\"The networking stack doesn't seem to be available.\\n\");\n\t\treturn NULL;\n\t}\n\n\tstruct ifreq request;\n\tif (!prepare_request(request, device)) {\n\t\tsnprintf(errorBuffer, PCAP_ERRBUF_SIZE,\n\t\t\t\"Interface name \\\"%s\\\" is too long.\", device);\n\t\tclose(socket);\n\t\treturn NULL;\n\t}\n\n\t// check if the interface exist\n\tif (ioctl(socket, SIOCGIFINDEX, &request, sizeof(request)) < 0) {\n\t\tsnprintf(errorBuffer, PCAP_ERRBUF_SIZE,\n\t\t\t\"Interface \\\"%s\\\" does not exist.\\n\", device);\n\t\tclose(socket);\n\t\treturn NULL;\n\t}\n\n\tclose(socket);\n\t\t// no longer needed after this point\n\n\t// get link level interface for this interface\n\n\tsocket = ::socket(AF_LINK, SOCK_DGRAM, 0);\n\tif (socket < 0) {\n\t\tsnprintf(errorBuffer, PCAP_ERRBUF_SIZE, \"No link level: %s\\n\",\n\t\t\tstrerror(errno));\n\t\treturn NULL;\n\t}\n\n\t// start monitoring\n\tif (ioctl(socket, SIOCSPACKETCAP, &request, sizeof(struct ifreq)) < 0) {\n\t\tsnprintf(errorBuffer, PCAP_ERRBUF_SIZE, \"Cannot start monitoring: %s\\n\",\n\t\t\tstrerror(errno));\n\t\tclose(socket);\n\t\treturn NULL;\n\t}\n\n\tpcap_t* handle = pcap_create_common(errorBuffer,\n\t\tsizeof (struct pcap_haiku));\n\tif (handle == NULL) {\n\t\tsnprintf(errorBuffer, PCAP_ERRBUF_SIZE, \"malloc: %s\", strerror(errno));\n\t\tclose(socket);\n\t\treturn NULL;\n\t}\n\n\thandle->selectable_fd = socket;\n\thandle->fd = socket;\n\t\n\thandle->activate_op = pcap_activate_haiku;\n\t//handle->can_set_rfmon_op = pcap_can_set_rfmon_linux;\n\n\treturn handle;\n}",
          "fn_code_pos": [
            [
              210,
              11
            ],
            [
              274,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "errorBuffer": "char"
            },
            "return_type": "pcap_t"
          }
        },
        {
          "fn_code": "static int\ncan_be_bound(const char *name)\n{\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              276,
              0
            ],
            [
              280,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "can_be_bound",
            "parameters": {
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nget_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)\n{\n\t/* TODO */\n\tif (*flags & PCAP_IF_LOOPBACK) {\n\t\t/*\n\t\t * Loopback devices aren't wireless, and \"connected\"/\n\t\t * \"disconnected\" doesn't apply to them.\n\t\t */\n\t\t*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;\n\t\treturn (0);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              282,
              0
            ],
            [
              295,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_if_flags",
            "parameters": {
              "name": "char",
              "flags": "bpf_u_int32",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\npcap_platform_finddevs(pcap_if_list_t* _allDevices, char* errorBuffer)\n{\n\treturn pcap_findalldevs_interfaces(_allDevices, errorBuffer, can_be_bound,\n\t\tget_if_flags);\n}",
          "fn_code_pos": [
            [
              297,
              11
            ],
            [
              302,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_platform_finddevs",
            "parameters": {
              "_allDevices": "pcap_if_list_t",
              "errorBuffer": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "pcap_create_interface(const char *device, char *errorBuffer)",
          "fn_dec_pos": [
            [
              211,
              0
            ],
            [
              211,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {
              "device": "char",
              "errorBuffer": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_haiku {\n\tstruct pcap_stat\tstat;\n\tchar\t*device;\t/* device name */\n}",
          {
            "stat": "struct pcap_stat",
            "*device": "char"
          },
          "pcap_haiku",
          [
            31,
            0
          ],
          [
            34,
            1
          ]
        ],
        [
          "struct pcap_haiku {\n\tstruct pcap_stat\tstat;\n\tchar\t*device;\t/* device name */\n}",
          {
            "stat": "struct pcap_stat",
            "*device": "char"
          },
          "pcap_haiku",
          [
            31,
            0
          ],
          [
            34,
            1
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            32,
            1
          ],
          [
            32,
            17
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            38,
            16
          ],
          [
            38,
            28
          ]
        ],
        [
          "struct pcap_haiku",
          {},
          "",
          [
            54,
            1
          ],
          [
            54,
            18
          ]
        ],
        [
          "struct pcap_haiku",
          {},
          "",
          [
            54,
            31
          ],
          [
            54,
            48
          ]
        ],
        [
          "struct sockaddr_dl",
          {},
          "",
          [
            56,
            1
          ],
          [
            56,
            19
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            68,
            4
          ],
          [
            68,
            19
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            125,
            37
          ],
          [
            125,
            55
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            140,
            33
          ],
          [
            140,
            49
          ]
        ],
        [
          "struct pcap_haiku",
          {},
          "",
          [
            142,
            1
          ],
          [
            142,
            18
          ]
        ],
        [
          "struct pcap_haiku",
          {},
          "",
          [
            142,
            31
          ],
          [
            142,
            48
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            149,
            50
          ],
          [
            149,
            62
          ]
        ],
        [
          "struct pcap_haiku",
          {},
          "",
          [
            167,
            1
          ],
          [
            167,
            18
          ]
        ],
        [
          "struct pcap_haiku",
          {},
          "",
          [
            167,
            31
          ],
          [
            167,
            48
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            223,
            1
          ],
          [
            223,
            13
          ]
        ],
        [
          "struct ifreq",
          {},
          "",
          [
            252,
            52
          ],
          [
            252,
            64
          ]
        ],
        [
          "struct pcap_haiku",
          {},
          "",
          [
            260,
            10
          ],
          [
            260,
            27
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"config.h\"\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"pcap-int.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <OS.h>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include <sys/sockio.h>\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include <net/if.h>\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include <net/if_dl.h>\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include <net/if_types.h>\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    }
  },
  "head": {
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-septel.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "septel_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              11,
              8
            ],
            [
              11,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "septel_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "septel_findalldevs(pcap_if_list_t *devlistp, char *errbuf)",
          "fn_dec_pos": [
            [
              12,
              4
            ],
            [
              12,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "septel_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-tc.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "TcCreate(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              48,
              0
            ],
            [
              48,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcCreate",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TcFindAllDevs(pcap_if_list_t *devlistp, char *errbuf)",
          "fn_dec_pos": [
            [
              51,
              0
            ],
            [
              51,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TcFindAllDevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <TcApi.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-common.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "dlt_to_linktype(int dlt)",
          "fn_dec_pos": [
            [
              45,
              11
            ],
            [
              45,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dlt_to_linktype",
            "parameters": {
              "dlt": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "linktype_to_dlt(int linktype)",
          "fn_dec_pos": [
            [
              47,
              11
            ],
            [
              47,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "linktype_to_dlt",
            "parameters": {
              "linktype": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "swap_pseudo_headers(int linktype, struct pcap_pkthdr *hdr,\n    u_char *data)",
          "fn_dec_pos": [
            [
              49,
              12
            ],
            [
              50,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "swap_pseudo_headers",
            "parameters": {
              "linktype": "int",
              "hdr": "struct pcap_pkthdr",
              "data": "u_char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "max_snaplen_for_dlt(int dlt)",
          "fn_dec_pos": [
            [
              52,
              13
            ],
            [
              52,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "max_snaplen_for_dlt",
            "parameters": {
              "dlt": "int"
            },
            "return_type": "u_int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            49,
            46
          ],
          [
            49,
            64
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-netmap.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "pcap_netmap_create(const char *, char *, int *)",
          "fn_dec_pos": [
            [
              0,
              8
            ],
            [
              0,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_netmap_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_netmap_findalldevs(pcap_if_list_t *devlistp, char *errbuf)",
          "fn_dec_pos": [
            [
              1,
              4
            ],
            [
              1,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_netmap_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-dbus.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "dbus_create(const char *, char *, int *)",
          "fn_dec_pos": [
            [
              0,
              8
            ],
            [
              0,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dbus_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "dbus_findalldevs(pcap_if_list_t *devlistp, char *errbuf)",
          "fn_dec_pos": [
            [
              1,
              4
            ],
            [
              1,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dbus_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-bpf.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <pcap/bpf.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-int.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*activate_op_t)(pcap_t *)",
          "fn_dec_pos": [
            [
              116,
              12
            ],
            [
              116,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*can_set_rfmon_op_t)(pcap_t *)",
          "fn_dec_pos": [
            [
              117,
              12
            ],
            [
              117,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*read_op_t)(pcap_t *, int cnt, pcap_handler, u_char *)",
          "fn_dec_pos": [
            [
              118,
              12
            ],
            [
              118,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "cnt": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*next_packet_op_t)(pcap_t *, struct pcap_pkthdr *, u_char **)",
          "fn_dec_pos": [
            [
              119,
              12
            ],
            [
              119,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*inject_op_t)(pcap_t *, const void *, int)",
          "fn_dec_pos": [
            [
              120,
              12
            ],
            [
              120,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*save_current_filter_op_t)(pcap_t *, const char *)",
          "fn_dec_pos": [
            [
              121,
              13
            ],
            [
              121,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*setfilter_op_t)(pcap_t *, struct bpf_program *)",
          "fn_dec_pos": [
            [
              122,
              12
            ],
            [
              122,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*setdirection_op_t)(pcap_t *, pcap_direction_t)",
          "fn_dec_pos": [
            [
              123,
              12
            ],
            [
              123,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*set_datalink_op_t)(pcap_t *, int)",
          "fn_dec_pos": [
            [
              124,
              12
            ],
            [
              124,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*getnonblock_op_t)(pcap_t *)",
          "fn_dec_pos": [
            [
              125,
              12
            ],
            [
              125,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*setnonblock_op_t)(pcap_t *, int)",
          "fn_dec_pos": [
            [
              126,
              12
            ],
            [
              126,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*stats_op_t)(pcap_t *, struct pcap_stat *)",
          "fn_dec_pos": [
            [
              127,
              12
            ],
            [
              127,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*breakloop_op_t)(pcap_t *)",
          "fn_dec_pos": [
            [
              128,
              13
            ],
            [
              128,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*stats_ex_op_t)(pcap_t *, int *)",
          "fn_dec_pos": [
            [
              130,
              26
            ],
            [
              130,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "(*setbuff_op_t)(pcap_t *, int)",
          "fn_dec_pos": [
            [
              131,
              12
            ],
            [
              131,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*setmode_op_t)(pcap_t *, int)",
          "fn_dec_pos": [
            [
              132,
              12
            ],
            [
              132,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*setmintocopy_op_t)(pcap_t *, int)",
          "fn_dec_pos": [
            [
              133,
              12
            ],
            [
              133,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*getevent_op_t)(pcap_t *)",
          "fn_dec_pos": [
            [
              134,
              15
            ],
            [
              134,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "HANDLE"
          }
        },
        {
          "fn_code": "(*oid_get_request_op_t)(pcap_t *, bpf_u_int32, void *, size_t *)",
          "fn_dec_pos": [
            [
              135,
              12
            ],
            [
              135,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*oid_set_request_op_t)(pcap_t *, bpf_u_int32, const void *, size_t *)",
          "fn_dec_pos": [
            [
              136,
              12
            ],
            [
              136,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*sendqueue_transmit_op_t)(pcap_t *, pcap_send_queue *, int)",
          "fn_dec_pos": [
            [
              137,
              14
            ],
            [
              137,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "(*setuserbuffer_op_t)(pcap_t *, int)",
          "fn_dec_pos": [
            [
              138,
              12
            ],
            [
              138,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*live_dump_op_t)(pcap_t *, char *, int, int)",
          "fn_dec_pos": [
            [
              139,
              12
            ],
            [
              139,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*live_dump_ended_op_t)(pcap_t *, int)",
          "fn_dec_pos": [
            [
              140,
              12
            ],
            [
              140,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*get_airpcap_handle_op_t)(pcap_t *)",
          "fn_dec_pos": [
            [
              141,
              23
            ],
            [
              141,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "PAirpcapHandle"
          }
        },
        {
          "fn_code": "(*cleanup_op_t)(pcap_t *)",
          "fn_dec_pos": [
            [
              143,
              13
            ],
            [
              143,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_offline_read(pcap_t *, int, pcap_handler, u_char *)",
          "fn_dec_pos": [
            [
              384,
              4
            ],
            [
              384,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_offline_read",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_getnonblock_fd(pcap_t *)",
          "fn_dec_pos": [
            [
              400,
              4
            ],
            [
              400,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getnonblock_fd",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_setnonblock_fd(pcap_t *p, int)",
          "fn_dec_pos": [
            [
              401,
              4
            ],
            [
              401,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setnonblock_fd",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_create_interface(const char *, char *)",
          "fn_dec_pos": [
            [
              415,
              8
            ],
            [
              415,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_interface",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_create_common(char *, size_t)",
          "fn_dec_pos": [
            [
              416,
              8
            ],
            [
              416,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create_common",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_do_addexit(pcap_t *)",
          "fn_dec_pos": [
            [
              417,
              4
            ],
            [
              417,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_do_addexit",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_add_to_pcaps_to_close(pcap_t *)",
          "fn_dec_pos": [
            [
              418,
              5
            ],
            [
              418,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_add_to_pcaps_to_close",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_remove_from_pcaps_to_close(pcap_t *)",
          "fn_dec_pos": [
            [
              419,
              5
            ],
            [
              419,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_remove_from_pcaps_to_close",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_cleanup_live_common(pcap_t *)",
          "fn_dec_pos": [
            [
              420,
              5
            ],
            [
              420,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_cleanup_live_common",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_check_activated(pcap_t *)",
          "fn_dec_pos": [
            [
              421,
              4
            ],
            [
              421,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_check_activated",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_breakloop_common(pcap_t *)",
          "fn_dec_pos": [
            [
              422,
              5
            ],
            [
              422,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_breakloop_common",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*get_if_flags_func)(const char *, bpf_u_int32 *, char *)",
          "fn_dec_pos": [
            [
              447,
              12
            ],
            [
              447,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_platform_finddevs(pcap_if_list_t *, char *)",
          "fn_dec_pos": [
            [
              448,
              4
            ],
            [
              448,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_platform_finddevs",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_findalldevs_interfaces(pcap_if_list_t *, char *,\n\t    int (*)(const char *), get_if_flags_func)",
          "fn_dec_pos": [
            [
              450,
              4
            ],
            [
              451,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_findalldevs_interfaces",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "find_or_add_dev(pcap_if_list_t *, const char *, bpf_u_int32,\n\t    get_if_flags_func, const char *, char *)",
          "fn_dec_pos": [
            [
              453,
              11
            ],
            [
              454,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_or_add_dev",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "find_dev(pcap_if_list_t *, const char *)",
          "fn_dec_pos": [
            [
              455,
              11
            ],
            [
              455,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_dev",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "add_dev(pcap_if_list_t *, const char *, bpf_u_int32, const char *,\n\t    char *)",
          "fn_dec_pos": [
            [
              456,
              11
            ],
            [
              457,
              12
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_dev",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "add_addr_to_dev(pcap_if_t *, struct sockaddr *, size_t,\n\t    struct sockaddr *, size_t, struct sockaddr *, size_t,\n\t    struct sockaddr *dstaddr, size_t, char *errbuf)",
          "fn_dec_pos": [
            [
              458,
              4
            ],
            [
              460,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_addr_to_dev",
            "parameters": {
              "dstaddr": "struct sockaddr",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "find_or_add_if(pcap_if_list_t *, const char *, bpf_u_int32,\n\t    get_if_flags_func, char *)",
          "fn_dec_pos": [
            [
              462,
              11
            ],
            [
              463,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find_or_add_if",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "add_addr_to_if(pcap_if_list_t *, const char *, bpf_u_int32,\n\t    get_if_flags_func,\n\t    struct sockaddr *, size_t, struct sockaddr *, size_t,\n\t    struct sockaddr *, size_t, struct sockaddr *, size_t, char *)",
          "fn_dec_pos": [
            [
              464,
              4
            ],
            [
              467,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_addr_to_if",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_open_offline_common(char *ebuf, size_t size)",
          "fn_dec_pos": [
            [
              480,
              8
            ],
            [
              480,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_offline_common",
            "parameters": {
              "ebuf": "char",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "sf_cleanup(pcap_t *p)",
          "fn_dec_pos": [
            [
              481,
              5
            ],
            [
              481,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sf_cleanup",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_filter_with_aux_data(const struct bpf_insn *,\n    const u_char *, u_int, u_int, const struct bpf_aux_data *)",
          "fn_dec_pos": [
            [
              501,
              6
            ],
            [
              502,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_filter_with_aux_data",
            "parameters": {},
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "pcap_filter(const struct bpf_insn *, const u_char *, u_int, u_int)",
          "fn_dec_pos": [
            [
              507,
              6
            ],
            [
              507,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_filter",
            "parameters": {},
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "pcap_validate_filter(const struct bpf_insn *, int)",
          "fn_dec_pos": [
            [
              512,
              4
            ],
            [
              512,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_validate_filter",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_oneshot(u_char *, const struct pcap_pkthdr *, const u_char *)",
          "fn_dec_pos": [
            [
              521,
              5
            ],
            [
              521,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_oneshot",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "install_bpf_program(pcap_t *, struct bpf_program *)",
          "fn_dec_pos": [
            [
              523,
              4
            ],
            [
              523,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "install_bpf_program",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_strcasecmp(const char *, const char *)",
          "fn_dec_pos": [
            [
              525,
              4
            ],
            [
              525,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_strcasecmp",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_createsrcstr_ex(char *, int, const char *, const char *,\n    const char *, unsigned char, char *)",
          "fn_dec_pos": [
            [
              532,
              4
            ],
            [
              533,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_createsrcstr_ex",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_parsesrcstr_ex(const char *, int *, char *, char *,\n    char *, unsigned char *, char *)",
          "fn_dec_pos": [
            [
              534,
              4
            ],
            [
              535,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_parsesrcstr_ex",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_opt {\n\tchar\t*device;\n\tint\ttimeout;\t/* timeout for buffering */\n\tu_int\tbuffer_size;\n\tint\tpromisc;\n\tint\trfmon;\t\t/* monitor mode */\n\tint\timmediate;\t/* immediate mode - deliver packets as soon as they arrive */\n\tint\tnonblock;\t/* non-blocking mode - don't wait for packets to be delivered, return \"no packets available\" */\n\tint\ttstamp_type;\n\tint\ttstamp_precision;\n\n\t/*\n\t * Platform-dependent options.\n\t */\n#ifdef __linux__\n\tint\tprotocol;\t/* protocol to use when creating PF_PACKET socket */\n#endif\n#ifdef _WIN32\n\tint\tnocapture_local;/* disable NPF loopback */\n#endif\n}",
          {
            "*device": "char",
            "timeout": "int",
            "buffer_size": "u_int",
            "promisc": "int",
            "rfmon": "int",
            "immediate": "int",
            "nonblock": "int",
            "tstamp_type": "int",
            "tstamp_precision": "int",
            "protocol": "int",
            "nocapture_local": "int"
          },
          "pcap_opt",
          [
            94,
            0
          ],
          [
            114,
            1
          ]
        ],
        [
          "struct pcap {\n\t/*\n\t * Method to call to read packets on a live capture.\n\t */\n\tread_op_t read_op;\n\n\t/*\n\t * Method to call to read the next packet from a savefile.\n\t */\n\tnext_packet_op_t next_packet_op;\n\n#ifdef _WIN32\n\tHANDLE handle;\n#else\n\tint fd;\n#endif /* _WIN32 */\n\n\t/*\n\t * Read buffer.\n\t */\n\tu_int bufsize;\n\tvoid *buffer;\n\tu_char *bp;\n\tint cc;\n\n\tsig_atomic_t break_loop; /* flag set to force break from packet-reading loop */\n\n\tvoid *priv;\t\t/* private data for methods */\n\n#ifdef ENABLE_REMOTE\n\tstruct pcap_samp rmt_samp;\t/* parameters related to the sampling process. */\n#endif\n\n\tint swapped;\n\tFILE *rfile;\t\t/* null if live capture, non-null if savefile */\n\tu_int fddipad;\n\tstruct pcap *next;\t/* list of open pcaps that need stuff cleared on close */\n\n\t/*\n\t * File version number; meaningful only for a savefile, but we\n\t * keep it here so that apps that (mistakenly) ask for the\n\t * version numbers will get the same zero values that they\n\t * always did.\n\t */\n\tint version_major;\n\tint version_minor;\n\n\tint snapshot;\n\tint linktype;\t\t/* Network linktype */\n\tint linktype_ext;       /* Extended information stored in the linktype field of a file */\n\tint offset;\t\t/* offset for proper alignment */\n\tint activated;\t\t/* true if the capture is really started */\n\tint oldstyle;\t\t/* if we're opening with pcap_open_live() */\n\n\tstruct pcap_opt opt;\n\n\t/*\n\t * Place holder for pcap_next().\n\t */\n\tu_char *pkt;\n\n#ifdef _WIN32\n\tstruct pcap_stat stat;\t/* used for pcap_stats_ex() */\n#endif\n\n\t/* We're accepting only packets in this direction/these directions. */\n\tpcap_direction_t direction;\n\n\t/*\n\t * Flags to affect BPF code generation.\n\t */\n\tint bpf_codegen_flags;\n\n#if !defined(_WIN32) && !defined(MSDOS)\n\tint selectable_fd;\t/* FD on which select()/poll()/epoll_wait()/kevent()/etc. can be done */\n\n\t/*\n\t * In case there either is no selectable FD, or there is but\n\t * it doesn't necessarily work (e.g., if it doesn't get notified\n\t * if the packet capture timeout expires before the buffer\n\t * fills up), this points to a timeout that should be used\n\t * in select()/poll()/epoll_wait()/kevent() call.  The pcap_t should\n\t * be put into non-blocking mode, and, if the timeout expires on\n\t * the call, an attempt should be made to read packets from all\n\t * pcap_t's with a required timeout, and the code must be\n\t * prepared not to see any packets from the attempt.\n\t */\n\tstruct timeval *required_select_timeout;\n#endif\n\n\t/*\n\t * Placeholder for filter code if bpf not in kernel.\n\t */\n\tstruct bpf_program fcode;\n\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\n\tint dlt_count;\n\tu_int *dlt_list;\n\tint tstamp_type_count;\n\tu_int *tstamp_type_list;\n\tint tstamp_precision_count;\n\tu_int *tstamp_precision_list;\n\n\tstruct pcap_pkthdr pcap_header;\t/* This is needed for the pcap_next_ex() to work */\n\n\t/*\n\t * More methods.\n\t */\n\tactivate_op_t activate_op;\n\tcan_set_rfmon_op_t can_set_rfmon_op;\n\tinject_op_t inject_op;\n\tsave_current_filter_op_t save_current_filter_op;\n\tsetfilter_op_t setfilter_op;\n\tsetdirection_op_t setdirection_op;\n\tset_datalink_op_t set_datalink_op;\n\tgetnonblock_op_t getnonblock_op;\n\tsetnonblock_op_t setnonblock_op;\n\tstats_op_t stats_op;\n\tbreakloop_op_t breakloop_op;\n\n\t/*\n\t * Routine to use as callback for pcap_next()/pcap_next_ex().\n\t */\n\tpcap_handler oneshot_callback;\n\n#ifdef _WIN32\n\t/*\n\t * These are, at least currently, specific to the Win32 NPF\n\t * driver.\n\t */\n\tstats_ex_op_t stats_ex_op;\n\tsetbuff_op_t setbuff_op;\n\tsetmode_op_t setmode_op;\n\tsetmintocopy_op_t setmintocopy_op;\n\tgetevent_op_t getevent_op;\n\toid_get_request_op_t oid_get_request_op;\n\toid_set_request_op_t oid_set_request_op;\n\tsendqueue_transmit_op_t sendqueue_transmit_op;\n\tsetuserbuffer_op_t setuserbuffer_op;\n\tlive_dump_op_t live_dump_op;\n\tlive_dump_ended_op_t live_dump_ended_op;\n\tget_airpcap_handle_op_t get_airpcap_handle_op;\n#endif\n\tcleanup_op_t cleanup_op;\n}",
          {
            "read_op": "read_op_t",
            "next_packet_op": "next_packet_op_t",
            "handle": "HANDLE",
            "fd": "int",
            "bufsize": "u_int",
            "*buffer": "void",
            "*bp": "u_char",
            "cc": "int",
            "break_loop": "sig_atomic_t",
            "*priv": "void",
            "rmt_samp": "struct pcap_samp",
            "swapped": "int",
            "*rfile": "FILE",
            "fddipad": "u_int",
            "*next": "struct pcap",
            "version_major": "int",
            "version_minor": "int",
            "snapshot": "int",
            "linktype": "int",
            "linktype_ext": "int",
            "offset": "int",
            "activated": "int",
            "oldstyle": "int",
            "opt": "struct pcap_opt",
            "*pkt": "u_char",
            "stat": "struct pcap_stat",
            "direction": "pcap_direction_t",
            "bpf_codegen_flags": "int",
            "selectable_fd": "int",
            "*required_select_timeout": "struct timeval",
            "fcode": "struct bpf_program",
            "errbuf[PCAP_ERRBUF_SIZE + 1]": "char",
            "dlt_count": "int",
            "*dlt_list": "u_int",
            "tstamp_type_count": "int",
            "*tstamp_type_list": "u_int",
            "tstamp_precision_count": "int",
            "*tstamp_precision_list": "u_int",
            "pcap_header": "struct pcap_pkthdr",
            "activate_op": "activate_op_t",
            "can_set_rfmon_op": "can_set_rfmon_op_t",
            "inject_op": "inject_op_t",
            "save_current_filter_op": "save_current_filter_op_t",
            "setfilter_op": "setfilter_op_t",
            "setdirection_op": "setdirection_op_t",
            "set_datalink_op": "set_datalink_op_t",
            "getnonblock_op": "getnonblock_op_t",
            "setnonblock_op": "setnonblock_op_t",
            "stats_op": "stats_op_t",
            "breakloop_op": "breakloop_op_t",
            "oneshot_callback": "pcap_handler",
            "stats_ex_op": "stats_ex_op_t",
            "setbuff_op": "setbuff_op_t",
            "setmode_op": "setmode_op_t",
            "setmintocopy_op": "setmintocopy_op_t",
            "getevent_op": "getevent_op_t",
            "oid_get_request_op": "oid_get_request_op_t",
            "oid_set_request_op": "oid_set_request_op_t",
            "sendqueue_transmit_op": "sendqueue_transmit_op_t",
            "setuserbuffer_op": "setuserbuffer_op_t",
            "live_dump_op": "live_dump_op_t",
            "live_dump_ended_op": "live_dump_ended_op_t",
            "get_airpcap_handle_op": "get_airpcap_handle_op_t",
            "cleanup_op": "cleanup_op_t"
          },
          "pcap",
          [
            149,
            0
          ],
          [
            293,
            1
          ]
        ],
        [
          "struct pcap_timeval {\n    bpf_int32 tv_sec;\t\t/* seconds */\n    bpf_int32 tv_usec;\t\t/* microseconds */\n}",
          {
            "tv_sec": "bpf_int32",
            "tv_usec": "bpf_int32"
          },
          "pcap_timeval",
          [
            310,
            0
          ],
          [
            313,
            1
          ]
        ],
        [
          "struct pcap_sf_pkthdr {\n    struct pcap_timeval ts;\t/* time stamp */\n    bpf_u_int32 caplen;\t\t/* length of portion present */\n    bpf_u_int32 len;\t\t/* length this packet (off wire) */\n}",
          {
            "ts": "struct pcap_timeval",
            "caplen": "bpf_u_int32",
            "len": "bpf_u_int32"
          },
          "pcap_sf_pkthdr",
          [
            345,
            0
          ],
          [
            349,
            1
          ]
        ],
        [
          "struct pcap_sf_patched_pkthdr {\n    struct pcap_timeval ts;\t/* time stamp */\n    bpf_u_int32 caplen;\t\t/* length of portion present */\n    bpf_u_int32 len;\t\t/* length this packet (off wire) */\n    int\t\tindex;\n    unsigned short protocol;\n    unsigned char pkt_type;\n}",
          {
            "ts": "struct pcap_timeval",
            "caplen": "bpf_u_int32",
            "len": "bpf_u_int32",
            "index": "int",
            "protocol": "unsigned short",
            "pkt_type": "unsigned char"
          },
          "pcap_sf_patched_pkthdr",
          [
            361,
            0
          ],
          [
            368,
            1
          ]
        ],
        [
          "struct oneshot_userdata {\n\tstruct pcap_pkthdr *hdr;\n\tconst u_char **pkt;\n\tpcap_t *pd;\n}",
          {
            "*hdr": "struct pcap_pkthdr",
            "u_char": "const",
            "*pd": "pcap_t"
          },
          "oneshot_userdata",
          [
            374,
            0
          ],
          [
            378,
            1
          ]
        ],
        [
          "struct bpf_aux_data {\n\tu_short vlan_tag_present;\n\tu_short vlan_tag;\n}",
          {
            "vlan_tag_present": "u_short",
            "vlan_tag": "u_short"
          },
          "bpf_aux_data",
          [
            492,
            0
          ],
          [
            495,
            1
          ]
        ],
        [
          "struct pcap_opt {\n\tchar\t*device;\n\tint\ttimeout;\t/* timeout for buffering */\n\tu_int\tbuffer_size;\n\tint\tpromisc;\n\tint\trfmon;\t\t/* monitor mode */\n\tint\timmediate;\t/* immediate mode - deliver packets as soon as they arrive */\n\tint\tnonblock;\t/* non-blocking mode - don't wait for packets to be delivered, return \"no packets available\" */\n\tint\ttstamp_type;\n\tint\ttstamp_precision;\n\n\t/*\n\t * Platform-dependent options.\n\t */\n#ifdef __linux__\n\tint\tprotocol;\t/* protocol to use when creating PF_PACKET socket */\n#endif\n#ifdef _WIN32\n\tint\tnocapture_local;/* disable NPF loopback */\n#endif\n}",
          {
            "*device": "char",
            "timeout": "int",
            "buffer_size": "u_int",
            "promisc": "int",
            "rfmon": "int",
            "immediate": "int",
            "nonblock": "int",
            "tstamp_type": "int",
            "tstamp_precision": "int",
            "protocol": "int",
            "nocapture_local": "int"
          },
          "pcap_opt",
          [
            94,
            0
          ],
          [
            114,
            1
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            119,
            42
          ],
          [
            119,
            60
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            122,
            40
          ],
          [
            122,
            58
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            127,
            36
          ],
          [
            127,
            52
          ]
        ],
        [
          "typedef struct pcap_stat *(*stats_ex_op_t)(pcap_t *, int *);",
          {},
          "stats_ex_op_t",
          [
            130,
            0
          ],
          [
            130,
            60
          ]
        ],
        [
          "typedef struct pcap_stat *(*stats_ex_op_t)(pcap_t *, int *);",
          {},
          "pcap_t",
          [
            130,
            0
          ],
          [
            130,
            60
          ]
        ],
        [
          "struct pcap {\n\t/*\n\t * Method to call to read packets on a live capture.\n\t */\n\tread_op_t read_op;\n\n\t/*\n\t * Method to call to read the next packet from a savefile.\n\t */\n\tnext_packet_op_t next_packet_op;\n\n#ifdef _WIN32\n\tHANDLE handle;\n#else\n\tint fd;\n#endif /* _WIN32 */\n\n\t/*\n\t * Read buffer.\n\t */\n\tu_int bufsize;\n\tvoid *buffer;\n\tu_char *bp;\n\tint cc;\n\n\tsig_atomic_t break_loop; /* flag set to force break from packet-reading loop */\n\n\tvoid *priv;\t\t/* private data for methods */\n\n#ifdef ENABLE_REMOTE\n\tstruct pcap_samp rmt_samp;\t/* parameters related to the sampling process. */\n#endif\n\n\tint swapped;\n\tFILE *rfile;\t\t/* null if live capture, non-null if savefile */\n\tu_int fddipad;\n\tstruct pcap *next;\t/* list of open pcaps that need stuff cleared on close */\n\n\t/*\n\t * File version number; meaningful only for a savefile, but we\n\t * keep it here so that apps that (mistakenly) ask for the\n\t * version numbers will get the same zero values that they\n\t * always did.\n\t */\n\tint version_major;\n\tint version_minor;\n\n\tint snapshot;\n\tint linktype;\t\t/* Network linktype */\n\tint linktype_ext;       /* Extended information stored in the linktype field of a file */\n\tint offset;\t\t/* offset for proper alignment */\n\tint activated;\t\t/* true if the capture is really started */\n\tint oldstyle;\t\t/* if we're opening with pcap_open_live() */\n\n\tstruct pcap_opt opt;\n\n\t/*\n\t * Place holder for pcap_next().\n\t */\n\tu_char *pkt;\n\n#ifdef _WIN32\n\tstruct pcap_stat stat;\t/* used for pcap_stats_ex() */\n#endif\n\n\t/* We're accepting only packets in this direction/these directions. */\n\tpcap_direction_t direction;\n\n\t/*\n\t * Flags to affect BPF code generation.\n\t */\n\tint bpf_codegen_flags;\n\n#if !defined(_WIN32) && !defined(MSDOS)\n\tint selectable_fd;\t/* FD on which select()/poll()/epoll_wait()/kevent()/etc. can be done */\n\n\t/*\n\t * In case there either is no selectable FD, or there is but\n\t * it doesn't necessarily work (e.g., if it doesn't get notified\n\t * if the packet capture timeout expires before the buffer\n\t * fills up), this points to a timeout that should be used\n\t * in select()/poll()/epoll_wait()/kevent() call.  The pcap_t should\n\t * be put into non-blocking mode, and, if the timeout expires on\n\t * the call, an attempt should be made to read packets from all\n\t * pcap_t's with a required timeout, and the code must be\n\t * prepared not to see any packets from the attempt.\n\t */\n\tstruct timeval *required_select_timeout;\n#endif\n\n\t/*\n\t * Placeholder for filter code if bpf not in kernel.\n\t */\n\tstruct bpf_program fcode;\n\n\tchar errbuf[PCAP_ERRBUF_SIZE + 1];\n\tint dlt_count;\n\tu_int *dlt_list;\n\tint tstamp_type_count;\n\tu_int *tstamp_type_list;\n\tint tstamp_precision_count;\n\tu_int *tstamp_precision_list;\n\n\tstruct pcap_pkthdr pcap_header;\t/* This is needed for the pcap_next_ex() to work */\n\n\t/*\n\t * More methods.\n\t */\n\tactivate_op_t activate_op;\n\tcan_set_rfmon_op_t can_set_rfmon_op;\n\tinject_op_t inject_op;\n\tsave_current_filter_op_t save_current_filter_op;\n\tsetfilter_op_t setfilter_op;\n\tsetdirection_op_t setdirection_op;\n\tset_datalink_op_t set_datalink_op;\n\tgetnonblock_op_t getnonblock_op;\n\tsetnonblock_op_t setnonblock_op;\n\tstats_op_t stats_op;\n\tbreakloop_op_t breakloop_op;\n\n\t/*\n\t * Routine to use as callback for pcap_next()/pcap_next_ex().\n\t */\n\tpcap_handler oneshot_callback;\n\n#ifdef _WIN32\n\t/*\n\t * These are, at least currently, specific to the Win32 NPF\n\t * driver.\n\t */\n\tstats_ex_op_t stats_ex_op;\n\tsetbuff_op_t setbuff_op;\n\tsetmode_op_t setmode_op;\n\tsetmintocopy_op_t setmintocopy_op;\n\tgetevent_op_t getevent_op;\n\toid_get_request_op_t oid_get_request_op;\n\toid_set_request_op_t oid_set_request_op;\n\tsendqueue_transmit_op_t sendqueue_transmit_op;\n\tsetuserbuffer_op_t setuserbuffer_op;\n\tlive_dump_op_t live_dump_op;\n\tlive_dump_ended_op_t live_dump_ended_op;\n\tget_airpcap_handle_op_t get_airpcap_handle_op;\n#endif\n\tcleanup_op_t cleanup_op;\n}",
          {
            "read_op": "read_op_t",
            "next_packet_op": "next_packet_op_t",
            "handle": "HANDLE",
            "fd": "int",
            "bufsize": "u_int",
            "*buffer": "void",
            "*bp": "u_char",
            "cc": "int",
            "break_loop": "sig_atomic_t",
            "*priv": "void",
            "rmt_samp": "struct pcap_samp",
            "swapped": "int",
            "*rfile": "FILE",
            "fddipad": "u_int",
            "*next": "struct pcap",
            "version_major": "int",
            "version_minor": "int",
            "snapshot": "int",
            "linktype": "int",
            "linktype_ext": "int",
            "offset": "int",
            "activated": "int",
            "oldstyle": "int",
            "opt": "struct pcap_opt",
            "*pkt": "u_char",
            "stat": "struct pcap_stat",
            "direction": "pcap_direction_t",
            "bpf_codegen_flags": "int",
            "selectable_fd": "int",
            "*required_select_timeout": "struct timeval",
            "fcode": "struct bpf_program",
            "errbuf[PCAP_ERRBUF_SIZE + 1]": "char",
            "dlt_count": "int",
            "*dlt_list": "u_int",
            "tstamp_type_count": "int",
            "*tstamp_type_list": "u_int",
            "tstamp_precision_count": "int",
            "*tstamp_precision_list": "u_int",
            "pcap_header": "struct pcap_pkthdr",
            "activate_op": "activate_op_t",
            "can_set_rfmon_op": "can_set_rfmon_op_t",
            "inject_op": "inject_op_t",
            "save_current_filter_op": "save_current_filter_op_t",
            "setfilter_op": "setfilter_op_t",
            "setdirection_op": "setdirection_op_t",
            "set_datalink_op": "set_datalink_op_t",
            "getnonblock_op": "getnonblock_op_t",
            "setnonblock_op": "setnonblock_op_t",
            "stats_op": "stats_op_t",
            "breakloop_op": "breakloop_op_t",
            "oneshot_callback": "pcap_handler",
            "stats_ex_op": "stats_ex_op_t",
            "setbuff_op": "setbuff_op_t",
            "setmode_op": "setmode_op_t",
            "setmintocopy_op": "setmintocopy_op_t",
            "getevent_op": "getevent_op_t",
            "oid_get_request_op": "oid_get_request_op_t",
            "oid_set_request_op": "oid_set_request_op_t",
            "sendqueue_transmit_op": "sendqueue_transmit_op_t",
            "setuserbuffer_op": "setuserbuffer_op_t",
            "live_dump_op": "live_dump_op_t",
            "live_dump_ended_op": "live_dump_ended_op_t",
            "get_airpcap_handle_op": "get_airpcap_handle_op_t",
            "cleanup_op": "cleanup_op_t"
          },
          "pcap",
          [
            149,
            0
          ],
          [
            293,
            1
          ]
        ],
        [
          "struct pcap_samp",
          {},
          "",
          [
            179,
            1
          ],
          [
            179,
            17
          ]
        ],
        [
          "struct pcap",
          {},
          "",
          [
            185,
            1
          ],
          [
            185,
            12
          ]
        ],
        [
          "struct pcap_opt",
          {},
          "",
          [
            203,
            1
          ],
          [
            203,
            16
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            211,
            1
          ],
          [
            211,
            17
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            236,
            1
          ],
          [
            236,
            15
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            242,
            1
          ],
          [
            242,
            19
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            252,
            1
          ],
          [
            252,
            19
          ]
        ],
        [
          "struct pcap_timeval {\n    bpf_int32 tv_sec;\t\t/* seconds */\n    bpf_int32 tv_usec;\t\t/* microseconds */\n}",
          {
            "tv_sec": "bpf_int32",
            "tv_usec": "bpf_int32"
          },
          "pcap_timeval",
          [
            310,
            0
          ],
          [
            313,
            1
          ]
        ],
        [
          "struct pcap_sf_pkthdr {\n    struct pcap_timeval ts;\t/* time stamp */\n    bpf_u_int32 caplen;\t\t/* length of portion present */\n    bpf_u_int32 len;\t\t/* length this packet (off wire) */\n}",
          {
            "ts": "struct pcap_timeval",
            "caplen": "bpf_u_int32",
            "len": "bpf_u_int32"
          },
          "pcap_sf_pkthdr",
          [
            345,
            0
          ],
          [
            349,
            1
          ]
        ],
        [
          "struct pcap_timeval",
          {},
          "",
          [
            346,
            4
          ],
          [
            346,
            23
          ]
        ],
        [
          "struct pcap_sf_patched_pkthdr {\n    struct pcap_timeval ts;\t/* time stamp */\n    bpf_u_int32 caplen;\t\t/* length of portion present */\n    bpf_u_int32 len;\t\t/* length this packet (off wire) */\n    int\t\tindex;\n    unsigned short protocol;\n    unsigned char pkt_type;\n}",
          {
            "ts": "struct pcap_timeval",
            "caplen": "bpf_u_int32",
            "len": "bpf_u_int32",
            "index": "int",
            "protocol": "unsigned short",
            "pkt_type": "unsigned char"
          },
          "pcap_sf_patched_pkthdr",
          [
            361,
            0
          ],
          [
            368,
            1
          ]
        ],
        [
          "struct pcap_timeval",
          {},
          "",
          [
            362,
            4
          ],
          [
            362,
            23
          ]
        ],
        [
          "struct oneshot_userdata {\n\tstruct pcap_pkthdr *hdr;\n\tconst u_char **pkt;\n\tpcap_t *pd;\n}",
          {
            "*hdr": "struct pcap_pkthdr",
            "u_char": "const",
            "*pd": "pcap_t"
          },
          "oneshot_userdata",
          [
            374,
            0
          ],
          [
            378,
            1
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            375,
            1
          ],
          [
            375,
            19
          ]
        ],
        [
          "struct pcap_if_list",
          {},
          "",
          [
            445,
            0
          ],
          [
            445,
            19
          ]
        ],
        [
          "typedef struct pcap_if_list pcap_if_list_t;",
          {},
          "pcap_if_list_t",
          [
            446,
            0
          ],
          [
            446,
            43
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            458,
            33
          ],
          [
            458,
            48
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            459,
            5
          ],
          [
            459,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            459,
            32
          ],
          [
            459,
            47
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            460,
            5
          ],
          [
            460,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            466,
            5
          ],
          [
            466,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            466,
            32
          ],
          [
            466,
            47
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            467,
            5
          ],
          [
            467,
            20
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            467,
            32
          ],
          [
            467,
            47
          ]
        ],
        [
          "struct bpf_aux_data {\n\tu_short vlan_tag_present;\n\tu_short vlan_tag;\n}",
          {
            "vlan_tag_present": "u_short",
            "vlan_tag": "u_short"
          },
          "bpf_aux_data",
          [
            492,
            0
          ],
          [
            495,
            1
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            501,
            38
          ],
          [
            501,
            53
          ]
        ],
        [
          "struct bpf_aux_data",
          {},
          "",
          [
            502,
            40
          ],
          [
            502,
            59
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            507,
            24
          ],
          [
            507,
            39
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            512,
            31
          ],
          [
            512,
            46
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            521,
            34
          ],
          [
            521,
            52
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            523,
            34
          ],
          [
            523,
            52
          ]
        ]
      ],
      "include_list": [
        [
          "#include <signal.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <pcap/pcap.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include \"varattrs.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"fmtutils.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            54,
            2
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <io.h>\n",
          [
            55,
            2
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            386,
            0
          ],
          [
            387,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            388,
            0
          ],
          [
            389,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/nametoaddr.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "__pcap_atodn(const char *, bpf_u_int32 *)",
          "fn_dec_pos": [
            [
              41,
              4
            ],
            [
              41,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "__pcap_atodn",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "__pcap_atoin(const char *, bpf_u_int32 *)",
          "fn_dec_pos": [
            [
              42,
              4
            ],
            [
              42,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "__pcap_atoin",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "__pcap_nametodnaddr(const char *, u_short *)",
          "fn_dec_pos": [
            [
              43,
              4
            ],
            [
              43,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "__pcap_nametodnaddr",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-dos.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "get_rxbuf     (int len)",
          "fn_dec_pos": [
            [
              131,
              15
            ],
            [
              131,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_rxbuf",
            "parameters": {
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "peek_rxbuf    (BYTE **buf)",
          "fn_dec_pos": [
            [
              132,
              15
            ],
            [
              132,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "peek_rxbuf",
            "parameters": {
              "buf": "BYTE"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "release_rxbuf (BYTE  *buf)",
          "fn_dec_pos": [
            [
              133,
              15
            ],
            [
              133,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "release_rxbuf",
            "parameters": {
              "buf": "BYTE"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*probe)(struct device *dev)",
          "fn_dec_pos": [
            [
              153,
              15
            ],
            [
              153,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*open) (struct device *dev)",
          "fn_dec_pos": [
            [
              154,
              15
            ],
            [
              154,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*close)(struct device *dev)",
          "fn_dec_pos": [
            [
              155,
              15
            ],
            [
              155,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*xmit) (struct device *dev, const void *buf, int len)",
          "fn_dec_pos": [
            [
              156,
              15
            ],
            [
              156,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dev": "struct device",
              "buf": "void",
              "len": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*get_stats)(struct device *dev)",
          "fn_dec_pos": [
            [
              157,
              15
            ],
            [
              157,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*set_multicast_list)(struct device *dev)",
          "fn_dec_pos": [
            [
              158,
              15
            ],
            [
              158,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "dev": "struct device"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*copy_rx_buf) (BYTE *buf, int max)",
          "fn_dec_pos": [
            [
              161,
              15
            ],
            [
              161,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "buf": "BYTE",
              "max": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*get_rx_buf) (int len)",
          "fn_dec_pos": [
            [
              162,
              15
            ],
            [
              162,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*peek_rx_buf) (BYTE **buf)",
          "fn_dec_pos": [
            [
              163,
              15
            ],
            [
              163,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "buf": "BYTE"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*release_rx_buf) (BYTE *buf)",
          "fn_dec_pos": [
            [
              164,
              15
            ],
            [
              164,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "buf": "BYTE"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_w32_os_yield (void)",
          "fn_dec_pos": [
            [
              210,
              12
            ],
            [
              210,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_w32_os_yield",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_assert (const char *what, const char *file, unsigned line)",
          "fn_dec_pos": [
            [
              216,
              7
            ],
            [
              216,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_assert",
            "parameters": {
              "what": "char",
              "file": "char",
              "line": "unsigned"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct rx_ringbuf {\n         volatile int in_index;   /* queue index head */\n         int          out_index;  /* queue index tail */\n         int          elem_size;  /* size of each element */\n         int          num_elem;   /* number of elements */\n         char        *buf_start;  /* start of buffer pool */\n       }",
          {
            "int": "volatile",
            "out_index": "int",
            "elem_size": "int",
            "num_elem": "int",
            "*buf_start": "char"
          },
          "rx_ringbuf",
          [
            118,
            2
          ],
          [
            124,
            8
          ]
        ],
        [
          "struct rx_elem {\n         DWORD size;              /* size copied to this element */\n         BYTE  data[ETH_MAX+10];  /* add some margin. data[0] should be */\n       }",
          {
            "size": "DWORD",
            "data[ETH_MAX+10]": "BYTE"
          },
          "rx_elem",
          [
            126,
            2
          ],
          [
            129,
            8
          ]
        ],
        [
          "struct device {\n         const char *name;\n         const char *long_name;\n         DWORD  base_addr;      /* device I/O address       */\n         int    irq;            /* device IRQ number        */\n         int    dma;            /* DMA channel              */\n         DWORD  mem_start;      /* shared mem start         */\n         DWORD  mem_end;        /* shared mem end           */\n         DWORD  rmem_start;     /* shmem \"recv\" start       */\n         DWORD  rmem_end;       /* shared \"recv\" end        */\n\n         struct device *next;   /* next device in list      */\n\n         /* interface service routines */\n         int   (*probe)(struct device *dev);\n         int   (*open) (struct device *dev);\n         void  (*close)(struct device *dev);\n         int   (*xmit) (struct device *dev, const void *buf, int len);\n         void *(*get_stats)(struct device *dev);\n         void  (*set_multicast_list)(struct device *dev);\n\n         /* driver-to-pcap receive buffer routines */\n         int   (*copy_rx_buf) (BYTE *buf, int max); /* rx-copy (pktdrvr only) */\n         BYTE *(*get_rx_buf) (int len);             /* rx-buf fetch/enqueue */\n         int   (*peek_rx_buf) (BYTE **buf);         /* rx-non-copy at queue */\n         int   (*release_rx_buf) (BYTE *buf);       /* release after peek */\n\n         WORD   flags;          /* Low-level status flags. */\n         void  *priv;           /* private data */\n       }",
          {
            "char": "const",
            "base_addr": "DWORD",
            "irq": "int",
            "dma": "int",
            "mem_start": "DWORD",
            "mem_end": "DWORD",
            "rmem_start": "DWORD",
            "rmem_end": "DWORD",
            "*next": "struct device",
            "(*probe)(struct device *dev)": "int",
            "(*open) (struct device *dev)": "int",
            "(*close)(struct device *dev)": "void",
            "(*xmit) (struct device *dev, const void *buf, int len)": "int",
            "*(*get_stats)(struct device *dev)": "void",
            "(*set_multicast_list)(struct device *dev)": "void",
            "(*copy_rx_buf) (BYTE *buf, int max)": "int",
            "*(*get_rx_buf) (int len)": "BYTE",
            "(*peek_rx_buf) (BYTE **buf)": "int",
            "(*release_rx_buf) (BYTE *buf)": "int",
            "flags": "WORD",
            "*priv": "void"
          },
          "device",
          [
            139,
            2
          ],
          [
            168,
            8
          ]
        ],
        [
          "typedef struct net_device_stats {\n          DWORD  rx_packets;            /* total packets received       */\n          DWORD  tx_packets;            /* total packets transmitted    */\n          DWORD  rx_bytes;              /* total bytes received         */\n          DWORD  tx_bytes;              /* total bytes transmitted      */\n          DWORD  rx_errors;             /* bad packets received         */\n          DWORD  tx_errors;             /* packet transmit problems     */\n          DWORD  rx_dropped;            /* no space in Rx buffers       */\n          DWORD  tx_dropped;            /* no space available for Tx    */\n          DWORD  multicast;             /* multicast packets received   */\n\n          /* detailed rx_errors: */\n          DWORD  rx_length_errors;\n          DWORD  rx_over_errors;        /* recv'r overrun error         */\n          DWORD  rx_osize_errors;       /* recv'r over-size error       */\n          DWORD  rx_crc_errors;         /* recv'd pkt with crc error    */\n          DWORD  rx_frame_errors;       /* recv'd frame alignment error */\n          DWORD  rx_fifo_errors;        /* recv'r fifo overrun          */\n          DWORD  rx_missed_errors;      /* recv'r missed packet         */\n\n          /* detailed tx_errors */\n          DWORD  tx_aborted_errors;\n          DWORD  tx_carrier_errors;\n          DWORD  tx_fifo_errors;\n          DWORD  tx_heartbeat_errors;\n          DWORD  tx_window_errors;\n          DWORD  tx_collisions;\n          DWORD  tx_jabbers;\n        } NET_STATS;",
          {
            "rx_packets": "DWORD",
            "tx_packets": "DWORD",
            "rx_bytes": "DWORD",
            "tx_bytes": "DWORD",
            "rx_errors": "DWORD",
            "tx_errors": "DWORD",
            "rx_dropped": "DWORD",
            "tx_dropped": "DWORD",
            "multicast": "DWORD",
            "rx_length_errors": "DWORD",
            "rx_over_errors": "DWORD",
            "rx_osize_errors": "DWORD",
            "rx_crc_errors": "DWORD",
            "rx_frame_errors": "DWORD",
            "rx_fifo_errors": "DWORD",
            "rx_missed_errors": "DWORD",
            "tx_aborted_errors": "DWORD",
            "tx_carrier_errors": "DWORD",
            "tx_fifo_errors": "DWORD",
            "tx_heartbeat_errors": "DWORD",
            "tx_window_errors": "DWORD",
            "tx_collisions": "DWORD",
            "tx_jabbers": "DWORD"
          },
          "NET_STATS",
          [
            173,
            2
          ],
          [
            201,
            20
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            106,
            9
          ],
          [
            106,
            22
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            107,
            9
          ],
          [
            107,
            22
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            108,
            9
          ],
          [
            108,
            22
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            109,
            9
          ],
          [
            109,
            22
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            110,
            9
          ],
          [
            110,
            22
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            111,
            9
          ],
          [
            111,
            22
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            112,
            9
          ],
          [
            112,
            22
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            113,
            9
          ],
          [
            113,
            22
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            114,
            9
          ],
          [
            114,
            22
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            115,
            9
          ],
          [
            115,
            22
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            116,
            9
          ],
          [
            116,
            22
          ]
        ],
        [
          "struct rx_ringbuf {\n         volatile int in_index;   /* queue index head */\n         int          out_index;  /* queue index tail */\n         int          elem_size;  /* size of each element */\n         int          num_elem;   /* number of elements */\n         char        *buf_start;  /* start of buffer pool */\n       }",
          {
            "int": "volatile",
            "out_index": "int",
            "elem_size": "int",
            "num_elem": "int",
            "*buf_start": "char"
          },
          "rx_ringbuf",
          [
            118,
            2
          ],
          [
            124,
            8
          ]
        ],
        [
          "struct rx_elem {\n         DWORD size;              /* size copied to this element */\n         BYTE  data[ETH_MAX+10];  /* add some margin. data[0] should be */\n       }",
          {
            "size": "DWORD",
            "data[ETH_MAX+10]": "BYTE"
          },
          "rx_elem",
          [
            126,
            2
          ],
          [
            129,
            8
          ]
        ],
        [
          "struct device {\n         const char *name;\n         const char *long_name;\n         DWORD  base_addr;      /* device I/O address       */\n         int    irq;            /* device IRQ number        */\n         int    dma;            /* DMA channel              */\n         DWORD  mem_start;      /* shared mem start         */\n         DWORD  mem_end;        /* shared mem end           */\n         DWORD  rmem_start;     /* shmem \"recv\" start       */\n         DWORD  rmem_end;       /* shared \"recv\" end        */\n\n         struct device *next;   /* next device in list      */\n\n         /* interface service routines */\n         int   (*probe)(struct device *dev);\n         int   (*open) (struct device *dev);\n         void  (*close)(struct device *dev);\n         int   (*xmit) (struct device *dev, const void *buf, int len);\n         void *(*get_stats)(struct device *dev);\n         void  (*set_multicast_list)(struct device *dev);\n\n         /* driver-to-pcap receive buffer routines */\n         int   (*copy_rx_buf) (BYTE *buf, int max); /* rx-copy (pktdrvr only) */\n         BYTE *(*get_rx_buf) (int len);             /* rx-buf fetch/enqueue */\n         int   (*peek_rx_buf) (BYTE **buf);         /* rx-non-copy at queue */\n         int   (*release_rx_buf) (BYTE *buf);       /* release after peek */\n\n         WORD   flags;          /* Low-level status flags. */\n         void  *priv;           /* private data */\n       }",
          {
            "char": "const",
            "base_addr": "DWORD",
            "irq": "int",
            "dma": "int",
            "mem_start": "DWORD",
            "mem_end": "DWORD",
            "rmem_start": "DWORD",
            "rmem_end": "DWORD",
            "*next": "struct device",
            "(*probe)(struct device *dev)": "int",
            "(*open) (struct device *dev)": "int",
            "(*close)(struct device *dev)": "void",
            "(*xmit) (struct device *dev, const void *buf, int len)": "int",
            "*(*get_stats)(struct device *dev)": "void",
            "(*set_multicast_list)(struct device *dev)": "void",
            "(*copy_rx_buf) (BYTE *buf, int max)": "int",
            "*(*get_rx_buf) (int len)": "BYTE",
            "(*peek_rx_buf) (BYTE **buf)": "int",
            "(*release_rx_buf) (BYTE *buf)": "int",
            "flags": "WORD",
            "*priv": "void"
          },
          "device",
          [
            139,
            2
          ],
          [
            168,
            8
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            150,
            9
          ],
          [
            150,
            22
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            153,
            24
          ],
          [
            153,
            37
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            154,
            24
          ],
          [
            154,
            37
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            155,
            24
          ],
          [
            155,
            37
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            156,
            24
          ],
          [
            156,
            37
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            157,
            28
          ],
          [
            157,
            41
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            158,
            37
          ],
          [
            158,
            50
          ]
        ],
        [
          "typedef struct net_device_stats {\n          DWORD  rx_packets;            /* total packets received       */\n          DWORD  tx_packets;            /* total packets transmitted    */\n          DWORD  rx_bytes;              /* total bytes received         */\n          DWORD  tx_bytes;              /* total bytes transmitted      */\n          DWORD  rx_errors;             /* bad packets received         */\n          DWORD  tx_errors;             /* packet transmit problems     */\n          DWORD  rx_dropped;            /* no space in Rx buffers       */\n          DWORD  tx_dropped;            /* no space available for Tx    */\n          DWORD  multicast;             /* multicast packets received   */\n\n          /* detailed rx_errors: */\n          DWORD  rx_length_errors;\n          DWORD  rx_over_errors;        /* recv'r overrun error         */\n          DWORD  rx_osize_errors;       /* recv'r over-size error       */\n          DWORD  rx_crc_errors;         /* recv'd pkt with crc error    */\n          DWORD  rx_frame_errors;       /* recv'd frame alignment error */\n          DWORD  rx_fifo_errors;        /* recv'r fifo overrun          */\n          DWORD  rx_missed_errors;      /* recv'r missed packet         */\n\n          /* detailed tx_errors */\n          DWORD  tx_aborted_errors;\n          DWORD  tx_carrier_errors;\n          DWORD  tx_fifo_errors;\n          DWORD  tx_heartbeat_errors;\n          DWORD  tx_window_errors;\n          DWORD  tx_collisions;\n          DWORD  tx_jabbers;\n        } NET_STATS;",
          {
            "rx_packets": "DWORD",
            "tx_packets": "DWORD",
            "rx_bytes": "DWORD",
            "tx_bytes": "DWORD",
            "rx_errors": "DWORD",
            "tx_errors": "DWORD",
            "rx_dropped": "DWORD",
            "tx_dropped": "DWORD",
            "multicast": "DWORD",
            "rx_length_errors": "DWORD",
            "rx_over_errors": "DWORD",
            "rx_osize_errors": "DWORD",
            "rx_crc_errors": "DWORD",
            "rx_frame_errors": "DWORD",
            "rx_fifo_errors": "DWORD",
            "rx_missed_errors": "DWORD",
            "tx_aborted_errors": "DWORD",
            "tx_carrier_errors": "DWORD",
            "tx_fifo_errors": "DWORD",
            "tx_heartbeat_errors": "DWORD",
            "tx_window_errors": "DWORD",
            "tx_collisions": "DWORD",
            "tx_jabbers": "DWORD"
          },
          "NET_STATS",
          [
            173,
            2
          ],
          [
            201,
            20
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            204,
            7
          ],
          [
            204,
            20
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            205,
            13
          ],
          [
            205,
            26
          ]
        ],
        [
          "struct device",
          {},
          "",
          [
            206,
            7
          ],
          [
            206,
            20
          ]
        ]
      ],
      "include_list": [
        [
          "#include <pc.h>    /* simple non-conio kbhit */\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <conio.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <pharlap.h>\n",
          [
            46,
            2
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include \"msdos/pm_drvr/lock.h\"\n",
          [
            96,
            2
          ],
          [
            97,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/rpcap-protocol.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "rpcap_createhdr(struct rpcap_header *header, uint8 ver, uint8 type, uint16 value, uint32 length)",
          "fn_dec_pos": [
            [
              423,
              12
            ],
            [
              423,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_createhdr",
            "parameters": {
              "header": "struct rpcap_header",
              "ver": "uint8",
              "type": "uint8",
              "value": "uint16",
              "length": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "rpcap_msg_type_string(uint8 type)",
          "fn_dec_pos": [
            [
              424,
              19
            ],
            [
              424,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_msg_type_string",
            "parameters": {
              "type": "uint8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "rpcap_senderror(SOCKET sock, SSL *ssl, uint8 ver, uint16 errcode, const char *error, char *errbuf)",
          "fn_dec_pos": [
            [
              425,
              11
            ],
            [
              425,
              109
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_senderror",
            "parameters": {
              "sock": "SOCKET",
              "ssl": "SSL",
              "ver": "uint8",
              "errcode": "uint16",
              "error": "char",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct rpcap_header\n{\n\tuint8 ver;\t/* RPCAP version number */\n\tuint8 type;\t/* RPCAP message type (error, findalldevs, ...) */\n\tuint16 value;\t/* Message-dependent value (not always used) */\n\tuint32 plen;\t/* Length of the payload of this RPCAP message */\n}",
          {
            "ver": "uint8",
            "type": "uint8",
            "value": "uint16",
            "plen": "uint32"
          },
          "rpcap_header",
          [
            140,
            0
          ],
          [
            146,
            1
          ]
        ],
        [
          "struct rpcap_authreply\n{\n\tuint8 minvers;\t/* Minimum version supported */\n\tuint8 maxvers;\t/* Maximum version supported */\n}",
          {
            "minvers": "uint8",
            "maxvers": "uint8"
          },
          "rpcap_authreply",
          [
            155,
            0
          ],
          [
            159,
            1
          ]
        ],
        [
          "struct rpcap_findalldevs_if\n{\n\tuint16 namelen;\t/* Length of the interface name */\n\tuint16 desclen;\t/* Length of the interface description */\n\tuint32 flags;\t/* Interface flags */\n\tuint16 naddr;\t/* Number of addresses */\n\tuint16 dummy;\t/* Must be zero */\n}",
          {
            "namelen": "uint16",
            "desclen": "uint16",
            "flags": "uint32",
            "naddr": "uint16",
            "dummy": "uint16"
          },
          "rpcap_findalldevs_if",
          [
            162,
            0
          ],
          [
            169,
            1
          ]
        ],
        [
          "struct rpcap_sockaddr\n{\n\tuint16\tfamily;\t\t\t/* Address family */\n\tchar\tdata[128-2];\t\t/* Data */\n}",
          {
            "family": "uint16",
            "data[128-2]": "char"
          },
          "rpcap_sockaddr",
          [
            213,
            0
          ],
          [
            217,
            1
          ]
        ],
        [
          "struct rpcap_sockaddr_in\n{\n\tuint16\tfamily;\t\t\t/* Address family */\n\tuint16\tport;\t\t\t/* Port number */\n\tuint32\taddr;\t\t\t/* IPv4 address */\n\tuint8\tzero[8];\t\t/* Padding */\n}",
          {
            "family": "uint16",
            "port": "uint16",
            "addr": "uint32",
            "zero[8]": "uint8"
          },
          "rpcap_sockaddr_in",
          [
            223,
            0
          ],
          [
            229,
            1
          ]
        ],
        [
          "struct rpcap_sockaddr_in6\n{\n\tuint16\tfamily;\t\t\t/* Address family */\n\tuint16\tport;\t\t\t/* Port number */\n\tuint32\tflowinfo;\t\t/* IPv6 flow information */\n\tuint8\taddr[16];\t\t/* IPv6 address */\n\tuint32\tscope_id;\t\t/* Scope zone index */\n}",
          {
            "family": "uint16",
            "port": "uint16",
            "flowinfo": "uint32",
            "addr[16]": "uint8",
            "scope_id": "uint32"
          },
          "rpcap_sockaddr_in6",
          [
            235,
            0
          ],
          [
            242,
            1
          ]
        ],
        [
          "struct rpcap_findalldevs_ifaddr\n{\n\tstruct rpcap_sockaddr addr;\t\t/* Network address */\n\tstruct rpcap_sockaddr netmask;\t\t/* Netmask for that address */\n\tstruct rpcap_sockaddr broadaddr;\t/* Broadcast address for that address */\n\tstruct rpcap_sockaddr dstaddr;\t\t/* P2P destination address for that address */\n}",
          {
            "addr": "struct rpcap_sockaddr",
            "netmask": "struct rpcap_sockaddr",
            "broadaddr": "struct rpcap_sockaddr",
            "dstaddr": "struct rpcap_sockaddr"
          },
          "rpcap_findalldevs_ifaddr",
          [
            245,
            0
          ],
          [
            251,
            1
          ]
        ],
        [
          "struct rpcap_openreply\n{\n\tint32 linktype;\t/* Link type */\n\tint32 tzoff;\t/* Timezone offset - not used by newer clients */\n}",
          {
            "linktype": "int32",
            "tzoff": "int32"
          },
          "rpcap_openreply",
          [
            258,
            0
          ],
          [
            262,
            1
          ]
        ],
        [
          "struct rpcap_startcapreq\n{\n\tuint32 snaplen;\t\t/* Length of the snapshot (number of bytes to capture for each packet) */\n\tuint32 read_timeout;\t/* Read timeout in milliseconds */\n\tuint16 flags;\t\t/* Flags (see RPCAP_STARTCAPREQ_FLAG_xxx) */\n\tuint16 portdata;\t/* Network port on which the client is waiting at (if 'serveropen') */\n}",
          {
            "snaplen": "uint32",
            "read_timeout": "uint32",
            "flags": "uint16",
            "portdata": "uint16"
          },
          "rpcap_startcapreq",
          [
            265,
            0
          ],
          [
            271,
            1
          ]
        ],
        [
          "struct rpcap_startcapreply\n{\n\tint32 bufsize;\t\t/* Size of the user buffer allocated by WinPcap; it can be different from the one we chose */\n\tuint16 portdata;\t/* Network port on which the server is waiting at (passive mode only) */\n\tuint16 dummy;\t\t/* Must be zero */\n}",
          {
            "bufsize": "int32",
            "portdata": "uint16",
            "dummy": "uint16"
          },
          "rpcap_startcapreply",
          [
            274,
            0
          ],
          [
            279,
            1
          ]
        ],
        [
          "struct rpcap_pkthdr\n{\n\t/*\n\t * This protocol needs to be updated with a new version before\n\t * 2038-01-19 03:14:07 UTC.\n\t */\n\tuint32 timestamp_sec;\t/* 'struct timeval' compatible, it represents the 'tv_sec' field */\n\tuint32 timestamp_usec;\t/* 'struct timeval' compatible, it represents the 'tv_usec' field */\n\tuint32 caplen;\t\t/* Length of portion present in the capture */\n\tuint32 len;\t\t/* Real length this packet (off wire) */\n\tuint32 npkt;\t\t/* Ordinal number of the packet (i.e. the first one captured has '1', the second one '2', etc) */\n}",
          {
            "timestamp_sec": "uint32",
            "timestamp_usec": "uint32",
            "caplen": "uint32",
            "len": "uint32",
            "npkt": "uint32"
          },
          "rpcap_pkthdr",
          [
            287,
            0
          ],
          [
            298,
            1
          ]
        ],
        [
          "struct rpcap_filter\n{\n\tuint16 filtertype;\t/* type of the filter transferred (BPF instructions, ...) */\n\tuint16 dummy;\t\t/* Must be zero */\n\tuint32 nitems;\t\t/* Number of items contained into the filter (e.g. BPF instructions for BPF filters) */\n}",
          {
            "filtertype": "uint16",
            "dummy": "uint16",
            "nitems": "uint32"
          },
          "rpcap_filter",
          [
            301,
            0
          ],
          [
            306,
            1
          ]
        ],
        [
          "struct rpcap_filterbpf_insn\n{\n\tuint16 code;\t/* opcode of the instruction */\n\tuint8 jt;\t/* relative offset to jump to in case of 'true' */\n\tuint8 jf;\t/* relative offset to jump to in case of 'false' */\n\tint32 k;\t/* instruction-dependent value */\n}",
          {
            "code": "uint16",
            "jt": "uint8",
            "jf": "uint8",
            "k": "int32"
          },
          "rpcap_filterbpf_insn",
          [
            309,
            0
          ],
          [
            315,
            1
          ]
        ],
        [
          "struct rpcap_auth\n{\n\tuint16 type;\t/* Authentication type */\n\tuint16 dummy;\t/* Must be zero */\n\tuint16 slen1;\t/* Length of the first authentication item (e.g. username) */\n\tuint16 slen2;\t/* Length of the second authentication item (e.g. password) */\n}",
          {
            "type": "uint16",
            "dummy": "uint16",
            "slen1": "uint16",
            "slen2": "uint16"
          },
          "rpcap_auth",
          [
            318,
            0
          ],
          [
            324,
            1
          ]
        ],
        [
          "struct rpcap_stats\n{\n\tuint32 ifrecv;\t\t/* Packets received by the kernel filter (i.e. pcap_stats.ps_recv) */\n\tuint32 ifdrop;\t\t/* Packets dropped by the network interface (e.g. not enough buffers) (i.e. pcap_stats.ps_ifdrop) */\n\tuint32 krnldrop;\t/* Packets dropped by the kernel filter (i.e. pcap_stats.ps_drop) */\n\tuint32 svrcapt;\t\t/* Packets captured by the RPCAP daemon and sent on the network */\n}",
          {
            "ifrecv": "uint32",
            "ifdrop": "uint32",
            "krnldrop": "uint32",
            "svrcapt": "uint32"
          },
          "rpcap_stats",
          [
            327,
            0
          ],
          [
            333,
            1
          ]
        ],
        [
          "struct rpcap_sampling\n{\n\tuint8 method;\t/* Sampling method */\n\tuint8 dummy1;\t/* Must be zero */\n\tuint16 dummy2;\t/* Must be zero */\n\tuint32 value;\t/* Parameter related to the sampling method */\n}",
          {
            "method": "uint8",
            "dummy1": "uint8",
            "dummy2": "uint16",
            "value": "uint32"
          },
          "rpcap_sampling",
          [
            336,
            0
          ],
          [
            342,
            1
          ]
        ],
        [
          "struct rpcap_header\n{\n\tuint8 ver;\t/* RPCAP version number */\n\tuint8 type;\t/* RPCAP message type (error, findalldevs, ...) */\n\tuint16 value;\t/* Message-dependent value (not always used) */\n\tuint32 plen;\t/* Length of the payload of this RPCAP message */\n}",
          {
            "ver": "uint8",
            "type": "uint8",
            "value": "uint16",
            "plen": "uint32"
          },
          "rpcap_header",
          [
            140,
            0
          ],
          [
            146,
            1
          ]
        ],
        [
          "struct rpcap_authreply\n{\n\tuint8 minvers;\t/* Minimum version supported */\n\tuint8 maxvers;\t/* Maximum version supported */\n}",
          {
            "minvers": "uint8",
            "maxvers": "uint8"
          },
          "rpcap_authreply",
          [
            155,
            0
          ],
          [
            159,
            1
          ]
        ],
        [
          "struct rpcap_findalldevs_if\n{\n\tuint16 namelen;\t/* Length of the interface name */\n\tuint16 desclen;\t/* Length of the interface description */\n\tuint32 flags;\t/* Interface flags */\n\tuint16 naddr;\t/* Number of addresses */\n\tuint16 dummy;\t/* Must be zero */\n}",
          {
            "namelen": "uint16",
            "desclen": "uint16",
            "flags": "uint32",
            "naddr": "uint16",
            "dummy": "uint16"
          },
          "rpcap_findalldevs_if",
          [
            162,
            0
          ],
          [
            169,
            1
          ]
        ],
        [
          "struct rpcap_sockaddr\n{\n\tuint16\tfamily;\t\t\t/* Address family */\n\tchar\tdata[128-2];\t\t/* Data */\n}",
          {
            "family": "uint16",
            "data[128-2]": "char"
          },
          "rpcap_sockaddr",
          [
            213,
            0
          ],
          [
            217,
            1
          ]
        ],
        [
          "struct rpcap_sockaddr_in\n{\n\tuint16\tfamily;\t\t\t/* Address family */\n\tuint16\tport;\t\t\t/* Port number */\n\tuint32\taddr;\t\t\t/* IPv4 address */\n\tuint8\tzero[8];\t\t/* Padding */\n}",
          {
            "family": "uint16",
            "port": "uint16",
            "addr": "uint32",
            "zero[8]": "uint8"
          },
          "rpcap_sockaddr_in",
          [
            223,
            0
          ],
          [
            229,
            1
          ]
        ],
        [
          "struct rpcap_sockaddr_in6\n{\n\tuint16\tfamily;\t\t\t/* Address family */\n\tuint16\tport;\t\t\t/* Port number */\n\tuint32\tflowinfo;\t\t/* IPv6 flow information */\n\tuint8\taddr[16];\t\t/* IPv6 address */\n\tuint32\tscope_id;\t\t/* Scope zone index */\n}",
          {
            "family": "uint16",
            "port": "uint16",
            "flowinfo": "uint32",
            "addr[16]": "uint8",
            "scope_id": "uint32"
          },
          "rpcap_sockaddr_in6",
          [
            235,
            0
          ],
          [
            242,
            1
          ]
        ],
        [
          "struct rpcap_findalldevs_ifaddr\n{\n\tstruct rpcap_sockaddr addr;\t\t/* Network address */\n\tstruct rpcap_sockaddr netmask;\t\t/* Netmask for that address */\n\tstruct rpcap_sockaddr broadaddr;\t/* Broadcast address for that address */\n\tstruct rpcap_sockaddr dstaddr;\t\t/* P2P destination address for that address */\n}",
          {
            "addr": "struct rpcap_sockaddr",
            "netmask": "struct rpcap_sockaddr",
            "broadaddr": "struct rpcap_sockaddr",
            "dstaddr": "struct rpcap_sockaddr"
          },
          "rpcap_findalldevs_ifaddr",
          [
            245,
            0
          ],
          [
            251,
            1
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            247,
            1
          ],
          [
            247,
            22
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            248,
            1
          ],
          [
            248,
            22
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            249,
            1
          ],
          [
            249,
            22
          ]
        ],
        [
          "struct rpcap_sockaddr",
          {},
          "",
          [
            250,
            1
          ],
          [
            250,
            22
          ]
        ],
        [
          "struct rpcap_openreply\n{\n\tint32 linktype;\t/* Link type */\n\tint32 tzoff;\t/* Timezone offset - not used by newer clients */\n}",
          {
            "linktype": "int32",
            "tzoff": "int32"
          },
          "rpcap_openreply",
          [
            258,
            0
          ],
          [
            262,
            1
          ]
        ],
        [
          "struct rpcap_startcapreq\n{\n\tuint32 snaplen;\t\t/* Length of the snapshot (number of bytes to capture for each packet) */\n\tuint32 read_timeout;\t/* Read timeout in milliseconds */\n\tuint16 flags;\t\t/* Flags (see RPCAP_STARTCAPREQ_FLAG_xxx) */\n\tuint16 portdata;\t/* Network port on which the client is waiting at (if 'serveropen') */\n}",
          {
            "snaplen": "uint32",
            "read_timeout": "uint32",
            "flags": "uint16",
            "portdata": "uint16"
          },
          "rpcap_startcapreq",
          [
            265,
            0
          ],
          [
            271,
            1
          ]
        ],
        [
          "struct rpcap_startcapreply\n{\n\tint32 bufsize;\t\t/* Size of the user buffer allocated by WinPcap; it can be different from the one we chose */\n\tuint16 portdata;\t/* Network port on which the server is waiting at (passive mode only) */\n\tuint16 dummy;\t\t/* Must be zero */\n}",
          {
            "bufsize": "int32",
            "portdata": "uint16",
            "dummy": "uint16"
          },
          "rpcap_startcapreply",
          [
            274,
            0
          ],
          [
            279,
            1
          ]
        ],
        [
          "struct rpcap_pkthdr\n{\n\t/*\n\t * This protocol needs to be updated with a new version before\n\t * 2038-01-19 03:14:07 UTC.\n\t */\n\tuint32 timestamp_sec;\t/* 'struct timeval' compatible, it represents the 'tv_sec' field */\n\tuint32 timestamp_usec;\t/* 'struct timeval' compatible, it represents the 'tv_usec' field */\n\tuint32 caplen;\t\t/* Length of portion present in the capture */\n\tuint32 len;\t\t/* Real length this packet (off wire) */\n\tuint32 npkt;\t\t/* Ordinal number of the packet (i.e. the first one captured has '1', the second one '2', etc) */\n}",
          {
            "timestamp_sec": "uint32",
            "timestamp_usec": "uint32",
            "caplen": "uint32",
            "len": "uint32",
            "npkt": "uint32"
          },
          "rpcap_pkthdr",
          [
            287,
            0
          ],
          [
            298,
            1
          ]
        ],
        [
          "struct rpcap_filter\n{\n\tuint16 filtertype;\t/* type of the filter transferred (BPF instructions, ...) */\n\tuint16 dummy;\t\t/* Must be zero */\n\tuint32 nitems;\t\t/* Number of items contained into the filter (e.g. BPF instructions for BPF filters) */\n}",
          {
            "filtertype": "uint16",
            "dummy": "uint16",
            "nitems": "uint32"
          },
          "rpcap_filter",
          [
            301,
            0
          ],
          [
            306,
            1
          ]
        ],
        [
          "struct rpcap_filterbpf_insn\n{\n\tuint16 code;\t/* opcode of the instruction */\n\tuint8 jt;\t/* relative offset to jump to in case of 'true' */\n\tuint8 jf;\t/* relative offset to jump to in case of 'false' */\n\tint32 k;\t/* instruction-dependent value */\n}",
          {
            "code": "uint16",
            "jt": "uint8",
            "jf": "uint8",
            "k": "int32"
          },
          "rpcap_filterbpf_insn",
          [
            309,
            0
          ],
          [
            315,
            1
          ]
        ],
        [
          "struct rpcap_auth\n{\n\tuint16 type;\t/* Authentication type */\n\tuint16 dummy;\t/* Must be zero */\n\tuint16 slen1;\t/* Length of the first authentication item (e.g. username) */\n\tuint16 slen2;\t/* Length of the second authentication item (e.g. password) */\n}",
          {
            "type": "uint16",
            "dummy": "uint16",
            "slen1": "uint16",
            "slen2": "uint16"
          },
          "rpcap_auth",
          [
            318,
            0
          ],
          [
            324,
            1
          ]
        ],
        [
          "struct rpcap_stats\n{\n\tuint32 ifrecv;\t\t/* Packets received by the kernel filter (i.e. pcap_stats.ps_recv) */\n\tuint32 ifdrop;\t\t/* Packets dropped by the network interface (e.g. not enough buffers) (i.e. pcap_stats.ps_ifdrop) */\n\tuint32 krnldrop;\t/* Packets dropped by the kernel filter (i.e. pcap_stats.ps_drop) */\n\tuint32 svrcapt;\t\t/* Packets captured by the RPCAP daemon and sent on the network */\n}",
          {
            "ifrecv": "uint32",
            "ifdrop": "uint32",
            "krnldrop": "uint32",
            "svrcapt": "uint32"
          },
          "rpcap_stats",
          [
            327,
            0
          ],
          [
            333,
            1
          ]
        ],
        [
          "struct rpcap_sampling\n{\n\tuint8 method;\t/* Sampling method */\n\tuint8 dummy1;\t/* Must be zero */\n\tuint16 dummy2;\t/* Must be zero */\n\tuint32 value;\t/* Parameter related to the sampling method */\n}",
          {
            "method": "uint8",
            "dummy1": "uint8",
            "dummy2": "uint16",
            "value": "uint32"
          },
          "rpcap_sampling",
          [
            336,
            0
          ],
          [
            342,
            1
          ]
        ],
        [
          "struct rpcap_header",
          {},
          "",
          [
            423,
            28
          ],
          [
            423,
            47
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"sockutils.h\"\n",
          [
            420,
            0
          ],
          [
            421,
            0
          ]
        ],
        [
          "#include \"sslutils.h\"\n",
          [
            421,
            0
          ],
          [
            422,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-rdmasniff.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "rdmasniff_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              0,
              8
            ],
            [
              0,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rdmasniff_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "rdmasniff_findalldevs(pcap_if_list_t *devlistp, char *err_str)",
          "fn_dec_pos": [
            [
              1,
              4
            ],
            [
              1,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rdmasniff_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "err_str": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/sf-pcap.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "pcap_check_header(bpf_u_int32 magic, FILE *fp,\n    u_int precision, char *errbuf, int *err)",
          "fn_dec_pos": [
            [
              33,
              15
            ],
            [
              34,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_check_header",
            "parameters": {
              "magic": "bpf_u_int32",
              "fp": "FILE",
              "precision": "u_int",
              "errbuf": "char",
              "err": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-namedb.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <pcap/namedb.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/arcnet.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/portability.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "pcap_strlcat(char * restrict dst, const char * restrict src, size_t dstsize)",
          "fn_dec_pos": [
            [
              62,
              18
            ],
            [
              62,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_strlcat",
            "parameters": {
              "dst": "char",
              "src": "char",
              "dstsize": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "pcap_strlcpy(char * restrict dst, const char * restrict src, size_t dstsize)",
          "fn_dec_pos": [
            [
              80,
              18
            ],
            [
              80,
              94
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_strlcpy",
            "parameters": {
              "dst": "char",
              "src": "char",
              "dstsize": "size_t"
            },
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "pcap_snprintf(char *, size_t, PCAP_FORMAT_STRING(const char *), ...)",
          "fn_dec_pos": [
            [
              123,
              11
            ],
            [
              123,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_snprintf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_vsnprintf(char *, size_t, const char *, va_list ap)",
          "fn_dec_pos": [
            [
              130,
              11
            ],
            [
              130,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_vsnprintf",
            "parameters": {
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_asprintf(char **, PCAP_FORMAT_STRING(const char *), ...)",
          "fn_dec_pos": [
            [
              140,
              11
            ],
            [
              140,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_asprintf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_vasprintf(char **, const char *, va_list ap)",
          "fn_dec_pos": [
            [
              147,
              11
            ],
            [
              147,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_vasprintf",
            "parameters": {
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_strtok_r(char *, const char *, char **)",
          "fn_dec_pos": [
            [
              162,
              17
            ],
            [
              162,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_strtok_r",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdarg.h>\t/* we declare varargs functions on some platforms */\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"pcap/funcattrs.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-rpcap.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "pcap_open_rpcap(const char *source, int snaplen, int flags,\n    int read_timeout, struct pcap_rmtauth *auth, char *errbuf)",
          "fn_dec_pos": [
            [
              39,
              8
            ],
            [
              40,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_rpcap",
            "parameters": {
              "source": "char",
              "snaplen": "int",
              "flags": "int",
              "read_timeout": "int",
              "auth": "struct pcap_rmtauth",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_findalldevs_ex_remote(const char *source,\n    struct pcap_rmtauth *auth, pcap_if_t **alldevs, char *errbuf)",
          "fn_dec_pos": [
            [
              45,
              4
            ],
            [
              46,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_findalldevs_ex_remote",
            "parameters": {
              "source": "char",
              "auth": "struct pcap_rmtauth",
              "alldevs": "pcap_if_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_rmtauth",
          {},
          "",
          [
            40,
            22
          ],
          [
            40,
            41
          ]
        ],
        [
          "struct pcap_rmtauth",
          {},
          "",
          [
            46,
            4
          ],
          [
            46,
            23
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-netfilter-linux.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "netfilter_findalldevs(pcap_if_list_t *devlistp, char *err_str)",
          "fn_dec_pos": [
            [
              33,
              4
            ],
            [
              33,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "netfilter_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "err_str": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "netfilter_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              34,
              8
            ],
            [
              34,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "netfilter_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/dlpisubs.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "pcap_stats_dlpi(pcap_t *, struct pcap_stat *)",
          "fn_dec_pos": [
            [
              24,
              4
            ],
            [
              24,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_dlpi",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_process_pkts(pcap_t *, pcap_handler, u_char *, int, u_char *, int)",
          "fn_dec_pos": [
            [
              25,
              4
            ],
            [
              25,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_process_pkts",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_process_mactype(pcap_t *, u_int)",
          "fn_dec_pos": [
            [
              26,
              4
            ],
            [
              26,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_process_mactype",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_conf_bufmod(pcap_t *, int)",
          "fn_dec_pos": [
            [
              28,
              4
            ],
            [
              28,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_conf_bufmod",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_alloc_databuf(pcap_t *)",
          "fn_dec_pos": [
            [
              30,
              4
            ],
            [
              30,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_alloc_databuf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "strioctl(int, int, int, char *)",
          "fn_dec_pos": [
            [
              31,
              4
            ],
            [
              31,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strioctl",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_dlpi {\n#ifdef HAVE_LIBDLPI\n\tdlpi_handle_t dlpi_hd;\n#endif /* HAVE_LIBDLPI */\n#ifdef DL_HP_RAWDLS\n\tint send_fd;\n#endif /* DL_HP_RAWDLS */\n\n\tstruct pcap_stat stat;\n}",
          {
            "dlpi_hd": "dlpi_handle_t",
            "send_fd": "int",
            "stat": "struct pcap_stat"
          },
          "pcap_dlpi",
          [
            10,
            0
          ],
          [
            19,
            1
          ]
        ],
        [
          "struct pcap_dlpi {\n#ifdef HAVE_LIBDLPI\n\tdlpi_handle_t dlpi_hd;\n#endif /* HAVE_LIBDLPI */\n#ifdef DL_HP_RAWDLS\n\tint send_fd;\n#endif /* DL_HP_RAWDLS */\n\n\tstruct pcap_stat stat;\n}",
          {
            "dlpi_hd": "dlpi_handle_t",
            "send_fd": "int",
            "stat": "struct pcap_stat"
          },
          "pcap_dlpi",
          [
            10,
            0
          ],
          [
            19,
            1
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            18,
            1
          ],
          [
            18,
            17
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            24,
            30
          ],
          [
            24,
            46
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/atmuni31.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/nlpid.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/sslutils.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ssl_set_certfile(const char *certfile)",
          "fn_dec_pos": [
            [
              44,
              5
            ],
            [
              44,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ssl_set_certfile",
            "parameters": {
              "certfile": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ssl_set_keyfile(const char *keyfile)",
          "fn_dec_pos": [
            [
              45,
              5
            ],
            [
              45,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ssl_set_keyfile",
            "parameters": {
              "keyfile": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ssl_init_once(int is_server, int enable_compression, char *errbuf, size_t errbuflen)",
          "fn_dec_pos": [
            [
              46,
              4
            ],
            [
              46,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ssl_init_once",
            "parameters": {
              "is_server": "int",
              "enable_compression": "int",
              "errbuf": "char",
              "errbuflen": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ssl_promotion(int is_server, SOCKET s, char *errbuf, size_t errbuflen)",
          "fn_dec_pos": [
            [
              47,
              5
            ],
            [
              47,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ssl_promotion",
            "parameters": {
              "is_server": "int",
              "s": "SOCKET",
              "errbuf": "char",
              "errbuflen": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ssl_finish(SSL *ssl)",
          "fn_dec_pos": [
            [
              48,
              5
            ],
            [
              48,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ssl_finish",
            "parameters": {
              "ssl": "SSL"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ssl_send(SSL *, char const *buffer, int size, char *errbuf, size_t errbuflen)",
          "fn_dec_pos": [
            [
              49,
              4
            ],
            [
              49,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ssl_send",
            "parameters": {
              "buffer": "char",
              "size": "int",
              "errbuf": "char",
              "errbuflen": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ssl_recv(SSL *, char *buffer, int size, char *errbuf, size_t errbuflen)",
          "fn_dec_pos": [
            [
              50,
              4
            ],
            [
              50,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ssl_recv",
            "parameters": {
              "buffer": "char",
              "size": "int",
              "errbuf": "char",
              "errbuflen": "size_t"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"pcap/socket.h\"  // for SOCKET\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <openssl/ssl.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <openssl/err.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/ethertype.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-rpcap-int.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "rpcap_createhdr(struct rpcap_header *header, uint8 type, uint16 value, uint32 length)",
          "fn_dec_pos": [
            [
              71,
              5
            ],
            [
              71,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_createhdr",
            "parameters": {
              "header": "struct rpcap_header",
              "type": "uint8",
              "value": "uint16",
              "length": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "rpcap_senderror(SOCKET sock, char *error, unsigned short errcode, char *errbuf)",
          "fn_dec_pos": [
            [
              72,
              4
            ],
            [
              72,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcap_senderror",
            "parameters": {
              "sock": "SOCKET",
              "error": "char",
              "errcode": "unsigned short",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct rpcap_header",
          {},
          "",
          [
            71,
            21
          ],
          [
            71,
            40
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"pcap.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"sockutils.h\"\t/* Needed for some structures (like SOCKET, sockaddr_in) which are used here */\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/sunatmpos.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-usb-linux.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "usb_findalldevs(pcap_if_list_t *devlistp, char *err_str)",
          "fn_dec_pos": [
            [
              36,
              4
            ],
            [
              36,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "err_str": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "usb_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              37,
              8
            ],
            [
              37,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usb_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <pcap/pcap.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/diag-control.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"pcap/compiler-tests.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/ftmacros.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-types.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <winsock2.h>\n",
          [
            40,
            2
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            45,
            2
          ],
          [
            46,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/ppp.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/extract.h": {
      "fn_def_list": [
        {
          "fn_code": "UNALIGNED_OK static inline uint16_t\nEXTRACT_BE_U_2(const void *p)\n{\n\treturn ((uint16_t)ntohs(*(const uint16_t *)(p)));\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EXTRACT_BE_U_2",
            "parameters": {
              "p": "void"
            },
            "return_type": "UNALIGNED_OK"
          }
        },
        {
          "fn_code": "UNALIGNED_OK static inline int16_t\nEXTRACT_BE_S_2(const void *p)\n{\n\treturn ((int16_t)ntohs(*(const int16_t *)(p)));\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              85,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EXTRACT_BE_S_2",
            "parameters": {
              "p": "void"
            },
            "return_type": "UNALIGNED_OK"
          }
        },
        {
          "fn_code": "UNALIGNED_OK static inline uint32_t\nEXTRACT_BE_U_4(const void *p)\n{\n\treturn ((uint32_t)ntohl(*(const uint32_t *)(p)));\n}",
          "fn_code_pos": [
            [
              87,
              0
            ],
            [
              91,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EXTRACT_BE_U_4",
            "parameters": {
              "p": "void"
            },
            "return_type": "UNALIGNED_OK"
          }
        },
        {
          "fn_code": "UNALIGNED_OK static inline int32_t\nEXTRACT_BE_S_4(const void *p)\n{\n\treturn ((int32_t)ntohl(*(const int32_t *)(p)));\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EXTRACT_BE_S_4",
            "parameters": {
              "p": "void"
            },
            "return_type": "UNALIGNED_OK"
          }
        },
        {
          "fn_code": "UNALIGNED_OK static inline uint64_t\nEXTRACT_BE_U_8(const void *p)\n{\n\treturn ((uint64_t)(((uint64_t)ntohl(*((const uint32_t *)(p) + 0))) << 32 |\n\t\t((uint64_t)ntohl(*((const uint32_t *)(p) + 1))) << 0));\n\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EXTRACT_BE_U_8",
            "parameters": {
              "p": "void"
            },
            "return_type": "UNALIGNED_OK"
          }
        },
        {
          "fn_code": "UNALIGNED_OK static inline int64_t\nEXTRACT_BE_S_8(const void *p)\n{\n\treturn ((int64_t)(((int64_t)ntohl(*((const uint32_t *)(p) + 0))) << 32 |\n\t\t((uint64_t)ntohl(*((const uint32_t *)(p) + 1))) << 0));\n\n}",
          "fn_code_pos": [
            [
              107,
              0
            ],
            [
              113,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EXTRACT_BE_S_8",
            "parameters": {
              "p": "void"
            },
            "return_type": "UNALIGNED_OK"
          }
        },
        {
          "fn_code": "UNALIGNED_OK static inline uint16_t\nEXTRACT_BE_U_2(const void *p)\n{\n\treturn ((uint16_t)ntohs(((const unaligned_uint16_t *)(p))->val));\n}",
          "fn_code_pos": [
            [
              185,
              0
            ],
            [
              189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EXTRACT_BE_U_2",
            "parameters": {
              "p": "void"
            },
            "return_type": "UNALIGNED_OK"
          }
        },
        {
          "fn_code": "UNALIGNED_OK static inline int16_t\nEXTRACT_BE_S_2(const void *p)\n{\n\treturn ((int16_t)ntohs(((const unaligned_int16_t *)(p))->val));\n}",
          "fn_code_pos": [
            [
              191,
              0
            ],
            [
              195,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EXTRACT_BE_S_2",
            "parameters": {
              "p": "void"
            },
            "return_type": "UNALIGNED_OK"
          }
        },
        {
          "fn_code": "UNALIGNED_OK static inline uint32_t\nEXTRACT_BE_U_4(const void *p)\n{\n\treturn ((uint32_t)ntohl(((const unaligned_uint32_t *)(p))->val));\n}",
          "fn_code_pos": [
            [
              197,
              0
            ],
            [
              201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EXTRACT_BE_U_4",
            "parameters": {
              "p": "void"
            },
            "return_type": "UNALIGNED_OK"
          }
        },
        {
          "fn_code": "UNALIGNED_OK static inline int32_t\nEXTRACT_BE_S_4(const void *p)\n{\n\treturn ((int32_t)ntohl(((const unaligned_int32_t *)(p))->val));\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EXTRACT_BE_S_4",
            "parameters": {
              "p": "void"
            },
            "return_type": "UNALIGNED_OK"
          }
        },
        {
          "fn_code": "UNALIGNED_OK static inline uint64_t\nEXTRACT_BE_U_8(const void *p)\n{\n\treturn ((uint64_t)(((uint64_t)ntohl(((const unaligned_uint32_t *)(p) + 0)->val)) << 32 |\n\t\t((uint64_t)ntohl(((const unaligned_uint32_t *)(p) + 1)->val)) << 0));\n}",
          "fn_code_pos": [
            [
              209,
              0
            ],
            [
              214,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EXTRACT_BE_U_8",
            "parameters": {
              "p": "void"
            },
            "return_type": "UNALIGNED_OK"
          }
        },
        {
          "fn_code": "UNALIGNED_OK static inline int64_t\nEXTRACT_BE_S_8(const void *p)\n{\n\treturn ((int64_t)(((uint64_t)ntohl(((const unaligned_uint32_t *)(p) + 0)->val)) << 32 |\n\t\t((uint64_t)ntohl(((const unaligned_uint32_t *)(p) + 1)->val)) << 0));\n}",
          "fn_code_pos": [
            [
              216,
              0
            ],
            [
              221,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EXTRACT_BE_S_8",
            "parameters": {
              "p": "void"
            },
            "return_type": "UNALIGNED_OK"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\tuint16_t\tval;\n} __attribute__((packed)) unaligned_uint16_t;",
          {
            "val": "uint16_t"
          },
          "unaligned_uint16_t",
          [
            169,
            0
          ],
          [
            171,
            45
          ]
        ],
        [
          "typedef struct {\n\tint16_t\t\tval;\n} __attribute__((packed)) unaligned_int16_t;",
          {
            "val": "int16_t"
          },
          "unaligned_int16_t",
          [
            173,
            0
          ],
          [
            175,
            44
          ]
        ],
        [
          "typedef struct {\n\tuint32_t\tval;\n} __attribute__((packed)) unaligned_uint32_t;",
          {
            "val": "uint32_t"
          },
          "unaligned_uint32_t",
          [
            177,
            0
          ],
          [
            179,
            45
          ]
        ],
        [
          "typedef struct {\n\tint32_t\t\tval;\n} __attribute__((packed)) unaligned_int32_t;",
          {
            "val": "int32_t"
          },
          "unaligned_int32_t",
          [
            181,
            0
          ],
          [
            183,
            44
          ]
        ],
        [
          "typedef struct {\n\tuint16_t\tval;\n} __attribute__((packed)) unaligned_uint16_t;",
          {
            "val": "uint16_t"
          },
          "unaligned_uint16_t",
          [
            169,
            0
          ],
          [
            171,
            45
          ]
        ],
        [
          "typedef struct {\n\tint16_t\t\tval;\n} __attribute__((packed)) unaligned_int16_t;",
          {
            "val": "int16_t"
          },
          "unaligned_int16_t",
          [
            173,
            0
          ],
          [
            175,
            44
          ]
        ],
        [
          "typedef struct {\n\tuint32_t\tval;\n} __attribute__((packed)) unaligned_uint32_t;",
          {
            "val": "uint32_t"
          },
          "unaligned_uint32_t",
          [
            177,
            0
          ],
          [
            179,
            45
          ]
        ],
        [
          "typedef struct {\n\tint32_t\t\tval;\n} __attribute__((packed)) unaligned_int32_t;",
          {
            "val": "int32_t"
          },
          "unaligned_int32_t",
          [
            181,
            0
          ],
          [
            183,
            44
          ]
        ]
      ],
      "include_list": [
        [
          "#include <arpa/inet.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <pcap/pcap-inttypes.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <pcap/compiler-tests.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"portability.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-dpdk.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "pcap_dpdk_create(const char *, char *, int *)",
          "fn_dec_pos": [
            [
              26,
              8
            ],
            [
              26,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dpdk_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_dpdk_findalldevs(pcap_if_list_t *devlistp, char *errbuf)",
          "fn_dec_pos": [
            [
              27,
              4
            ],
            [
              27,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dpdk_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/llc.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/optimize.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/ieee80211.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/gencode.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "gen_loadi(compiler_state_t *, bpf_u_int32)",
          "fn_dec_pos": [
            [
              288,
              13
            ],
            [
              288,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_loadi",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_load(compiler_state_t *, int, struct arth *, bpf_u_int32)",
          "fn_dec_pos": [
            [
              289,
              13
            ],
            [
              289,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_load",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_loadlen(compiler_state_t *)",
          "fn_dec_pos": [
            [
              290,
              13
            ],
            [
              290,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_loadlen",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_neg(compiler_state_t *, struct arth *)",
          "fn_dec_pos": [
            [
              291,
              13
            ],
            [
              291,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_neg",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_arth(compiler_state_t *, int, struct arth *, struct arth *)",
          "fn_dec_pos": [
            [
              292,
              13
            ],
            [
              292,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_arth",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_and(struct block *, struct block *)",
          "fn_dec_pos": [
            [
              294,
              5
            ],
            [
              294,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_and",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "gen_or(struct block *, struct block *)",
          "fn_dec_pos": [
            [
              295,
              5
            ],
            [
              295,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_or",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "gen_not(struct block *)",
          "fn_dec_pos": [
            [
              296,
              5
            ],
            [
              296,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_not",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "gen_scode(compiler_state_t *, const char *, struct qual)",
          "fn_dec_pos": [
            [
              298,
              14
            ],
            [
              298,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_scode",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ecode(compiler_state_t *, const char *, struct qual)",
          "fn_dec_pos": [
            [
              299,
              14
            ],
            [
              299,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ecode",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_acode(compiler_state_t *, const char *, struct qual)",
          "fn_dec_pos": [
            [
              300,
              14
            ],
            [
              300,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_acode",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_mcode(compiler_state_t *, const char *, const char *,\n    bpf_u_int32, struct qual)",
          "fn_dec_pos": [
            [
              301,
              14
            ],
            [
              302,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mcode",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_mcode6(compiler_state_t *, const char *, const char *,\n    bpf_u_int32, struct qual)",
          "fn_dec_pos": [
            [
              304,
              14
            ],
            [
              305,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mcode6",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_ncode(compiler_state_t *, const char *, bpf_u_int32,\n    struct qual)",
          "fn_dec_pos": [
            [
              307,
              14
            ],
            [
              308,
              16
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_ncode",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_proto_abbrev(compiler_state_t *, int)",
          "fn_dec_pos": [
            [
              309,
              14
            ],
            [
              309,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_proto_abbrev",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_relation(compiler_state_t *, int, struct arth *,\n    struct arth *, int)",
          "fn_dec_pos": [
            [
              310,
              14
            ],
            [
              311,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_relation",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_less(compiler_state_t *, int)",
          "fn_dec_pos": [
            [
              312,
              14
            ],
            [
              312,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_less",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_greater(compiler_state_t *, int)",
          "fn_dec_pos": [
            [
              313,
              14
            ],
            [
              313,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_greater",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_byteop(compiler_state_t *, int, int, bpf_u_int32)",
          "fn_dec_pos": [
            [
              314,
              14
            ],
            [
              314,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_byteop",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_broadcast(compiler_state_t *, int)",
          "fn_dec_pos": [
            [
              315,
              14
            ],
            [
              315,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_broadcast",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_multicast(compiler_state_t *, int)",
          "fn_dec_pos": [
            [
              316,
              14
            ],
            [
              316,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_multicast",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_inbound(compiler_state_t *, int)",
          "fn_dec_pos": [
            [
              317,
              14
            ],
            [
              317,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_inbound",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_llc(compiler_state_t *)",
          "fn_dec_pos": [
            [
              319,
              14
            ],
            [
              319,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_llc_i(compiler_state_t *)",
          "fn_dec_pos": [
            [
              320,
              14
            ],
            [
              320,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_i",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_llc_s(compiler_state_t *)",
          "fn_dec_pos": [
            [
              321,
              14
            ],
            [
              321,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_s",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_llc_u(compiler_state_t *)",
          "fn_dec_pos": [
            [
              322,
              14
            ],
            [
              322,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_u",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_llc_s_subtype(compiler_state_t *, bpf_u_int32)",
          "fn_dec_pos": [
            [
              323,
              14
            ],
            [
              323,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_s_subtype",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_llc_u_subtype(compiler_state_t *, bpf_u_int32)",
          "fn_dec_pos": [
            [
              324,
              14
            ],
            [
              324,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_llc_u_subtype",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_vlan(compiler_state_t *, bpf_u_int32, int)",
          "fn_dec_pos": [
            [
              326,
              14
            ],
            [
              326,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_vlan",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_mpls(compiler_state_t *, bpf_u_int32, int)",
          "fn_dec_pos": [
            [
              327,
              14
            ],
            [
              327,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mpls",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pppoed(compiler_state_t *)",
          "fn_dec_pos": [
            [
              329,
              14
            ],
            [
              329,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pppoed",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pppoes(compiler_state_t *, bpf_u_int32, int)",
          "fn_dec_pos": [
            [
              330,
              14
            ],
            [
              330,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pppoes",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_geneve(compiler_state_t *, bpf_u_int32, int)",
          "fn_dec_pos": [
            [
              332,
              14
            ],
            [
              332,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_geneve",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_atmfield_code(compiler_state_t *, int, bpf_u_int32,\n    int, int)",
          "fn_dec_pos": [
            [
              334,
              14
            ],
            [
              335,
              13
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmfield_code",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_atmtype_abbrev(compiler_state_t *, int)",
          "fn_dec_pos": [
            [
              336,
              14
            ],
            [
              336,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmtype_abbrev",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_atmmulti_abbrev(compiler_state_t *, int)",
          "fn_dec_pos": [
            [
              337,
              14
            ],
            [
              337,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_atmmulti_abbrev",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_mtp2type_abbrev(compiler_state_t *, int)",
          "fn_dec_pos": [
            [
              339,
              14
            ],
            [
              339,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mtp2type_abbrev",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_mtp3field_code(compiler_state_t *, int, bpf_u_int32,\n    int, int)",
          "fn_dec_pos": [
            [
              340,
              14
            ],
            [
              341,
              13
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_mtp3field_code",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_ifname(compiler_state_t *, const char *)",
          "fn_dec_pos": [
            [
              343,
              14
            ],
            [
              343,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_ifname",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_rnr(compiler_state_t *, int)",
          "fn_dec_pos": [
            [
              344,
              14
            ],
            [
              344,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_rnr",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_srnr(compiler_state_t *, int)",
          "fn_dec_pos": [
            [
              345,
              14
            ],
            [
              345,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_srnr",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_ruleset(compiler_state_t *, char *)",
          "fn_dec_pos": [
            [
              346,
              14
            ],
            [
              346,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_ruleset",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_reason(compiler_state_t *, int)",
          "fn_dec_pos": [
            [
              347,
              14
            ],
            [
              347,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_reason",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_pf_action(compiler_state_t *, int)",
          "fn_dec_pos": [
            [
              348,
              14
            ],
            [
              348,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_pf_action",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_p80211_type(compiler_state_t *, bpf_u_int32, bpf_u_int32)",
          "fn_dec_pos": [
            [
              350,
              14
            ],
            [
              350,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_p80211_type",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gen_p80211_fcdir(compiler_state_t *, bpf_u_int32)",
          "fn_dec_pos": [
            [
              351,
              14
            ],
            [
              351,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_p80211_fcdir",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "bpf_optimize(struct icode *, char *)",
          "fn_dec_pos": [
            [
              368,
              4
            ],
            [
              368,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_optimize",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "bpf_set_error(compiler_state_t *, const char *, ...)",
          "fn_dec_pos": [
            [
              369,
              5
            ],
            [
              369,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_set_error",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "finish_parse(compiler_state_t *, struct block *)",
          "fn_dec_pos": [
            [
              372,
              4
            ],
            [
              372,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "finish_parse",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "sdup(compiler_state_t *, const char *)",
          "fn_dec_pos": [
            [
              373,
              6
            ],
            [
              373,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sdup",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "icode_to_fcode(struct icode *, struct block *, u_int *,\n    char *)",
          "fn_dec_pos": [
            [
              375,
              17
            ],
            [
              376,
              11
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "icode_to_fcode",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "sappend(struct slist *, struct slist *)",
          "fn_dec_pos": [
            [
              377,
              5
            ],
            [
              377,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sappend",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_parse(void *, compiler_state_t *)",
          "fn_dec_pos": [
            [
              383,
              4
            ],
            [
              383,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_parse",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct stmt {\n\tint code;\n\tstruct slist *jt;\t/*only for relative jump in block*/\n\tstruct slist *jf;\t/*only for relative jump in block*/\n\tbpf_u_int32 k;\n}",
          {
            "code": "int",
            "*jt": "struct slist",
            "*jf": "struct slist",
            "k": "bpf_u_int32"
          },
          "stmt",
          [
            202,
            0
          ],
          [
            207,
            1
          ]
        ],
        [
          "struct slist {\n\tstruct stmt s;\n\tstruct slist *next;\n}",
          {
            "s": "struct stmt",
            "*next": "struct slist"
          },
          "slist",
          [
            209,
            0
          ],
          [
            212,
            1
          ]
        ],
        [
          "struct edge {\n\tint id;\n\tint code;\n\tuset edom;\n\tstruct block *succ;\n\tstruct block *pred;\n\tstruct edge *next;\t/* link list of incoming edges for a node */\n}",
          {
            "id": "int",
            "code": "int",
            "edom": "uset",
            "*succ": "struct block",
            "*pred": "struct block",
            "*next": "struct edge"
          },
          "edge",
          [
            233,
            0
          ],
          [
            240,
            1
          ]
        ],
        [
          "struct block {\n\tint id;\n\tstruct slist *stmts;\t/* side effect stmts */\n\tstruct stmt s;\t\t/* branch stmt */\n\tint mark;\n\tu_int longjt;\t\t/* jt branch requires long jump */\n\tu_int longjf;\t\t/* jf branch requires long jump */\n\tint level;\n\tint offset;\n\tint sense;\n\tstruct edge et;\n\tstruct edge ef;\n\tstruct block *head;\n\tstruct block *link;\t/* link field used by optimizer */\n\tuset dom;\n\tuset closure;\n\tstruct edge *in_edges;\n\tatomset def, kill;\n\tatomset in_use;\n\tatomset out_use;\n\tint oval;\n\tbpf_u_int32 val[N_ATOMS];\n}",
          {
            "id": "int",
            "*stmts": "struct slist",
            "s": "struct stmt",
            "mark": "int",
            "longjt": "u_int",
            "longjf": "u_int",
            "level": "int",
            "offset": "int",
            "sense": "int",
            "et": "struct edge",
            "ef": "struct edge",
            "*head": "struct block",
            "*link": "struct block",
            "dom": "uset",
            "closure": "uset",
            "*in_edges": "struct edge",
            "def": "atomset",
            "in_use": "atomset",
            "out_use": "atomset",
            "oval": "int",
            "val[N_ATOMS]": "bpf_u_int32"
          },
          "block",
          [
            242,
            0
          ],
          [
            264,
            1
          ]
        ],
        [
          "struct arth {\n\tstruct block *b;\t/* protocol checks */\n\tstruct slist *s;\t/* stmt list */\n\tint regno;\t\t/* virtual register number of result */\n}",
          {
            "*b": "struct block",
            "*s": "struct slist",
            "regno": "int"
          },
          "arth",
          [
            271,
            0
          ],
          [
            275,
            1
          ]
        ],
        [
          "struct qual {\n\tunsigned char addr;\n\tunsigned char proto;\n\tunsigned char dir;\n\tunsigned char pad;\n}",
          {
            "addr": "unsigned char",
            "proto": "unsigned char",
            "dir": "unsigned char",
            "pad": "unsigned char"
          },
          "qual",
          [
            277,
            0
          ],
          [
            282,
            1
          ]
        ],
        [
          "struct icode {\n\tstruct block *root;\n\tint cur_mark;\n}",
          {
            "*root": "struct block",
            "cur_mark": "int"
          },
          "icode",
          [
            363,
            0
          ],
          [
            366,
            1
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            200,
            0
          ],
          [
            200,
            12
          ]
        ],
        [
          "struct stmt {\n\tint code;\n\tstruct slist *jt;\t/*only for relative jump in block*/\n\tstruct slist *jf;\t/*only for relative jump in block*/\n\tbpf_u_int32 k;\n}",
          {
            "code": "int",
            "*jt": "struct slist",
            "*jf": "struct slist",
            "k": "bpf_u_int32"
          },
          "stmt",
          [
            202,
            0
          ],
          [
            207,
            1
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            204,
            1
          ],
          [
            204,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            205,
            1
          ],
          [
            205,
            13
          ]
        ],
        [
          "struct slist {\n\tstruct stmt s;\n\tstruct slist *next;\n}",
          {
            "s": "struct stmt",
            "*next": "struct slist"
          },
          "slist",
          [
            209,
            0
          ],
          [
            212,
            1
          ]
        ],
        [
          "struct stmt",
          {},
          "",
          [
            210,
            1
          ],
          [
            210,
            12
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            211,
            1
          ],
          [
            211,
            13
          ]
        ],
        [
          "struct edge {\n\tint id;\n\tint code;\n\tuset edom;\n\tstruct block *succ;\n\tstruct block *pred;\n\tstruct edge *next;\t/* link list of incoming edges for a node */\n}",
          {
            "id": "int",
            "code": "int",
            "edom": "uset",
            "*succ": "struct block",
            "*pred": "struct block",
            "*next": "struct edge"
          },
          "edge",
          [
            233,
            0
          ],
          [
            240,
            1
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            237,
            1
          ],
          [
            237,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            238,
            1
          ],
          [
            238,
            13
          ]
        ],
        [
          "struct edge",
          {},
          "",
          [
            239,
            1
          ],
          [
            239,
            12
          ]
        ],
        [
          "struct block {\n\tint id;\n\tstruct slist *stmts;\t/* side effect stmts */\n\tstruct stmt s;\t\t/* branch stmt */\n\tint mark;\n\tu_int longjt;\t\t/* jt branch requires long jump */\n\tu_int longjf;\t\t/* jf branch requires long jump */\n\tint level;\n\tint offset;\n\tint sense;\n\tstruct edge et;\n\tstruct edge ef;\n\tstruct block *head;\n\tstruct block *link;\t/* link field used by optimizer */\n\tuset dom;\n\tuset closure;\n\tstruct edge *in_edges;\n\tatomset def, kill;\n\tatomset in_use;\n\tatomset out_use;\n\tint oval;\n\tbpf_u_int32 val[N_ATOMS];\n}",
          {
            "id": "int",
            "*stmts": "struct slist",
            "s": "struct stmt",
            "mark": "int",
            "longjt": "u_int",
            "longjf": "u_int",
            "level": "int",
            "offset": "int",
            "sense": "int",
            "et": "struct edge",
            "ef": "struct edge",
            "*head": "struct block",
            "*link": "struct block",
            "dom": "uset",
            "closure": "uset",
            "*in_edges": "struct edge",
            "def": "atomset",
            "in_use": "atomset",
            "out_use": "atomset",
            "oval": "int",
            "val[N_ATOMS]": "bpf_u_int32"
          },
          "block",
          [
            242,
            0
          ],
          [
            264,
            1
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            244,
            1
          ],
          [
            244,
            13
          ]
        ],
        [
          "struct stmt",
          {},
          "",
          [
            245,
            1
          ],
          [
            245,
            12
          ]
        ],
        [
          "struct edge",
          {},
          "",
          [
            252,
            1
          ],
          [
            252,
            12
          ]
        ],
        [
          "struct edge",
          {},
          "",
          [
            253,
            1
          ],
          [
            253,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            254,
            1
          ],
          [
            254,
            13
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            255,
            1
          ],
          [
            255,
            13
          ]
        ],
        [
          "struct edge",
          {},
          "",
          [
            258,
            1
          ],
          [
            258,
            12
          ]
        ],
        [
          "struct arth {\n\tstruct block *b;\t/* protocol checks */\n\tstruct slist *s;\t/* stmt list */\n\tint regno;\t\t/* virtual register number of result */\n}",
          {
            "*b": "struct block",
            "*s": "struct slist",
            "regno": "int"
          },
          "arth",
          [
            271,
            0
          ],
          [
            275,
            1
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            272,
            1
          ],
          [
            272,
            13
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            273,
            1
          ],
          [
            273,
            13
          ]
        ],
        [
          "struct qual {\n\tunsigned char addr;\n\tunsigned char proto;\n\tunsigned char dir;\n\tunsigned char pad;\n}",
          {
            "addr": "unsigned char",
            "proto": "unsigned char",
            "dir": "unsigned char",
            "pad": "unsigned char"
          },
          "qual",
          [
            277,
            0
          ],
          [
            282,
            1
          ]
        ],
        [
          "struct _compiler_state",
          {},
          "",
          [
            284,
            0
          ],
          [
            284,
            22
          ]
        ],
        [
          "typedef struct _compiler_state compiler_state_t;",
          {},
          "compiler_state_t",
          [
            286,
            0
          ],
          [
            286,
            48
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            288,
            0
          ],
          [
            288,
            11
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            289,
            0
          ],
          [
            289,
            11
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            289,
            47
          ],
          [
            289,
            58
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            290,
            0
          ],
          [
            290,
            11
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            291,
            0
          ],
          [
            291,
            11
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            291,
            41
          ],
          [
            291,
            52
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            292,
            0
          ],
          [
            292,
            11
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            292,
            47
          ],
          [
            292,
            58
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            292,
            62
          ],
          [
            292,
            73
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            294,
            13
          ],
          [
            294,
            25
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            294,
            29
          ],
          [
            294,
            41
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            295,
            12
          ],
          [
            295,
            24
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            295,
            28
          ],
          [
            295,
            40
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            296,
            13
          ],
          [
            296,
            25
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            298,
            0
          ],
          [
            298,
            12
          ]
        ],
        [
          "struct qual",
          {},
          "",
          [
            298,
            58
          ],
          [
            298,
            69
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            299,
            0
          ],
          [
            299,
            12
          ]
        ],
        [
          "struct qual",
          {},
          "",
          [
            299,
            58
          ],
          [
            299,
            69
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            300,
            0
          ],
          [
            300,
            12
          ]
        ],
        [
          "struct qual",
          {},
          "",
          [
            300,
            58
          ],
          [
            300,
            69
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            301,
            0
          ],
          [
            301,
            12
          ]
        ],
        [
          "struct qual",
          {},
          "",
          [
            302,
            17
          ],
          [
            302,
            28
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            304,
            0
          ],
          [
            304,
            12
          ]
        ],
        [
          "struct qual",
          {},
          "",
          [
            305,
            17
          ],
          [
            305,
            28
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            307,
            0
          ],
          [
            307,
            12
          ]
        ],
        [
          "struct qual",
          {},
          "",
          [
            308,
            4
          ],
          [
            308,
            15
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            309,
            0
          ],
          [
            309,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            310,
            0
          ],
          [
            310,
            12
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            310,
            52
          ],
          [
            310,
            63
          ]
        ],
        [
          "struct arth",
          {},
          "",
          [
            311,
            4
          ],
          [
            311,
            15
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            312,
            0
          ],
          [
            312,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            313,
            0
          ],
          [
            313,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            314,
            0
          ],
          [
            314,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            315,
            0
          ],
          [
            315,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            316,
            0
          ],
          [
            316,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            317,
            0
          ],
          [
            317,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            319,
            0
          ],
          [
            319,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            320,
            0
          ],
          [
            320,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            321,
            0
          ],
          [
            321,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            322,
            0
          ],
          [
            322,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            323,
            0
          ],
          [
            323,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            324,
            0
          ],
          [
            324,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            326,
            0
          ],
          [
            326,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            327,
            0
          ],
          [
            327,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            329,
            0
          ],
          [
            329,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            330,
            0
          ],
          [
            330,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            332,
            0
          ],
          [
            332,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            334,
            0
          ],
          [
            334,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            336,
            0
          ],
          [
            336,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            337,
            0
          ],
          [
            337,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            339,
            0
          ],
          [
            339,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            340,
            0
          ],
          [
            340,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            343,
            0
          ],
          [
            343,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            344,
            0
          ],
          [
            344,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            345,
            0
          ],
          [
            345,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            346,
            0
          ],
          [
            346,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            347,
            0
          ],
          [
            347,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            348,
            0
          ],
          [
            348,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            350,
            0
          ],
          [
            350,
            12
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            351,
            0
          ],
          [
            351,
            12
          ]
        ],
        [
          "struct icode {\n\tstruct block *root;\n\tint cur_mark;\n}",
          {
            "*root": "struct block",
            "cur_mark": "int"
          },
          "icode",
          [
            363,
            0
          ],
          [
            366,
            1
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            364,
            1
          ],
          [
            364,
            13
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            368,
            17
          ],
          [
            368,
            29
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            372,
            37
          ],
          [
            372,
            49
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            375,
            0
          ],
          [
            375,
            15
          ]
        ],
        [
          "struct icode",
          {},
          "",
          [
            375,
            32
          ],
          [
            375,
            44
          ]
        ],
        [
          "struct block",
          {},
          "",
          [
            375,
            48
          ],
          [
            375,
            60
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            377,
            13
          ],
          [
            377,
            25
          ]
        ],
        [
          "struct slist",
          {},
          "",
          [
            377,
            29
          ],
          [
            377,
            41
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"pcap/funcattrs.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/fmtutils.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "pcap_fmt_errmsg_for_errno(char *, size_t, int,\n    PCAP_FORMAT_STRING(const char *), ...)",
          "fn_dec_pos": [
            [
              42,
              5
            ],
            [
              43,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_fmt_errmsg_for_errno",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_win32_err_to_str(DWORD, char *)",
          "fn_dec_pos": [
            [
              46,
              5
            ],
            [
              46,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_win32_err_to_str",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"pcap/funcattrs.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/varattrs.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <pcap/compiler-tests.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-bt-monitor-linux.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "bt_monitor_findalldevs(pcap_if_list_t *devlistp, char *err_str)",
          "fn_dec_pos": [
            [
              30,
              4
            ],
            [
              30,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_monitor_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "err_str": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "bt_monitor_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              31,
              8
            ],
            [
              31,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_monitor_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-dag.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "dag_create(const char *, char *, int *)",
          "fn_dec_pos": [
            [
              10,
              8
            ],
            [
              10,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "dag_findalldevs(pcap_if_list_t *devlistp, char *errbuf)",
          "fn_dec_pos": [
            [
              11,
              4
            ],
            [
              11,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dag_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-snf.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "snf_create(const char *, char *, int *)",
          "fn_dec_pos": [
            [
              0,
              8
            ],
            [
              0,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "snf_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "snf_findalldevs(pcap_if_list_t *devlistp, char *errbuf)",
          "fn_dec_pos": [
            [
              1,
              4
            ],
            [
              1,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "snf_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "errbuf": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/sf-pcapng.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "pcap_ng_check_header(bpf_u_int32 magic, FILE *fp,\n    u_int precision, char *errbuf, int *err)",
          "fn_dec_pos": [
            [
              28,
              15
            ],
            [
              29,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_ng_check_header",
            "parameters": {
              "magic": "bpf_u_int32",
              "fp": "FILE",
              "precision": "u_int",
              "errbuf": "char",
              "err": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/sockutils.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "getnameinfo(const struct sockaddr*,socklen_t,char*,DWORD,\n\tchar*,DWORD,int)",
          "fn_dec_pos": [
            [
              61,
              11
            ],
            [
              62,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getnameinfo",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "sock_init(char *errbuf, int errbuflen)",
          "fn_dec_pos": [
            [
              127,
              4
            ],
            [
              127,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_init",
            "parameters": {
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "sock_cleanup(void)",
          "fn_dec_pos": [
            [
              128,
              5
            ],
            [
              128,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_cleanup",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "sock_fmterror(const char *caller, int errcode, char *errbuf, int errbuflen)",
          "fn_dec_pos": [
            [
              129,
              5
            ],
            [
              129,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_fmterror",
            "parameters": {
              "caller": "char",
              "errcode": "int",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "sock_geterror(const char *caller, char *errbuf, int errbufsize)",
          "fn_dec_pos": [
            [
              130,
              5
            ],
            [
              130,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_geterror",
            "parameters": {
              "caller": "char",
              "errbuf": "char",
              "errbufsize": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "sock_initaddress(const char *address, const char *port,\n    struct addrinfo *hints, struct addrinfo **addrinfo,\n    char *errbuf, int errbuflen)",
          "fn_dec_pos": [
            [
              131,
              4
            ],
            [
              133,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_initaddress",
            "parameters": {
              "address": "char",
              "port": "char",
              "hints": "struct addrinfo",
              "addrinfo": "struct addrinfo",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "sock_recv(SOCKET sock, SSL *, void *buffer, size_t size, int receiveall,\n    char *errbuf, int errbuflen)",
          "fn_dec_pos": [
            [
              134,
              4
            ],
            [
              135,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_recv",
            "parameters": {
              "sock": "SOCKET",
              "buffer": "void",
              "size": "size_t",
              "receiveall": "int",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "sock_recv_dgram(SOCKET sock, SSL *, void *buffer, size_t size,\n    char *errbuf, int errbuflen)",
          "fn_dec_pos": [
            [
              136,
              4
            ],
            [
              137,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_recv_dgram",
            "parameters": {
              "sock": "SOCKET",
              "buffer": "void",
              "size": "size_t",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "sock_open(struct addrinfo *addrinfo, int server, int nconn, char *errbuf, int errbuflen)",
          "fn_dec_pos": [
            [
              138,
              7
            ],
            [
              138,
              95
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_open",
            "parameters": {
              "addrinfo": "struct addrinfo",
              "server": "int",
              "nconn": "int",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "SOCKET"
          }
        },
        {
          "fn_code": "sock_close(SOCKET sock, char *errbuf, int errbuflen)",
          "fn_dec_pos": [
            [
              139,
              4
            ],
            [
              139,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_close",
            "parameters": {
              "sock": "SOCKET",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "sock_send(SOCKET sock, SSL *, const char *buffer, size_t size,\n    char *errbuf, int errbuflen)",
          "fn_dec_pos": [
            [
              141,
              4
            ],
            [
              142,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_send",
            "parameters": {
              "sock": "SOCKET",
              "buffer": "char",
              "size": "size_t",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "sock_bufferize(const char *buffer, int size, char *tempbuf, int *offset, int totsize, int checkonly, char *errbuf, int errbuflen)",
          "fn_dec_pos": [
            [
              143,
              4
            ],
            [
              143,
              133
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_bufferize",
            "parameters": {
              "buffer": "char",
              "size": "int",
              "tempbuf": "char",
              "offset": "int",
              "totsize": "int",
              "checkonly": "int",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "sock_discard(SOCKET sock, SSL *, int size, char *errbuf, int errbuflen)",
          "fn_dec_pos": [
            [
              144,
              4
            ],
            [
              144,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_discard",
            "parameters": {
              "sock": "SOCKET",
              "size": "int",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "sock_check_hostlist(char *hostlist, const char *sep, struct sockaddr_storage *from, char *errbuf, int errbuflen)",
          "fn_dec_pos": [
            [
              145,
              4
            ],
            [
              145,
              116
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_check_hostlist",
            "parameters": {
              "hostlist": "char",
              "sep": "char",
              "from": "struct sockaddr_storage",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "sock_cmpaddr(struct sockaddr_storage *first, struct sockaddr_storage *second)",
          "fn_dec_pos": [
            [
              146,
              4
            ],
            [
              146,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_cmpaddr",
            "parameters": {
              "first": "struct sockaddr_storage",
              "second": "struct sockaddr_storage"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "sock_getmyinfo(SOCKET sock, char *address, int addrlen, char *port, int portlen, int flags, char *errbuf, int errbuflen)",
          "fn_dec_pos": [
            [
              148,
              4
            ],
            [
              148,
              124
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_getmyinfo",
            "parameters": {
              "sock": "SOCKET",
              "address": "char",
              "addrlen": "int",
              "port": "char",
              "portlen": "int",
              "flags": "int",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "sock_getascii_addrport(const struct sockaddr_storage *sockaddr, char *address, int addrlen, char *port, int portlen, int flags, char *errbuf, int errbuflen)",
          "fn_dec_pos": [
            [
              150,
              4
            ],
            [
              150,
              160
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_getascii_addrport",
            "parameters": {
              "sockaddr": "struct sockaddr_storage",
              "address": "char",
              "addrlen": "int",
              "port": "char",
              "portlen": "int",
              "flags": "int",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "sock_present2network(const char *address, struct sockaddr_storage *sockaddr, int addr_family, char *errbuf, int errbuflen)",
          "fn_dec_pos": [
            [
              151,
              4
            ],
            [
              151,
              126
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sock_present2network",
            "parameters": {
              "address": "char",
              "sockaddr": "struct sockaddr_storage",
              "addr_family": "int",
              "errbuf": "char",
              "errbuflen": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct sockaddr",
          {},
          "",
          [
            61,
            29
          ],
          [
            61,
            44
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            132,
            4
          ],
          [
            132,
            19
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            132,
            28
          ],
          [
            132,
            43
          ]
        ],
        [
          "struct addrinfo",
          {},
          "",
          [
            138,
            17
          ],
          [
            138,
            32
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            145,
            57
          ],
          [
            145,
            80
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            146,
            17
          ],
          [
            146,
            40
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            146,
            49
          ],
          [
            146,
            72
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            150,
            33
          ],
          [
            150,
            56
          ]
        ],
        [
          "struct sockaddr_storage",
          {},
          "",
          [
            151,
            46
          ],
          [
            151,
            69
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"pcap/socket.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <unistd.h>\t/* close() */\n",
          [
            43,
            2
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include \"sslutils.h\"  // for SSL type, whatever that turns out to be\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-bt-linux.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "bt_findalldevs(pcap_if_list_t *devlistp, char *err_str)",
          "fn_dec_pos": [
            [
              36,
              4
            ],
            [
              36,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_findalldevs",
            "parameters": {
              "devlistp": "pcap_if_list_t",
              "err_str": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "bt_create(const char *device, char *ebuf, int *is_ours)",
          "fn_dec_pos": [
            [
              37,
              8
            ],
            [
              37,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bt_create",
            "parameters": {
              "device": "char",
              "ebuf": "char",
              "is_ours": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap-sita.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "acn_parse_hosts_file(char *errbuf)",
          "fn_dec_pos": [
            [
              6,
              11
            ],
            [
              6,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "acn_parse_hosts_file",
            "parameters": {
              "errbuf": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "acn_findalldevs(char *errbuf)",
          "fn_dec_pos": [
            [
              7,
              11
            ],
            [
              7,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "acn_findalldevs",
            "parameters": {
              "errbuf": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/lbl/os-osf4.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "pcap_snprintf(char *, size_t, const char *, ...)",
          "fn_dec_pos": [
            [
              22,
              4
            ],
            [
              22,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_snprintf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_vsnprintf(char *, size_t, const char *, va_list)",
          "fn_dec_pos": [
            [
              23,
              4
            ],
            [
              23,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_vsnprintf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pfopen(char *, int)",
          "fn_dec_pos": [
            [
              24,
              4
            ],
            [
              24,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pfopen",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/lbl/os-hpux11.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ffs(int i)",
          "fn_dec_pos": [
            [
              22,
              4
            ],
            [
              22,
              14
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ffs",
            "parameters": {
              "i": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/lbl/os-aix7.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ffs(int i)",
          "fn_dec_pos": [
            [
              22,
              4
            ],
            [
              22,
              14
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ffs",
            "parameters": {
              "i": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/lbl/os-sunos4.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "_filbuf(FILE *)",
          "fn_dec_pos": [
            [
              23,
              4
            ],
            [
              23,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_filbuf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "_flsbuf(u_char, FILE *)",
          "fn_dec_pos": [
            [
              24,
              4
            ],
            [
              24,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_flsbuf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "fclose(FILE *)",
          "fn_dec_pos": [
            [
              25,
              4
            ],
            [
              25,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fclose",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "fflush(FILE *)",
          "fn_dec_pos": [
            [
              26,
              4
            ],
            [
              26,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fflush",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "fgetc(FILE *)",
          "fn_dec_pos": [
            [
              27,
              4
            ],
            [
              27,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fgetc",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "fprintf(FILE *, const char *, ...)",
          "fn_dec_pos": [
            [
              28,
              4
            ],
            [
              28,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fprintf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "fputc(int, FILE *)",
          "fn_dec_pos": [
            [
              29,
              4
            ],
            [
              29,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fputc",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "fputs(const char *, FILE *)",
          "fn_dec_pos": [
            [
              30,
              4
            ],
            [
              30,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fputs",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "fread(void *, u_int, u_int, FILE *)",
          "fn_dec_pos": [
            [
              31,
              6
            ],
            [
              31,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fread",
            "parameters": {},
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "fseek(FILE *, long, int)",
          "fn_dec_pos": [
            [
              32,
              4
            ],
            [
              32,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fseek",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "fwrite(const void *, u_int, u_int, FILE *)",
          "fn_dec_pos": [
            [
              33,
              6
            ],
            [
              33,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fwrite",
            "parameters": {},
            "return_type": "u_int"
          }
        },
        {
          "fn_code": "pclose(FILE *)",
          "fn_dec_pos": [
            [
              34,
              4
            ],
            [
              34,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pclose",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "rewind(FILE *)",
          "fn_dec_pos": [
            [
              35,
              5
            ],
            [
              35,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rewind",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "setbuf(FILE *, char *)",
          "fn_dec_pos": [
            [
              36,
              5
            ],
            [
              36,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setbuf",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "setlinebuf(FILE *)",
          "fn_dec_pos": [
            [
              37,
              4
            ],
            [
              37,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setlinebuf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "ungetc(int, FILE *)",
          "fn_dec_pos": [
            [
              38,
              4
            ],
            [
              38,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ungetc",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "vfprintf(FILE *, const char *, ...)",
          "fn_dec_pos": [
            [
              39,
              4
            ],
            [
              39,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "vfprintf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "vprintf(const char *, ...)",
          "fn_dec_pos": [
            [
              40,
              4
            ],
            [
              40,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "vprintf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "read(int, char *, u_int)",
          "fn_dec_pos": [
            [
              44,
              4
            ],
            [
              44,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "write(int, char *, u_int)",
          "fn_dec_pos": [
            [
              45,
              4
            ],
            [
              45,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "write",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "a64l(const char *)",
          "fn_dec_pos": [
            [
              48,
              5
            ],
            [
              48,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "a64l",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "accept(int, struct sockaddr *, int *)",
          "fn_dec_pos": [
            [
              52,
              4
            ],
            [
              52,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "accept",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "bind(int, struct sockaddr *, int)",
          "fn_dec_pos": [
            [
              53,
              4
            ],
            [
              53,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bind",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "bcmp(const void *, const void *, u_int)",
          "fn_dec_pos": [
            [
              54,
              4
            ],
            [
              54,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bcmp",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "bcopy(const void *, void *, u_int)",
          "fn_dec_pos": [
            [
              55,
              5
            ],
            [
              55,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bcopy",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "bzero(void *, int)",
          "fn_dec_pos": [
            [
              56,
              5
            ],
            [
              56,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bzero",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "chroot(const char *)",
          "fn_dec_pos": [
            [
              57,
              4
            ],
            [
              57,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "chroot",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "close(int)",
          "fn_dec_pos": [
            [
              58,
              4
            ],
            [
              58,
              14
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "close",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "closelog(void)",
          "fn_dec_pos": [
            [
              59,
              5
            ],
            [
              59,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "closelog",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "connect(int, struct sockaddr *, int)",
          "fn_dec_pos": [
            [
              60,
              4
            ],
            [
              60,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "connect",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "crypt(const char *, const char *)",
          "fn_dec_pos": [
            [
              61,
              6
            ],
            [
              61,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crypt",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "daemon(int, int)",
          "fn_dec_pos": [
            [
              62,
              4
            ],
            [
              62,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "fchmod(int, int)",
          "fn_dec_pos": [
            [
              63,
              4
            ],
            [
              63,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fchmod",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "fchown(int, int, int)",
          "fn_dec_pos": [
            [
              64,
              4
            ],
            [
              64,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fchown",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "endgrent(void)",
          "fn_dec_pos": [
            [
              65,
              5
            ],
            [
              65,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "endgrent",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "endpwent(void)",
          "fn_dec_pos": [
            [
              66,
              5
            ],
            [
              66,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "endpwent",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "ether_aton(const char *)",
          "fn_dec_pos": [
            [
              70,
              19
            ],
            [
              70,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ether_aton",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "flock(int, int)",
          "fn_dec_pos": [
            [
              71,
              4
            ],
            [
              71,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "flock",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "fstat(int, struct stat *)",
          "fn_dec_pos": [
            [
              75,
              4
            ],
            [
              75,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fstat",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "fstatfs(int, struct statfs *)",
          "fn_dec_pos": [
            [
              79,
              4
            ],
            [
              79,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fstatfs",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "fsync(int)",
          "fn_dec_pos": [
            [
              80,
              4
            ],
            [
              80,
              14
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fsync",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "ftime(struct timeb *)",
          "fn_dec_pos": [
            [
              84,
              4
            ],
            [
              84,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ftime",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "ftruncate(int, off_t)",
          "fn_dec_pos": [
            [
              85,
              4
            ],
            [
              85,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ftruncate",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "getdtablesize(void)",
          "fn_dec_pos": [
            [
              86,
              4
            ],
            [
              86,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getdtablesize",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "gethostid(void)",
          "fn_dec_pos": [
            [
              87,
              5
            ],
            [
              87,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gethostid",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gethostname(char *, int)",
          "fn_dec_pos": [
            [
              88,
              4
            ],
            [
              88,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gethostname",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "getopt(int, char * const *, const char *)",
          "fn_dec_pos": [
            [
              89,
              4
            ],
            [
              89,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "getpagesize(void)",
          "fn_dec_pos": [
            [
              90,
              4
            ],
            [
              90,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getpagesize",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "getpass(char *)",
          "fn_dec_pos": [
            [
              91,
              6
            ],
            [
              91,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getpass",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "getpeername(int, struct sockaddr *, int *)",
          "fn_dec_pos": [
            [
              92,
              4
            ],
            [
              92,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getpeername",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "getpriority(int, int)",
          "fn_dec_pos": [
            [
              93,
              4
            ],
            [
              93,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getpriority",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "getrlimit(int, struct rlimit *)",
          "fn_dec_pos": [
            [
              97,
              4
            ],
            [
              97,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getrlimit",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "getsockname(int, struct sockaddr *, int *)",
          "fn_dec_pos": [
            [
              98,
              4
            ],
            [
              98,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getsockname",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "getsockopt(int, int, int, char *, int *)",
          "fn_dec_pos": [
            [
              99,
              4
            ],
            [
              99,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getsockopt",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "gettimeofday(struct timeval *, struct timezone *)",
          "fn_dec_pos": [
            [
              104,
              4
            ],
            [
              104,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gettimeofday",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "getusershell(void)",
          "fn_dec_pos": [
            [
              105,
              6
            ],
            [
              105,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getusershell",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "getwd(char *)",
          "fn_dec_pos": [
            [
              106,
              6
            ],
            [
              106,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getwd",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "initgroups(const char *, int)",
          "fn_dec_pos": [
            [
              107,
              4
            ],
            [
              107,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initgroups",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "ioctl(int, int, caddr_t)",
          "fn_dec_pos": [
            [
              108,
              4
            ],
            [
              108,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ioctl",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "iruserok(u_long, int, char *, char *)",
          "fn_dec_pos": [
            [
              109,
              4
            ],
            [
              109,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iruserok",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "isatty(int)",
          "fn_dec_pos": [
            [
              110,
              4
            ],
            [
              110,
              15
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "isatty",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "killpg(int, int)",
          "fn_dec_pos": [
            [
              111,
              4
            ],
            [
              111,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "killpg",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "listen(int, int)",
          "fn_dec_pos": [
            [
              112,
              4
            ],
            [
              112,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "listen",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "login(struct utmp *)",
          "fn_dec_pos": [
            [
              116,
              5
            ],
            [
              116,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "login",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "logout(const char *)",
          "fn_dec_pos": [
            [
              117,
              4
            ],
            [
              117,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "logout",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "lseek(int, off_t, int)",
          "fn_dec_pos": [
            [
              118,
              6
            ],
            [
              118,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lseek",
            "parameters": {},
            "return_type": "off_t"
          }
        },
        {
          "fn_code": "lstat(const char *, struct stat *)",
          "fn_dec_pos": [
            [
              119,
              4
            ],
            [
              119,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lstat",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "mkstemp(char *)",
          "fn_dec_pos": [
            [
              120,
              4
            ],
            [
              120,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mkstemp",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "mktemp(char *)",
          "fn_dec_pos": [
            [
              121,
              6
            ],
            [
              121,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mktemp",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "munmap(caddr_t, int)",
          "fn_dec_pos": [
            [
              122,
              4
            ],
            [
              122,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "munmap",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "openlog(const char *, int, int)",
          "fn_dec_pos": [
            [
              123,
              5
            ],
            [
              123,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "openlog",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "perror(const char *)",
          "fn_dec_pos": [
            [
              124,
              5
            ],
            [
              124,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "perror",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "printf(const char *, ...)",
          "fn_dec_pos": [
            [
              125,
              4
            ],
            [
              125,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "printf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "puts(const char *)",
          "fn_dec_pos": [
            [
              126,
              4
            ],
            [
              126,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "puts",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "random(void)",
          "fn_dec_pos": [
            [
              127,
              5
            ],
            [
              127,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "random",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "readlink(const char *, char *, int)",
          "fn_dec_pos": [
            [
              128,
              4
            ],
            [
              128,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readlink",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "readv(int, struct iovec *, int)",
          "fn_dec_pos": [
            [
              132,
              4
            ],
            [
              132,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readv",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "recv(int, char *, u_int, int)",
          "fn_dec_pos": [
            [
              133,
              4
            ],
            [
              133,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "recv",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "recvfrom(int, char *, u_int, int, struct sockaddr *, int *)",
          "fn_dec_pos": [
            [
              134,
              4
            ],
            [
              134,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "recvfrom",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "rename(const char *, const char *)",
          "fn_dec_pos": [
            [
              135,
              4
            ],
            [
              135,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rename",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "rcmd(char **, u_short, char *, char *, char *, int *)",
          "fn_dec_pos": [
            [
              136,
              4
            ],
            [
              136,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rcmd",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "rresvport(int *)",
          "fn_dec_pos": [
            [
              137,
              4
            ],
            [
              137,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rresvport",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "send(int, char *, u_int, int)",
          "fn_dec_pos": [
            [
              138,
              4
            ],
            [
              138,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "send",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "sendto(int, char *, u_int, int, struct sockaddr *, int)",
          "fn_dec_pos": [
            [
              139,
              4
            ],
            [
              139,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sendto",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "setenv(const char *, const char *, int)",
          "fn_dec_pos": [
            [
              140,
              4
            ],
            [
              140,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setenv",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "seteuid(int)",
          "fn_dec_pos": [
            [
              141,
              4
            ],
            [
              141,
              16
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "seteuid",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "setpriority(int, int, int)",
          "fn_dec_pos": [
            [
              142,
              4
            ],
            [
              142,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setpriority",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "select(int, fd_set *, fd_set *, fd_set *, struct timeval *)",
          "fn_dec_pos": [
            [
              143,
              4
            ],
            [
              143,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "select",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "setpgrp(int, int)",
          "fn_dec_pos": [
            [
              144,
              4
            ],
            [
              144,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setpgrp",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "setpwent(void)",
          "fn_dec_pos": [
            [
              145,
              5
            ],
            [
              145,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setpwent",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "setrlimit(int, struct rlimit *)",
          "fn_dec_pos": [
            [
              146,
              4
            ],
            [
              146,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setrlimit",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "setsockopt(int, int, int, char *, int)",
          "fn_dec_pos": [
            [
              147,
              4
            ],
            [
              147,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setsockopt",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "shutdown(int, int)",
          "fn_dec_pos": [
            [
              148,
              4
            ],
            [
              148,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "shutdown",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "sigblock(int)",
          "fn_dec_pos": [
            [
              149,
              4
            ],
            [
              149,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sigblock",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*signal (int, void (*) (int))) (int)",
          "fn_dec_pos": [
            [
              150,
              5
            ],
            [
              150,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "signal (int, void (*) (int))",
          "fn_dec_pos": [
            [
              150,
              7
            ],
            [
              150,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "signal",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "sigpause(int)",
          "fn_dec_pos": [
            [
              151,
              4
            ],
            [
              151,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sigpause",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "sigsetmask(int)",
          "fn_dec_pos": [
            [
              152,
              4
            ],
            [
              152,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sigsetmask",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "sigvec(int, struct sigvec *, struct sigvec*)",
          "fn_dec_pos": [
            [
              156,
              4
            ],
            [
              156,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sigvec",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_snprintf(char *, size_t, const char *, ...)",
          "fn_dec_pos": [
            [
              157,
              4
            ],
            [
              157,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_snprintf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "socket(int, int, int)",
          "fn_dec_pos": [
            [
              158,
              4
            ],
            [
              158,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "socket",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "socketpair(int, int, int, int *)",
          "fn_dec_pos": [
            [
              159,
              4
            ],
            [
              159,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "socketpair",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "symlink(const char *, const char *)",
          "fn_dec_pos": [
            [
              160,
              4
            ],
            [
              160,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "symlink",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "srandom(int)",
          "fn_dec_pos": [
            [
              161,
              5
            ],
            [
              161,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "srandom",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "sscanf(char *, const char *, ...)",
          "fn_dec_pos": [
            [
              162,
              4
            ],
            [
              162,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sscanf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "stat(const char *, struct stat *)",
          "fn_dec_pos": [
            [
              163,
              4
            ],
            [
              163,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "stat",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "statfs(char *, struct statfs *)",
          "fn_dec_pos": [
            [
              164,
              4
            ],
            [
              164,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "statfs",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "strerror(int)",
          "fn_dec_pos": [
            [
              165,
              6
            ],
            [
              165,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strerror",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "strcasecmp(const char *, const char *)",
          "fn_dec_pos": [
            [
              166,
              4
            ],
            [
              166,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strcasecmp",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "strftime(char *, int, char *, struct tm *)",
          "fn_dec_pos": [
            [
              170,
              4
            ],
            [
              170,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strftime",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "strncasecmp(const char *, const char *, int)",
          "fn_dec_pos": [
            [
              171,
              4
            ],
            [
              171,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strncasecmp",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "strtol(const char *, char **, int)",
          "fn_dec_pos": [
            [
              172,
              5
            ],
            [
              172,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strtol",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "sync(void)",
          "fn_dec_pos": [
            [
              173,
              5
            ],
            [
              173,
              15
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sync",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "syslog(int, const char *, ...)",
          "fn_dec_pos": [
            [
              174,
              5
            ],
            [
              174,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "syslog",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "system(const char *)",
          "fn_dec_pos": [
            [
              175,
              4
            ],
            [
              175,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "system",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "tell(int)",
          "fn_dec_pos": [
            [
              176,
              5
            ],
            [
              176,
              14
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tell",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "time(time_t *)",
          "fn_dec_pos": [
            [
              177,
              7
            ],
            [
              177,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "time",
            "parameters": {},
            "return_type": "time_t"
          }
        },
        {
          "fn_code": "timezone(int, int)",
          "fn_dec_pos": [
            [
              178,
              6
            ],
            [
              178,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "timezone",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "tolower(int)",
          "fn_dec_pos": [
            [
              179,
              4
            ],
            [
              179,
              16
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tolower",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "toupper(int)",
          "fn_dec_pos": [
            [
              180,
              4
            ],
            [
              180,
              16
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "toupper",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "truncate(char *, off_t)",
          "fn_dec_pos": [
            [
              181,
              4
            ],
            [
              181,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "truncate",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "unsetenv(const char *)",
          "fn_dec_pos": [
            [
              182,
              5
            ],
            [
              182,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unsetenv",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "vfork(void)",
          "fn_dec_pos": [
            [
              183,
              4
            ],
            [
              183,
              15
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "vfork",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "vsprintf(char *, const char *, ...)",
          "fn_dec_pos": [
            [
              184,
              4
            ],
            [
              184,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "vsprintf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "writev(int, struct iovec *, int)",
          "fn_dec_pos": [
            [
              185,
              4
            ],
            [
              185,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "writev",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "utimes(const char *, struct timeval *)",
          "fn_dec_pos": [
            [
              189,
              4
            ],
            [
              189,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "utimes",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "wait(int *)",
          "fn_dec_pos": [
            [
              191,
              4
            ],
            [
              191,
              15
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "wait",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "wait3(int *, int, struct rusage *)",
          "fn_dec_pos": [
            [
              192,
              6
            ],
            [
              192,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "wait3",
            "parameters": {},
            "return_type": "pid_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct\tsockaddr",
          {},
          "",
          [
            50,
            0
          ],
          [
            50,
            15
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            52,
            16
          ],
          [
            52,
            31
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            53,
            14
          ],
          [
            53,
            29
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            60,
            17
          ],
          [
            60,
            32
          ]
        ],
        [
          "struct\tether_addr",
          {},
          "",
          [
            68,
            0
          ],
          [
            68,
            17
          ]
        ],
        [
          "struct\tether_addr",
          {},
          "",
          [
            70,
            0
          ],
          [
            70,
            17
          ]
        ],
        [
          "struct\tstat",
          {},
          "",
          [
            73,
            0
          ],
          [
            73,
            11
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            75,
            15
          ],
          [
            75,
            26
          ]
        ],
        [
          "struct statfs",
          {},
          "",
          [
            77,
            0
          ],
          [
            77,
            13
          ]
        ],
        [
          "struct statfs",
          {},
          "",
          [
            79,
            17
          ],
          [
            79,
            30
          ]
        ],
        [
          "struct timeb",
          {},
          "",
          [
            82,
            0
          ],
          [
            82,
            12
          ]
        ],
        [
          "struct timeb",
          {},
          "",
          [
            84,
            10
          ],
          [
            84,
            22
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            92,
            21
          ],
          [
            92,
            36
          ]
        ],
        [
          "struct\trlimit",
          {},
          "",
          [
            95,
            0
          ],
          [
            95,
            13
          ]
        ],
        [
          "struct rlimit",
          {},
          "",
          [
            97,
            19
          ],
          [
            97,
            32
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            98,
            21
          ],
          [
            98,
            36
          ]
        ],
        [
          "struct\ttimeval",
          {},
          "",
          [
            101,
            0
          ],
          [
            101,
            14
          ]
        ],
        [
          "struct\ttimezone",
          {},
          "",
          [
            102,
            0
          ],
          [
            102,
            15
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            104,
            17
          ],
          [
            104,
            31
          ]
        ],
        [
          "struct timezone",
          {},
          "",
          [
            104,
            35
          ],
          [
            104,
            50
          ]
        ],
        [
          "struct\tutmp",
          {},
          "",
          [
            114,
            0
          ],
          [
            114,
            11
          ]
        ],
        [
          "struct utmp",
          {},
          "",
          [
            116,
            11
          ],
          [
            116,
            22
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            119,
            24
          ],
          [
            119,
            35
          ]
        ],
        [
          "struct\tiovec",
          {},
          "",
          [
            130,
            0
          ],
          [
            130,
            12
          ]
        ],
        [
          "struct iovec",
          {},
          "",
          [
            132,
            15
          ],
          [
            132,
            27
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            134,
            38
          ],
          [
            134,
            53
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            139,
            36
          ],
          [
            139,
            51
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            143,
            46
          ],
          [
            143,
            60
          ]
        ],
        [
          "struct rlimit",
          {},
          "",
          [
            146,
            19
          ],
          [
            146,
            32
          ]
        ],
        [
          "struct\tsigvec",
          {},
          "",
          [
            154,
            0
          ],
          [
            154,
            13
          ]
        ],
        [
          "struct sigvec",
          {},
          "",
          [
            156,
            16
          ],
          [
            156,
            29
          ]
        ],
        [
          "struct sigvec",
          {},
          "",
          [
            156,
            33
          ],
          [
            156,
            46
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            163,
            23
          ],
          [
            163,
            34
          ]
        ],
        [
          "struct statfs",
          {},
          "",
          [
            164,
            19
          ],
          [
            164,
            32
          ]
        ],
        [
          "struct\ttm",
          {},
          "",
          [
            168,
            0
          ],
          [
            168,
            9
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            170,
            34
          ],
          [
            170,
            43
          ]
        ],
        [
          "struct iovec",
          {},
          "",
          [
            185,
            16
          ],
          [
            185,
            28
          ]
        ],
        [
          "struct\trusage",
          {},
          "",
          [
            187,
            0
          ],
          [
            187,
            13
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            189,
            25
          ],
          [
            189,
            39
          ]
        ],
        [
          "struct rusage",
          {},
          "",
          [
            192,
            24
          ],
          [
            192,
            37
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/lbl/os-aix4.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ffs(int i)",
          "fn_dec_pos": [
            [
              22,
              4
            ],
            [
              22,
              14
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ffs",
            "parameters": {
              "i": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/lbl/os-ultrix4.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "bcmp(const char *, const char *, u_int)",
          "fn_dec_pos": [
            [
              22,
              4
            ],
            [
              22,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bcmp",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "bcopy(const void *, void *, u_int)",
          "fn_dec_pos": [
            [
              23,
              5
            ],
            [
              23,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bcopy",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "bzero(void *, u_int)",
          "fn_dec_pos": [
            [
              24,
              5
            ],
            [
              24,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bzero",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "getopt(int, char * const *, const char *)",
          "fn_dec_pos": [
            [
              25,
              4
            ],
            [
              25,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "gettimeofday(struct timeval *, struct timezone *)",
          "fn_dec_pos": [
            [
              30,
              4
            ],
            [
              30,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gettimeofday",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "ioctl(int, int, caddr_t)",
          "fn_dec_pos": [
            [
              31,
              4
            ],
            [
              31,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ioctl",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pfopen(char *, int)",
          "fn_dec_pos": [
            [
              32,
              4
            ],
            [
              32,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pfopen",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "setlinebuf(FILE *)",
          "fn_dec_pos": [
            [
              33,
              4
            ],
            [
              33,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setlinebuf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "socket(int, int, int)",
          "fn_dec_pos": [
            [
              34,
              4
            ],
            [
              34,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "socket",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "strcasecmp(const char *, const char *)",
          "fn_dec_pos": [
            [
              35,
              4
            ],
            [
              35,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strcasecmp",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct timeval",
          {},
          "",
          [
            27,
            0
          ],
          [
            27,
            14
          ]
        ],
        [
          "struct timezone",
          {},
          "",
          [
            28,
            0
          ],
          [
            28,
            15
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            30,
            17
          ],
          [
            30,
            31
          ]
        ],
        [
          "struct timezone",
          {},
          "",
          [
            30,
            35
          ],
          [
            30,
            50
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/lbl/os-solaris2.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "strerror(int)",
          "fn_dec_pos": [
            [
              22,
              9
            ],
            [
              22,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strerror",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_snprintf(char *, size_t, const char *, ...)",
          "fn_dec_pos": [
            [
              23,
              4
            ],
            [
              23,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_snprintf",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/lbl/os-osf5.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "pcap_snprintf(char *, size_t, const char *, ...)",
          "fn_dec_pos": [
            [
              26,
              4
            ],
            [
              26,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_snprintf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pcap_vsnprintf(char *, size_t, const char *, va_list)",
          "fn_dec_pos": [
            [
              27,
              4
            ],
            [
              27,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_vsnprintf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "pfopen(char *, int)",
          "fn_dec_pos": [
            [
              28,
              4
            ],
            [
              28,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pfopen",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap/namedb.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "pcap_next_etherent(FILE *)",
          "fn_dec_pos": [
            [
              57,
              31
            ],
            [
              57,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_next_etherent",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_ether_hostton(const char*)",
          "fn_dec_pos": [
            [
              58,
              17
            ],
            [
              58,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_ether_hostton",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_ether_aton(const char *)",
          "fn_dec_pos": [
            [
              59,
              17
            ],
            [
              59,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_ether_aton",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_nametoaddr(const char *)",
          "fn_dec_pos": [
            [
              61,
              23
            ],
            [
              61,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_nametoaddrinfo(const char *)",
          "fn_dec_pos": [
            [
              63,
              26
            ],
            [
              63,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_nametoaddrinfo",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "bpf_u_int32 pcap_nametonetaddr(const char *)",
          "fn_dec_pos": [
            [
              64,
              9
            ],
            [
              64,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_u_int32 pcap_nametonetaddr",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_nametoport(const char *, int *, int *)",
          "fn_dec_pos": [
            [
              66,
              13
            ],
            [
              66,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_nametoport",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_nametoportrange(const char *, int *, int *, int *)",
          "fn_dec_pos": [
            [
              67,
              13
            ],
            [
              67,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_nametoportrange",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_nametoproto(const char *)",
          "fn_dec_pos": [
            [
              68,
              13
            ],
            [
              68,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_nametoproto",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_nametoeproto(const char *)",
          "fn_dec_pos": [
            [
              69,
              13
            ],
            [
              69,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_nametoeproto",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_nametollc(const char *)",
          "fn_dec_pos": [
            [
              70,
              13
            ],
            [
              70,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_nametollc",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_etherent {\n\tu_char addr[6];\n\tchar name[122];\n}",
          {
            "addr[6]": "u_char",
            "name[122]": "char"
          },
          "pcap_etherent",
          [
            50,
            0
          ],
          [
            53,
            1
          ]
        ],
        [
          "struct pcap_etherent {\n\tu_char addr[6];\n\tchar name[122];\n}",
          {
            "addr[6]": "u_char",
            "name[122]": "char"
          },
          "pcap_etherent",
          [
            50,
            0
          ],
          [
            53,
            1
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap/dlt.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap/sll.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct sll_header {\n\tuint16_t sll_pkttype;\t\t/* packet type */\n\tuint16_t sll_hatype;\t\t/* link-layer address type */\n\tuint16_t sll_halen;\t\t/* link-layer address length */\n\tuint8_t  sll_addr[SLL_ADDRLEN];\t/* link-layer address */\n\tuint16_t sll_protocol;\t\t/* protocol */\n}",
          {
            "sll_pkttype": "uint16_t",
            "sll_hatype": "uint16_t",
            "sll_halen": "uint16_t",
            "sll_addr[SLL_ADDRLEN]": "uint8_t",
            "sll_protocol": "uint16_t"
          },
          "sll_header",
          [
            84,
            0
          ],
          [
            90,
            1
          ]
        ],
        [
          "struct sll2_header {\n\tuint16_t sll2_protocol;\t\t\t/* protocol */\n\tuint16_t sll2_reserved_mbz;\t\t/* reserved - must be zero */\n\tuint32_t sll2_if_index;\t\t\t/* 1-based interface index */\n\tuint16_t sll2_hatype;\t\t\t/* link-layer address type */\n\tuint8_t  sll2_pkttype;\t\t\t/* packet type */\n\tuint8_t  sll2_halen;\t\t\t/* link-layer address length */\n\tuint8_t  sll2_addr[SLL_ADDRLEN];\t/* link-layer address */\n}",
          {
            "sll2_protocol": "uint16_t",
            "sll2_reserved_mbz": "uint16_t",
            "sll2_if_index": "uint32_t",
            "sll2_hatype": "uint16_t",
            "sll2_pkttype": "uint8_t",
            "sll2_halen": "uint8_t",
            "sll2_addr[SLL_ADDRLEN]": "uint8_t"
          },
          "sll2_header",
          [
            97,
            0
          ],
          [
            105,
            1
          ]
        ],
        [
          "struct sll_header {\n\tuint16_t sll_pkttype;\t\t/* packet type */\n\tuint16_t sll_hatype;\t\t/* link-layer address type */\n\tuint16_t sll_halen;\t\t/* link-layer address length */\n\tuint8_t  sll_addr[SLL_ADDRLEN];\t/* link-layer address */\n\tuint16_t sll_protocol;\t\t/* protocol */\n}",
          {
            "sll_pkttype": "uint16_t",
            "sll_hatype": "uint16_t",
            "sll_halen": "uint16_t",
            "sll_addr[SLL_ADDRLEN]": "uint8_t",
            "sll_protocol": "uint16_t"
          },
          "sll_header",
          [
            84,
            0
          ],
          [
            90,
            1
          ]
        ],
        [
          "struct sll2_header {\n\tuint16_t sll2_protocol;\t\t\t/* protocol */\n\tuint16_t sll2_reserved_mbz;\t\t/* reserved - must be zero */\n\tuint32_t sll2_if_index;\t\t\t/* 1-based interface index */\n\tuint16_t sll2_hatype;\t\t\t/* link-layer address type */\n\tuint8_t  sll2_pkttype;\t\t\t/* packet type */\n\tuint8_t  sll2_halen;\t\t\t/* link-layer address length */\n\tuint8_t  sll2_addr[SLL_ADDRLEN];\t/* link-layer address */\n}",
          {
            "sll2_protocol": "uint16_t",
            "sll2_reserved_mbz": "uint16_t",
            "sll2_if_index": "uint32_t",
            "sll2_hatype": "uint16_t",
            "sll2_pkttype": "uint8_t",
            "sll2_halen": "uint8_t",
            "sll2_addr[SLL_ADDRLEN]": "uint8_t"
          },
          "sll2_header",
          [
            97,
            0
          ],
          [
            105,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include <pcap/pcap-inttypes.h>\n",
          [
            76,
            0
          ],
          [
            77,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap/bluetooth.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct _pcap_bluetooth_h4_header {\n\tuint32_t direction; /* if first bit is set direction is incoming */\n} pcap_bluetooth_h4_header;",
          {
            "direction": "uint32_t"
          },
          "pcap_bluetooth_h4_header",
          [
            42,
            0
          ],
          [
            44,
            27
          ]
        ],
        [
          "typedef struct _pcap_bluetooth_linux_monitor_header {\n\tuint16_t adapter_id;\n\tuint16_t opcode;\n} pcap_bluetooth_linux_monitor_header;",
          {
            "adapter_id": "uint16_t",
            "opcode": "uint16_t"
          },
          "pcap_bluetooth_linux_monitor_header",
          [
            50,
            0
          ],
          [
            53,
            38
          ]
        ],
        [
          "typedef struct _pcap_bluetooth_h4_header {\n\tuint32_t direction; /* if first bit is set direction is incoming */\n} pcap_bluetooth_h4_header;",
          {
            "direction": "uint32_t"
          },
          "pcap_bluetooth_h4_header",
          [
            42,
            0
          ],
          [
            44,
            27
          ]
        ],
        [
          "typedef struct _pcap_bluetooth_linux_monitor_header {\n\tuint16_t adapter_id;\n\tuint16_t opcode;\n} pcap_bluetooth_linux_monitor_header;",
          {
            "adapter_id": "uint16_t",
            "opcode": "uint16_t"
          },
          "pcap_bluetooth_linux_monitor_header",
          [
            50,
            0
          ],
          [
            53,
            38
          ]
        ]
      ],
      "include_list": [
        [
          "#include <pcap/pcap-inttypes.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap/funcattrs.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <pcap/compiler-tests.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <sal.h>\n",
          [
            252,
            1
          ],
          [
            253,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap/nflog.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct nflog_hdr {\n\tuint8_t\t\tnflog_family;\t/* address family */\n\tuint8_t\t\tnflog_version;\t/* version */\n\tuint16_t\tnflog_rid;\t/* resource ID */\n} nflog_hdr_t;",
          {
            "nflog_family": "uint8_t",
            "nflog_version": "uint8_t",
            "nflog_rid": "uint16_t"
          },
          "nflog_hdr_t",
          [
            43,
            0
          ],
          [
            47,
            14
          ]
        ],
        [
          "typedef struct nflog_tlv {\n\tuint16_t\ttlv_length;\t/* tlv length */\n\tuint16_t\ttlv_type;\t/* tlv type */\n\t/* value follows this */\n} nflog_tlv_t;",
          {
            "tlv_length": "uint16_t",
            "tlv_type": "uint16_t"
          },
          "nflog_tlv_t",
          [
            49,
            0
          ],
          [
            53,
            14
          ]
        ],
        [
          "typedef struct nflog_packet_hdr {\n\tuint16_t\thw_protocol;\t/* hw protocol */\n\tuint8_t\t\thook;\t\t/* netfilter hook */\n\tuint8_t\t\tpad;\t\t/* padding to 32 bits */\n} nflog_packet_hdr_t;",
          {
            "hw_protocol": "uint16_t",
            "hook": "uint8_t",
            "pad": "uint8_t"
          },
          "nflog_packet_hdr_t",
          [
            55,
            0
          ],
          [
            59,
            21
          ]
        ],
        [
          "typedef struct nflog_hwaddr {\n\tuint16_t\thw_addrlen;\t/* address length */\n\tuint16_t\tpad;\t\t/* padding to 32-bit boundary */\n\tuint8_t\t\thw_addr[8];\t/* address, up to 8 bytes */\n} nflog_hwaddr_t;",
          {
            "hw_addrlen": "uint16_t",
            "pad": "uint16_t",
            "hw_addr[8]": "uint8_t"
          },
          "nflog_hwaddr_t",
          [
            61,
            0
          ],
          [
            65,
            17
          ]
        ],
        [
          "typedef struct nflog_timestamp {\n\tuint64_t\tsec;\n\tuint64_t\tusec;\n} nflog_timestamp_t;",
          {
            "sec": "uint64_t",
            "usec": "uint64_t"
          },
          "nflog_timestamp_t",
          [
            67,
            0
          ],
          [
            70,
            20
          ]
        ],
        [
          "typedef struct nflog_hdr {\n\tuint8_t\t\tnflog_family;\t/* address family */\n\tuint8_t\t\tnflog_version;\t/* version */\n\tuint16_t\tnflog_rid;\t/* resource ID */\n} nflog_hdr_t;",
          {
            "nflog_family": "uint8_t",
            "nflog_version": "uint8_t",
            "nflog_rid": "uint16_t"
          },
          "nflog_hdr_t",
          [
            43,
            0
          ],
          [
            47,
            14
          ]
        ],
        [
          "typedef struct nflog_tlv {\n\tuint16_t\ttlv_length;\t/* tlv length */\n\tuint16_t\ttlv_type;\t/* tlv type */\n\t/* value follows this */\n} nflog_tlv_t;",
          {
            "tlv_length": "uint16_t",
            "tlv_type": "uint16_t"
          },
          "nflog_tlv_t",
          [
            49,
            0
          ],
          [
            53,
            14
          ]
        ],
        [
          "typedef struct nflog_packet_hdr {\n\tuint16_t\thw_protocol;\t/* hw protocol */\n\tuint8_t\t\thook;\t\t/* netfilter hook */\n\tuint8_t\t\tpad;\t\t/* padding to 32 bits */\n} nflog_packet_hdr_t;",
          {
            "hw_protocol": "uint16_t",
            "hook": "uint8_t",
            "pad": "uint8_t"
          },
          "nflog_packet_hdr_t",
          [
            55,
            0
          ],
          [
            59,
            21
          ]
        ],
        [
          "typedef struct nflog_hwaddr {\n\tuint16_t\thw_addrlen;\t/* address length */\n\tuint16_t\tpad;\t\t/* padding to 32-bit boundary */\n\tuint8_t\t\thw_addr[8];\t/* address, up to 8 bytes */\n} nflog_hwaddr_t;",
          {
            "hw_addrlen": "uint16_t",
            "pad": "uint16_t",
            "hw_addr[8]": "uint8_t"
          },
          "nflog_hwaddr_t",
          [
            61,
            0
          ],
          [
            65,
            17
          ]
        ],
        [
          "typedef struct nflog_timestamp {\n\tuint64_t\tsec;\n\tuint64_t\tusec;\n} nflog_timestamp_t;",
          {
            "sec": "uint64_t",
            "usec": "uint64_t"
          },
          "nflog_timestamp_t",
          [
            67,
            0
          ],
          [
            70,
            20
          ]
        ]
      ],
      "include_list": [
        [
          "#include <pcap/pcap-inttypes.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap/pcap.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*pcap_handler)(u_char *, const struct pcap_pkthdr *,\n\t\t\t     const u_char *)",
          "fn_dec_pos": [
            [
              286,
              13
            ],
            [
              287,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_lookupdev(char *)",
          "fn_dec_pos": [
            [
              328,
              15
            ],
            [
              328,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lookupdev",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_lookupnet(const char *, bpf_u_int32 *, bpf_u_int32 *, char *)",
          "fn_dec_pos": [
            [
              331,
              13
            ],
            [
              331,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lookupnet",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_create(const char *, char *)",
          "fn_dec_pos": [
            [
              333,
              17
            ],
            [
              333,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_create",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_set_snaplen(pcap_t *, int)",
          "fn_dec_pos": [
            [
              334,
              13
            ],
            [
              334,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_snaplen",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_set_promisc(pcap_t *, int)",
          "fn_dec_pos": [
            [
              335,
              13
            ],
            [
              335,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_promisc",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_can_set_rfmon(pcap_t *)",
          "fn_dec_pos": [
            [
              336,
              13
            ],
            [
              336,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_can_set_rfmon",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_set_rfmon(pcap_t *, int)",
          "fn_dec_pos": [
            [
              337,
              13
            ],
            [
              337,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_rfmon",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_set_timeout(pcap_t *, int)",
          "fn_dec_pos": [
            [
              338,
              13
            ],
            [
              338,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_timeout",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_set_tstamp_type(pcap_t *, int)",
          "fn_dec_pos": [
            [
              339,
              13
            ],
            [
              339,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_tstamp_type",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_set_immediate_mode(pcap_t *, int)",
          "fn_dec_pos": [
            [
              340,
              13
            ],
            [
              340,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_immediate_mode",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_set_buffer_size(pcap_t *, int)",
          "fn_dec_pos": [
            [
              341,
              13
            ],
            [
              341,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_buffer_size",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_set_tstamp_precision(pcap_t *, int)",
          "fn_dec_pos": [
            [
              342,
              13
            ],
            [
              342,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_tstamp_precision",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_get_tstamp_precision(pcap_t *)",
          "fn_dec_pos": [
            [
              343,
              13
            ],
            [
              343,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_get_tstamp_precision",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_activate(pcap_t *)",
          "fn_dec_pos": [
            [
              344,
              13
            ],
            [
              344,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_activate",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_list_tstamp_types(pcap_t *, int **)",
          "fn_dec_pos": [
            [
              346,
              13
            ],
            [
              346,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_list_tstamp_types",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_free_tstamp_types(int *)",
          "fn_dec_pos": [
            [
              347,
              14
            ],
            [
              347,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_free_tstamp_types",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_tstamp_type_name_to_val(const char *)",
          "fn_dec_pos": [
            [
              348,
              13
            ],
            [
              348,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_tstamp_type_name_to_val",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_tstamp_type_val_to_name(int)",
          "fn_dec_pos": [
            [
              349,
              21
            ],
            [
              349,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_tstamp_type_val_to_name",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_tstamp_type_val_to_description(int)",
          "fn_dec_pos": [
            [
              350,
              21
            ],
            [
              350,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_tstamp_type_val_to_description",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_set_protocol_linux(pcap_t *, int)",
          "fn_dec_pos": [
            [
              353,
              13
            ],
            [
              353,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_protocol_linux",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_open_live(const char *, int, int, int, char *)",
          "fn_dec_pos": [
            [
              409,
              17
            ],
            [
              409,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_live",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_open_dead(int, int)",
          "fn_dec_pos": [
            [
              410,
              17
            ],
            [
              410,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_dead",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_open_dead_with_tstamp_precision(int, int, u_int)",
          "fn_dec_pos": [
            [
              411,
              17
            ],
            [
              411,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_dead_with_tstamp_precision",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_open_offline_with_tstamp_precision(const char *, u_int, char *)",
          "fn_dec_pos": [
            [
              412,
              17
            ],
            [
              412,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_offline_with_tstamp_precision",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_open_offline(const char *, char *)",
          "fn_dec_pos": [
            [
              413,
              17
            ],
            [
              413,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open_offline",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_hopen_offline_with_tstamp_precision(intptr_t, u_int, char *)",
          "fn_dec_pos": [
            [
              415,
              20
            ],
            [
              415,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_hopen_offline_with_tstamp_precision",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_hopen_offline(intptr_t, char *)",
          "fn_dec_pos": [
            [
              416,
              20
            ],
            [
              416,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_hopen_offline",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_fopen_offline_with_tstamp_precision(FILE *, u_int, char *)",
          "fn_dec_pos": [
            [
              437,
              19
            ],
            [
              437,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_fopen_offline_with_tstamp_precision",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_fopen_offline(FILE *, char *)",
          "fn_dec_pos": [
            [
              438,
              19
            ],
            [
              438,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_fopen_offline",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_close(pcap_t *)",
          "fn_dec_pos": [
            [
              441,
              14
            ],
            [
              441,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_close",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_loop(pcap_t *, int, pcap_handler, u_char *)",
          "fn_dec_pos": [
            [
              442,
              13
            ],
            [
              442,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_loop",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_dispatch(pcap_t *, int, pcap_handler, u_char *)",
          "fn_dec_pos": [
            [
              443,
              13
            ],
            [
              443,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dispatch",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_next(pcap_t *, struct pcap_pkthdr *)",
          "fn_dec_pos": [
            [
              444,
              23
            ],
            [
              444,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_next",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_next_ex(pcap_t *, struct pcap_pkthdr **, const u_char **)",
          "fn_dec_pos": [
            [
              445,
              14
            ],
            [
              445,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_next_ex",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_breakloop(pcap_t *)",
          "fn_dec_pos": [
            [
              446,
              14
            ],
            [
              446,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_breakloop",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_stats(pcap_t *, struct pcap_stat *)",
          "fn_dec_pos": [
            [
              447,
              13
            ],
            [
              447,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_setfilter(pcap_t *, struct bpf_program *)",
          "fn_dec_pos": [
            [
              448,
              13
            ],
            [
              448,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setfilter",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_setdirection(pcap_t *, pcap_direction_t)",
          "fn_dec_pos": [
            [
              449,
              14
            ],
            [
              449,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setdirection",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_getnonblock(pcap_t *, char *)",
          "fn_dec_pos": [
            [
              450,
              13
            ],
            [
              450,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getnonblock",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_setnonblock(pcap_t *, int, char *)",
          "fn_dec_pos": [
            [
              451,
              13
            ],
            [
              451,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setnonblock",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_inject(pcap_t *, const void *, size_t)",
          "fn_dec_pos": [
            [
              452,
              13
            ],
            [
              452,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_inject",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_sendpacket(pcap_t *, const u_char *, int)",
          "fn_dec_pos": [
            [
              453,
              13
            ],
            [
              453,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_sendpacket",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_statustostr(int)",
          "fn_dec_pos": [
            [
              454,
              21
            ],
            [
              454,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_statustostr",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_strerror(int)",
          "fn_dec_pos": [
            [
              455,
              21
            ],
            [
              455,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_strerror",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_geterr(pcap_t *)",
          "fn_dec_pos": [
            [
              456,
              15
            ],
            [
              456,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_geterr",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_perror(pcap_t *, const char *)",
          "fn_dec_pos": [
            [
              457,
              14
            ],
            [
              457,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_perror",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_compile(pcap_t *, struct bpf_program *, const char *, int,\n\t    bpf_u_int32)",
          "fn_dec_pos": [
            [
              458,
              13
            ],
            [
              459,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_compile",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_compile_nopcap(int, int, struct bpf_program *,\n\t    const char *, int, bpf_u_int32)",
          "fn_dec_pos": [
            [
              460,
              13
            ],
            [
              461,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_compile_nopcap",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_freecode(struct bpf_program *)",
          "fn_dec_pos": [
            [
              462,
              14
            ],
            [
              462,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_freecode",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_offline_filter(const struct bpf_program *,\n\t    const struct pcap_pkthdr *, const u_char *)",
          "fn_dec_pos": [
            [
              463,
              13
            ],
            [
              464,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_offline_filter",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_datalink(pcap_t *)",
          "fn_dec_pos": [
            [
              465,
              13
            ],
            [
              465,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_datalink",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_datalink_ext(pcap_t *)",
          "fn_dec_pos": [
            [
              466,
              13
            ],
            [
              466,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_datalink_ext",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_list_datalinks(pcap_t *, int **)",
          "fn_dec_pos": [
            [
              467,
              13
            ],
            [
              467,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_list_datalinks",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_set_datalink(pcap_t *, int)",
          "fn_dec_pos": [
            [
              468,
              13
            ],
            [
              468,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_datalink",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_free_datalinks(int *)",
          "fn_dec_pos": [
            [
              469,
              14
            ],
            [
              469,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_free_datalinks",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_datalink_name_to_val(const char *)",
          "fn_dec_pos": [
            [
              470,
              13
            ],
            [
              470,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_datalink_name_to_val",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_datalink_val_to_name(int)",
          "fn_dec_pos": [
            [
              471,
              21
            ],
            [
              471,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_datalink_val_to_name",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_datalink_val_to_description(int)",
          "fn_dec_pos": [
            [
              472,
              21
            ],
            [
              472,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_datalink_val_to_description",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_snapshot(pcap_t *)",
          "fn_dec_pos": [
            [
              473,
              13
            ],
            [
              473,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_snapshot",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_is_swapped(pcap_t *)",
          "fn_dec_pos": [
            [
              474,
              13
            ],
            [
              474,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_is_swapped",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_major_version(pcap_t *)",
          "fn_dec_pos": [
            [
              475,
              13
            ],
            [
              475,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_major_version",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_minor_version(pcap_t *)",
          "fn_dec_pos": [
            [
              476,
              13
            ],
            [
              476,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_minor_version",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_bufsize(pcap_t *)",
          "fn_dec_pos": [
            [
              477,
              13
            ],
            [
              477,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_bufsize",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_file(pcap_t *)",
          "fn_dec_pos": [
            [
              480,
              15
            ],
            [
              480,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_file",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_fileno(pcap_t *)",
          "fn_dec_pos": [
            [
              481,
              13
            ],
            [
              481,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_fileno",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_wsockinit(void)",
          "fn_dec_pos": [
            [
              484,
              15
            ],
            [
              484,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_wsockinit",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_dump_open(pcap_t *, const char *)",
          "fn_dec_pos": [
            [
              487,
              24
            ],
            [
              487,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_dump_hopen(pcap_t *, intptr_t)",
          "fn_dec_pos": [
            [
              489,
              26
            ],
            [
              489,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_dump_fopen(pcap_t *, FILE *fp)",
          "fn_dec_pos": [
            [
              508,
              26
            ],
            [
              508,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "fp": "FILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_dump_open_append(pcap_t *, const char *)",
          "fn_dec_pos": [
            [
              510,
              24
            ],
            [
              510,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_dump_file(pcap_dumper_t *)",
          "fn_dec_pos": [
            [
              511,
              15
            ],
            [
              511,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_file",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_dump_ftell(pcap_dumper_t *)",
          "fn_dec_pos": [
            [
              512,
              14
            ],
            [
              512,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_ftell",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_dump_ftell64(pcap_dumper_t *)",
          "fn_dec_pos": [
            [
              513,
              17
            ],
            [
              513,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_ftell64",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_dump_flush(pcap_dumper_t *)",
          "fn_dec_pos": [
            [
              514,
              13
            ],
            [
              514,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_flush",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_dump_close(pcap_dumper_t *)",
          "fn_dec_pos": [
            [
              515,
              14
            ],
            [
              515,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump_close",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_dump(u_char *, const struct pcap_pkthdr *, const u_char *)",
          "fn_dec_pos": [
            [
              516,
              14
            ],
            [
              516,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_dump",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_findalldevs(pcap_if_t **, char *)",
          "fn_dec_pos": [
            [
              518,
              13
            ],
            [
              518,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_findalldevs",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_freealldevs(pcap_if_t *)",
          "fn_dec_pos": [
            [
              519,
              14
            ],
            [
              519,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_freealldevs",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_lib_version(void)",
          "fn_dec_pos": [
            [
              536,
              21
            ],
            [
              536,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_lib_version",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_setbuff(pcap_t *p, int dim)",
          "fn_dec_pos": [
            [
              565,
              15
            ],
            [
              565,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setbuff",
            "parameters": {
              "p": "pcap_t",
              "dim": "int"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_setmode(pcap_t *p, int mode)",
          "fn_dec_pos": [
            [
              566,
              15
            ],
            [
              566,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setmode",
            "parameters": {
              "p": "pcap_t",
              "mode": "int"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_setmintocopy(pcap_t *p, int size)",
          "fn_dec_pos": [
            [
              567,
              15
            ],
            [
              567,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setmintocopy",
            "parameters": {
              "p": "pcap_t",
              "size": "int"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_getevent(pcap_t *p)",
          "fn_dec_pos": [
            [
              569,
              18
            ],
            [
              569,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_getevent",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_oid_get_request(pcap_t *, bpf_u_int32, void *, size_t *)",
          "fn_dec_pos": [
            [
              571,
              15
            ],
            [
              571,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_oid_get_request",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_oid_set_request(pcap_t *, bpf_u_int32, const void *, size_t *)",
          "fn_dec_pos": [
            [
              572,
              15
            ],
            [
              572,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_oid_set_request",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_sendqueue_alloc(u_int memsize)",
          "fn_dec_pos": [
            [
              574,
              28
            ],
            [
              574,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "memsize": "u_int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_sendqueue_destroy(pcap_send_queue* queue)",
          "fn_dec_pos": [
            [
              576,
              16
            ],
            [
              576,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_sendqueue_destroy",
            "parameters": {
              "queue": "pcap_send_queue"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_sendqueue_queue(pcap_send_queue* queue, const struct pcap_pkthdr *pkt_header, const u_char *pkt_data)",
          "fn_dec_pos": [
            [
              578,
              15
            ],
            [
              578,
              121
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_sendqueue_queue",
            "parameters": {
              "queue": "pcap_send_queue",
              "pkt_header": "struct pcap_pkthdr",
              "pkt_data": "u_char"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_sendqueue_transmit(pcap_t *p, pcap_send_queue* queue, int sync)",
          "fn_dec_pos": [
            [
              580,
              17
            ],
            [
              580,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_sendqueue_transmit",
            "parameters": {
              "p": "pcap_t",
              "queue": "pcap_send_queue",
              "sync": "int"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_stats_ex(pcap_t *p, int *pcap_stat_size)",
          "fn_dec_pos": [
            [
              582,
              29
            ],
            [
              582,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_ex",
            "parameters": {
              "p": "pcap_t",
              "pcap_stat_size": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_setuserbuffer(pcap_t *p, int size)",
          "fn_dec_pos": [
            [
              584,
              15
            ],
            [
              584,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setuserbuffer",
            "parameters": {
              "p": "pcap_t",
              "size": "int"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_live_dump(pcap_t *p, char *filename, int maxsize, int maxpacks)",
          "fn_dec_pos": [
            [
              586,
              15
            ],
            [
              586,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_live_dump",
            "parameters": {
              "p": "pcap_t",
              "filename": "char",
              "maxsize": "int",
              "maxpacks": "int"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_live_dump_ended(pcap_t *p, int sync)",
          "fn_dec_pos": [
            [
              588,
              15
            ],
            [
              588,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_live_dump_ended",
            "parameters": {
              "p": "pcap_t",
              "sync": "int"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_start_oem(char* err_str, int flags)",
          "fn_dec_pos": [
            [
              590,
              15
            ],
            [
              590,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_start_oem",
            "parameters": {
              "err_str": "char",
              "flags": "int"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "PAirpcapHandle pcap_get_airpcap_handle(pcap_t *p)",
          "fn_dec_pos": [
            [
              592,
              11
            ],
            [
              592,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PAirpcapHandle pcap_get_airpcap_handle",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_stats_ex (pcap_t *, struct pcap_stat_ex *)",
          "fn_dec_pos": [
            [
              604,
              16
            ],
            [
              604,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_stats_ex",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_set_wait (pcap_t *p, void (*yield)(void), int wait)",
          "fn_dec_pos": [
            [
              605,
              16
            ],
            [
              605,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_set_wait",
            "parameters": {
              "p": "pcap_t",
              "yield": "void",
              "wait": "int"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "(*yield)(void)",
          "fn_dec_pos": [
            [
              605,
              47
            ],
            [
              605,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "pcap_mac_packets (void)",
          "fn_dec_pos": [
            [
              606,
              18
            ],
            [
              606,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_mac_packets",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_get_selectable_fd(pcap_t *)",
          "fn_dec_pos": [
            [
              614,
              15
            ],
            [
              614,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_get_selectable_fd",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_get_required_select_timeout(pcap_t *)",
          "fn_dec_pos": [
            [
              615,
              27
            ],
            [
              615,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_get_required_select_timeout",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_open(const char *source, int snaplen, int flags,\n\t    int read_timeout, struct pcap_rmtauth *auth, char *errbuf)",
          "fn_dec_pos": [
            [
              847,
              17
            ],
            [
              848,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_open",
            "parameters": {
              "source": "char",
              "snaplen": "int",
              "flags": "int",
              "read_timeout": "int",
              "auth": "struct pcap_rmtauth",
              "errbuf": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_createsrcstr(char *source, int type, const char *host,\n\t    const char *port, const char *name, char *errbuf)",
          "fn_dec_pos": [
            [
              849,
              13
            ],
            [
              850,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_createsrcstr",
            "parameters": {
              "source": "char",
              "type": "int",
              "host": "char",
              "port": "char",
              "name": "char",
              "errbuf": "char"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_parsesrcstr(const char *source, int *type, char *host,\n\t    char *port, char *name, char *errbuf)",
          "fn_dec_pos": [
            [
              851,
              13
            ],
            [
              852,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_parsesrcstr",
            "parameters": {
              "source": "char",
              "type": "int",
              "host": "char",
              "port": "char",
              "name": "char",
              "errbuf": "char"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_findalldevs_ex(const char *source,\n\t    struct pcap_rmtauth *auth, pcap_if_t **alldevs, char *errbuf)",
          "fn_dec_pos": [
            [
              873,
              13
            ],
            [
              874,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_findalldevs_ex",
            "parameters": {
              "source": "char",
              "auth": "struct pcap_rmtauth",
              "alldevs": "pcap_if_t",
              "errbuf": "char"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_setsampling(pcap_t *p)",
          "fn_dec_pos": [
            [
              943,
              27
            ],
            [
              943,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_setsampling",
            "parameters": {
              "p": "pcap_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "pcap_remoteact_accept(const char *address, const char *port,\n\t    const char *hostlist, char *connectinghost,\n\t    struct pcap_rmtauth *auth, char *errbuf)",
          "fn_dec_pos": [
            [
              952,
              16
            ],
            [
              954,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_remoteact_accept",
            "parameters": {
              "address": "char",
              "port": "char",
              "hostlist": "char",
              "connectinghost": "char",
              "auth": "struct pcap_rmtauth",
              "errbuf": "char"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_remoteact_accept_ex(const char *address, const char *port,\n\t    const char *hostlist, char *connectinghost,\n\t    struct pcap_rmtauth *auth, int uses_ssl, char *errbuf)",
          "fn_dec_pos": [
            [
              955,
              16
            ],
            [
              957,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_remoteact_accept_ex",
            "parameters": {
              "address": "char",
              "port": "char",
              "hostlist": "char",
              "connectinghost": "char",
              "auth": "struct pcap_rmtauth",
              "uses_ssl": "int",
              "errbuf": "char"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_remoteact_list(char *hostlist, char sep, int size,\n\t    char *errbuf)",
          "fn_dec_pos": [
            [
              958,
              13
            ],
            [
              959,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_remoteact_list",
            "parameters": {
              "hostlist": "char",
              "sep": "char",
              "size": "int",
              "errbuf": "char"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_remoteact_close(const char *host, char *errbuf)",
          "fn_dec_pos": [
            [
              960,
              13
            ],
            [
              960,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_remoteact_close",
            "parameters": {
              "host": "char",
              "errbuf": "char"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "pcap_remoteact_cleanup(void)",
          "fn_dec_pos": [
            [
              961,
              14
            ],
            [
              961,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcap_remoteact_cleanup",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct pcap_file_header {\n\tbpf_u_int32 magic;\n\tu_short version_major;\n\tu_short version_minor;\n\tbpf_int32 thiszone;\t/* gmt to local correction; this is always 0 */\n\tbpf_u_int32 sigfigs;\t/* accuracy of timestamps; this is always 0 */\n\tbpf_u_int32 snaplen;\t/* max length saved portion of each pkt */\n\tbpf_u_int32 linktype;\t/* data link type (LINKTYPE_*) */\n}",
          {
            "magic": "bpf_u_int32",
            "version_major": "u_short",
            "version_minor": "u_short",
            "thiszone": "bpf_int32",
            "sigfigs": "bpf_u_int32",
            "snaplen": "bpf_u_int32",
            "linktype": "bpf_u_int32"
          },
          "pcap_file_header",
          [
            163,
            0
          ],
          [
            171,
            1
          ]
        ],
        [
          "struct pcap_pkthdr {\n\tstruct timeval ts;\t/* time stamp */\n\tbpf_u_int32 caplen;\t/* length of portion present */\n\tbpf_u_int32 len;\t/* length this packet (off wire) */\n}",
          {
            "ts": "struct timeval",
            "caplen": "bpf_u_int32",
            "len": "bpf_u_int32"
          },
          "pcap_pkthdr",
          [
            201,
            0
          ],
          [
            205,
            1
          ]
        ],
        [
          "struct pcap_stat {\n\tu_int ps_recv;\t\t/* number of packets received */\n\tu_int ps_drop;\t\t/* number of packets dropped */\n\tu_int ps_ifdrop;\t/* drops by interface -- only supported on some platforms */\n#ifdef _WIN32\n\tu_int ps_capt;\t\t/* number of packets that reach the application */\n\tu_int ps_sent;\t\t/* number of packets sent by the server on the network */\n\tu_int ps_netdrop;\t/* number of packets lost on the network */\n#endif /* _WIN32 */\n}",
          {
            "ps_recv": "u_int",
            "ps_drop": "u_int",
            "ps_ifdrop": "u_int",
            "ps_capt": "u_int",
            "ps_sent": "u_int",
            "ps_netdrop": "u_int"
          },
          "pcap_stat",
          [
            210,
            0
          ],
          [
            219,
            1
          ]
        ],
        [
          "struct pcap_stat_ex {\n       u_long  rx_packets;        /* total packets received       */\n       u_long  tx_packets;        /* total packets transmitted    */\n       u_long  rx_bytes;          /* total bytes received         */\n       u_long  tx_bytes;          /* total bytes transmitted      */\n       u_long  rx_errors;         /* bad packets received         */\n       u_long  tx_errors;         /* packet transmit problems     */\n       u_long  rx_dropped;        /* no space in Rx buffers       */\n       u_long  tx_dropped;        /* no space available for Tx    */\n       u_long  multicast;         /* multicast packets received   */\n       u_long  collisions;\n\n       /* detailed rx_errors: */\n       u_long  rx_length_errors;\n       u_long  rx_over_errors;    /* receiver ring buff overflow  */\n       u_long  rx_crc_errors;     /* recv'd pkt with crc error    */\n       u_long  rx_frame_errors;   /* recv'd frame alignment error */\n       u_long  rx_fifo_errors;    /* recv'r fifo overrun          */\n       u_long  rx_missed_errors;  /* recv'r missed packet         */\n\n       /* detailed tx_errors */\n       u_long  tx_aborted_errors;\n       u_long  tx_carrier_errors;\n       u_long  tx_fifo_errors;\n       u_long  tx_heartbeat_errors;\n       u_long  tx_window_errors;\n     }",
          {
            "rx_packets": "u_long",
            "tx_packets": "u_long",
            "rx_bytes": "u_long",
            "tx_bytes": "u_long",
            "rx_errors": "u_long",
            "tx_errors": "u_long",
            "rx_dropped": "u_long",
            "tx_dropped": "u_long",
            "multicast": "u_long",
            "collisions": "u_long",
            "rx_length_errors": "u_long",
            "rx_over_errors": "u_long",
            "rx_crc_errors": "u_long",
            "rx_frame_errors": "u_long",
            "rx_fifo_errors": "u_long",
            "rx_missed_errors": "u_long",
            "tx_aborted_errors": "u_long",
            "tx_carrier_errors": "u_long",
            "tx_fifo_errors": "u_long",
            "tx_heartbeat_errors": "u_long",
            "tx_window_errors": "u_long"
          },
          "pcap_stat_ex",
          [
            225,
            0
          ],
          [
            251,
            6
          ]
        ],
        [
          "struct pcap_if {\n\tstruct pcap_if *next;\n\tchar *name;\t\t/* name to hand to \"pcap_open_live()\" */\n\tchar *description;\t/* textual description of interface, or NULL */\n\tstruct pcap_addr *addresses;\n\tbpf_u_int32 flags;\t/* PCAP_IF_ interface flags */\n}",
          {
            "*next": "struct pcap_if",
            "*name": "char",
            "*description": "char",
            "*addresses": "struct pcap_addr",
            "flags": "bpf_u_int32"
          },
          "pcap_if",
          [
            257,
            0
          ],
          [
            263,
            1
          ]
        ],
        [
          "struct pcap_addr {\n\tstruct pcap_addr *next;\n\tstruct sockaddr *addr;\t\t/* address */\n\tstruct sockaddr *netmask;\t/* netmask for that address */\n\tstruct sockaddr *broadaddr;\t/* broadcast address for that address */\n\tstruct sockaddr *dstaddr;\t/* P2P destination address for that address */\n}",
          {
            "*next": "struct pcap_addr",
            "*addr": "struct sockaddr",
            "*netmask": "struct sockaddr",
            "*broadaddr": "struct sockaddr",
            "*dstaddr": "struct sockaddr"
          },
          "pcap_addr",
          [
            278,
            0
          ],
          [
            284,
            1
          ]
        ],
        [
          "struct pcap_send_queue\n  {\n\tu_int maxlen;\t/* Maximum size of the queue, in bytes. This\n\t\t\t   variable contains the size of the buffer field. */\n\tu_int len;\t/* Current size of the queue, in bytes. */\n\tchar *buffer;\t/* Buffer containing the packets to be sent. */\n  }",
          {
            "maxlen": "u_int",
            "len": "u_int",
            "*buffer": "char"
          },
          "pcap_send_queue",
          [
            547,
            2
          ],
          [
            553,
            3
          ]
        ],
        [
          "struct pcap_rmtauth\n{\n\t/*\n\t * \\brief Type of the authentication required.\n\t *\n\t * In order to provide maximum flexibility, we can support different types\n\t * of authentication based on the value of this 'type' variable. The currently\n\t * supported authentication methods are defined into the\n\t * \\link remote_auth_methods Remote Authentication Methods Section\\endlink.\n\t */\n\tint type;\n\t/*\n\t * \\brief Zero-terminated string containing the username that has to be\n\t * used on the remote machine for authentication.\n\t *\n\t * This field is meaningless in case of the RPCAP_RMTAUTH_NULL authentication\n\t * and it can be NULL.\n\t */\n\tchar *username;\n\t/*\n\t * \\brief Zero-terminated string containing the password that has to be\n\t * used on the remote machine for authentication.\n\t *\n\t * This field is meaningless in case of the RPCAP_RMTAUTH_NULL authentication\n\t * and it can be NULL.\n\t */\n\tchar *password;\n}",
          {
            "type": "int",
            "*username": "char",
            "*password": "char"
          },
          "pcap_rmtauth",
          [
            800,
            0
          ],
          [
            827,
            1
          ]
        ],
        [
          "struct pcap_samp\n{\n\t/*\n\t * Method used for sampling; see above.\n\t */\n\tint method;\n\n\t/*\n\t * This value depends on the sampling method defined.\n\t * For its meaning, see above.\n\t */\n\tint value;\n}",
          {
            "method": "int",
            "value": "int"
          },
          "pcap_samp",
          [
            926,
            0
          ],
          [
            938,
            1
          ]
        ],
        [
          "typedef struct pcap pcap_t;",
          {},
          "pcap_t",
          [
            119,
            0
          ],
          [
            119,
            27
          ]
        ],
        [
          "typedef struct pcap_dumper pcap_dumper_t;",
          {},
          "pcap_dumper_t",
          [
            120,
            0
          ],
          [
            120,
            41
          ]
        ],
        [
          "typedef struct pcap_if pcap_if_t;",
          {},
          "pcap_if_t",
          [
            121,
            0
          ],
          [
            121,
            33
          ]
        ],
        [
          "typedef struct pcap_addr pcap_addr_t;",
          {},
          "pcap_addr_t",
          [
            122,
            0
          ],
          [
            122,
            37
          ]
        ],
        [
          "struct pcap_file_header {\n\tbpf_u_int32 magic;\n\tu_short version_major;\n\tu_short version_minor;\n\tbpf_int32 thiszone;\t/* gmt to local correction; this is always 0 */\n\tbpf_u_int32 sigfigs;\t/* accuracy of timestamps; this is always 0 */\n\tbpf_u_int32 snaplen;\t/* max length saved portion of each pkt */\n\tbpf_u_int32 linktype;\t/* data link type (LINKTYPE_*) */\n}",
          {
            "magic": "bpf_u_int32",
            "version_major": "u_short",
            "version_minor": "u_short",
            "thiszone": "bpf_int32",
            "sigfigs": "bpf_u_int32",
            "snaplen": "bpf_u_int32",
            "linktype": "bpf_u_int32"
          },
          "pcap_file_header",
          [
            163,
            0
          ],
          [
            171,
            1
          ]
        ],
        [
          "struct pcap_pkthdr {\n\tstruct timeval ts;\t/* time stamp */\n\tbpf_u_int32 caplen;\t/* length of portion present */\n\tbpf_u_int32 len;\t/* length this packet (off wire) */\n}",
          {
            "ts": "struct timeval",
            "caplen": "bpf_u_int32",
            "len": "bpf_u_int32"
          },
          "pcap_pkthdr",
          [
            201,
            0
          ],
          [
            205,
            1
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            202,
            1
          ],
          [
            202,
            15
          ]
        ],
        [
          "struct pcap_stat {\n\tu_int ps_recv;\t\t/* number of packets received */\n\tu_int ps_drop;\t\t/* number of packets dropped */\n\tu_int ps_ifdrop;\t/* drops by interface -- only supported on some platforms */\n#ifdef _WIN32\n\tu_int ps_capt;\t\t/* number of packets that reach the application */\n\tu_int ps_sent;\t\t/* number of packets sent by the server on the network */\n\tu_int ps_netdrop;\t/* number of packets lost on the network */\n#endif /* _WIN32 */\n}",
          {
            "ps_recv": "u_int",
            "ps_drop": "u_int",
            "ps_ifdrop": "u_int",
            "ps_capt": "u_int",
            "ps_sent": "u_int",
            "ps_netdrop": "u_int"
          },
          "pcap_stat",
          [
            210,
            0
          ],
          [
            219,
            1
          ]
        ],
        [
          "struct pcap_stat_ex {\n       u_long  rx_packets;        /* total packets received       */\n       u_long  tx_packets;        /* total packets transmitted    */\n       u_long  rx_bytes;          /* total bytes received         */\n       u_long  tx_bytes;          /* total bytes transmitted      */\n       u_long  rx_errors;         /* bad packets received         */\n       u_long  tx_errors;         /* packet transmit problems     */\n       u_long  rx_dropped;        /* no space in Rx buffers       */\n       u_long  tx_dropped;        /* no space available for Tx    */\n       u_long  multicast;         /* multicast packets received   */\n       u_long  collisions;\n\n       /* detailed rx_errors: */\n       u_long  rx_length_errors;\n       u_long  rx_over_errors;    /* receiver ring buff overflow  */\n       u_long  rx_crc_errors;     /* recv'd pkt with crc error    */\n       u_long  rx_frame_errors;   /* recv'd frame alignment error */\n       u_long  rx_fifo_errors;    /* recv'r fifo overrun          */\n       u_long  rx_missed_errors;  /* recv'r missed packet         */\n\n       /* detailed tx_errors */\n       u_long  tx_aborted_errors;\n       u_long  tx_carrier_errors;\n       u_long  tx_fifo_errors;\n       u_long  tx_heartbeat_errors;\n       u_long  tx_window_errors;\n     }",
          {
            "rx_packets": "u_long",
            "tx_packets": "u_long",
            "rx_bytes": "u_long",
            "tx_bytes": "u_long",
            "rx_errors": "u_long",
            "tx_errors": "u_long",
            "rx_dropped": "u_long",
            "tx_dropped": "u_long",
            "multicast": "u_long",
            "collisions": "u_long",
            "rx_length_errors": "u_long",
            "rx_over_errors": "u_long",
            "rx_crc_errors": "u_long",
            "rx_frame_errors": "u_long",
            "rx_fifo_errors": "u_long",
            "rx_missed_errors": "u_long",
            "tx_aborted_errors": "u_long",
            "tx_carrier_errors": "u_long",
            "tx_fifo_errors": "u_long",
            "tx_heartbeat_errors": "u_long",
            "tx_window_errors": "u_long"
          },
          "pcap_stat_ex",
          [
            225,
            0
          ],
          [
            251,
            6
          ]
        ],
        [
          "struct pcap_if {\n\tstruct pcap_if *next;\n\tchar *name;\t\t/* name to hand to \"pcap_open_live()\" */\n\tchar *description;\t/* textual description of interface, or NULL */\n\tstruct pcap_addr *addresses;\n\tbpf_u_int32 flags;\t/* PCAP_IF_ interface flags */\n}",
          {
            "*next": "struct pcap_if",
            "*name": "char",
            "*description": "char",
            "*addresses": "struct pcap_addr",
            "flags": "bpf_u_int32"
          },
          "pcap_if",
          [
            257,
            0
          ],
          [
            263,
            1
          ]
        ],
        [
          "struct pcap_if",
          {},
          "",
          [
            258,
            1
          ],
          [
            258,
            15
          ]
        ],
        [
          "struct pcap_addr",
          {},
          "",
          [
            261,
            1
          ],
          [
            261,
            17
          ]
        ],
        [
          "struct pcap_addr {\n\tstruct pcap_addr *next;\n\tstruct sockaddr *addr;\t\t/* address */\n\tstruct sockaddr *netmask;\t/* netmask for that address */\n\tstruct sockaddr *broadaddr;\t/* broadcast address for that address */\n\tstruct sockaddr *dstaddr;\t/* P2P destination address for that address */\n}",
          {
            "*next": "struct pcap_addr",
            "*addr": "struct sockaddr",
            "*netmask": "struct sockaddr",
            "*broadaddr": "struct sockaddr",
            "*dstaddr": "struct sockaddr"
          },
          "pcap_addr",
          [
            278,
            0
          ],
          [
            284,
            1
          ]
        ],
        [
          "struct pcap_addr",
          {},
          "",
          [
            279,
            1
          ],
          [
            279,
            17
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            280,
            1
          ],
          [
            280,
            16
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            281,
            1
          ],
          [
            281,
            16
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            282,
            1
          ],
          [
            282,
            16
          ]
        ],
        [
          "struct sockaddr",
          {},
          "",
          [
            283,
            1
          ],
          [
            283,
            16
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            286,
            45
          ],
          [
            286,
            63
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            444,
            43
          ],
          [
            444,
            61
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            445,
            37
          ],
          [
            445,
            55
          ]
        ],
        [
          "struct pcap_stat",
          {},
          "",
          [
            447,
            34
          ],
          [
            447,
            50
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            448,
            38
          ],
          [
            448,
            56
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            458,
            36
          ],
          [
            458,
            54
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            460,
            43
          ],
          [
            460,
            61
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            462,
            28
          ],
          [
            462,
            46
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            463,
            39
          ],
          [
            463,
            57
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            464,
            11
          ],
          [
            464,
            29
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            516,
            40
          ],
          [
            516,
            58
          ]
        ],
        [
          "struct pcap_send_queue\n  {\n\tu_int maxlen;\t/* Maximum size of the queue, in bytes. This\n\t\t\t   variable contains the size of the buffer field. */\n\tu_int len;\t/* Current size of the queue, in bytes. */\n\tchar *buffer;\t/* Buffer containing the packets to be sent. */\n  }",
          {
            "maxlen": "u_int",
            "len": "u_int",
            "*buffer": "char"
          },
          "pcap_send_queue",
          [
            547,
            2
          ],
          [
            553,
            3
          ]
        ],
        [
          "typedef struct pcap_send_queue pcap_send_queue;",
          {},
          "pcap_send_queue",
          [
            555,
            2
          ],
          [
            555,
            49
          ]
        ],
        [
          "typedef struct _AirpcapHandle *PAirpcapHandle;",
          {},
          "PAirpcapHandle",
          [
            562,
            4
          ],
          [
            562,
            50
          ]
        ],
        [
          "struct pcap_pkthdr",
          {},
          "",
          [
            578,
            66
          ],
          [
            578,
            84
          ]
        ],
        [
          "struct pcap_stat_ex",
          {},
          "",
          [
            604,
            41
          ],
          [
            604,
            60
          ]
        ],
        [
          "struct pcap_rmtauth\n{\n\t/*\n\t * \\brief Type of the authentication required.\n\t *\n\t * In order to provide maximum flexibility, we can support different types\n\t * of authentication based on the value of this 'type' variable. The currently\n\t * supported authentication methods are defined into the\n\t * \\link remote_auth_methods Remote Authentication Methods Section\\endlink.\n\t */\n\tint type;\n\t/*\n\t * \\brief Zero-terminated string containing the username that has to be\n\t * used on the remote machine for authentication.\n\t *\n\t * This field is meaningless in case of the RPCAP_RMTAUTH_NULL authentication\n\t * and it can be NULL.\n\t */\n\tchar *username;\n\t/*\n\t * \\brief Zero-terminated string containing the password that has to be\n\t * used on the remote machine for authentication.\n\t *\n\t * This field is meaningless in case of the RPCAP_RMTAUTH_NULL authentication\n\t * and it can be NULL.\n\t */\n\tchar *password;\n}",
          {
            "type": "int",
            "*username": "char",
            "*password": "char"
          },
          "pcap_rmtauth",
          [
            800,
            0
          ],
          [
            827,
            1
          ]
        ],
        [
          "struct pcap_rmtauth",
          {},
          "",
          [
            848,
            23
          ],
          [
            848,
            42
          ]
        ],
        [
          "struct pcap_rmtauth",
          {},
          "",
          [
            874,
            5
          ],
          [
            874,
            24
          ]
        ],
        [
          "struct pcap_samp\n{\n\t/*\n\t * Method used for sampling; see above.\n\t */\n\tint method;\n\n\t/*\n\t * This value depends on the sampling method defined.\n\t * For its meaning, see above.\n\t */\n\tint value;\n}",
          {
            "method": "int",
            "value": "int"
          },
          "pcap_samp",
          [
            926,
            0
          ],
          [
            938,
            1
          ]
        ],
        [
          "struct pcap_rmtauth",
          {},
          "",
          [
            954,
            5
          ],
          [
            954,
            24
          ]
        ],
        [
          "struct pcap_rmtauth",
          {},
          "",
          [
            957,
            5
          ],
          [
            957,
            24
          ]
        ]
      ],
      "include_list": [
        [
          "#include <pcap/funcattrs.h>\n",
          [
            71,
            0
          ],
          [
            72,
            0
          ]
        ],
        [
          "#include <pcap/pcap-inttypes.h>\n",
          [
            73,
            0
          ],
          [
            74,
            0
          ]
        ],
        [
          "#include <winsock2.h>\t\t/* u_int, u_char etc. */\n",
          [
            76,
            2
          ],
          [
            77,
            0
          ]
        ],
        [
          "#include <io.h>\t\t/* _get_osfhandle() */\n",
          [
            77,
            2
          ],
          [
            78,
            0
          ]
        ],
        [
          "#include <sys/types.h>\t/* u_int, u_char etc. */\n",
          [
            79,
            2
          ],
          [
            80,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            80,
            2
          ],
          [
            81,
            0
          ]
        ],
        [
          "#include <sys/types.h>\t/* u_int, u_char etc. */\n",
          [
            82,
            2
          ],
          [
            83,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            83,
            2
          ],
          [
            84,
            0
          ]
        ],
        [
          "#include <pcap/socket.h>\t/* for SOCKET, as the active-mode rpcap APIs use it */\n",
          [
            86,
            0
          ],
          [
            87,
            0
          ]
        ],
        [
          "#include <pcap/bpf.h>\n",
          [
            89,
            0
          ],
          [
            90,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            92,
            0
          ],
          [
            93,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n       PCAP_D_INOUT = 0,\n       PCAP_D_IN,\n       PCAP_D_OUT\n} pcap_direction_t;",
          {
            "PCAP_D_INOUT": "",
            "PCAP_D_IN": "",
            "PCAP_D_OUT": ""
          },
          "pcap_direction_t",
          [
            183,
            0
          ],
          [
            187,
            19
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap/usb.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct _usb_setup {\n\tuint8_t bmRequestType;\n\tuint8_t bRequest;\n\tuint16_t wValue;\n\tuint16_t wIndex;\n\tuint16_t wLength;\n} pcap_usb_setup;",
          {
            "bmRequestType": "uint8_t",
            "bRequest": "uint8_t",
            "wValue": "uint16_t",
            "wIndex": "uint16_t",
            "wLength": "uint16_t"
          },
          "pcap_usb_setup",
          [
            58,
            0
          ],
          [
            64,
            17
          ]
        ],
        [
          "typedef struct _iso_rec {\n\tint32_t\terror_count;\n\tint32_t\tnumdesc;\n} iso_rec;",
          {
            "error_count": "int32_t",
            "numdesc": "int32_t"
          },
          "iso_rec",
          [
            69,
            0
          ],
          [
            72,
            10
          ]
        ],
        [
          "typedef struct _usb_header {\n\tuint64_t id;\n\tuint8_t event_type;\n\tuint8_t transfer_type;\n\tuint8_t endpoint_number;\n\tuint8_t device_address;\n\tuint16_t bus_id;\n\tchar setup_flag;/*if !=0 the urb setup header is not present*/\n\tchar data_flag; /*if !=0 no urb data is present*/\n\tint64_t ts_sec;\n\tint32_t ts_usec;\n\tint32_t status;\n\tuint32_t urb_len;\n\tuint32_t data_len; /* amount of urb data really present in this event*/\n\tpcap_usb_setup setup;\n} pcap_usb_header;",
          {
            "id": "uint64_t",
            "event_type": "uint8_t",
            "transfer_type": "uint8_t",
            "endpoint_number": "uint8_t",
            "device_address": "uint8_t",
            "bus_id": "uint16_t",
            "setup_flag": "char",
            "data_flag": "char",
            "ts_sec": "int64_t",
            "ts_usec": "int32_t",
            "status": "int32_t",
            "urb_len": "uint32_t",
            "data_len": "uint32_t",
            "setup": "pcap_usb_setup"
          },
          "pcap_usb_header",
          [
            78,
            0
          ],
          [
            93,
            18
          ]
        ],
        [
          "typedef struct _usb_header_mmapped {\n\tuint64_t id;\n\tuint8_t event_type;\n\tuint8_t transfer_type;\n\tuint8_t endpoint_number;\n\tuint8_t device_address;\n\tuint16_t bus_id;\n\tchar setup_flag;/*if !=0 the urb setup header is not present*/\n\tchar data_flag; /*if !=0 no urb data is present*/\n\tint64_t ts_sec;\n\tint32_t ts_usec;\n\tint32_t status;\n\tuint32_t urb_len;\n\tuint32_t data_len; /* amount of urb data really present in this event*/\n\tunion {\n\t\tpcap_usb_setup setup;\n\t\tiso_rec iso;\n\t} s;\n\tint32_t\tinterval;\t/* for Interrupt and Isochronous events */\n\tint32_t start_frame;\t/* for Isochronous events */\n\tuint32_t xfer_flags;\t/* copy of URB's transfer flags */\n\tuint32_t ndesc;\t/* number of isochronous descriptors */\n} pcap_usb_header_mmapped;",
          {
            "id": "uint64_t",
            "event_type": "uint8_t",
            "transfer_type": "uint8_t",
            "endpoint_number": "uint8_t",
            "device_address": "uint8_t",
            "bus_id": "uint16_t",
            "setup_flag": "char",
            "data_flag": "char",
            "ts_sec": "int64_t",
            "ts_usec": "int32_t",
            "status": "int32_t",
            "urb_len": "uint32_t",
            "data_len": "uint32_t",
            "s": "union {\n\t\tpcap_usb_setup setup;\n\t\tiso_rec iso;\n\t}",
            "setup": "pcap_usb_setup",
            "iso": "iso_rec",
            "interval": "int32_t",
            "start_frame": "int32_t",
            "xfer_flags": "uint32_t",
            "ndesc": "uint32_t"
          },
          "pcap_usb_header_mmapped",
          [
            103,
            0
          ],
          [
            125,
            26
          ]
        ],
        [
          "typedef struct _usb_isodesc {\n\tint32_t\t\tstatus;\n\tuint32_t\toffset;\n\tuint32_t\tlen;\n\tuint8_t\tpad[4];\n} usb_isodesc;",
          {
            "status": "int32_t",
            "offset": "uint32_t",
            "len": "uint32_t",
            "pad[4]": "uint8_t"
          },
          "usb_isodesc",
          [
            135,
            0
          ],
          [
            140,
            14
          ]
        ],
        [
          "typedef struct _usb_setup {\n\tuint8_t bmRequestType;\n\tuint8_t bRequest;\n\tuint16_t wValue;\n\tuint16_t wIndex;\n\tuint16_t wLength;\n} pcap_usb_setup;",
          {
            "bmRequestType": "uint8_t",
            "bRequest": "uint8_t",
            "wValue": "uint16_t",
            "wIndex": "uint16_t",
            "wLength": "uint16_t"
          },
          "pcap_usb_setup",
          [
            58,
            0
          ],
          [
            64,
            17
          ]
        ],
        [
          "typedef struct _iso_rec {\n\tint32_t\terror_count;\n\tint32_t\tnumdesc;\n} iso_rec;",
          {
            "error_count": "int32_t",
            "numdesc": "int32_t"
          },
          "iso_rec",
          [
            69,
            0
          ],
          [
            72,
            10
          ]
        ],
        [
          "typedef struct _usb_header {\n\tuint64_t id;\n\tuint8_t event_type;\n\tuint8_t transfer_type;\n\tuint8_t endpoint_number;\n\tuint8_t device_address;\n\tuint16_t bus_id;\n\tchar setup_flag;/*if !=0 the urb setup header is not present*/\n\tchar data_flag; /*if !=0 no urb data is present*/\n\tint64_t ts_sec;\n\tint32_t ts_usec;\n\tint32_t status;\n\tuint32_t urb_len;\n\tuint32_t data_len; /* amount of urb data really present in this event*/\n\tpcap_usb_setup setup;\n} pcap_usb_header;",
          {
            "id": "uint64_t",
            "event_type": "uint8_t",
            "transfer_type": "uint8_t",
            "endpoint_number": "uint8_t",
            "device_address": "uint8_t",
            "bus_id": "uint16_t",
            "setup_flag": "char",
            "data_flag": "char",
            "ts_sec": "int64_t",
            "ts_usec": "int32_t",
            "status": "int32_t",
            "urb_len": "uint32_t",
            "data_len": "uint32_t",
            "setup": "pcap_usb_setup"
          },
          "pcap_usb_header",
          [
            78,
            0
          ],
          [
            93,
            18
          ]
        ],
        [
          "typedef struct _usb_header_mmapped {\n\tuint64_t id;\n\tuint8_t event_type;\n\tuint8_t transfer_type;\n\tuint8_t endpoint_number;\n\tuint8_t device_address;\n\tuint16_t bus_id;\n\tchar setup_flag;/*if !=0 the urb setup header is not present*/\n\tchar data_flag; /*if !=0 no urb data is present*/\n\tint64_t ts_sec;\n\tint32_t ts_usec;\n\tint32_t status;\n\tuint32_t urb_len;\n\tuint32_t data_len; /* amount of urb data really present in this event*/\n\tunion {\n\t\tpcap_usb_setup setup;\n\t\tiso_rec iso;\n\t} s;\n\tint32_t\tinterval;\t/* for Interrupt and Isochronous events */\n\tint32_t start_frame;\t/* for Isochronous events */\n\tuint32_t xfer_flags;\t/* copy of URB's transfer flags */\n\tuint32_t ndesc;\t/* number of isochronous descriptors */\n} pcap_usb_header_mmapped;",
          {
            "id": "uint64_t",
            "event_type": "uint8_t",
            "transfer_type": "uint8_t",
            "endpoint_number": "uint8_t",
            "device_address": "uint8_t",
            "bus_id": "uint16_t",
            "setup_flag": "char",
            "data_flag": "char",
            "ts_sec": "int64_t",
            "ts_usec": "int32_t",
            "status": "int32_t",
            "urb_len": "uint32_t",
            "data_len": "uint32_t",
            "s": "union {\n\t\tpcap_usb_setup setup;\n\t\tiso_rec iso;\n\t}",
            "setup": "pcap_usb_setup",
            "iso": "iso_rec",
            "interval": "int32_t",
            "start_frame": "int32_t",
            "xfer_flags": "uint32_t",
            "ndesc": "uint32_t"
          },
          "pcap_usb_header_mmapped",
          [
            103,
            0
          ],
          [
            125,
            26
          ]
        ],
        [
          "typedef struct _usb_isodesc {\n\tint32_t\t\tstatus;\n\tuint32_t\toffset;\n\tuint32_t\tlen;\n\tuint8_t\tpad[4];\n} usb_isodesc;",
          {
            "status": "int32_t",
            "offset": "uint32_t",
            "len": "uint32_t",
            "pad[4]": "uint8_t"
          },
          "usb_isodesc",
          [
            135,
            0
          ],
          [
            140,
            14
          ]
        ]
      ],
      "include_list": [
        [
          "#include <pcap/pcap-inttypes.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap/pcap-inttypes.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <inttypes.h>\n",
          [
            45,
            4
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <inttypes.h>\n",
          [
            119,
            2
          ],
          [
            120,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap/vlan.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct vlan_tag {\n\tuint16_t\tvlan_tpid;\t\t/* ETH_P_8021Q */\n\tuint16_t\tvlan_tci;\t\t/* VLAN TCI */\n}",
          {
            "vlan_tpid": "uint16_t",
            "vlan_tci": "uint16_t"
          },
          "vlan_tag",
          [
            38,
            0
          ],
          [
            41,
            1
          ]
        ],
        [
          "struct vlan_tag {\n\tuint16_t\tvlan_tpid;\t\t/* ETH_P_8021Q */\n\tuint16_t\tvlan_tci;\t\t/* VLAN TCI */\n}",
          {
            "vlan_tpid": "uint16_t",
            "vlan_tci": "uint16_t"
          },
          "vlan_tag",
          [
            38,
            0
          ],
          [
            41,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include <pcap/pcap-inttypes.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap/socket.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <windef.h>\n",
          [
            45,
            4
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <winsock2.h>\n",
          [
            47,
            2
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <ws2tcpip.h>\n",
          [
            48,
            2
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            65,
            2
          ],
          [
            66,
            0
          ]
        ],
        [
          "#include <sys/socket.h>\n",
          [
            66,
            2
          ],
          [
            67,
            0
          ]
        ],
        [
          "#include <netdb.h>\t\t/* for struct addrinfo/getaddrinfo() */\n",
          [
            67,
            2
          ],
          [
            68,
            0
          ]
        ],
        [
          "#include <netinet/in.h>\t/* for sockaddr_in, in BSD at least */\n",
          [
            68,
            2
          ],
          [
            69,
            0
          ]
        ],
        [
          "#include <arpa/inet.h>\n",
          [
            69,
            2
          ],
          [
            70,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap/can_socketcan.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\tuint32_t can_id;\n\tuint8_t payload_length;\n\tuint8_t pad;\n\tuint8_t reserved1;\n\tuint8_t reserved2;\n} pcap_can_socketcan_hdr;",
          {
            "can_id": "uint32_t",
            "payload_length": "uint8_t",
            "pad": "uint8_t",
            "reserved1": "uint8_t",
            "reserved2": "uint8_t"
          },
          "pcap_can_socketcan_hdr",
          [
            47,
            0
          ],
          [
            53,
            25
          ]
        ],
        [
          "typedef struct {\n\tuint32_t can_id;\n\tuint8_t payload_length;\n\tuint8_t pad;\n\tuint8_t reserved1;\n\tuint8_t reserved2;\n} pcap_can_socketcan_hdr;",
          {
            "can_id": "uint32_t",
            "payload_length": "uint8_t",
            "pad": "uint8_t",
            "reserved1": "uint8_t",
            "reserved2": "uint8_t"
          },
          "pcap_can_socketcan_hdr",
          [
            47,
            0
          ],
          [
            53,
            25
          ]
        ]
      ],
      "include_list": [
        [
          "#include <pcap/pcap-inttypes.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap/bpf.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "bpf_filter(const struct bpf_insn *, const u_char *, u_int, u_int)",
          "fn_dec_pos": [
            [
              246,
              15
            ],
            [
              246,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_filter",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "bpf_validate(const struct bpf_insn *f, int len)",
          "fn_dec_pos": [
            [
              247,
              13
            ],
            [
              247,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_validate",
            "parameters": {
              "f": "struct bpf_insn",
              "len": "int"
            },
            "return_type": "PCAP_API"
          }
        },
        {
          "fn_code": "bpf_image(const struct bpf_insn *, int)",
          "fn_dec_pos": [
            [
              248,
              15
            ],
            [
              248,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_image",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "bpf_dump(const struct bpf_program *, int)",
          "fn_dec_pos": [
            [
              249,
              14
            ],
            [
              249,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bpf_dump",
            "parameters": {},
            "return_type": "PCAP_API"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct bpf_program {\n\tu_int bf_len;\n\tstruct bpf_insn *bf_insns;\n}",
          {
            "bf_len": "u_int",
            "*bf_insns": "struct bpf_insn"
          },
          "bpf_program",
          [
            103,
            0
          ],
          [
            106,
            1
          ]
        ],
        [
          "struct bpf_insn {\n\tu_short\tcode;\n\tu_char \tjt;\n\tu_char \tjf;\n\tbpf_u_int32 k;\n}",
          {
            "code": "u_short",
            "jt": "u_char",
            "jf": "u_char",
            "k": "bpf_u_int32"
          },
          "bpf_insn",
          [
            233,
            0
          ],
          [
            238,
            1
          ]
        ],
        [
          "struct bpf_program {\n\tu_int bf_len;\n\tstruct bpf_insn *bf_insns;\n}",
          {
            "bf_len": "u_int",
            "*bf_insns": "struct bpf_insn"
          },
          "bpf_program",
          [
            103,
            0
          ],
          [
            106,
            1
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            105,
            1
          ],
          [
            105,
            16
          ]
        ],
        [
          "struct bpf_insn {\n\tu_short\tcode;\n\tu_char \tjt;\n\tu_char \tjf;\n\tbpf_u_int32 k;\n}",
          {
            "code": "u_short",
            "jt": "u_char",
            "jf": "u_char",
            "k": "bpf_u_int32"
          },
          "bpf_insn",
          [
            233,
            0
          ],
          [
            238,
            1
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            246,
            32
          ],
          [
            246,
            47
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            247,
            32
          ],
          [
            247,
            47
          ]
        ],
        [
          "struct bpf_insn",
          {},
          "",
          [
            248,
            31
          ],
          [
            248,
            46
          ]
        ],
        [
          "struct bpf_program",
          {},
          "",
          [
            249,
            29
          ],
          [
            249,
            47
          ]
        ]
      ],
      "include_list": [
        [
          "#include <pcap/funcattrs.h>\n",
          [
            70,
            0
          ],
          [
            71,
            0
          ]
        ],
        [
          "#include <pcap/dlt.h>\n",
          [
            108,
            0
          ],
          [
            109,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/pcap/ipnet.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/msdos/pktdrvr.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "PktInitDriver (PKT_RX_MODE mode)",
          "fn_dec_pos": [
            [
              122,
              13
            ],
            [
              122,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktInitDriver",
            "parameters": {
              "mode": "PKT_RX_MODE"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PktExitDriver (void)",
          "fn_dec_pos": [
            [
              123,
              13
            ],
            [
              123,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktExitDriver",
            "parameters": {},
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PktGetErrorStr    (int errNum)",
          "fn_dec_pos": [
            [
              125,
              19
            ],
            [
              125,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktGetErrorStr",
            "parameters": {
              "errNum": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PktGetClassName   (WORD class)",
          "fn_dec_pos": [
            [
              126,
              19
            ],
            [
              126,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktGetClassName",
            "parameters": {
              "class": "WORD"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PktRXmodeStr      (PKT_RX_MODE mode)",
          "fn_dec_pos": [
            [
              127,
              19
            ],
            [
              127,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktRXmodeStr",
            "parameters": {
              "mode": "PKT_RX_MODE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PktSearchDriver   (void)",
          "fn_dec_pos": [
            [
              128,
              19
            ],
            [
              128,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktSearchDriver",
            "parameters": {},
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PktReceive        (BYTE *buf, int max)",
          "fn_dec_pos": [
            [
              129,
              19
            ],
            [
              129,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktReceive",
            "parameters": {
              "buf": "BYTE",
              "max": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "PktTransmit       (const void *eth, int len)",
          "fn_dec_pos": [
            [
              130,
              19
            ],
            [
              130,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktTransmit",
            "parameters": {
              "eth": "void",
              "len": "int"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PktRxDropped      (void)",
          "fn_dec_pos": [
            [
              131,
              19
            ],
            [
              131,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktRxDropped",
            "parameters": {},
            "return_type": "DWORD"
          }
        },
        {
          "fn_code": "PktReleaseHandle  (WORD handle)",
          "fn_dec_pos": [
            [
              132,
              19
            ],
            [
              132,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktReleaseHandle",
            "parameters": {
              "handle": "WORD"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PktTerminHandle   (WORD handle)",
          "fn_dec_pos": [
            [
              133,
              19
            ],
            [
              133,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktTerminHandle",
            "parameters": {
              "handle": "WORD"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PktResetInterface (WORD handle)",
          "fn_dec_pos": [
            [
              134,
              19
            ],
            [
              134,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktResetInterface",
            "parameters": {
              "handle": "WORD"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PktSetReceiverMode(PKT_RX_MODE  mode)",
          "fn_dec_pos": [
            [
              135,
              19
            ],
            [
              135,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktSetReceiverMode",
            "parameters": {
              "mode": "PKT_RX_MODE"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PktGetReceiverMode(PKT_RX_MODE *mode)",
          "fn_dec_pos": [
            [
              136,
              19
            ],
            [
              136,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktGetReceiverMode",
            "parameters": {
              "mode": "PKT_RX_MODE"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PktGetStatistics  (WORD handle)",
          "fn_dec_pos": [
            [
              137,
              19
            ],
            [
              137,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktGetStatistics",
            "parameters": {
              "handle": "WORD"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PktSessStatistics (WORD handle)",
          "fn_dec_pos": [
            [
              138,
              19
            ],
            [
              138,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktSessStatistics",
            "parameters": {
              "handle": "WORD"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PktResetStatistics(WORD handle)",
          "fn_dec_pos": [
            [
              139,
              19
            ],
            [
              139,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktResetStatistics",
            "parameters": {
              "handle": "WORD"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PktGetAddress     (ETHER *addr)",
          "fn_dec_pos": [
            [
              140,
              19
            ],
            [
              140,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktGetAddress",
            "parameters": {
              "addr": "ETHER"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PktSetAddress     (const ETHER *addr)",
          "fn_dec_pos": [
            [
              141,
              19
            ],
            [
              141,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktSetAddress",
            "parameters": {
              "addr": "ETHER"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PktGetDriverInfo  (void)",
          "fn_dec_pos": [
            [
              142,
              19
            ],
            [
              142,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktGetDriverInfo",
            "parameters": {},
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PktGetDriverParam (void)",
          "fn_dec_pos": [
            [
              143,
              19
            ],
            [
              143,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktGetDriverParam",
            "parameters": {},
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "PktQueueBusy      (BOOL busy)",
          "fn_dec_pos": [
            [
              144,
              19
            ],
            [
              144,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktQueueBusy",
            "parameters": {
              "busy": "BOOL"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "PktBuffersUsed    (void)",
          "fn_dec_pos": [
            [
              145,
              19
            ],
            [
              145,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PktBuffersUsed",
            "parameters": {},
            "return_type": "WORD"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n        char type[8];\n        char len;\n      } PKT_FRAME;",
          {
            "type[8]": "char",
            "len": "char"
          },
          "PKT_FRAME",
          [
            42,
            0
          ],
          [
            45,
            18
          ]
        ],
        [
          "typedef struct {\n        BYTE  class;        /* = 1 for DEC/Interl/Xerox Ethernet */\n        BYTE  number;       /* = 0 for single LAN adapter        */\n        WORD  type;         /* = 13 for 3C523                    */\n        BYTE  funcs;        /* Basic/Extended/HiPerf functions   */\n        WORD  intr;         /* user interrupt vector number      */\n        WORD  handle;       /* Handle associated with session    */\n        BYTE  name [15];    /* Name of adapter interface,ie.3C523*/\n        BOOL  quiet;        /* (don't) print errors to stdout    */\n        const char *error;  /* address of error string           */\n        BYTE  majVer;       /* Major driver implementation ver.  */\n        BYTE  minVer;       /* Minor driver implementation ver.  */\n        BYTE  dummyLen;     /* length of following data          */\n        WORD  MAClength;    /* HiPerformance data, N/A           */\n        WORD  MTU;          /* HiPerformance data, N/A           */\n        WORD  multicast;    /* HiPerformance data, N/A           */\n        WORD  rcvrBuffers;  /* valid for                         */\n        WORD  UMTbufs;      /*   High Performance drivers only   */\n        WORD  postEOIintr;  /*                  Usage ??         */\n      } PKT_INFO;",
          {
            "class": "BYTE",
            "number": "BYTE",
            "type": "WORD",
            "funcs": "BYTE",
            "intr": "WORD",
            "handle": "WORD",
            "name [15]": "BYTE",
            "quiet": "BOOL",
            "char": "const",
            "majVer": "BYTE",
            "minVer": "BYTE",
            "dummyLen": "BYTE",
            "MAClength": "WORD",
            "MTU": "WORD",
            "multicast": "WORD",
            "rcvrBuffers": "WORD",
            "UMTbufs": "WORD",
            "postEOIintr": "WORD"
          },
          "PKT_INFO",
          [
            48,
            0
          ],
          [
            67,
            17
          ]
        ],
        [
          "typedef struct {\n        DWORD inPackets;          /* # of packets received    */\n        DWORD outPackets;         /* # of packets transmitted */\n        DWORD inBytes;            /* # of bytes received      */\n        DWORD outBytes;           /* # of bytes transmitted   */\n        DWORD inErrors;           /* # of reception errors    */\n        DWORD outErrors;          /* # of transmission errors */\n        DWORD lost;               /* # of packets lost (RX)   */\n      } PKT_STAT;",
          {
            "inPackets": "DWORD",
            "outPackets": "DWORD",
            "inBytes": "DWORD",
            "outBytes": "DWORD",
            "inErrors": "DWORD",
            "outErrors": "DWORD",
            "lost": "DWORD"
          },
          "PKT_STAT",
          [
            72,
            0
          ],
          [
            80,
            17
          ]
        ],
        [
          "typedef struct {\n        ETHER destin;\n        ETHER source;\n        WORD  proto;\n        BYTE  data [TX_BUF_SIZE];\n      } TX_ELEMENT;",
          {
            "destin": "ETHER",
            "source": "ETHER",
            "proto": "WORD",
            "data [TX_BUF_SIZE]": "BYTE"
          },
          "TX_ELEMENT",
          [
            83,
            0
          ],
          [
            88,
            19
          ]
        ],
        [
          "typedef struct {\n        WORD  firstCount;         /* # of bytes on 1st         */\n        WORD  secondCount;        /* and 2nd upcall            */\n        WORD  handle;             /* instance that upcalled    */\n        ETHER destin;             /* E-net destination address */\n        ETHER source;             /* E-net source address      */\n        WORD  proto;              /* protocol number           */\n        BYTE  data [RX_BUF_SIZE];\n      } RX_ELEMENT;",
          {
            "firstCount": "WORD",
            "secondCount": "WORD",
            "handle": "WORD",
            "destin": "ETHER",
            "source": "ETHER",
            "proto": "WORD",
            "data [RX_BUF_SIZE]": "BYTE"
          },
          "RX_ELEMENT",
          [
            90,
            0
          ],
          [
            98,
            19
          ]
        ],
        [
          "typedef struct {\n        char type[8];\n        char len;\n      } PKT_FRAME;",
          {
            "type[8]": "char",
            "len": "char"
          },
          "PKT_FRAME",
          [
            42,
            0
          ],
          [
            45,
            18
          ]
        ],
        [
          "typedef struct {\n        BYTE  class;        /* = 1 for DEC/Interl/Xerox Ethernet */\n        BYTE  number;       /* = 0 for single LAN adapter        */\n        WORD  type;         /* = 13 for 3C523                    */\n        BYTE  funcs;        /* Basic/Extended/HiPerf functions   */\n        WORD  intr;         /* user interrupt vector number      */\n        WORD  handle;       /* Handle associated with session    */\n        BYTE  name [15];    /* Name of adapter interface,ie.3C523*/\n        BOOL  quiet;        /* (don't) print errors to stdout    */\n        const char *error;  /* address of error string           */\n        BYTE  majVer;       /* Major driver implementation ver.  */\n        BYTE  minVer;       /* Minor driver implementation ver.  */\n        BYTE  dummyLen;     /* length of following data          */\n        WORD  MAClength;    /* HiPerformance data, N/A           */\n        WORD  MTU;          /* HiPerformance data, N/A           */\n        WORD  multicast;    /* HiPerformance data, N/A           */\n        WORD  rcvrBuffers;  /* valid for                         */\n        WORD  UMTbufs;      /*   High Performance drivers only   */\n        WORD  postEOIintr;  /*                  Usage ??         */\n      } PKT_INFO;",
          {
            "class": "BYTE",
            "number": "BYTE",
            "type": "WORD",
            "funcs": "BYTE",
            "intr": "WORD",
            "handle": "WORD",
            "name [15]": "BYTE",
            "quiet": "BOOL",
            "char": "const",
            "majVer": "BYTE",
            "minVer": "BYTE",
            "dummyLen": "BYTE",
            "MAClength": "WORD",
            "MTU": "WORD",
            "multicast": "WORD",
            "rcvrBuffers": "WORD",
            "UMTbufs": "WORD",
            "postEOIintr": "WORD"
          },
          "PKT_INFO",
          [
            48,
            0
          ],
          [
            67,
            17
          ]
        ],
        [
          "typedef struct {\n        DWORD inPackets;          /* # of packets received    */\n        DWORD outPackets;         /* # of packets transmitted */\n        DWORD inBytes;            /* # of bytes received      */\n        DWORD outBytes;           /* # of bytes transmitted   */\n        DWORD inErrors;           /* # of reception errors    */\n        DWORD outErrors;          /* # of transmission errors */\n        DWORD lost;               /* # of packets lost (RX)   */\n      } PKT_STAT;",
          {
            "inPackets": "DWORD",
            "outPackets": "DWORD",
            "inBytes": "DWORD",
            "outBytes": "DWORD",
            "inErrors": "DWORD",
            "outErrors": "DWORD",
            "lost": "DWORD"
          },
          "PKT_STAT",
          [
            72,
            0
          ],
          [
            80,
            17
          ]
        ],
        [
          "typedef struct {\n        ETHER destin;\n        ETHER source;\n        WORD  proto;\n        BYTE  data [TX_BUF_SIZE];\n      } TX_ELEMENT;",
          {
            "destin": "ETHER",
            "source": "ETHER",
            "proto": "WORD",
            "data [TX_BUF_SIZE]": "BYTE"
          },
          "TX_ELEMENT",
          [
            83,
            0
          ],
          [
            88,
            19
          ]
        ],
        [
          "typedef struct {\n        WORD  firstCount;         /* # of bytes on 1st         */\n        WORD  secondCount;        /* and 2nd upcall            */\n        WORD  handle;             /* instance that upcalled    */\n        ETHER destin;             /* E-net destination address */\n        ETHER source;             /* E-net source address      */\n        WORD  proto;              /* protocol number           */\n        BYTE  data [RX_BUF_SIZE];\n      } RX_ELEMENT;",
          {
            "firstCount": "WORD",
            "secondCount": "WORD",
            "handle": "WORD",
            "destin": "ETHER",
            "source": "ETHER",
            "proto": "WORD",
            "data [RX_BUF_SIZE]": "BYTE"
          },
          "RX_ELEMENT",
          [
            90,
            0
          ],
          [
            98,
            19
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum  {                /* Packet-driver classes */\n        PD_ETHER      = 1,\n        PD_PRONET10   = 2,\n        PD_IEEE8025   = 3,\n        PD_OMNINET    = 4,\n        PD_APPLETALK  = 5,\n        PD_SLIP       = 6,\n        PD_STARTLAN   = 7,\n        PD_ARCNET     = 8,\n        PD_AX25       = 9,\n        PD_KISS       = 10,\n        PD_IEEE8023_2 = 11,\n        PD_FDDI8022   = 12,\n        PD_X25        = 13,\n        PD_LANstar    = 14,\n        PD_PPP        = 18\n      } PKT_CLASS;",
          {
            "PD_ETHER": "",
            "PD_PRONET10": "",
            "PD_IEEE8025": "",
            "PD_OMNINET": "",
            "PD_APPLETALK": "",
            "PD_SLIP": "",
            "PD_STARTLAN": "",
            "PD_ARCNET": "",
            "PD_AX25": "",
            "PD_KISS": "",
            "PD_IEEE8023_2": "",
            "PD_FDDI8022": "",
            "PD_X25": "",
            "PD_LANstar": "",
            "PD_PPP": ""
          },
          "PKT_CLASS",
          [
            15,
            0
          ],
          [
            31,
            18
          ]
        ],
        [
          "typedef enum  {             /* Packet-driver receive modes    */\n        PDRX_OFF    = 1,    /* turn off receiver              */\n        PDRX_DIRECT,        /* receive only to this interface */\n        PDRX_BROADCAST,     /* DIRECT + broadcast packets     */\n        PDRX_MULTICAST1,    /* BROADCAST + limited multicast  */\n        PDRX_MULTICAST2,    /* BROADCAST + all multicast      */\n        PDRX_ALL_PACKETS,   /* receive all packets on network */\n      } PKT_RX_MODE;",
          {
            "PDRX_OFF": "",
            "PDRX_DIRECT": "",
            "PDRX_BROADCAST": "",
            "PDRX_MULTICAST1": "",
            "PDRX_MULTICAST2": "",
            "PDRX_ALL_PACKETS": ""
          },
          "PKT_RX_MODE",
          [
            33,
            0
          ],
          [
            40,
            20
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/testprogs/unix.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/rpcapd/config_params.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct active_pars\n{\n\tchar address[MAX_LINE + 1];\t// keeps the network address (either numeric or literal) to of the active client\n\tchar port[MAX_LINE + 1];\t// keeps the network port to bind to\n\tint ai_family;\t\t\t// address faimly to use\n}",
          {
            "address[MAX_LINE + 1]": "char",
            "port[MAX_LINE + 1]": "char",
            "ai_family": "int"
          },
          "active_pars",
          [
            43,
            0
          ],
          [
            48,
            1
          ]
        ],
        [
          "struct active_pars\n{\n\tchar address[MAX_LINE + 1];\t// keeps the network address (either numeric or literal) to of the active client\n\tchar port[MAX_LINE + 1];\t// keeps the network port to bind to\n\tint ai_family;\t\t\t// address faimly to use\n}",
          {
            "address[MAX_LINE + 1]": "char",
            "port[MAX_LINE + 1]": "char",
            "ai_family": "int"
          },
          "active_pars",
          [
            43,
            0
          ],
          [
            48,
            1
          ]
        ],
        [
          "struct active_pars",
          {},
          "",
          [
            51,
            7
          ],
          [
            51,
            25
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/rpcapd/log.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "rpcapd_log_set(int, int)",
          "fn_dec_pos": [
            [
              23,
              12
            ],
            [
              23,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcapd_log_set",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "rpcapd_log(log_priority priority,\n    PCAP_FORMAT_STRING(const char *message), ...)",
          "fn_dec_pos": [
            [
              32,
              12
            ],
            [
              33,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rpcapd_log",
            "parameters": {
              "priority": "log_priority",
              "message": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"pcap/funcattrs.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n\tLOGPRIO_DEBUG,\n\tLOGPRIO_INFO,\n\tLOGPRIO_WARNING,\n\tLOGPRIO_ERROR\n} log_priority;",
          {
            "LOGPRIO_DEBUG": "",
            "LOGPRIO_INFO": "",
            "LOGPRIO_WARNING": "",
            "LOGPRIO_ERROR": ""
          },
          "log_priority",
          [
            25,
            0
          ],
          [
            30,
            15
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/rpcapd/rpcapd.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "send_shutdown_notification(void)",
          "fn_dec_pos": [
            [
              38,
              5
            ],
            [
              38,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "send_shutdown_notification",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "send_reread_configuration_notification(void)",
          "fn_dec_pos": [
            [
              39,
              5
            ],
            [
              39,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "send_reread_configuration_notification",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "main_startup(void)",
          "fn_dec_pos": [
            [
              41,
              5
            ],
            [
              41,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main_startup",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/rpcapd/daemon.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "daemon_serviceloop(SOCKET sockctrl, int isactive, char *passiveClients,\n    int nullAuthAllowed, int uses_ssl)",
          "fn_dec_pos": [
            [
              46,
              4
            ],
            [
              47,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "daemon_serviceloop",
            "parameters": {
              "sockctrl": "SOCKET",
              "isactive": "int",
              "passiveClients": "char",
              "nullAuthAllowed": "int",
              "uses_ssl": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "sleep_secs(int secs)",
          "fn_dec_pos": [
            [
              49,
              5
            ],
            [
              49,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sleep_secs",
            "parameters": {
              "secs": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <config.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"sslutils.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/rpcapd/fileconf.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "fileconf_read(void)",
          "fn_dec_pos": [
            [
              35,
              5
            ],
            [
              35,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fileconf_read",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "fileconf_save(const char *savefile)",
          "fn_dec_pos": [
            [
              36,
              4
            ],
            [
              36,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fileconf_save",
            "parameters": {
              "savefile": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/rpcapd/win32-svc.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "svc_start(void)",
          "fn_dec_pos": [
            [
              32,
              4
            ],
            [
              32,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "svc_start",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libpcap/missing/getopt.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "getopt(int nargc, char * const *nargv, const char *ostr)",
          "fn_dec_pos": [
            [
              6,
              11
            ],
            [
              6,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {
              "nargc": "int",
              "nargv": "char",
              "ostr": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    }
  }
}