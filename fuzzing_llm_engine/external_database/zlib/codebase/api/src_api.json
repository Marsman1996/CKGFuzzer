{
  "src": {
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/inffast.c": {
      "fn_def_list": [
        {
          "fn_code": "void ZLIB_INTERNAL inflate_fast(z_streamp strm, unsigned start) {\n    struct inflate_state FAR *state;\n    z_const unsigned char FAR *in;      /* local strm->next_in */\n    z_const unsigned char FAR *last;    /* have enough input while in < last */\n    unsigned char FAR *out;     /* local strm->next_out */\n    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */\n    unsigned char FAR *end;     /* while out < end, enough space available */\n#ifdef INFLATE_STRICT\n    unsigned dmax;              /* maximum distance from zlib header */\n#endif\n    unsigned wsize;             /* window size or zero if not using window */\n    unsigned whave;             /* valid bytes in the window */\n    unsigned wnext;             /* window write index */\n    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */\n    unsigned long hold;         /* local strm->hold */\n    unsigned bits;              /* local strm->bits */\n    code const FAR *lcode;      /* local strm->lencode */\n    code const FAR *dcode;      /* local strm->distcode */\n    unsigned lmask;             /* mask for first level of length codes */\n    unsigned dmask;             /* mask for first level of distance codes */\n    code const *here;           /* retrieved table entry */\n    unsigned op;                /* code bits, operation, extra bits, or */\n                                /*  window position, window bytes to copy */\n    unsigned len;               /* match length, unused bytes */\n    unsigned dist;              /* match distance */\n    unsigned char FAR *from;    /* where to copy match from */\n\n    /* copy state to local variables */\n    state = (struct inflate_state FAR *)strm->state;\n    in = strm->next_in;\n    last = in + (strm->avail_in - 5);\n    out = strm->next_out;\n    beg = out - (start - strm->avail_out);\n    end = out + (strm->avail_out - 257);\n#ifdef INFLATE_STRICT\n    dmax = state->dmax;\n#endif\n    wsize = state->wsize;\n    whave = state->whave;\n    wnext = state->wnext;\n    window = state->window;\n    hold = state->hold;\n    bits = state->bits;\n    lcode = state->lencode;\n    dcode = state->distcode;\n    lmask = (1U << state->lenbits) - 1;\n    dmask = (1U << state->distbits) - 1;\n\n    /* decode literals and length/distances until end-of-block or not enough\n       input data or output space */\n    do {\n        if (bits < 15) {\n            hold += (unsigned long)(*in++) << bits;\n            bits += 8;\n            hold += (unsigned long)(*in++) << bits;\n            bits += 8;\n        }\n        here = lcode + (hold & lmask);\n      dolen:\n        op = (unsigned)(here->bits);\n        hold >>= op;\n        bits -= op;\n        op = (unsigned)(here->op);\n        if (op == 0) {                          /* literal */\n            Tracevv((stderr, here->val >= 0x20 && here->val < 0x7f ?\n                    \"inflate:         literal '%c'\\n\" :\n                    \"inflate:         literal 0x%02x\\n\", here->val));\n            *out++ = (unsigned char)(here->val);\n        }\n        else if (op & 16) {                     /* length base */\n            len = (unsigned)(here->val);\n            op &= 15;                           /* number of extra bits */\n            if (op) {\n                if (bits < op) {\n                    hold += (unsigned long)(*in++) << bits;\n                    bits += 8;\n                }\n                len += (unsigned)hold & ((1U << op) - 1);\n                hold >>= op;\n                bits -= op;\n            }\n            Tracevv((stderr, \"inflate:         length %u\\n\", len));\n            if (bits < 15) {\n                hold += (unsigned long)(*in++) << bits;\n                bits += 8;\n                hold += (unsigned long)(*in++) << bits;\n                bits += 8;\n            }\n            here = dcode + (hold & dmask);\n          dodist:\n            op = (unsigned)(here->bits);\n            hold >>= op;\n            bits -= op;\n            op = (unsigned)(here->op);\n            if (op & 16) {                      /* distance base */\n                dist = (unsigned)(here->val);\n                op &= 15;                       /* number of extra bits */\n                if (bits < op) {\n                    hold += (unsigned long)(*in++) << bits;\n                    bits += 8;\n                    if (bits < op) {\n                        hold += (unsigned long)(*in++) << bits;\n                        bits += 8;\n                    }\n                }\n                dist += (unsigned)hold & ((1U << op) - 1);\n#ifdef INFLATE_STRICT\n                if (dist > dmax) {\n                    strm->msg = (z_const char *)\"invalid distance too far back\";\n                    state->mode = BAD;\n                    break;\n                }\n#endif\n                hold >>= op;\n                bits -= op;\n                Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n                op = (unsigned)(out - beg);     /* max distance in output */\n                if (dist > op) {                /* see if copy from window */\n                    op = dist - op;             /* distance back in window */\n                    if (op > whave) {\n                        if (state->sane) {\n                            strm->msg =\n                                (z_const char *)\"invalid distance too far back\";\n                            state->mode = BAD;\n                            break;\n                        }\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                        if (len <= op - whave) {\n                            do {\n                                *out++ = 0;\n                            } while (--len);\n                            continue;\n                        }\n                        len -= op - whave;\n                        do {\n                            *out++ = 0;\n                        } while (--op > whave);\n                        if (op == 0) {\n                            from = out - dist;\n                            do {\n                                *out++ = *from++;\n                            } while (--len);\n                            continue;\n                        }\n#endif\n                    }\n                    from = window;\n                    if (wnext == 0) {           /* very common case */\n                        from += wsize - op;\n                        if (op < len) {         /* some from window */\n                            len -= op;\n                            do {\n                                *out++ = *from++;\n                            } while (--op);\n                            from = out - dist;  /* rest from output */\n                        }\n                    }\n                    else if (wnext < op) {      /* wrap around window */\n                        from += wsize + wnext - op;\n                        op -= wnext;\n                        if (op < len) {         /* some from end of window */\n                            len -= op;\n                            do {\n                                *out++ = *from++;\n                            } while (--op);\n                            from = window;\n                            if (wnext < len) {  /* some from start of window */\n                                op = wnext;\n                                len -= op;\n                                do {\n                                    *out++ = *from++;\n                                } while (--op);\n                                from = out - dist;      /* rest from output */\n                            }\n                        }\n                    }\n                    else {                      /* contiguous in window */\n                        from += wnext - op;\n                        if (op < len) {         /* some from window */\n                            len -= op;\n                            do {\n                                *out++ = *from++;\n                            } while (--op);\n                            from = out - dist;  /* rest from output */\n                        }\n                    }\n                    while (len > 2) {\n                        *out++ = *from++;\n                        *out++ = *from++;\n                        *out++ = *from++;\n                        len -= 3;\n                    }\n                    if (len) {\n                        *out++ = *from++;\n                        if (len > 1)\n                            *out++ = *from++;\n                    }\n                }\n                else {\n                    from = out - dist;          /* copy direct from output */\n                    do {                        /* minimum length is three */\n                        *out++ = *from++;\n                        *out++ = *from++;\n                        *out++ = *from++;\n                        len -= 3;\n                    } while (len > 2);\n                    if (len) {\n                        *out++ = *from++;\n                        if (len > 1)\n                            *out++ = *from++;\n                    }\n                }\n            }\n            else if ((op & 64) == 0) {          /* 2nd level distance code */\n                here = dcode + here->val + (hold & ((1U << op) - 1));\n                goto dodist;\n            }\n            else {\n                strm->msg = (z_const char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n        }\n        else if ((op & 64) == 0) {              /* 2nd level length code */\n            here = lcode + here->val + (hold & ((1U << op) - 1));\n            goto dolen;\n        }\n        else if (op & 32) {                     /* end-of-block */\n            Tracevv((stderr, \"inflate:         end of block\\n\"));\n            state->mode = TYPE;\n            break;\n        }\n        else {\n            strm->msg = (z_const char *)\"invalid literal/length code\";\n            state->mode = BAD;\n            break;\n        }\n    } while (in < last && out < end);\n\n    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n    len = bits >> 3;\n    in -= len;\n    bits -= len << 3;\n    hold &= (1U << bits) - 1;\n\n    /* update state and return */\n    strm->next_in = in;\n    strm->next_out = out;\n    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));\n    strm->avail_out = (unsigned)(out < end ?\n                                 257 + (end - out) : 257 - (out - end));\n    state->hold = hold;\n    state->bits = bits;\n    return;\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              303,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL inflate_fast",
            "parameters": {
              "strm": "z_streamp",
              "start": "unsigned"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct inflate_state",
          {},
          "",
          [
            50,
            4
          ],
          [
            50,
            24
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            77,
            13
          ],
          [
            77,
            33
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"zutil.h\"\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ],
        [
          "#include \"inftrees.h\"\n",
          [
            6,
            0
          ],
          [
            7,
            0
          ]
        ],
        [
          "#include \"inflate.h\"\n",
          [
            7,
            0
          ],
          [
            8,
            0
          ]
        ],
        [
          "#include \"inffast.h\"\n",
          [
            8,
            0
          ],
          [
            9,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/compress.c": {
      "fn_def_list": [
        {
          "fn_code": "int ZEXPORT compress2(Bytef *dest, uLongf *destLen, const Bytef *source,\n                      uLong sourceLen, int level) {\n    z_stream stream;\n    int err;\n    const uInt max = (uInt)-1;\n    uLong left;\n\n    left = *destLen;\n    *destLen = 0;\n\n    stream.zalloc = (alloc_func)0;\n    stream.zfree = (free_func)0;\n    stream.opaque = (voidpf)0;\n\n    err = deflateInit(&stream, level);\n    if (err != Z_OK) return err;\n\n    stream.next_out = dest;\n    stream.avail_out = 0;\n    stream.next_in = (z_const Bytef *)source;\n    stream.avail_in = 0;\n\n    do {\n        if (stream.avail_out == 0) {\n            stream.avail_out = left > (uLong)max ? max : (uInt)left;\n            left -= stream.avail_out;\n        }\n        if (stream.avail_in == 0) {\n            stream.avail_in = sourceLen > (uLong)max ? max : (uInt)sourceLen;\n            sourceLen -= stream.avail_in;\n        }\n        err = deflate(&stream, sourceLen ? Z_NO_FLUSH : Z_FINISH);\n    } while (err == Z_OK);\n\n    *destLen = stream.total_out;\n    deflateEnd(&stream);\n    return err == Z_STREAM_END ? Z_OK : err;\n}",
          "fn_code_pos": [
            [
              21,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compress2",
            "parameters": {
              "dest": "Bytef",
              "destLen": "uLongf",
              "source": "Bytef",
              "sourceLen": "uLong",
              "level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT compress(Bytef *dest, uLongf *destLen, const Bytef *source,\n                     uLong sourceLen) {\n    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compress",
            "parameters": {
              "dest": "Bytef",
              "destLen": "uLongf",
              "source": "Bytef",
              "sourceLen": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "uLong ZEXPORT compressBound(uLong sourceLen) {\n    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +\n           (sourceLen >> 25) + 13;\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              74,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compressBound",
            "parameters": {
              "sourceLen": "uLong"
            },
            "return_type": "uLong"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"zlib.h\"\n",
          [
            8,
            0
          ],
          [
            9,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/deflate.c": {
      "fn_def_list": [
        {
          "fn_code": "local void slide_hash(deflate_state *s) {\n    unsigned n, m;\n    Posf *p;\n    uInt wsize = s->w_size;\n\n    n = s->hash_size;\n    p = &s->head[n];\n    do {\n        m = *--p;\n        *p = (Pos)(m >= wsize ? m - wsize : NIL);\n    } while (--n);\n    n = wsize;\n#ifndef FASTEST\n    p = &s->prev[n];\n    do {\n        m = *--p;\n        *p = (Pos)(m >= wsize ? m - wsize : NIL);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n    } while (--n);\n#endif\n}",
          "fn_code_pos": [
            [
              186,
              0
            ],
            [
              208,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "slide_hash",
            "parameters": {
              "s": "deflate_state"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local unsigned read_buf(z_streamp strm, Bytef *buf, unsigned size) {\n    unsigned len = strm->avail_in;\n\n    if (len > size) len = size;\n    if (len == 0) return 0;\n\n    strm->avail_in  -= len;\n\n    zmemcpy(buf, strm->next_in, len);\n    if (strm->state->wrap == 1) {\n        strm->adler = adler32(strm->adler, buf, len);\n    }\n#ifdef GZIP\n    else if (strm->state->wrap == 2) {\n        strm->adler = crc32(strm->adler, buf, len);\n    }\n#endif\n    strm->next_in  += len;\n    strm->total_in += len;\n\n    return len;\n}",
          "fn_code_pos": [
            [
              217,
              0
            ],
            [
              238,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_buf",
            "parameters": {
              "strm": "z_streamp",
              "buf": "Bytef",
              "size": "unsigned"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "local void fill_window(deflate_state *s) {\n    unsigned n;\n    unsigned more;    /* Amount of free space at the end of the window. */\n    uInt wsize = s->w_size;\n\n    Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n    do {\n        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);\n\n        /* Deal with !@#$% 64K limit: */\n        if (sizeof(int) <= 2) {\n            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n                more = wsize;\n\n            } else if (more == (unsigned)(-1)) {\n                /* Very unlikely, but possible on 16 bit machine if\n                 * strstart == 0 && lookahead == 1 (input done a byte at time)\n                 */\n                more--;\n            }\n        }\n\n        /* If the window is almost full and there is insufficient lookahead,\n         * move the upper half to the lower one to make room in the upper half.\n         */\n        if (s->strstart >= wsize + MAX_DIST(s)) {\n\n            zmemcpy(s->window, s->window + wsize, (unsigned)wsize - more);\n            s->match_start -= wsize;\n            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */\n            s->block_start -= (long) wsize;\n            if (s->insert > s->strstart)\n                s->insert = s->strstart;\n            slide_hash(s);\n            more += wsize;\n        }\n        if (s->strm->avail_in == 0) break;\n\n        /* If there was no sliding:\n         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n         *    more == window_size - lookahead - strstart\n         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n         * => more >= window_size - 2*WSIZE + 2\n         * In the BIG_MEM or MMAP case (not yet supported),\n         *   window_size == input_size + MIN_LOOKAHEAD  &&\n         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n         * Otherwise, window_size == 2*WSIZE so more >= 2.\n         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n         */\n        Assert(more >= 2, \"more < 2\");\n\n        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);\n        s->lookahead += n;\n\n        /* Initialize the hash value now that we have some input: */\n        if (s->lookahead + s->insert >= MIN_MATCH) {\n            uInt str = s->strstart - s->insert;\n            s->ins_h = s->window[str];\n            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);\n#if MIN_MATCH != 3\n            Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n            while (s->insert) {\n                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);\n#ifndef FASTEST\n                s->prev[str & s->w_mask] = s->head[s->ins_h];\n#endif\n                s->head[s->ins_h] = (Pos)str;\n                str++;\n                s->insert--;\n                if (s->lookahead + s->insert < MIN_MATCH)\n                    break;\n            }\n        }\n        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n         * but this is not important since only literal bytes will be emitted.\n         */\n\n    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);\n\n    /* If the WIN_INIT bytes after the end of the current data have never been\n     * written, then zero those bytes in order to avoid memory check reports of\n     * the use of uninitialized (or uninitialised as Julian writes) bytes by\n     * the longest match routines.  Update the high water mark for the next\n     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n     */\n    if (s->high_water < s->window_size) {\n        ulg curr = s->strstart + (ulg)(s->lookahead);\n        ulg init;\n\n        if (s->high_water < curr) {\n            /* Previous high water mark below current data -- zero WIN_INIT\n             * bytes or up to end of window, whichever is less.\n             */\n            init = s->window_size - curr;\n            if (init > WIN_INIT)\n                init = WIN_INIT;\n            zmemzero(s->window + curr, (unsigned)init);\n            s->high_water = curr + init;\n        }\n        else if (s->high_water < (ulg)curr + WIN_INIT) {\n            /* High water mark at or above current data, but below current data\n             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n             * to end of window, whichever is less.\n             */\n            init = (ulg)curr + WIN_INIT - s->high_water;\n            if (init > s->window_size - s->high_water)\n                init = s->window_size - s->high_water;\n            zmemzero(s->window + s->high_water, (unsigned)init);\n            s->high_water += init;\n        }\n    }\n\n    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n           \"not enough room for search\");\n}",
          "fn_code_pos": [
            [
              250,
              0
            ],
            [
              367,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fill_window",
            "parameters": {
              "s": "deflate_state"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int ZEXPORT deflateInit_(z_streamp strm, int level, const char *version,\n                         int stream_size) {\n    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,\n                         Z_DEFAULT_STRATEGY, version, stream_size);\n    /* To do: ignore strm->next_in if we use it as window */\n}",
          "fn_code_pos": [
            [
              370,
              0
            ],
            [
              375,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateInit_",
            "parameters": {
              "strm": "z_streamp",
              "level": "int",
              "version": "char",
              "stream_size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT deflateInit2_(z_streamp strm, int level, int method,\n                          int windowBits, int memLevel, int strategy,\n                          const char *version, int stream_size) {\n    deflate_state *s;\n    int wrap = 1;\n    static const char my_version[] = ZLIB_VERSION;\n\n    if (version == Z_NULL || version[0] != my_version[0] ||\n        stream_size != sizeof(z_stream)) {\n        return Z_VERSION_ERROR;\n    }\n    if (strm == Z_NULL) return Z_STREAM_ERROR;\n\n    strm->msg = Z_NULL;\n    if (strm->zalloc == (alloc_func)0) {\n#ifdef Z_SOLO\n        return Z_STREAM_ERROR;\n#else\n        strm->zalloc = zcalloc;\n        strm->opaque = (voidpf)0;\n#endif\n    }\n    if (strm->zfree == (free_func)0)\n#ifdef Z_SOLO\n        return Z_STREAM_ERROR;\n#else\n        strm->zfree = zcfree;\n#endif\n\n#ifdef FASTEST\n    if (level != 0) level = 1;\n#else\n    if (level == Z_DEFAULT_COMPRESSION) level = 6;\n#endif\n\n    if (windowBits < 0) { /* suppress zlib wrapper */\n        wrap = 0;\n        if (windowBits < -15)\n            return Z_STREAM_ERROR;\n        windowBits = -windowBits;\n    }\n#ifdef GZIP\n    else if (windowBits > 15) {\n        wrap = 2;       /* write gzip wrapper instead */\n        windowBits -= 16;\n    }\n#endif\n    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||\n        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n        strategy < 0 || strategy > Z_FIXED || (windowBits == 8 && wrap != 1)) {\n        return Z_STREAM_ERROR;\n    }\n    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */\n    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));\n    if (s == Z_NULL) return Z_MEM_ERROR;\n    strm->state = (struct internal_state FAR *)s;\n    s->strm = strm;\n    s->status = INIT_STATE;     /* to pass state test in deflateReset() */\n\n    s->wrap = wrap;\n    s->gzhead = Z_NULL;\n    s->w_bits = (uInt)windowBits;\n    s->w_size = 1 << s->w_bits;\n    s->w_mask = s->w_size - 1;\n\n    s->hash_bits = (uInt)memLevel + 7;\n    s->hash_size = 1 << s->hash_bits;\n    s->hash_mask = s->hash_size - 1;\n    s->hash_shift =  ((s->hash_bits + MIN_MATCH-1) / MIN_MATCH);\n\n    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));\n    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));\n    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));\n\n    s->high_water = 0;      /* nothing written to s->window yet */\n\n    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n    /* We overlay pending_buf and sym_buf. This works since the average size\n     * for length/distance pairs over any compressed block is assured to be 31\n     * bits or less.\n     *\n     * Analysis: The longest fixed codes are a length code of 8 bits plus 5\n     * extra bits, for lengths 131 to 257. The longest fixed distance codes are\n     * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest\n     * possible fixed-codes length/distance pair is then 31 bits total.\n     *\n     * sym_buf starts one-fourth of the way into pending_buf. So there are\n     * three bytes in sym_buf for every four bytes in pending_buf. Each symbol\n     * in sym_buf is three bytes -- two for the distance and one for the\n     * literal/length. As each symbol is consumed, the pointer to the next\n     * sym_buf value to read moves forward three bytes. From that symbol, up to\n     * 31 bits are written to pending_buf. The closest the written pending_buf\n     * bits gets to the next sym_buf symbol to read is just before the last\n     * code is written. At that time, 31*(n - 2) bits have been written, just\n     * after 24*(n - 2) bits have been consumed from sym_buf. sym_buf starts at\n     * 8*n bits into pending_buf. (Note that the symbol buffer fills when n - 1\n     * symbols are written.) The closest the writing gets to what is unread is\n     * then n + 14 bits. Here n is lit_bufsize, which is 16384 by default, and\n     * can range from 128 to 32768.\n     *\n     * Therefore, at a minimum, there are 142 bits of space between what is\n     * written and what is read in the overlain buffers, so the symbols cannot\n     * be overwritten by the compressed data. That space is actually 139 bits,\n     * due to the three-bit fixed-code block header.\n     *\n     * That covers the case where either Z_FIXED is specified, forcing fixed\n     * codes, or when the use of fixed codes is chosen, because that choice\n     * results in a smaller compressed block than dynamic codes. That latter\n     * condition then assures that the above analysis also covers all dynamic\n     * blocks. A dynamic-code block will only be chosen to be emitted if it has\n     * fewer bits than a fixed-code block would for the same set of symbols.\n     * Therefore its average symbol length is assured to be less than 31. So\n     * the compressed data for a dynamic block also cannot overwrite the\n     * symbols from which it is being constructed.\n     */\n\n    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, LIT_BUFS);\n    s->pending_buf_size = (ulg)s->lit_bufsize * 4;\n\n    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||\n        s->pending_buf == Z_NULL) {\n        s->status = FINISH_STATE;\n        strm->msg = ERR_MSG(Z_MEM_ERROR);\n        deflateEnd (strm);\n        return Z_MEM_ERROR;\n    }\n#ifdef LIT_MEM\n    s->d_buf = (ushf *)(s->pending_buf + (s->lit_bufsize << 1));\n    s->l_buf = s->pending_buf + (s->lit_bufsize << 2);\n    s->sym_end = s->lit_bufsize - 1;\n#else\n    s->sym_buf = s->pending_buf + s->lit_bufsize;\n    s->sym_end = (s->lit_bufsize - 1) * 3;\n#endif\n    /* We avoid equality with lit_bufsize*3 because of wraparound at 64K\n     * on 16 bit machines and because stored blocks are restricted to\n     * 64K-1 bytes.\n     */\n\n    s->level = level;\n    s->strategy = strategy;\n    s->method = (Byte)method;\n\n    return deflateReset(strm);\n}",
          "fn_code_pos": [
            [
              378,
              0
            ],
            [
              523,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateInit2_",
            "parameters": {
              "strm": "z_streamp",
              "level": "int",
              "method": "int",
              "windowBits": "int",
              "memLevel": "int",
              "strategy": "int",
              "version": "char",
              "stream_size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "local int deflateStateCheck(z_streamp strm) {\n    deflate_state *s;\n    if (strm == Z_NULL ||\n        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)\n        return 1;\n    s = strm->state;\n    if (s == Z_NULL || s->strm != strm || (s->status != INIT_STATE &&\n#ifdef GZIP\n                                           s->status != GZIP_STATE &&\n#endif\n                                           s->status != EXTRA_STATE &&\n                                           s->status != NAME_STATE &&\n                                           s->status != COMMENT_STATE &&\n                                           s->status != HCRC_STATE &&\n                                           s->status != BUSY_STATE &&\n                                           s->status != FINISH_STATE))\n        return 1;\n    return 0;\n}",
          "fn_code_pos": [
            [
              528,
              0
            ],
            [
              546,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateStateCheck",
            "parameters": {
              "strm": "z_streamp"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int ZEXPORT deflateSetDictionary(z_streamp strm, const Bytef *dictionary,\n                                 uInt  dictLength) {\n    deflate_state *s;\n    uInt str, n;\n    int wrap;\n    unsigned avail;\n    z_const unsigned char *next;\n\n    if (deflateStateCheck(strm) || dictionary == Z_NULL)\n        return Z_STREAM_ERROR;\n    s = strm->state;\n    wrap = s->wrap;\n    if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)\n        return Z_STREAM_ERROR;\n\n    /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n    if (wrap == 1)\n        strm->adler = adler32(strm->adler, dictionary, dictLength);\n    s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */\n\n    /* if dictionary would fill window, just replace the history */\n    if (dictLength >= s->w_size) {\n        if (wrap == 0) {            /* already empty otherwise */\n            CLEAR_HASH(s);\n            s->strstart = 0;\n            s->block_start = 0L;\n            s->insert = 0;\n        }\n        dictionary += dictLength - s->w_size;  /* use the tail */\n        dictLength = s->w_size;\n    }\n\n    /* insert dictionary into window and hash */\n    avail = strm->avail_in;\n    next = strm->next_in;\n    strm->avail_in = dictLength;\n    strm->next_in = (z_const Bytef *)dictionary;\n    fill_window(s);\n    while (s->lookahead >= MIN_MATCH) {\n        str = s->strstart;\n        n = s->lookahead - (MIN_MATCH-1);\n        do {\n            UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);\n#ifndef FASTEST\n            s->prev[str & s->w_mask] = s->head[s->ins_h];\n#endif\n            s->head[s->ins_h] = (Pos)str;\n            str++;\n        } while (--n);\n        s->strstart = str;\n        s->lookahead = MIN_MATCH-1;\n        fill_window(s);\n    }\n    s->strstart += s->lookahead;\n    s->block_start = (long)s->strstart;\n    s->insert = s->lookahead;\n    s->lookahead = 0;\n    s->match_length = s->prev_length = MIN_MATCH-1;\n    s->match_available = 0;\n    strm->next_in = next;\n    strm->avail_in = avail;\n    s->wrap = wrap;\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              549,
              0
            ],
            [
              612,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateSetDictionary",
            "parameters": {
              "strm": "z_streamp",
              "dictionary": "Bytef",
              "dictLength": "uInt"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT deflateGetDictionary(z_streamp strm, Bytef *dictionary,\n                                 uInt *dictLength) {\n    deflate_state *s;\n    uInt len;\n\n    if (deflateStateCheck(strm))\n        return Z_STREAM_ERROR;\n    s = strm->state;\n    len = s->strstart + s->lookahead;\n    if (len > s->w_size)\n        len = s->w_size;\n    if (dictionary != Z_NULL && len)\n        zmemcpy(dictionary, s->window + s->strstart + s->lookahead - len, len);\n    if (dictLength != Z_NULL)\n        *dictLength = len;\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              615,
              0
            ],
            [
              631,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateGetDictionary",
            "parameters": {
              "strm": "z_streamp",
              "dictionary": "Bytef",
              "dictLength": "uInt"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "local void lm_init(deflate_state *s) {\n    s->window_size = (ulg)2L*s->w_size;\n\n    CLEAR_HASH(s);\n\n    /* Set the default configuration parameters:\n     */\n    s->max_lazy_match   = configuration_table[s->level].max_lazy;\n    s->good_match       = configuration_table[s->level].good_length;\n    s->nice_match       = configuration_table[s->level].nice_length;\n    s->max_chain_length = configuration_table[s->level].max_chain;\n\n    s->strstart = 0;\n    s->block_start = 0L;\n    s->lookahead = 0;\n    s->insert = 0;\n    s->match_length = s->prev_length = MIN_MATCH-1;\n    s->match_available = 0;\n    s->ins_h = 0;\n}",
          "fn_code_pos": [
            [
              672,
              0
            ],
            [
              691,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lm_init",
            "parameters": {
              "s": "deflate_state"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int ZEXPORT deflateReset(z_streamp strm) {\n    int ret;\n\n    ret = deflateResetKeep(strm);\n    if (ret == Z_OK)\n        lm_init(strm->state);\n    return ret;\n}",
          "fn_code_pos": [
            [
              694,
              0
            ],
            [
              701,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateReset",
            "parameters": {
              "strm": "z_streamp"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT deflateSetHeader(z_streamp strm, gz_headerp head) {\n    if (deflateStateCheck(strm) || strm->state->wrap != 2)\n        return Z_STREAM_ERROR;\n    strm->state->gzhead = head;\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              704,
              0
            ],
            [
              709,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateSetHeader",
            "parameters": {
              "strm": "z_streamp",
              "head": "gz_headerp"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT deflatePending(z_streamp strm, unsigned *pending, int *bits) {\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    if (pending != Z_NULL)\n        *pending = strm->state->pending;\n    if (bits != Z_NULL)\n        *bits = strm->state->bi_valid;\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              712,
              0
            ],
            [
              719,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflatePending",
            "parameters": {
              "strm": "z_streamp",
              "pending": "unsigned",
              "bits": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT deflateUsed(z_streamp strm, int *bits) {\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    if (bits != Z_NULL)\n        *bits = strm->state->bi_used;\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              722,
              0
            ],
            [
              727,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateUsed",
            "parameters": {
              "strm": "z_streamp",
              "bits": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT deflatePrime(z_streamp strm, int bits, int value) {\n    deflate_state *s;\n    int put;\n\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    s = strm->state;\n#ifdef LIT_MEM\n    if (bits < 0 || bits > 16 ||\n        (uchf *)s->d_buf < s->pending_out + ((Buf_size + 7) >> 3))\n        return Z_BUF_ERROR;\n#else\n    if (bits < 0 || bits > 16 ||\n        s->sym_buf < s->pending_out + ((Buf_size + 7) >> 3))\n        return Z_BUF_ERROR;\n#endif\n    do {\n        put = Buf_size - s->bi_valid;\n        if (put > bits)\n            put = bits;\n        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);\n        s->bi_valid += put;\n        _tr_flush_bits(s);\n        value >>= put;\n        bits -= put;\n    } while (bits);\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              730,
              0
            ],
            [
              756,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflatePrime",
            "parameters": {
              "strm": "z_streamp",
              "bits": "int",
              "value": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT deflateParams(z_streamp strm, int level, int strategy) {\n    deflate_state *s;\n    compress_func func;\n\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    s = strm->state;\n\n#ifdef FASTEST\n    if (level != 0) level = 1;\n#else\n    if (level == Z_DEFAULT_COMPRESSION) level = 6;\n#endif\n    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {\n        return Z_STREAM_ERROR;\n    }\n    func = configuration_table[s->level].func;\n\n    if ((strategy != s->strategy || func != configuration_table[level].func) &&\n        s->last_flush != -2) {\n        /* Flush the last buffer: */\n        int err = deflate(strm, Z_BLOCK);\n        if (err == Z_STREAM_ERROR)\n            return err;\n        if (strm->avail_in || (s->strstart - s->block_start) + s->lookahead)\n            return Z_BUF_ERROR;\n    }\n    if (s->level != level) {\n        if (s->level == 0 && s->matches != 0) {\n            if (s->matches == 1)\n                slide_hash(s);\n            else\n                CLEAR_HASH(s);\n            s->matches = 0;\n        }\n        s->level = level;\n        s->max_lazy_match   = configuration_table[level].max_lazy;\n        s->good_match       = configuration_table[level].good_length;\n        s->nice_match       = configuration_table[level].nice_length;\n        s->max_chain_length = configuration_table[level].max_chain;\n    }\n    s->strategy = strategy;\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              759,
              0
            ],
            [
              801,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateParams",
            "parameters": {
              "strm": "z_streamp",
              "level": "int",
              "strategy": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT deflateTune(z_streamp strm, int good_length, int max_lazy,\n                        int nice_length, int max_chain) {\n    deflate_state *s;\n\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    s = strm->state;\n    s->good_match = (uInt)good_length;\n    s->max_lazy_match = (uInt)max_lazy;\n    s->nice_match = nice_length;\n    s->max_chain_length = (uInt)max_chain;\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              804,
              0
            ],
            [
              815,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateTune",
            "parameters": {
              "strm": "z_streamp",
              "good_length": "int",
              "max_lazy": "int",
              "nice_length": "int",
              "max_chain": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "uLong ZEXPORT deflateBound(z_streamp strm, uLong sourceLen) {\n    deflate_state *s;\n    uLong fixedlen, storelen, wraplen;\n\n    /* upper bound for fixed blocks with 9-bit literals and length 255\n       (memLevel == 2, which is the lowest that may not use stored blocks) --\n       ~13% overhead plus a small constant */\n    fixedlen = sourceLen + (sourceLen >> 3) + (sourceLen >> 8) +\n               (sourceLen >> 9) + 4;\n\n    /* upper bound for stored blocks with length 127 (memLevel == 1) --\n       ~4% overhead plus a small constant */\n    storelen = sourceLen + (sourceLen >> 5) + (sourceLen >> 7) +\n               (sourceLen >> 11) + 7;\n\n    /* if can't get parameters, return larger bound plus a wrapper */\n    if (deflateStateCheck(strm))\n        return (fixedlen > storelen ? fixedlen : storelen) + 18;\n\n    /* compute wrapper length */\n    s = strm->state;\n    switch (s->wrap < 0 ? -s->wrap : s->wrap) {\n    case 0:                                 /* raw deflate */\n        wraplen = 0;\n        break;\n    case 1:                                 /* zlib wrapper */\n        wraplen = 6 + (s->strstart ? 4 : 0);\n        break;\n#ifdef GZIP\n    case 2:                                 /* gzip wrapper */\n        wraplen = 18;\n        if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */\n            Bytef *str;\n            if (s->gzhead->extra != Z_NULL)\n                wraplen += 2 + s->gzhead->extra_len;\n            str = s->gzhead->name;\n            if (str != Z_NULL)\n                do {\n                    wraplen++;\n                } while (*str++);\n            str = s->gzhead->comment;\n            if (str != Z_NULL)\n                do {\n                    wraplen++;\n                } while (*str++);\n            if (s->gzhead->hcrc)\n                wraplen += 2;\n        }\n        break;\n#endif\n    default:                                /* for compiler happiness */\n        wraplen = 18;\n    }\n\n    /* if not default parameters, return one of the conservative bounds */\n    if (s->w_bits != 15 || s->hash_bits != 8 + 7)\n        return (s->w_bits <= s->hash_bits && s->level ? fixedlen : storelen) +\n               wraplen;\n\n    /* default settings: return tight bound for that case -- ~0.03% overhead\n       plus a small constant */\n    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +\n           (sourceLen >> 25) + 13 - 6 + wraplen;\n}",
          "fn_code_pos": [
            [
              841,
              0
            ],
            [
              904,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateBound",
            "parameters": {
              "strm": "z_streamp",
              "sourceLen": "uLong"
            },
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "local void putShortMSB(deflate_state *s, uInt b) {\n    put_byte(s, (Byte)(b >> 8));\n    put_byte(s, (Byte)(b & 0xff));\n}",
          "fn_code_pos": [
            [
              911,
              0
            ],
            [
              914,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "putShortMSB",
            "parameters": {
              "s": "deflate_state",
              "b": "uInt"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void flush_pending(z_streamp strm) {\n    unsigned len;\n    deflate_state *s = strm->state;\n\n    _tr_flush_bits(s);\n    len = s->pending;\n    if (len > strm->avail_out) len = strm->avail_out;\n    if (len == 0) return;\n\n    zmemcpy(strm->next_out, s->pending_out, len);\n    strm->next_out  += len;\n    s->pending_out  += len;\n    strm->total_out += len;\n    strm->avail_out -= len;\n    s->pending      -= len;\n    if (s->pending == 0) {\n        s->pending_out = s->pending_buf;\n    }\n}",
          "fn_code_pos": [
            [
              922,
              0
            ],
            [
              940,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "flush_pending",
            "parameters": {
              "strm": "z_streamp"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int ZEXPORT deflate(z_streamp strm, int flush) {\n    int old_flush; /* value of flush param for previous deflate call */\n    deflate_state *s;\n\n    if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {\n        return Z_STREAM_ERROR;\n    }\n    s = strm->state;\n\n    if (strm->next_out == Z_NULL ||\n        (strm->avail_in != 0 && strm->next_in == Z_NULL) ||\n        (s->status == FINISH_STATE && flush != Z_FINISH)) {\n        ERR_RETURN(strm, Z_STREAM_ERROR);\n    }\n    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);\n\n    old_flush = s->last_flush;\n    s->last_flush = flush;\n\n    /* Flush as much pending output as possible */\n    if (s->pending != 0) {\n        flush_pending(strm);\n        if (strm->avail_out == 0) {\n            /* Since avail_out is 0, deflate will be called again with\n             * more output space, but possibly with both pending and\n             * avail_in equal to zero. There won't be anything to do,\n             * but this is not an error situation so make sure we\n             * return OK instead of BUF_ERROR at next call of deflate:\n             */\n            s->last_flush = -1;\n            return Z_OK;\n        }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n    } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&\n               flush != Z_FINISH) {\n        ERR_RETURN(strm, Z_BUF_ERROR);\n    }\n\n    /* User must not provide more input after the first FINISH: */\n    if (s->status == FINISH_STATE && strm->avail_in != 0) {\n        ERR_RETURN(strm, Z_BUF_ERROR);\n    }\n\n    /* Write the header */\n    if (s->status == INIT_STATE && s->wrap == 0)\n        s->status = BUSY_STATE;\n    if (s->status == INIT_STATE) {\n        /* zlib header */\n        uInt header = (Z_DEFLATED + ((s->w_bits - 8) << 4)) << 8;\n        uInt level_flags;\n\n        if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)\n            level_flags = 0;\n        else if (s->level < 6)\n            level_flags = 1;\n        else if (s->level == 6)\n            level_flags = 2;\n        else\n            level_flags = 3;\n        header |= (level_flags << 6);\n        if (s->strstart != 0) header |= PRESET_DICT;\n        header += 31 - (header % 31);\n\n        putShortMSB(s, header);\n\n        /* Save the adler32 of the preset dictionary: */\n        if (s->strstart != 0) {\n            putShortMSB(s, (uInt)(strm->adler >> 16));\n            putShortMSB(s, (uInt)(strm->adler & 0xffff));\n        }\n        strm->adler = adler32(0L, Z_NULL, 0);\n        s->status = BUSY_STATE;\n\n        /* Compression must start with an empty pending buffer */\n        flush_pending(strm);\n        if (s->pending != 0) {\n            s->last_flush = -1;\n            return Z_OK;\n        }\n    }\n#ifdef GZIP\n    if (s->status == GZIP_STATE) {\n        /* gzip header */\n        strm->adler = crc32(0L, Z_NULL, 0);\n        put_byte(s, 31);\n        put_byte(s, 139);\n        put_byte(s, 8);\n        if (s->gzhead == Z_NULL) {\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, 0);\n            put_byte(s, s->level == 9 ? 2 :\n                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?\n                      4 : 0));\n            put_byte(s, OS_CODE);\n            s->status = BUSY_STATE;\n\n            /* Compression must start with an empty pending buffer */\n            flush_pending(strm);\n            if (s->pending != 0) {\n                s->last_flush = -1;\n                return Z_OK;\n            }\n        }\n        else {\n            put_byte(s, (s->gzhead->text ? 1 : 0) +\n                     (s->gzhead->hcrc ? 2 : 0) +\n                     (s->gzhead->extra == Z_NULL ? 0 : 4) +\n                     (s->gzhead->name == Z_NULL ? 0 : 8) +\n                     (s->gzhead->comment == Z_NULL ? 0 : 16)\n                     );\n            put_byte(s, (Byte)(s->gzhead->time & 0xff));\n            put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));\n            put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));\n            put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));\n            put_byte(s, s->level == 9 ? 2 :\n                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?\n                      4 : 0));\n            put_byte(s, s->gzhead->os & 0xff);\n            if (s->gzhead->extra != Z_NULL) {\n                put_byte(s, s->gzhead->extra_len & 0xff);\n                put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);\n            }\n            if (s->gzhead->hcrc)\n                strm->adler = crc32(strm->adler, s->pending_buf,\n                                    s->pending);\n            s->gzindex = 0;\n            s->status = EXTRA_STATE;\n        }\n    }\n    if (s->status == EXTRA_STATE) {\n        if (s->gzhead->extra != Z_NULL) {\n            ulg beg = s->pending;   /* start of bytes to update crc */\n            uInt left = (s->gzhead->extra_len & 0xffff) - s->gzindex;\n            while (s->pending + left > s->pending_buf_size) {\n                uInt copy = s->pending_buf_size - s->pending;\n                zmemcpy(s->pending_buf + s->pending,\n                        s->gzhead->extra + s->gzindex, copy);\n                s->pending = s->pending_buf_size;\n                HCRC_UPDATE(beg);\n                s->gzindex += copy;\n                flush_pending(strm);\n                if (s->pending != 0) {\n                    s->last_flush = -1;\n                    return Z_OK;\n                }\n                beg = 0;\n                left -= copy;\n            }\n            zmemcpy(s->pending_buf + s->pending,\n                    s->gzhead->extra + s->gzindex, left);\n            s->pending += left;\n            HCRC_UPDATE(beg);\n            s->gzindex = 0;\n        }\n        s->status = NAME_STATE;\n    }\n    if (s->status == NAME_STATE) {\n        if (s->gzhead->name != Z_NULL) {\n            ulg beg = s->pending;   /* start of bytes to update crc */\n            int val;\n            do {\n                if (s->pending == s->pending_buf_size) {\n                    HCRC_UPDATE(beg);\n                    flush_pending(strm);\n                    if (s->pending != 0) {\n                        s->last_flush = -1;\n                        return Z_OK;\n                    }\n                    beg = 0;\n                }\n                val = s->gzhead->name[s->gzindex++];\n                put_byte(s, val);\n            } while (val != 0);\n            HCRC_UPDATE(beg);\n            s->gzindex = 0;\n        }\n        s->status = COMMENT_STATE;\n    }\n    if (s->status == COMMENT_STATE) {\n        if (s->gzhead->comment != Z_NULL) {\n            ulg beg = s->pending;   /* start of bytes to update crc */\n            int val;\n            do {\n                if (s->pending == s->pending_buf_size) {\n                    HCRC_UPDATE(beg);\n                    flush_pending(strm);\n                    if (s->pending != 0) {\n                        s->last_flush = -1;\n                        return Z_OK;\n                    }\n                    beg = 0;\n                }\n                val = s->gzhead->comment[s->gzindex++];\n                put_byte(s, val);\n            } while (val != 0);\n            HCRC_UPDATE(beg);\n        }\n        s->status = HCRC_STATE;\n    }\n    if (s->status == HCRC_STATE) {\n        if (s->gzhead->hcrc) {\n            if (s->pending + 2 > s->pending_buf_size) {\n                flush_pending(strm);\n                if (s->pending != 0) {\n                    s->last_flush = -1;\n                    return Z_OK;\n                }\n            }\n            put_byte(s, (Byte)(strm->adler & 0xff));\n            put_byte(s, (Byte)((strm->adler >> 8) & 0xff));\n            strm->adler = crc32(0L, Z_NULL, 0);\n        }\n        s->status = BUSY_STATE;\n\n        /* Compression must start with an empty pending buffer */\n        flush_pending(strm);\n        if (s->pending != 0) {\n            s->last_flush = -1;\n            return Z_OK;\n        }\n    }\n#endif\n\n    /* Start a new block or continue the current one.\n     */\n    if (strm->avail_in != 0 || s->lookahead != 0 ||\n        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {\n        block_state bstate;\n\n        bstate = s->level == 0 ? deflate_stored(s, flush) :\n                 s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :\n                 s->strategy == Z_RLE ? deflate_rle(s, flush) :\n                 (*(configuration_table[s->level].func))(s, flush);\n\n        if (bstate == finish_started || bstate == finish_done) {\n            s->status = FINISH_STATE;\n        }\n        if (bstate == need_more || bstate == finish_started) {\n            if (strm->avail_out == 0) {\n                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */\n            }\n            return Z_OK;\n            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n             * of deflate should use the same flush parameter to make sure\n             * that the flush is complete. So we don't have to output an\n             * empty block here, this will be done at next call. This also\n             * ensures that for a very small output buffer, we emit at most\n             * one empty block.\n             */\n        }\n        if (bstate == block_done) {\n            if (flush == Z_PARTIAL_FLUSH) {\n                _tr_align(s);\n            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n                _tr_stored_block(s, (char*)0, 0L, 0);\n                /* For a full flush, this empty block will be recognized\n                 * as a special marker by inflate_sync().\n                 */\n                if (flush == Z_FULL_FLUSH) {\n                    CLEAR_HASH(s);             /* forget history */\n                    if (s->lookahead == 0) {\n                        s->strstart = 0;\n                        s->block_start = 0L;\n                        s->insert = 0;\n                    }\n                }\n            }\n            flush_pending(strm);\n            if (strm->avail_out == 0) {\n              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n              return Z_OK;\n            }\n        }\n    }\n\n    if (flush != Z_FINISH) return Z_OK;\n    if (s->wrap <= 0) return Z_STREAM_END;\n\n    /* Write the trailer */\n#ifdef GZIP\n    if (s->wrap == 2) {\n        put_byte(s, (Byte)(strm->adler & 0xff));\n        put_byte(s, (Byte)((strm->adler >> 8) & 0xff));\n        put_byte(s, (Byte)((strm->adler >> 16) & 0xff));\n        put_byte(s, (Byte)((strm->adler >> 24) & 0xff));\n        put_byte(s, (Byte)(strm->total_in & 0xff));\n        put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));\n        put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));\n        put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));\n    }\n    else\n#endif\n    {\n        putShortMSB(s, (uInt)(strm->adler >> 16));\n        putShortMSB(s, (uInt)(strm->adler & 0xffff));\n    }\n    flush_pending(strm);\n    /* If avail_out is zero, the application will call deflate again\n     * to flush the rest.\n     */\n    if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */\n    return s->pending != 0 ? Z_OK : Z_STREAM_END;\n}",
          "fn_code_pos": [
            [
              953,
              0
            ],
            [
              1262,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflate",
            "parameters": {
              "strm": "z_streamp",
              "flush": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT deflateEnd(z_streamp strm) {\n    int status;\n\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n\n    status = strm->state->status;\n\n    /* Deallocate in reverse order of allocations: */\n    TRY_FREE(strm, strm->state->pending_buf);\n    TRY_FREE(strm, strm->state->head);\n    TRY_FREE(strm, strm->state->prev);\n    TRY_FREE(strm, strm->state->window);\n\n    ZFREE(strm, strm->state);\n    strm->state = Z_NULL;\n\n    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;\n}",
          "fn_code_pos": [
            [
              1265,
              0
            ],
            [
              1282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateEnd",
            "parameters": {
              "strm": "z_streamp"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT deflateCopy(z_streamp dest, z_streamp source) {\n#ifdef MAXSEG_64K\n    (void)dest;\n    (void)source;\n    return Z_STREAM_ERROR;\n#else\n    deflate_state *ds;\n    deflate_state *ss;\n\n\n    if (deflateStateCheck(source) || dest == Z_NULL) {\n        return Z_STREAM_ERROR;\n    }\n\n    ss = source->state;\n\n    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));\n\n    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n    if (ds == Z_NULL) return Z_MEM_ERROR;\n    dest->state = (struct internal_state FAR *) ds;\n    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));\n    ds->strm = dest;\n\n    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, LIT_BUFS);\n\n    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n        ds->pending_buf == Z_NULL) {\n        deflateEnd (dest);\n        return Z_MEM_ERROR;\n    }\n    /* following zmemcpy do not work for 16-bit MSDOS */\n    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));\n    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));\n    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));\n    zmemcpy(ds->pending_buf, ss->pending_buf, ds->lit_bufsize * LIT_BUFS);\n\n    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n#ifdef LIT_MEM\n    ds->d_buf = (ushf *)(ds->pending_buf + (ds->lit_bufsize << 1));\n    ds->l_buf = ds->pending_buf + (ds->lit_bufsize << 2);\n#else\n    ds->sym_buf = ds->pending_buf + ds->lit_bufsize;\n#endif\n\n    ds->l_desc.dyn_tree = ds->dyn_ltree;\n    ds->d_desc.dyn_tree = ds->dyn_dtree;\n    ds->bl_desc.dyn_tree = ds->bl_tree;\n\n    return Z_OK;\n#endif /* MAXSEG_64K */\n}",
          "fn_code_pos": [
            [
              1289,
              0
            ],
            [
              1343,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateCopy",
            "parameters": {
              "dest": "z_streamp",
              "source": "z_streamp"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "local uInt longest_match(deflate_state *s, IPos cur_match) {\n    unsigned chain_length = s->max_chain_length;/* max hash chain length */\n    register Bytef *scan = s->window + s->strstart; /* current string */\n    register Bytef *match;                      /* matched string */\n    register int len;                           /* length of current match */\n    int best_len = (int)s->prev_length;         /* best match length so far */\n    int nice_match = s->nice_match;             /* stop if match long enough */\n    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?\n        s->strstart - (IPos)MAX_DIST(s) : NIL;\n    /* Stop when cur_match becomes <= limit. To simplify the code,\n     * we prevent matches with the string of window index 0.\n     */\n    Posf *prev = s->prev;\n    uInt wmask = s->w_mask;\n\n#ifdef UNALIGNED_OK\n    /* Compare two bytes at a time. Note: this is not always beneficial.\n     * Try with and without -DUNALIGNED_OK to check.\n     */\n    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;\n    register ush scan_start = *(ushf*)scan;\n    register ush scan_end   = *(ushf*)(scan + best_len - 1);\n#else\n    register Bytef *strend = s->window + s->strstart + MAX_MATCH;\n    register Byte scan_end1  = scan[best_len - 1];\n    register Byte scan_end   = scan[best_len];\n#endif\n\n    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n     * It is easy to get rid of this optimization if necessary.\n     */\n    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n    /* Do not waste too much time if we already have a good match: */\n    if (s->prev_length >= s->good_match) {\n        chain_length >>= 2;\n    }\n    /* Do not look for matches beyond the end of the input. This is necessary\n     * to make deflate deterministic.\n     */\n    if ((uInt)nice_match > s->lookahead) nice_match = (int)s->lookahead;\n\n    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n           \"need lookahead\");\n\n    do {\n        Assert(cur_match < s->strstart, \"no future\");\n        match = s->window + cur_match;\n\n        /* Skip to next match if the match length cannot increase\n         * or if the match length is less than 2.  Note that the checks below\n         * for insufficient lookahead only occur occasionally for performance\n         * reasons.  Therefore uninitialized memory will be accessed, and\n         * conditional jumps will be made that depend on those values.\n         * However the length of the match is limited to the lookahead, so\n         * the output of deflate is not affected by the uninitialized values.\n         */\n#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)\n        /* This code assumes sizeof(unsigned short) == 2. Do not use\n         * UNALIGNED_OK if your compiler uses a different size.\n         */\n        if (*(ushf*)(match + best_len - 1) != scan_end ||\n            *(ushf*)match != scan_start) continue;\n\n        /* It is not necessary to compare scan[2] and match[2] since they are\n         * always equal when the other bytes match, given that the hash keys\n         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at\n         * strstart + 3, + 5, up to strstart + 257. We check for insufficient\n         * lookahead only every 4th comparison; the 128th check will be made\n         * at strstart + 257. If MAX_MATCH-2 is not a multiple of 8, it is\n         * necessary to put more guard bytes at the end of the window, or\n         * to check more often for insufficient lookahead.\n         */\n        Assert(scan[2] == match[2], \"scan[2]?\");\n        scan++, match++;\n        do {\n        } while (*(ushf*)(scan += 2) == *(ushf*)(match += 2) &&\n                 *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&\n                 *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&\n                 *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&\n                 scan < strend);\n        /* The funny \"do {}\" generates better code on most compilers */\n\n        /* Here, scan <= window + strstart + 257 */\n        Assert(scan <= s->window + (unsigned)(s->window_size - 1),\n               \"wild scan\");\n        if (*scan == *match) scan++;\n\n        len = (MAX_MATCH - 1) - (int)(strend - scan);\n        scan = strend - (MAX_MATCH-1);\n\n#else /* UNALIGNED_OK */\n\n        if (match[best_len]     != scan_end  ||\n            match[best_len - 1] != scan_end1 ||\n            *match              != *scan     ||\n            *++match            != scan[1])      continue;\n\n        /* The check at best_len - 1 can be removed because it will be made\n         * again later. (This heuristic is not always a win.)\n         * It is not necessary to compare scan[2] and match[2] since they\n         * are always equal when the other bytes match, given that\n         * the hash keys are equal and that HASH_BITS >= 8.\n         */\n        scan += 2, match++;\n        Assert(*scan == *match, \"match[2]?\");\n\n        /* We check for insufficient lookahead only every 8th comparison;\n         * the 256th check will be made at strstart + 258.\n         */\n        do {\n        } while (*++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 *++scan == *++match && *++scan == *++match &&\n                 scan < strend);\n\n        Assert(scan <= s->window + (unsigned)(s->window_size - 1),\n               \"wild scan\");\n\n        len = MAX_MATCH - (int)(strend - scan);\n        scan = strend - MAX_MATCH;\n\n#endif /* UNALIGNED_OK */\n\n        if (len > best_len) {\n            s->match_start = cur_match;\n            best_len = len;\n            if (len >= nice_match) break;\n#ifdef UNALIGNED_OK\n            scan_end = *(ushf*)(scan + best_len - 1);\n#else\n            scan_end1  = scan[best_len - 1];\n            scan_end   = scan[best_len];\n#endif\n        }\n    } while ((cur_match = prev[cur_match & wmask]) > limit\n             && --chain_length != 0);\n\n    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;\n    return s->lookahead;\n}",
          "fn_code_pos": [
            [
              1355,
              0
            ],
            [
              1496,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "longest_match",
            "parameters": {
              "s": "deflate_state",
              "cur_match": "IPos"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local uInt longest_match(deflate_state *s, IPos cur_match) {\n    register Bytef *scan = s->window + s->strstart; /* current string */\n    register Bytef *match;                       /* matched string */\n    register int len;                           /* length of current match */\n    register Bytef *strend = s->window + s->strstart + MAX_MATCH;\n\n    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n     * It is easy to get rid of this optimization if necessary.\n     */\n    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n           \"need lookahead\");\n\n    Assert(cur_match < s->strstart, \"no future\");\n\n    match = s->window + cur_match;\n\n    /* Return failure if the match length is less than 2:\n     */\n    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;\n\n    /* The check at best_len - 1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2, match += 2;\n    Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart + 258.\n     */\n    do {\n    } while (*++scan == *++match && *++scan == *++match &&\n             *++scan == *++match && *++scan == *++match &&\n             *++scan == *++match && *++scan == *++match &&\n             *++scan == *++match && *++scan == *++match &&\n             scan < strend);\n\n    Assert(scan <= s->window + (unsigned)(s->window_size - 1), \"wild scan\");\n\n    len = MAX_MATCH - (int)(strend - scan);\n\n    if (len < MIN_MATCH) return MIN_MATCH - 1;\n\n    s->match_start = cur_match;\n    return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;\n}",
          "fn_code_pos": [
            [
              1503,
              0
            ],
            [
              1552,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "longest_match",
            "parameters": {
              "s": "deflate_state",
              "cur_match": "IPos"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void check_match(deflate_state *s, IPos start, IPos match, int length) {\n    /* check that the match is indeed a match */\n    Bytef *back = s->window + (int)match, *here = s->window + start;\n    IPos len = length;\n    if (match == (IPos)-1) {\n        /* match starts one byte before the current window -- just compare the\n           subsequent length-1 bytes */\n        back++;\n        here++;\n        len--;\n    }\n    if (zmemcmp(back, here, len) != EQUAL) {\n        fprintf(stderr, \" start %u, match %d, length %d\\n\",\n                start, (int)match, length);\n        do {\n            fprintf(stderr, \"(%02x %02x)\", *back++, *here++);\n        } while (--len != 0);\n        z_error(\"invalid match\");\n    }\n    if (z_verbose > 1) {\n        fprintf(stderr,\"\\\\[%d,%d]\", start - match, length);\n        do { putc(s->window[start++], stderr); } while (--length != 0);\n    }\n}",
          "fn_code_pos": [
            [
              1564,
              0
            ],
            [
              1587,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "check_match",
            "parameters": {
              "s": "deflate_state",
              "start": "IPos",
              "match": "IPos",
              "length": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local block_state deflate_stored(deflate_state *s, int flush) {\n    /* Smallest worthy block size when not flushing or finishing. By default\n     * this is 32K. This can be as small as 507 bytes for memLevel == 1. For\n     * large input and output buffers, the stored block size will be larger.\n     */\n    unsigned min_block = MIN(s->pending_buf_size - 5, s->w_size);\n\n    /* Copy as many min_block or larger stored blocks directly to next_out as\n     * possible. If flushing, copy the remaining available input to next_out as\n     * stored blocks, if there is enough space.\n     */\n    int last = 0;\n    unsigned len, left, have;\n    unsigned used = s->strm->avail_in;\n    do {\n        /* Set len to the maximum size block that we can copy directly with the\n         * available input data and output space. Set left to how much of that\n         * would be copied from what's left in the window.\n         */\n        len = MAX_STORED;       /* maximum deflate stored block length */\n        have = (s->bi_valid + 42) >> 3;         /* number of header bytes */\n        if (s->strm->avail_out < have)          /* need room for header */\n            break;\n            /* maximum stored block length that will fit in avail_out: */\n        have = s->strm->avail_out - have;\n        left = s->strstart - s->block_start;    /* bytes left in window */\n        if (len > (ulg)left + s->strm->avail_in)\n            len = left + s->strm->avail_in;     /* limit len to the input */\n        if (len > have)\n            len = have;                         /* limit len to the output */\n\n        /* If the stored block would be less than min_block in length, or if\n         * unable to copy all of the available input when flushing, then try\n         * copying to the window and the pending buffer instead. Also don't\n         * write an empty block when flushing -- deflate() does that.\n         */\n        if (len < min_block && ((len == 0 && flush != Z_FINISH) ||\n                                flush == Z_NO_FLUSH ||\n                                len != left + s->strm->avail_in))\n            break;\n\n        /* Make a dummy stored block in pending to get the header bytes,\n         * including any pending bits. This also updates the debugging counts.\n         */\n        last = flush == Z_FINISH && len == left + s->strm->avail_in ? 1 : 0;\n        _tr_stored_block(s, (char *)0, 0L, last);\n\n        /* Replace the lengths in the dummy stored block with len. */\n        s->pending_buf[s->pending - 4] = (Bytef)len;\n        s->pending_buf[s->pending - 3] = (Bytef)(len >> 8);\n        s->pending_buf[s->pending - 2] = (Bytef)~len;\n        s->pending_buf[s->pending - 1] = (Bytef)(~len >> 8);\n\n        /* Write the stored block header bytes. */\n        flush_pending(s->strm);\n\n#ifdef ZLIB_DEBUG\n        /* Update debugging counts for the data about to be copied. */\n        s->compressed_len += len << 3;\n        s->bits_sent += len << 3;\n#endif\n\n        /* Copy uncompressed bytes from the window to next_out. */\n        if (left) {\n            if (left > len)\n                left = len;\n            zmemcpy(s->strm->next_out, s->window + s->block_start, left);\n            s->strm->next_out += left;\n            s->strm->avail_out -= left;\n            s->strm->total_out += left;\n            s->block_start += left;\n            len -= left;\n        }\n\n        /* Copy uncompressed bytes directly from next_in to next_out, updating\n         * the check value.\n         */\n        if (len) {\n            read_buf(s->strm, s->strm->next_out, len);\n            s->strm->next_out += len;\n            s->strm->avail_out -= len;\n            s->strm->total_out += len;\n        }\n    } while (last == 0);\n\n    /* Update the sliding window with the last s->w_size bytes of the copied\n     * data, or append all of the copied data to the existing window if less\n     * than s->w_size bytes were copied. Also update the number of bytes to\n     * insert in the hash tables, in the event that deflateParams() switches to\n     * a non-zero compression level.\n     */\n    used -= s->strm->avail_in;      /* number of input bytes directly copied */\n    if (used) {\n        /* If any input was used, then no unused input remains in the window,\n         * therefore s->block_start == s->strstart.\n         */\n        if (used >= s->w_size) {    /* supplant the previous history */\n            s->matches = 2;         /* clear hash */\n            zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);\n            s->strstart = s->w_size;\n            s->insert = s->strstart;\n        }\n        else {\n            if (s->window_size - s->strstart <= used) {\n                /* Slide the window down. */\n                s->strstart -= s->w_size;\n                zmemcpy(s->window, s->window + s->w_size, s->strstart);\n                if (s->matches < 2)\n                    s->matches++;   /* add a pending slide_hash() */\n                if (s->insert > s->strstart)\n                    s->insert = s->strstart;\n            }\n            zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);\n            s->strstart += used;\n            s->insert += MIN(used, s->w_size - s->insert);\n        }\n        s->block_start = s->strstart;\n    }\n    if (s->high_water < s->strstart)\n        s->high_water = s->strstart;\n\n    /* If the last block was written to next_out, then done. */\n    if (last) {\n        s->bi_used = 8;\n        return finish_done;\n    }\n\n    /* If flushing and all input has been consumed, then done. */\n    if (flush != Z_NO_FLUSH && flush != Z_FINISH &&\n        s->strm->avail_in == 0 && (long)s->strstart == s->block_start)\n        return block_done;\n\n    /* Fill the window with any remaining input. */\n    have = s->window_size - s->strstart;\n    if (s->strm->avail_in > have && s->block_start >= (long)s->w_size) {\n        /* Slide the window down. */\n        s->block_start -= s->w_size;\n        s->strstart -= s->w_size;\n        zmemcpy(s->window, s->window + s->w_size, s->strstart);\n        if (s->matches < 2)\n            s->matches++;           /* add a pending slide_hash() */\n        have += s->w_size;          /* more space now */\n        if (s->insert > s->strstart)\n            s->insert = s->strstart;\n    }\n    if (have > s->strm->avail_in)\n        have = s->strm->avail_in;\n    if (have) {\n        read_buf(s->strm, s->window + s->strstart, have);\n        s->strstart += have;\n        s->insert += MIN(have, s->w_size - s->insert);\n    }\n    if (s->high_water < s->strstart)\n        s->high_water = s->strstart;\n\n    /* There was not enough avail_out to write a complete worthy or flushed\n     * stored block to next_out. Write a stored block to pending instead, if we\n     * have enough input for a worthy block, or if flushing and there is enough\n     * room for the remaining input as a stored block in the pending buffer.\n     */\n    have = (s->bi_valid + 42) >> 3;         /* number of header bytes */\n        /* maximum stored block length that will fit in pending: */\n    have = MIN(s->pending_buf_size - have, MAX_STORED);\n    min_block = MIN(have, s->w_size);\n    left = s->strstart - s->block_start;\n    if (left >= min_block ||\n        ((left || flush == Z_FINISH) && flush != Z_NO_FLUSH &&\n         s->strm->avail_in == 0 && left <= have)) {\n        len = MIN(left, have);\n        last = flush == Z_FINISH && s->strm->avail_in == 0 &&\n               len == left ? 1 : 0;\n        _tr_stored_block(s, (charf *)s->window + s->block_start, len, last);\n        s->block_start += len;\n        flush_pending(s->strm);\n    }\n\n    /* We've done all we can with the available input and output. */\n    if (last)\n        s->bi_used = 8;\n    return last ? finish_started : need_more;\n}",
          "fn_code_pos": [
            [
              1634,
              0
            ],
            [
              1814,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_state deflate_stored",
            "parameters": {
              "s": "deflate_state",
              "flush": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local block_state deflate_fast(deflate_state *s, int flush) {\n    IPos hash_head;       /* head of the hash chain */\n    int bflush;           /* set if current block must be flushed */\n\n    for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s->lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; /* flush the current block */\n        }\n\n        /* Insert the string window[strstart .. strstart + 2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        hash_head = NIL;\n        if (s->lookahead >= MIN_MATCH) {\n            INSERT_STRING(s, s->strstart, hash_head);\n        }\n\n        /* Find the longest match, discarding those <= prev_length.\n         * At this point we have always match_length < MIN_MATCH\n         */\n        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {\n            /* To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             */\n            s->match_length = longest_match (s, hash_head);\n            /* longest_match() sets match_start */\n        }\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->match_start, s->match_length);\n\n            _tr_tally_dist(s, s->strstart - s->match_start,\n                           s->match_length - MIN_MATCH, bflush);\n\n            s->lookahead -= s->match_length;\n\n            /* Insert new strings in the hash table only if the match length\n             * is not too large. This saves time but degrades compression.\n             */\n#ifndef FASTEST\n            if (s->match_length <= s->max_insert_length &&\n                s->lookahead >= MIN_MATCH) {\n                s->match_length--; /* string at strstart already in table */\n                do {\n                    s->strstart++;\n                    INSERT_STRING(s, s->strstart, hash_head);\n                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n                     * always MIN_MATCH bytes ahead.\n                     */\n                } while (--s->match_length != 0);\n                s->strstart++;\n            } else\n#endif\n            {\n                s->strstart += s->match_length;\n                s->match_length = 0;\n                s->ins_h = s->window[s->strstart];\n                UPDATE_HASH(s, s->ins_h, s->window[s->strstart + 1]);\n#if MIN_MATCH != 3\n                Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n                 * matter since it will be recomputed at next deflate call.\n                 */\n            }\n        } else {\n            /* No match, output a literal byte */\n            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            _tr_tally_lit(s, s->window[s->strstart], bflush);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->sym_next)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}",
          "fn_code_pos": [
            [
              1823,
              0
            ],
            [
              1914,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_state deflate_fast",
            "parameters": {
              "s": "deflate_state",
              "flush": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local block_state deflate_slow(deflate_state *s, int flush) {\n    IPos hash_head;          /* head of hash chain */\n    int bflush;              /* set if current block must be flushed */\n\n    /* Process the input block. */\n    for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s->lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; /* flush the current block */\n        }\n\n        /* Insert the string window[strstart .. strstart + 2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n        hash_head = NIL;\n        if (s->lookahead >= MIN_MATCH) {\n            INSERT_STRING(s, s->strstart, hash_head);\n        }\n\n        /* Find the longest match, discarding those <= prev_length.\n         */\n        s->prev_length = s->match_length, s->prev_match = s->match_start;\n        s->match_length = MIN_MATCH-1;\n\n        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&\n            s->strstart - hash_head <= MAX_DIST(s)) {\n            /* To simplify the code, we prevent matches with the string\n             * of window index 0 (in particular we have to avoid a match\n             * of the string with itself at the start of the input file).\n             */\n            s->match_length = longest_match (s, hash_head);\n            /* longest_match() sets match_start */\n\n            if (s->match_length <= 5 && (s->strategy == Z_FILTERED\n#if TOO_FAR <= 32767\n                || (s->match_length == MIN_MATCH &&\n                    s->strstart - s->match_start > TOO_FAR)\n#endif\n                )) {\n\n                /* If prev_match is also MIN_MATCH, match_start is garbage\n                 * but we will ignore the current match anyway.\n                 */\n                s->match_length = MIN_MATCH-1;\n            }\n        }\n        /* If there was a match at the previous step and the current\n         * match is not better, output the previous match:\n         */\n        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {\n            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;\n            /* Do not insert strings in hash table beyond this. */\n\n            check_match(s, s->strstart - 1, s->prev_match, s->prev_length);\n\n            _tr_tally_dist(s, s->strstart - 1 - s->prev_match,\n                           s->prev_length - MIN_MATCH, bflush);\n\n            /* Insert in hash table all strings up to the end of the match.\n             * strstart - 1 and strstart are already inserted. If there is not\n             * enough lookahead, the last two strings are not inserted in\n             * the hash table.\n             */\n            s->lookahead -= s->prev_length - 1;\n            s->prev_length -= 2;\n            do {\n                if (++s->strstart <= max_insert) {\n                    INSERT_STRING(s, s->strstart, hash_head);\n                }\n            } while (--s->prev_length != 0);\n            s->match_available = 0;\n            s->match_length = MIN_MATCH-1;\n            s->strstart++;\n\n            if (bflush) FLUSH_BLOCK(s, 0);\n\n        } else if (s->match_available) {\n            /* If there was no match at the previous position, output a\n             * single literal. If there was a match but the current match\n             * is longer, truncate the previous match to a single literal.\n             */\n            Tracevv((stderr,\"%c\", s->window[s->strstart - 1]));\n            _tr_tally_lit(s, s->window[s->strstart - 1], bflush);\n            if (bflush) {\n                FLUSH_BLOCK_ONLY(s, 0);\n            }\n            s->strstart++;\n            s->lookahead--;\n            if (s->strm->avail_out == 0) return need_more;\n        } else {\n            /* There is no previous match to compare with, wait for\n             * the next step to decide.\n             */\n            s->match_available = 1;\n            s->strstart++;\n            s->lookahead--;\n        }\n    }\n    Assert (flush != Z_NO_FLUSH, \"no flush?\");\n    if (s->match_available) {\n        Tracevv((stderr,\"%c\", s->window[s->strstart - 1]));\n        _tr_tally_lit(s, s->window[s->strstart - 1], bflush);\n        s->match_available = 0;\n    }\n    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->sym_next)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}",
          "fn_code_pos": [
            [
              1922,
              0
            ],
            [
              2042,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_state deflate_slow",
            "parameters": {
              "s": "deflate_state",
              "flush": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local block_state deflate_rle(deflate_state *s, int flush) {\n    int bflush;             /* set if current block must be flushed */\n    uInt prev;              /* byte at distance one to match */\n    Bytef *scan, *strend;   /* scan goes up to strend for length of run */\n\n    for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the longest run, plus one for the unrolled loop.\n         */\n        if (s->lookahead <= MAX_MATCH) {\n            fill_window(s);\n            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; /* flush the current block */\n        }\n\n        /* See how many times the previous byte repeats */\n        s->match_length = 0;\n        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {\n            scan = s->window + s->strstart - 1;\n            prev = *scan;\n            if (prev == *++scan && prev == *++scan && prev == *++scan) {\n                strend = s->window + s->strstart + MAX_MATCH;\n                do {\n                } while (prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         scan < strend);\n                s->match_length = MAX_MATCH - (uInt)(strend - scan);\n                if (s->match_length > s->lookahead)\n                    s->match_length = s->lookahead;\n            }\n            Assert(scan <= s->window + (uInt)(s->window_size - 1),\n                   \"wild scan\");\n        }\n\n        /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->strstart - 1, s->match_length);\n\n            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);\n\n            s->lookahead -= s->match_length;\n            s->strstart += s->match_length;\n            s->match_length = 0;\n        } else {\n            /* No match, output a literal byte */\n            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            _tr_tally_lit(s, s->window[s->strstart], bflush);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->sym_next)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}",
          "fn_code_pos": [
            [
              2050,
              0
            ],
            [
              2115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_state deflate_rle",
            "parameters": {
              "s": "deflate_state",
              "flush": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local block_state deflate_huff(deflate_state *s, int flush) {\n    int bflush;             /* set if current block must be flushed */\n\n    for (;;) {\n        /* Make sure that we have a literal to write. */\n        if (s->lookahead == 0) {\n            fill_window(s);\n            if (s->lookahead == 0) {\n                if (flush == Z_NO_FLUSH)\n                    return need_more;\n                break;      /* flush the current block */\n            }\n        }\n\n        /* Output a literal byte */\n        s->match_length = 0;\n        Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        _tr_tally_lit(s, s->window[s->strstart], bflush);\n        s->lookahead--;\n        s->strstart++;\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->sym_next)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}",
          "fn_code_pos": [
            [
              2121,
              0
            ],
            [
              2151,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_state deflate_huff",
            "parameters": {
              "s": "deflate_state",
              "flush": "int"
            },
            "return_type": "local"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*compress_func)(deflate_state *s, int flush)",
          "fn_dec_pos": [
            [
              69,
              20
            ],
            [
              69,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "s": "deflate_state",
              "flush": "int"
            },
            "return_type": "block_state"
          }
        },
        {
          "fn_code": "block_state deflate_stored(deflate_state *s, int flush)",
          "fn_dec_pos": [
            [
              72,
              6
            ],
            [
              72,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_state deflate_stored",
            "parameters": {
              "s": "deflate_state",
              "flush": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "block_state deflate_fast(deflate_state *s, int flush)",
          "fn_dec_pos": [
            [
              73,
              6
            ],
            [
              73,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_state deflate_fast",
            "parameters": {
              "s": "deflate_state",
              "flush": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "block_state deflate_slow(deflate_state *s, int flush)",
          "fn_dec_pos": [
            [
              75,
              6
            ],
            [
              75,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_state deflate_slow",
            "parameters": {
              "s": "deflate_state",
              "flush": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "block_state deflate_rle(deflate_state *s, int flush)",
          "fn_dec_pos": [
            [
              77,
              6
            ],
            [
              77,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_state deflate_rle",
            "parameters": {
              "s": "deflate_state",
              "flush": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "block_state deflate_huff(deflate_state *s, int flush)",
          "fn_dec_pos": [
            [
              78,
              6
            ],
            [
              78,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_state deflate_huff",
            "parameters": {
              "s": "deflate_state",
              "flush": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "deflateResetKeep(z_streamp strm)",
          "fn_dec_pos": [
            [
              634,
              12
            ],
            [
              634,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateResetKeep",
            "parameters": {
              "strm": "z_streamp"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct config_s {\n   ush good_length; /* reduce lazy search above this match length */\n   ush max_lazy;    /* do not perform lazy search above this match length */\n   ush nice_length; /* quit search above this match length */\n   ush max_chain;\n   compress_func func;\n} config;",
          {
            "good_length": "ush",
            "max_lazy": "ush",
            "nice_length": "ush",
            "max_chain": "ush",
            "func": "compress_func"
          },
          "config",
          [
            97,
            0
          ],
          [
            103,
            9
          ]
        ],
        [
          "typedef struct config_s {\n   ush good_length; /* reduce lazy search above this match length */\n   ush max_lazy;    /* do not perform lazy search above this match length */\n   ush nice_length; /* quit search above this match length */\n   ush max_chain;\n   compress_func func;\n} config;",
          {
            "good_length": "ush",
            "max_lazy": "ush",
            "nice_length": "ush",
            "max_chain": "ush",
            "func": "compress_func"
          },
          "config",
          [
            97,
            0
          ],
          [
            103,
            9
          ]
        ],
        [
          "struct internal_state",
          {},
          "",
          [
            433,
            19
          ],
          [
            433,
            40
          ]
        ],
        [
          "struct internal_state",
          {},
          "",
          [
            1309,
            19
          ],
          [
            1309,
            40
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"deflate.h\"\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n    need_more,      /* block not completed, need more input or more output */\n    block_done,     /* block flush performed */\n    finish_started, /* finish started, need only more output at next deflate */\n    finish_done     /* finish done, accept no more input or output */\n} block_state;",
          {
            "need_more": "",
            "block_done": "",
            "finish_started": "",
            "finish_done": ""
          },
          "block_state",
          [
            62,
            0
          ],
          [
            67,
            14
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/gzclose.c": {
      "fn_def_list": [
        {
          "fn_code": "int ZEXPORT gzclose(gzFile file) {\n#ifndef NO_GZCOMPRESS\n    gz_statep state;\n\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n\n    return state->mode == GZ_READ ? gzclose_r(file) : gzclose_w(file);\n#else\n    return gzclose_r(file);\n#endif\n}",
          "fn_code_pos": [
            [
              10,
              0
            ],
            [
              22,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzclose",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"gzguts.h\"\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/trees.c": {
      "fn_def_list": [
        {
          "fn_code": "local unsigned bi_reverse(unsigned code, int len) {\n    register unsigned res = 0;\n    do {\n        res |= code & 1;\n        code >>= 1, res <<= 1;\n    } while (--len > 0);\n    return res >> 1;\n}",
          "fn_code_pos": [
            [
              153,
              0
            ],
            [
              160,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bi_reverse",
            "parameters": {
              "code": "unsigned",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "local void bi_flush(deflate_state *s) {\n    if (s->bi_valid == 16) {\n        put_short(s, s->bi_buf);\n        s->bi_buf = 0;\n        s->bi_valid = 0;\n    } else if (s->bi_valid >= 8) {\n        put_byte(s, (Byte)s->bi_buf);\n        s->bi_buf >>= 8;\n        s->bi_valid -= 8;\n    }\n}",
          "fn_code_pos": [
            [
              165,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bi_flush",
            "parameters": {
              "s": "deflate_state"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void bi_windup(deflate_state *s) {\n    if (s->bi_valid > 8) {\n        put_short(s, s->bi_buf);\n    } else if (s->bi_valid > 0) {\n        put_byte(s, (Byte)s->bi_buf);\n    }\n    s->bi_used = ((s->bi_valid - 1) & 7) + 1;\n    s->bi_buf = 0;\n    s->bi_valid = 0;\n#ifdef ZLIB_DEBUG\n    s->bits_sent = (s->bits_sent + 7) & ~7;\n#endif\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bi_windup",
            "parameters": {
              "s": "deflate_state"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void gen_codes(ct_data *tree, int max_code, ushf *bl_count) {\n    ush next_code[MAX_BITS+1]; /* next code value for each bit length */\n    unsigned code = 0;         /* running code value */\n    int bits;                  /* bit index */\n    int n;                     /* code index */\n\n    /* The distribution counts are first used to generate the code values\n     * without bit reversal.\n     */\n    for (bits = 1; bits <= MAX_BITS; bits++) {\n        code = (code + bl_count[bits - 1]) << 1;\n        next_code[bits] = (ush)code;\n    }\n    /* Check that the bit counts in bl_count are consistent. The last code\n     * must be all ones.\n     */\n    Assert (code + bl_count[MAX_BITS] - 1 == (1 << MAX_BITS) - 1,\n            \"inconsistent bit counts\");\n    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n    for (n = 0;  n <= max_code; n++) {\n        int len = tree[n].Len;\n        if (len == 0) continue;\n        /* Now reverse the bits */\n        tree[n].Code = (ush)bi_reverse(next_code[len]++, len);\n\n        Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n            n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len] - 1));\n    }\n}",
          "fn_code_pos": [
            [
              202,
              0
            ],
            [
              231,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_codes",
            "parameters": {
              "tree": "ct_data",
              "max_code": "int",
              "bl_count": "ushf"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void send_bits(deflate_state *s, int value, int length) {\n    Tracevv((stderr,\" l %2d v %4x \", length, value));\n    Assert(length > 0 && length <= 15, \"invalid length\");\n    s->bits_sent += (ulg)length;\n\n    /* If not enough room in bi_buf, use (valid) bits from bi_buf and\n     * (16 - bi_valid) bits from value, leaving (width - (16 - bi_valid))\n     * unused bits in value.\n     */\n    if (s->bi_valid > (int)Buf_size - length) {\n        s->bi_buf |= (ush)value << s->bi_valid;\n        put_short(s, s->bi_buf);\n        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);\n        s->bi_valid += length - Buf_size;\n    } else {\n        s->bi_buf |= (ush)value << s->bi_valid;\n        s->bi_valid += length;\n    }\n}",
          "fn_code_pos": [
            [
              252,
              0
            ],
            [
              270,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "send_bits",
            "parameters": {
              "s": "deflate_state",
              "value": "int",
              "length": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void tr_static_init(void) {\n#if defined(GEN_TREES_H) || !defined(STDC)\n    static int static_init_done = 0;\n    int n;        /* iterates over tree elements */\n    int bits;     /* bit counter */\n    int length;   /* length value */\n    int code;     /* code value */\n    int dist;     /* distance index */\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    if (static_init_done) return;\n\n    /* For some embedded targets, global variables are not initialized: */\n#ifdef NO_INIT_GLOBAL_POINTERS\n    static_l_desc.static_tree = static_ltree;\n    static_l_desc.extra_bits = extra_lbits;\n    static_d_desc.static_tree = static_dtree;\n    static_d_desc.extra_bits = extra_dbits;\n    static_bl_desc.extra_bits = extra_blbits;\n#endif\n\n    /* Initialize the mapping length (0..255) -> length code (0..28) */\n    length = 0;\n    for (code = 0; code < LENGTH_CODES-1; code++) {\n        base_length[code] = length;\n        for (n = 0; n < (1 << extra_lbits[code]); n++) {\n            _length_code[length++] = (uch)code;\n        }\n    }\n    Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n     * in two different ways: code 284 + 5 bits or code 285, so we\n     * overwrite length_code[255] to use the best encoding:\n     */\n    _length_code[length - 1] = (uch)code;\n\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n    dist = 0;\n    for (code = 0 ; code < 16; code++) {\n        base_dist[code] = dist;\n        for (n = 0; n < (1 << extra_dbits[code]); n++) {\n            _dist_code[dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */\n    for ( ; code < D_CODES; code++) {\n        base_dist[code] = dist << 7;\n        for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n            _dist_code[256 + dist++] = (uch)code;\n        }\n    }\n    Assert (dist == 256, \"tr_static_init: 256 + dist != 512\");\n\n    /* Construct the codes of the static literal tree */\n    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;\n    n = 0;\n    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;\n    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;\n    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;\n    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;\n    /* Codes 286 and 287 do not exist, but we must include them in the\n     * tree construction to get a canonical Huffman tree (longest code\n     * all ones)\n     */\n    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);\n\n    /* The static distance tree is trivial: */\n    for (n = 0; n < D_CODES; n++) {\n        static_dtree[n].Len = 5;\n        static_dtree[n].Code = bi_reverse((unsigned)n, 5);\n    }\n    static_init_done = 1;\n\n#  ifdef GEN_TREES_H\n    gen_trees_header();\n#  endif\n#endif /* defined(GEN_TREES_H) || !defined(STDC) */\n}",
          "fn_code_pos": [
            [
              294,
              0
            ],
            [
              373,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tr_static_init",
            "parameters": {},
            "return_type": "local"
          }
        },
        {
          "fn_code": "void gen_trees_header(void) {\n    FILE *header = fopen(\"trees.h\", \"w\");\n    int i;\n\n    Assert (header != NULL, \"Can't open trees.h\");\n    fprintf(header,\n            \"/* header created automatically with -DGEN_TREES_H */\\n\\n\");\n\n    fprintf(header, \"local const ct_data static_ltree[L_CODES+2] = {\\n\");\n    for (i = 0; i < L_CODES+2; i++) {\n        fprintf(header, \"{{%3u},{%3u}}%s\", static_ltree[i].Code,\n                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));\n    }\n\n    fprintf(header, \"local const ct_data static_dtree[D_CODES] = {\\n\");\n    for (i = 0; i < D_CODES; i++) {\n        fprintf(header, \"{{%2u},{%2u}}%s\", static_dtree[i].Code,\n                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));\n    }\n\n    fprintf(header, \"const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\\n\");\n    for (i = 0; i < DIST_CODE_LEN; i++) {\n        fprintf(header, \"%2u%s\", _dist_code[i],\n                SEPARATOR(i, DIST_CODE_LEN-1, 20));\n    }\n\n    fprintf(header,\n        \"const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\\n\");\n    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {\n        fprintf(header, \"%2u%s\", _length_code[i],\n                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));\n    }\n\n    fprintf(header, \"local const int base_length[LENGTH_CODES] = {\\n\");\n    for (i = 0; i < LENGTH_CODES; i++) {\n        fprintf(header, \"%1u%s\", base_length[i],\n                SEPARATOR(i, LENGTH_CODES-1, 20));\n    }\n\n    fprintf(header, \"local const int base_dist[D_CODES] = {\\n\");\n    for (i = 0; i < D_CODES; i++) {\n        fprintf(header, \"%5u%s\", base_dist[i],\n                SEPARATOR(i, D_CODES-1, 10));\n    }\n\n    fclose(header);\n}",
          "fn_code_pos": [
            [
              387,
              0
            ],
            [
              433,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_trees_header",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "local void init_block(deflate_state *s) {\n    int n; /* iterates over tree elements */\n\n    /* Initialize the trees. */\n    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;\n    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;\n    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;\n\n    s->dyn_ltree[END_BLOCK].Freq = 1;\n    s->opt_len = s->static_len = 0L;\n    s->sym_next = s->matches = 0;\n}",
          "fn_code_pos": [
            [
              439,
              0
            ],
            [
              450,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "init_block",
            "parameters": {
              "s": "deflate_state"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "void ZLIB_INTERNAL _tr_init(deflate_state *s) {\n    tr_static_init();\n\n    s->l_desc.dyn_tree = s->dyn_ltree;\n    s->l_desc.stat_desc = &static_l_desc;\n\n    s->d_desc.dyn_tree = s->dyn_dtree;\n    s->d_desc.stat_desc = &static_d_desc;\n\n    s->bl_desc.dyn_tree = s->bl_tree;\n    s->bl_desc.stat_desc = &static_bl_desc;\n\n    s->bi_buf = 0;\n    s->bi_valid = 0;\n    s->bi_used = 0;\n#ifdef ZLIB_DEBUG\n    s->compressed_len = 0L;\n    s->bits_sent = 0L;\n#endif\n\n    /* Initialize the first block of the first file: */\n    init_block(s);\n}",
          "fn_code_pos": [
            [
              455,
              0
            ],
            [
              477,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL _tr_init",
            "parameters": {
              "s": "deflate_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "local void pqdownheap(deflate_state *s, ct_data *tree, int k) {\n    int v = s->heap[k];\n    int j = k << 1;  /* left son of k */\n    while (j <= s->heap_len) {\n        /* Set j to the smallest of the two sons: */\n        if (j < s->heap_len &&\n            smaller(tree, s->heap[j + 1], s->heap[j], s->depth)) {\n            j++;\n        }\n        /* Exit if v is smaller than both sons */\n        if (smaller(tree, v, s->heap[j], s->depth)) break;\n\n        /* Exchange v with the smallest son */\n        s->heap[k] = s->heap[j];  k = j;\n\n        /* And continue down the tree, setting j to the left son of k */\n        j <<= 1;\n    }\n    s->heap[k] = v;\n}",
          "fn_code_pos": [
            [
              508,
              0
            ],
            [
              527,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pqdownheap",
            "parameters": {
              "s": "deflate_state",
              "tree": "ct_data",
              "k": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void gen_bitlen(deflate_state *s, tree_desc *desc) {\n    ct_data *tree        = desc->dyn_tree;\n    int max_code         = desc->max_code;\n    const ct_data *stree = desc->stat_desc->static_tree;\n    const intf *extra    = desc->stat_desc->extra_bits;\n    int base             = desc->stat_desc->extra_base;\n    int max_length       = desc->stat_desc->max_length;\n    int h;              /* heap index */\n    int n, m;           /* iterate over the tree elements */\n    int bits;           /* bit length */\n    int xbits;          /* extra bits */\n    ush f;              /* frequency */\n    int overflow = 0;   /* number of elements with bit length too large */\n\n    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;\n\n    /* In a first pass, compute the optimal bit lengths (which may\n     * overflow in the case of the bit length tree).\n     */\n    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */\n\n    for (h = s->heap_max + 1; h < HEAP_SIZE; h++) {\n        n = s->heap[h];\n        bits = tree[tree[n].Dad].Len + 1;\n        if (bits > max_length) bits = max_length, overflow++;\n        tree[n].Len = (ush)bits;\n        /* We overwrite tree[n].Dad which is no longer needed */\n\n        if (n > max_code) continue; /* not a leaf node */\n\n        s->bl_count[bits]++;\n        xbits = 0;\n        if (n >= base) xbits = extra[n - base];\n        f = tree[n].Freq;\n        s->opt_len += (ulg)f * (unsigned)(bits + xbits);\n        if (stree) s->static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);\n    }\n    if (overflow == 0) return;\n\n    Tracev((stderr,\"\\nbit length overflow\\n\"));\n    /* This happens for example on obj2 and pic of the Calgary corpus */\n\n    /* Find the first bit length which could increase: */\n    do {\n        bits = max_length - 1;\n        while (s->bl_count[bits] == 0) bits--;\n        s->bl_count[bits]--;        /* move one leaf down the tree */\n        s->bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n        s->bl_count[max_length]--;\n        /* The brother of the overflow item also moves one step up,\n         * but this does not affect bl_count[max_length]\n         */\n        overflow -= 2;\n    } while (overflow > 0);\n\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n     * lengths instead of fixing only the wrong ones. This idea is taken\n     * from 'ar' written by Haruhiko Okumura.)\n     */\n    for (bits = max_length; bits != 0; bits--) {\n        n = s->bl_count[bits];\n        while (n != 0) {\n            m = s->heap[--h];\n            if (m > max_code) continue;\n            if ((unsigned) tree[m].Len != (unsigned) bits) {\n                Tracev((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n                s->opt_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;\n                tree[m].Len = (ush)bits;\n            }\n            n--;\n        }\n    }\n}",
          "fn_code_pos": [
            [
              539,
              0
            ],
            [
              612,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_bitlen",
            "parameters": {
              "s": "deflate_state",
              "desc": "tree_desc"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void build_tree(deflate_state *s, tree_desc *desc) {\n    ct_data *tree         = desc->dyn_tree;\n    const ct_data *stree  = desc->stat_desc->static_tree;\n    int elems             = desc->stat_desc->elems;\n    int n, m;          /* iterate over heap elements */\n    int max_code = -1; /* largest code with non zero frequency */\n    int node;          /* new node being created */\n\n    /* Construct the initial heap, with least frequent element in\n     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n + 1].\n     * heap[0] is not used.\n     */\n    s->heap_len = 0, s->heap_max = HEAP_SIZE;\n\n    for (n = 0; n < elems; n++) {\n        if (tree[n].Freq != 0) {\n            s->heap[++(s->heap_len)] = max_code = n;\n            s->depth[n] = 0;\n        } else {\n            tree[n].Len = 0;\n        }\n    }\n\n    /* The pkzip format requires that at least one distance code exists,\n     * and that at least one bit should be sent even if there is only one\n     * possible code. So to avoid special checks later on we force at least\n     * two codes of non zero frequency.\n     */\n    while (s->heap_len < 2) {\n        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);\n        tree[node].Freq = 1;\n        s->depth[node] = 0;\n        s->opt_len--; if (stree) s->static_len -= stree[node].Len;\n        /* node is 0 or 1 so it does not have extra bits */\n    }\n    desc->max_code = max_code;\n\n    /* The elements heap[heap_len/2 + 1 .. heap_len] are leaves of the tree,\n     * establish sub-heaps of increasing lengths:\n     */\n    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);\n\n    /* Construct the Huffman tree by repeatedly combining the least two\n     * frequent nodes.\n     */\n    node = elems;              /* next internal node of the tree */\n    do {\n        pqremove(s, tree, n);  /* n = node of least frequency */\n        m = s->heap[SMALLEST]; /* m = node of next least frequency */\n\n        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */\n        s->heap[--(s->heap_max)] = m;\n\n        /* Create a new node father of n and m */\n        tree[node].Freq = tree[n].Freq + tree[m].Freq;\n        s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?\n                                s->depth[n] : s->depth[m]) + 1);\n        tree[n].Dad = tree[m].Dad = (ush)node;\n#ifdef DUMP_BL_TREE\n        if (tree == s->bl_tree) {\n            fprintf(stderr,\"\\nnode %d(%d), sons %d(%d) %d(%d)\",\n                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);\n        }\n#endif\n        /* and insert the new node in the heap */\n        s->heap[SMALLEST] = node++;\n        pqdownheap(s, tree, SMALLEST);\n\n    } while (s->heap_len >= 2);\n\n    s->heap[--(s->heap_max)] = s->heap[SMALLEST];\n\n    /* At this point, the fields freq and dad are set. We can now\n     * generate the bit lengths.\n     */\n    gen_bitlen(s, (tree_desc *)desc);\n\n    /* The field len is now set, we can generate the bit codes */\n    gen_codes ((ct_data *)tree, max_code, s->bl_count);\n}",
          "fn_code_pos": [
            [
              626,
              0
            ],
            [
              705,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "build_tree",
            "parameters": {
              "s": "deflate_state",
              "desc": "tree_desc"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void scan_tree(deflate_state *s, ct_data *tree, int max_code) {\n    int n;                     /* iterates over all tree elements */\n    int prevlen = -1;          /* last emitted length */\n    int curlen;                /* length of current code */\n    int nextlen = tree[0].Len; /* length of next code */\n    int count = 0;             /* repeat count of the current code */\n    int max_count = 7;         /* max repeat count */\n    int min_count = 4;         /* min repeat count */\n\n    if (nextlen == 0) max_count = 138, min_count = 3;\n    tree[max_code + 1].Len = (ush)0xffff; /* guard */\n\n    for (n = 0; n <= max_code; n++) {\n        curlen = nextlen; nextlen = tree[n + 1].Len;\n        if (++count < max_count && curlen == nextlen) {\n            continue;\n        } else if (count < min_count) {\n            s->bl_tree[curlen].Freq += (ush)count;\n        } else if (curlen != 0) {\n            if (curlen != prevlen) s->bl_tree[curlen].Freq++;\n            s->bl_tree[REP_3_6].Freq++;\n        } else if (count <= 10) {\n            s->bl_tree[REPZ_3_10].Freq++;\n        } else {\n            s->bl_tree[REPZ_11_138].Freq++;\n        }\n        count = 0; prevlen = curlen;\n        if (nextlen == 0) {\n            max_count = 138, min_count = 3;\n        } else if (curlen == nextlen) {\n            max_count = 6, min_count = 3;\n        } else {\n            max_count = 7, min_count = 4;\n        }\n    }\n}",
          "fn_code_pos": [
            [
              711,
              0
            ],
            [
              746,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "scan_tree",
            "parameters": {
              "s": "deflate_state",
              "tree": "ct_data",
              "max_code": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void send_tree(deflate_state *s, ct_data *tree, int max_code) {\n    int n;                     /* iterates over all tree elements */\n    int prevlen = -1;          /* last emitted length */\n    int curlen;                /* length of current code */\n    int nextlen = tree[0].Len; /* length of next code */\n    int count = 0;             /* repeat count of the current code */\n    int max_count = 7;         /* max repeat count */\n    int min_count = 4;         /* min repeat count */\n\n    /* tree[max_code + 1].Len = -1; */  /* guard already set */\n    if (nextlen == 0) max_count = 138, min_count = 3;\n\n    for (n = 0; n <= max_code; n++) {\n        curlen = nextlen; nextlen = tree[n + 1].Len;\n        if (++count < max_count && curlen == nextlen) {\n            continue;\n        } else if (count < min_count) {\n            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);\n\n        } else if (curlen != 0) {\n            if (curlen != prevlen) {\n                send_code(s, curlen, s->bl_tree); count--;\n            }\n            Assert(count >= 3 && count <= 6, \" 3_6?\");\n            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count - 3, 2);\n\n        } else if (count <= 10) {\n            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count - 3, 3);\n\n        } else {\n            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count - 11, 7);\n        }\n        count = 0; prevlen = curlen;\n        if (nextlen == 0) {\n            max_count = 138, min_count = 3;\n        } else if (curlen == nextlen) {\n            max_count = 6, min_count = 3;\n        } else {\n            max_count = 7, min_count = 4;\n        }\n    }\n}",
          "fn_code_pos": [
            [
              752,
              0
            ],
            [
              793,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "send_tree",
            "parameters": {
              "s": "deflate_state",
              "tree": "ct_data",
              "max_code": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int build_bl_tree(deflate_state *s) {\n    int max_blindex;  /* index of last bit length code of non zero freq */\n\n    /* Determine the bit length frequencies for literal and distance trees */\n    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);\n    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);\n\n    /* Build the bit length tree: */\n    build_tree(s, (tree_desc *)(&(s->bl_desc)));\n    /* opt_len now includes the length of the tree representations, except the\n     * lengths of the bit lengths codes and the 5 + 5 + 4 bits for the counts.\n     */\n\n    /* Determine the number of bit length codes to send. The pkzip format\n     * requires that at least 4 bit length codes be sent. (appnote.txt says\n     * 3 but the actual value used is 4.)\n     */\n    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {\n        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;\n    }\n    /* Update opt_len to include the bit length tree and counts */\n    s->opt_len += 3*((ulg)max_blindex + 1) + 5 + 5 + 4;\n    Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n            s->opt_len, s->static_len));\n\n    return max_blindex;\n}",
          "fn_code_pos": [
            [
              799,
              0
            ],
            [
              825,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "build_bl_tree",
            "parameters": {
              "s": "deflate_state"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void send_all_trees(deflate_state *s, int lcodes, int dcodes,\n                          int blcodes) {\n    int rank;                    /* index in bl_order */\n\n    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n            \"too many codes\");\n    Tracev((stderr, \"\\nbl counts: \"));\n    send_bits(s, lcodes - 257, 5);  /* not +255 as stated in appnote.txt */\n    send_bits(s, dcodes - 1,   5);\n    send_bits(s, blcodes - 4,  4);  /* not -3 as stated in appnote.txt */\n    for (rank = 0; rank < blcodes; rank++) {\n        Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);\n    }\n    Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n    send_tree(s, (ct_data *)s->dyn_ltree, lcodes - 1);  /* literal tree */\n    Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n    send_tree(s, (ct_data *)s->dyn_dtree, dcodes - 1);  /* distance tree */\n    Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}",
          "fn_code_pos": [
            [
              832,
              0
            ],
            [
              854,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "send_all_trees",
            "parameters": {
              "s": "deflate_state",
              "lcodes": "int",
              "dcodes": "int",
              "blcodes": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "void ZLIB_INTERNAL _tr_stored_block(deflate_state *s, charf *buf,\n                                    ulg stored_len, int last) {\n    send_bits(s, (STORED_BLOCK<<1) + last, 3);  /* send block type */\n    bi_windup(s);        /* align on byte boundary */\n    put_short(s, (ush)stored_len);\n    put_short(s, (ush)~stored_len);\n    if (stored_len)\n        zmemcpy(s->pending_buf + s->pending, (Bytef *)buf, stored_len);\n    s->pending += stored_len;\n#ifdef ZLIB_DEBUG\n    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;\n    s->compressed_len += (stored_len + 4) << 3;\n    s->bits_sent += 2*16;\n    s->bits_sent += stored_len << 3;\n#endif\n}",
          "fn_code_pos": [
            [
              859,
              0
            ],
            [
              874,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL _tr_stored_block",
            "parameters": {
              "s": "deflate_state",
              "buf": "charf",
              "stored_len": "ulg",
              "last": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ZLIB_INTERNAL _tr_flush_bits(deflate_state *s) {\n    bi_flush(s);\n}",
          "fn_code_pos": [
            [
              879,
              0
            ],
            [
              881,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL _tr_flush_bits",
            "parameters": {
              "s": "deflate_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ZLIB_INTERNAL _tr_align(deflate_state *s) {\n    send_bits(s, STATIC_TREES<<1, 3);\n    send_code(s, END_BLOCK, static_ltree);\n#ifdef ZLIB_DEBUG\n    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */\n#endif\n    bi_flush(s);\n}",
          "fn_code_pos": [
            [
              887,
              0
            ],
            [
              894,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL _tr_align",
            "parameters": {
              "s": "deflate_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "local void compress_block(deflate_state *s, const ct_data *ltree,\n                          const ct_data *dtree) {\n    unsigned dist;      /* distance of matched string */\n    int lc;             /* match length or unmatched char (if dist == 0) */\n    unsigned sx = 0;    /* running index in symbol buffers */\n    unsigned code;      /* the code to send */\n    int extra;          /* number of extra bits to send */\n\n    if (s->sym_next != 0) do {\n#ifdef LIT_MEM\n        dist = s->d_buf[sx];\n        lc = s->l_buf[sx++];\n#else\n        dist = s->sym_buf[sx++] & 0xff;\n        dist += (unsigned)(s->sym_buf[sx++] & 0xff) << 8;\n        lc = s->sym_buf[sx++];\n#endif\n        if (dist == 0) {\n            send_code(s, lc, ltree); /* send a literal byte */\n            Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n        } else {\n            /* Here, lc is the match length - MIN_MATCH */\n            code = _length_code[lc];\n            send_code(s, code + LITERALS + 1, ltree);   /* send length code */\n            extra = extra_lbits[code];\n            if (extra != 0) {\n                lc -= base_length[code];\n                send_bits(s, lc, extra);       /* send the extra length bits */\n            }\n            dist--; /* dist is now the match distance - 1 */\n            code = d_code(dist);\n            Assert (code < D_CODES, \"bad d_code\");\n\n            send_code(s, code, dtree);       /* send the distance code */\n            extra = extra_dbits[code];\n            if (extra != 0) {\n                dist -= (unsigned)base_dist[code];\n                send_bits(s, dist, extra);   /* send the extra distance bits */\n            }\n        } /* literal or match pair ? */\n\n        /* Check for no overlay of pending_buf on needed symbols */\n#ifdef LIT_MEM\n        Assert(s->pending < 2 * (s->lit_bufsize + sx), \"pendingBuf overflow\");\n#else\n        Assert(s->pending < s->lit_bufsize + sx, \"pendingBuf overflow\");\n#endif\n\n    } while (sx < s->sym_next);\n\n    send_code(s, END_BLOCK, ltree);\n}",
          "fn_code_pos": [
            [
              899,
              0
            ],
            [
              950,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compress_block",
            "parameters": {
              "s": "deflate_state",
              "ltree": "ct_data",
              "dtree": "ct_data"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int detect_data_type(deflate_state *s) {\n    /* block_mask is the bit mask of block-listed bytes\n     * set bits 0..6, 14..25, and 28..31\n     * 0xf3ffc07f = binary 11110011111111111100000001111111\n     */\n    unsigned long block_mask = 0xf3ffc07fUL;\n    int n;\n\n    /* Check for non-textual (\"block-listed\") bytes. */\n    for (n = 0; n <= 31; n++, block_mask >>= 1)\n        if ((block_mask & 1) && (s->dyn_ltree[n].Freq != 0))\n            return Z_BINARY;\n\n    /* Check for textual (\"allow-listed\") bytes. */\n    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0\n            || s->dyn_ltree[13].Freq != 0)\n        return Z_TEXT;\n    for (n = 32; n < LITERALS; n++)\n        if (s->dyn_ltree[n].Freq != 0)\n            return Z_TEXT;\n\n    /* There are no \"block-listed\" or \"allow-listed\" bytes:\n     * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n     */\n    return Z_BINARY;\n}",
          "fn_code_pos": [
            [
              965,
              0
            ],
            [
              990,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "detect_data_type",
            "parameters": {
              "s": "deflate_state"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int ZLIB_INTERNAL _tr_tally(deflate_state *s, unsigned dist, unsigned lc) {\n#ifdef LIT_MEM\n    s->d_buf[s->sym_next] = (ush)dist;\n    s->l_buf[s->sym_next++] = (uch)lc;\n#else\n    s->sym_buf[s->sym_next++] = (uch)dist;\n    s->sym_buf[s->sym_next++] = (uch)(dist >> 8);\n    s->sym_buf[s->sym_next++] = (uch)lc;\n#endif\n    if (dist == 0) {\n        /* lc is the unmatched char */\n        s->dyn_ltree[lc].Freq++;\n    } else {\n        s->matches++;\n        /* Here, lc is the match length - MIN_MATCH */\n        dist--;             /* dist = match distance - 1 */\n        Assert((ush)dist < (ush)MAX_DIST(s) &&\n               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n               (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n        s->dyn_ltree[_length_code[lc] + LITERALS + 1].Freq++;\n        s->dyn_dtree[d_code(dist)].Freq++;\n    }\n    return (s->sym_next == s->sym_end);\n}",
          "fn_code_pos": [
            [
              1094,
              0
            ],
            [
              1118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL _tr_tally",
            "parameters": {
              "s": "deflate_state",
              "dist": "unsigned",
              "lc": "unsigned"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "gen_trees_header(void)",
          "fn_dec_pos": [
            [
              234,
              11
            ],
            [
              234,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gen_trees_header",
            "parameters": {},
            "return_type": "local"
          }
        },
        {
          "fn_code": "ZLIB_INTERNAL _tr_flush_block(deflate_state *s, charf *buf,\n                                   ulg stored_len, int last)",
          "fn_dec_pos": [
            [
              996,
              5
            ],
            [
              997,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL _tr_flush_block",
            "parameters": {
              "s": "deflate_state",
              "buf": "charf",
              "stored_len": "ulg",
              "last": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct static_tree_desc_s {\n    const ct_data *static_tree;  /* static tree or NULL */\n    const intf *extra_bits;      /* extra bits for each code or NULL */\n    int     extra_base;          /* base index for extra_bits */\n    int     elems;               /* max number of elements in the tree */\n    int     max_length;          /* max bit length for the codes */\n}",
          {
            "ct_data": "const",
            "intf": "const",
            "extra_base": "int",
            "elems": "int",
            "max_length": "int"
          },
          "static_tree_desc_s",
          [
            116,
            0
          ],
          [
            122,
            1
          ]
        ],
        [
          "struct static_tree_desc_s {\n    const ct_data *static_tree;  /* static tree or NULL */\n    const intf *extra_bits;      /* extra bits for each code or NULL */\n    int     extra_base;          /* base index for extra_bits */\n    int     elems;               /* max number of elements in the tree */\n    int     max_length;          /* max bit length for the codes */\n}",
          {
            "ct_data": "const",
            "intf": "const",
            "extra_base": "int",
            "elems": "int",
            "max_length": "int"
          },
          "static_tree_desc_s",
          [
            116,
            0
          ],
          [
            122,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"deflate.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#  include <ctype.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#  include \"trees.h\"\n",
          [
            113,
            0
          ],
          [
            114,
            0
          ]
        ],
        [
          "#    include <stdio.h>\n",
          [
            380,
            0
          ],
          [
            381,
            0
          ]
        ],
        [
          "#  include <stdio.h>\n",
          [
            615,
            0
          ],
          [
            616,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/uncompr.c": {
      "fn_def_list": [
        {
          "fn_code": "int ZEXPORT uncompress2(Bytef *dest, uLongf *destLen, const Bytef *source,\n                        uLong *sourceLen) {\n    z_stream stream;\n    int err;\n    const uInt max = (uInt)-1;\n    uLong len, left;\n    Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */\n\n    len = *sourceLen;\n    if (*destLen) {\n        left = *destLen;\n        *destLen = 0;\n    }\n    else {\n        left = 1;\n        dest = buf;\n    }\n\n    stream.next_in = (z_const Bytef *)source;\n    stream.avail_in = 0;\n    stream.zalloc = (alloc_func)0;\n    stream.zfree = (free_func)0;\n    stream.opaque = (voidpf)0;\n\n    err = inflateInit(&stream);\n    if (err != Z_OK) return err;\n\n    stream.next_out = dest;\n    stream.avail_out = 0;\n\n    do {\n        if (stream.avail_out == 0) {\n            stream.avail_out = left > (uLong)max ? max : (uInt)left;\n            left -= stream.avail_out;\n        }\n        if (stream.avail_in == 0) {\n            stream.avail_in = len > (uLong)max ? max : (uInt)len;\n            len -= stream.avail_in;\n        }\n        err = inflate(&stream, Z_NO_FLUSH);\n    } while (err == Z_OK);\n\n    *sourceLen -= len + stream.avail_in;\n    if (dest != buf)\n        *destLen = stream.total_out;\n    else if (stream.total_out && err == Z_BUF_ERROR)\n        left = 1;\n\n    inflateEnd(&stream);\n    return err == Z_STREAM_END ? Z_OK :\n           err == Z_NEED_DICT ? Z_DATA_ERROR  :\n           err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :\n           err;\n}",
          "fn_code_pos": [
            [
              26,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "uncompress2",
            "parameters": {
              "dest": "Bytef",
              "destLen": "uLongf",
              "source": "Bytef",
              "sourceLen": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT uncompress(Bytef *dest, uLongf *destLen, const Bytef *source,\n                       uLong sourceLen) {\n    return uncompress2(dest, destLen, source, &sourceLen);\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "uncompress",
            "parameters": {
              "dest": "Bytef",
              "destLen": "uLongf",
              "source": "Bytef",
              "sourceLen": "uLong"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"zlib.h\"\n",
          [
            8,
            0
          ],
          [
            9,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/gzread.c": {
      "fn_def_list": [
        {
          "fn_code": "local int gz_load(gz_statep state, unsigned char *buf, unsigned len,\n                  unsigned *have) {\n    int ret;\n    unsigned get, max = ((unsigned)-1 >> 2) + 1;\n\n    *have = 0;\n    do {\n        get = len - *have;\n        if (get > max)\n            get = max;\n        ret = read(state->fd, buf + *have, get);\n        if (ret <= 0)\n            break;\n        *have += (unsigned)ret;\n    } while (*have < len);\n    if (ret < 0) {\n        gz_error(state, Z_ERRNO, zstrerror());\n        return -1;\n    }\n    if (ret == 0)\n        state->eof = 1;\n    return 0;\n}",
          "fn_code_pos": [
            [
              11,
              0
            ],
            [
              33,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_load",
            "parameters": {
              "state": "gz_statep",
              "buf": "unsigned char",
              "len": "unsigned",
              "have": "unsigned"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int gz_avail(gz_statep state) {\n    unsigned got;\n    z_streamp strm = &(state->strm);\n\n    if (state->err != Z_OK && state->err != Z_BUF_ERROR)\n        return -1;\n    if (state->eof == 0) {\n        if (strm->avail_in) {       /* copy what's there to the start */\n            unsigned char *p = state->in;\n            unsigned const char *q = strm->next_in;\n            unsigned n = strm->avail_in;\n            do {\n                *p++ = *q++;\n            } while (--n);\n        }\n        if (gz_load(state, state->in + strm->avail_in,\n                    state->size - strm->avail_in, &got) == -1)\n            return -1;\n        strm->avail_in += got;\n        strm->next_in = state->in;\n    }\n    return 0;\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              64,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_avail",
            "parameters": {
              "state": "gz_statep"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int gz_look(gz_statep state) {\n    z_streamp strm = &(state->strm);\n\n    /* allocate read buffers and inflate memory */\n    if (state->size == 0) {\n        /* allocate buffers */\n        state->in = (unsigned char *)malloc(state->want);\n        state->out = (unsigned char *)malloc(state->want << 1);\n        if (state->in == NULL || state->out == NULL) {\n            free(state->out);\n            free(state->in);\n            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        state->size = state->want;\n\n        /* allocate inflate memory */\n        state->strm.zalloc = Z_NULL;\n        state->strm.zfree = Z_NULL;\n        state->strm.opaque = Z_NULL;\n        state->strm.avail_in = 0;\n        state->strm.next_in = Z_NULL;\n        if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */\n            free(state->out);\n            free(state->in);\n            state->size = 0;\n            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n    }\n\n    /* get at least the magic bytes in the input buffer */\n    if (strm->avail_in < 2) {\n        if (gz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in == 0)\n            return 0;\n    }\n\n    /* look for gzip magic bytes -- if there, do gzip decoding (note: there is\n       a logical dilemma here when considering the case of a partially written\n       gzip file, to wit, if a single 31 byte is written, then we cannot tell\n       whether this is a single-byte file, or just a partially written gzip\n       file -- for here we assume that if a gzip file is being written, then\n       the header will be written in a single operation, so that reading a\n       single byte is sufficient indication that it is not a gzip file) */\n    if (strm->avail_in > 1 &&\n            strm->next_in[0] == 31 && strm->next_in[1] == 139) {\n        inflateReset(strm);\n        state->how = GZIP;\n        state->direct = 0;\n        return 0;\n    }\n\n    /* no gzip header -- if we were decoding gzip before, then this is trailing\n       garbage.  Ignore the trailing garbage and finish. */\n    if (state->direct == 0) {\n        strm->avail_in = 0;\n        state->eof = 1;\n        state->x.have = 0;\n        return 0;\n    }\n\n    /* doing raw i/o, copy any leftover input to output -- this assumes that\n       the output buffer is larger than the input buffer, which also assures\n       space for gzungetc() */\n    state->x.next = state->out;\n    memcpy(state->x.next, strm->next_in, strm->avail_in);\n    state->x.have = strm->avail_in;\n    strm->avail_in = 0;\n    state->how = COPY;\n    state->direct = 1;\n    return 0;\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              148,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_look",
            "parameters": {
              "state": "gz_statep"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int gz_decomp(gz_statep state) {\n    int ret = Z_OK;\n    unsigned had;\n    z_streamp strm = &(state->strm);\n\n    /* fill output buffer up to end of deflate stream */\n    had = strm->avail_out;\n    do {\n        /* get more input for inflate() */\n        if (strm->avail_in == 0 && gz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in == 0) {\n            gz_error(state, Z_BUF_ERROR, \"unexpected end of file\");\n            break;\n        }\n\n        /* decompress and handle errors */\n        ret = inflate(strm, Z_NO_FLUSH);\n        if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {\n            gz_error(state, Z_STREAM_ERROR,\n                     \"internal error: inflate stream corrupt\");\n            return -1;\n        }\n        if (ret == Z_MEM_ERROR) {\n            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */\n            gz_error(state, Z_DATA_ERROR,\n                     strm->msg == NULL ? \"compressed data error\" : strm->msg);\n            return -1;\n        }\n    } while (strm->avail_out && ret != Z_STREAM_END);\n\n    /* update available output */\n    state->x.have = had - strm->avail_out;\n    state->x.next = strm->next_out - state->x.have;\n\n    /* if the gzip stream completed successfully, look for another */\n    if (ret == Z_STREAM_END)\n        state->how = LOOK;\n\n    /* good decompression */\n    return 0;\n}",
          "fn_code_pos": [
            [
              155,
              0
            ],
            [
              199,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_decomp",
            "parameters": {
              "state": "gz_statep"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int gz_fetch(gz_statep state) {\n    z_streamp strm = &(state->strm);\n\n    do {\n        switch(state->how) {\n        case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */\n            if (gz_look(state) == -1)\n                return -1;\n            if (state->how == LOOK)\n                return 0;\n            break;\n        case COPY:      /* -> COPY */\n            if (gz_load(state, state->out, state->size << 1, &(state->x.have))\n                    == -1)\n                return -1;\n            state->x.next = state->out;\n            return 0;\n        case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */\n            strm->avail_out = state->size << 1;\n            strm->next_out = state->out;\n            if (gz_decomp(state) == -1)\n                return -1;\n        }\n    } while (state->x.have == 0 && (!state->eof || strm->avail_in));\n    return 0;\n}",
          "fn_code_pos": [
            [
              207,
              0
            ],
            [
              232,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_fetch",
            "parameters": {
              "state": "gz_statep"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int gz_skip(gz_statep state, z_off64_t len) {\n    unsigned n;\n\n    /* skip over len bytes or reach end-of-file, whichever comes first */\n    while (len)\n        /* skip over whatever is in output buffer */\n        if (state->x.have) {\n            n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?\n                (unsigned)len : state->x.have;\n            state->x.have -= n;\n            state->x.next += n;\n            state->x.pos += n;\n            len -= n;\n        }\n\n        /* output buffer empty -- return if we're at the end of the input */\n        else if (state->eof && state->strm.avail_in == 0)\n            break;\n\n        /* need more data to skip -- load up output buffer */\n        else {\n            /* get more output, looking for header if required */\n            if (gz_fetch(state) == -1)\n                return -1;\n        }\n    return 0;\n}",
          "fn_code_pos": [
            [
              235,
              0
            ],
            [
              261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_skip",
            "parameters": {
              "state": "gz_statep",
              "len": "z_off64_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local z_size_t gz_read(gz_statep state, voidp buf, z_size_t len) {\n    z_size_t got;\n    unsigned n;\n\n    /* if len is zero, avoid unnecessary operations */\n    if (len == 0)\n        return 0;\n\n    /* process a skip request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_skip(state, state->skip) == -1)\n            return 0;\n    }\n\n    /* get len bytes to buf, or less than len if at the end */\n    got = 0;\n    do {\n        /* set n to the maximum amount of len that fits in an unsigned int */\n        n = (unsigned)-1;\n        if (n > len)\n            n = (unsigned)len;\n\n        /* first just try copying data from the output buffer */\n        if (state->x.have) {\n            if (state->x.have < n)\n                n = state->x.have;\n            memcpy(buf, state->x.next, n);\n            state->x.next += n;\n            state->x.have -= n;\n        }\n\n        /* output buffer empty -- return if we're at the end of the input */\n        else if (state->eof && state->strm.avail_in == 0) {\n            state->past = 1;        /* tried to read past end */\n            break;\n        }\n\n        /* need output data -- for small len or new stream load up our output\n           buffer */\n        else if (state->how == LOOK || n < (state->size << 1)) {\n            /* get more output, looking for header if required */\n            if (gz_fetch(state) == -1)\n                return 0;\n            continue;       /* no progress yet -- go back to copy above */\n            /* the copy above assures that we will leave with space in the\n               output buffer, allowing at least one gzungetc() to succeed */\n        }\n\n        /* large len -- read directly into user buffer */\n        else if (state->how == COPY) {      /* read directly */\n            if (gz_load(state, (unsigned char *)buf, n, &n) == -1)\n                return 0;\n        }\n\n        /* large len -- decompress directly into user buffer */\n        else {  /* state->how == GZIP */\n            state->strm.avail_out = n;\n            state->strm.next_out = (unsigned char *)buf;\n            if (gz_decomp(state) == -1)\n                return 0;\n            n = state->x.have;\n            state->x.have = 0;\n        }\n\n        /* update progress */\n        len -= n;\n        buf = (char *)buf + n;\n        got += n;\n        state->x.pos += n;\n    } while (len);\n\n    /* return number of bytes read into user buffer */\n    return got;\n}",
          "fn_code_pos": [
            [
              267,
              0
            ],
            [
              341,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_read",
            "parameters": {
              "state": "gz_statep",
              "buf": "voidp",
              "len": "z_size_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int ZEXPORT gzread(gzFile file, voidp buf, unsigned len) {\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n\n    /* check that we're reading and that there's no (serious) error */\n    if (state->mode != GZ_READ ||\n            (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return -1;\n\n    /* since an int is returned, make sure len fits in one, otherwise return\n       with an error (this avoids a flaw in the interface) */\n    if ((int)len < 0) {\n        gz_error(state, Z_STREAM_ERROR, \"request does not fit in an int\");\n        return -1;\n    }\n\n    /* read len or fewer bytes to buf */\n    len = (unsigned)gz_read(state, buf, len);\n\n    /* check for an error */\n    if (len == 0 && state->err != Z_OK && state->err != Z_BUF_ERROR)\n        return -1;\n\n    /* return the number of bytes read (this is assured to fit in an int) */\n    return (int)len;\n}",
          "fn_code_pos": [
            [
              344,
              0
            ],
            [
              373,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzread",
            "parameters": {
              "file": "gzFile",
              "buf": "voidp",
              "len": "unsigned"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "z_size_t ZEXPORT gzfread(voidp buf, z_size_t size, z_size_t nitems,\n                         gzFile file) {\n    z_size_t len;\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return 0;\n    state = (gz_statep)file;\n\n    /* check that we're reading and that there's no (serious) error */\n    if (state->mode != GZ_READ ||\n            (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return 0;\n\n    /* compute bytes to read -- error on overflow */\n    len = nitems * size;\n    if (size && len / size != nitems) {\n        gz_error(state, Z_STREAM_ERROR, \"request does not fit in a size_t\");\n        return 0;\n    }\n\n    /* read len or fewer bytes to buf, return the number of full items read */\n    return len ? gz_read(state, buf, len) / size : 0;\n}",
          "fn_code_pos": [
            [
              376,
              0
            ],
            [
              400,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfread",
            "parameters": {
              "buf": "voidp",
              "size": "z_size_t",
              "nitems": "z_size_t",
              "file": "gzFile"
            },
            "return_type": "z_size_t"
          }
        },
        {
          "fn_code": "int ZEXPORT gzgetc(gzFile file) {\n    unsigned char buf[1];\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n\n    /* check that we're reading and that there's no (serious) error */\n    if (state->mode != GZ_READ ||\n        (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return -1;\n\n    /* try output buffer (no need to check for skip request) */\n    if (state->x.have) {\n        state->x.have--;\n        state->x.pos++;\n        return *(state->x.next)++;\n    }\n\n    /* nothing there -- try gz_read() */\n    return gz_read(state, buf, 1) < 1 ? -1 : buf[0];\n}",
          "fn_code_pos": [
            [
              408,
              0
            ],
            [
              431,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzgetc",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT gzgetc_(gzFile file) {\n    return gzgetc(file);\n}",
          "fn_code_pos": [
            [
              433,
              0
            ],
            [
              435,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzgetc_",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT gzungetc(int c, gzFile file) {\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n\n    /* in case this was just opened, set up the input buffer */\n    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)\n        (void)gz_look(state);\n\n    /* check that we're reading and that there's no (serious) error */\n    if (state->mode != GZ_READ ||\n        (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return -1;\n\n    /* process a skip request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_skip(state, state->skip) == -1)\n            return -1;\n    }\n\n    /* can't push EOF */\n    if (c < 0)\n        return -1;\n\n    /* if output buffer empty, put byte at end (allows more pushing) */\n    if (state->x.have == 0) {\n        state->x.have = 1;\n        state->x.next = state->out + (state->size << 1) - 1;\n        state->x.next[0] = (unsigned char)c;\n        state->x.pos--;\n        state->past = 0;\n        return c;\n    }\n\n    /* if no room, give up (must have already done a gzungetc()) */\n    if (state->x.have == (state->size << 1)) {\n        gz_error(state, Z_DATA_ERROR, \"out of room to push characters\");\n        return -1;\n    }\n\n    /* slide output data if needed and insert byte before existing data */\n    if (state->x.next == state->out) {\n        unsigned char *src = state->out + state->x.have;\n        unsigned char *dest = state->out + (state->size << 1);\n        while (src > state->out)\n            *--dest = *--src;\n        state->x.next = dest;\n    }\n    state->x.have++;\n    state->x.next--;\n    state->x.next[0] = (unsigned char)c;\n    state->x.pos--;\n    state->past = 0;\n    return c;\n}",
          "fn_code_pos": [
            [
              438,
              0
            ],
            [
              496,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzungetc",
            "parameters": {
              "c": "int",
              "file": "gzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "char * ZEXPORT gzgets(gzFile file, char *buf, int len) {\n    unsigned left, n;\n    char *str;\n    unsigned char *eol;\n    gz_statep state;\n\n    /* check parameters and get internal structure */\n    if (file == NULL || buf == NULL || len < 1)\n        return NULL;\n    state = (gz_statep)file;\n\n    /* check that we're reading and that there's no (serious) error */\n    if (state->mode != GZ_READ ||\n        (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return NULL;\n\n    /* process a skip request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_skip(state, state->skip) == -1)\n            return NULL;\n    }\n\n    /* copy output bytes up to new line or len - 1, whichever comes first --\n       append a terminating zero to the string (we don't check for a zero in\n       the contents, let the user worry about that) */\n    str = buf;\n    left = (unsigned)len - 1;\n    if (left) do {\n        /* assure that something is in the output buffer */\n        if (state->x.have == 0 && gz_fetch(state) == -1)\n            return NULL;                /* error */\n        if (state->x.have == 0) {       /* end of file */\n            state->past = 1;            /* read past end */\n            break;                      /* return what we have */\n        }\n\n        /* look for end-of-line in current output buffer */\n        n = state->x.have > left ? left : state->x.have;\n        eol = (unsigned char *)memchr(state->x.next, '\\n', n);\n        if (eol != NULL)\n            n = (unsigned)(eol - state->x.next) + 1;\n\n        /* copy through end-of-line, or remainder if not found */\n        memcpy(buf, state->x.next, n);\n        state->x.have -= n;\n        state->x.next += n;\n        state->x.pos += n;\n        left -= n;\n        buf += n;\n    } while (left && eol == NULL);\n\n    /* return terminated string, or if nothing, end of file */\n    if (buf == str)\n        return NULL;\n    buf[0] = 0;\n    return str;\n}",
          "fn_code_pos": [
            [
              499,
              0
            ],
            [
              556,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzgets",
            "parameters": {
              "file": "gzFile",
              "buf": "char",
              "len": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int ZEXPORT gzdirect(gzFile file) {\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return 0;\n    state = (gz_statep)file;\n\n    /* if the state is not known, but we can find out, then do so (this is\n       mainly for right after a gzopen() or gzdopen()) */\n    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)\n        (void)gz_look(state);\n\n    /* return 1 if transparent, 0 if processing a gzip stream */\n    return state->direct;\n}",
          "fn_code_pos": [
            [
              559,
              0
            ],
            [
              574,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzdirect",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT gzclose_r(gzFile file) {\n    int ret, err;\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n\n    /* check that we're reading */\n    if (state->mode != GZ_READ)\n        return Z_STREAM_ERROR;\n\n    /* free memory and close file */\n    if (state->size) {\n        inflateEnd(&(state->strm));\n        free(state->out);\n        free(state->in);\n    }\n    err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;\n    gz_error(state, Z_OK, NULL);\n    free(state->path);\n    ret = close(state->fd);\n    free(state);\n    return ret ? Z_ERRNO : err;\n}",
          "fn_code_pos": [
            [
              577,
              0
            ],
            [
              602,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzclose_r",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "gzgets(gzFile file, char *buf, int len)",
          "fn_dec_pos": [
            [
              499,
              15
            ],
            [
              499,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzgets",
            "parameters": {
              "file": "gzFile",
              "buf": "char",
              "len": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"gzguts.h\"\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/zutil.c": {
      "fn_def_list": [
        {
          "fn_code": "const char * ZEXPORT zlibVersion(void) {\n    return ZLIB_VERSION;\n}",
          "fn_code_pos": [
            [
              26,
              0
            ],
            [
              28,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zlibVersion",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "uLong ZEXPORT zlibCompileFlags(void) {\n    uLong flags;\n\n    flags = 0;\n    switch ((int)(sizeof(uInt))) {\n    case 2:     break;\n    case 4:     flags += 1;     break;\n    case 8:     flags += 2;     break;\n    default:    flags += 3;\n    }\n    switch ((int)(sizeof(uLong))) {\n    case 2:     break;\n    case 4:     flags += 1 << 2;        break;\n    case 8:     flags += 2 << 2;        break;\n    default:    flags += 3 << 2;\n    }\n    switch ((int)(sizeof(voidpf))) {\n    case 2:     break;\n    case 4:     flags += 1 << 4;        break;\n    case 8:     flags += 2 << 4;        break;\n    default:    flags += 3 << 4;\n    }\n    switch ((int)(sizeof(z_off_t))) {\n    case 2:     break;\n    case 4:     flags += 1 << 6;        break;\n    case 8:     flags += 2 << 6;        break;\n    default:    flags += 3 << 6;\n    }\n#ifdef ZLIB_DEBUG\n    flags += 1 << 8;\n#endif\n    /*\n#if defined(ASMV) || defined(ASMINF)\n    flags += 1 << 9;\n#endif\n     */\n#ifdef ZLIB_WINAPI\n    flags += 1 << 10;\n#endif\n#ifdef BUILDFIXED\n    flags += 1 << 12;\n#endif\n#ifdef DYNAMIC_CRC_TABLE\n    flags += 1 << 13;\n#endif\n#ifdef NO_GZCOMPRESS\n    flags += 1L << 16;\n#endif\n#ifdef NO_GZIP\n    flags += 1L << 17;\n#endif\n#ifdef PKZIP_BUG_WORKAROUND\n    flags += 1L << 20;\n#endif\n#ifdef FASTEST\n    flags += 1L << 21;\n#endif\n#if defined(STDC) || defined(Z_HAVE_STDARG_H)\n#  ifdef NO_vsnprintf\n    flags += 1L << 25;\n#    ifdef HAS_vsprintf_void\n    flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_vsnprintf_void\n    flags += 1L << 26;\n#    endif\n#  endif\n#else\n    flags += 1L << 24;\n#  ifdef NO_snprintf\n    flags += 1L << 25;\n#    ifdef HAS_sprintf_void\n    flags += 1L << 26;\n#    endif\n#  else\n#    ifdef HAS_snprintf_void\n    flags += 1L << 26;\n#    endif\n#  endif\n#endif\n    return flags;\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zlibCompileFlags",
            "parameters": {},
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "void ZLIB_INTERNAL z_error(char *m) {\n    fprintf(stderr, \"%s\\n\", m);\n    exit(1);\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL z_error",
            "parameters": {
              "m": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "const char * ZEXPORT zError(int err) {\n    return ERR_MSG(err);\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              132,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zError",
            "parameters": {
              "err": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "void ZLIB_INTERNAL zmemcpy(Bytef* dest, const Bytef* source, uInt len) {\n    if (len == 0) return;\n    do {\n        *dest++ = *source++; /* ??? to be unrolled */\n    } while (--len != 0);\n}",
          "fn_code_pos": [
            [
              144,
              0
            ],
            [
              149,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL zmemcpy",
            "parameters": {
              "dest": "Bytef",
              "source": "Bytef",
              "len": "uInt"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ZLIB_INTERNAL zmemcmp(const Bytef* s1, const Bytef* s2, uInt len) {\n    uInt j;\n\n    for (j = 0; j < len; j++) {\n        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;\n    }\n    return 0;\n}",
          "fn_code_pos": [
            [
              151,
              0
            ],
            [
              158,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL zmemcmp",
            "parameters": {
              "s1": "Bytef",
              "s2": "Bytef",
              "len": "uInt"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void ZLIB_INTERNAL zmemzero(Bytef* dest, uInt len) {\n    if (len == 0) return;\n    do {\n        *dest++ = 0;  /* ??? to be unrolled */\n    } while (--len != 0);\n}",
          "fn_code_pos": [
            [
              160,
              0
            ],
            [
              165,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL zmemzero",
            "parameters": {
              "dest": "Bytef",
              "len": "uInt"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size) {\n    voidpf buf;\n    ulg bsize = (ulg)items*size;\n\n    (void)opaque;\n\n    /* If we allocate less than 65520 bytes, we assume that farmalloc\n     * will return a usable pointer which doesn't have to be normalized.\n     */\n    if (bsize < 65520L) {\n        buf = farmalloc(bsize);\n        if (*(ush*)&buf != 0) return buf;\n    } else {\n        buf = farmalloc(bsize + 16L);\n    }\n    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;\n    table[next_ptr].org_ptr = buf;\n\n    /* Normalize the pointer to seg:0 */\n    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;\n    *(ush*)&buf = 0;\n    table[next_ptr++].new_ptr = buf;\n    return buf;\n}",
          "fn_code_pos": [
            [
              201,
              0
            ],
            [
              224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL zcalloc",
            "parameters": {
              "opaque": "voidpf",
              "items": "unsigned",
              "size": "unsigned"
            },
            "return_type": "voidpf"
          }
        },
        {
          "fn_code": "void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr) {\n    int n;\n\n    (void)opaque;\n\n    if (*(ush*)&ptr != 0) { /* object < 64K */\n        farfree(ptr);\n        return;\n    }\n    /* Find the original pointer */\n    for (n = 0; n < next_ptr; n++) {\n        if (ptr != table[n].new_ptr) continue;\n\n        farfree(table[n].org_ptr);\n        while (++n < next_ptr) {\n            table[n-1] = table[n];\n        }\n        next_ptr--;\n        return;\n    }\n    Assert(0, \"zcfree: ptr not found\");\n}",
          "fn_code_pos": [
            [
              226,
              0
            ],
            [
              247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL zcfree",
            "parameters": {
              "opaque": "voidpf",
              "ptr": "voidpf"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, uInt items, uInt size) {\n    (void)opaque;\n    return _halloc((long)items, size);\n}",
          "fn_code_pos": [
            [
              262,
              0
            ],
            [
              265,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL zcalloc",
            "parameters": {
              "opaque": "voidpf",
              "items": "uInt",
              "size": "uInt"
            },
            "return_type": "voidpf"
          }
        },
        {
          "fn_code": "void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr) {\n    (void)opaque;\n    _hfree(ptr);\n}",
          "fn_code_pos": [
            [
              267,
              0
            ],
            [
              270,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL zcfree",
            "parameters": {
              "opaque": "voidpf",
              "ptr": "voidpf"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size) {\n    (void)opaque;\n    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :\n                              (voidpf)calloc(items, size);\n}",
          "fn_code_pos": [
            [
              285,
              0
            ],
            [
              289,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL zcalloc",
            "parameters": {
              "opaque": "voidpf",
              "items": "unsigned",
              "size": "unsigned"
            },
            "return_type": "voidpf"
          }
        },
        {
          "fn_code": "void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr) {\n    (void)opaque;\n    free(ptr);\n}",
          "fn_code_pos": [
            [
              291,
              0
            ],
            [
              294,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL zcfree",
            "parameters": {
              "opaque": "voidpf",
              "ptr": "voidpf"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "zlibVersion(void)",
          "fn_dec_pos": [
            [
              26,
              21
            ],
            [
              26,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zlibVersion",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "zError(int err)",
          "fn_dec_pos": [
            [
              130,
              21
            ],
            [
              130,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zError",
            "parameters": {
              "err": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "malloc(uInt size)",
          "fn_dec_pos": [
            [
              280,
              13
            ],
            [
              280,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "malloc",
            "parameters": {
              "size": "uInt"
            },
            "return_type": "voidp"
          }
        },
        {
          "fn_code": "calloc(uInt items, uInt size)",
          "fn_dec_pos": [
            [
              281,
              13
            ],
            [
              281,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "calloc",
            "parameters": {
              "items": "uInt",
              "size": "uInt"
            },
            "return_type": "voidp"
          }
        },
        {
          "fn_code": "free(voidpf ptr)",
          "fn_dec_pos": [
            [
              282,
              12
            ],
            [
              282,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "free",
            "parameters": {
              "ptr": "voidpf"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct ptr_table_s {\n    voidpf org_ptr;\n    voidpf new_ptr;\n} ptr_table;",
          {
            "org_ptr": "voidpf",
            "new_ptr": "voidpf"
          },
          "ptr_table",
          [
            188,
            0
          ],
          [
            191,
            12
          ]
        ],
        [
          "typedef struct ptr_table_s {\n    voidpf org_ptr;\n    voidpf new_ptr;\n} ptr_table;",
          {
            "org_ptr": "voidpf",
            "new_ptr": "voidpf"
          },
          "ptr_table",
          [
            188,
            0
          ],
          [
            191,
            12
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"zutil.h\"\n",
          [
            7,
            0
          ],
          [
            8,
            0
          ]
        ],
        [
          "#  include \"gzguts.h\"\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            115,
            0
          ],
          [
            116,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/gzwrite.c": {
      "fn_def_list": [
        {
          "fn_code": "local int gz_init(gz_statep state) {\n    int ret;\n    z_streamp strm = &(state->strm);\n\n    /* allocate input buffer (double size for gzprintf) */\n    state->in = (unsigned char *)malloc(state->want << 1);\n    if (state->in == NULL) {\n        gz_error(state, Z_MEM_ERROR, \"out of memory\");\n        return -1;\n    }\n\n    /* only need output buffer and deflate state if compressing */\n    if (!state->direct) {\n        /* allocate output buffer */\n        state->out = (unsigned char *)malloc(state->want);\n        if (state->out == NULL) {\n            free(state->in);\n            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n\n        /* allocate deflate memory, set up for gzip compression */\n        strm->zalloc = Z_NULL;\n        strm->zfree = Z_NULL;\n        strm->opaque = Z_NULL;\n        ret = deflateInit2(strm, state->level, Z_DEFLATED,\n                           MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);\n        if (ret != Z_OK) {\n            free(state->out);\n            free(state->in);\n            gz_error(state, Z_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        strm->next_in = NULL;\n    }\n\n    /* mark state as initialized */\n    state->size = state->want;\n\n    /* initialize write buffer if compressing */\n    if (!state->direct) {\n        strm->avail_out = state->size;\n        strm->next_out = state->out;\n        state->x.next = strm->next_out;\n    }\n    return 0;\n}",
          "fn_code_pos": [
            [
              10,
              0
            ],
            [
              56,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_init",
            "parameters": {
              "state": "gz_statep"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int gz_comp(gz_statep state, int flush) {\n    int ret, writ;\n    unsigned have, put, max = ((unsigned)-1 >> 2) + 1;\n    z_streamp strm = &(state->strm);\n\n    /* allocate memory if this is the first time through */\n    if (state->size == 0 && gz_init(state) == -1)\n        return -1;\n\n    /* write directly if requested */\n    if (state->direct) {\n        while (strm->avail_in) {\n            put = strm->avail_in > max ? max : strm->avail_in;\n            writ = write(state->fd, strm->next_in, put);\n            if (writ < 0) {\n                gz_error(state, Z_ERRNO, zstrerror());\n                return -1;\n            }\n            strm->avail_in -= (unsigned)writ;\n            strm->next_in += writ;\n        }\n        return 0;\n    }\n\n    /* check for a pending reset */\n    if (state->reset) {\n        /* don't start a new gzip member unless there is data to write */\n        if (strm->avail_in == 0)\n            return 0;\n        deflateReset(strm);\n        state->reset = 0;\n    }\n\n    /* run deflate() on provided input until it produces no more output */\n    ret = Z_OK;\n    do {\n        /* write out current buffer contents if full, or if flushing, but if\n           doing Z_FINISH then don't write until we get to Z_STREAM_END */\n        if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&\n            (flush != Z_FINISH || ret == Z_STREAM_END))) {\n            while (strm->next_out > state->x.next) {\n                put = strm->next_out - state->x.next > (int)max ? max :\n                      (unsigned)(strm->next_out - state->x.next);\n                writ = write(state->fd, state->x.next, put);\n                if (writ < 0) {\n                    gz_error(state, Z_ERRNO, zstrerror());\n                    return -1;\n                }\n                state->x.next += writ;\n            }\n            if (strm->avail_out == 0) {\n                strm->avail_out = state->size;\n                strm->next_out = state->out;\n                state->x.next = state->out;\n            }\n        }\n\n        /* compress */\n        have = strm->avail_out;\n        ret = deflate(strm, flush);\n        if (ret == Z_STREAM_ERROR) {\n            gz_error(state, Z_STREAM_ERROR,\n                      \"internal error: deflate stream corrupt\");\n            return -1;\n        }\n        have -= strm->avail_out;\n    } while (have);\n\n    /* if that completed a deflate stream, allow another to start */\n    if (flush == Z_FINISH)\n        state->reset = 1;\n\n    /* all done, no errors */\n    return 0;\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_comp",
            "parameters": {
              "state": "gz_statep",
              "flush": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int gz_zero(gz_statep state, z_off64_t len) {\n    int first;\n    unsigned n;\n    z_streamp strm = &(state->strm);\n\n    /* consume whatever's left in the input buffer */\n    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)\n        return -1;\n\n    /* compress len zeros (len guaranteed > 0) */\n    first = 1;\n    while (len) {\n        n = GT_OFF(state->size) || (z_off64_t)state->size > len ?\n            (unsigned)len : state->size;\n        if (first) {\n            memset(state->in, 0, n);\n            first = 0;\n        }\n        strm->avail_in = n;\n        strm->next_in = state->in;\n        state->x.pos += n;\n        if (gz_comp(state, Z_NO_FLUSH) == -1)\n            return -1;\n        len -= n;\n    }\n    return 0;\n}",
          "fn_code_pos": [
            [
              142,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_zero",
            "parameters": {
              "state": "gz_statep",
              "len": "z_off64_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local z_size_t gz_write(gz_statep state, voidpc buf, z_size_t len) {\n    z_size_t put = len;\n\n    /* if len is zero, avoid unnecessary operations */\n    if (len == 0)\n        return 0;\n\n    /* allocate memory if this is the first time through */\n    if (state->size == 0 && gz_init(state) == -1)\n        return 0;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return 0;\n    }\n\n    /* for small len, copy to input buffer, otherwise compress directly */\n    if (len < state->size) {\n        /* copy to input buffer, compress when full */\n        do {\n            unsigned have, copy;\n\n            if (state->strm.avail_in == 0)\n                state->strm.next_in = state->in;\n            have = (unsigned)((state->strm.next_in + state->strm.avail_in) -\n                              state->in);\n            copy = state->size - have;\n            if (copy > len)\n                copy = (unsigned)len;\n            memcpy(state->in + have, buf, copy);\n            state->strm.avail_in += copy;\n            state->x.pos += copy;\n            buf = (const char *)buf + copy;\n            len -= copy;\n            if (len && gz_comp(state, Z_NO_FLUSH) == -1)\n                return 0;\n        } while (len);\n    }\n    else {\n        /* consume whatever's left in the input buffer */\n        if (state->strm.avail_in && gz_comp(state, Z_NO_FLUSH) == -1)\n            return 0;\n\n        /* directly compress user buffer to file */\n        state->strm.next_in = (z_const Bytef *)buf;\n        do {\n            unsigned n = (unsigned)-1;\n            if (n > len)\n                n = (unsigned)len;\n            state->strm.avail_in = n;\n            state->x.pos += n;\n            if (gz_comp(state, Z_NO_FLUSH) == -1)\n                return 0;\n            len -= n;\n        } while (len);\n    }\n\n    /* input was all buffered or compressed */\n    return put;\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_write",
            "parameters": {
              "state": "gz_statep",
              "buf": "voidpc",
              "len": "z_size_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int ZEXPORT gzwrite(gzFile file, voidpc buf, unsigned len) {\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return 0;\n    state = (gz_statep)file;\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return 0;\n\n    /* since an int is returned, make sure len fits in one, otherwise return\n       with an error (this avoids a flaw in the interface) */\n    if ((int)len < 0) {\n        gz_error(state, Z_DATA_ERROR, \"requested length does not fit in int\");\n        return 0;\n    }\n\n    /* write len bytes from buf (the return value will fit in an int) */\n    return (int)gz_write(state, buf, len);\n}",
          "fn_code_pos": [
            [
              236,
              0
            ],
            [
              257,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzwrite",
            "parameters": {
              "file": "gzFile",
              "buf": "voidpc",
              "len": "unsigned"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "z_size_t ZEXPORT gzfwrite(voidpc buf, z_size_t size, z_size_t nitems,\n                          gzFile file) {\n    z_size_t len;\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return 0;\n    state = (gz_statep)file;\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return 0;\n\n    /* compute bytes to read -- error on overflow */\n    len = nitems * size;\n    if (size && len / size != nitems) {\n        gz_error(state, Z_STREAM_ERROR, \"request does not fit in a size_t\");\n        return 0;\n    }\n\n    /* write len bytes to buf, return the number of full items written */\n    return len ? gz_write(state, buf, len) / size : 0;\n}",
          "fn_code_pos": [
            [
              260,
              0
            ],
            [
              283,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfwrite",
            "parameters": {
              "buf": "voidpc",
              "size": "z_size_t",
              "nitems": "z_size_t",
              "file": "gzFile"
            },
            "return_type": "z_size_t"
          }
        },
        {
          "fn_code": "int ZEXPORT gzputc(gzFile file, int c) {\n    unsigned have;\n    unsigned char buf[1];\n    gz_statep state;\n    z_streamp strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return -1;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return -1;\n    }\n\n    /* try writing to input buffer for speed (state->size == 0 if buffer not\n       initialized) */\n    if (state->size) {\n        if (strm->avail_in == 0)\n            strm->next_in = state->in;\n        have = (unsigned)((strm->next_in + strm->avail_in) - state->in);\n        if (have < state->size) {\n            state->in[have] = (unsigned char)c;\n            strm->avail_in++;\n            state->x.pos++;\n            return c & 0xff;\n        }\n    }\n\n    /* no room in buffer or not initialized, use gz_write() */\n    buf[0] = (unsigned char)c;\n    if (gz_write(state, buf, 1) != 1)\n        return -1;\n    return c & 0xff;\n}",
          "fn_code_pos": [
            [
              286,
              0
            ],
            [
              328,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzputc",
            "parameters": {
              "file": "gzFile",
              "c": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT gzputs(gzFile file, const char *s) {\n    z_size_t len, put;\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return -1;\n\n    /* write string */\n    len = strlen(s);\n    if ((int)len < 0 || (unsigned)len != len) {\n        gz_error(state, Z_STREAM_ERROR, \"string length does not fit in int\");\n        return -1;\n    }\n    put = gz_write(state, s, len);\n    return put < len ? -1 : (int)len;\n}",
          "fn_code_pos": [
            [
              331,
              0
            ],
            [
              352,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzputs",
            "parameters": {
              "file": "gzFile",
              "s": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va) {\n    int len;\n    unsigned left;\n    char *next;\n    gz_statep state;\n    z_streamp strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return Z_STREAM_ERROR;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return state->err;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->err;\n    }\n\n    /* do the printf() into the input buffer, put length in len -- the input\n       buffer is double-sized just for this function, so there is guaranteed to\n       be state->size bytes available after the current contents */\n    if (strm->avail_in == 0)\n        strm->next_in = state->in;\n    next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);\n    next[state->size - 1] = 0;\n#ifdef NO_vsnprintf\n#  ifdef HAS_vsprintf_void\n    (void)vsprintf(next, format, va);\n    for (len = 0; len < state->size; len++)\n        if (next[len] == 0) break;\n#  else\n    len = vsprintf(next, format, va);\n#  endif\n#else\n#  ifdef HAS_vsnprintf_void\n    (void)vsnprintf(next, state->size, format, va);\n    len = strlen(next);\n#  else\n    len = vsnprintf(next, state->size, format, va);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, compress first half if past that */\n    strm->avail_in += (unsigned)len;\n    state->x.pos += len;\n    if (strm->avail_in >= state->size) {\n        left = strm->avail_in - state->size;\n        strm->avail_in = state->size;\n        if (gz_comp(state, Z_NO_FLUSH) == -1)\n            return state->err;\n        memmove(state->in, state->in + state->size, left);\n        strm->next_in = state->in;\n        strm->avail_in = left;\n    }\n    return len;\n}",
          "fn_code_pos": [
            [
              358,
              0
            ],
            [
              427,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzvprintf",
            "parameters": {
              "file": "gzFile",
              "format": "char",
              "va": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORTVA gzprintf(gzFile file, const char *format, ...) {\n    va_list va;\n    int ret;\n\n    va_start(va, format);\n    ret = gzvprintf(file, format, va);\n    va_end(va);\n    return ret;\n}",
          "fn_code_pos": [
            [
              429,
              0
            ],
            [
              437,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzprintf",
            "parameters": {
              "file": "gzFile",
              "format": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORTVA gzprintf(gzFile file, const char *format, int a1, int a2, int a3,\n                       int a4, int a5, int a6, int a7, int a8, int a9, int a10,\n                       int a11, int a12, int a13, int a14, int a15, int a16,\n                       int a17, int a18, int a19, int a20) {\n    unsigned len, left;\n    char *next;\n    gz_statep state;\n    z_streamp strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that can really pass pointer in ints */\n    if (sizeof(int) != sizeof(void *))\n        return Z_STREAM_ERROR;\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return Z_STREAM_ERROR;\n\n    /* make sure we have some buffer space */\n    if (state->size == 0 && gz_init(state) == -1)\n        return state->error;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->error;\n    }\n\n    /* do the printf() into the input buffer, put length in len -- the input\n       buffer is double-sized just for this function, so there is guaranteed to\n       be state->size bytes available after the current contents */\n    if (strm->avail_in == 0)\n        strm->next_in = state->in;\n    next = (char *)(strm->next_in + strm->avail_in);\n    next[state->size - 1] = 0;\n#ifdef NO_snprintf\n#  ifdef HAS_sprintf_void\n    sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12,\n            a13, a14, a15, a16, a17, a18, a19, a20);\n    for (len = 0; len < size; len++)\n        if (next[len] == 0)\n            break;\n#  else\n    len = sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11,\n                  a12, a13, a14, a15, a16, a17, a18, a19, a20);\n#  endif\n#else\n#  ifdef HAS_snprintf_void\n    snprintf(next, state->size, format, a1, a2, a3, a4, a5, a6, a7, a8, a9,\n             a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n    len = strlen(next);\n#  else\n    len = snprintf(next, state->size, format, a1, a2, a3, a4, a5, a6, a7, a8,\n                   a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);\n#  endif\n#endif\n\n    /* check that printf() results fit in buffer */\n    if (len == 0 || len >= state->size || next[state->size - 1] != 0)\n        return 0;\n\n    /* update buffer and position, compress first half if past that */\n    strm->avail_in += len;\n    state->x.pos += len;\n    if (strm->avail_in >= state->size) {\n        left = strm->avail_in - state->size;\n        strm->avail_in = state->size;\n        if (gz_comp(state, Z_NO_FLUSH) == -1)\n            return state->err;\n        memmove(state->in, state->in + state->size, left);\n        strm->next_in = state->in;\n        strm->avail_in = left;\n    }\n    return (int)len;\n}",
          "fn_code_pos": [
            [
              442,
              0
            ],
            [
              522,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzprintf",
            "parameters": {
              "file": "gzFile",
              "format": "char",
              "a1": "int",
              "a2": "int",
              "a3": "int",
              "a4": "int",
              "a5": "int",
              "a6": "int",
              "a7": "int",
              "a8": "int",
              "a9": "int",
              "a10": "int",
              "a11": "int",
              "a12": "int",
              "a13": "int",
              "a14": "int",
              "a15": "int",
              "a16": "int",
              "a17": "int",
              "a18": "int",
              "a19": "int",
              "a20": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT gzflush(gzFile file, int flush) {\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK)\n        return Z_STREAM_ERROR;\n\n    /* check flush parameter */\n    if (flush < 0 || flush > Z_FINISH)\n        return Z_STREAM_ERROR;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->err;\n    }\n\n    /* compress remaining data with requested flush */\n    (void)gz_comp(state, flush);\n    return state->err;\n}",
          "fn_code_pos": [
            [
              527,
              0
            ],
            [
              553,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzflush",
            "parameters": {
              "file": "gzFile",
              "flush": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT gzsetparams(gzFile file, int level, int strategy) {\n    gz_statep state;\n    z_streamp strm;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n    strm = &(state->strm);\n\n    /* check that we're writing and that there's no error */\n    if (state->mode != GZ_WRITE || state->err != Z_OK || state->direct)\n        return Z_STREAM_ERROR;\n\n    /* if no change is requested, then do nothing */\n    if (level == state->level && strategy == state->strategy)\n        return Z_OK;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            return state->err;\n    }\n\n    /* change compression parameters for subsequent input */\n    if (state->size) {\n        /* flush previous input with previous parameters before changing */\n        if (strm->avail_in && gz_comp(state, Z_BLOCK) == -1)\n            return state->err;\n        deflateParams(strm, level, strategy);\n    }\n    state->level = level;\n    state->strategy = strategy;\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              556,
              0
            ],
            [
              591,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzsetparams",
            "parameters": {
              "file": "gzFile",
              "level": "int",
              "strategy": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT gzclose_w(gzFile file) {\n    int ret = Z_OK;\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return Z_STREAM_ERROR;\n    state = (gz_statep)file;\n\n    /* check that we're writing */\n    if (state->mode != GZ_WRITE)\n        return Z_STREAM_ERROR;\n\n    /* check for seek request */\n    if (state->seek) {\n        state->seek = 0;\n        if (gz_zero(state, state->skip) == -1)\n            ret = state->err;\n    }\n\n    /* flush, free memory, and close file */\n    if (gz_comp(state, Z_FINISH) == -1)\n        ret = state->err;\n    if (state->size) {\n        if (!state->direct) {\n            (void)deflateEnd(&(state->strm));\n            free(state->out);\n        }\n        free(state->in);\n    }\n    gz_error(state, Z_OK, NULL);\n    free(state->path);\n    if (close(state->fd) == -1)\n        ret = Z_ERRNO;\n    free(state);\n    return ret;\n}",
          "fn_code_pos": [
            [
              594,
              0
            ],
            [
              630,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzclose_w",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"gzguts.h\"\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            355,
            0
          ],
          [
            356,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/gzlib.c": {
      "fn_def_list": [
        {
          "fn_code": "char ZLIB_INTERNAL *gz_strwinerror(DWORD error) {\n    static char buf[1024];\n\n    wchar_t *msgbuf;\n    DWORD lasterr = GetLastError();\n    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM\n        | FORMAT_MESSAGE_ALLOCATE_BUFFER,\n        NULL,\n        error,\n        0, /* Default language */\n        (LPVOID)&msgbuf,\n        0,\n        NULL);\n    if (chars != 0) {\n        /* If there is an \\r\\n appended, zap it.  */\n        if (chars >= 2\n            && msgbuf[chars - 2] == '\\r' && msgbuf[chars - 1] == '\\n') {\n            chars -= 2;\n            msgbuf[chars] = 0;\n        }\n\n        if (chars > sizeof (buf) - 1) {\n            chars = sizeof (buf) - 1;\n            msgbuf[chars] = 0;\n        }\n\n        wcstombs(buf, msgbuf, chars + 1);       // assumes buf is big enough\n        LocalFree(msgbuf);\n    }\n    else {\n        sprintf(buf, \"unknown win32 error (%ld)\", error);\n    }\n\n    SetLastError(lasterr);\n    return buf;\n}",
          "fn_code_pos": [
            [
              28,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "char"
          }
        },
        {
          "fn_code": "local void gz_reset(gz_statep state) {\n    state->x.have = 0;              /* no output data available */\n    if (state->mode == GZ_READ) {   /* for reading ... */\n        state->eof = 0;             /* not at end of file */\n        state->past = 0;            /* have not read past end yet */\n        state->how = LOOK;          /* look for gzip header */\n    }\n    else                            /* for writing ... */\n        state->reset = 0;           /* no deflateReset pending */\n    state->seek = 0;                /* no seek request pending */\n    gz_error(state, Z_OK, NULL);    /* clear error */\n    state->x.pos = 0;               /* no uncompressed data yet */\n    state->strm.avail_in = 0;       /* no input data yet */\n}",
          "fn_code_pos": [
            [
              68,
              0
            ],
            [
              81,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_reset",
            "parameters": {
              "state": "gz_statep"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local gzFile gz_open(const void *path, int fd, const char *mode) {\n    gz_statep state;\n    z_size_t len;\n    int oflag;\n#ifdef O_CLOEXEC\n    int cloexec = 0;\n#endif\n#ifdef O_EXCL\n    int exclusive = 0;\n#endif\n\n    /* check input */\n    if (path == NULL)\n        return NULL;\n\n    /* allocate gzFile structure to return */\n    state = (gz_statep)malloc(sizeof(gz_state));\n    if (state == NULL)\n        return NULL;\n    state->size = 0;            /* no buffers allocated yet */\n    state->want = GZBUFSIZE;    /* requested buffer size */\n    state->msg = NULL;          /* no error message yet */\n\n    /* interpret mode */\n    state->mode = GZ_NONE;\n    state->level = Z_DEFAULT_COMPRESSION;\n    state->strategy = Z_DEFAULT_STRATEGY;\n    state->direct = 0;\n    while (*mode) {\n        if (*mode >= '0' && *mode <= '9')\n            state->level = *mode - '0';\n        else\n            switch (*mode) {\n            case 'r':\n                state->mode = GZ_READ;\n                break;\n#ifndef NO_GZCOMPRESS\n            case 'w':\n                state->mode = GZ_WRITE;\n                break;\n            case 'a':\n                state->mode = GZ_APPEND;\n                break;\n#endif\n            case '+':       /* can't read and write at the same time */\n                free(state);\n                return NULL;\n            case 'b':       /* ignore -- will request binary anyway */\n                break;\n#ifdef O_CLOEXEC\n            case 'e':\n                cloexec = 1;\n                break;\n#endif\n#ifdef O_EXCL\n            case 'x':\n                exclusive = 1;\n                break;\n#endif\n            case 'f':\n                state->strategy = Z_FILTERED;\n                break;\n            case 'h':\n                state->strategy = Z_HUFFMAN_ONLY;\n                break;\n            case 'R':\n                state->strategy = Z_RLE;\n                break;\n            case 'F':\n                state->strategy = Z_FIXED;\n                break;\n            case 'T':\n                state->direct = 1;\n                break;\n            default:        /* could consider as an error, but just ignore */\n                ;\n            }\n        mode++;\n    }\n\n    /* must provide an \"r\", \"w\", or \"a\" */\n    if (state->mode == GZ_NONE) {\n        free(state);\n        return NULL;\n    }\n\n    /* can't force transparent read */\n    if (state->mode == GZ_READ) {\n        if (state->direct) {\n            free(state);\n            return NULL;\n        }\n        state->direct = 1;      /* for empty file */\n    }\n\n    /* save the path name for error messages */\n#ifdef WIDECHAR\n    if (fd == -2)\n        len = wcstombs(NULL, path, 0);\n    else\n#endif\n        len = strlen((const char *)path);\n    state->path = (char *)malloc(len + 1);\n    if (state->path == NULL) {\n        free(state);\n        return NULL;\n    }\n#ifdef WIDECHAR\n    if (fd == -2) {\n        if (len)\n            wcstombs(state->path, path, len + 1);\n        else\n            *(state->path) = 0;\n    }\n    else\n#endif\n    {\n#if !defined(NO_snprintf) && !defined(NO_vsnprintf)\n        (void)snprintf(state->path, len + 1, \"%s\", (const char *)path);\n#else\n        strcpy(state->path, path);\n#endif\n    }\n\n    /* compute the flags for open() */\n    oflag =\n#ifdef O_LARGEFILE\n        O_LARGEFILE |\n#endif\n#ifdef O_BINARY\n        O_BINARY |\n#endif\n#ifdef O_CLOEXEC\n        (cloexec ? O_CLOEXEC : 0) |\n#endif\n        (state->mode == GZ_READ ?\n         O_RDONLY :\n         (O_WRONLY | O_CREAT |\n#ifdef O_EXCL\n          (exclusive ? O_EXCL : 0) |\n#endif\n          (state->mode == GZ_WRITE ?\n           O_TRUNC :\n           O_APPEND)));\n\n    /* open the file with the appropriate flags (or just use fd) */\n    if (fd == -1)\n        state->fd = open((const char *)path, oflag, 0666);\n#ifdef WIDECHAR\n    else if (fd == -2)\n        state->fd = _wopen(path, oflag, _S_IREAD | _S_IWRITE);\n#endif\n    else\n        state->fd = fd;\n    if (state->fd == -1) {\n        free(state->path);\n        free(state);\n        return NULL;\n    }\n    if (state->mode == GZ_APPEND) {\n        LSEEK(state->fd, 0, SEEK_END);  /* so gzoffset() is correct */\n        state->mode = GZ_WRITE;         /* simplify later checks */\n    }\n\n    /* save the current position for rewinding (only if reading) */\n    if (state->mode == GZ_READ) {\n        state->start = LSEEK(state->fd, 0, SEEK_CUR);\n        if (state->start == -1) state->start = 0;\n    }\n\n    /* initialize stream */\n    gz_reset(state);\n\n    /* return stream */\n    return (gzFile)state;\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_open",
            "parameters": {
              "path": "void",
              "fd": "int",
              "mode": "char"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "gzFile ZEXPORT gzopen(const char *path, const char *mode) {\n    return gz_open(path, -1, mode);\n}",
          "fn_code_pos": [
            [
              262,
              0
            ],
            [
              264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzopen",
            "parameters": {
              "path": "char",
              "mode": "char"
            },
            "return_type": "gzFile"
          }
        },
        {
          "fn_code": "gzFile ZEXPORT gzopen64(const char *path, const char *mode) {\n    return gz_open(path, -1, mode);\n}",
          "fn_code_pos": [
            [
              267,
              0
            ],
            [
              269,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzopen64",
            "parameters": {
              "path": "char",
              "mode": "char"
            },
            "return_type": "gzFile"
          }
        },
        {
          "fn_code": "gzFile ZEXPORT gzdopen(int fd, const char *mode) {\n    char *path;         /* identifier for error messages */\n    gzFile gz;\n\n    if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)\n        return NULL;\n#if !defined(NO_snprintf) && !defined(NO_vsnprintf)\n    (void)snprintf(path, 7 + 3 * sizeof(int), \"<fd:%d>\", fd);\n#else\n    sprintf(path, \"<fd:%d>\", fd);   /* for debugging */\n#endif\n    gz = gz_open(path, fd, mode);\n    free(path);\n    return gz;\n}",
          "fn_code_pos": [
            [
              272,
              0
            ],
            [
              286,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzdopen",
            "parameters": {
              "fd": "int",
              "mode": "char"
            },
            "return_type": "gzFile"
          }
        },
        {
          "fn_code": "gzFile ZEXPORT gzopen_w(const wchar_t *path, const char *mode) {\n    return gz_open(path, -2, mode);\n}",
          "fn_code_pos": [
            [
              290,
              0
            ],
            [
              292,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzopen_w",
            "parameters": {
              "path": "wchar_t",
              "mode": "char"
            },
            "return_type": "gzFile"
          }
        },
        {
          "fn_code": "int ZEXPORT gzbuffer(gzFile file, unsigned size) {\n    gz_statep state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return -1;\n\n    /* make sure we haven't already allocated memory */\n    if (state->size != 0)\n        return -1;\n\n    /* check and set requested size */\n    if ((size << 1) < size)\n        return -1;              /* need to be able to double it */\n    if (size < 8)\n        size = 8;               /* needed to behave well with flushing */\n    state->want = size;\n    return 0;\n}",
          "fn_code_pos": [
            [
              296,
              0
            ],
            [
              317,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzbuffer",
            "parameters": {
              "file": "gzFile",
              "size": "unsigned"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT gzrewind(gzFile file) {\n    gz_statep state;\n\n    /* get internal structure */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n\n    /* check that we're reading and that there's no error */\n    if (state->mode != GZ_READ ||\n            (state->err != Z_OK && state->err != Z_BUF_ERROR))\n        return -1;\n\n    /* back up and start over */\n    if (LSEEK(state->fd, state->start, SEEK_SET) == -1)\n        return -1;\n    gz_reset(state);\n    return 0;\n}",
          "fn_code_pos": [
            [
              320,
              0
            ],
            [
              338,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzrewind",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "z_off64_t ZEXPORT gzseek64(gzFile file, z_off64_t offset, int whence) {\n    unsigned n;\n    z_off64_t ret;\n    gz_statep state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return -1;\n\n    /* check that there's no error */\n    if (state->err != Z_OK && state->err != Z_BUF_ERROR)\n        return -1;\n\n    /* can only seek from start or relative to current position */\n    if (whence != SEEK_SET && whence != SEEK_CUR)\n        return -1;\n\n    /* normalize offset to a SEEK_CUR specification */\n    if (whence == SEEK_SET)\n        offset -= state->x.pos;\n    else if (state->seek)\n        offset += state->skip;\n    state->seek = 0;\n\n    /* if within raw area while reading, just go there */\n    if (state->mode == GZ_READ && state->how == COPY &&\n            state->x.pos + offset >= 0) {\n        ret = LSEEK(state->fd, offset - (z_off64_t)state->x.have, SEEK_CUR);\n        if (ret == -1)\n            return -1;\n        state->x.have = 0;\n        state->eof = 0;\n        state->past = 0;\n        state->seek = 0;\n        gz_error(state, Z_OK, NULL);\n        state->strm.avail_in = 0;\n        state->x.pos += offset;\n        return state->x.pos;\n    }\n\n    /* calculate skip amount, rewinding if needed for back seek when reading */\n    if (offset < 0) {\n        if (state->mode != GZ_READ)         /* writing -- can't go backwards */\n            return -1;\n        offset += state->x.pos;\n        if (offset < 0)                     /* before start of file! */\n            return -1;\n        if (gzrewind(file) == -1)           /* rewind, then skip to offset */\n            return -1;\n    }\n\n    /* if reading, skip what's in output buffer (one less gzgetc() check) */\n    if (state->mode == GZ_READ) {\n        n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?\n            (unsigned)offset : state->x.have;\n        state->x.have -= n;\n        state->x.next += n;\n        state->x.pos += n;\n        offset -= n;\n    }\n\n    /* request skip (if not zero) */\n    if (offset) {\n        state->seek = 1;\n        state->skip = offset;\n    }\n    return state->x.pos + offset;\n}",
          "fn_code_pos": [
            [
              341,
              0
            ],
            [
              411,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzseek64",
            "parameters": {
              "file": "gzFile",
              "offset": "z_off64_t",
              "whence": "int"
            },
            "return_type": "z_off64_t"
          }
        },
        {
          "fn_code": "z_off_t ZEXPORT gzseek(gzFile file, z_off_t offset, int whence) {\n    z_off64_t ret;\n\n    ret = gzseek64(file, (z_off64_t)offset, whence);\n    return ret == (z_off_t)ret ? (z_off_t)ret : -1;\n}",
          "fn_code_pos": [
            [
              414,
              0
            ],
            [
              419,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzseek",
            "parameters": {
              "file": "gzFile",
              "offset": "z_off_t",
              "whence": "int"
            },
            "return_type": "z_off_t"
          }
        },
        {
          "fn_code": "z_off64_t ZEXPORT gztell64(gzFile file) {\n    gz_statep state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return -1;\n\n    /* return position */\n    return state->x.pos + (state->seek ? state->skip : 0);\n}",
          "fn_code_pos": [
            [
              422,
              0
            ],
            [
              434,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gztell64",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "z_off64_t"
          }
        },
        {
          "fn_code": "z_off_t ZEXPORT gztell(gzFile file) {\n    z_off64_t ret;\n\n    ret = gztell64(file);\n    return ret == (z_off_t)ret ? (z_off_t)ret : -1;\n}",
          "fn_code_pos": [
            [
              437,
              0
            ],
            [
              442,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gztell",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "z_off_t"
          }
        },
        {
          "fn_code": "z_off64_t ZEXPORT gzoffset64(gzFile file) {\n    z_off64_t offset;\n    gz_statep state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return -1;\n    state = (gz_statep)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return -1;\n\n    /* compute and return effective offset in file */\n    offset = LSEEK(state->fd, 0, SEEK_CUR);\n    if (offset == -1)\n        return -1;\n    if (state->mode == GZ_READ)             /* reading */\n        offset -= state->strm.avail_in;     /* don't count buffered input */\n    return offset;\n}",
          "fn_code_pos": [
            [
              445,
              0
            ],
            [
              463,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzoffset64",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "z_off64_t"
          }
        },
        {
          "fn_code": "z_off_t ZEXPORT gzoffset(gzFile file) {\n    z_off64_t ret;\n\n    ret = gzoffset64(file);\n    return ret == (z_off_t)ret ? (z_off_t)ret : -1;\n}",
          "fn_code_pos": [
            [
              466,
              0
            ],
            [
              471,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzoffset",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "z_off_t"
          }
        },
        {
          "fn_code": "int ZEXPORT gzeof(gzFile file) {\n    gz_statep state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return 0;\n    state = (gz_statep)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return 0;\n\n    /* return end-of-file state */\n    return state->mode == GZ_READ ? state->past : 0;\n}",
          "fn_code_pos": [
            [
              474,
              0
            ],
            [
              486,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzeof",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char * ZEXPORT gzerror(gzFile file, int *errnum) {\n    gz_statep state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return NULL;\n    state = (gz_statep)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return NULL;\n\n    /* return error information */\n    if (errnum != NULL)\n        *errnum = state->err;\n    return state->err == Z_MEM_ERROR ? \"out of memory\" :\n                                       (state->msg == NULL ? \"\" : state->msg);\n}",
          "fn_code_pos": [
            [
              489,
              0
            ],
            [
              504,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzerror",
            "parameters": {
              "file": "gzFile",
              "errnum": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "void ZEXPORT gzclearerr(gzFile file) {\n    gz_statep state;\n\n    /* get internal structure and check integrity */\n    if (file == NULL)\n        return;\n    state = (gz_statep)file;\n    if (state->mode != GZ_READ && state->mode != GZ_WRITE)\n        return;\n\n    /* clear error and end-of-file */\n    if (state->mode == GZ_READ) {\n        state->eof = 0;\n        state->past = 0;\n    }\n    gz_error(state, Z_OK, NULL);\n}",
          "fn_code_pos": [
            [
              507,
              0
            ],
            [
              523,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzclearerr",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void ZLIB_INTERNAL gz_error(gz_statep state, int err, const char *msg) {\n    /* free previously allocated message and clear */\n    if (state->msg != NULL) {\n        if (state->err != Z_MEM_ERROR)\n            free(state->msg);\n        state->msg = NULL;\n    }\n\n    /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */\n    if (err != Z_OK && err != Z_BUF_ERROR)\n        state->x.have = 0;\n\n    /* set error code, and if no message, then done */\n    state->err = err;\n    if (msg == NULL)\n        return;\n\n    /* for an out of memory error, return literal string when requested */\n    if (err == Z_MEM_ERROR)\n        return;\n\n    /* construct error message with path */\n    if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==\n            NULL) {\n        state->err = Z_MEM_ERROR;\n        return;\n    }\n#if !defined(NO_snprintf) && !defined(NO_vsnprintf)\n    (void)snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,\n                   \"%s%s%s\", state->path, \": \", msg);\n#else\n    strcpy(state->msg, state->path);\n    strcat(state->msg, \": \");\n    strcat(state->msg, msg);\n#endif\n}",
          "fn_code_pos": [
            [
              531,
              0
            ],
            [
              566,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL gz_error",
            "parameters": {
              "state": "gz_statep",
              "err": "int",
              "msg": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned ZLIB_INTERNAL gz_intmax(void) {\n#ifdef INT_MAX\n    return INT_MAX;\n#else\n    unsigned p = 1, q;\n    do {\n        q = p;\n        p <<= 1;\n        p++;\n    } while (p > q);\n    return q >> 1;\n#endif\n}",
          "fn_code_pos": [
            [
              572,
              0
            ],
            [
              584,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_intmax",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "gz_strwinerror(DWORD error)",
          "fn_dec_pos": [
            [
              28,
              20
            ],
            [
              28,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "error": "DWORD"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzerror(gzFile file, int *errnum)",
          "fn_dec_pos": [
            [
              489,
              21
            ],
            [
              489,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzerror",
            "parameters": {
              "file": "gzFile",
              "errnum": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"gzguts.h\"\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/crc32.c": {
      "fn_def_list": [
        {
          "fn_code": "local z_word_t byte_swap(z_word_t word) {\n#  if W == 8\n    return\n        (word & 0xff00000000000000) >> 56 |\n        (word & 0xff000000000000) >> 40 |\n        (word & 0xff0000000000) >> 24 |\n        (word & 0xff00000000) >> 8 |\n        (word & 0xff000000) << 8 |\n        (word & 0xff0000) << 24 |\n        (word & 0xff00) << 40 |\n        (word & 0xff) << 56;\n#  else   /* W == 4 */\n    return\n        (word & 0xff000000) >> 24 |\n        (word & 0xff0000) >> 8 |\n        (word & 0xff00) << 8 |\n        (word & 0xff) << 24;\n#  endif\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "byte_swap",
            "parameters": {
              "word": "z_word_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local z_crc_t multmodp(z_crc_t a, z_crc_t b) {\n    z_crc_t m, p;\n\n    m = (z_crc_t)1 << 31;\n    p = 0;\n    for (;;) {\n        if (a & m) {\n            p ^= b;\n            if ((a & (m - 1)) == 0)\n                break;\n        }\n        m >>= 1;\n        b = b & 1 ? (b >> 1) ^ POLY : b >> 1;\n    }\n    return p;\n}",
          "fn_code_pos": [
            [
              154,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "multmodp",
            "parameters": {
              "a": "z_crc_t",
              "b": "z_crc_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local z_crc_t x2nmodp(z_off64_t n, unsigned k) {\n    z_crc_t p;\n\n    p = (z_crc_t)1 << 31;           /* x^0 == 1 */\n    while (n) {\n        if (n & 1)\n            p = multmodp(x2n_table[k & 31], p);\n        n >>= 1;\n        k++;\n    }\n    return p;\n}",
          "fn_code_pos": [
            [
              175,
              0
            ],
            [
              186,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "x2nmodp",
            "parameters": {
              "n": "z_off64_t",
              "k": "unsigned"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void once(once_t *state, void (*init)(void)) {\n    if (!atomic_load(&state->done)) {\n        if (atomic_flag_test_and_set(&state->begun))\n            while (!atomic_load(&state->done))\n                ;\n        else {\n            init();\n            atomic_store(&state->done, 1);\n        }\n    }\n}",
          "fn_code_pos": [
            [
              235,
              0
            ],
            [
              245,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "once",
            "parameters": {
              "state": "once_t",
              "init": "void"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int test_and_set(int volatile *flag) {\n    int was;\n\n    was = *flag;\n    *flag = 1;\n    return was;\n}",
          "fn_code_pos": [
            [
              258,
              0
            ],
            [
              264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "test_and_set",
            "parameters": {
              "flag": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void once(once_t *state, void (*init)(void)) {\n    if (!state->done) {\n        if (test_and_set(&state->begun))\n            while (!state->done)\n                ;\n        else {\n            init();\n            state->done = 1;\n        }\n    }\n}",
          "fn_code_pos": [
            [
              267,
              0
            ],
            [
              277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "once",
            "parameters": {
              "state": "once_t",
              "init": "void"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void make_crc_table(void) {\n    unsigned i, j, n;\n    z_crc_t p;\n\n    /* initialize the CRC of bytes tables */\n    for (i = 0; i < 256; i++) {\n        p = i;\n        for (j = 0; j < 8; j++)\n            p = p & 1 ? (p >> 1) ^ POLY : p >> 1;\n        crc_table[i] = p;\n#ifdef W\n        crc_big_table[i] = byte_swap(p);\n#endif\n    }\n\n    /* initialize the x^2^n mod p(x) table */\n    p = (z_crc_t)1 << 30;         /* x^1 */\n    x2n_table[0] = p;\n    for (n = 1; n < 32; n++)\n        x2n_table[n] = p = multmodp(p, p);\n\n#ifdef W\n    /* initialize the braiding tables -- needs x2n_table[] */\n    braid(crc_braid_table, crc_braid_big_table, N, W);\n#endif\n\n#ifdef MAKECRCH\n    {\n        /*\n          The crc32.h header file contains tables for both 32-bit and 64-bit\n          z_word_t's, and so requires a 64-bit type be available. In that case,\n          z_word_t must be defined to be 64-bits. This code then also generates\n          and writes out the tables for the case that z_word_t is 32 bits.\n         */\n#if !defined(W) || W != 8\n#  error Need a 64-bit integer type in order to generate crc32.h.\n#endif\n        FILE *out;\n        int k, n;\n        z_crc_t ltl[8][256];\n        z_word_t big[8][256];\n\n        out = fopen(\"crc32.h\", \"w\");\n        if (out == NULL) return;\n\n        /* write out little-endian CRC table to crc32.h */\n        fprintf(out,\n            \"/* crc32.h -- tables for rapid CRC calculation\\n\"\n            \" * Generated automatically by crc32.c\\n */\\n\"\n            \"\\n\"\n            \"local const z_crc_t FAR crc_table[] = {\\n\"\n            \"    \");\n        write_table(out, crc_table, 256);\n        fprintf(out,\n            \"};\\n\");\n\n        /* write out big-endian CRC table for 64-bit z_word_t to crc32.h */\n        fprintf(out,\n            \"\\n\"\n            \"#ifdef W\\n\"\n            \"\\n\"\n            \"#if W == 8\\n\"\n            \"\\n\"\n            \"local const z_word_t FAR crc_big_table[] = {\\n\"\n            \"    \");\n        write_table64(out, crc_big_table, 256);\n        fprintf(out,\n            \"};\\n\");\n\n        /* write out big-endian CRC table for 32-bit z_word_t to crc32.h */\n        fprintf(out,\n            \"\\n\"\n            \"#else /* W == 4 */\\n\"\n            \"\\n\"\n            \"local const z_word_t FAR crc_big_table[] = {\\n\"\n            \"    \");\n        write_table32hi(out, crc_big_table, 256);\n        fprintf(out,\n            \"};\\n\"\n            \"\\n\"\n            \"#endif\\n\");\n\n        /* write out braid tables for each value of N */\n        for (n = 1; n <= 6; n++) {\n            fprintf(out,\n            \"\\n\"\n            \"#if N == %d\\n\", n);\n\n            /* compute braid tables for this N and 64-bit word_t */\n            braid(ltl, big, n, 8);\n\n            /* write out braid tables for 64-bit z_word_t to crc32.h */\n            fprintf(out,\n            \"\\n\"\n            \"#if W == 8\\n\"\n            \"\\n\"\n            \"local const z_crc_t FAR crc_braid_table[][256] = {\\n\");\n            for (k = 0; k < 8; k++) {\n                fprintf(out, \"   {\");\n                write_table(out, ltl[k], 256);\n                fprintf(out, \"}%s\", k < 7 ? \",\\n\" : \"\");\n            }\n            fprintf(out,\n            \"};\\n\"\n            \"\\n\"\n            \"local const z_word_t FAR crc_braid_big_table[][256] = {\\n\");\n            for (k = 0; k < 8; k++) {\n                fprintf(out, \"   {\");\n                write_table64(out, big[k], 256);\n                fprintf(out, \"}%s\", k < 7 ? \",\\n\" : \"\");\n            }\n            fprintf(out,\n            \"};\\n\");\n\n            /* compute braid tables for this N and 32-bit word_t */\n            braid(ltl, big, n, 4);\n\n            /* write out braid tables for 32-bit z_word_t to crc32.h */\n            fprintf(out,\n            \"\\n\"\n            \"#else /* W == 4 */\\n\"\n            \"\\n\"\n            \"local const z_crc_t FAR crc_braid_table[][256] = {\\n\");\n            for (k = 0; k < 4; k++) {\n                fprintf(out, \"   {\");\n                write_table(out, ltl[k], 256);\n                fprintf(out, \"}%s\", k < 3 ? \",\\n\" : \"\");\n            }\n            fprintf(out,\n            \"};\\n\"\n            \"\\n\"\n            \"local const z_word_t FAR crc_braid_big_table[][256] = {\\n\");\n            for (k = 0; k < 4; k++) {\n                fprintf(out, \"   {\");\n                write_table32hi(out, big[k], 256);\n                fprintf(out, \"}%s\", k < 3 ? \",\\n\" : \"\");\n            }\n            fprintf(out,\n            \"};\\n\"\n            \"\\n\"\n            \"#endif\\n\"\n            \"\\n\"\n            \"#endif\\n\");\n        }\n        fprintf(out,\n            \"\\n\"\n            \"#endif\\n\");\n\n        /* write out zeros operator table to crc32.h */\n        fprintf(out,\n            \"\\n\"\n            \"local const z_crc_t FAR x2n_table[] = {\\n\"\n            \"    \");\n        write_table(out, x2n_table, 32);\n        fprintf(out,\n            \"};\\n\");\n        fclose(out);\n    }\n#endif /* MAKECRCH */\n}",
          "fn_code_pos": [
            [
              309,
              0
            ],
            [
              468,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "make_crc_table",
            "parameters": {},
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void write_table(FILE *out, const z_crc_t FAR *table, int k) {\n    int n;\n\n    for (n = 0; n < k; n++)\n        fprintf(out, \"%s0x%08lx%s\", n == 0 || n % 5 ? \"\" : \"    \",\n                (unsigned long)(table[n]),\n                n == k - 1 ? \"\" : (n % 5 == 4 ? \",\\n\" : \", \"));\n}",
          "fn_code_pos": [
            [
              476,
              0
            ],
            [
              483,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "write_table",
            "parameters": {
              "out": "FILE",
              "FAR": "z_crc_t",
              "k": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void write_table32hi(FILE *out, const z_word_t FAR *table, int k) {\n    int n;\n\n    for (n = 0; n < k; n++)\n        fprintf(out, \"%s0x%08lx%s\", n == 0 || n % 5 ? \"\" : \"    \",\n                (unsigned long)(table[n] >> 32),\n                n == k - 1 ? \"\" : (n % 5 == 4 ? \",\\n\" : \", \"));\n}",
          "fn_code_pos": [
            [
              489,
              0
            ],
            [
              496,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "write_table32hi",
            "parameters": {
              "out": "FILE",
              "FAR": "z_word_t",
              "k": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void write_table64(FILE *out, const z_word_t FAR *table, int k) {\n    int n;\n\n    for (n = 0; n < k; n++)\n        fprintf(out, \"%s0x%016llx%s\", n == 0 || n % 3 ? \"\" : \"    \",\n                (unsigned long long)(table[n]),\n                n == k - 1 ? \"\" : (n % 3 == 2 ? \",\\n\" : \", \"));\n}",
          "fn_code_pos": [
            [
              505,
              0
            ],
            [
              512,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "write_table64",
            "parameters": {
              "out": "FILE",
              "FAR": "z_word_t",
              "k": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int main(void) {\n    make_crc_table();\n    return 0;\n}",
          "fn_code_pos": [
            [
              515,
              0
            ],
            [
              518,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "local void braid(z_crc_t ltl[][256], z_word_t big[][256], int n, int w) {\n    int k;\n    z_crc_t i, p, q;\n    for (k = 0; k < w; k++) {\n        p = x2nmodp((n * w + 3 - k) << 3, 0);\n        ltl[k][0] = 0;\n        big[w - 1 - k][0] = 0;\n        for (i = 1; i < 256; i++) {\n            ltl[k][i] = q = multmodp(i << 24, p);\n            big[w - 1 - k][i] = byte_swap(q);\n        }\n    }\n}",
          "fn_code_pos": [
            [
              527,
              0
            ],
            [
              539,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "braid",
            "parameters": {
              "ltl": "z_crc_t",
              "big": "z_word_t",
              "n": "int",
              "w": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "const z_crc_t FAR * ZEXPORT get_crc_table(void) {\n#ifdef DYNAMIC_CRC_TABLE\n    once(&made, make_crc_table);\n#endif /* DYNAMIC_CRC_TABLE */\n    return (const z_crc_t FAR *)crc_table;\n}",
          "fn_code_pos": [
            [
              548,
              0
            ],
            [
              553,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_crc_table",
            "parameters": {},
            "return_type": "z_crc_t"
          }
        },
        {
          "fn_code": "unsigned long ZEXPORT crc32_z(unsigned long crc, const unsigned char FAR *buf,\n                              z_size_t len) {\n    z_crc_t val;\n    z_word_t crc1, crc2;\n    const z_word_t *word;\n    z_word_t val0, val1, val2;\n    z_size_t last, last2, i;\n    z_size_t num;\n\n    /* Return initial CRC, if requested. */\n    if (buf == Z_NULL) return 0;\n\n#ifdef DYNAMIC_CRC_TABLE\n    once(&made, make_crc_table);\n#endif /* DYNAMIC_CRC_TABLE */\n\n    /* Pre-condition the CRC */\n    crc = (~crc) & 0xffffffff;\n\n    /* Compute the CRC up to a word boundary. */\n    while (len && ((z_size_t)buf & 7) != 0) {\n        len--;\n        val = *buf++;\n        __asm__ volatile(\"crc32b %w0, %w0, %w1\" : \"+r\"(crc) : \"r\"(val));\n    }\n\n    /* Prepare to compute the CRC on full 64-bit words word[0..num-1]. */\n    word = (z_word_t const *)buf;\n    num = len >> 3;\n    len &= 7;\n\n    /* Do three interleaved CRCs to realize the throughput of one crc32x\n       instruction per cycle. Each CRC is calculated on Z_BATCH words. The\n       three CRCs are combined into a single CRC after each set of batches. */\n    while (num >= 3 * Z_BATCH) {\n        crc1 = 0;\n        crc2 = 0;\n        for (i = 0; i < Z_BATCH; i++) {\n            val0 = word[i];\n            val1 = word[i + Z_BATCH];\n            val2 = word[i + 2 * Z_BATCH];\n            __asm__ volatile(\"crc32x %w0, %w0, %x1\" : \"+r\"(crc) : \"r\"(val0));\n            __asm__ volatile(\"crc32x %w0, %w0, %x1\" : \"+r\"(crc1) : \"r\"(val1));\n            __asm__ volatile(\"crc32x %w0, %w0, %x1\" : \"+r\"(crc2) : \"r\"(val2));\n        }\n        word += 3 * Z_BATCH;\n        num -= 3 * Z_BATCH;\n        crc = multmodp(Z_BATCH_ZEROS, crc) ^ crc1;\n        crc = multmodp(Z_BATCH_ZEROS, crc) ^ crc2;\n    }\n\n    /* Do one last smaller batch with the remaining words, if there are enough\n       to pay for the combination of CRCs. */\n    last = num / 3;\n    if (last >= Z_BATCH_MIN) {\n        last2 = last << 1;\n        crc1 = 0;\n        crc2 = 0;\n        for (i = 0; i < last; i++) {\n            val0 = word[i];\n            val1 = word[i + last];\n            val2 = word[i + last2];\n            __asm__ volatile(\"crc32x %w0, %w0, %x1\" : \"+r\"(crc) : \"r\"(val0));\n            __asm__ volatile(\"crc32x %w0, %w0, %x1\" : \"+r\"(crc1) : \"r\"(val1));\n            __asm__ volatile(\"crc32x %w0, %w0, %x1\" : \"+r\"(crc2) : \"r\"(val2));\n        }\n        word += 3 * last;\n        num -= 3 * last;\n        val = x2nmodp(last, 6);\n        crc = multmodp(val, crc) ^ crc1;\n        crc = multmodp(val, crc) ^ crc2;\n    }\n\n    /* Compute the CRC on any remaining words. */\n    for (i = 0; i < num; i++) {\n        val0 = word[i];\n        __asm__ volatile(\"crc32x %w0, %w0, %x1\" : \"+r\"(crc) : \"r\"(val0));\n    }\n    word += num;\n\n    /* Complete the CRC on any remaining bytes. */\n    buf = (const unsigned char FAR *)word;\n    while (len) {\n        len--;\n        val = *buf++;\n        __asm__ volatile(\"crc32b %w0, %w0, %w1\" : \"+r\"(crc) : \"r\"(val));\n    }\n\n    /* Return the CRC, post-conditioned. */\n    return crc ^ 0xffffffff;\n}",
          "fn_code_pos": [
            [
              574,
              0
            ],
            [
              664,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_z",
            "parameters": {
              "crc": "unsigned long",
              "FAR": "unsigned char",
              "len": "z_size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "local z_crc_t crc_word(z_word_t data) {\n    int k;\n    for (k = 0; k < W; k++)\n        data = (data >> 8) ^ crc_table[data & 0xff];\n    return (z_crc_t)data;\n}",
          "fn_code_pos": [
            [
              675,
              0
            ],
            [
              680,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc_word",
            "parameters": {
              "data": "z_word_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local z_word_t crc_word_big(z_word_t data) {\n    int k;\n    for (k = 0; k < W; k++)\n        data = (data << 8) ^\n            crc_big_table[(data >> ((W - 1) << 3)) & 0xff];\n    return data;\n}",
          "fn_code_pos": [
            [
              682,
              0
            ],
            [
              688,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc_word_big",
            "parameters": {
              "data": "z_word_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "unsigned long ZEXPORT crc32_z(unsigned long crc, const unsigned char FAR *buf,\n                              z_size_t len) {\n    /* Return initial CRC, if requested. */\n    if (buf == Z_NULL) return 0;\n\n#ifdef DYNAMIC_CRC_TABLE\n    once(&made, make_crc_table);\n#endif /* DYNAMIC_CRC_TABLE */\n\n    /* Pre-condition the CRC */\n    crc = (~crc) & 0xffffffff;\n\n#ifdef W\n\n    /* If provided enough bytes, do a braided CRC calculation. */\n    if (len >= N * W + W - 1) {\n        z_size_t blks;\n        z_word_t const *words;\n        unsigned endian;\n        int k;\n\n        /* Compute the CRC up to a z_word_t boundary. */\n        while (len && ((z_size_t)buf & (W - 1)) != 0) {\n            len--;\n            crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n        }\n\n        /* Compute the CRC on as many N z_word_t blocks as are available. */\n        blks = len / (N * W);\n        len -= blks * N * W;\n        words = (z_word_t const *)buf;\n\n        /* Do endian check at execution time instead of compile time, since ARM\n           processors can change the endianness at execution time. If the\n           compiler knows what the endianness will be, it can optimize out the\n           check and the unused branch. */\n        endian = 1;\n        if (*(unsigned char *)&endian) {\n            /* Little endian. */\n\n            z_crc_t crc0;\n            z_word_t word0;\n#if N > 1\n            z_crc_t crc1;\n            z_word_t word1;\n#if N > 2\n            z_crc_t crc2;\n            z_word_t word2;\n#if N > 3\n            z_crc_t crc3;\n            z_word_t word3;\n#if N > 4\n            z_crc_t crc4;\n            z_word_t word4;\n#if N > 5\n            z_crc_t crc5;\n            z_word_t word5;\n#endif\n#endif\n#endif\n#endif\n#endif\n\n            /* Initialize the CRC for each braid. */\n            crc0 = crc;\n#if N > 1\n            crc1 = 0;\n#if N > 2\n            crc2 = 0;\n#if N > 3\n            crc3 = 0;\n#if N > 4\n            crc4 = 0;\n#if N > 5\n            crc5 = 0;\n#endif\n#endif\n#endif\n#endif\n#endif\n\n            /*\n              Process the first blks-1 blocks, computing the CRCs on each braid\n              independently.\n             */\n            while (--blks) {\n                /* Load the word for each braid into registers. */\n                word0 = crc0 ^ words[0];\n#if N > 1\n                word1 = crc1 ^ words[1];\n#if N > 2\n                word2 = crc2 ^ words[2];\n#if N > 3\n                word3 = crc3 ^ words[3];\n#if N > 4\n                word4 = crc4 ^ words[4];\n#if N > 5\n                word5 = crc5 ^ words[5];\n#endif\n#endif\n#endif\n#endif\n#endif\n                words += N;\n\n                /* Compute and update the CRC for each word. The loop should\n                   get unrolled. */\n                crc0 = crc_braid_table[0][word0 & 0xff];\n#if N > 1\n                crc1 = crc_braid_table[0][word1 & 0xff];\n#if N > 2\n                crc2 = crc_braid_table[0][word2 & 0xff];\n#if N > 3\n                crc3 = crc_braid_table[0][word3 & 0xff];\n#if N > 4\n                crc4 = crc_braid_table[0][word4 & 0xff];\n#if N > 5\n                crc5 = crc_braid_table[0][word5 & 0xff];\n#endif\n#endif\n#endif\n#endif\n#endif\n                for (k = 1; k < W; k++) {\n                    crc0 ^= crc_braid_table[k][(word0 >> (k << 3)) & 0xff];\n#if N > 1\n                    crc1 ^= crc_braid_table[k][(word1 >> (k << 3)) & 0xff];\n#if N > 2\n                    crc2 ^= crc_braid_table[k][(word2 >> (k << 3)) & 0xff];\n#if N > 3\n                    crc3 ^= crc_braid_table[k][(word3 >> (k << 3)) & 0xff];\n#if N > 4\n                    crc4 ^= crc_braid_table[k][(word4 >> (k << 3)) & 0xff];\n#if N > 5\n                    crc5 ^= crc_braid_table[k][(word5 >> (k << 3)) & 0xff];\n#endif\n#endif\n#endif\n#endif\n#endif\n                }\n            }\n\n            /*\n              Process the last block, combining the CRCs of the N braids at the\n              same time.\n             */\n            crc = crc_word(crc0 ^ words[0]);\n#if N > 1\n            crc = crc_word(crc1 ^ words[1] ^ crc);\n#if N > 2\n            crc = crc_word(crc2 ^ words[2] ^ crc);\n#if N > 3\n            crc = crc_word(crc3 ^ words[3] ^ crc);\n#if N > 4\n            crc = crc_word(crc4 ^ words[4] ^ crc);\n#if N > 5\n            crc = crc_word(crc5 ^ words[5] ^ crc);\n#endif\n#endif\n#endif\n#endif\n#endif\n            words += N;\n        }\n        else {\n            /* Big endian. */\n\n            z_word_t crc0, word0, comb;\n#if N > 1\n            z_word_t crc1, word1;\n#if N > 2\n            z_word_t crc2, word2;\n#if N > 3\n            z_word_t crc3, word3;\n#if N > 4\n            z_word_t crc4, word4;\n#if N > 5\n            z_word_t crc5, word5;\n#endif\n#endif\n#endif\n#endif\n#endif\n\n            /* Initialize the CRC for each braid. */\n            crc0 = byte_swap(crc);\n#if N > 1\n            crc1 = 0;\n#if N > 2\n            crc2 = 0;\n#if N > 3\n            crc3 = 0;\n#if N > 4\n            crc4 = 0;\n#if N > 5\n            crc5 = 0;\n#endif\n#endif\n#endif\n#endif\n#endif\n\n            /*\n              Process the first blks-1 blocks, computing the CRCs on each braid\n              independently.\n             */\n            while (--blks) {\n                /* Load the word for each braid into registers. */\n                word0 = crc0 ^ words[0];\n#if N > 1\n                word1 = crc1 ^ words[1];\n#if N > 2\n                word2 = crc2 ^ words[2];\n#if N > 3\n                word3 = crc3 ^ words[3];\n#if N > 4\n                word4 = crc4 ^ words[4];\n#if N > 5\n                word5 = crc5 ^ words[5];\n#endif\n#endif\n#endif\n#endif\n#endif\n                words += N;\n\n                /* Compute and update the CRC for each word. The loop should\n                   get unrolled. */\n                crc0 = crc_braid_big_table[0][word0 & 0xff];\n#if N > 1\n                crc1 = crc_braid_big_table[0][word1 & 0xff];\n#if N > 2\n                crc2 = crc_braid_big_table[0][word2 & 0xff];\n#if N > 3\n                crc3 = crc_braid_big_table[0][word3 & 0xff];\n#if N > 4\n                crc4 = crc_braid_big_table[0][word4 & 0xff];\n#if N > 5\n                crc5 = crc_braid_big_table[0][word5 & 0xff];\n#endif\n#endif\n#endif\n#endif\n#endif\n                for (k = 1; k < W; k++) {\n                    crc0 ^= crc_braid_big_table[k][(word0 >> (k << 3)) & 0xff];\n#if N > 1\n                    crc1 ^= crc_braid_big_table[k][(word1 >> (k << 3)) & 0xff];\n#if N > 2\n                    crc2 ^= crc_braid_big_table[k][(word2 >> (k << 3)) & 0xff];\n#if N > 3\n                    crc3 ^= crc_braid_big_table[k][(word3 >> (k << 3)) & 0xff];\n#if N > 4\n                    crc4 ^= crc_braid_big_table[k][(word4 >> (k << 3)) & 0xff];\n#if N > 5\n                    crc5 ^= crc_braid_big_table[k][(word5 >> (k << 3)) & 0xff];\n#endif\n#endif\n#endif\n#endif\n#endif\n                }\n            }\n\n            /*\n              Process the last block, combining the CRCs of the N braids at the\n              same time.\n             */\n            comb = crc_word_big(crc0 ^ words[0]);\n#if N > 1\n            comb = crc_word_big(crc1 ^ words[1] ^ comb);\n#if N > 2\n            comb = crc_word_big(crc2 ^ words[2] ^ comb);\n#if N > 3\n            comb = crc_word_big(crc3 ^ words[3] ^ comb);\n#if N > 4\n            comb = crc_word_big(crc4 ^ words[4] ^ comb);\n#if N > 5\n            comb = crc_word_big(crc5 ^ words[5] ^ comb);\n#endif\n#endif\n#endif\n#endif\n#endif\n            words += N;\n            crc = byte_swap(comb);\n        }\n\n        /*\n          Update the pointer to the remaining bytes to process.\n         */\n        buf = (unsigned char const *)words;\n    }\n\n#endif /* W */\n\n    /* Complete the computation of the CRC on any remaining bytes. */\n    while (len >= 8) {\n        len -= 8;\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n    }\n    while (len) {\n        len--;\n        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];\n    }\n\n    /* Return the CRC, post-conditioned. */\n    return crc ^ 0xffffffff;\n}",
          "fn_code_pos": [
            [
              693,
              0
            ],
            [
              1009,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_z",
            "parameters": {
              "crc": "unsigned long",
              "FAR": "unsigned char",
              "len": "z_size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned long ZEXPORT crc32(unsigned long crc, const unsigned char FAR *buf,\n                            uInt len) {\n    return crc32_z(crc, buf, len);\n}",
          "fn_code_pos": [
            [
              1014,
              0
            ],
            [
              1017,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32",
            "parameters": {
              "crc": "unsigned long",
              "FAR": "unsigned char",
              "len": "uInt"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "uLong ZEXPORT crc32_combine64(uLong crc1, uLong crc2, z_off64_t len2) {\n#ifdef DYNAMIC_CRC_TABLE\n    once(&made, make_crc_table);\n#endif /* DYNAMIC_CRC_TABLE */\n    return multmodp(x2nmodp(len2, 3), crc1) ^ (crc2 & 0xffffffff);\n}",
          "fn_code_pos": [
            [
              1020,
              0
            ],
            [
              1025,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_combine64",
            "parameters": {
              "crc1": "uLong",
              "crc2": "uLong",
              "len2": "z_off64_t"
            },
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "uLong ZEXPORT crc32_combine(uLong crc1, uLong crc2, z_off_t len2) {\n    return crc32_combine64(crc1, crc2, (z_off64_t)len2);\n}",
          "fn_code_pos": [
            [
              1028,
              0
            ],
            [
              1030,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_combine",
            "parameters": {
              "crc1": "uLong",
              "crc2": "uLong",
              "len2": "z_off_t"
            },
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "uLong ZEXPORT crc32_combine_gen64(z_off64_t len2) {\n#ifdef DYNAMIC_CRC_TABLE\n    once(&made, make_crc_table);\n#endif /* DYNAMIC_CRC_TABLE */\n    return x2nmodp(len2, 3);\n}",
          "fn_code_pos": [
            [
              1033,
              0
            ],
            [
              1038,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_combine_gen64",
            "parameters": {
              "len2": "z_off64_t"
            },
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "uLong ZEXPORT crc32_combine_gen(z_off_t len2) {\n    return crc32_combine_gen64((z_off64_t)len2);\n}",
          "fn_code_pos": [
            [
              1041,
              0
            ],
            [
              1043,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_combine_gen",
            "parameters": {
              "len2": "z_off_t"
            },
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "uLong ZEXPORT crc32_combine_op(uLong crc1, uLong crc2, uLong op) {\n    return multmodp(op, crc1) ^ (crc2 & 0xffffffff);\n}",
          "fn_code_pos": [
            [
              1046,
              0
            ],
            [
              1048,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_combine_op",
            "parameters": {
              "crc1": "uLong",
              "crc2": "uLong",
              "op": "uLong"
            },
            "return_type": "uLong"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "braid(z_crc_t [][256], z_word_t [][256], int, int)",
          "fn_dec_pos": [
            [
              198,
              14
            ],
            [
              198,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "braid",
            "parameters": {},
            "return_type": "local"
          }
        },
        {
          "fn_code": "write_table(FILE *, const z_crc_t FAR *, int)",
          "fn_dec_pos": [
            [
              201,
              14
            ],
            [
              201,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "write_table",
            "parameters": {
              "FAR": "z_crc_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "write_table32hi(FILE *, const z_word_t FAR *, int)",
          "fn_dec_pos": [
            [
              202,
              14
            ],
            [
              202,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "write_table32hi",
            "parameters": {
              "FAR": "z_word_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "write_table64(FILE *, const z_word_t FAR *, int)",
          "fn_dec_pos": [
            [
              203,
              14
            ],
            [
              203,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "write_table64",
            "parameters": {
              "FAR": "z_word_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "(*init)(void)",
          "fn_dec_pos": [
            [
              235,
              36
            ],
            [
              235,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*init)(void)",
          "fn_dec_pos": [
            [
              267,
              36
            ],
            [
              267,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "get_crc_table(void)",
          "fn_dec_pos": [
            [
              548,
              28
            ],
            [
              548,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_crc_table",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct once_s {\n    atomic_flag begun;\n    atomic_int done;\n}",
          {
            "begun": "atomic_flag",
            "done": "atomic_int"
          },
          "once_s",
          [
            224,
            0
          ],
          [
            227,
            1
          ]
        ],
        [
          "struct once_s {\n    volatile int begun;\n    volatile int done;\n}",
          {
            "int": "volatile"
          },
          "once_s",
          [
            250,
            0
          ],
          [
            253,
            1
          ]
        ],
        [
          "typedef struct once_s once_t;",
          {},
          "once_t",
          [
            215,
            0
          ],
          [
            215,
            29
          ]
        ],
        [
          "struct once_s {\n    atomic_flag begun;\n    atomic_int done;\n}",
          {
            "begun": "atomic_flag",
            "done": "atomic_int"
          },
          "once_s",
          [
            224,
            0
          ],
          [
            227,
            1
          ]
        ],
        [
          "struct once_s {\n    volatile int begun;\n    volatile int done;\n}",
          {
            "int": "volatile"
          },
          "once_s",
          [
            250,
            0
          ],
          [
            253,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#  include <stdio.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"zutil.h\"      /* for Z_U4, Z_U8, z_crc_t, and FAR definitions */\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include \"crc32.h\"\n",
          [
            144,
            0
          ],
          [
            145,
            0
          ]
        ],
        [
          "#include <stdatomic.h>\n",
          [
            221,
            0
          ],
          [
            222,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/adler32.c": {
      "fn_def_list": [
        {
          "fn_code": "uLong ZEXPORT adler32_z(uLong adler, const Bytef *buf, z_size_t len) {\n    unsigned long sum2;\n    unsigned n;\n\n    /* split Adler-32 into component sums */\n    sum2 = (adler >> 16) & 0xffff;\n    adler &= 0xffff;\n\n    /* in case user likes doing a byte at a time, keep it fast */\n    if (len == 1) {\n        adler += buf[0];\n        if (adler >= BASE)\n            adler -= BASE;\n        sum2 += adler;\n        if (sum2 >= BASE)\n            sum2 -= BASE;\n        return adler | (sum2 << 16);\n    }\n\n    /* initial Adler-32 value (deferred check for len == 1 speed) */\n    if (buf == Z_NULL)\n        return 1L;\n\n    /* in case short lengths are provided, keep it somewhat fast */\n    if (len < 16) {\n        while (len--) {\n            adler += *buf++;\n            sum2 += adler;\n        }\n        if (adler >= BASE)\n            adler -= BASE;\n        MOD28(sum2);            /* only added so many BASE's */\n        return adler | (sum2 << 16);\n    }\n\n    /* do length NMAX blocks -- requires just one modulo operation */\n    while (len >= NMAX) {\n        len -= NMAX;\n        n = NMAX / 16;          /* NMAX is divisible by 16 */\n        do {\n            DO16(buf);          /* 16 sums unrolled */\n            buf += 16;\n        } while (--n);\n        MOD(adler);\n        MOD(sum2);\n    }\n\n    /* do remaining bytes (less than NMAX, still just one modulo) */\n    if (len) {                  /* avoid modulos if none remaining */\n        while (len >= 16) {\n            len -= 16;\n            DO16(buf);\n            buf += 16;\n        }\n        while (len--) {\n            adler += *buf++;\n            sum2 += adler;\n        }\n        MOD(adler);\n        MOD(sum2);\n    }\n\n    /* return recombined sums */\n    return adler | (sum2 << 16);\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "adler32_z",
            "parameters": {
              "adler": "uLong",
              "buf": "Bytef",
              "len": "z_size_t"
            },
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "uLong ZEXPORT adler32(uLong adler, const Bytef *buf, uInt len) {\n    return adler32_z(adler, buf, len);\n}",
          "fn_code_pos": [
            [
              127,
              0
            ],
            [
              129,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "adler32",
            "parameters": {
              "adler": "uLong",
              "buf": "Bytef",
              "len": "uInt"
            },
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "local uLong adler32_combine_(uLong adler1, uLong adler2, z_off64_t len2) {\n    unsigned long sum1;\n    unsigned long sum2;\n    unsigned rem;\n\n    /* for negative len, return invalid adler32 as a clue for debugging */\n    if (len2 < 0)\n        return 0xffffffffUL;\n\n    /* the derivation of this formula is left as an exercise for the reader */\n    MOD63(len2);                /* assumes len2 >= 0 */\n    rem = (unsigned)len2;\n    sum1 = adler1 & 0xffff;\n    sum2 = rem * sum1;\n    MOD(sum2);\n    sum1 += (adler2 & 0xffff) + BASE - 1;\n    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;\n    if (sum1 >= BASE) sum1 -= BASE;\n    if (sum1 >= BASE) sum1 -= BASE;\n    if (sum2 >= ((unsigned long)BASE << 1)) sum2 -= ((unsigned long)BASE << 1);\n    if (sum2 >= BASE) sum2 -= BASE;\n    return sum1 | (sum2 << 16);\n}",
          "fn_code_pos": [
            [
              132,
              0
            ],
            [
              154,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "adler32_combine_",
            "parameters": {
              "adler1": "uLong",
              "adler2": "uLong",
              "len2": "z_off64_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "uLong ZEXPORT adler32_combine(uLong adler1, uLong adler2, z_off_t len2) {\n    return adler32_combine_(adler1, adler2, len2);\n}",
          "fn_code_pos": [
            [
              157,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "adler32_combine",
            "parameters": {
              "adler1": "uLong",
              "adler2": "uLong",
              "len2": "z_off_t"
            },
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "uLong ZEXPORT adler32_combine64(uLong adler1, uLong adler2, z_off64_t len2) {\n    return adler32_combine_(adler1, adler2, len2);\n}",
          "fn_code_pos": [
            [
              161,
              0
            ],
            [
              163,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "adler32_combine64",
            "parameters": {
              "adler1": "uLong",
              "adler2": "uLong",
              "len2": "z_off64_t"
            },
            "return_type": "uLong"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"zutil.h\"\n",
          [
            7,
            0
          ],
          [
            8,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/inftrees.c": {
      "fn_def_list": [
        {
          "fn_code": "int ZLIB_INTERNAL inflate_table(codetype type, unsigned short FAR *lens,\n                                unsigned codes, code FAR * FAR *table,\n                                unsigned FAR *bits, unsigned short FAR *work) {\n    unsigned len;               /* a code's length in bits */\n    unsigned sym;               /* index of code symbols */\n    unsigned min, max;          /* minimum and maximum code lengths */\n    unsigned root;              /* number of index bits for root table */\n    unsigned curr;              /* number of index bits for current table */\n    unsigned drop;              /* code bits to drop for sub-table */\n    int left;                   /* number of prefix codes available */\n    unsigned used;              /* code entries in table used */\n    unsigned huff;              /* Huffman code */\n    unsigned incr;              /* for incrementing code, index */\n    unsigned fill;              /* index for replicating entries */\n    unsigned low;               /* low bits for current root entry */\n    unsigned mask;              /* mask for low root bits */\n    code here;                  /* table entry for duplication */\n    code FAR *next;             /* next available space in table */\n    const unsigned short FAR *base;     /* base value table to use */\n    const unsigned short FAR *extra;    /* extra bits table to use */\n    unsigned match;             /* use base and extra for symbol >= match */\n    unsigned short count[MAXBITS+1];    /* number of codes of each length */\n    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */\n    static const unsigned short lbase[31] = { /* Length codes 257..285 base */\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};\n    static const unsigned short lext[31] = { /* Length codes 257..285 extra */\n        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 73, 200};\n    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577, 0, 0};\n    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */\n        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n        28, 28, 29, 29, 64, 64};\n\n    /*\n       Process a set of code lengths to create a canonical Huffman code.  The\n       code lengths are lens[0..codes-1].  Each length corresponds to the\n       symbols 0..codes-1.  The Huffman code is generated by first sorting the\n       symbols by length from short to long, and retaining the symbol order\n       for codes with equal lengths.  Then the code starts with all zero bits\n       for the first code of the shortest length, and the codes are integer\n       increments for the same length, and zeros are appended as the length\n       increases.  For the deflate format, these bits are stored backwards\n       from their more natural integer increment ordering, and so when the\n       decoding tables are built in the large loop below, the integer codes\n       are incremented backwards.\n\n       This routine assumes, but does not check, that all of the entries in\n       lens[] are in the range 0..MAXBITS.  The caller must assure this.\n       1..MAXBITS is interpreted as that code length.  zero means that that\n       symbol does not occur in this code.\n\n       The codes are sorted by computing a count of codes for each length,\n       creating from that a table of starting indices for each length in the\n       sorted table, and then entering the symbols in order in the sorted\n       table.  The sorted table is work[], with that space being provided by\n       the caller.\n\n       The length counts are used for other purposes as well, i.e. finding\n       the minimum and maximum length codes, determining if there are any\n       codes at all, checking for a valid set of lengths, and looking ahead\n       at length counts to determine sub-table sizes when building the\n       decoding tables.\n     */\n\n    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n    for (len = 0; len <= MAXBITS; len++)\n        count[len] = 0;\n    for (sym = 0; sym < codes; sym++)\n        count[lens[sym]]++;\n\n    /* bound code lengths, force root to be within code lengths */\n    root = *bits;\n    for (max = MAXBITS; max >= 1; max--)\n        if (count[max] != 0) break;\n    if (root > max) root = max;\n    if (max == 0) {                     /* no symbols to code at all */\n        here.op = (unsigned char)64;    /* invalid code marker */\n        here.bits = (unsigned char)1;\n        here.val = (unsigned short)0;\n        *(*table)++ = here;             /* make a table to force an error */\n        *(*table)++ = here;\n        *bits = 1;\n        return 0;     /* no symbols, but wait for decoding to report error */\n    }\n    for (min = 1; min < max; min++)\n        if (count[min] != 0) break;\n    if (root < min) root = min;\n\n    /* check for an over-subscribed or incomplete set of lengths */\n    left = 1;\n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) return -1;        /* over-subscribed */\n    }\n    if (left > 0 && (type == CODES || max != 1))\n        return -1;                      /* incomplete set */\n\n    /* generate offsets into symbol table for each length for sorting */\n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + count[len];\n\n    /* sort symbols by length, by symbol order within each length */\n    for (sym = 0; sym < codes; sym++)\n        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;\n\n    /*\n       Create and fill in decoding tables.  In this loop, the table being\n       filled is at next and has curr index bits.  The code being used is huff\n       with length len.  That code is converted to an index by dropping drop\n       bits off of the bottom.  For codes where len is less than drop + curr,\n       those top drop + curr - len bits are incremented through all values to\n       fill the table with replicated entries.\n\n       root is the number of index bits for the root table.  When len exceeds\n       root, sub-tables are created pointed to by the root entry with an index\n       of the low root bits of huff.  This is saved in low to check for when a\n       new sub-table should be started.  drop is zero when the root table is\n       being filled, and drop is root when sub-tables are being filled.\n\n       When a new sub-table is needed, it is necessary to look ahead in the\n       code lengths to determine what size sub-table is needed.  The length\n       counts are used for this, and so count[] is decremented as codes are\n       entered in the tables.\n\n       used keeps track of how many table entries have been allocated from the\n       provided *table space.  It is checked for LENS and DIST tables against\n       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n       the initial root table size constants.  See the comments in inftrees.h\n       for more information.\n\n       sym increments through all symbols, and the loop terminates when\n       all codes of length max, i.e. all codes, have been processed.  This\n       routine permits incomplete codes, so another loop after this one fills\n       in the rest of the decoding tables with invalid code markers.\n     */\n\n    /* set up for code type */\n    switch (type) {\n    case CODES:\n        base = extra = work;    /* dummy value--not used */\n        match = 20;\n        break;\n    case LENS:\n        base = lbase;\n        extra = lext;\n        match = 257;\n        break;\n    default:    /* DISTS */\n        base = dbase;\n        extra = dext;\n        match = 0;\n    }\n\n    /* initialize state for loop */\n    huff = 0;                   /* starting code */\n    sym = 0;                    /* starting code symbol */\n    len = min;                  /* starting code length */\n    next = *table;              /* current table to fill in */\n    curr = root;                /* current table index bits */\n    drop = 0;                   /* current bits to drop from code for index */\n    low = (unsigned)(-1);       /* trigger new sub-table when len > root */\n    used = 1U << root;          /* use root table entries */\n    mask = used - 1;            /* mask for comparing low */\n\n    /* check available table space */\n    if ((type == LENS && used > ENOUGH_LENS) ||\n        (type == DISTS && used > ENOUGH_DISTS))\n        return 1;\n\n    /* process all codes and make table entries */\n    for (;;) {\n        /* create table entry */\n        here.bits = (unsigned char)(len - drop);\n        if (work[sym] + 1U < match) {\n            here.op = (unsigned char)0;\n            here.val = work[sym];\n        }\n        else if (work[sym] >= match) {\n            here.op = (unsigned char)(extra[work[sym] - match]);\n            here.val = base[work[sym] - match];\n        }\n        else {\n            here.op = (unsigned char)(32 + 64);         /* end of block */\n            here.val = 0;\n        }\n\n        /* replicate for those indices with low len bits equal to huff */\n        incr = 1U << (len - drop);\n        fill = 1U << curr;\n        min = fill;                 /* save offset to next table */\n        do {\n            fill -= incr;\n            next[(huff >> drop) + fill] = here;\n        } while (fill != 0);\n\n        /* backwards increment the len-bit code huff */\n        incr = 1U << (len - 1);\n        while (huff & incr)\n            incr >>= 1;\n        if (incr != 0) {\n            huff &= incr - 1;\n            huff += incr;\n        }\n        else\n            huff = 0;\n\n        /* go to next symbol, update count, len */\n        sym++;\n        if (--(count[len]) == 0) {\n            if (len == max) break;\n            len = lens[work[sym]];\n        }\n\n        /* create new sub-table if needed */\n        if (len > root && (huff & mask) != low) {\n            /* if first time, transition to sub-tables */\n            if (drop == 0)\n                drop = root;\n\n            /* increment past last table */\n            next += min;            /* here min is 1 << curr */\n\n            /* determine length of next table */\n            curr = len - drop;\n            left = (int)(1 << curr);\n            while (curr + drop < max) {\n                left -= count[curr + drop];\n                if (left <= 0) break;\n                curr++;\n                left <<= 1;\n            }\n\n            /* check for enough space */\n            used += 1U << curr;\n            if ((type == LENS && used > ENOUGH_LENS) ||\n                (type == DISTS && used > ENOUGH_DISTS))\n                return 1;\n\n            /* point entry in root table to sub-table */\n            low = huff & mask;\n            (*table)[low].op = (unsigned char)curr;\n            (*table)[low].bits = (unsigned char)root;\n            (*table)[low].val = (unsigned short)(next - *table);\n        }\n    }\n\n    /* fill in remaining table entry if code is incomplete (guaranteed to have\n       at most one remaining entry, since if the code is incomplete, the\n       maximum code length that was allowed to get this far is one bit) */\n    if (huff != 0) {\n        here.op = (unsigned char)64;            /* invalid code marker */\n        here.bits = (unsigned char)(len - drop);\n        here.val = (unsigned short)0;\n        next[huff] = here;\n    }\n\n    /* set return parameters */\n    *table += used;\n    *bits = root;\n    return 0;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL inflate_table",
            "parameters": {
              "type": "codetype",
              "lens": "unsigned short FAR",
              "codes": "unsigned",
              "FAR": "code",
              "bits": "unsigned FAR",
              "work": "unsigned short FAR"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"zutil.h\"\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ],
        [
          "#include \"inftrees.h\"\n",
          [
            6,
            0
          ],
          [
            7,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/infback.c": {
      "fn_def_list": [
        {
          "fn_code": "int ZEXPORT inflateBackInit_(z_streamp strm, int windowBits,\n                             unsigned char FAR *window, const char *version,\n                             int stream_size) {\n    struct inflate_state FAR *state;\n\n    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||\n        stream_size != (int)(sizeof(z_stream)))\n        return Z_VERSION_ERROR;\n    if (strm == Z_NULL || window == Z_NULL ||\n        windowBits < 8 || windowBits > 15)\n        return Z_STREAM_ERROR;\n    strm->msg = Z_NULL;                 /* in case we return an error */\n    if (strm->zalloc == (alloc_func)0) {\n#ifdef Z_SOLO\n        return Z_STREAM_ERROR;\n#else\n        strm->zalloc = zcalloc;\n        strm->opaque = (voidpf)0;\n#endif\n    }\n    if (strm->zfree == (free_func)0)\n#ifdef Z_SOLO\n        return Z_STREAM_ERROR;\n#else\n    strm->zfree = zcfree;\n#endif\n    state = (struct inflate_state FAR *)ZALLOC(strm, 1,\n                                               sizeof(struct inflate_state));\n    if (state == Z_NULL) return Z_MEM_ERROR;\n    Tracev((stderr, \"inflate: allocated\\n\"));\n    strm->state = (struct internal_state FAR *)state;\n    state->dmax = 32768U;\n    state->wbits = (uInt)windowBits;\n    state->wsize = 1U << windowBits;\n    state->window = window;\n    state->wnext = 0;\n    state->whave = 0;\n    state->sane = 1;\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              24,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateBackInit_",
            "parameters": {
              "strm": "z_streamp",
              "windowBits": "int",
              "FAR": "unsigned char",
              "version": "char",
              "stream_size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "local void fixedtables(struct inflate_state FAR *state) {\n#ifdef BUILDFIXED\n    static int virgin = 1;\n    static code *lenfix, *distfix;\n    static code fixed[544];\n\n    /* build fixed huffman tables if first call (may not be thread safe) */\n    if (virgin) {\n        unsigned sym, bits;\n        static code *next;\n\n        /* literal/length table */\n        sym = 0;\n        while (sym < 144) state->lens[sym++] = 8;\n        while (sym < 256) state->lens[sym++] = 9;\n        while (sym < 280) state->lens[sym++] = 7;\n        while (sym < 288) state->lens[sym++] = 8;\n        next = fixed;\n        lenfix = next;\n        bits = 9;\n        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);\n\n        /* distance table */\n        sym = 0;\n        while (sym < 32) state->lens[sym++] = 5;\n        distfix = next;\n        bits = 5;\n        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);\n\n        /* do this just once */\n        virgin = 0;\n    }\n#else /* !BUILDFIXED */\n#   include \"inffixed.h\"\n#endif /* BUILDFIXED */\n    state->lencode = lenfix;\n    state->lenbits = 9;\n    state->distcode = distfix;\n    state->distbits = 5;\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fixedtables",
            "parameters": {
              "FAR": "struct inflate_state"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int ZEXPORT inflateBack(z_streamp strm, in_func in, void FAR *in_desc,\n                        out_func out, void FAR *out_desc) {\n    struct inflate_state FAR *state;\n    z_const unsigned char FAR *next;    /* next input */\n    unsigned char FAR *put;     /* next output */\n    unsigned have, left;        /* available input and output */\n    unsigned long hold;         /* bit buffer */\n    unsigned bits;              /* bits in bit buffer */\n    unsigned copy;              /* number of stored or match bytes to copy */\n    unsigned char FAR *from;    /* where to copy match bytes from */\n    code here;                  /* current decoding table entry */\n    code last;                  /* parent table entry */\n    unsigned len;               /* length to copy for repeats, bits to drop */\n    int ret;                    /* return code */\n    static const unsigned short order[19] = /* permutation of code lengths */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    /* Check that the strm exists and that the state was initialized */\n    if (strm == Z_NULL || strm->state == Z_NULL)\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n\n    /* Reset the state */\n    strm->msg = Z_NULL;\n    state->mode = TYPE;\n    state->last = 0;\n    state->whave = 0;\n    next = strm->next_in;\n    have = next != Z_NULL ? strm->avail_in : 0;\n    hold = 0;\n    bits = 0;\n    put = state->window;\n    left = state->wsize;\n\n    /* Inflate until end of block marked as last */\n    for (;;)\n        switch (state->mode) {\n        case TYPE:\n            /* determine and dispatch block type */\n            if (state->last) {\n                BYTEBITS();\n                state->mode = DONE;\n                break;\n            }\n            NEEDBITS(3);\n            state->last = BITS(1);\n            DROPBITS(1);\n            switch (BITS(2)) {\n            case 0:                             /* stored block */\n                Tracev((stderr, \"inflate:     stored block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = STORED;\n                break;\n            case 1:                             /* fixed block */\n                fixedtables(state);\n                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = LEN;              /* decode codes */\n                break;\n            case 2:                             /* dynamic block */\n                Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n                state->mode = TABLE;\n                break;\n            case 3:\n                strm->msg = (z_const char *)\"invalid block type\";\n                state->mode = BAD;\n            }\n            DROPBITS(2);\n            break;\n\n        case STORED:\n            /* get and verify stored block length */\n            BYTEBITS();                         /* go to byte boundary */\n            NEEDBITS(32);\n            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                strm->msg = (z_const char *)\"invalid stored block lengths\";\n                state->mode = BAD;\n                break;\n            }\n            state->length = (unsigned)hold & 0xffff;\n            Tracev((stderr, \"inflate:       stored length %u\\n\",\n                    state->length));\n            INITBITS();\n\n            /* copy stored block from input to output */\n            while (state->length != 0) {\n                copy = state->length;\n                PULL();\n                ROOM();\n                if (copy > have) copy = have;\n                if (copy > left) copy = left;\n                zmemcpy(put, next, copy);\n                have -= copy;\n                next += copy;\n                left -= copy;\n                put += copy;\n                state->length -= copy;\n            }\n            Tracev((stderr, \"inflate:       stored end\\n\"));\n            state->mode = TYPE;\n            break;\n\n        case TABLE:\n            /* get dynamic table entries descriptor */\n            NEEDBITS(14);\n            state->nlen = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5) + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n            DROPBITS(4);\n#ifndef PKZIP_BUG_WORKAROUND\n            if (state->nlen > 286 || state->ndist > 30) {\n                strm->msg = (z_const char *)\"too many length or distance symbols\";\n                state->mode = BAD;\n                break;\n            }\n#endif\n            Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n\n            /* get code length code lengths (not a typo) */\n            state->have = 0;\n            while (state->have < state->ncode) {\n                NEEDBITS(3);\n                state->lens[order[state->have++]] = (unsigned short)BITS(3);\n                DROPBITS(3);\n            }\n            while (state->have < 19)\n                state->lens[order[state->have++]] = 0;\n            state->next = state->codes;\n            state->lencode = (code const FAR *)(state->next);\n            state->lenbits = 7;\n            ret = inflate_table(CODES, state->lens, 19, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (z_const char *)\"invalid code lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n\n            /* get length and distance code code lengths */\n            state->have = 0;\n            while (state->have < state->nlen + state->ndist) {\n                for (;;) {\n                    here = state->lencode[BITS(state->lenbits)];\n                    if ((unsigned)(here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                if (here.val < 16) {\n                    DROPBITS(here.bits);\n                    state->lens[state->have++] = here.val;\n                }\n                else {\n                    if (here.val == 16) {\n                        NEEDBITS(here.bits + 2);\n                        DROPBITS(here.bits);\n                        if (state->have == 0) {\n                            strm->msg = (z_const char *)\"invalid bit length repeat\";\n                            state->mode = BAD;\n                            break;\n                        }\n                        len = (unsigned)(state->lens[state->have - 1]);\n                        copy = 3 + BITS(2);\n                        DROPBITS(2);\n                    }\n                    else if (here.val == 17) {\n                        NEEDBITS(here.bits + 3);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 3 + BITS(3);\n                        DROPBITS(3);\n                    }\n                    else {\n                        NEEDBITS(here.bits + 7);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 11 + BITS(7);\n                        DROPBITS(7);\n                    }\n                    if (state->have + copy > state->nlen + state->ndist) {\n                        strm->msg = (z_const char *)\"invalid bit length repeat\";\n                        state->mode = BAD;\n                        break;\n                    }\n                    while (copy--)\n                        state->lens[state->have++] = (unsigned short)len;\n                }\n            }\n\n            /* handle error breaks in while */\n            if (state->mode == BAD) break;\n\n            /* check for end-of-block code (better have one) */\n            if (state->lens[256] == 0) {\n                strm->msg = (z_const char *)\"invalid code -- missing end-of-block\";\n                state->mode = BAD;\n                break;\n            }\n\n            /* build code tables -- note: do not change the lenbits or distbits\n               values here (9 and 6) without reading the comments in inftrees.h\n               concerning the ENOUGH constants, which depend on those values */\n            state->next = state->codes;\n            state->lencode = (code const FAR *)(state->next);\n            state->lenbits = 9;\n            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),\n                                &(state->lenbits), state->work);\n            if (ret) {\n                strm->msg = (z_const char *)\"invalid literal/lengths set\";\n                state->mode = BAD;\n                break;\n            }\n            state->distcode = (code const FAR *)(state->next);\n            state->distbits = 6;\n            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n                            &(state->next), &(state->distbits), state->work);\n            if (ret) {\n                strm->msg = (z_const char *)\"invalid distances set\";\n                state->mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       codes ok\\n\"));\n            state->mode = LEN;\n                /* fallthrough */\n\n        case LEN:\n            /* use inflate_fast() if we have enough input and output */\n            if (have >= 6 && left >= 258) {\n                RESTORE();\n                if (state->whave < state->wsize)\n                    state->whave = state->wsize - left;\n                inflate_fast(strm, state->wsize);\n                LOAD();\n                break;\n            }\n\n            /* get a literal, length, or end-of-block code */\n            for (;;) {\n                here = state->lencode[BITS(state->lenbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if (here.op && (here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->lencode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n            }\n            DROPBITS(here.bits);\n            state->length = (unsigned)here.val;\n\n            /* process literal */\n            if (here.op == 0) {\n                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                        \"inflate:         literal '%c'\\n\" :\n                        \"inflate:         literal 0x%02x\\n\", here.val));\n                ROOM();\n                *put++ = (unsigned char)(state->length);\n                left--;\n                state->mode = LEN;\n                break;\n            }\n\n            /* process end of block */\n            if (here.op & 32) {\n                Tracevv((stderr, \"inflate:         end of block\\n\"));\n                state->mode = TYPE;\n                break;\n            }\n\n            /* invalid code */\n            if (here.op & 64) {\n                strm->msg = (z_const char *)\"invalid literal/length code\";\n                state->mode = BAD;\n                break;\n            }\n\n            /* length code -- get extra bits, if any */\n            state->extra = (unsigned)(here.op) & 15;\n            if (state->extra != 0) {\n                NEEDBITS(state->extra);\n                state->length += BITS(state->extra);\n                DROPBITS(state->extra);\n            }\n            Tracevv((stderr, \"inflate:         length %u\\n\", state->length));\n\n            /* get distance code */\n            for (;;) {\n                here = state->distcode[BITS(state->distbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if ((here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = state->distcode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n            }\n            DROPBITS(here.bits);\n            if (here.op & 64) {\n                strm->msg = (z_const char *)\"invalid distance code\";\n                state->mode = BAD;\n                break;\n            }\n            state->offset = (unsigned)here.val;\n\n            /* get distance extra bits, if any */\n            state->extra = (unsigned)(here.op) & 15;\n            if (state->extra != 0) {\n                NEEDBITS(state->extra);\n                state->offset += BITS(state->extra);\n                DROPBITS(state->extra);\n            }\n            if (state->offset > state->wsize - (state->whave < state->wsize ?\n                                                left : 0)) {\n                strm->msg = (z_const char *)\"invalid distance too far back\";\n                state->mode = BAD;\n                break;\n            }\n            Tracevv((stderr, \"inflate:         distance %u\\n\", state->offset));\n\n            /* copy match from window to output */\n            do {\n                ROOM();\n                copy = state->wsize - state->offset;\n                if (copy < left) {\n                    from = put + copy;\n                    copy = left - copy;\n                }\n                else {\n                    from = put - state->offset;\n                    copy = left;\n                }\n                if (copy > state->length) copy = state->length;\n                state->length -= copy;\n                left -= copy;\n                do {\n                    *put++ = *from++;\n                } while (--copy);\n            } while (state->length != 0);\n            break;\n\n        case DONE:\n            /* inflate stream terminated properly */\n            ret = Z_STREAM_END;\n            goto inf_leave;\n\n        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n\n        default:\n            /* can't happen, but makes compilers happy */\n            ret = Z_STREAM_ERROR;\n            goto inf_leave;\n        }\n\n    /* Write leftover output and return unused input */\n  inf_leave:\n    if (left < state->wsize) {\n        if (out(out_desc, state->window, state->wsize - left) &&\n            ret == Z_STREAM_END)\n            ret = Z_BUF_ERROR;\n    }\n    strm->next_in = next;\n    strm->avail_in = have;\n    return ret;\n}",
          "fn_code_pos": [
            [
              241,
              0
            ],
            [
              618,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateBack",
            "parameters": {
              "strm": "z_streamp",
              "in": "in_func",
              "FAR": "void",
              "out": "out_func"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT inflateBackEnd(z_streamp strm) {\n    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)\n        return Z_STREAM_ERROR;\n    ZFREE(strm, strm->state);\n    strm->state = Z_NULL;\n    Tracev((stderr, \"inflate: end\\n\"));\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              620,
              0
            ],
            [
              627,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateBackEnd",
            "parameters": {
              "strm": "z_streamp"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct inflate_state",
          {},
          "",
          [
            27,
            4
          ],
          [
            27,
            24
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            50,
            13
          ],
          [
            50,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            51,
            54
          ],
          [
            51,
            74
          ]
        ],
        [
          "struct internal_state",
          {},
          "",
          [
            54,
            19
          ],
          [
            54,
            40
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            75,
            23
          ],
          [
            75,
            43
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            243,
            4
          ],
          [
            243,
            24
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            261,
            13
          ],
          [
            261,
            33
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"zutil.h\"\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"inftrees.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"inflate.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"inffast.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#   include \"inffixed.h\"\n",
          [
            108,
            0
          ],
          [
            109,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/inflate.c": {
      "fn_def_list": [
        {
          "fn_code": "local int inflateStateCheck(z_streamp strm) {\n    struct inflate_state FAR *state;\n    if (strm == Z_NULL ||\n        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)\n        return 1;\n    state = (struct inflate_state FAR *)strm->state;\n    if (state == Z_NULL || state->strm != strm ||\n        state->mode < HEAD || state->mode > SYNC)\n        return 1;\n    return 0;\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              103,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateStateCheck",
            "parameters": {
              "strm": "z_streamp"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int ZEXPORT inflateResetKeep(z_streamp strm) {\n    struct inflate_state FAR *state;\n\n    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    strm->total_in = strm->total_out = state->total = 0;\n    strm->msg = Z_NULL;\n    if (state->wrap)        /* to support ill-conceived Java test suite */\n        strm->adler = state->wrap & 1;\n    state->mode = HEAD;\n    state->last = 0;\n    state->havedict = 0;\n    state->flags = -1;\n    state->dmax = 32768U;\n    state->head = Z_NULL;\n    state->hold = 0;\n    state->bits = 0;\n    state->lencode = state->distcode = state->next = state->codes;\n    state->sane = 1;\n    state->back = -1;\n    Tracev((stderr, \"inflate: reset\\n\"));\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              105,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateResetKeep",
            "parameters": {
              "strm": "z_streamp"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT inflateReset(z_streamp strm) {\n    struct inflate_state FAR *state;\n\n    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    state->wsize = 0;\n    state->whave = 0;\n    state->wnext = 0;\n    return inflateResetKeep(strm);\n}",
          "fn_code_pos": [
            [
              129,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateReset",
            "parameters": {
              "strm": "z_streamp"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT inflateReset2(z_streamp strm, int windowBits) {\n    int wrap;\n    struct inflate_state FAR *state;\n\n    /* get the state */\n    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n\n    /* extract wrap request from windowBits parameter */\n    if (windowBits < 0) {\n        if (windowBits < -15)\n            return Z_STREAM_ERROR;\n        wrap = 0;\n        windowBits = -windowBits;\n    }\n    else {\n        wrap = (windowBits >> 4) + 5;\n#ifdef GUNZIP\n        if (windowBits < 48)\n            windowBits &= 15;\n#endif\n    }\n\n    /* set number of window bits, free window if different */\n    if (windowBits && (windowBits < 8 || windowBits > 15))\n        return Z_STREAM_ERROR;\n    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {\n        ZFREE(strm, state->window);\n        state->window = Z_NULL;\n    }\n\n    /* update state and reset the rest of it */\n    state->wrap = wrap;\n    state->wbits = (unsigned)windowBits;\n    return inflateReset(strm);\n}",
          "fn_code_pos": [
            [
              140,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateReset2",
            "parameters": {
              "strm": "z_streamp",
              "windowBits": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT inflateInit2_(z_streamp strm, int windowBits,\n                          const char *version, int stream_size) {\n    int ret;\n    struct inflate_state FAR *state;\n\n    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||\n        stream_size != (int)(sizeof(z_stream)))\n        return Z_VERSION_ERROR;\n    if (strm == Z_NULL) return Z_STREAM_ERROR;\n    strm->msg = Z_NULL;                 /* in case we return an error */\n    if (strm->zalloc == (alloc_func)0) {\n#ifdef Z_SOLO\n        return Z_STREAM_ERROR;\n#else\n        strm->zalloc = zcalloc;\n        strm->opaque = (voidpf)0;\n#endif\n    }\n    if (strm->zfree == (free_func)0)\n#ifdef Z_SOLO\n        return Z_STREAM_ERROR;\n#else\n        strm->zfree = zcfree;\n#endif\n    state = (struct inflate_state FAR *)\n            ZALLOC(strm, 1, sizeof(struct inflate_state));\n    if (state == Z_NULL) return Z_MEM_ERROR;\n    Tracev((stderr, \"inflate: allocated\\n\"));\n    strm->state = (struct internal_state FAR *)state;\n    state->strm = strm;\n    state->window = Z_NULL;\n    state->mode = HEAD;     /* to pass state test in inflateReset2() */\n    ret = inflateReset2(strm, windowBits);\n    if (ret != Z_OK) {\n        ZFREE(strm, state);\n        strm->state = Z_NULL;\n    }\n    return ret;\n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              215,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateInit2_",
            "parameters": {
              "strm": "z_streamp",
              "windowBits": "int",
              "version": "char",
              "stream_size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT inflateInit_(z_streamp strm, const char *version,\n                         int stream_size) {\n    return inflateInit2_(strm, DEF_WBITS, version, stream_size);\n}",
          "fn_code_pos": [
            [
              217,
              0
            ],
            [
              220,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateInit_",
            "parameters": {
              "strm": "z_streamp",
              "version": "char",
              "stream_size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT inflatePrime(z_streamp strm, int bits, int value) {\n    struct inflate_state FAR *state;\n\n    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;\n    if (bits == 0)\n        return Z_OK;\n    state = (struct inflate_state FAR *)strm->state;\n    if (bits < 0) {\n        state->hold = 0;\n        state->bits = 0;\n        return Z_OK;\n    }\n    if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;\n    value &= (1L << bits) - 1;\n    state->hold += (unsigned)value << state->bits;\n    state->bits += (uInt)bits;\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              222,
              0
            ],
            [
              239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflatePrime",
            "parameters": {
              "strm": "z_streamp",
              "bits": "int",
              "value": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "local void fixedtables(struct inflate_state FAR *state) {\n#ifdef BUILDFIXED\n    static int virgin = 1;\n    static code *lenfix, *distfix;\n    static code fixed[544];\n\n    /* build fixed huffman tables if first call (may not be thread safe) */\n    if (virgin) {\n        unsigned sym, bits;\n        static code *next;\n\n        /* literal/length table */\n        sym = 0;\n        while (sym < 144) state->lens[sym++] = 8;\n        while (sym < 256) state->lens[sym++] = 9;\n        while (sym < 280) state->lens[sym++] = 7;\n        while (sym < 288) state->lens[sym++] = 8;\n        next = fixed;\n        lenfix = next;\n        bits = 9;\n        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);\n\n        /* distance table */\n        sym = 0;\n        while (sym < 32) state->lens[sym++] = 5;\n        distfix = next;\n        bits = 5;\n        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);\n\n        /* do this just once */\n        virgin = 0;\n    }\n#else /* !BUILDFIXED */\n#   include \"inffixed.h\"\n#endif /* BUILDFIXED */\n    state->lencode = lenfix;\n    state->lenbits = 9;\n    state->distcode = distfix;\n    state->distbits = 5;\n}",
          "fn_code_pos": [
            [
              251,
              0
            ],
            [
              290,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fixedtables",
            "parameters": {
              "FAR": "struct inflate_state"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "void makefixed(void)\n{\n    unsigned low, size;\n    struct inflate_state state;\n\n    fixedtables(&state);\n    puts(\"    /* inffixed.h -- table for decoding fixed codes\");\n    puts(\"     * Generated automatically by makefixed().\");\n    puts(\"     */\");\n    puts(\"\");\n    puts(\"    /* WARNING: this file should *not* be used by applications.\");\n    puts(\"       It is part of the implementation of this library and is\");\n    puts(\"       subject to change. Applications should only use zlib.h.\");\n    puts(\"     */\");\n    puts(\"\");\n    size = 1U << 9;\n    printf(\"    static const code lenfix[%u] = {\", size);\n    low = 0;\n    for (;;) {\n        if ((low % 7) == 0) printf(\"\\n        \");\n        printf(\"{%u,%u,%d}\", (low & 127) == 99 ? 64 : state.lencode[low].op,\n               state.lencode[low].bits, state.lencode[low].val);\n        if (++low == size) break;\n        putchar(',');\n    }\n    puts(\"\\n    };\");\n    size = 1U << 5;\n    printf(\"\\n    static const code distfix[%u] = {\", size);\n    low = 0;\n    for (;;) {\n        if ((low % 6) == 0) printf(\"\\n        \");\n        printf(\"{%u,%u,%d}\", state.distcode[low].op, state.distcode[low].bits,\n               state.distcode[low].val);\n        if (++low == size) break;\n        putchar(',');\n    }\n    puts(\"\\n    };\");\n}",
          "fn_code_pos": [
            [
              313,
              0
            ],
            [
              350,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "makefixed",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "local int updatewindow(z_streamp strm, const Bytef *end, unsigned copy) {\n    struct inflate_state FAR *state;\n    unsigned dist;\n\n    state = (struct inflate_state FAR *)strm->state;\n\n    /* if it hasn't been done already, allocate space for the window */\n    if (state->window == Z_NULL) {\n        state->window = (unsigned char FAR *)\n                        ZALLOC(strm, 1U << state->wbits,\n                               sizeof(unsigned char));\n        if (state->window == Z_NULL) return 1;\n    }\n\n    /* if window not in use yet, initialize */\n    if (state->wsize == 0) {\n        state->wsize = 1U << state->wbits;\n        state->wnext = 0;\n        state->whave = 0;\n    }\n\n    /* copy state->wsize or less output bytes into the circular window */\n    if (copy >= state->wsize) {\n        zmemcpy(state->window, end - state->wsize, state->wsize);\n        state->wnext = 0;\n        state->whave = state->wsize;\n    }\n    else {\n        dist = state->wsize - state->wnext;\n        if (dist > copy) dist = copy;\n        zmemcpy(state->window + state->wnext, end - copy, dist);\n        copy -= dist;\n        if (copy) {\n            zmemcpy(state->window, end - copy, copy);\n            state->wnext = copy;\n            state->whave = state->wsize;\n        }\n        else {\n            state->wnext += dist;\n            if (state->wnext == state->wsize) state->wnext = 0;\n            if (state->whave < state->wsize) state->whave += dist;\n        }\n    }\n    return 0;\n}",
          "fn_code_pos": [
            [
              367,
              0
            ],
            [
              411,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "updatewindow",
            "parameters": {
              "strm": "z_streamp",
              "end": "Bytef",
              "copy": "unsigned"
            },
            "return_type": "local"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "inflate(z_streamp strm, int flush)",
          "fn_dec_pos": [
            [
              589,
              12
            ],
            [
              589,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflate",
            "parameters": {
              "strm": "z_streamp",
              "flush": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct inflate_state",
          {},
          "",
          [
            94,
            4
          ],
          [
            94,
            24
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            98,
            13
          ],
          [
            98,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            106,
            4
          ],
          [
            106,
            24
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            109,
            13
          ],
          [
            109,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            130,
            4
          ],
          [
            130,
            24
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            133,
            13
          ],
          [
            133,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            142,
            4
          ],
          [
            142,
            24
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            146,
            13
          ],
          [
            146,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            180,
            4
          ],
          [
            180,
            24
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            201,
            13
          ],
          [
            201,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            202,
            35
          ],
          [
            202,
            55
          ]
        ],
        [
          "struct internal_state",
          {},
          "",
          [
            205,
            19
          ],
          [
            205,
            40
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            223,
            4
          ],
          [
            223,
            24
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            228,
            13
          ],
          [
            228,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            251,
            23
          ],
          [
            251,
            43
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            316,
            4
          ],
          [
            316,
            24
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            368,
            4
          ],
          [
            368,
            24
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            371,
            13
          ],
          [
            371,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            590,
            4
          ],
          [
            590,
            24
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            613,
            13
          ],
          [
            613,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            1269,
            13
          ],
          [
            1269,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            1283,
            13
          ],
          [
            1283,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            1305,
            13
          ],
          [
            1305,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            1334,
            13
          ],
          [
            1334,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            1383,
            13
          ],
          [
            1383,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            1434,
            13
          ],
          [
            1434,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            1447,
            13
          ],
          [
            1447,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            1450,
            12
          ],
          [
            1450,
            32
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            1451,
            36
          ],
          [
            1451,
            56
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            1465,
            48
          ],
          [
            1465,
            68
          ]
        ],
        [
          "struct internal_state",
          {},
          "",
          [
            1478,
            19
          ],
          [
            1478,
            40
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            1486,
            13
          ],
          [
            1486,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            1501,
            13
          ],
          [
            1501,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            1514,
            13
          ],
          [
            1514,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            1523,
            13
          ],
          [
            1523,
            33
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"zutil.h\"\n",
          [
            82,
            0
          ],
          [
            83,
            0
          ]
        ],
        [
          "#include \"inftrees.h\"\n",
          [
            83,
            0
          ],
          [
            84,
            0
          ]
        ],
        [
          "#include \"inflate.h\"\n",
          [
            84,
            0
          ],
          [
            85,
            0
          ]
        ],
        [
          "#include \"inffast.h\"\n",
          [
            85,
            0
          ],
          [
            86,
            0
          ]
        ],
        [
          "#   include \"inffixed.h\"\n",
          [
            284,
            0
          ],
          [
            285,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            293,
            0
          ],
          [
            294,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/iostream3/zfstream.cc": {
      "fn_def_list": [
        {
          "fn_code": "gzfilebuf::gzfilebuf()\n: file(NULL), io_mode(std::ios_base::openmode(0)), own_fd(false),\n  buffer(NULL), buffer_size(BIGBUFSIZE), own_buffer(true)\n{\n  // No buffers to start with\n  this->disable_buffer();\n}",
          "fn_code_pos": [
            [
              20,
              0
            ],
            [
              26,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::gzfilebuf",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzfilebuf::~gzfilebuf()\n{\n  // Sync output buffer and close only if responsible for file\n  // (i.e. attached streams should be left open at this stage)\n  this->sync();\n  if (own_fd)\n    this->close();\n  // Make sure internal buffer is deallocated\n  this->disable_buffer();\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              38,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::~gzfilebuf",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "int\ngzfilebuf::setcompression(int comp_level,\n                          int comp_strategy)\n{\n  return gzsetparams(file, comp_level, comp_strategy);\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              46,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::setcompression",
            "parameters": {
              "comp_level": "int",
              "comp_strategy": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "gzfilebuf*\ngzfilebuf::open(const char *name,\n                std::ios_base::openmode mode)\n{\n  // Fail if file already open\n  if (this->is_open())\n    return NULL;\n  // Don't support simultaneous read/write access (yet)\n  if ((mode & std::ios_base::in) && (mode & std::ios_base::out))\n    return NULL;\n\n  // Build mode string for gzopen and check it [27.8.1.3.2]\n  char char_mode[6] = \"\\0\\0\\0\\0\\0\";\n  if (!this->open_mode(mode, char_mode))\n    return NULL;\n\n  // Attempt to open file\n  if ((file = gzopen(name, char_mode)) == NULL)\n    return NULL;\n\n  // On success, allocate internal buffer and set flags\n  this->enable_buffer();\n  io_mode = mode;\n  own_fd = true;\n  return this;\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              74,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::open",
            "parameters": {
              "name": "char",
              "mode": "std::ios_base::openmode"
            },
            "return_type": "gzfilebuf"
          }
        },
        {
          "fn_code": "gzfilebuf*\ngzfilebuf::attach(int fd,\n                  std::ios_base::openmode mode)\n{\n  // Fail if file already open\n  if (this->is_open())\n    return NULL;\n  // Don't support simultaneous read/write access (yet)\n  if ((mode & std::ios_base::in) && (mode & std::ios_base::out))\n    return NULL;\n\n  // Build mode string for gzdopen and check it [27.8.1.3.2]\n  char char_mode[6] = \"\\0\\0\\0\\0\\0\";\n  if (!this->open_mode(mode, char_mode))\n    return NULL;\n\n  // Attempt to attach to file\n  if ((file = gzdopen(fd, char_mode)) == NULL)\n    return NULL;\n\n  // On success, allocate internal buffer and set flags\n  this->enable_buffer();\n  io_mode = mode;\n  own_fd = false;\n  return this;\n}",
          "fn_code_pos": [
            [
              77,
              0
            ],
            [
              102,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::attach",
            "parameters": {
              "fd": "int",
              "mode": "std::ios_base::openmode"
            },
            "return_type": "gzfilebuf"
          }
        },
        {
          "fn_code": "gzfilebuf*\ngzfilebuf::close()\n{\n  // Fail immediately if no file is open\n  if (!this->is_open())\n    return NULL;\n  // Assume success\n  gzfilebuf* retval = this;\n  // Attempt to sync and close gzipped file\n  if (this->sync() == -1)\n    retval = NULL;\n  if (gzclose(file) < 0)\n    retval = NULL;\n  // File is now gone anyway (postcondition [27.8.1.3.8])\n  file = NULL;\n  own_fd = false;\n  // Destroy internal buffer if it exists\n  this->disable_buffer();\n  return retval;\n}",
          "fn_code_pos": [
            [
              105,
              0
            ],
            [
              124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::close",
            "parameters": {},
            "return_type": "gzfilebuf"
          }
        },
        {
          "fn_code": "bool\ngzfilebuf::open_mode(std::ios_base::openmode mode,\n                     char* c_mode) const\n{\n  bool testb = mode & std::ios_base::binary;\n  bool testi = mode & std::ios_base::in;\n  bool testo = mode & std::ios_base::out;\n  bool testt = mode & std::ios_base::trunc;\n  bool testa = mode & std::ios_base::app;\n\n  // Check for valid flag combinations - see [27.8.1.3.2] (Table 92)\n  // Original zfstream hardcoded the compression level to maximum here...\n  // Double the time for less than 1% size improvement seems\n  // excessive though - keeping it at the default level\n  // To change back, just append \"9\" to the next three mode strings\n  if (!testi && testo && !testt && !testa)\n    strcpy(c_mode, \"w\");\n  if (!testi && testo && !testt && testa)\n    strcpy(c_mode, \"a\");\n  if (!testi && testo && testt && !testa)\n    strcpy(c_mode, \"w\");\n  if (testi && !testo && !testt && !testa)\n    strcpy(c_mode, \"r\");\n  // No read/write mode yet\n//  if (testi && testo && !testt && !testa)\n//    strcpy(c_mode, \"r+\");\n//  if (testi && testo && testt && !testa)\n//    strcpy(c_mode, \"w+\");\n\n  // Mode string should be empty for invalid combination of flags\n  if (strlen(c_mode) == 0)\n    return false;\n  if (testb)\n    strcat(c_mode, \"b\");\n  return true;\n}",
          "fn_code_pos": [
            [
              129,
              0
            ],
            [
              164,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::open_mode",
            "parameters": {
              "mode": "std::ios_base::openmode",
              "c_mode": "char"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "std::streamsize\ngzfilebuf::showmanyc()\n{\n  // Calls to underflow will fail if file not opened for reading\n  if (!this->is_open() || !(io_mode & std::ios_base::in))\n    return -1;\n  // Make sure get area is in use\n  if (this->gptr() && (this->gptr() < this->egptr()))\n    return std::streamsize(this->egptr() - this->gptr());\n  else\n    return 0;\n}",
          "fn_code_pos": [
            [
              167,
              0
            ],
            [
              178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::showmanyc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzfilebuf::int_type\ngzfilebuf::underflow()\n{\n  // If something is left in the get area by chance, return it\n  // (this shouldn't normally happen, as underflow is only supposed\n  // to be called when gptr >= egptr, but it serves as error check)\n  if (this->gptr() && (this->gptr() < this->egptr()))\n    return traits_type::to_int_type(*(this->gptr()));\n\n  // If the file hasn't been opened for reading, produce error\n  if (!this->is_open() || !(io_mode & std::ios_base::in))\n    return traits_type::eof();\n\n  // Attempt to fill internal buffer from gzipped file\n  // (buffer must be guaranteed to exist...)\n  int bytes_read = gzread(file, buffer, buffer_size);\n  // Indicates error or EOF\n  if (bytes_read <= 0)\n  {\n    // Reset get area\n    this->setg(buffer, buffer, buffer);\n    return traits_type::eof();\n  }\n  // Make all bytes read from file available as get area\n  this->setg(buffer, buffer, buffer + bytes_read);\n\n  // Return next character in get area\n  return traits_type::to_int_type(*(this->gptr()));\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              209,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::underflow",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzfilebuf::int_type\ngzfilebuf::overflow(int_type c)\n{\n  // Determine whether put area is in use\n  if (this->pbase())\n  {\n    // Double-check pointer range\n    if (this->pptr() > this->epptr() || this->pptr() < this->pbase())\n      return traits_type::eof();\n    // Add extra character to buffer if not EOF\n    if (!traits_type::eq_int_type(c, traits_type::eof()))\n    {\n      *(this->pptr()) = traits_type::to_char_type(c);\n      this->pbump(1);\n    }\n    // Number of characters to write to file\n    int bytes_to_write = this->pptr() - this->pbase();\n    // Overflow doesn't fail if nothing is to be written\n    if (bytes_to_write > 0)\n    {\n      // If the file hasn't been opened for writing, produce error\n      if (!this->is_open() || !(io_mode & std::ios_base::out))\n        return traits_type::eof();\n      // If gzipped file won't accept all bytes written to it, fail\n      if (gzwrite(file, this->pbase(), bytes_to_write) != bytes_to_write)\n        return traits_type::eof();\n      // Reset next pointer to point to pbase on success\n      this->pbump(-bytes_to_write);\n    }\n  }\n  // Write extra character to file if not EOF\n  else if (!traits_type::eq_int_type(c, traits_type::eof()))\n  {\n    // If the file hasn't been opened for writing, produce error\n    if (!this->is_open() || !(io_mode & std::ios_base::out))\n      return traits_type::eof();\n    // Impromptu char buffer (allows \"unbuffered\" output)\n    char_type last_char = traits_type::to_char_type(c);\n    // If gzipped file won't accept this character, fail\n    if (gzwrite(file, &last_char, 1) != 1)\n      return traits_type::eof();\n  }\n\n  // If you got here, you have succeeded (even if c was EOF)\n  // The return value should therefore be non-EOF\n  if (traits_type::eq_int_type(c, traits_type::eof()))\n    return traits_type::not_eof(c);\n  else\n    return c;\n}",
          "fn_code_pos": [
            [
              212,
              0
            ],
            [
              261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::overflow",
            "parameters": {
              "c": "int_type"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "std::streambuf*\ngzfilebuf::setbuf(char_type* p,\n                  std::streamsize n)\n{\n  // First make sure stuff is sync'ed, for safety\n  if (this->sync() == -1)\n    return NULL;\n  // If buffering is turned off on purpose via setbuf(0,0), still allocate one...\n  // \"Unbuffered\" only really refers to put [27.8.1.4.10], while get needs at\n  // least a buffer of size 1 (very inefficient though, therefore make it bigger?)\n  // This follows from [27.5.2.4.3]/12 (gptr needs to point at something, it seems)\n  if (!p || !n)\n  {\n    // Replace existing buffer (if any) with small internal buffer\n    this->disable_buffer();\n    buffer = NULL;\n    buffer_size = 0;\n    own_buffer = true;\n    this->enable_buffer();\n  }\n  else\n  {\n    // Replace existing buffer (if any) with external buffer\n    this->disable_buffer();\n    buffer = p;\n    buffer_size = n;\n    own_buffer = false;\n    this->enable_buffer();\n  }\n  return this;\n}",
          "fn_code_pos": [
            [
              264,
              0
            ],
            [
              294,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::setbuf",
            "parameters": {
              "p": "char_type",
              "n": "std::streamsize"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "int\ngzfilebuf::sync()\n{\n  return traits_type::eq_int_type(this->overflow(), traits_type::eof()) ? -1 : 0;\n}",
          "fn_code_pos": [
            [
              297,
              0
            ],
            [
              301,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::sync",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\ngzfilebuf::enable_buffer()\n{\n  // If internal buffer required, allocate one\n  if (own_buffer && !buffer)\n  {\n    // Check for buffered vs. \"unbuffered\"\n    if (buffer_size > 0)\n    {\n      // Allocate internal buffer\n      buffer = new char_type[buffer_size];\n      // Get area starts empty and will be expanded by underflow as need arises\n      this->setg(buffer, buffer, buffer);\n      // Setup entire internal buffer as put area.\n      // The one-past-end pointer actually points to the last element of the buffer,\n      // so that overflow(c) can safely add the extra character c to the sequence.\n      // These pointers remain in place for the duration of the buffer\n      this->setp(buffer, buffer + buffer_size - 1);\n    }\n    else\n    {\n      // Even in \"unbuffered\" case, (small?) get buffer is still required\n      buffer_size = SMALLBUFSIZE;\n      buffer = new char_type[buffer_size];\n      this->setg(buffer, buffer, buffer);\n      // \"Unbuffered\" means no put buffer\n      this->setp(0, 0);\n    }\n  }\n  else\n  {\n    // If buffer already allocated, reset buffer pointers just to make sure no\n    // stale chars are lying around\n    this->setg(buffer, buffer, buffer);\n    this->setp(buffer, buffer + buffer_size - 1);\n  }\n}",
          "fn_code_pos": [
            [
              306,
              0
            ],
            [
              342,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::enable_buffer",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\ngzfilebuf::disable_buffer()\n{\n  // If internal buffer exists, deallocate it\n  if (own_buffer && buffer)\n  {\n    // Preserve unbuffered status by zeroing size\n    if (!this->pbase())\n      buffer_size = 0;\n    delete[] buffer;\n    buffer = NULL;\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n  }\n  else\n  {\n    // Reset buffer pointers to initial state if external buffer exists\n    this->setg(buffer, buffer, buffer);\n    if (buffer)\n      this->setp(buffer, buffer + buffer_size - 1);\n    else\n      this->setp(0, 0);\n  }\n}",
          "fn_code_pos": [
            [
              345,
              0
            ],
            [
              368,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::disable_buffer",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "gzifstream::gzifstream()\n: std::istream(NULL), sb()\n{ this->init(&sb); }",
          "fn_code_pos": [
            [
              373,
              0
            ],
            [
              375,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzifstream::gzifstream",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzifstream::gzifstream(const char* name,\n                       std::ios_base::openmode mode)\n: std::istream(NULL), sb()\n{\n  this->init(&sb);\n  this->open(name, mode);\n}",
          "fn_code_pos": [
            [
              378,
              0
            ],
            [
              384,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzifstream::gzifstream",
            "parameters": {
              "name": "char",
              "mode": "std::ios_base::openmode"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzifstream::gzifstream(int fd,\n                       std::ios_base::openmode mode)\n: std::istream(NULL), sb()\n{\n  this->init(&sb);\n  this->attach(fd, mode);\n}",
          "fn_code_pos": [
            [
              387,
              0
            ],
            [
              393,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzifstream::gzifstream",
            "parameters": {
              "fd": "int",
              "mode": "std::ios_base::openmode"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void\ngzifstream::open(const char* name,\n                 std::ios_base::openmode mode)\n{\n  if (!sb.open(name, mode | std::ios_base::in))\n    this->setstate(std::ios_base::failbit);\n  else\n    this->clear();\n}",
          "fn_code_pos": [
            [
              396,
              0
            ],
            [
              404,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzifstream::open",
            "parameters": {
              "name": "char",
              "mode": "std::ios_base::openmode"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\ngzifstream::attach(int fd,\n                   std::ios_base::openmode mode)\n{\n  if (!sb.attach(fd, mode | std::ios_base::in))\n    this->setstate(std::ios_base::failbit);\n  else\n    this->clear();\n}",
          "fn_code_pos": [
            [
              407,
              0
            ],
            [
              415,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzifstream::attach",
            "parameters": {
              "fd": "int",
              "mode": "std::ios_base::openmode"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\ngzifstream::close()\n{\n  if (!sb.close())\n    this->setstate(std::ios_base::failbit);\n}",
          "fn_code_pos": [
            [
              418,
              0
            ],
            [
              423,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzifstream::close",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "gzofstream::gzofstream()\n: std::ostream(NULL), sb()\n{ this->init(&sb); }",
          "fn_code_pos": [
            [
              428,
              0
            ],
            [
              430,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzofstream::gzofstream",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzofstream::gzofstream(const char* name,\n                       std::ios_base::openmode mode)\n: std::ostream(NULL), sb()\n{\n  this->init(&sb);\n  this->open(name, mode);\n}",
          "fn_code_pos": [
            [
              433,
              0
            ],
            [
              439,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzofstream::gzofstream",
            "parameters": {
              "name": "char",
              "mode": "std::ios_base::openmode"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzofstream::gzofstream(int fd,\n                       std::ios_base::openmode mode)\n: std::ostream(NULL), sb()\n{\n  this->init(&sb);\n  this->attach(fd, mode);\n}",
          "fn_code_pos": [
            [
              442,
              0
            ],
            [
              448,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzofstream::gzofstream",
            "parameters": {
              "fd": "int",
              "mode": "std::ios_base::openmode"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void\ngzofstream::open(const char* name,\n                 std::ios_base::openmode mode)\n{\n  if (!sb.open(name, mode | std::ios_base::out))\n    this->setstate(std::ios_base::failbit);\n  else\n    this->clear();\n}",
          "fn_code_pos": [
            [
              451,
              0
            ],
            [
              459,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzofstream::open",
            "parameters": {
              "name": "char",
              "mode": "std::ios_base::openmode"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\ngzofstream::attach(int fd,\n                   std::ios_base::openmode mode)\n{\n  if (!sb.attach(fd, mode | std::ios_base::out))\n    this->setstate(std::ios_base::failbit);\n  else\n    this->clear();\n}",
          "fn_code_pos": [
            [
              462,
              0
            ],
            [
              470,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzofstream::attach",
            "parameters": {
              "fd": "int",
              "mode": "std::ios_base::openmode"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\ngzofstream::close()\n{\n  if (!sb.close())\n    this->setstate(std::ios_base::failbit);\n}",
          "fn_code_pos": [
            [
              473,
              0
            ],
            [
              478,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzofstream::close",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "gzfilebuf::open(const char *name,\n                std::ios_base::openmode mode)",
          "fn_dec_pos": [
            [
              50,
              0
            ],
            [
              51,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::open",
            "parameters": {
              "name": "char",
              "mode": "std::ios_base::openmode"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzfilebuf::attach(int fd,\n                  std::ios_base::openmode mode)",
          "fn_dec_pos": [
            [
              78,
              0
            ],
            [
              79,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::attach",
            "parameters": {
              "fd": "int",
              "mode": "std::ios_base::openmode"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzfilebuf::close()",
          "fn_dec_pos": [
            [
              106,
              0
            ],
            [
              106,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::close",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzfilebuf::setbuf(char_type* p,\n                  std::streamsize n)",
          "fn_dec_pos": [
            [
              265,
              0
            ],
            [
              266,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::setbuf",
            "parameters": {
              "p": "char_type",
              "n": "std::streamsize"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"zfstream.h\"\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <cstring>          // for strcpy, strcat, strlen (mode strings)\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <cstdio>           // for BUFSIZ\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/iostream3/test.cc": {
      "fn_def_list": [
        {
          "fn_code": "int main() {\n\n  gzofstream outf;\n  gzifstream inf;\n  char buf[80];\n\n  outf.open(\"test1.txt.gz\");\n  outf << \"The quick brown fox sidestepped the lazy canine\\n\"\n       << 1.3 << \"\\nPlan \" << 9 << std::endl;\n  outf.close();\n  std::cout << \"Wrote the following message to 'test1.txt.gz' (check with zcat or zless):\\n\"\n            << \"The quick brown fox sidestepped the lazy canine\\n\"\n            << 1.3 << \"\\nPlan \" << 9 << std::endl;\n\n  std::cout << \"\\nReading 'test1.txt.gz' (buffered) produces:\\n\";\n  inf.open(\"test1.txt.gz\");\n  while (inf.getline(buf,80,'\\n')) {\n    std::cout << buf << \"\\t(\" << inf.rdbuf()->in_avail() << \" chars left in buffer)\\n\";\n  }\n  inf.close();\n\n  outf.rdbuf()->pubsetbuf(0,0);\n  outf.open(\"test2.txt.gz\");\n  outf << setcompression(Z_NO_COMPRESSION)\n       << \"The quick brown fox sidestepped the lazy canine\\n\"\n       << 1.3 << \"\\nPlan \" << 9 << std::endl;\n  outf.close();\n  std::cout << \"\\nWrote the same message to 'test2.txt.gz' in uncompressed form\";\n\n  std::cout << \"\\nReading 'test2.txt.gz' (unbuffered) produces:\\n\";\n  inf.rdbuf()->pubsetbuf(0,0);\n  inf.open(\"test2.txt.gz\");\n  while (inf.getline(buf,80,'\\n')) {\n    std::cout << buf << \"\\t(\" << inf.rdbuf()->in_avail() << \" chars left in buffer)\\n\";\n  }\n  inf.close();\n\n  return 0;\n\n}",
          "fn_code_pos": [
            [
              10,
              0
            ],
            [
              49,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"zfstream.h\"\n",
          [
            7,
            0
          ],
          [
            8,
            0
          ]
        ],
        [
          "#include <iostream>      // for cout\n",
          [
            8,
            0
          ],
          [
            9,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/minizip/zip.c": {
      "fn_def_list": [
        {
          "fn_code": "local linkedlist_datablock_internal* allocate_new_datablock(void) {\n    linkedlist_datablock_internal* ldi;\n    ldi = (linkedlist_datablock_internal*)\n                 ALLOC(sizeof(linkedlist_datablock_internal));\n    if (ldi!=NULL)\n    {\n        ldi->next_datablock = NULL ;\n        ldi->filled_in_this_block = 0 ;\n        ldi->avail_in_this_block = SIZEDATA_INDATABLOCK ;\n    }\n    return ldi;\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              214,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void free_datablock(linkedlist_datablock_internal* ldi) {\n    while (ldi!=NULL)\n    {\n        linkedlist_datablock_internal* ldinext = ldi->next_datablock;\n        free(ldi);\n        ldi = ldinext;\n    }\n}",
          "fn_code_pos": [
            [
              216,
              0
            ],
            [
              223,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "free_datablock",
            "parameters": {
              "ldi": "linkedlist_datablock_internal"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void init_linkedlist(linkedlist_data* ll) {\n    ll->first_block = ll->last_block = NULL;\n}",
          "fn_code_pos": [
            [
              225,
              0
            ],
            [
              227,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "init_linkedlist",
            "parameters": {
              "ll": "linkedlist_data"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void free_linkedlist(linkedlist_data* ll) {\n    free_datablock(ll->first_block);\n    ll->first_block = ll->last_block = NULL;\n}",
          "fn_code_pos": [
            [
              229,
              0
            ],
            [
              232,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "free_linkedlist",
            "parameters": {
              "ll": "linkedlist_data"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int add_data_in_datablock(linkedlist_data* ll, const void* buf, uLong len) {\n    linkedlist_datablock_internal* ldi;\n    const unsigned char* from_copy;\n\n    if (ll==NULL)\n        return ZIP_INTERNALERROR;\n\n    if (ll->last_block == NULL)\n    {\n        ll->first_block = ll->last_block = allocate_new_datablock();\n        if (ll->first_block == NULL)\n            return ZIP_INTERNALERROR;\n    }\n\n    ldi = ll->last_block;\n    from_copy = (const unsigned char*)buf;\n\n    while (len>0)\n    {\n        uInt copy_this;\n        uInt i;\n        unsigned char* to_copy;\n\n        if (ldi->avail_in_this_block==0)\n        {\n            ldi->next_datablock = allocate_new_datablock();\n            if (ldi->next_datablock == NULL)\n                return ZIP_INTERNALERROR;\n            ldi = ldi->next_datablock ;\n            ll->last_block = ldi;\n        }\n\n        if (ldi->avail_in_this_block < len)\n            copy_this = (uInt)ldi->avail_in_this_block;\n        else\n            copy_this = (uInt)len;\n\n        to_copy = &(ldi->data[ldi->filled_in_this_block]);\n\n        for (i=0;i<copy_this;i++)\n            *(to_copy+i)=*(from_copy+i);\n\n        ldi->filled_in_this_block += copy_this;\n        ldi->avail_in_this_block -= copy_this;\n        from_copy += copy_this ;\n        len -= copy_this;\n    }\n    return ZIP_OK;\n}",
          "fn_code_pos": [
            [
              235,
              0
            ],
            [
              283,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_data_in_datablock",
            "parameters": {
              "ll": "linkedlist_data",
              "buf": "void",
              "len": "uLong"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void block_init(block_t *block, linkedlist_data *list) {\n    block->node = list->first_block;\n    block->next = block->node->data;\n    block->left = block->node->filled_in_this_block;\n}",
          "fn_code_pos": [
            [
              298,
              0
            ],
            [
              302,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_init",
            "parameters": {
              "block": "block_t",
              "list": "linkedlist_data"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void block_stop(block_t *block) {\n    block->left = 0;\n    block->next = NULL;\n}",
          "fn_code_pos": [
            [
              307,
              0
            ],
            [
              310,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_stop",
            "parameters": {
              "block": "block_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int block_end(block_t *block) {\n    linkedlist_datablock_internal *node = block->node;\n    if (node == NULL)\n        // This block was previously terminated with extreme prejudice.\n        return 1;\n    if (block->next < node->data + node->filled_in_this_block)\n        // There are more bytes to read in the current datablock.\n        return 0;\n    while (node->next_datablock != NULL) {\n        if (node->filled_in_this_block != 0)\n            // There are some bytes in a later datablock.\n            return 0;\n        node = node->next_datablock;\n    }\n    // Reached the end of the list of datablocks. There's nothing.\n    return 1;\n}",
          "fn_code_pos": [
            [
              313,
              0
            ],
            [
              329,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_end",
            "parameters": {
              "block": "block_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int block_get(block_t *block) {\n    while (block->left == 0) {\n        if (block->node == NULL)\n            // We've been marked bad. Return end.\n            return -1;\n        // Update left in case more was filled in since we were last here.\n        block->left = block->node->filled_in_this_block -\n                      (block->next - block->node->data);\n        if (block->left != 0)\n            // There was indeed more data appended in the current datablock.\n            break;\n        if (block->node->next_datablock == NULL)\n            // No more data here, and there is no next datablock. At the end.\n            return -1;\n        // Try the next datablock for more data.\n        block->node = block->node->next_datablock;\n        block->next = block->node->data;\n        block->left = block->node->filled_in_this_block;\n    }\n    // We have a byte to return.\n    block->left--;\n    return *block->next++;\n}",
          "fn_code_pos": [
            [
              332,
              0
            ],
            [
              354,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_get",
            "parameters": {
              "block": "block_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local long block_get2(block_t *block) {\n    long got = block_get(block);\n    return got | ((unsigned long)block_get(block) << 8);\n}",
          "fn_code_pos": [
            [
              358,
              0
            ],
            [
              361,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_get2",
            "parameters": {
              "block": "block_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "local size_t block_read(block_t *block, unsigned char *buf, size_t len) {\n    size_t need = len;\n    while (need) {\n        if (block->left == 0) {\n            // Get a byte to update and step through the linked list as needed.\n            int got = block_get(block);\n            if (got == -1)\n                // Reached the end.\n                break;\n            *buf++ = (unsigned char)got;\n            need--;\n            continue;\n        }\n        size_t take = need > block->left ? block->left : need;\n        memcpy(buf, block->next, take);\n        block->next += take;\n        block->left -= take;\n        buf += take;\n        need -= take;\n    }\n    return len - need;      // return the number of bytes copied\n}",
          "fn_code_pos": [
            [
              364,
              0
            ],
            [
              385,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_read",
            "parameters": {
              "block": "block_t",
              "buf": "unsigned char",
              "len": "size_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int block_skip(block_t *block, size_t n) {\n    while (n > block->left) {\n        n -= block->left;\n        block->next += block->left;\n        block->left = 0;\n        if (block_get(block) == -1)\n            return -1;\n        n--;\n    }\n    block->next += n;\n    block->left -= n;\n    return 0;\n}",
          "fn_code_pos": [
            [
              389,
              0
            ],
            [
              401,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_skip",
            "parameters": {
              "block": "block_t",
              "n": "size_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local char *block_central_name(block_t *block, set_t *set) {\n    char *name = NULL;\n    for (;;) {\n        if (block_end(block))\n            // At the end of the central directory (so far).\n            return NULL;\n\n        // Check for a central directory record signature.\n        if (block_get2(block) != (CENTRALHEADERMAGIC & 0xffff) ||\n            block_get2(block) != (CENTRALHEADERMAGIC >> 16))\n            // Incorrect signature.\n            break;\n\n        // Go through the remaining fixed-length portion of the record,\n        // extracting the lengths of the three variable-length fields.\n        block_skip(block, 24);\n        unsigned flen = block_get2(block);      // file name length\n        unsigned xlen = block_get2(block);      // extra field length\n        unsigned clen = block_get2(block);      // comment field length\n        if (block_skip(block, 12) == -1)\n            // Premature end of the record.\n            break;\n\n        // Extract the name and skip over the extra and comment fields.\n        name = set_alloc(set, NULL, flen + 1);\n        if (block_read(block, (unsigned char *)name, flen) < flen ||\n            block_skip(block, xlen + clen) == -1)\n            // Premature end of the record.\n            break;\n\n        // Check for embedded nuls in the name.\n        if (memchr(name, 0, flen) != NULL) {\n            // This name can never match the zero-terminated name provided to\n            // zipAlreadyThere(), so we discard it and go back to get another\n            // name. (Who the heck is putting nuls inside their zip file entry\n            // names anyway?)\n            set_free(set, name);\n            continue;\n        }\n\n        // All good. Return the zero-terminated file name.\n        name[flen] = 0;\n        return name;\n    }\n\n    // Invalid signature or premature end of the central directory record.\n    // Abandon trying to process the central directory.\n    set_free(set, name);\n    block_stop(block);\n    return NULL;\n}",
          "fn_code_pos": [
            [
              406,
              0
            ],
            [
              456,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_central_name",
            "parameters": {
              "block": "block_t",
              "set": "set_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "extern int ZEXPORT zipAlreadyThere(zipFile file, char const *name) {\n    zip64_internal *zip = file;\n    if (zip == NULL)\n        return ZIP_PARAMERROR;\n    if (zip->central_dir.first_block == NULL)\n        // No central directory yet, so no, name isn't there.\n        return 0;\n    if (setjmp(zip->set.env)) {\n        // Memory allocation failure.\n        set_end(&zip->set);\n        return -2;\n    }\n    if (!set_ok(&zip->set)) {\n        // This is the first time here with some central directory content. We\n        // construct this set of names only on demand. Prepare set and block.\n        set_start(&zip->set);\n        block_init(&zip->block, &zip->central_dir);\n    }\n\n    // Update the set of names from the current central directory contents.\n    // This reads any new central directory records since the last time we were\n    // here.\n    for (;;) {\n        char *there = block_central_name(&zip->block, &zip->set);\n        if (there == NULL) {\n            if (zip->block.next == NULL)\n                // The central directory is invalid.\n                return -1;\n            break;\n        }\n\n        // Add there to the set.\n        if (set_insert(&zip->set, there))\n            // There's already a duplicate in the central directory! We'll just\n            // let this be and carry on.\n            set_free(&zip->set, there);\n    }\n\n    // Return true if name is in the central directory.\n    size_t len = strlen(name);\n    char *copy = set_alloc(&zip->set, NULL, len + 1);\n    strcpy(copy, name);\n    int found = set_found(&zip->set, copy);\n    set_free(&zip->set, copy);\n    return found;\n}",
          "fn_code_pos": [
            [
              461,
              0
            ],
            [
              506,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipAlreadyThere",
            "parameters": {
              "file": "zipFile",
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "local int zip64local_putValue(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T x, int nbByte) {\n    unsigned char buf[8];\n    int n;\n    for (n = 0; n < nbByte; n++)\n    {\n        buf[n] = (unsigned char)(x & 0xff);\n        x >>= 8;\n    }\n    if (x != 0)\n      {     /* data overflow - hack for ZIP64 (X Roche) */\n      for (n = 0; n < nbByte; n++)\n        {\n          buf[n] = 0xff;\n        }\n      }\n\n    if (ZWRITE64(*pzlib_filefunc_def,filestream,buf,(uLong)nbByte)!=(uLong)nbByte)\n        return ZIP_ERRNO;\n    else\n        return ZIP_OK;\n}",
          "fn_code_pos": [
            [
              517,
              0
            ],
            [
              537,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zip64local_putValue",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_32_def",
              "filestream": "voidpf",
              "x": "ZPOS64_T",
              "nbByte": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void zip64local_putValue_inmemory (void* dest, ZPOS64_T x, int nbByte) {\n    unsigned char* buf=(unsigned char*)dest;\n    int n;\n    for (n = 0; n < nbByte; n++) {\n        buf[n] = (unsigned char)(x & 0xff);\n        x >>= 8;\n    }\n\n    if (x != 0)\n    {     /* data overflow - hack for ZIP64 */\n       for (n = 0; n < nbByte; n++)\n       {\n          buf[n] = 0xff;\n       }\n    }\n}",
          "fn_code_pos": [
            [
              539,
              0
            ],
            [
              554,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zip64local_putValue_inmemory",
            "parameters": {
              "dest": "void",
              "x": "ZPOS64_T",
              "nbByte": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local uLong zip64local_TmzDateToDosDate(const tm_zip* ptm) {\n    uLong year = (uLong)ptm->tm_year;\n    if (year>=1980)\n        year-=1980;\n    else if (year>=80)\n        year-=80;\n    return\n      (uLong) (((uLong)(ptm->tm_mday) + (32 * (uLong)(ptm->tm_mon+1)) + (512 * year)) << 16) |\n        (((uLong)ptm->tm_sec/2) + (32 * (uLong)ptm->tm_min) + (2048 * (uLong)ptm->tm_hour));\n}",
          "fn_code_pos": [
            [
              559,
              0
            ],
            [
              568,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zip64local_TmzDateToDosDate",
            "parameters": {
              "ptm": "tm_zip"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int zip64local_getByte(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, int* pi) {\n    unsigned char c;\n    int err = (int)ZREAD64(*pzlib_filefunc_def,filestream,&c,1);\n    if (err==1)\n    {\n        *pi = (int)c;\n        return ZIP_OK;\n    }\n    else\n    {\n        if (ZERROR64(*pzlib_filefunc_def,filestream))\n            return ZIP_ERRNO;\n        else\n            return ZIP_EOF;\n    }\n}",
          "fn_code_pos": [
            [
              573,
              0
            ],
            [
              588,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zip64local_getByte",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_32_def",
              "filestream": "voidpf",
              "pi": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int zip64local_getShort(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX) {\n    uLong x ;\n    int i = 0;\n    int err;\n\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x = (uLong)i;\n\n    if (err==ZIP_OK)\n        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x += ((uLong)i)<<8;\n\n    if (err==ZIP_OK)\n        *pX = x;\n    else\n        *pX = 0;\n    return err;\n}",
          "fn_code_pos": [
            [
              594,
              0
            ],
            [
              611,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zip64local_getShort",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_32_def",
              "filestream": "voidpf",
              "pX": "uLong"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int zip64local_getLong(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX) {\n    uLong x ;\n    int i = 0;\n    int err;\n\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x = (uLong)i;\n\n    if (err==ZIP_OK)\n        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x += ((uLong)i)<<8;\n\n    if (err==ZIP_OK)\n        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x += ((uLong)i)<<16;\n\n    if (err==ZIP_OK)\n        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n    x += ((uLong)i)<<24;\n\n    if (err==ZIP_OK)\n        *pX = x;\n    else\n        *pX = 0;\n    return err;\n}",
          "fn_code_pos": [
            [
              613,
              0
            ],
            [
              638,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zip64local_getLong",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_32_def",
              "filestream": "voidpf",
              "pX": "uLong"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int zip64local_getLong64(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T *pX) {\n  ZPOS64_T x;\n  int i = 0;\n  int err;\n\n  err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n  x = (ZPOS64_T)i;\n\n  if (err==ZIP_OK)\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n  x += ((ZPOS64_T)i)<<8;\n\n  if (err==ZIP_OK)\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n  x += ((ZPOS64_T)i)<<16;\n\n  if (err==ZIP_OK)\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n  x += ((ZPOS64_T)i)<<24;\n\n  if (err==ZIP_OK)\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n  x += ((ZPOS64_T)i)<<32;\n\n  if (err==ZIP_OK)\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n  x += ((ZPOS64_T)i)<<40;\n\n  if (err==ZIP_OK)\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n  x += ((ZPOS64_T)i)<<48;\n\n  if (err==ZIP_OK)\n    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);\n  x += ((ZPOS64_T)i)<<56;\n\n  if (err==ZIP_OK)\n    *pX = x;\n  else\n    *pX = 0;\n\n  return err;\n}",
          "fn_code_pos": [
            [
              641,
              0
            ],
            [
              683,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zip64local_getLong64",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_32_def",
              "filestream": "voidpf",
              "pX": "ZPOS64_T"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local ZPOS64_T zip64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream) {\n  unsigned char* buf;\n  ZPOS64_T uSizeFile;\n  ZPOS64_T uBackRead;\n  ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */\n  ZPOS64_T uPosFound=0;\n\n  if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)\n    return 0;\n\n\n  uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);\n\n  if (uMaxBack>uSizeFile)\n    uMaxBack = uSizeFile;\n\n  buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);\n  if (buf==NULL)\n    return 0;\n\n  uBackRead = 4;\n  while (uBackRead<uMaxBack)\n  {\n    uLong uReadSize;\n    ZPOS64_T uReadPos ;\n    int i;\n    if (uBackRead+BUFREADCOMMENT>uMaxBack)\n      uBackRead = uMaxBack;\n    else\n      uBackRead+=BUFREADCOMMENT;\n    uReadPos = uSizeFile-uBackRead ;\n\n    uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?\n      (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);\n    if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n      break;\n\n    if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)\n      break;\n\n    for (i=(int)uReadSize-3; (i--)>0;)\n      if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&\n        ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))\n      {\n        uPosFound = uReadPos+(unsigned)i;\n        break;\n      }\n\n    if (uPosFound!=0)\n      break;\n  }\n  free(buf);\n  return uPosFound;\n}",
          "fn_code_pos": [
            [
              692,
              0
            ],
            [
              745,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zip64local_SearchCentralDir",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_32_def",
              "filestream": "voidpf"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local ZPOS64_T zip64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream) {\n  unsigned char* buf;\n  ZPOS64_T uSizeFile;\n  ZPOS64_T uBackRead;\n  ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */\n  ZPOS64_T uPosFound=0;\n  uLong uL;\n  ZPOS64_T relativeOffset;\n\n  if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)\n    return 0;\n\n  uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);\n\n  if (uMaxBack>uSizeFile)\n    uMaxBack = uSizeFile;\n\n  buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);\n  if (buf==NULL)\n    return 0;\n\n  uBackRead = 4;\n  while (uBackRead<uMaxBack)\n  {\n    uLong uReadSize;\n    ZPOS64_T uReadPos;\n    int i;\n    if (uBackRead+BUFREADCOMMENT>uMaxBack)\n      uBackRead = uMaxBack;\n    else\n      uBackRead+=BUFREADCOMMENT;\n    uReadPos = uSizeFile-uBackRead ;\n\n    uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?\n      (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);\n    if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n      break;\n\n    if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)\n      break;\n\n    for (i=(int)uReadSize-3; (i--)>0;)\n    {\n      // Signature \"0x07064b50\" Zip64 end of central directory locator\n      if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) && ((*(buf+i+2))==0x06) && ((*(buf+i+3))==0x07))\n      {\n        uPosFound = uReadPos+(unsigned)i;\n        break;\n      }\n    }\n\n      if (uPosFound!=0)\n        break;\n  }\n\n  free(buf);\n  if (uPosFound == 0)\n    return 0;\n\n  /* Zip64 end of central directory locator */\n  if (ZSEEK64(*pzlib_filefunc_def,filestream, uPosFound,ZLIB_FILEFUNC_SEEK_SET)!=0)\n    return 0;\n\n  /* the signature, already checked */\n  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)\n    return 0;\n\n  /* number of the disk with the start of the zip64 end of central directory */\n  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)\n    return 0;\n  if (uL != 0)\n    return 0;\n\n  /* relative offset of the zip64 end of central directory record */\n  if (zip64local_getLong64(pzlib_filefunc_def,filestream,&relativeOffset)!=ZIP_OK)\n    return 0;\n\n  /* total number of disks */\n  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)\n    return 0;\n  if (uL != 1)\n    return 0;\n\n  /* Goto Zip64 end of central directory record */\n  if (ZSEEK64(*pzlib_filefunc_def,filestream, relativeOffset,ZLIB_FILEFUNC_SEEK_SET)!=0)\n    return 0;\n\n  /* the signature */\n  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)\n    return 0;\n\n  if (uL != 0x06064b50) // signature of 'Zip64 end of central directory'\n    return 0;\n\n  return relativeOffset;\n}",
          "fn_code_pos": [
            [
              751,
              0
            ],
            [
              846,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zip64local_SearchCentralDir64",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_32_def",
              "filestream": "voidpf"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int LoadCentralDirectoryRecord(zip64_internal* pziinit) {\n  int err=ZIP_OK;\n  ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/\n\n  ZPOS64_T size_central_dir;     /* size of the central directory  */\n  ZPOS64_T offset_central_dir;   /* offset of start of central directory */\n  ZPOS64_T central_pos;\n  uLong uL;\n\n  uLong number_disk;          /* number of the current disk, used for\n                              spanning ZIP, unsupported, always 0*/\n  uLong number_disk_with_CD;  /* number of the disk with central dir, used\n                              for spanning ZIP, unsupported, always 0*/\n  ZPOS64_T number_entry;\n  ZPOS64_T number_entry_CD;      /* total number of entries in\n                                the central dir\n                                (same than number_entry on nospan) */\n  uLong VersionMadeBy;\n  uLong VersionNeeded;\n  uLong size_comment;\n\n  int hasZIP64Record = 0;\n\n  // check first if we find a ZIP64 record\n  central_pos = zip64local_SearchCentralDir64(&pziinit->z_filefunc,pziinit->filestream);\n  if(central_pos > 0)\n  {\n    hasZIP64Record = 1;\n  }\n  else if(central_pos == 0)\n  {\n    central_pos = zip64local_SearchCentralDir(&pziinit->z_filefunc,pziinit->filestream);\n  }\n\n/* disable to allow appending to empty ZIP archive\n        if (central_pos==0)\n            err=ZIP_ERRNO;\n*/\n\n  if(hasZIP64Record)\n  {\n    ZPOS64_T sizeEndOfCentralDirectory;\n    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)\n      err=ZIP_ERRNO;\n\n    /* the signature, already checked */\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* size of zip64 end of central directory record */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &sizeEndOfCentralDirectory)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* version made by */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionMadeBy)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* version needed to extract */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionNeeded)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* number of this disk */\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* number of the disk with the start of the central directory */\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* total number of entries in the central directory on this disk */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &number_entry)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* total number of entries in the central directory */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&number_entry_CD)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))\n      err=ZIP_BADZIPFILE;\n\n    /* size of the central directory */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&size_central_dir)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* offset of start of central directory with respect to the\n    starting disk number */\n    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&offset_central_dir)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    // TODO..\n    // read the comment from the standard central header.\n    size_comment = 0;\n  }\n  else\n  {\n    // Read End of central Directory info\n    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n      err=ZIP_ERRNO;\n\n    /* the signature, already checked */\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* number of this disk */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* number of the disk with the start of the central directory */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)\n      err=ZIP_ERRNO;\n\n    /* total number of entries in the central dir on this disk */\n    number_entry = 0;\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n    else\n      number_entry = uL;\n\n    /* total number of entries in the central dir */\n    number_entry_CD = 0;\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n    else\n      number_entry_CD = uL;\n\n    if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))\n      err=ZIP_BADZIPFILE;\n\n    /* size of the central directory */\n    size_central_dir = 0;\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n    else\n      size_central_dir = uL;\n\n    /* offset of start of central directory with respect to the starting disk number */\n    offset_central_dir = 0;\n    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)\n      err=ZIP_ERRNO;\n    else\n      offset_central_dir = uL;\n\n\n    /* zipfile global comment length */\n    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &size_comment)!=ZIP_OK)\n      err=ZIP_ERRNO;\n  }\n\n  if ((central_pos<offset_central_dir+size_central_dir) &&\n    (err==ZIP_OK))\n    err=ZIP_BADZIPFILE;\n\n  if (err!=ZIP_OK)\n  {\n    ZCLOSE64(pziinit->z_filefunc, pziinit->filestream);\n    return ZIP_ERRNO;\n  }\n\n  if (size_comment>0)\n  {\n    pziinit->globalcomment = (char*)ALLOC(size_comment+1);\n    if (pziinit->globalcomment)\n    {\n      size_comment = ZREAD64(pziinit->z_filefunc, pziinit->filestream, pziinit->globalcomment,size_comment);\n      pziinit->globalcomment[size_comment]=0;\n    }\n  }\n\n  byte_before_the_zipfile = central_pos - (offset_central_dir+size_central_dir);\n  pziinit->add_position_when_writing_offset = byte_before_the_zipfile;\n\n  {\n    ZPOS64_T size_central_dir_to_read = size_central_dir;\n    size_t buf_size = SIZEDATA_INDATABLOCK;\n    void* buf_read = (void*)ALLOC(buf_size);\n    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir + byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)\n      err=ZIP_ERRNO;\n\n    while ((size_central_dir_to_read>0) && (err==ZIP_OK))\n    {\n      ZPOS64_T read_this = SIZEDATA_INDATABLOCK;\n      if (read_this > size_central_dir_to_read)\n        read_this = size_central_dir_to_read;\n\n      if (ZREAD64(pziinit->z_filefunc, pziinit->filestream,buf_read,(uLong)read_this) != read_this)\n        err=ZIP_ERRNO;\n\n      if (err==ZIP_OK)\n        err = add_data_in_datablock(&pziinit->central_dir,buf_read, (uLong)read_this);\n\n      size_central_dir_to_read-=read_this;\n    }\n    free(buf_read);\n  }\n  pziinit->begin_pos = byte_before_the_zipfile;\n  pziinit->number_entry = number_entry_CD;\n\n  if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir+byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET) != 0)\n    err=ZIP_ERRNO;\n\n  return err;\n}",
          "fn_code_pos": [
            [
              848,
              0
            ],
            [
              1049,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LoadCentralDirectoryRecord",
            "parameters": {
              "pziinit": "zip64_internal"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "extern zipFile ZEXPORT zipOpen3(const void *pathname, int append, zipcharpc* globalcomment, zlib_filefunc64_32_def* pzlib_filefunc64_32_def) {\n    zip64_internal ziinit;\n    zip64_internal* zi;\n    int err=ZIP_OK;\n\n    ziinit.z_filefunc.zseek32_file = NULL;\n    ziinit.z_filefunc.ztell32_file = NULL;\n    if (pzlib_filefunc64_32_def==NULL)\n        fill_fopen64_filefunc(&ziinit.z_filefunc.zfile_func64);\n    else\n        ziinit.z_filefunc = *pzlib_filefunc64_32_def;\n\n    ziinit.filestream = ZOPEN64(ziinit.z_filefunc,\n                  pathname,\n                  (append == APPEND_STATUS_CREATE) ?\n                  (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_CREATE) :\n                    (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_EXISTING));\n\n    if (ziinit.filestream == NULL)\n        return NULL;\n\n    if (append == APPEND_STATUS_CREATEAFTER)\n        ZSEEK64(ziinit.z_filefunc,ziinit.filestream,0,SEEK_END);\n\n    ziinit.begin_pos = ZTELL64(ziinit.z_filefunc,ziinit.filestream);\n    ziinit.in_opened_file_inzip = 0;\n    ziinit.ci.stream_initialised = 0;\n    ziinit.number_entry = 0;\n    ziinit.add_position_when_writing_offset = 0;\n    init_linkedlist(&(ziinit.central_dir));\n    memset(&ziinit.set, 0, sizeof(set_t));  // make sure set appears dormant\n\n\n\n    zi = (zip64_internal*)ALLOC(sizeof(zip64_internal));\n    if (zi==NULL)\n    {\n        ZCLOSE64(ziinit.z_filefunc,ziinit.filestream);\n        return NULL;\n    }\n\n    /* now we add file in a zipfile */\n#    ifndef NO_ADDFILEINEXISTINGZIP\n    ziinit.globalcomment = NULL;\n    if (append == APPEND_STATUS_ADDINZIP)\n    {\n      // Read and Cache Central Directory Records\n      err = LoadCentralDirectoryRecord(&ziinit);\n    }\n\n    if (globalcomment)\n    {\n      *globalcomment = ziinit.globalcomment;\n    }\n#    endif /* !NO_ADDFILEINEXISTINGZIP*/\n\n    if (err != ZIP_OK)\n    {\n#    ifndef NO_ADDFILEINEXISTINGZIP\n        free(ziinit.globalcomment);\n#    endif /* !NO_ADDFILEINEXISTINGZIP*/\n        free(zi);\n        return NULL;\n    }\n    else\n    {\n        *zi = ziinit;\n        return (zipFile)zi;\n    }\n}",
          "fn_code_pos": [
            [
              1056,
              0
            ],
            [
              1125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpen3",
            "parameters": {
              "pathname": "void",
              "append": "int",
              "globalcomment": "zipcharpc",
              "pzlib_filefunc64_32_def": "zlib_filefunc64_32_def"
            },
            "return_type": "zipFile"
          }
        },
        {
          "fn_code": "extern zipFile ZEXPORT zipOpen2(const char *pathname, int append, zipcharpc* globalcomment, zlib_filefunc_def* pzlib_filefunc32_def) {\n    if (pzlib_filefunc32_def != NULL)\n    {\n        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;\n        fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill,pzlib_filefunc32_def);\n        return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);\n    }\n    else\n        return zipOpen3(pathname, append, globalcomment, NULL);\n}",
          "fn_code_pos": [
            [
              1127,
              0
            ],
            [
              1136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpen2",
            "parameters": {
              "pathname": "char",
              "append": "int",
              "globalcomment": "zipcharpc",
              "pzlib_filefunc32_def": "zlib_filefunc_def"
            },
            "return_type": "zipFile"
          }
        },
        {
          "fn_code": "extern zipFile ZEXPORT zipOpen2_64(const void *pathname, int append, zipcharpc* globalcomment, zlib_filefunc64_def* pzlib_filefunc_def) {\n    if (pzlib_filefunc_def != NULL)\n    {\n        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;\n        zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;\n        zlib_filefunc64_32_def_fill.ztell32_file = NULL;\n        zlib_filefunc64_32_def_fill.zseek32_file = NULL;\n        return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);\n    }\n    else\n        return zipOpen3(pathname, append, globalcomment, NULL);\n}",
          "fn_code_pos": [
            [
              1138,
              0
            ],
            [
              1149,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpen2_64",
            "parameters": {
              "pathname": "void",
              "append": "int",
              "globalcomment": "zipcharpc",
              "pzlib_filefunc_def": "zlib_filefunc64_def"
            },
            "return_type": "zipFile"
          }
        },
        {
          "fn_code": "extern zipFile ZEXPORT zipOpen(const char* pathname, int append) {\n    return zipOpen3((const void*)pathname,append,NULL,NULL);\n}",
          "fn_code_pos": [
            [
              1153,
              0
            ],
            [
              1155,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpen",
            "parameters": {
              "pathname": "char",
              "append": "int"
            },
            "return_type": "zipFile"
          }
        },
        {
          "fn_code": "extern zipFile ZEXPORT zipOpen64(const void* pathname, int append) {\n    return zipOpen3(pathname,append,NULL,NULL);\n}",
          "fn_code_pos": [
            [
              1157,
              0
            ],
            [
              1159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpen64",
            "parameters": {
              "pathname": "void",
              "append": "int"
            },
            "return_type": "zipFile"
          }
        },
        {
          "fn_code": "local int Write_LocalFileHeader(zip64_internal* zi, const char* filename, uInt size_extrafield_local, const void* extrafield_local) {\n  /* write the local header */\n  int err;\n  uInt size_filename = (uInt)strlen(filename);\n  uInt size_extrafield = size_extrafield_local;\n\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)LOCALHEADERMAGIC, 4);\n\n  if (err==ZIP_OK)\n  {\n    if(zi->ci.zip64)\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);/* version needed to extract */\n    else\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)20,2);/* version needed to extract */\n  }\n\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.flag,2);\n\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.method,2);\n\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.dosDate,4);\n\n  // CRC / Compressed size / Uncompressed size will be filled in later and rewritten later\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* crc 32, unknown */\n  if (err==ZIP_OK)\n  {\n    if(zi->ci.zip64)\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); /* compressed size, unknown */\n    else\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* compressed size, unknown */\n  }\n  if (err==ZIP_OK)\n  {\n    if(zi->ci.zip64)\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); /* uncompressed size, unknown */\n    else\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* uncompressed size, unknown */\n  }\n\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_filename,2);\n\n  if(zi->ci.zip64)\n  {\n    size_extrafield += 20;\n  }\n\n  if (err==ZIP_OK)\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_extrafield,2);\n\n  if ((err==ZIP_OK) && (size_filename > 0))\n  {\n    if (ZWRITE64(zi->z_filefunc,zi->filestream,filename,size_filename)!=size_filename)\n      err = ZIP_ERRNO;\n  }\n\n  if ((err==ZIP_OK) && (size_extrafield_local > 0))\n  {\n    if (ZWRITE64(zi->z_filefunc, zi->filestream, extrafield_local, size_extrafield_local) != size_extrafield_local)\n      err = ZIP_ERRNO;\n  }\n\n\n  if ((err==ZIP_OK) && (zi->ci.zip64))\n  {\n      // write the Zip64 extended info\n      short HeaderID = 1;\n      short DataSize = 16;\n      ZPOS64_T CompressedSize = 0;\n      ZPOS64_T UncompressedSize = 0;\n\n      // Remember position of Zip64 extended info for the local file header. (needed when we update size after done with file)\n      zi->ci.pos_zip64extrainfo = ZTELL64(zi->z_filefunc,zi->filestream);\n\n      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)HeaderID,2);\n      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)DataSize,2);\n\n      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)UncompressedSize,8);\n      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)CompressedSize,8);\n  }\n\n  return err;\n}",
          "fn_code_pos": [
            [
              1161,
              0
            ],
            [
              1247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Write_LocalFileHeader",
            "parameters": {
              "zi": "zip64_internal",
              "filename": "char",
              "size_extrafield_local": "uInt",
              "extrafield_local": "void"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "extern int ZEXPORT zipOpenNewFileInZip4(zipFile file, const char* filename, const zip_fileinfo* zipfi,\n                                        const void* extrafield_local, uInt size_extrafield_local,\n                                        const void* extrafield_global, uInt size_extrafield_global,\n                                        const char* comment, int method, int level, int raw,\n                                        int windowBits,int memLevel, int strategy,\n                                        const char* password, uLong crcForCrypting,\n                                        uLong versionMadeBy, uLong flagBase) {\n    return zipOpenNewFileInZip4_64(file, filename, zipfi,\n                                   extrafield_local, size_extrafield_local,\n                                   extrafield_global, size_extrafield_global,\n                                   comment, method, level, raw,\n                                   windowBits, memLevel, strategy,\n                                   password, crcForCrypting, versionMadeBy, flagBase, 0);\n}",
          "fn_code_pos": [
            [
              1476,
              0
            ],
            [
              1489,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpenNewFileInZip4",
            "parameters": {
              "file": "zipFile",
              "filename": "char",
              "zipfi": "zip_fileinfo",
              "extrafield_local": "void",
              "size_extrafield_local": "uInt",
              "extrafield_global": "void",
              "size_extrafield_global": "uInt",
              "comment": "char",
              "method": "int",
              "level": "int",
              "raw": "int",
              "windowBits": "int",
              "memLevel": "int",
              "strategy": "int",
              "password": "char",
              "crcForCrypting": "uLong",
              "versionMadeBy": "uLong",
              "flagBase": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT zipOpenNewFileInZip3(zipFile file, const char* filename, const zip_fileinfo* zipfi,\n                                        const void* extrafield_local, uInt size_extrafield_local,\n                                        const void* extrafield_global, uInt size_extrafield_global,\n                                        const char* comment, int method, int level, int raw,\n                                        int windowBits,int memLevel, int strategy,\n                                        const char* password, uLong crcForCrypting) {\n    return zipOpenNewFileInZip4_64(file, filename, zipfi,\n                                   extrafield_local, size_extrafield_local,\n                                   extrafield_global, size_extrafield_global,\n                                   comment, method, level, raw,\n                                   windowBits, memLevel, strategy,\n                                   password, crcForCrypting, VERSIONMADEBY, 0, 0);\n}",
          "fn_code_pos": [
            [
              1491,
              0
            ],
            [
              1503,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpenNewFileInZip3",
            "parameters": {
              "file": "zipFile",
              "filename": "char",
              "zipfi": "zip_fileinfo",
              "extrafield_local": "void",
              "size_extrafield_local": "uInt",
              "extrafield_global": "void",
              "size_extrafield_global": "uInt",
              "comment": "char",
              "method": "int",
              "level": "int",
              "raw": "int",
              "windowBits": "int",
              "memLevel": "int",
              "strategy": "int",
              "password": "char",
              "crcForCrypting": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT zipOpenNewFileInZip3_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,\n                                         const void* extrafield_local, uInt size_extrafield_local,\n                                         const void* extrafield_global, uInt size_extrafield_global,\n                                         const char* comment, int method, int level, int raw,\n                                         int windowBits,int memLevel, int strategy,\n                                         const char* password, uLong crcForCrypting, int zip64) {\n    return zipOpenNewFileInZip4_64(file, filename, zipfi,\n                                   extrafield_local, size_extrafield_local,\n                                   extrafield_global, size_extrafield_global,\n                                   comment, method, level, raw,\n                                   windowBits, memLevel, strategy,\n                                   password, crcForCrypting, VERSIONMADEBY, 0, zip64);\n}",
          "fn_code_pos": [
            [
              1505,
              0
            ],
            [
              1517,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpenNewFileInZip3_64",
            "parameters": {
              "file": "zipFile",
              "filename": "char",
              "zipfi": "zip_fileinfo",
              "extrafield_local": "void",
              "size_extrafield_local": "uInt",
              "extrafield_global": "void",
              "size_extrafield_global": "uInt",
              "comment": "char",
              "method": "int",
              "level": "int",
              "raw": "int",
              "windowBits": "int",
              "memLevel": "int",
              "strategy": "int",
              "password": "char",
              "crcForCrypting": "uLong",
              "zip64": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT zipOpenNewFileInZip2(zipFile file, const char* filename, const zip_fileinfo* zipfi,\n                                        const void* extrafield_local, uInt size_extrafield_local,\n                                        const void* extrafield_global, uInt size_extrafield_global,\n                                        const char* comment, int method, int level, int raw) {\n    return zipOpenNewFileInZip4_64(file, filename, zipfi,\n                                   extrafield_local, size_extrafield_local,\n                                   extrafield_global, size_extrafield_global,\n                                   comment, method, level, raw,\n                                   -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,\n                                   NULL, 0, VERSIONMADEBY, 0, 0);\n}",
          "fn_code_pos": [
            [
              1519,
              0
            ],
            [
              1529,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpenNewFileInZip2",
            "parameters": {
              "file": "zipFile",
              "filename": "char",
              "zipfi": "zip_fileinfo",
              "extrafield_local": "void",
              "size_extrafield_local": "uInt",
              "extrafield_global": "void",
              "size_extrafield_global": "uInt",
              "comment": "char",
              "method": "int",
              "level": "int",
              "raw": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT zipOpenNewFileInZip2_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,\n                                           const void* extrafield_local, uInt size_extrafield_local,\n                                           const void* extrafield_global, uInt size_extrafield_global,\n                                           const char* comment, int method, int level, int raw, int zip64) {\n    return zipOpenNewFileInZip4_64(file, filename, zipfi,\n                                   extrafield_local, size_extrafield_local,\n                                   extrafield_global, size_extrafield_global,\n                                   comment, method, level, raw,\n                                   -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,\n                                   NULL, 0, VERSIONMADEBY, 0, zip64);\n}",
          "fn_code_pos": [
            [
              1531,
              0
            ],
            [
              1541,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpenNewFileInZip2_64",
            "parameters": {
              "file": "zipFile",
              "filename": "char",
              "zipfi": "zip_fileinfo",
              "extrafield_local": "void",
              "size_extrafield_local": "uInt",
              "extrafield_global": "void",
              "size_extrafield_global": "uInt",
              "comment": "char",
              "method": "int",
              "level": "int",
              "raw": "int",
              "zip64": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT zipOpenNewFileInZip64(zipFile file, const char* filename, const zip_fileinfo* zipfi,\n                                         const void* extrafield_local, uInt size_extrafield_local,\n                                         const void*extrafield_global, uInt size_extrafield_global,\n                                         const char* comment, int method, int level, int zip64) {\n    return zipOpenNewFileInZip4_64(file, filename, zipfi,\n                                   extrafield_local, size_extrafield_local,\n                                   extrafield_global, size_extrafield_global,\n                                   comment, method, level, 0,\n                                   -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,\n                                   NULL, 0, VERSIONMADEBY, 0, zip64);\n}",
          "fn_code_pos": [
            [
              1543,
              0
            ],
            [
              1553,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpenNewFileInZip64",
            "parameters": {
              "file": "zipFile",
              "filename": "char",
              "zipfi": "zip_fileinfo",
              "extrafield_local": "void",
              "size_extrafield_local": "uInt",
              "extrafield_global": "void",
              "size_extrafield_global": "uInt",
              "comment": "char",
              "method": "int",
              "level": "int",
              "zip64": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT zipOpenNewFileInZip(zipFile file, const char* filename, const zip_fileinfo* zipfi,\n                                       const void* extrafield_local, uInt size_extrafield_local,\n                                       const void*extrafield_global, uInt size_extrafield_global,\n                                       const char* comment, int method, int level) {\n    return zipOpenNewFileInZip4_64(file, filename, zipfi,\n                                   extrafield_local, size_extrafield_local,\n                                   extrafield_global, size_extrafield_global,\n                                   comment, method, level, 0,\n                                   -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,\n                                   NULL, 0, VERSIONMADEBY, 0, 0);\n}",
          "fn_code_pos": [
            [
              1555,
              0
            ],
            [
              1565,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpenNewFileInZip",
            "parameters": {
              "file": "zipFile",
              "filename": "char",
              "zipfi": "zip_fileinfo",
              "extrafield_local": "void",
              "size_extrafield_local": "uInt",
              "extrafield_global": "void",
              "size_extrafield_global": "uInt",
              "comment": "char",
              "method": "int",
              "level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "local int zip64FlushWriteBuffer(zip64_internal* zi) {\n    int err=ZIP_OK;\n\n    if (zi->ci.encrypt != 0)\n    {\n#ifndef NOCRYPT\n        uInt i;\n        int t;\n        for (i=0;i<zi->ci.pos_in_buffered_data;i++)\n            zi->ci.buffered_data[i] = zencode(zi->ci.keys, zi->ci.pcrc_32_tab, zi->ci.buffered_data[i],t);\n#endif\n    }\n\n    if (ZWRITE64(zi->z_filefunc,zi->filestream,zi->ci.buffered_data,zi->ci.pos_in_buffered_data) != zi->ci.pos_in_buffered_data)\n      err = ZIP_ERRNO;\n\n    zi->ci.totalCompressedData += zi->ci.pos_in_buffered_data;\n\n#ifdef HAVE_BZIP2\n    if(zi->ci.method == Z_BZIP2ED)\n    {\n      zi->ci.totalUncompressedData += zi->ci.bstream.total_in_lo32;\n      zi->ci.bstream.total_in_lo32 = 0;\n      zi->ci.bstream.total_in_hi32 = 0;\n    }\n    else\n#endif\n    {\n      zi->ci.totalUncompressedData += zi->ci.stream.total_in;\n      zi->ci.stream.total_in = 0;\n    }\n\n\n    zi->ci.pos_in_buffered_data = 0;\n\n    return err;\n}",
          "fn_code_pos": [
            [
              1567,
              0
            ],
            [
              1603,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zip64FlushWriteBuffer",
            "parameters": {
              "zi": "zip64_internal"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "extern int ZEXPORT zipWriteInFileInZip(zipFile file, const void* buf, unsigned int len) {\n    zip64_internal* zi;\n    int err=ZIP_OK;\n\n    if (file == NULL)\n        return ZIP_PARAMERROR;\n    zi = (zip64_internal*)file;\n\n    if (zi->in_opened_file_inzip == 0)\n        return ZIP_PARAMERROR;\n\n    zi->ci.crc32 = crc32(zi->ci.crc32,buf,(uInt)len);\n\n#ifdef HAVE_BZIP2\n    if(zi->ci.method == Z_BZIP2ED && (!zi->ci.raw))\n    {\n      zi->ci.bstream.next_in = (void*)buf;\n      zi->ci.bstream.avail_in = len;\n      err = BZ_RUN_OK;\n\n      while ((err==BZ_RUN_OK) && (zi->ci.bstream.avail_in>0))\n      {\n        if (zi->ci.bstream.avail_out == 0)\n        {\n          if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)\n            err = ZIP_ERRNO;\n          zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;\n          zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;\n        }\n\n\n        if(err != BZ_RUN_OK)\n          break;\n\n        if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))\n        {\n          uLong uTotalOutBefore_lo = zi->ci.bstream.total_out_lo32;\n//          uLong uTotalOutBefore_hi = zi->ci.bstream.total_out_hi32;\n          err=BZ2_bzCompress(&zi->ci.bstream,  BZ_RUN);\n\n          zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore_lo) ;\n        }\n      }\n\n      if(err == BZ_RUN_OK)\n        err = ZIP_OK;\n    }\n    else\n#endif\n    {\n      zi->ci.stream.next_in = buf;\n      zi->ci.stream.avail_in = len;\n\n      while ((err==ZIP_OK) && (zi->ci.stream.avail_in>0))\n      {\n          if (zi->ci.stream.avail_out == 0)\n          {\n              if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)\n                  err = ZIP_ERRNO;\n              zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;\n              zi->ci.stream.next_out = zi->ci.buffered_data;\n          }\n\n\n          if(err != ZIP_OK)\n              break;\n\n          if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))\n          {\n              uLong uTotalOutBefore = zi->ci.stream.total_out;\n              err=deflate(&zi->ci.stream,  Z_NO_FLUSH);\n\n              zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;\n          }\n          else\n          {\n              uInt copy_this,i;\n              if (zi->ci.stream.avail_in < zi->ci.stream.avail_out)\n                  copy_this = zi->ci.stream.avail_in;\n              else\n                  copy_this = zi->ci.stream.avail_out;\n\n              for (i = 0; i < copy_this; i++)\n                  *(((char*)zi->ci.stream.next_out)+i) =\n                      *(((const char*)zi->ci.stream.next_in)+i);\n              {\n                  zi->ci.stream.avail_in -= copy_this;\n                  zi->ci.stream.avail_out-= copy_this;\n                  zi->ci.stream.next_in+= copy_this;\n                  zi->ci.stream.next_out+= copy_this;\n                  zi->ci.stream.total_in+= copy_this;\n                  zi->ci.stream.total_out+= copy_this;\n                  zi->ci.pos_in_buffered_data += copy_this;\n              }\n          }\n      }// while(...)\n    }\n\n    return err;\n}",
          "fn_code_pos": [
            [
              1605,
              0
            ],
            [
              1704,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipWriteInFileInZip",
            "parameters": {
              "file": "zipFile",
              "buf": "void",
              "len": "unsigned int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT zipCloseFileInZipRaw(zipFile file, uLong uncompressed_size, uLong crc32) {\n    return zipCloseFileInZipRaw64 (file, uncompressed_size, crc32);\n}",
          "fn_code_pos": [
            [
              1706,
              0
            ],
            [
              1708,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipCloseFileInZipRaw",
            "parameters": {
              "file": "zipFile",
              "uncompressed_size": "uLong",
              "crc32": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT zipCloseFileInZipRaw64(zipFile file, ZPOS64_T uncompressed_size, uLong crc32) {\n    zip64_internal* zi;\n    ZPOS64_T compressed_size;\n    uLong invalidValue = 0xffffffff;\n    unsigned datasize = 0;\n    int err=ZIP_OK;\n\n    if (file == NULL)\n        return ZIP_PARAMERROR;\n    zi = (zip64_internal*)file;\n\n    if (zi->in_opened_file_inzip == 0)\n        return ZIP_PARAMERROR;\n    zi->ci.stream.avail_in = 0;\n\n    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))\n                {\n                        while (err==ZIP_OK)\n                        {\n                                uLong uTotalOutBefore;\n                                if (zi->ci.stream.avail_out == 0)\n                                {\n                                        if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)\n                                                err = ZIP_ERRNO;\n                                        zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;\n                                        zi->ci.stream.next_out = zi->ci.buffered_data;\n                                }\n                                uTotalOutBefore = zi->ci.stream.total_out;\n                                err=deflate(&zi->ci.stream,  Z_FINISH);\n                                zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;\n                        }\n                }\n    else if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))\n    {\n#ifdef HAVE_BZIP2\n      err = BZ_FINISH_OK;\n      while (err==BZ_FINISH_OK)\n      {\n        uLong uTotalOutBefore;\n        if (zi->ci.bstream.avail_out == 0)\n        {\n          if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)\n            err = ZIP_ERRNO;\n          zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;\n          zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;\n        }\n        uTotalOutBefore = zi->ci.bstream.total_out_lo32;\n        err=BZ2_bzCompress(&zi->ci.bstream,  BZ_FINISH);\n        if(err == BZ_STREAM_END)\n          err = Z_STREAM_END;\n\n        zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore);\n      }\n\n      if(err == BZ_FINISH_OK)\n        err = ZIP_OK;\n#endif\n    }\n\n    if (err==Z_STREAM_END)\n        err=ZIP_OK; /* this is normal */\n\n    if ((zi->ci.pos_in_buffered_data>0) && (err==ZIP_OK))\n                {\n        if (zip64FlushWriteBuffer(zi)==ZIP_ERRNO)\n            err = ZIP_ERRNO;\n                }\n\n    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))\n    {\n        int tmp_err = deflateEnd(&zi->ci.stream);\n        if (err == ZIP_OK)\n            err = tmp_err;\n        zi->ci.stream_initialised = 0;\n    }\n#ifdef HAVE_BZIP2\n    else if((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))\n    {\n      int tmperr = BZ2_bzCompressEnd(&zi->ci.bstream);\n                        if (err==ZIP_OK)\n                                err = tmperr;\n                        zi->ci.stream_initialised = 0;\n    }\n#endif\n\n    if (!zi->ci.raw)\n    {\n        crc32 = (uLong)zi->ci.crc32;\n        uncompressed_size = zi->ci.totalUncompressedData;\n    }\n    compressed_size = zi->ci.totalCompressedData;\n\n#    ifndef NOCRYPT\n    compressed_size += zi->ci.crypt_header_size;\n#    endif\n\n    // update Current Item crc and sizes,\n    if(compressed_size >= 0xffffffff || uncompressed_size >= 0xffffffff || zi->ci.pos_local_header >= 0xffffffff)\n    {\n      /*version Made by*/\n      zip64local_putValue_inmemory(zi->ci.central_header+4,(uLong)45,2);\n      /*version needed*/\n      zip64local_putValue_inmemory(zi->ci.central_header+6,(uLong)45,2);\n\n    }\n\n    zip64local_putValue_inmemory(zi->ci.central_header+16,crc32,4); /*crc*/\n\n\n    if(compressed_size >= 0xffffffff)\n      zip64local_putValue_inmemory(zi->ci.central_header+20, invalidValue,4); /*compr size*/\n    else\n      zip64local_putValue_inmemory(zi->ci.central_header+20, compressed_size,4); /*compr size*/\n\n    /// set internal file attributes field\n    if (zi->ci.stream.data_type == Z_ASCII)\n        zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)Z_ASCII,2);\n\n    if(uncompressed_size >= 0xffffffff)\n      zip64local_putValue_inmemory(zi->ci.central_header+24, invalidValue,4); /*uncompr size*/\n    else\n      zip64local_putValue_inmemory(zi->ci.central_header+24, uncompressed_size,4); /*uncompr size*/\n\n    // Add ZIP64 extra info field for uncompressed size\n    if(uncompressed_size >= 0xffffffff)\n      datasize += 8;\n\n    // Add ZIP64 extra info field for compressed size\n    if(compressed_size >= 0xffffffff)\n      datasize += 8;\n\n    // Add ZIP64 extra info field for relative offset to local file header of current file\n    if(zi->ci.pos_local_header >= 0xffffffff)\n      datasize += 8;\n\n    if(datasize > 0)\n    {\n      char* p = NULL;\n\n      if((uLong)(datasize + 4) > zi->ci.size_centralExtraFree)\n      {\n        // we cannot write more data to the buffer that we have room for.\n        return ZIP_BADZIPFILE;\n      }\n\n      p = zi->ci.central_header + zi->ci.size_centralheader;\n\n      // Add Extra Information Header for 'ZIP64 information'\n      zip64local_putValue_inmemory(p, 0x0001, 2); // HeaderID\n      p += 2;\n      zip64local_putValue_inmemory(p, datasize, 2); // DataSize\n      p += 2;\n\n      if(uncompressed_size >= 0xffffffff)\n      {\n        zip64local_putValue_inmemory(p, uncompressed_size, 8);\n        p += 8;\n      }\n\n      if(compressed_size >= 0xffffffff)\n      {\n        zip64local_putValue_inmemory(p, compressed_size, 8);\n        p += 8;\n      }\n\n      if(zi->ci.pos_local_header >= 0xffffffff)\n      {\n        zip64local_putValue_inmemory(p, zi->ci.pos_local_header, 8);\n        p += 8;\n      }\n\n      // Update how much extra free space we got in the memory buffer\n      // and increase the centralheader size so the new ZIP64 fields are included\n      // ( 4 below is the size of HeaderID and DataSize field )\n      zi->ci.size_centralExtraFree -= datasize + 4;\n      zi->ci.size_centralheader += datasize + 4;\n\n      // Update the extra info size field\n      zi->ci.size_centralExtra += datasize + 4;\n      zip64local_putValue_inmemory(zi->ci.central_header+30,(uLong)zi->ci.size_centralExtra,2);\n    }\n\n    if (err==ZIP_OK)\n        err = add_data_in_datablock(&zi->central_dir, zi->ci.central_header, (uLong)zi->ci.size_centralheader);\n\n    free(zi->ci.central_header);\n\n    if (err==ZIP_OK)\n    {\n        // Update the LocalFileHeader with the new values.\n\n        ZPOS64_T cur_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);\n\n        if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_local_header + 14,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            err = ZIP_ERRNO;\n\n        if (err==ZIP_OK)\n            err = zip64local_putValue(&zi->z_filefunc,zi->filestream,crc32,4); /* crc 32, unknown */\n\n        if(uncompressed_size >= 0xffffffff || compressed_size >= 0xffffffff )\n        {\n          if(zi->ci.pos_zip64extrainfo > 0)\n          {\n            // Update the size in the ZIP64 extended field.\n            if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_zip64extrainfo + 4,ZLIB_FILEFUNC_SEEK_SET)!=0)\n              err = ZIP_ERRNO;\n\n            if (err==ZIP_OK) /* compressed size, unknown */\n              err = zip64local_putValue(&zi->z_filefunc, zi->filestream, uncompressed_size, 8);\n\n            if (err==ZIP_OK) /* uncompressed size, unknown */\n              err = zip64local_putValue(&zi->z_filefunc, zi->filestream, compressed_size, 8);\n          }\n          else\n              err = ZIP_BADZIPFILE; // Caller passed zip64 = 0, so no room for zip64 info -> fatal\n        }\n        else\n        {\n          if (err==ZIP_OK) /* compressed size, unknown */\n              err = zip64local_putValue(&zi->z_filefunc,zi->filestream,compressed_size,4);\n\n          if (err==ZIP_OK) /* uncompressed size, unknown */\n              err = zip64local_putValue(&zi->z_filefunc,zi->filestream,uncompressed_size,4);\n        }\n\n        if (ZSEEK64(zi->z_filefunc,zi->filestream, cur_pos_inzip,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            err = ZIP_ERRNO;\n    }\n\n    zi->number_entry ++;\n    zi->in_opened_file_inzip = 0;\n\n    return err;\n}",
          "fn_code_pos": [
            [
              1710,
              0
            ],
            [
              1943,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipCloseFileInZipRaw64",
            "parameters": {
              "file": "zipFile",
              "uncompressed_size": "ZPOS64_T",
              "crc32": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT zipCloseFileInZip(zipFile file) {\n    return zipCloseFileInZipRaw (file,0,0);\n}",
          "fn_code_pos": [
            [
              1945,
              0
            ],
            [
              1947,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipCloseFileInZip",
            "parameters": {
              "file": "zipFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "local int Write_Zip64EndOfCentralDirectoryLocator(zip64_internal* zi, ZPOS64_T zip64eocd_pos_inzip) {\n  int err = ZIP_OK;\n  ZPOS64_T pos = zip64eocd_pos_inzip - zi->add_position_when_writing_offset;\n\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDLOCHEADERMAGIC,4);\n\n  /*num disks*/\n    if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);\n\n  /*relative offset*/\n    if (err==ZIP_OK) /* Relative offset to the Zip64EndOfCentralDirectory */\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, pos,8);\n\n  /*total disks*/ /* Do not support spawning of disk so always say 1 here*/\n    if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)1,4);\n\n    return err;\n}",
          "fn_code_pos": [
            [
              1949,
              0
            ],
            [
              1968,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Write_Zip64EndOfCentralDirectoryLocator",
            "parameters": {
              "zi": "zip64_internal",
              "zip64eocd_pos_inzip": "ZPOS64_T"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int Write_Zip64EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip) {\n  int err = ZIP_OK;\n\n  uLong Zip64DataSize = 44;\n\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDHEADERMAGIC,4);\n\n  if (err==ZIP_OK) /* size of this 'zip64 end of central directory' */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)Zip64DataSize,8); // why ZPOS64_T of this ?\n\n  if (err==ZIP_OK) /* version made by */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);\n\n  if (err==ZIP_OK) /* version needed */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);\n\n  if (err==ZIP_OK) /* number of this disk */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);\n\n  if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);\n\n  if (err==ZIP_OK) /* total number of entries in the central dir on this disk */\n    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);\n\n  if (err==ZIP_OK) /* total number of entries in the central dir */\n    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);\n\n  if (err==ZIP_OK) /* size of the central directory */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)size_centraldir,8);\n\n  if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */\n  {\n    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (ZPOS64_T)pos,8);\n  }\n  return err;\n}",
          "fn_code_pos": [
            [
              1970,
              0
            ],
            [
              2007,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Write_Zip64EndOfCentralDirectoryRecord",
            "parameters": {
              "zi": "zip64_internal",
              "size_centraldir": "uLong",
              "centraldir_pos_inzip": "ZPOS64_T"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int Write_EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip) {\n  int err = ZIP_OK;\n\n  /*signature*/\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ENDHEADERMAGIC,4);\n\n  if (err==ZIP_OK) /* number of this disk */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);\n\n  if (err==ZIP_OK) /* number of the disk with the start of the central directory */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);\n\n  if (err==ZIP_OK) /* total number of entries in the central dir on this disk */\n  {\n    {\n      if(zi->number_entry >= 0xFFFF)\n        err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); // use value in ZIP64 record\n      else\n        err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);\n    }\n  }\n\n  if (err==ZIP_OK) /* total number of entries in the central dir */\n  {\n    if(zi->number_entry >= 0xFFFF)\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); // use value in ZIP64 record\n    else\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);\n  }\n\n  if (err==ZIP_OK) /* size of the central directory */\n    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_centraldir,4);\n\n  if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */\n  {\n    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;\n    if(pos >= 0xffffffff)\n    {\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)0xffffffff,4);\n    }\n    else\n      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)(centraldir_pos_inzip - zi->add_position_when_writing_offset),4);\n  }\n\n   return err;\n}",
          "fn_code_pos": [
            [
              2009,
              0
            ],
            [
              2054,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Write_EndOfCentralDirectoryRecord",
            "parameters": {
              "zi": "zip64_internal",
              "size_centraldir": "uLong",
              "centraldir_pos_inzip": "ZPOS64_T"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int Write_GlobalComment(zip64_internal* zi, const char* global_comment) {\n  int err = ZIP_OK;\n  uInt size_global_comment = 0;\n\n  if(global_comment != NULL)\n    size_global_comment = (uInt)strlen(global_comment);\n\n  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_global_comment,2);\n\n  if (err == ZIP_OK && size_global_comment > 0)\n  {\n    if (ZWRITE64(zi->z_filefunc,zi->filestream, global_comment, size_global_comment) != size_global_comment)\n      err = ZIP_ERRNO;\n  }\n  return err;\n}",
          "fn_code_pos": [
            [
              2056,
              0
            ],
            [
              2071,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Write_GlobalComment",
            "parameters": {
              "zi": "zip64_internal",
              "global_comment": "char"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "extern int ZEXPORT zipClose(zipFile file, const char* global_comment) {\n    zip64_internal* zi;\n    int err = 0;\n    uLong size_centraldir = 0;\n    ZPOS64_T centraldir_pos_inzip;\n    ZPOS64_T pos;\n\n    if (file == NULL)\n        return ZIP_PARAMERROR;\n\n    zi = (zip64_internal*)file;\n\n    if (zi->in_opened_file_inzip == 1)\n    {\n        err = zipCloseFileInZip (file);\n    }\n\n#ifndef NO_ADDFILEINEXISTINGZIP\n    if (global_comment==NULL)\n        global_comment = zi->globalcomment;\n#endif\n\n    centraldir_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);\n\n    if (err==ZIP_OK)\n    {\n        linkedlist_datablock_internal* ldi = zi->central_dir.first_block;\n        while (ldi!=NULL)\n        {\n            if ((err==ZIP_OK) && (ldi->filled_in_this_block>0))\n            {\n                if (ZWRITE64(zi->z_filefunc,zi->filestream, ldi->data, ldi->filled_in_this_block) != ldi->filled_in_this_block)\n                    err = ZIP_ERRNO;\n            }\n\n            size_centraldir += ldi->filled_in_this_block;\n            ldi = ldi->next_datablock;\n        }\n    }\n    free_linkedlist(&(zi->central_dir));\n\n    set_end(&zi->set);          // set was zeroed, so this is safe\n\n    pos = centraldir_pos_inzip - zi->add_position_when_writing_offset;\n    if(pos >= 0xffffffff || zi->number_entry >= 0xFFFF)\n    {\n      ZPOS64_T Zip64EOCDpos = ZTELL64(zi->z_filefunc,zi->filestream);\n      Write_Zip64EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);\n\n      Write_Zip64EndOfCentralDirectoryLocator(zi, Zip64EOCDpos);\n    }\n\n    if (err==ZIP_OK)\n      err = Write_EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);\n\n    if(err == ZIP_OK)\n      err = Write_GlobalComment(zi, global_comment);\n\n    if (ZCLOSE64(zi->z_filefunc,zi->filestream) != 0)\n        if (err == ZIP_OK)\n            err = ZIP_ERRNO;\n\n#ifndef NO_ADDFILEINEXISTINGZIP\n    free(zi->globalcomment);\n#endif\n    free(zi);\n\n    return err;\n}",
          "fn_code_pos": [
            [
              2073,
              0
            ],
            [
              2141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipClose",
            "parameters": {
              "file": "zipFile",
              "global_comment": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT zipRemoveExtraInfoBlock(char* pData, int* dataLen, short sHeader) {\n  char* p = pData;\n  int size = 0;\n  char* pNewHeader;\n  char* pTmp;\n  short header;\n  short dataSize;\n\n  int retVal = ZIP_OK;\n\n  if(pData == NULL || dataLen == NULL || *dataLen < 4)\n    return ZIP_PARAMERROR;\n\n  pNewHeader = (char*)ALLOC((unsigned)*dataLen);\n  pTmp = pNewHeader;\n\n  while(p < (pData + *dataLen))\n  {\n    header = *(short*)p;\n    dataSize = *(((short*)p)+1);\n\n    if( header == sHeader ) // Header found.\n    {\n      p += dataSize + 4; // skip it. do not copy to temp buffer\n    }\n    else\n    {\n      // Extra Info block should not be removed, So copy it to the temp buffer.\n      memcpy(pTmp, p, dataSize + 4);\n      p += dataSize + 4;\n      size += dataSize + 4;\n    }\n\n  }\n\n  if(size < *dataLen)\n  {\n    // clean old extra info block.\n    memset(pData,0, *dataLen);\n\n    // copy the new extra info block over the old\n    if(size > 0)\n      memcpy(pData, pNewHeader, size);\n\n    // set the new extra info size\n    *dataLen = size;\n\n    retVal = ZIP_OK;\n  }\n  else\n    retVal = ZIP_ERRNO;\n\n  free(pNewHeader);\n\n  return retVal;\n}",
          "fn_code_pos": [
            [
              2143,
              0
            ],
            [
              2198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipRemoveExtraInfoBlock",
            "parameters": {
              "pData": "char",
              "dataLen": "int",
              "sHeader": "short"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "allocate_new_datablock(void)",
          "fn_dec_pos": [
            [
              203,
              37
            ],
            [
              203,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "block_central_name(block_t *block, set_t *set)",
          "fn_dec_pos": [
            [
              406,
              12
            ],
            [
              406,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "block_central_name",
            "parameters": {
              "block": "block_t",
              "set": "set_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "zipOpenNewFileInZip4_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,\n                                           const void* extrafield_local, uInt size_extrafield_local,\n                                           const void* extrafield_global, uInt size_extrafield_global,\n                                           const char* comment, int method, int level, int raw,\n                                           int windowBits,int memLevel, int strategy,\n                                           const char* password, uLong crcForCrypting,\n                                           uLong versionMadeBy, uLong flagBase, int zip64)",
          "fn_dec_pos": [
            [
              1257,
              19
            ],
            [
              1263,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpenNewFileInZip4_64",
            "parameters": {
              "file": "zipFile",
              "filename": "char",
              "zipfi": "zip_fileinfo",
              "extrafield_local": "void",
              "size_extrafield_local": "uInt",
              "extrafield_global": "void",
              "size_extrafield_global": "uInt",
              "comment": "char",
              "method": "int",
              "level": "int",
              "raw": "int",
              "windowBits": "int",
              "memLevel": "int",
              "strategy": "int",
              "password": "char",
              "crcForCrypting": "uLong",
              "versionMadeBy": "uLong",
              "flagBase": "uLong",
              "zip64": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct linkedlist_datablock_internal_s\n{\n  struct linkedlist_datablock_internal_s* next_datablock;\n  uLong  avail_in_this_block;\n  uLong  filled_in_this_block;\n  uLong  unused; /* for future use and alignment */\n  unsigned char data[SIZEDATA_INDATABLOCK];\n} linkedlist_datablock_internal;",
          {
            "* next_datablock": "struct linkedlist_datablock_internal_s",
            "avail_in_this_block": "uLong",
            "filled_in_this_block": "uLong",
            "unused": "uLong",
            "data[SIZEDATA_INDATABLOCK]": "unsigned char"
          },
          "linkedlist_datablock_internal",
          [
            111,
            0
          ],
          [
            118,
            32
          ]
        ],
        [
          "typedef struct linkedlist_data_s\n{\n    linkedlist_datablock_internal* first_block;\n    linkedlist_datablock_internal* last_block;\n} linkedlist_data;",
          {
            "* first_block": "linkedlist_datablock_internal",
            "* last_block": "linkedlist_datablock_internal"
          },
          "linkedlist_data",
          [
            120,
            0
          ],
          [
            124,
            18
          ]
        ],
        [
          "typedef struct {\n    unsigned char *next;        // next byte in datablock data\n    size_t left;                // number of bytes left in data (at least)\n    linkedlist_datablock_internal *node;    // current datablock\n} block_t;",
          {
            "*next": "unsigned char",
            "left": "size_t",
            "*node": "linkedlist_datablock_internal"
          },
          "block_t",
          [
            133,
            0
          ],
          [
            137,
            10
          ]
        ],
        [
          "typedef struct\n{\n    z_stream stream;            /* zLib stream structure for inflate */\n#ifdef HAVE_BZIP2\n    bz_stream bstream;          /* bzLib stream structure for bziped */\n#endif\n\n    int  stream_initialised;    /* 1 is stream is initialised */\n    uInt pos_in_buffered_data;  /* last written byte in buffered_data */\n\n    ZPOS64_T pos_local_header;     /* offset of the local header of the file\n                                     currently writing */\n    char* central_header;       /* central header data for the current file */\n    uLong size_centralExtra;\n    uLong size_centralheader;   /* size of the central header for cur file */\n    uLong size_centralExtraFree; /* Extra bytes allocated to the centralheader but that are not used */\n    uLong flag;                 /* flag of the file currently writing */\n\n    int  method;                /* compression method of file currently wr.*/\n    int  raw;                   /* 1 for directly writing raw data */\n    Byte buffered_data[Z_BUFSIZE];/* buffer contain compressed data to be writ*/\n    uLong dosDate;\n    uLong crc32;\n    int  encrypt;\n    int  zip64;               /* Add ZIP64 extended information in the extra field */\n    ZPOS64_T pos_zip64extrainfo;\n    ZPOS64_T totalCompressedData;\n    ZPOS64_T totalUncompressedData;\n#ifndef NOCRYPT\n    unsigned long keys[3];     /* keys defining the pseudo-random sequence */\n    const z_crc_t* pcrc_32_tab;\n    unsigned crypt_header_size;\n#endif\n} curfile64_info;",
          {
            "stream": "z_stream",
            "bstream": "bz_stream",
            "stream_initialised": "int",
            "pos_in_buffered_data": "uInt",
            "pos_local_header": "ZPOS64_T",
            "* central_header": "char",
            "size_centralExtra": "uLong",
            "size_centralheader": "uLong",
            "size_centralExtraFree": "uLong",
            "flag": "uLong",
            "method": "int",
            "raw": "int",
            "buffered_data[Z_BUFSIZE]": "Byte",
            "dosDate": "uLong",
            "crc32": "uLong",
            "encrypt": "int",
            "zip64": "int",
            "pos_zip64extrainfo": "ZPOS64_T",
            "totalCompressedData": "ZPOS64_T",
            "totalUncompressedData": "ZPOS64_T",
            "keys[3]": "unsigned long",
            "z_crc_t": "const",
            "crypt_header_size": "unsigned"
          },
          "curfile64_info",
          [
            140,
            0
          ],
          [
            173,
            17
          ]
        ],
        [
          "typedef struct\n{\n    zlib_filefunc64_32_def z_filefunc;\n    voidpf filestream;        /* io structure of the zipfile */\n    linkedlist_data central_dir;/* datablock with central dir in construction*/\n    int  in_opened_file_inzip;  /* 1 if a file in the zip is currently writ.*/\n    curfile64_info ci;            /* info on the file currently writing */\n\n    ZPOS64_T begin_pos;            /* position of the beginning of the zipfile */\n    ZPOS64_T add_position_when_writing_offset;\n    ZPOS64_T number_entry;\n\n#ifndef NO_ADDFILEINEXISTINGZIP\n    char *globalcomment;\n#endif\n\n    // Support for zipAlreadyThere().\n    set_t set;              // set for detecting name collisions\n    block_t block;          // block for reading the central directory\n\n} zip64_internal;",
          {
            "z_filefunc": "zlib_filefunc64_32_def",
            "filestream": "voidpf",
            "central_dir": "linkedlist_data",
            "in_opened_file_inzip": "int",
            "ci": "curfile64_info",
            "begin_pos": "ZPOS64_T",
            "add_position_when_writing_offset": "ZPOS64_T",
            "number_entry": "ZPOS64_T",
            "*globalcomment": "char",
            "set": "set_t",
            "block": "block_t"
          },
          "zip64_internal",
          [
            175,
            0
          ],
          [
            195,
            17
          ]
        ],
        [
          "typedef struct linkedlist_datablock_internal_s\n{\n  struct linkedlist_datablock_internal_s* next_datablock;\n  uLong  avail_in_this_block;\n  uLong  filled_in_this_block;\n  uLong  unused; /* for future use and alignment */\n  unsigned char data[SIZEDATA_INDATABLOCK];\n} linkedlist_datablock_internal;",
          {
            "* next_datablock": "struct linkedlist_datablock_internal_s",
            "avail_in_this_block": "uLong",
            "filled_in_this_block": "uLong",
            "unused": "uLong",
            "data[SIZEDATA_INDATABLOCK]": "unsigned char"
          },
          "linkedlist_datablock_internal",
          [
            111,
            0
          ],
          [
            118,
            32
          ]
        ],
        [
          "struct linkedlist_datablock_internal_s",
          {},
          "",
          [
            113,
            2
          ],
          [
            113,
            40
          ]
        ],
        [
          "typedef struct linkedlist_data_s\n{\n    linkedlist_datablock_internal* first_block;\n    linkedlist_datablock_internal* last_block;\n} linkedlist_data;",
          {
            "* first_block": "linkedlist_datablock_internal",
            "* last_block": "linkedlist_datablock_internal"
          },
          "linkedlist_data",
          [
            120,
            0
          ],
          [
            124,
            18
          ]
        ],
        [
          "typedef struct {\n    unsigned char *next;        // next byte in datablock data\n    size_t left;                // number of bytes left in data (at least)\n    linkedlist_datablock_internal *node;    // current datablock\n} block_t;",
          {
            "*next": "unsigned char",
            "left": "size_t",
            "*node": "linkedlist_datablock_internal"
          },
          "block_t",
          [
            133,
            0
          ],
          [
            137,
            10
          ]
        ],
        [
          "typedef struct\n{\n    z_stream stream;            /* zLib stream structure for inflate */\n#ifdef HAVE_BZIP2\n    bz_stream bstream;          /* bzLib stream structure for bziped */\n#endif\n\n    int  stream_initialised;    /* 1 is stream is initialised */\n    uInt pos_in_buffered_data;  /* last written byte in buffered_data */\n\n    ZPOS64_T pos_local_header;     /* offset of the local header of the file\n                                     currently writing */\n    char* central_header;       /* central header data for the current file */\n    uLong size_centralExtra;\n    uLong size_centralheader;   /* size of the central header for cur file */\n    uLong size_centralExtraFree; /* Extra bytes allocated to the centralheader but that are not used */\n    uLong flag;                 /* flag of the file currently writing */\n\n    int  method;                /* compression method of file currently wr.*/\n    int  raw;                   /* 1 for directly writing raw data */\n    Byte buffered_data[Z_BUFSIZE];/* buffer contain compressed data to be writ*/\n    uLong dosDate;\n    uLong crc32;\n    int  encrypt;\n    int  zip64;               /* Add ZIP64 extended information in the extra field */\n    ZPOS64_T pos_zip64extrainfo;\n    ZPOS64_T totalCompressedData;\n    ZPOS64_T totalUncompressedData;\n#ifndef NOCRYPT\n    unsigned long keys[3];     /* keys defining the pseudo-random sequence */\n    const z_crc_t* pcrc_32_tab;\n    unsigned crypt_header_size;\n#endif\n} curfile64_info;",
          {
            "stream": "z_stream",
            "bstream": "bz_stream",
            "stream_initialised": "int",
            "pos_in_buffered_data": "uInt",
            "pos_local_header": "ZPOS64_T",
            "* central_header": "char",
            "size_centralExtra": "uLong",
            "size_centralheader": "uLong",
            "size_centralExtraFree": "uLong",
            "flag": "uLong",
            "method": "int",
            "raw": "int",
            "buffered_data[Z_BUFSIZE]": "Byte",
            "dosDate": "uLong",
            "crc32": "uLong",
            "encrypt": "int",
            "zip64": "int",
            "pos_zip64extrainfo": "ZPOS64_T",
            "totalCompressedData": "ZPOS64_T",
            "totalUncompressedData": "ZPOS64_T",
            "keys[3]": "unsigned long",
            "z_crc_t": "const",
            "crypt_header_size": "unsigned"
          },
          "curfile64_info",
          [
            140,
            0
          ],
          [
            173,
            17
          ]
        ],
        [
          "typedef struct\n{\n    zlib_filefunc64_32_def z_filefunc;\n    voidpf filestream;        /* io structure of the zipfile */\n    linkedlist_data central_dir;/* datablock with central dir in construction*/\n    int  in_opened_file_inzip;  /* 1 if a file in the zip is currently writ.*/\n    curfile64_info ci;            /* info on the file currently writing */\n\n    ZPOS64_T begin_pos;            /* position of the beginning of the zipfile */\n    ZPOS64_T add_position_when_writing_offset;\n    ZPOS64_T number_entry;\n\n#ifndef NO_ADDFILEINEXISTINGZIP\n    char *globalcomment;\n#endif\n\n    // Support for zipAlreadyThere().\n    set_t set;              // set for detecting name collisions\n    block_t block;          // block for reading the central directory\n\n} zip64_internal;",
          {
            "z_filefunc": "zlib_filefunc64_32_def",
            "filestream": "voidpf",
            "central_dir": "linkedlist_data",
            "in_opened_file_inzip": "int",
            "ci": "curfile64_info",
            "begin_pos": "ZPOS64_T",
            "add_position_when_writing_offset": "ZPOS64_T",
            "number_entry": "ZPOS64_T",
            "*globalcomment": "char",
            "set": "set_t",
            "block": "block_t"
          },
          "zip64_internal",
          [
            175,
            0
          ],
          [
            195,
            17
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <time.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"zip.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <stddef.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#   include <errno.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"skipset.h\"\n",
          [
            132,
            0
          ],
          [
            133,
            0
          ]
        ],
        [
          "#include \"crypt.h\"\n",
          [
            200,
            0
          ],
          [
            201,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/minizip/iowin32.c": {
      "fn_def_list": [
        {
          "fn_code": "static void win32_translate_open_mode(int mode,\n                                      DWORD* lpdwDesiredAccess,\n                                      DWORD* lpdwCreationDisposition,\n                                      DWORD* lpdwShareMode,\n                                      DWORD* lpdwFlagsAndAttributes) {\n    *lpdwDesiredAccess = *lpdwShareMode = *lpdwFlagsAndAttributes = *lpdwCreationDisposition = 0;\n\n    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)\n    {\n        *lpdwDesiredAccess = GENERIC_READ;\n        *lpdwCreationDisposition = OPEN_EXISTING;\n        *lpdwShareMode = FILE_SHARE_READ;\n    }\n    else if (mode & ZLIB_FILEFUNC_MODE_EXISTING)\n    {\n        *lpdwDesiredAccess = GENERIC_WRITE | GENERIC_READ;\n        *lpdwCreationDisposition = OPEN_EXISTING;\n    }\n    else if (mode & ZLIB_FILEFUNC_MODE_CREATE)\n    {\n        *lpdwDesiredAccess = GENERIC_WRITE | GENERIC_READ;\n        *lpdwCreationDisposition = CREATE_ALWAYS;\n    }\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_translate_open_mode",
            "parameters": {
              "mode": "int",
              "lpdwDesiredAccess": "DWORD",
              "lpdwCreationDisposition": "DWORD",
              "lpdwShareMode": "DWORD",
              "lpdwFlagsAndAttributes": "DWORD"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static voidpf win32_build_iowin(HANDLE hFile) {\n    voidpf ret=NULL;\n\n    if ((hFile != NULL) && (hFile != INVALID_HANDLE_VALUE))\n    {\n        WIN32FILE_IOWIN w32fiow;\n        w32fiow.hf = hFile;\n        w32fiow.error = 0;\n        ret = malloc(sizeof(WIN32FILE_IOWIN));\n\n        if (ret==NULL)\n            CloseHandle(hFile);\n        else\n            *((WIN32FILE_IOWIN*)ret) = w32fiow;\n    }\n    return ret;\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              88,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_build_iowin",
            "parameters": {
              "hFile": "HANDLE"
            },
            "return_type": "voidpf"
          }
        },
        {
          "fn_code": "voidpf ZCALLBACK win32_open64_file_func(voidpf opaque, const void* filename, int mode) {\n    (void)opaque;\n    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;\n    HANDLE hFile = NULL;\n\n    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);\n\n#ifdef IOWIN32_USING_WINRT_API\n#ifdef UNICODE\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFile2((LPCTSTR)filename, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);\n#else\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n    {\n        WCHAR filenameW[FILENAME_MAX + 0x200 + 1];\n        MultiByteToWideChar(CP_ACP,0,(const char*)filename,-1,filenameW,FILENAME_MAX + 0x200);\n        hFile = CreateFile2(filenameW, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);\n    }\n#endif\n#else\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFile((LPCTSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);\n#endif\n\n    return win32_build_iowin(hFile);\n}",
          "fn_code_pos": [
            [
              90,
              0
            ],
            [
              115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_open64_file_func",
            "parameters": {
              "opaque": "voidpf",
              "filename": "void",
              "mode": "int"
            },
            "return_type": "voidpf"
          }
        },
        {
          "fn_code": "voidpf ZCALLBACK win32_open64_file_funcA(voidpf opaque, const void* filename, int mode) {\n    (void)opaque;\n    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;\n    HANDLE hFile = NULL;\n\n    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);\n\n#ifdef IOWIN32_USING_WINRT_API\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n    {\n        WCHAR filenameW[FILENAME_MAX + 0x200 + 1];\n        MultiByteToWideChar(CP_ACP,0,(const char*)filename,-1,filenameW,FILENAME_MAX + 0x200);\n        hFile = CreateFile2(filenameW, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);\n    }\n#else\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFileA((LPCSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);\n#endif\n\n    return win32_build_iowin(hFile);\n}",
          "fn_code_pos": [
            [
              118,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_open64_file_funcA",
            "parameters": {
              "opaque": "voidpf",
              "filename": "void",
              "mode": "int"
            },
            "return_type": "voidpf"
          }
        },
        {
          "fn_code": "voidpf ZCALLBACK win32_open64_file_funcW(voidpf opaque, const void* filename, int mode) {\n    (void)opaque;\n    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;\n    HANDLE hFile = NULL;\n\n    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);\n\n#ifdef IOWIN32_USING_WINRT_API\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFile2((LPCWSTR)filename, dwDesiredAccess, dwShareMode, dwCreationDisposition,NULL);\n#else\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFileW((LPCWSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);\n#endif\n\n    return win32_build_iowin(hFile);\n}",
          "fn_code_pos": [
            [
              141,
              0
            ],
            [
              157,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_open64_file_funcW",
            "parameters": {
              "opaque": "voidpf",
              "filename": "void",
              "mode": "int"
            },
            "return_type": "voidpf"
          }
        },
        {
          "fn_code": "voidpf ZCALLBACK win32_open_file_func(voidpf opaque, const char* filename, int mode) {\n    (void)opaque;\n    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;\n    HANDLE hFile = NULL;\n\n    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);\n\n#ifdef IOWIN32_USING_WINRT_API\n#ifdef UNICODE\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFile2((LPCTSTR)filename, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);\n#else\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n    {\n        WCHAR filenameW[FILENAME_MAX + 0x200 + 1];\n        MultiByteToWideChar(CP_ACP,0,(const char*)filename,-1,filenameW,FILENAME_MAX + 0x200);\n        hFile = CreateFile2(filenameW, dwDesiredAccess, dwShareMode, dwCreationDisposition, NULL);\n    }\n#endif\n#else\n    if ((filename!=NULL) && (dwDesiredAccess != 0))\n        hFile = CreateFile((LPCTSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);\n#endif\n\n    return win32_build_iowin(hFile);\n}",
          "fn_code_pos": [
            [
              160,
              0
            ],
            [
              185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_open_file_func",
            "parameters": {
              "opaque": "voidpf",
              "filename": "char",
              "mode": "int"
            },
            "return_type": "voidpf"
          }
        },
        {
          "fn_code": "uLong ZCALLBACK win32_read_file_func(voidpf opaque, voidpf stream, void* buf,uLong size) {\n    (void)opaque;\n    uLong ret=0;\n    HANDLE hFile = NULL;\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n\n    if (hFile != NULL)\n    {\n        if (!ReadFile(hFile, buf, size, &ret, NULL))\n        {\n            DWORD dwErr = GetLastError();\n            if (dwErr == ERROR_HANDLE_EOF)\n                dwErr = 0;\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n        }\n    }\n\n    return ret;\n}",
          "fn_code_pos": [
            [
              188,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_read_file_func",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf",
              "buf": "void",
              "size": "uLong"
            },
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "uLong ZCALLBACK win32_write_file_func(voidpf opaque, voidpf stream, const void* buf, uLong size) {\n    (void)opaque;\n    uLong ret=0;\n    HANDLE hFile = NULL;\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n\n    if (hFile != NULL)\n    {\n        if (!WriteFile(hFile, buf, size, &ret, NULL))\n        {\n            DWORD dwErr = GetLastError();\n            if (dwErr == ERROR_HANDLE_EOF)\n                dwErr = 0;\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n        }\n    }\n\n    return ret;\n}",
          "fn_code_pos": [
            [
              210,
              0
            ],
            [
              229,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_write_file_func",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf",
              "buf": "void",
              "size": "uLong"
            },
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "static BOOL MySetFilePointerEx(HANDLE hFile, LARGE_INTEGER pos, LARGE_INTEGER *newPos, DWORD dwMoveMethod) {\n#ifdef IOWIN32_USING_WINRT_API\n    return SetFilePointerEx(hFile, pos, newPos, dwMoveMethod);\n#else\n    LONG lHigh = pos.HighPart;\n    DWORD dwNewPos = SetFilePointer(hFile, pos.LowPart, &lHigh, dwMoveMethod);\n    BOOL fOk = TRUE;\n    if (dwNewPos == 0xFFFFFFFF)\n        if (GetLastError() != NO_ERROR)\n            fOk = FALSE;\n    if ((newPos != NULL) && (fOk))\n    {\n        newPos->LowPart = dwNewPos;\n        newPos->HighPart = lHigh;\n    }\n    return fOk;\n#endif\n}",
          "fn_code_pos": [
            [
              231,
              0
            ],
            [
              248,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MySetFilePointerEx",
            "parameters": {
              "hFile": "HANDLE",
              "pos": "LARGE_INTEGER",
              "newPos": "LARGE_INTEGER",
              "dwMoveMethod": "DWORD"
            },
            "return_type": "BOOL"
          }
        },
        {
          "fn_code": "long ZCALLBACK win32_tell_file_func(voidpf opaque, voidpf stream) {\n    (void)opaque;\n    long ret=-1;\n    HANDLE hFile = NULL;\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n    if (hFile != NULL)\n    {\n        LARGE_INTEGER pos;\n        pos.QuadPart = 0;\n\n        if (!MySetFilePointerEx(hFile, pos, &pos, FILE_CURRENT))\n        {\n            DWORD dwErr = GetLastError();\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n            ret = -1;\n        }\n        else\n            ret=(long)pos.LowPart;\n    }\n    return ret;\n}",
          "fn_code_pos": [
            [
              250,
              0
            ],
            [
              271,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_tell_file_func",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ZPOS64_T ZCALLBACK win32_tell64_file_func(voidpf opaque, voidpf stream) {\n    (void)opaque;\n    ZPOS64_T ret= (ZPOS64_T)-1;\n    HANDLE hFile = NULL;\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream)->hf;\n\n    if (hFile)\n    {\n        LARGE_INTEGER pos;\n        pos.QuadPart = 0;\n\n        if (!MySetFilePointerEx(hFile, pos, &pos, FILE_CURRENT))\n        {\n            DWORD dwErr = GetLastError();\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n            ret = (ZPOS64_T)-1;\n        }\n        else\n            ret=pos.QuadPart;\n    }\n    return ret;\n}",
          "fn_code_pos": [
            [
              273,
              0
            ],
            [
              295,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_tell64_file_func",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf"
            },
            "return_type": "ZPOS64_T"
          }
        },
        {
          "fn_code": "long ZCALLBACK win32_seek_file_func(voidpf opaque, voidpf stream, uLong offset, int origin) {\n    (void)opaque;\n    DWORD dwMoveMethod=0xFFFFFFFF;\n    HANDLE hFile = NULL;\n\n    long ret=-1;\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n    switch (origin)\n    {\n    case ZLIB_FILEFUNC_SEEK_CUR :\n        dwMoveMethod = FILE_CURRENT;\n        break;\n    case ZLIB_FILEFUNC_SEEK_END :\n        dwMoveMethod = FILE_END;\n        break;\n    case ZLIB_FILEFUNC_SEEK_SET :\n        dwMoveMethod = FILE_BEGIN;\n        break;\n    default: return -1;\n    }\n\n    if (hFile != NULL)\n    {\n        LARGE_INTEGER pos;\n        pos.QuadPart = offset;\n        if (!MySetFilePointerEx(hFile, pos, NULL, dwMoveMethod))\n        {\n            DWORD dwErr = GetLastError();\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n            ret = -1;\n        }\n        else\n            ret=0;\n    }\n    return ret;\n}",
          "fn_code_pos": [
            [
              298,
              0
            ],
            [
              334,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_seek_file_func",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf",
              "offset": "uLong",
              "origin": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "long ZCALLBACK win32_seek64_file_func(voidpf opaque, voidpf stream, ZPOS64_T offset, int origin) {\n    (void)opaque;\n    DWORD dwMoveMethod=0xFFFFFFFF;\n    HANDLE hFile = NULL;\n    long ret=-1;\n\n    if (stream!=NULL)\n        hFile = ((WIN32FILE_IOWIN*)stream)->hf;\n\n    switch (origin)\n    {\n        case ZLIB_FILEFUNC_SEEK_CUR :\n            dwMoveMethod = FILE_CURRENT;\n            break;\n        case ZLIB_FILEFUNC_SEEK_END :\n            dwMoveMethod = FILE_END;\n            break;\n        case ZLIB_FILEFUNC_SEEK_SET :\n            dwMoveMethod = FILE_BEGIN;\n            break;\n        default: return -1;\n    }\n\n    if (hFile)\n    {\n        LARGE_INTEGER pos;\n        pos.QuadPart = offset;\n        if (!MySetFilePointerEx(hFile, pos, NULL, dwMoveMethod))\n        {\n            DWORD dwErr = GetLastError();\n            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;\n            ret = -1;\n        }\n        else\n            ret=0;\n    }\n    return ret;\n}",
          "fn_code_pos": [
            [
              336,
              0
            ],
            [
              373,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_seek64_file_func",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf",
              "offset": "ZPOS64_T",
              "origin": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "int ZCALLBACK win32_close_file_func(voidpf opaque, voidpf stream) {\n    (void)opaque;\n    int ret=-1;\n\n    if (stream!=NULL)\n    {\n        HANDLE hFile;\n        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;\n        if (hFile != NULL)\n        {\n            CloseHandle(hFile);\n            ret=0;\n        }\n        free(stream);\n    }\n    return ret;\n}",
          "fn_code_pos": [
            [
              375,
              0
            ],
            [
              391,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_close_file_func",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZCALLBACK win32_error_file_func(voidpf opaque, voidpf stream) {\n    (void)opaque;\n    int ret=-1;\n    if (stream!=NULL)\n    {\n        ret = ((WIN32FILE_IOWIN*)stream) -> error;\n    }\n    return ret;\n}",
          "fn_code_pos": [
            [
              393,
              0
            ],
            [
              401,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "win32_error_file_func",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void fill_win32_filefunc(zlib_filefunc_def* pzlib_filefunc_def) {\n    pzlib_filefunc_def->zopen_file = win32_open_file_func;\n    pzlib_filefunc_def->zread_file = win32_read_file_func;\n    pzlib_filefunc_def->zwrite_file = win32_write_file_func;\n    pzlib_filefunc_def->ztell_file = win32_tell_file_func;\n    pzlib_filefunc_def->zseek_file = win32_seek_file_func;\n    pzlib_filefunc_def->zclose_file = win32_close_file_func;\n    pzlib_filefunc_def->zerror_file = win32_error_file_func;\n    pzlib_filefunc_def->opaque = NULL;\n}",
          "fn_code_pos": [
            [
              403,
              0
            ],
            [
              412,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fill_win32_filefunc",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc_def"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void fill_win32_filefunc64(zlib_filefunc64_def* pzlib_filefunc_def) {\n    pzlib_filefunc_def->zopen64_file = win32_open64_file_func;\n    pzlib_filefunc_def->zread_file = win32_read_file_func;\n    pzlib_filefunc_def->zwrite_file = win32_write_file_func;\n    pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;\n    pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;\n    pzlib_filefunc_def->zclose_file = win32_close_file_func;\n    pzlib_filefunc_def->zerror_file = win32_error_file_func;\n    pzlib_filefunc_def->opaque = NULL;\n}",
          "fn_code_pos": [
            [
              414,
              0
            ],
            [
              423,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fill_win32_filefunc64",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_def"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void fill_win32_filefunc64A(zlib_filefunc64_def* pzlib_filefunc_def) {\n    pzlib_filefunc_def->zopen64_file = win32_open64_file_funcA;\n    pzlib_filefunc_def->zread_file = win32_read_file_func;\n    pzlib_filefunc_def->zwrite_file = win32_write_file_func;\n    pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;\n    pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;\n    pzlib_filefunc_def->zclose_file = win32_close_file_func;\n    pzlib_filefunc_def->zerror_file = win32_error_file_func;\n    pzlib_filefunc_def->opaque = NULL;\n}",
          "fn_code_pos": [
            [
              426,
              0
            ],
            [
              435,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fill_win32_filefunc64A",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_def"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void fill_win32_filefunc64W(zlib_filefunc64_def* pzlib_filefunc_def) {\n    pzlib_filefunc_def->zopen64_file = win32_open64_file_funcW;\n    pzlib_filefunc_def->zread_file = win32_read_file_func;\n    pzlib_filefunc_def->zwrite_file = win32_write_file_func;\n    pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;\n    pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;\n    pzlib_filefunc_def->zclose_file = win32_close_file_func;\n    pzlib_filefunc_def->zerror_file = win32_error_file_func;\n    pzlib_filefunc_def->opaque = NULL;\n}",
          "fn_code_pos": [
            [
              438,
              0
            ],
            [
              447,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fill_win32_filefunc64W",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_def"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct\n{\n    HANDLE hf;\n    int error;\n} WIN32FILE_IOWIN;",
          {
            "hf": "HANDLE",
            "error": "int"
          },
          "WIN32FILE_IOWIN",
          [
            40,
            0
          ],
          [
            44,
            18
          ]
        ],
        [
          "typedef struct\n{\n    HANDLE hf;\n    int error;\n} WIN32FILE_IOWIN;",
          {
            "hf": "HANDLE",
            "error": "int"
          },
          "WIN32FILE_IOWIN",
          [
            40,
            0
          ],
          [
            44,
            18
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdlib.h>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"ioapi.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"iowin32.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/minizip/minizip.c": {
      "fn_def_list": [
        {
          "fn_code": "static int filetime(const char *f, tm_zip *tmzip, uLong *dt) {\n  (void)tmzip;\n  int ret = 0;\n  {\n      FILETIME ftLocal;\n      HANDLE hFind;\n      WIN32_FIND_DATAA ff32;\n\n      hFind = FindFirstFileA(f,&ff32);\n      if (hFind != INVALID_HANDLE_VALUE)\n      {\n        FileTimeToLocalFileTime(&(ff32.ftLastWriteTime),&ftLocal);\n        FileTimeToDosDateTime(&ftLocal,((LPWORD)dt)+1,((LPWORD)dt)+0);\n        FindClose(hFind);\n        ret = 1;\n      }\n  }\n  return ret;\n}",
          "fn_code_pos": [
            [
              79,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "filetime",
            "parameters": {
              "f": "char",
              "tmzip": "tm_zip",
              "dt": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int filetime(const char *f, tm_zip *tmzip, uLong *dt) {\n  (void)dt;\n  int ret=0;\n  struct stat s;        /* results of stat() */\n  struct tm* filedate;\n  time_t tm_t=0;\n\n  if (strcmp(f,\"-\")!=0)\n  {\n    char name[MAXFILENAME+1];\n    size_t len = strlen(f);\n    if (len > MAXFILENAME)\n      len = MAXFILENAME;\n\n    strncpy(name, f,MAXFILENAME-1);\n    /* strncpy doesn't append the trailing NULL, of the string is too long. */\n    name[ MAXFILENAME ] = '\\0';\n\n    if (name[len - 1] == '/')\n      name[len - 1] = '\\0';\n    /* not all systems allow stat'ing a file with / appended */\n    if (stat(name,&s)==0)\n    {\n      tm_t = s.st_mtime;\n      ret = 1;\n    }\n  }\n  filedate = localtime(&tm_t);\n\n  tmzip->tm_sec  = filedate->tm_sec;\n  tmzip->tm_min  = filedate->tm_min;\n  tmzip->tm_hour = filedate->tm_hour;\n  tmzip->tm_mday = filedate->tm_mday;\n  tmzip->tm_mon  = filedate->tm_mon ;\n  tmzip->tm_year = filedate->tm_year;\n\n  return ret;\n}",
          "fn_code_pos": [
            [
              101,
              0
            ],
            [
              138,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "filetime",
            "parameters": {
              "f": "char",
              "tmzip": "tm_zip",
              "dt": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int filetime(const char *f, tm_zip *tmzip, uLong *dt) {\n    (void)f;\n    (void)tmzip;\n    (void)dt;\n    return 0;\n}",
          "fn_code_pos": [
            [
              142,
              0
            ],
            [
              147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "filetime",
            "parameters": {
              "f": "char",
              "tmzip": "tm_zip",
              "dt": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int check_exist_file(const char* filename) {\n    FILE* ftestexist;\n    int ret = 1;\n    ftestexist = FOPEN_FUNC(filename,\"rb\");\n    if (ftestexist==NULL)\n        ret = 0;\n    else\n        fclose(ftestexist);\n    return ret;\n}",
          "fn_code_pos": [
            [
              153,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "check_exist_file",
            "parameters": {
              "filename": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void do_banner(void) {\n    printf(\"MiniZip 1.1, demo of zLib + MiniZip64 package, written by Gilles Vollant\\n\");\n    printf(\"more info on MiniZip at http://www.winimage.com/zLibDll/minizip.html\\n\\n\");\n}",
          "fn_code_pos": [
            [
              164,
              0
            ],
            [
              167,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "do_banner",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void do_help(void) {\n    printf(\"Usage : minizip [-o] [-a] [-0 to -9] [-p password] [-j] file.zip [files_to_add]\\n\\n\" \\\n           \"  -o  Overwrite existing file.zip\\n\" \\\n           \"  -a  Append to existing file.zip\\n\" \\\n           \"  -0  Store only\\n\" \\\n           \"  -1  Compress faster\\n\" \\\n           \"  -9  Compress better\\n\\n\" \\\n           \"  -j  exclude path. store only the file name.\\n\\n\");\n}",
          "fn_code_pos": [
            [
              169,
              0
            ],
            [
              177,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "do_help",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int getFileCrc(const char* filenameinzip, void* buf, unsigned long size_buf, unsigned long* result_crc) {\n   unsigned long calculate_crc=0;\n   int err=ZIP_OK;\n   FILE * fin = FOPEN_FUNC(filenameinzip,\"rb\");\n\n   unsigned long size_read = 0;\n   /* unsigned long total_read = 0; */\n   if (fin==NULL)\n   {\n       err = ZIP_ERRNO;\n   }\n\n    if (err == ZIP_OK)\n        do\n        {\n            err = ZIP_OK;\n            size_read = (unsigned long)fread(buf,1,size_buf,fin);\n            if (size_read < size_buf)\n                if (feof(fin)==0)\n            {\n                printf(\"error in reading %s\\n\",filenameinzip);\n                err = ZIP_ERRNO;\n            }\n\n            if (size_read>0)\n                calculate_crc = crc32_z(calculate_crc,buf,size_read);\n            /* total_read += size_read; */\n\n        } while ((err == ZIP_OK) && (size_read>0));\n\n    if (fin)\n        fclose(fin);\n\n    *result_crc=calculate_crc;\n    printf(\"file %s crc %lx\\n\", filenameinzip, calculate_crc);\n    return err;\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              217,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getFileCrc",
            "parameters": {
              "filenameinzip": "char",
              "buf": "void",
              "size_buf": "unsigned long",
              "result_crc": "unsigned long"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int isLargeFile(const char* filename) {\n  int largeFile = 0;\n  ZPOS64_T pos = 0;\n  FILE* pFile = FOPEN_FUNC(filename, \"rb\");\n\n  if(pFile != NULL)\n  {\n    FSEEKO_FUNC(pFile, 0, SEEK_END);\n    pos = (ZPOS64_T)FTELLO_FUNC(pFile);\n\n                printf(\"File : %s is %\"PUI64\" bytes\\n\", filename, pos);\n\n    if(pos >= 0xffffffff)\n     largeFile = 1;\n\n                fclose(pFile);\n  }\n\n return largeFile;\n}",
          "fn_code_pos": [
            [
              219,
              0
            ],
            [
              238,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "isLargeFile",
            "parameters": {
              "filename": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[]) {\n    int i;\n    int opt_overwrite=0;\n    int opt_compress_level=Z_DEFAULT_COMPRESSION;\n    int opt_exclude_path=0;\n    int zipfilenamearg = 0;\n    char filename_try[MAXFILENAME+16];\n    int zipok;\n    int err=0;\n    unsigned long size_buf=0;\n    void* buf=NULL;\n    const char* password=NULL;\n\n\n    do_banner();\n    if (argc==1)\n    {\n        do_help();\n        return 0;\n    }\n    else\n    {\n        for (i=1;i<argc;i++)\n        {\n            if ((*argv[i])=='-')\n            {\n                const char *p=argv[i]+1;\n\n                while ((*p)!='\\0')\n                {\n                    char c=*(p++);\n                    if ((c=='o') || (c=='O'))\n                        opt_overwrite = 1;\n                    if ((c=='a') || (c=='A'))\n                        opt_overwrite = 2;\n                    if ((c>='0') && (c<='9'))\n                        opt_compress_level = c-'0';\n                    if ((c=='j') || (c=='J'))\n                        opt_exclude_path = 1;\n\n                    if (((c=='p') || (c=='P')) && (i+1<argc))\n                    {\n                        password=argv[i+1];\n                        i++;\n                    }\n                }\n            }\n            else\n            {\n                if (zipfilenamearg == 0)\n                {\n                    zipfilenamearg = i ;\n                }\n            }\n        }\n    }\n\n    size_buf = WRITEBUFFERSIZE;\n    buf = (void*)malloc(size_buf);\n    if (buf==NULL)\n    {\n        printf(\"Error allocating memory\\n\");\n        return ZIP_INTERNALERROR;\n    }\n\n    if (zipfilenamearg==0)\n    {\n        zipok=0;\n    }\n    else\n    {\n        int len;\n        int dot_found=0;\n\n        zipok = 1 ;\n        strncpy(filename_try, argv[zipfilenamearg],MAXFILENAME-1);\n        /* strncpy doesn't append the trailing NULL, of the string is too long. */\n        filename_try[ MAXFILENAME ] = '\\0';\n\n        len=(int)strlen(filename_try);\n        for (i=0;i<len;i++)\n            if (filename_try[i]=='.')\n                dot_found=1;\n\n        if (dot_found==0)\n            strcat(filename_try,\".zip\");\n\n        if (opt_overwrite==2)\n        {\n            /* if the file don't exist, we not append file */\n            if (check_exist_file(filename_try)==0)\n                opt_overwrite=1;\n        }\n        else\n        if (opt_overwrite==0)\n            if (check_exist_file(filename_try)!=0)\n            {\n                char rep=0;\n                do\n                {\n                    char answer[128];\n                    int ret;\n                    printf(\"The file %s exists. Overwrite ? [y]es, [n]o, [a]ppend : \",filename_try);\n                    ret = scanf(\"%1s\",answer);\n                    if (ret != 1)\n                    {\n                       exit(EXIT_FAILURE);\n                    }\n                    rep = answer[0] ;\n                    if ((rep>='a') && (rep<='z'))\n                        rep -= 0x20;\n                }\n                while ((rep!='Y') && (rep!='N') && (rep!='A'));\n                if (rep=='N')\n                    zipok = 0;\n                if (rep=='A')\n                    opt_overwrite = 2;\n            }\n    }\n\n    if (zipok==1)\n    {\n        zipFile zf;\n        int errclose;\n#        ifdef USEWIN32IOAPI\n        zlib_filefunc64_def ffunc;\n        fill_win32_filefunc64A(&ffunc);\n        zf = zipOpen2_64(filename_try,(opt_overwrite==2) ? 2 : 0,NULL,&ffunc);\n#        else\n        zf = zipOpen64(filename_try,(opt_overwrite==2) ? 2 : 0);\n#        endif\n\n        if (zf == NULL)\n        {\n            printf(\"error opening %s\\n\",filename_try);\n            err= ZIP_ERRNO;\n        }\n        else\n            printf(\"creating %s\\n\",filename_try);\n\n        for (i=zipfilenamearg+1;(i<argc) && (err==ZIP_OK);i++)\n        {\n            if (!((((*(argv[i]))=='-') || ((*(argv[i]))=='/')) &&\n                  ((argv[i][1]=='o') || (argv[i][1]=='O') ||\n                   (argv[i][1]=='a') || (argv[i][1]=='A') ||\n                   (argv[i][1]=='p') || (argv[i][1]=='P') ||\n                   ((argv[i][1]>='0') && (argv[i][1]<='9'))) &&\n                  (strlen(argv[i]) == 2)))\n            {\n                FILE * fin = NULL;\n                size_t size_read;\n                const char* filenameinzip = argv[i];\n                const char *savefilenameinzip;\n                zip_fileinfo zi;\n                unsigned long crcFile=0;\n                int zip64 = 0;\n\n                zi.tmz_date.tm_sec = zi.tmz_date.tm_min = zi.tmz_date.tm_hour =\n                zi.tmz_date.tm_mday = zi.tmz_date.tm_mon = zi.tmz_date.tm_year = 0;\n                zi.dosDate = 0;\n                zi.internal_fa = 0;\n                zi.external_fa = 0;\n                filetime(filenameinzip,&zi.tmz_date,&zi.dosDate);\n\n/*\n                err = zipOpenNewFileInZip(zf,filenameinzip,&zi,\n                                 NULL,0,NULL,0,NULL / * comment * /,\n                                 (opt_compress_level != 0) ? Z_DEFLATED : 0,\n                                 opt_compress_level);\n*/\n                if ((password != NULL) && (err==ZIP_OK))\n                    err = getFileCrc(filenameinzip,buf,size_buf,&crcFile);\n\n                zip64 = isLargeFile(filenameinzip);\n\n                                                         /* The path name saved, should not include a leading slash. */\n               /*if it did, windows/xp and dynazip couldn't read the zip file. */\n                 savefilenameinzip = filenameinzip;\n                 while( savefilenameinzip[0] == '\\\\' || savefilenameinzip[0] == '/' )\n                 {\n                     savefilenameinzip++;\n                 }\n\n                 /*should the zip file contain any path at all?*/\n                 if( opt_exclude_path )\n                 {\n                     const char *tmpptr;\n                     const char *lastslash = 0;\n                     for( tmpptr = savefilenameinzip; *tmpptr; tmpptr++)\n                     {\n                         if( *tmpptr == '\\\\' || *tmpptr == '/')\n                         {\n                             lastslash = tmpptr;\n                         }\n                     }\n                     if( lastslash != NULL )\n                     {\n                         savefilenameinzip = lastslash+1; // base filename follows last slash.\n                     }\n                 }\n\n                 /**/\n                err = zipOpenNewFileInZip3_64(zf,savefilenameinzip,&zi,\n                                 NULL,0,NULL,0,NULL /* comment*/,\n                                 (opt_compress_level != 0) ? Z_DEFLATED : 0,\n                                 opt_compress_level,0,\n                                 /* -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY, */\n                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,\n                                 password,crcFile, zip64);\n\n                if (err != ZIP_OK)\n                    printf(\"error in opening %s in zipfile\\n\",filenameinzip);\n                else\n                {\n                    fin = FOPEN_FUNC(filenameinzip,\"rb\");\n                    if (fin==NULL)\n                    {\n                        err=ZIP_ERRNO;\n                        printf(\"error in opening %s for reading\\n\",filenameinzip);\n                    }\n                }\n\n                if (err == ZIP_OK)\n                    do\n                    {\n                        err = ZIP_OK;\n                        size_read = fread(buf,1,size_buf,fin);\n                        if (size_read < size_buf)\n                            if (feof(fin)==0)\n                        {\n                            printf(\"error in reading %s\\n\",filenameinzip);\n                            err = ZIP_ERRNO;\n                        }\n\n                        if (size_read>0)\n                        {\n                            err = zipWriteInFileInZip (zf,buf,(unsigned)size_read);\n                            if (err<0)\n                            {\n                                printf(\"error in writing %s in the zipfile\\n\",\n                                                 filenameinzip);\n                            }\n\n                        }\n                    } while ((err == ZIP_OK) && (size_read>0));\n\n                if (fin)\n                    fclose(fin);\n\n                if (err<0)\n                    err=ZIP_ERRNO;\n                else\n                {\n                    err = zipCloseFileInZip(zf);\n                    if (err!=ZIP_OK)\n                        printf(\"error in closing %s in the zipfile\\n\",\n                                    filenameinzip);\n                }\n            }\n        }\n        errclose = zipClose(zf,NULL);\n        if (errclose != ZIP_OK)\n            printf(\"error in closing %s\\n\",filename_try);\n    }\n    else\n    {\n       do_help();\n    }\n\n    free(buf);\n    return 0;\n}",
          "fn_code_pos": [
            [
              240,
              0
            ],
            [
              511,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct stat",
          {},
          "",
          [
            104,
            2
          ],
          [
            104,
            13
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            105,
            2
          ],
          [
            105,
            11
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <time.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "# include <direct.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "# include <io.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "# include <utime.h>\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "# include <sys/types.h>\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ],
        [
          "# include <sys/stat.h>\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include \"zip.h\"\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include \"ints.h\"\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ],
        [
          "#include \"iowin32.h\"\n",
          [
            68,
            8
          ],
          [
            69,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/minizip/ioapi.c": {
      "fn_def_list": [
        {
          "fn_code": "voidpf call_zopen64 (const zlib_filefunc64_32_def* pfilefunc, const void*filename, int mode) {\n    if (pfilefunc->zfile_func64.zopen64_file != NULL)\n        return (*(pfilefunc->zfile_func64.zopen64_file)) (pfilefunc->zfile_func64.opaque,filename,mode);\n    else\n    {\n        return (*(pfilefunc->zopen32_file))(pfilefunc->zfile_func64.opaque,(const char*)filename,mode);\n    }\n}",
          "fn_code_pos": [
            [
              30,
              0
            ],
            [
              37,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "call_zopen64",
            "parameters": {
              "pfilefunc": "zlib_filefunc64_32_def",
              "filename": "void",
              "mode": "int"
            },
            "return_type": "voidpf"
          }
        },
        {
          "fn_code": "long call_zseek64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin) {\n    if (pfilefunc->zfile_func64.zseek64_file != NULL)\n        return (*(pfilefunc->zfile_func64.zseek64_file)) (pfilefunc->zfile_func64.opaque,filestream,offset,origin);\n    else\n    {\n        uLong offsetTruncated = (uLong)offset;\n        if (offsetTruncated != offset)\n            return -1;\n        else\n            return (*(pfilefunc->zseek32_file))(pfilefunc->zfile_func64.opaque,filestream,offsetTruncated,origin);\n    }\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "call_zseek64",
            "parameters": {
              "pfilefunc": "zlib_filefunc64_32_def",
              "filestream": "voidpf",
              "offset": "ZPOS64_T",
              "origin": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ZPOS64_T call_ztell64 (const zlib_filefunc64_32_def* pfilefunc, voidpf filestream) {\n    if (pfilefunc->zfile_func64.zseek64_file != NULL)\n        return (*(pfilefunc->zfile_func64.ztell64_file)) (pfilefunc->zfile_func64.opaque,filestream);\n    else\n    {\n        uLong tell_uLong = (uLong)(*(pfilefunc->ztell32_file))(pfilefunc->zfile_func64.opaque,filestream);\n        if ((tell_uLong) == MAXU32)\n            return (ZPOS64_T)-1;\n        else\n            return tell_uLong;\n    }\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              63,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "call_ztell64",
            "parameters": {
              "pfilefunc": "zlib_filefunc64_32_def",
              "filestream": "voidpf"
            },
            "return_type": "ZPOS64_T"
          }
        },
        {
          "fn_code": "void fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def* p_filefunc64_32, const zlib_filefunc_def* p_filefunc32) {\n    p_filefunc64_32->zfile_func64.zopen64_file = NULL;\n    p_filefunc64_32->zopen32_file = p_filefunc32->zopen_file;\n    p_filefunc64_32->zfile_func64.zread_file = p_filefunc32->zread_file;\n    p_filefunc64_32->zfile_func64.zwrite_file = p_filefunc32->zwrite_file;\n    p_filefunc64_32->zfile_func64.ztell64_file = NULL;\n    p_filefunc64_32->zfile_func64.zseek64_file = NULL;\n    p_filefunc64_32->zfile_func64.zclose_file = p_filefunc32->zclose_file;\n    p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;\n    p_filefunc64_32->zfile_func64.opaque = p_filefunc32->opaque;\n    p_filefunc64_32->zseek32_file = p_filefunc32->zseek_file;\n    p_filefunc64_32->ztell32_file = p_filefunc32->ztell_file;\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fill_zlib_filefunc64_32_def_from_filefunc32",
            "parameters": {
              "p_filefunc64_32": "zlib_filefunc64_32_def",
              "p_filefunc32": "zlib_filefunc_def"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static voidpf ZCALLBACK fopen_file_func(voidpf opaque, const char* filename, int mode) {\n    FILE* file = NULL;\n    const char* mode_fopen = NULL;\n    (void)opaque;\n    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)\n        mode_fopen = \"rb\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)\n        mode_fopen = \"r+b\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_CREATE)\n        mode_fopen = \"wb\";\n\n    if ((filename!=NULL) && (mode_fopen != NULL))\n        file = fopen(filename, mode_fopen);\n    return file;\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fopen_file_func",
            "parameters": {
              "opaque": "voidpf",
              "filename": "char",
              "mode": "int"
            },
            "return_type": "voidpf"
          }
        },
        {
          "fn_code": "static voidpf ZCALLBACK fopen64_file_func(voidpf opaque, const void* filename, int mode) {\n    FILE* file = NULL;\n    const char* mode_fopen = NULL;\n    (void)opaque;\n    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)\n        mode_fopen = \"rb\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)\n        mode_fopen = \"r+b\";\n    else\n    if (mode & ZLIB_FILEFUNC_MODE_CREATE)\n        mode_fopen = \"wb\";\n\n    if ((filename!=NULL) && (mode_fopen != NULL))\n        file = FOPEN_FUNC((const char*)filename, mode_fopen);\n    return file;\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fopen64_file_func",
            "parameters": {
              "opaque": "voidpf",
              "filename": "void",
              "mode": "int"
            },
            "return_type": "voidpf"
          }
        },
        {
          "fn_code": "static uLong ZCALLBACK fread_file_func(voidpf opaque, voidpf stream, void* buf, uLong size) {\n    uLong ret;\n    (void)opaque;\n    ret = (uLong)fread(buf, 1, (size_t)size, (FILE *)stream);\n    return ret;\n}",
          "fn_code_pos": [
            [
              118,
              0
            ],
            [
              123,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fread_file_func",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf",
              "buf": "void",
              "size": "uLong"
            },
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "static uLong ZCALLBACK fwrite_file_func(voidpf opaque, voidpf stream, const void* buf, uLong size) {\n    uLong ret;\n    (void)opaque;\n    ret = (uLong)fwrite(buf, 1, (size_t)size, (FILE *)stream);\n    return ret;\n}",
          "fn_code_pos": [
            [
              125,
              0
            ],
            [
              130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fwrite_file_func",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf",
              "buf": "void",
              "size": "uLong"
            },
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "static long ZCALLBACK ftell_file_func(voidpf opaque, voidpf stream) {\n    long ret;\n    (void)opaque;\n    ret = ftell((FILE *)stream);\n    return ret;\n}",
          "fn_code_pos": [
            [
              132,
              0
            ],
            [
              137,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ftell_file_func",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static ZPOS64_T ZCALLBACK ftell64_file_func(voidpf opaque, voidpf stream) {\n    ZPOS64_T ret;\n    (void)opaque;\n    ret = (ZPOS64_T)FTELLO_FUNC((FILE *)stream);\n    return ret;\n}",
          "fn_code_pos": [
            [
              140,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ftell64_file_func",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf"
            },
            "return_type": "ZPOS64_T"
          }
        },
        {
          "fn_code": "static long ZCALLBACK fseek_file_func(voidpf opaque, voidpf stream, uLong offset, int origin) {\n    int fseek_origin=0;\n    long ret;\n    (void)opaque;\n    switch (origin)\n    {\n    case ZLIB_FILEFUNC_SEEK_CUR :\n        fseek_origin = SEEK_CUR;\n        break;\n    case ZLIB_FILEFUNC_SEEK_END :\n        fseek_origin = SEEK_END;\n        break;\n    case ZLIB_FILEFUNC_SEEK_SET :\n        fseek_origin = SEEK_SET;\n        break;\n    default: return -1;\n    }\n    ret = 0;\n    if (fseek((FILE *)stream, (long)offset, fseek_origin) != 0)\n        ret = -1;\n    return ret;\n}",
          "fn_code_pos": [
            [
              147,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fseek_file_func",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf",
              "offset": "uLong",
              "origin": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static long ZCALLBACK fseek64_file_func(voidpf opaque, voidpf stream, ZPOS64_T offset, int origin) {\n    int fseek_origin=0;\n    long ret;\n    (void)opaque;\n    switch (origin)\n    {\n    case ZLIB_FILEFUNC_SEEK_CUR :\n        fseek_origin = SEEK_CUR;\n        break;\n    case ZLIB_FILEFUNC_SEEK_END :\n        fseek_origin = SEEK_END;\n        break;\n    case ZLIB_FILEFUNC_SEEK_SET :\n        fseek_origin = SEEK_SET;\n        break;\n    default: return -1;\n    }\n    ret = 0;\n\n    if(FSEEKO_FUNC((FILE *)stream, (z_off64_t)offset, fseek_origin) != 0)\n                        ret = -1;\n\n    return ret;\n}",
          "fn_code_pos": [
            [
              170,
              0
            ],
            [
              193,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fseek64_file_func",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf",
              "offset": "ZPOS64_T",
              "origin": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static int ZCALLBACK fclose_file_func(voidpf opaque, voidpf stream) {\n    int ret;\n    (void)opaque;\n    ret = fclose((FILE *)stream);\n    return ret;\n}",
          "fn_code_pos": [
            [
              196,
              0
            ],
            [
              201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fclose_file_func",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int ZCALLBACK ferror_file_func(voidpf opaque, voidpf stream) {\n    int ret;\n    (void)opaque;\n    ret = ferror((FILE *)stream);\n    return ret;\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              208,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ferror_file_func",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void fill_fopen_filefunc(zlib_filefunc_def* pzlib_filefunc_def) {\n    pzlib_filefunc_def->zopen_file = fopen_file_func;\n    pzlib_filefunc_def->zread_file = fread_file_func;\n    pzlib_filefunc_def->zwrite_file = fwrite_file_func;\n    pzlib_filefunc_def->ztell_file = ftell_file_func;\n    pzlib_filefunc_def->zseek_file = fseek_file_func;\n    pzlib_filefunc_def->zclose_file = fclose_file_func;\n    pzlib_filefunc_def->zerror_file = ferror_file_func;\n    pzlib_filefunc_def->opaque = NULL;\n}",
          "fn_code_pos": [
            [
              210,
              0
            ],
            [
              219,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fill_fopen_filefunc",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc_def"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void fill_fopen64_filefunc(zlib_filefunc64_def* pzlib_filefunc_def) {\n    pzlib_filefunc_def->zopen64_file = fopen64_file_func;\n    pzlib_filefunc_def->zread_file = fread_file_func;\n    pzlib_filefunc_def->zwrite_file = fwrite_file_func;\n    pzlib_filefunc_def->ztell64_file = ftell64_file_func;\n    pzlib_filefunc_def->zseek64_file = fseek64_file_func;\n    pzlib_filefunc_def->zclose_file = fclose_file_func;\n    pzlib_filefunc_def->zerror_file = ferror_file_func;\n    pzlib_filefunc_def->opaque = NULL;\n}",
          "fn_code_pos": [
            [
              221,
              0
            ],
            [
              230,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fill_fopen64_filefunc",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_def"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"ioapi.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/minizip/unzip.c": {
      "fn_def_list": [
        {
          "fn_code": "local int unz64local_getShort(const zlib_filefunc64_32_def* pzlib_filefunc_def,\n                              voidpf filestream,\n                              uLong *pX) {\n    unsigned char c[2];\n    int err = (int)ZREAD64(*pzlib_filefunc_def,filestream,c,2);\n    if (err==2)\n    {\n        *pX = c[0] | ((uLong)c[1] << 8);\n        return UNZ_OK;\n    }\n    else\n    {\n        *pX = 0;\n        if (ZERROR64(*pzlib_filefunc_def,filestream))\n            return UNZ_ERRNO;\n        else\n            return UNZ_EOF;\n    }\n}",
          "fn_code_pos": [
            [
              195,
              0
            ],
            [
              213,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unz64local_getShort",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_32_def",
              "filestream": "voidpf",
              "pX": "uLong"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int unz64local_getLong(const zlib_filefunc64_32_def* pzlib_filefunc_def,\n                             voidpf filestream,\n                             uLong *pX) {\n    unsigned char c[4];\n    int err = (int)ZREAD64(*pzlib_filefunc_def,filestream,c,4);\n    if (err==4)\n    {\n        *pX = c[0] | ((uLong)c[1] << 8) | ((uLong)c[2] << 16) | ((uLong)c[3] << 24);\n        return UNZ_OK;\n    }\n    else\n    {\n        *pX = 0;\n        if (ZERROR64(*pzlib_filefunc_def,filestream))\n            return UNZ_ERRNO;\n        else\n            return UNZ_EOF;\n    }\n}",
          "fn_code_pos": [
            [
              215,
              0
            ],
            [
              233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unz64local_getLong",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_32_def",
              "filestream": "voidpf",
              "pX": "uLong"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int unz64local_getLong64(const zlib_filefunc64_32_def* pzlib_filefunc_def,\n                               voidpf filestream,\n                               ZPOS64_T *pX) {\n    unsigned char c[8];\n    int err = (int)ZREAD64(*pzlib_filefunc_def,filestream,c,8);\n    if (err==8)\n    {\n        *pX = c[0] | ((ZPOS64_T)c[1] << 8) | ((ZPOS64_T)c[2] << 16) | ((ZPOS64_T)c[3] << 24)\n            | ((ZPOS64_T)c[4] << 32) | ((ZPOS64_T)c[5] << 40) | ((ZPOS64_T)c[6] << 48) | ((ZPOS64_T)c[7] << 56);\n        return UNZ_OK;\n    }\n    else\n    {\n        *pX = 0;\n        if (ZERROR64(*pzlib_filefunc_def,filestream))\n            return UNZ_ERRNO;\n        else\n            return UNZ_EOF;\n    }\n}",
          "fn_code_pos": [
            [
              236,
              0
            ],
            [
              255,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unz64local_getLong64",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_32_def",
              "filestream": "voidpf",
              "pX": "ZPOS64_T"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int strcmpcasenosensitive_internal(const char* fileName1, const char* fileName2) {\n    for (;;)\n    {\n        char c1=*(fileName1++);\n        char c2=*(fileName2++);\n        if ((c1>='a') && (c1<='z'))\n            c1 -= 0x20;\n        if ((c2>='a') && (c2<='z'))\n            c2 -= 0x20;\n        if (c1=='\\0')\n            return ((c2=='\\0') ? 0 : -1);\n        if (c2=='\\0')\n            return 1;\n        if (c1<c2)\n            return -1;\n        if (c1>c2)\n            return 1;\n    }\n}",
          "fn_code_pos": [
            [
              258,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strcmpcasenosensitive_internal",
            "parameters": {
              "fileName1": "char",
              "fileName2": "char"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzStringFileNameCompare (const char*  fileName1,\n                                             const char*  fileName2,\n                                             int iCaseSensitivity) {\n    if (iCaseSensitivity==0)\n        iCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;\n\n    if (iCaseSensitivity==1)\n        return strcmp(fileName1,fileName2);\n\n    return STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);\n}",
          "fn_code_pos": [
            [
              298,
              0
            ],
            [
              308,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzStringFileNameCompare",
            "parameters": {
              "fileName1": "char",
              "fileName2": "char",
              "iCaseSensitivity": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "local ZPOS64_T unz64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream) {\n    unsigned char* buf;\n    ZPOS64_T uSizeFile;\n    ZPOS64_T uBackRead;\n    ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */\n    ZPOS64_T uPosFound=CENTRALDIRINVALID;\n\n    if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)\n        return CENTRALDIRINVALID;\n\n\n    uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);\n\n    if (uMaxBack>uSizeFile)\n        uMaxBack = uSizeFile;\n\n    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);\n    if (buf==NULL)\n        return CENTRALDIRINVALID;\n\n    uBackRead = 4;\n    while (uBackRead<uMaxBack)\n    {\n        uLong uReadSize;\n        ZPOS64_T uReadPos ;\n        int i;\n        if (uBackRead+BUFREADCOMMENT>uMaxBack)\n            uBackRead = uMaxBack;\n        else\n            uBackRead+=BUFREADCOMMENT;\n        uReadPos = uSizeFile-uBackRead ;\n\n        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?\n                     (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);\n        if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            break;\n\n        if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)\n            break;\n\n        for (i=(int)uReadSize-3; (i--)>0;)\n            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&\n                ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))\n            {\n                uPosFound = uReadPos+(unsigned)i;\n                break;\n            }\n\n        if (uPosFound!=CENTRALDIRINVALID)\n            break;\n    }\n    free(buf);\n    return uPosFound;\n}",
          "fn_code_pos": [
            [
              322,
              0
            ],
            [
              375,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unz64local_SearchCentralDir",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_32_def",
              "filestream": "voidpf"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local ZPOS64_T unz64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def,\n                                             voidpf filestream) {\n    unsigned char* buf;\n    ZPOS64_T uSizeFile;\n    ZPOS64_T uBackRead;\n    ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */\n    ZPOS64_T uPosFound=CENTRALDIRINVALID;\n    uLong uL;\n                ZPOS64_T relativeOffset;\n\n    if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)\n        return CENTRALDIRINVALID;\n\n\n    uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);\n\n    if (uMaxBack>uSizeFile)\n        uMaxBack = uSizeFile;\n\n    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);\n    if (buf==NULL)\n        return CENTRALDIRINVALID;\n\n    uBackRead = 4;\n    while (uBackRead<uMaxBack)\n    {\n        uLong uReadSize;\n        ZPOS64_T uReadPos;\n        int i;\n        if (uBackRead+BUFREADCOMMENT>uMaxBack)\n            uBackRead = uMaxBack;\n        else\n            uBackRead+=BUFREADCOMMENT;\n        uReadPos = uSizeFile-uBackRead ;\n\n        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?\n                     (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);\n        if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            break;\n\n        if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)\n            break;\n\n        for (i=(int)uReadSize-3; (i--)>0;)\n            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&\n                ((*(buf+i+2))==0x06) && ((*(buf+i+3))==0x07))\n            {\n                uPosFound = uReadPos+(unsigned)i;\n                break;\n            }\n\n        if (uPosFound!=CENTRALDIRINVALID)\n            break;\n    }\n    free(buf);\n    if (uPosFound == CENTRALDIRINVALID)\n        return CENTRALDIRINVALID;\n\n    /* Zip64 end of central directory locator */\n    if (ZSEEK64(*pzlib_filefunc_def,filestream, uPosFound,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return CENTRALDIRINVALID;\n\n    /* the signature, already checked */\n    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)\n        return CENTRALDIRINVALID;\n\n    /* number of the disk with the start of the zip64 end of central directory */\n    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)\n        return CENTRALDIRINVALID;\n    if (uL != 0)\n        return CENTRALDIRINVALID;\n\n    /* relative offset of the zip64 end of central directory record */\n    if (unz64local_getLong64(pzlib_filefunc_def,filestream,&relativeOffset)!=UNZ_OK)\n        return CENTRALDIRINVALID;\n\n    /* total number of disks */\n    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)\n        return CENTRALDIRINVALID;\n    if (uL != 1)\n        return CENTRALDIRINVALID;\n\n    /* Goto end of central directory record */\n    if (ZSEEK64(*pzlib_filefunc_def,filestream, relativeOffset,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return CENTRALDIRINVALID;\n\n     /* the signature */\n    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)\n        return CENTRALDIRINVALID;\n\n    if (uL != 0x06064b50)\n        return CENTRALDIRINVALID;\n\n    return relativeOffset;\n}",
          "fn_code_pos": [
            [
              382,
              0
            ],
            [
              476,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unz64local_SearchCentralDir64",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_32_def",
              "filestream": "voidpf"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local unzFile unzOpenInternal(const void *path,\n                              zlib_filefunc64_32_def* pzlib_filefunc64_32_def,\n                              int is64bitOpenFunction) {\n    unz64_s us;\n    unz64_s *s;\n    ZPOS64_T central_pos;\n    uLong   uL;\n\n    uLong number_disk;          /* number of the current disk, used for\n                                   spanning ZIP, unsupported, always 0*/\n    uLong number_disk_with_CD;  /* number the disk with central dir, used\n                                   for spanning ZIP, unsupported, always 0*/\n    ZPOS64_T number_entry_CD;      /* total number of entries in\n                                   the central dir\n                                   (same than number_entry on nospan) */\n\n    int err=UNZ_OK;\n\n    if (unz_copyright[0]!=' ')\n        return NULL;\n\n    us.z_filefunc.zseek32_file = NULL;\n    us.z_filefunc.ztell32_file = NULL;\n    if (pzlib_filefunc64_32_def==NULL)\n        fill_fopen64_filefunc(&us.z_filefunc.zfile_func64);\n    else\n        us.z_filefunc = *pzlib_filefunc64_32_def;\n    us.is64bitOpenFunction = is64bitOpenFunction;\n\n\n\n    us.filestream = ZOPEN64(us.z_filefunc,\n                                                 path,\n                                                 ZLIB_FILEFUNC_MODE_READ |\n                                                 ZLIB_FILEFUNC_MODE_EXISTING);\n    if (us.filestream==NULL)\n        return NULL;\n\n    central_pos = unz64local_SearchCentralDir64(&us.z_filefunc,us.filestream);\n    if (central_pos!=CENTRALDIRINVALID)\n    {\n        uLong uS;\n        ZPOS64_T uL64;\n\n        us.isZip64 = 1;\n\n        if (ZSEEK64(us.z_filefunc, us.filestream,\n                                      central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        err=UNZ_ERRNO;\n\n        /* the signature, already checked */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* size of zip64 end of central directory record */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&uL64)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* version made by */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* version needed to extract */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of this disk */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of the disk with the start of the central directory */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central directory on this disk */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.gi.number_entry)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central directory */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&number_entry_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        if ((number_entry_CD!=us.gi.number_entry) ||\n            (number_disk_with_CD!=0) ||\n            (number_disk!=0))\n            err=UNZ_BADZIPFILE;\n\n        /* size of the central directory */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.size_central_dir)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* offset of start of central directory with respect to the\n          starting disk number */\n        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.offset_central_dir)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        us.gi.size_comment = 0;\n    }\n    else\n    {\n        central_pos = unz64local_SearchCentralDir(&us.z_filefunc,us.filestream);\n        if (central_pos==CENTRALDIRINVALID)\n            err=UNZ_ERRNO;\n\n        us.isZip64 = 0;\n\n        if (ZSEEK64(us.z_filefunc, us.filestream,\n                                        central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)\n            err=UNZ_ERRNO;\n\n        /* the signature, already checked */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of this disk */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* number of the disk with the start of the central directory */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)\n            err=UNZ_ERRNO;\n\n        /* total number of entries in the central dir on this disk */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.gi.number_entry = uL;\n\n        /* total number of entries in the central dir */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        number_entry_CD = uL;\n\n        if ((number_entry_CD!=us.gi.number_entry) ||\n            (number_disk_with_CD!=0) ||\n            (number_disk!=0))\n            err=UNZ_BADZIPFILE;\n\n        /* size of the central directory */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.size_central_dir = uL;\n\n        /* offset of start of central directory with respect to the\n            starting disk number */\n        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)\n            err=UNZ_ERRNO;\n        us.offset_central_dir = uL;\n\n        /* zipfile comment length */\n        if (unz64local_getShort(&us.z_filefunc, us.filestream,&us.gi.size_comment)!=UNZ_OK)\n            err=UNZ_ERRNO;\n    }\n\n    if ((central_pos<us.offset_central_dir+us.size_central_dir) &&\n        (err==UNZ_OK))\n        err=UNZ_BADZIPFILE;\n\n    if (err!=UNZ_OK)\n    {\n        ZCLOSE64(us.z_filefunc, us.filestream);\n        return NULL;\n    }\n\n    us.byte_before_the_zipfile = central_pos -\n                            (us.offset_central_dir+us.size_central_dir);\n    us.central_pos = central_pos;\n    us.pfile_in_zip_read = NULL;\n    us.encrypted = 0;\n\n\n    s=(unz64_s*)ALLOC(sizeof(unz64_s));\n    if( s != NULL)\n    {\n        *s=us;\n        unzGoToFirstFile((unzFile)s);\n    }\n    return (unzFile)s;\n}",
          "fn_code_pos": [
            [
              487,
              0
            ],
            [
              664,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpenInternal",
            "parameters": {
              "path": "void",
              "pzlib_filefunc64_32_def": "zlib_filefunc64_32_def",
              "is64bitOpenFunction": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "extern unzFile ZEXPORT unzOpen2(const char *path,\n                                zlib_filefunc_def* pzlib_filefunc32_def) {\n    if (pzlib_filefunc32_def != NULL)\n    {\n        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;\n        fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill,pzlib_filefunc32_def);\n        return unzOpenInternal(path, &zlib_filefunc64_32_def_fill, 0);\n    }\n    else\n        return unzOpenInternal(path, NULL, 0);\n}",
          "fn_code_pos": [
            [
              667,
              0
            ],
            [
              677,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpen2",
            "parameters": {
              "path": "char",
              "pzlib_filefunc32_def": "zlib_filefunc_def"
            },
            "return_type": "unzFile"
          }
        },
        {
          "fn_code": "extern unzFile ZEXPORT unzOpen2_64(const void *path,\n                                   zlib_filefunc64_def* pzlib_filefunc_def) {\n    if (pzlib_filefunc_def != NULL)\n    {\n        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;\n        zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;\n        zlib_filefunc64_32_def_fill.ztell32_file = NULL;\n        zlib_filefunc64_32_def_fill.zseek32_file = NULL;\n        return unzOpenInternal(path, &zlib_filefunc64_32_def_fill, 1);\n    }\n    else\n        return unzOpenInternal(path, NULL, 1);\n}",
          "fn_code_pos": [
            [
              679,
              0
            ],
            [
              691,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpen2_64",
            "parameters": {
              "path": "void",
              "pzlib_filefunc_def": "zlib_filefunc64_def"
            },
            "return_type": "unzFile"
          }
        },
        {
          "fn_code": "extern unzFile ZEXPORT unzOpen(const char *path) {\n    return unzOpenInternal(path, NULL, 0);\n}",
          "fn_code_pos": [
            [
              693,
              0
            ],
            [
              695,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpen",
            "parameters": {
              "path": "char"
            },
            "return_type": "unzFile"
          }
        },
        {
          "fn_code": "extern unzFile ZEXPORT unzOpen64(const void *path) {\n    return unzOpenInternal(path, NULL, 1);\n}",
          "fn_code_pos": [
            [
              697,
              0
            ],
            [
              699,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpen64",
            "parameters": {
              "path": "void"
            },
            "return_type": "unzFile"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzClose(unzFile file) {\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n\n    if (s->pfile_in_zip_read!=NULL)\n        unzCloseCurrentFile(file);\n\n    ZCLOSE64(s->z_filefunc, s->filestream);\n    free(s);\n    return UNZ_OK;\n}",
          "fn_code_pos": [
            [
              706,
              0
            ],
            [
              718,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzClose",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzGetGlobalInfo64(unzFile file, unz_global_info64* pglobal_info) {\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    *pglobal_info=s->gi;\n    return UNZ_OK;\n}",
          "fn_code_pos": [
            [
              725,
              0
            ],
            [
              732,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetGlobalInfo64",
            "parameters": {
              "file": "unzFile",
              "pglobal_info": "unz_global_info64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzGetGlobalInfo(unzFile file, unz_global_info* pglobal_info32) {\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    /* to do : check if number_entry is not truncated */\n    pglobal_info32->number_entry = (uLong)s->gi.number_entry;\n    pglobal_info32->size_comment = s->gi.size_comment;\n    return UNZ_OK;\n}",
          "fn_code_pos": [
            [
              734,
              0
            ],
            [
              743,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetGlobalInfo",
            "parameters": {
              "file": "unzFile",
              "pglobal_info32": "unz_global_info"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "local void unz64local_DosDateToTmuDate(ZPOS64_T ulDosDate, tm_unz* ptm) {\n    ZPOS64_T uDate;\n    uDate = (ZPOS64_T)(ulDosDate>>16);\n    ptm->tm_mday = (int)(uDate&0x1f) ;\n    ptm->tm_mon =  (int)((((uDate)&0x1E0)/0x20)-1) ;\n    ptm->tm_year = (int)(((uDate&0x0FE00)/0x0200)+1980) ;\n\n    ptm->tm_hour = (int) ((ulDosDate &0xF800)/0x800);\n    ptm->tm_min =  (int) ((ulDosDate&0x7E0)/0x20) ;\n    ptm->tm_sec =  (int) (2*(ulDosDate&0x1f)) ;\n}",
          "fn_code_pos": [
            [
              747,
              0
            ],
            [
              757,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unz64local_DosDateToTmuDate",
            "parameters": {
              "ulDosDate": "ZPOS64_T",
              "ptm": "tm_unz"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int unz64local_GetCurrentFileInfoInternal(unzFile file,\n                                                unz_file_info64 *pfile_info,\n                                                unz_file_info64_internal\n                                                *pfile_info_internal,\n                                                char *szFileName,\n                                                uLong fileNameBufferSize,\n                                                void *extraField,\n                                                uLong extraFieldBufferSize,\n                                                char *szComment,\n                                                uLong commentBufferSize) {\n    unz64_s* s;\n    unz_file_info64 file_info;\n    unz_file_info64_internal file_info_internal;\n    int err=UNZ_OK;\n    uLong uMagic;\n    long lSeek=0;\n    uLong uL;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (ZSEEK64(s->z_filefunc, s->filestream,\n              s->pos_in_central_dir+s->byte_before_the_zipfile,\n              ZLIB_FILEFUNC_SEEK_SET)!=0)\n        err=UNZ_ERRNO;\n\n\n    /* we check the magic */\n    if (err==UNZ_OK)\n    {\n        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)\n            err=UNZ_ERRNO;\n        else if (uMagic!=0x02014b50)\n            err=UNZ_BADZIPFILE;\n    }\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.version) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.version_needed) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.flag) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.compression_method) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.dosDate) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    unz64local_DosDateToTmuDate(file_info.dosDate,&file_info.tmu_date);\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.crc) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)\n        err=UNZ_ERRNO;\n    file_info.compressed_size = uL;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)\n        err=UNZ_ERRNO;\n    file_info.uncompressed_size = uL;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_filename) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_extra) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_comment) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.disk_num_start) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.internal_fa) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.external_fa) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n                // relative offset of local header\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)\n        err=UNZ_ERRNO;\n    file_info_internal.offset_curfile = uL;\n\n    lSeek+=file_info.size_filename;\n    if ((err==UNZ_OK) && (szFileName!=NULL))\n    {\n        uLong uSizeRead ;\n        if (file_info.size_filename<fileNameBufferSize)\n        {\n            *(szFileName+file_info.size_filename)='\\0';\n            uSizeRead = file_info.size_filename;\n        }\n        else\n            uSizeRead = fileNameBufferSize;\n\n        if ((file_info.size_filename>0) && (fileNameBufferSize>0))\n            if (ZREAD64(s->z_filefunc, s->filestream,szFileName,uSizeRead)!=uSizeRead)\n                err=UNZ_ERRNO;\n        lSeek -= uSizeRead;\n    }\n\n    // Read extrafield\n    if ((err==UNZ_OK) && (extraField!=NULL))\n    {\n        ZPOS64_T uSizeRead ;\n        if (file_info.size_file_extra<extraFieldBufferSize)\n            uSizeRead = file_info.size_file_extra;\n        else\n            uSizeRead = extraFieldBufferSize;\n\n        if (lSeek!=0)\n        {\n            if (ZSEEK64(s->z_filefunc, s->filestream,(ZPOS64_T)lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)\n                lSeek=0;\n            else\n                err=UNZ_ERRNO;\n        }\n\n        if ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))\n            if (ZREAD64(s->z_filefunc, s->filestream,extraField,(uLong)uSizeRead)!=uSizeRead)\n                err=UNZ_ERRNO;\n\n        lSeek += file_info.size_file_extra - (uLong)uSizeRead;\n    }\n    else\n        lSeek += file_info.size_file_extra;\n\n\n    if ((err==UNZ_OK) && (file_info.size_file_extra != 0))\n    {\n                                uLong acc = 0;\n\n        // since lSeek now points to after the extra field we need to move back\n        lSeek -= file_info.size_file_extra;\n\n        if (lSeek!=0)\n        {\n            if (ZSEEK64(s->z_filefunc, s->filestream,(ZPOS64_T)lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)\n                lSeek=0;\n            else\n                err=UNZ_ERRNO;\n        }\n\n        while(acc < file_info.size_file_extra)\n        {\n            uLong headerId;\n                                                uLong dataSize;\n\n            if (unz64local_getShort(&s->z_filefunc, s->filestream,&headerId) != UNZ_OK)\n                err=UNZ_ERRNO;\n\n            if (unz64local_getShort(&s->z_filefunc, s->filestream,&dataSize) != UNZ_OK)\n                err=UNZ_ERRNO;\n\n            /* ZIP64 extra fields */\n            if (headerId == 0x0001)\n            {\n                if(file_info.uncompressed_size == MAXU32)\n                {\n                    if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.uncompressed_size) != UNZ_OK)\n                        err=UNZ_ERRNO;\n                }\n\n                if(file_info.compressed_size == MAXU32)\n                {\n                    if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.compressed_size) != UNZ_OK)\n                        err=UNZ_ERRNO;\n                }\n\n                if(file_info_internal.offset_curfile == MAXU32)\n                {\n                    /* Relative Header offset */\n                    if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info_internal.offset_curfile) != UNZ_OK)\n                        err=UNZ_ERRNO;\n                }\n\n                if(file_info.disk_num_start == 0xffff)\n                {\n                    /* Disk Start Number */\n                    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.disk_num_start) != UNZ_OK)\n                        err=UNZ_ERRNO;\n                }\n\n            }\n            else\n            {\n                if (ZSEEK64(s->z_filefunc, s->filestream,dataSize,ZLIB_FILEFUNC_SEEK_CUR)!=0)\n                    err=UNZ_ERRNO;\n            }\n\n            acc += 2 + 2 + dataSize;\n        }\n    }\n\n    if ((err==UNZ_OK) && (szComment!=NULL))\n    {\n        uLong uSizeRead ;\n        if (file_info.size_file_comment<commentBufferSize)\n        {\n            *(szComment+file_info.size_file_comment)='\\0';\n            uSizeRead = file_info.size_file_comment;\n        }\n        else\n            uSizeRead = commentBufferSize;\n\n        if (lSeek!=0)\n        {\n            if (ZSEEK64(s->z_filefunc, s->filestream,(ZPOS64_T)lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)\n                lSeek=0;\n            else\n                err=UNZ_ERRNO;\n        }\n\n        if ((file_info.size_file_comment>0) && (commentBufferSize>0))\n            if (ZREAD64(s->z_filefunc, s->filestream,szComment,uSizeRead)!=uSizeRead)\n                err=UNZ_ERRNO;\n        lSeek+=file_info.size_file_comment - uSizeRead;\n    }\n    else\n        lSeek+=file_info.size_file_comment;\n\n\n    if ((err==UNZ_OK) && (pfile_info!=NULL))\n        *pfile_info=file_info;\n\n    if ((err==UNZ_OK) && (pfile_info_internal!=NULL))\n        *pfile_info_internal=file_info_internal;\n\n    return err;\n}",
          "fn_code_pos": [
            [
              762,
              0
            ],
            [
              995,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unz64local_GetCurrentFileInfoInternal",
            "parameters": {
              "file": "unzFile",
              "pfile_info": "unz_file_info64",
              "pfile_info_internal": "unz_file_info64_internal",
              "szFileName": "char",
              "fileNameBufferSize": "uLong",
              "extraField": "void",
              "extraFieldBufferSize": "uLong",
              "szComment": "char",
              "commentBufferSize": "uLong"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzGetCurrentFileInfo64(unzFile file,\n                                           unz_file_info64 * pfile_info,\n                                           char * szFileName, uLong fileNameBufferSize,\n                                           void *extraField, uLong extraFieldBufferSize,\n                                           char* szComment,  uLong commentBufferSize) {\n    return unz64local_GetCurrentFileInfoInternal(file,pfile_info,NULL,\n                                                 szFileName,fileNameBufferSize,\n                                                 extraField,extraFieldBufferSize,\n                                                 szComment,commentBufferSize);\n}",
          "fn_code_pos": [
            [
              1004,
              0
            ],
            [
              1013,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetCurrentFileInfo64",
            "parameters": {
              "file": "unzFile",
              "pfile_info": "unz_file_info64",
              "szFileName": "char",
              "fileNameBufferSize": "uLong",
              "extraField": "void",
              "extraFieldBufferSize": "uLong",
              "szComment": "char",
              "commentBufferSize": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzGetCurrentFileInfo(unzFile file,\n                                         unz_file_info * pfile_info,\n                                         char * szFileName, uLong fileNameBufferSize,\n                                         void *extraField, uLong extraFieldBufferSize,\n                                         char* szComment,  uLong commentBufferSize) {\n    int err;\n    unz_file_info64 file_info64;\n    err = unz64local_GetCurrentFileInfoInternal(file,&file_info64,NULL,\n                                                szFileName,fileNameBufferSize,\n                                                extraField,extraFieldBufferSize,\n                                                szComment,commentBufferSize);\n    if ((err==UNZ_OK) && (pfile_info != NULL))\n    {\n        pfile_info->version = file_info64.version;\n        pfile_info->version_needed = file_info64.version_needed;\n        pfile_info->flag = file_info64.flag;\n        pfile_info->compression_method = file_info64.compression_method;\n        pfile_info->dosDate = file_info64.dosDate;\n        pfile_info->crc = file_info64.crc;\n\n        pfile_info->size_filename = file_info64.size_filename;\n        pfile_info->size_file_extra = file_info64.size_file_extra;\n        pfile_info->size_file_comment = file_info64.size_file_comment;\n\n        pfile_info->disk_num_start = file_info64.disk_num_start;\n        pfile_info->internal_fa = file_info64.internal_fa;\n        pfile_info->external_fa = file_info64.external_fa;\n\n        pfile_info->tmu_date = file_info64.tmu_date;\n\n\n        pfile_info->compressed_size = (uLong)file_info64.compressed_size;\n        pfile_info->uncompressed_size = (uLong)file_info64.uncompressed_size;\n\n    }\n    return err;\n}",
          "fn_code_pos": [
            [
              1015,
              0
            ],
            [
              1051,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetCurrentFileInfo",
            "parameters": {
              "file": "unzFile",
              "pfile_info": "unz_file_info",
              "szFileName": "char",
              "fileNameBufferSize": "uLong",
              "extraField": "void",
              "extraFieldBufferSize": "uLong",
              "szComment": "char",
              "commentBufferSize": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzGoToFirstFile(unzFile file) {\n    int err=UNZ_OK;\n    unz64_s* s;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    s->pos_in_central_dir=s->offset_central_dir;\n    s->num_file=0;\n    err=unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n                                             &s->cur_file_info_internal,\n                                             NULL,0,NULL,0,NULL,0);\n    s->current_file_ok = (err == UNZ_OK);\n    return err;\n}",
          "fn_code_pos": [
            [
              1056,
              0
            ],
            [
              1069,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGoToFirstFile",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzGoToNextFile(unzFile file) {\n    unz64_s* s;\n    int err;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n    if (s->gi.number_entry != 0xffff)    /* 2^16 files overflow hack */\n      if (s->num_file+1==s->gi.number_entry)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +\n            s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;\n    s->num_file++;\n    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n                                               &s->cur_file_info_internal,\n                                               NULL,0,NULL,0,NULL,0);\n    s->current_file_ok = (err == UNZ_OK);\n    return err;\n}",
          "fn_code_pos": [
            [
              1076,
              0
            ],
            [
              1097,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGoToNextFile",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzLocateFile(unzFile file, const char *szFileName, int iCaseSensitivity) {\n    unz64_s* s;\n    int err;\n\n    /* We remember the 'current' position in the file so that we can jump\n     * back there if we fail.\n     */\n    unz_file_info64 cur_file_infoSaved;\n    unz_file_info64_internal cur_file_info_internalSaved;\n    ZPOS64_T num_fileSaved;\n    ZPOS64_T pos_in_central_dirSaved;\n\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n\n    if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)\n        return UNZ_PARAMERROR;\n\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    /* Save the current state */\n    num_fileSaved = s->num_file;\n    pos_in_central_dirSaved = s->pos_in_central_dir;\n    cur_file_infoSaved = s->cur_file_info;\n    cur_file_info_internalSaved = s->cur_file_info_internal;\n\n    err = unzGoToFirstFile(file);\n\n    while (err == UNZ_OK)\n    {\n        char szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];\n        err = unzGetCurrentFileInfo64(file,NULL,\n                                    szCurrentFileName,sizeof(szCurrentFileName)-1,\n                                    NULL,0,NULL,0);\n        if (err == UNZ_OK)\n        {\n            if (unzStringFileNameCompare(szCurrentFileName,\n                                            szFileName,iCaseSensitivity)==0)\n                return UNZ_OK;\n            err = unzGoToNextFile(file);\n        }\n    }\n\n    /* We failed, so restore the state of the 'current file' to where we\n     * were.\n     */\n    s->num_file = num_fileSaved ;\n    s->pos_in_central_dir = pos_in_central_dirSaved ;\n    s->cur_file_info = cur_file_infoSaved;\n    s->cur_file_info_internal = cur_file_info_internalSaved;\n    return err;\n}",
          "fn_code_pos": [
            [
              1108,
              0
            ],
            [
              1162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzLocateFile",
            "parameters": {
              "file": "unzFile",
              "szFileName": "char",
              "iCaseSensitivity": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzGetFilePos64(unzFile file, unz64_file_pos* file_pos) {\n    unz64_s* s;\n\n    if (file==NULL || file_pos==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_END_OF_LIST_OF_FILE;\n\n    file_pos->pos_in_zip_directory  = s->pos_in_central_dir;\n    file_pos->num_of_file           = s->num_file;\n\n    return UNZ_OK;\n}",
          "fn_code_pos": [
            [
              1183,
              0
            ],
            [
              1196,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetFilePos64",
            "parameters": {
              "file": "unzFile",
              "file_pos": "unz64_file_pos"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzGetFilePos(unzFile file, unz_file_pos* file_pos) {\n    unz64_file_pos file_pos64;\n    int err = unzGetFilePos64(file,&file_pos64);\n    if (err==UNZ_OK)\n    {\n        file_pos->pos_in_zip_directory = (uLong)file_pos64.pos_in_zip_directory;\n        file_pos->num_of_file = (uLong)file_pos64.num_of_file;\n    }\n    return err;\n}",
          "fn_code_pos": [
            [
              1198,
              0
            ],
            [
              1207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetFilePos",
            "parameters": {
              "file": "unzFile",
              "file_pos": "unz_file_pos"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzGoToFilePos64(unzFile file, const unz64_file_pos* file_pos) {\n    unz64_s* s;\n    int err;\n\n    if (file==NULL || file_pos==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n\n    /* jump to the right spot */\n    s->pos_in_central_dir = file_pos->pos_in_zip_directory;\n    s->num_file           = file_pos->num_of_file;\n\n    /* set the current file */\n    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n                                               &s->cur_file_info_internal,\n                                               NULL,0,NULL,0,NULL,0);\n    /* return results */\n    s->current_file_ok = (err == UNZ_OK);\n    return err;\n}",
          "fn_code_pos": [
            [
              1209,
              0
            ],
            [
              1228,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGoToFilePos64",
            "parameters": {
              "file": "unzFile",
              "file_pos": "unz64_file_pos"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzGoToFilePos(unzFile file, unz_file_pos* file_pos) {\n    unz64_file_pos file_pos64;\n    if (file_pos == NULL)\n        return UNZ_PARAMERROR;\n\n    file_pos64.pos_in_zip_directory = file_pos->pos_in_zip_directory;\n    file_pos64.num_of_file = file_pos->num_of_file;\n    return unzGoToFilePos64(file,&file_pos64);\n}",
          "fn_code_pos": [
            [
              1230,
              0
            ],
            [
              1238,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGoToFilePos",
            "parameters": {
              "file": "unzFile",
              "file_pos": "unz_file_pos"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "local int unz64local_CheckCurrentFileCoherencyHeader(unz64_s* s, uInt* piSizeVar,\n                                                     ZPOS64_T * poffset_local_extrafield,\n                                                     uInt  * psize_local_extrafield) {\n    uLong uMagic,uData,uFlags;\n    uLong size_filename;\n    uLong size_extra_field;\n    int err=UNZ_OK;\n\n    *piSizeVar = 0;\n    *poffset_local_extrafield = 0;\n    *psize_local_extrafield = 0;\n\n    if (ZSEEK64(s->z_filefunc, s->filestream,s->cur_file_info_internal.offset_curfile +\n                                s->byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n\n    if (err==UNZ_OK)\n    {\n        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)\n            err=UNZ_ERRNO;\n        else if (uMagic!=0x04034b50)\n            err=UNZ_BADZIPFILE;\n    }\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)\n        err=UNZ_ERRNO;\n/*\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))\n        err=UNZ_BADZIPFILE;\n*/\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uFlags) != UNZ_OK)\n        err=UNZ_ERRNO;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))\n        err=UNZ_BADZIPFILE;\n\n    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&\n/* #ifdef HAVE_BZIP2 */\n                         (s->cur_file_info.compression_method!=Z_BZIP2ED) &&\n/* #endif */\n                         (s->cur_file_info.compression_method!=Z_DEFLATED))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* date/time */\n        err=UNZ_ERRNO;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* crc */\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size compr */\n        err=UNZ_ERRNO;\n    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size uncompr */\n        err=UNZ_ERRNO;\n    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) && ((uFlags & 8)==0))\n        err=UNZ_BADZIPFILE;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_filename) != UNZ_OK)\n        err=UNZ_ERRNO;\n    else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))\n        err=UNZ_BADZIPFILE;\n\n    *piSizeVar += (uInt)size_filename;\n\n    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_extra_field) != UNZ_OK)\n        err=UNZ_ERRNO;\n    *poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +\n                                    SIZEZIPLOCALHEADER + size_filename;\n    *psize_local_extrafield = (uInt)size_extra_field;\n\n    *piSizeVar += (uInt)size_extra_field;\n\n    return err;\n}",
          "fn_code_pos": [
            [
              1252,
              0
            ],
            [
              1332,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unz64local_CheckCurrentFileCoherencyHeader",
            "parameters": {
              "s": "unz64_s",
              "piSizeVar": "uInt",
              "poffset_local_extrafield": "ZPOS64_T",
              "psize_local_extrafield": "uInt"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzOpenCurrentFile3(unzFile file, int* method,\n                                       int* level, int raw, const char* password) {\n    int err=UNZ_OK;\n    uInt iSizeVar;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    ZPOS64_T offset_local_extrafield;  /* offset of the local extra field */\n    uInt  size_local_extrafield;    /* size of the local extra field */\n#    ifndef NOUNCRYPT\n    char source[12];\n#    else\n    if (password != NULL)\n        return UNZ_PARAMERROR;\n#    endif\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n        return UNZ_PARAMERROR;\n\n    if (s->pfile_in_zip_read != NULL)\n        unzCloseCurrentFile(file);\n\n    if (unz64local_CheckCurrentFileCoherencyHeader(s,&iSizeVar, &offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)\n        return UNZ_BADZIPFILE;\n\n    pfile_in_zip_read_info = (file_in_zip64_read_info_s*)ALLOC(sizeof(file_in_zip64_read_info_s));\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_INTERNALERROR;\n\n    pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);\n    pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;\n    pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;\n    pfile_in_zip_read_info->pos_local_extrafield=0;\n    pfile_in_zip_read_info->raw=raw;\n\n    if (pfile_in_zip_read_info->read_buffer==NULL)\n    {\n        free(pfile_in_zip_read_info);\n        return UNZ_INTERNALERROR;\n    }\n\n    pfile_in_zip_read_info->stream_initialised=0;\n\n    if (method!=NULL)\n        *method = (int)s->cur_file_info.compression_method;\n\n    if (level!=NULL)\n    {\n        *level = 6;\n        switch (s->cur_file_info.flag & 0x06)\n        {\n          case 6 : *level = 1; break;\n          case 4 : *level = 2; break;\n          case 2 : *level = 9; break;\n        }\n    }\n\n    if ((s->cur_file_info.compression_method!=0) &&\n/* #ifdef HAVE_BZIP2 */\n        (s->cur_file_info.compression_method!=Z_BZIP2ED) &&\n/* #endif */\n        (s->cur_file_info.compression_method!=Z_DEFLATED))\n\n        err=UNZ_BADZIPFILE;\n\n    pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;\n    pfile_in_zip_read_info->crc32=0;\n    pfile_in_zip_read_info->total_out_64=0;\n    pfile_in_zip_read_info->compression_method = s->cur_file_info.compression_method;\n    pfile_in_zip_read_info->filestream=s->filestream;\n    pfile_in_zip_read_info->z_filefunc=s->z_filefunc;\n    pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;\n\n    pfile_in_zip_read_info->stream.total_out = 0;\n\n    if ((s->cur_file_info.compression_method==Z_BZIP2ED) && (!raw))\n    {\n#ifdef HAVE_BZIP2\n      pfile_in_zip_read_info->bstream.bzalloc = (void *(*) (void *, int, int))0;\n      pfile_in_zip_read_info->bstream.bzfree = (free_func)0;\n      pfile_in_zip_read_info->bstream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->bstream.state = (voidpf)0;\n\n      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->stream.next_in = (voidpf)0;\n      pfile_in_zip_read_info->stream.avail_in = 0;\n\n      err=BZ2_bzDecompressInit(&pfile_in_zip_read_info->bstream, 0, 0);\n      if (err == Z_OK)\n        pfile_in_zip_read_info->stream_initialised=Z_BZIP2ED;\n      else\n      {\n        free(pfile_in_zip_read_info->read_buffer);\n        free(pfile_in_zip_read_info);\n        return err;\n      }\n#else\n      pfile_in_zip_read_info->raw=1;\n#endif\n    }\n    else if ((s->cur_file_info.compression_method==Z_DEFLATED) && (!raw))\n    {\n      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;\n      pfile_in_zip_read_info->stream.zfree = (free_func)0;\n      pfile_in_zip_read_info->stream.opaque = (voidpf)0;\n      pfile_in_zip_read_info->stream.next_in = 0;\n      pfile_in_zip_read_info->stream.avail_in = 0;\n\n      err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);\n      if (err == Z_OK)\n        pfile_in_zip_read_info->stream_initialised=Z_DEFLATED;\n      else\n      {\n        free(pfile_in_zip_read_info->read_buffer);\n        free(pfile_in_zip_read_info);\n        return err;\n      }\n        /* windowBits is passed < 0 to tell that there is no zlib header.\n         * Note that in this case inflate *requires* an extra \"dummy\" byte\n         * after the compressed stream in order to complete decompression and\n         * return Z_STREAM_END.\n         * In unzip, i don't wait absolutely Z_STREAM_END because I known the\n         * size of both compressed and uncompressed data\n         */\n    }\n    pfile_in_zip_read_info->rest_read_compressed =\n            s->cur_file_info.compressed_size ;\n    pfile_in_zip_read_info->rest_read_uncompressed =\n            s->cur_file_info.uncompressed_size ;\n\n\n    pfile_in_zip_read_info->pos_in_zipfile =\n            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +\n              iSizeVar;\n\n    pfile_in_zip_read_info->stream.avail_in = (uInt)0;\n\n    s->pfile_in_zip_read = pfile_in_zip_read_info;\n                s->encrypted = 0;\n\n#    ifndef NOUNCRYPT\n    if (password != NULL)\n    {\n        int i;\n        s->pcrc_32_tab = get_crc_table();\n        init_keys(password,s->keys,s->pcrc_32_tab);\n        if (ZSEEK64(s->z_filefunc, s->filestream,\n                  s->pfile_in_zip_read->pos_in_zipfile +\n                     s->pfile_in_zip_read->byte_before_the_zipfile,\n                  SEEK_SET)!=0)\n            return UNZ_INTERNALERROR;\n        if(ZREAD64(s->z_filefunc, s->filestream,source, 12)<12)\n            return UNZ_INTERNALERROR;\n\n        for (i = 0; i<12; i++)\n            zdecode(s->keys,s->pcrc_32_tab,source[i]);\n\n        s->pfile_in_zip_read->pos_in_zipfile+=12;\n        s->encrypted=1;\n    }\n#    endif\n\n\n    return UNZ_OK;\n}",
          "fn_code_pos": [
            [
              1338,
              0
            ],
            [
              1506,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpenCurrentFile3",
            "parameters": {
              "file": "unzFile",
              "method": "int",
              "level": "int",
              "raw": "int",
              "password": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzOpenCurrentFile(unzFile file) {\n    return unzOpenCurrentFile3(file, NULL, NULL, 0, NULL);\n}",
          "fn_code_pos": [
            [
              1508,
              0
            ],
            [
              1510,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpenCurrentFile",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzOpenCurrentFilePassword(unzFile file, const char* password) {\n    return unzOpenCurrentFile3(file, NULL, NULL, 0, password);\n}",
          "fn_code_pos": [
            [
              1512,
              0
            ],
            [
              1514,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpenCurrentFilePassword",
            "parameters": {
              "file": "unzFile",
              "password": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzOpenCurrentFile2(unzFile file, int* method, int* level, int raw) {\n    return unzOpenCurrentFile3(file, method, level, raw, NULL);\n}",
          "fn_code_pos": [
            [
              1516,
              0
            ],
            [
              1518,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpenCurrentFile2",
            "parameters": {
              "file": "unzFile",
              "method": "int",
              "level": "int",
              "raw": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern ZPOS64_T ZEXPORT unzGetCurrentFileZStreamPos64(unzFile file) {\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    s=(unz64_s*)file;\n    if (file==NULL)\n        return 0; //UNZ_PARAMERROR;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n    if (pfile_in_zip_read_info==NULL)\n        return 0; //UNZ_PARAMERROR;\n    return pfile_in_zip_read_info->pos_in_zipfile +\n                         pfile_in_zip_read_info->byte_before_the_zipfile;\n}",
          "fn_code_pos": [
            [
              1522,
              0
            ],
            [
              1533,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetCurrentFileZStreamPos64",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "ZPOS64_T"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzReadCurrentFile(unzFile file, voidp buf, unsigned len) {\n    int err=UNZ_OK;\n    uInt iRead = 0;\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n\n    if (pfile_in_zip_read_info->read_buffer == NULL)\n        return UNZ_END_OF_LIST_OF_FILE;\n    if (len==0)\n        return 0;\n\n    pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;\n\n    pfile_in_zip_read_info->stream.avail_out = (uInt)len;\n\n    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&\n        (!(pfile_in_zip_read_info->raw)))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;\n\n    if ((len>pfile_in_zip_read_info->rest_read_compressed+\n           pfile_in_zip_read_info->stream.avail_in) &&\n         (pfile_in_zip_read_info->raw))\n        pfile_in_zip_read_info->stream.avail_out =\n            (uInt)pfile_in_zip_read_info->rest_read_compressed+\n            pfile_in_zip_read_info->stream.avail_in;\n\n    while (pfile_in_zip_read_info->stream.avail_out>0)\n    {\n        if ((pfile_in_zip_read_info->stream.avail_in==0) &&\n            (pfile_in_zip_read_info->rest_read_compressed>0))\n        {\n            uInt uReadThis = UNZ_BUFSIZE;\n            if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)\n                uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;\n            if (uReadThis == 0)\n                return UNZ_EOF;\n            if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->pos_in_zipfile +\n                         pfile_in_zip_read_info->byte_before_the_zipfile,\n                         ZLIB_FILEFUNC_SEEK_SET)!=0)\n                return UNZ_ERRNO;\n            if (ZREAD64(pfile_in_zip_read_info->z_filefunc,\n                      pfile_in_zip_read_info->filestream,\n                      pfile_in_zip_read_info->read_buffer,\n                      uReadThis)!=uReadThis)\n                return UNZ_ERRNO;\n\n\n#            ifndef NOUNCRYPT\n            if(s->encrypted)\n            {\n                uInt i;\n                for(i=0;i<uReadThis;i++)\n                  pfile_in_zip_read_info->read_buffer[i] =\n                      (char)zdecode(s->keys,s->pcrc_32_tab,\n                              pfile_in_zip_read_info->read_buffer[i]);\n            }\n#            endif\n\n\n            pfile_in_zip_read_info->pos_in_zipfile += uReadThis;\n\n            pfile_in_zip_read_info->rest_read_compressed-=uReadThis;\n\n            pfile_in_zip_read_info->stream.next_in =\n                (Bytef*)pfile_in_zip_read_info->read_buffer;\n            pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;\n        }\n\n        if ((pfile_in_zip_read_info->compression_method==0) || (pfile_in_zip_read_info->raw))\n        {\n            uInt uDoCopy,i ;\n\n            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                return (iRead==0) ? UNZ_EOF : (int)iRead;\n\n            if (pfile_in_zip_read_info->stream.avail_out <\n                            pfile_in_zip_read_info->stream.avail_in)\n                uDoCopy = pfile_in_zip_read_info->stream.avail_out ;\n            else\n                uDoCopy = pfile_in_zip_read_info->stream.avail_in ;\n\n            for (i=0;i<uDoCopy;i++)\n                *(pfile_in_zip_read_info->stream.next_out+i) =\n                        *(pfile_in_zip_read_info->stream.next_in+i);\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uDoCopy;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,\n                                pfile_in_zip_read_info->stream.next_out,\n                                uDoCopy);\n            pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;\n            pfile_in_zip_read_info->stream.avail_in -= uDoCopy;\n            pfile_in_zip_read_info->stream.avail_out -= uDoCopy;\n            pfile_in_zip_read_info->stream.next_out += uDoCopy;\n            pfile_in_zip_read_info->stream.next_in += uDoCopy;\n            pfile_in_zip_read_info->stream.total_out += uDoCopy;\n            iRead += uDoCopy;\n        }\n        else if (pfile_in_zip_read_info->compression_method==Z_BZIP2ED)\n        {\n#ifdef HAVE_BZIP2\n            uLong uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            uLong uOutThis;\n\n            pfile_in_zip_read_info->bstream.next_in        = (char*)pfile_in_zip_read_info->stream.next_in;\n            pfile_in_zip_read_info->bstream.avail_in       = pfile_in_zip_read_info->stream.avail_in;\n            pfile_in_zip_read_info->bstream.total_in_lo32  = pfile_in_zip_read_info->stream.total_in;\n            pfile_in_zip_read_info->bstream.total_in_hi32  = 0;\n            pfile_in_zip_read_info->bstream.next_out       = (char*)pfile_in_zip_read_info->stream.next_out;\n            pfile_in_zip_read_info->bstream.avail_out      = pfile_in_zip_read_info->stream.avail_out;\n            pfile_in_zip_read_info->bstream.total_out_lo32 = pfile_in_zip_read_info->stream.total_out;\n            pfile_in_zip_read_info->bstream.total_out_hi32 = 0;\n\n            uTotalOutBefore = pfile_in_zip_read_info->bstream.total_out_lo32;\n            bufBefore = (const Bytef *)pfile_in_zip_read_info->bstream.next_out;\n\n            err=BZ2_bzDecompress(&pfile_in_zip_read_info->bstream);\n\n            uTotalOutAfter = pfile_in_zip_read_info->bstream.total_out_lo32;\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,bufBefore, (uInt)(uOutThis));\n            pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            pfile_in_zip_read_info->stream.next_in   = (Bytef*)pfile_in_zip_read_info->bstream.next_in;\n            pfile_in_zip_read_info->stream.avail_in  = pfile_in_zip_read_info->bstream.avail_in;\n            pfile_in_zip_read_info->stream.total_in  = pfile_in_zip_read_info->bstream.total_in_lo32;\n            pfile_in_zip_read_info->stream.next_out  = (Bytef*)pfile_in_zip_read_info->bstream.next_out;\n            pfile_in_zip_read_info->stream.avail_out = pfile_in_zip_read_info->bstream.avail_out;\n            pfile_in_zip_read_info->stream.total_out = pfile_in_zip_read_info->bstream.total_out_lo32;\n\n            if (err==BZ_STREAM_END)\n              return (iRead==0) ? UNZ_EOF : iRead;\n            if (err!=BZ_OK)\n              break;\n#endif\n        } // end Z_BZIP2ED\n        else\n        {\n            ZPOS64_T uTotalOutBefore,uTotalOutAfter;\n            const Bytef *bufBefore;\n            ZPOS64_T uOutThis;\n            int flush=Z_SYNC_FLUSH;\n\n            uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;\n            bufBefore = pfile_in_zip_read_info->stream.next_out;\n\n            /*\n            if ((pfile_in_zip_read_info->rest_read_uncompressed ==\n                     pfile_in_zip_read_info->stream.avail_out) &&\n                (pfile_in_zip_read_info->rest_read_compressed == 0))\n                flush = Z_FINISH;\n            */\n            err=inflate(&pfile_in_zip_read_info->stream,flush);\n\n            if ((err>=0) && (pfile_in_zip_read_info->stream.msg!=NULL))\n              err = Z_DATA_ERROR;\n\n            uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;\n            /* Detect overflow, because z_stream.total_out is uLong (32 bits) */\n            if (uTotalOutAfter<uTotalOutBefore)\n                uTotalOutAfter += 1LL << 32; /* Add maximum value of uLong + 1 */\n            uOutThis = uTotalOutAfter-uTotalOutBefore;\n\n            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;\n\n            pfile_in_zip_read_info->crc32 =\n                crc32(pfile_in_zip_read_info->crc32,bufBefore,\n                        (uInt)(uOutThis));\n\n            pfile_in_zip_read_info->rest_read_uncompressed -=\n                uOutThis;\n\n            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);\n\n            if (err==Z_STREAM_END)\n                return (iRead==0) ? UNZ_EOF : (int)iRead;\n            if (err!=Z_OK)\n                break;\n        }\n    }\n\n    if (err==Z_OK)\n        return (int)iRead;\n    return err;\n}",
          "fn_code_pos": [
            [
              1547,
              0
            ],
            [
              1748,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzReadCurrentFile",
            "parameters": {
              "file": "unzFile",
              "buf": "voidp",
              "len": "unsigned"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern z_off_t ZEXPORT unztell(unzFile file) {\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    return (z_off_t)pfile_in_zip_read_info->stream.total_out;\n}",
          "fn_code_pos": [
            [
              1754,
              0
            ],
            [
              1766,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unztell",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "z_off_t"
          }
        },
        {
          "fn_code": "extern ZPOS64_T ZEXPORT unztell64(unzFile file) {\n\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return (ZPOS64_T)-1;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return (ZPOS64_T)-1;\n\n    return pfile_in_zip_read_info->total_out_64;\n}",
          "fn_code_pos": [
            [
              1768,
              0
            ],
            [
              1781,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unztell64",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "ZPOS64_T"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzeof(unzFile file) {\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    if (pfile_in_zip_read_info->rest_read_uncompressed == 0)\n        return 1;\n    else\n        return 0;\n}",
          "fn_code_pos": [
            [
              1787,
              0
            ],
            [
              1802,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzeof",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzGetLocalExtrafield(unzFile file, voidp buf, unsigned len) {\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    uInt read_now;\n    ZPOS64_T size_to_read;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n    size_to_read = (pfile_in_zip_read_info->size_local_extrafield -\n                pfile_in_zip_read_info->pos_local_extrafield);\n\n    if (buf==NULL)\n        return (int)size_to_read;\n\n    if (len>size_to_read)\n        read_now = (uInt)size_to_read;\n    else\n        read_now = (uInt)len ;\n\n    if (read_now==0)\n        return 0;\n\n    if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,\n              pfile_in_zip_read_info->filestream,\n              pfile_in_zip_read_info->offset_local_extrafield +\n              pfile_in_zip_read_info->pos_local_extrafield,\n              ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n    if (ZREAD64(pfile_in_zip_read_info->z_filefunc,\n              pfile_in_zip_read_info->filestream,\n              buf,read_now)!=read_now)\n        return UNZ_ERRNO;\n\n    return (int)read_now;\n}",
          "fn_code_pos": [
            [
              1818,
              0
            ],
            [
              1859,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetLocalExtrafield",
            "parameters": {
              "file": "unzFile",
              "buf": "voidp",
              "len": "unsigned"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzCloseCurrentFile(unzFile file) {\n    int err=UNZ_OK;\n\n    unz64_s* s;\n    file_in_zip64_read_info_s* pfile_in_zip_read_info;\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    pfile_in_zip_read_info=s->pfile_in_zip_read;\n\n    if (pfile_in_zip_read_info==NULL)\n        return UNZ_PARAMERROR;\n\n\n    if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&\n        (!pfile_in_zip_read_info->raw))\n    {\n        if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)\n            err=UNZ_CRCERROR;\n    }\n\n\n    free(pfile_in_zip_read_info->read_buffer);\n    pfile_in_zip_read_info->read_buffer = NULL;\n    if (pfile_in_zip_read_info->stream_initialised == Z_DEFLATED)\n        inflateEnd(&pfile_in_zip_read_info->stream);\n#ifdef HAVE_BZIP2\n    else if (pfile_in_zip_read_info->stream_initialised == Z_BZIP2ED)\n        BZ2_bzDecompressEnd(&pfile_in_zip_read_info->bstream);\n#endif\n\n\n    pfile_in_zip_read_info->stream_initialised = 0;\n    free(pfile_in_zip_read_info);\n\n    s->pfile_in_zip_read=NULL;\n\n    return err;\n}",
          "fn_code_pos": [
            [
              1865,
              0
            ],
            [
              1903,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzCloseCurrentFile",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzGetGlobalComment(unzFile file, char * szComment, uLong uSizeBuf) {\n    unz64_s* s;\n    uLong uReadThis ;\n    if (file==NULL)\n        return (int)UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n\n    uReadThis = uSizeBuf;\n    if (uReadThis>s->gi.size_comment)\n        uReadThis = s->gi.size_comment;\n\n    if (ZSEEK64(s->z_filefunc,s->filestream,s->central_pos+22,ZLIB_FILEFUNC_SEEK_SET)!=0)\n        return UNZ_ERRNO;\n\n    if (uReadThis>0)\n    {\n      *szComment='\\0';\n      if (ZREAD64(s->z_filefunc,s->filestream,szComment,uReadThis)!=uReadThis)\n        return UNZ_ERRNO;\n    }\n\n    if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))\n        *(szComment+s->gi.size_comment)='\\0';\n    return (int)uReadThis;\n}",
          "fn_code_pos": [
            [
              1911,
              0
            ],
            [
              1935,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetGlobalComment",
            "parameters": {
              "file": "unzFile",
              "szComment": "char",
              "uSizeBuf": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern ZPOS64_T ZEXPORT unzGetOffset64(unzFile file) {\n    unz64_s* s;\n\n    if (file==NULL)\n          return 0; //UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n    if (!s->current_file_ok)\n      return 0;\n    if (s->gi.number_entry != 0 && s->gi.number_entry != 0xffff)\n      if (s->num_file==s->gi.number_entry)\n         return 0;\n    return s->pos_in_central_dir;\n}",
          "fn_code_pos": [
            [
              1938,
              0
            ],
            [
              1950,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetOffset64",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "ZPOS64_T"
          }
        },
        {
          "fn_code": "extern uLong ZEXPORT unzGetOffset(unzFile file) {\n    ZPOS64_T offset64;\n\n    if (file==NULL)\n          return 0; //UNZ_PARAMERROR;\n    offset64 = unzGetOffset64(file);\n    return (uLong)offset64;\n}",
          "fn_code_pos": [
            [
              1952,
              0
            ],
            [
              1959,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetOffset",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzSetOffset64(unzFile file, ZPOS64_T pos) {\n    unz64_s* s;\n    int err;\n\n    if (file==NULL)\n        return UNZ_PARAMERROR;\n    s=(unz64_s*)file;\n\n    s->pos_in_central_dir = pos;\n    s->num_file = s->gi.number_entry;      /* hack */\n    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,\n                                              &s->cur_file_info_internal,\n                                              NULL,0,NULL,0,NULL,0);\n    s->current_file_ok = (err == UNZ_OK);\n    return err;\n}",
          "fn_code_pos": [
            [
              1961,
              0
            ],
            [
              1976,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzSetOffset64",
            "parameters": {
              "file": "unzFile",
              "pos": "ZPOS64_T"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extern int ZEXPORT unzSetOffset (unzFile file, uLong pos) {\n    return unzSetOffset64(file,pos);\n}",
          "fn_code_pos": [
            [
              1978,
              0
            ],
            [
              1980,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzSetOffset",
            "parameters": {
              "file": "unzFile",
              "pos": "uLong"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct unz_file_info64_internal_s\n{\n    ZPOS64_T offset_curfile;/* relative offset of local header 8 bytes */\n} unz_file_info64_internal;",
          {
            "offset_curfile": "ZPOS64_T"
          },
          "unz_file_info64_internal",
          [
            116,
            0
          ],
          [
            119,
            27
          ]
        ],
        [
          "typedef struct\n{\n    char  *read_buffer;         /* internal buffer for compressed data */\n    z_stream stream;            /* zLib stream structure for inflate */\n\n#ifdef HAVE_BZIP2\n    bz_stream bstream;          /* bzLib stream structure for bziped */\n#endif\n\n    ZPOS64_T pos_in_zipfile;       /* position in byte on the zipfile, for fseek*/\n    uLong stream_initialised;   /* flag set if stream structure is initialised*/\n\n    ZPOS64_T offset_local_extrafield;/* offset of the local extra field */\n    uInt  size_local_extrafield;/* size of the local extra field */\n    ZPOS64_T pos_local_extrafield;   /* position in the local extra field in read*/\n    ZPOS64_T total_out_64;\n\n    uLong crc32;                /* crc32 of all data uncompressed */\n    uLong crc32_wait;           /* crc32 we must obtain after decompress all */\n    ZPOS64_T rest_read_compressed; /* number of byte to be decompressed */\n    ZPOS64_T rest_read_uncompressed;/*number of byte to be obtained after decomp*/\n    zlib_filefunc64_32_def z_filefunc;\n    voidpf filestream;        /* io structure of the zipfile */\n    uLong compression_method;   /* compression method (0==store) */\n    ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/\n    int   raw;\n} file_in_zip64_read_info_s;",
          {
            "*read_buffer": "char",
            "stream": "z_stream",
            "bstream": "bz_stream",
            "pos_in_zipfile": "ZPOS64_T",
            "stream_initialised": "uLong",
            "offset_local_extrafield": "ZPOS64_T",
            "size_local_extrafield": "uInt",
            "pos_local_extrafield": "ZPOS64_T",
            "total_out_64": "ZPOS64_T",
            "crc32": "uLong",
            "crc32_wait": "uLong",
            "rest_read_compressed": "ZPOS64_T",
            "rest_read_uncompressed": "ZPOS64_T",
            "z_filefunc": "zlib_filefunc64_32_def",
            "filestream": "voidpf",
            "compression_method": "uLong",
            "byte_before_the_zipfile": "ZPOS64_T",
            "raw": "int"
          },
          "file_in_zip64_read_info_s",
          [
            124,
            0
          ],
          [
            150,
            28
          ]
        ],
        [
          "typedef struct\n{\n    zlib_filefunc64_32_def z_filefunc;\n    int is64bitOpenFunction;\n    voidpf filestream;        /* io structure of the zipfile */\n    unz_global_info64 gi;       /* public global information */\n    ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/\n    ZPOS64_T num_file;             /* number of the current file in the zipfile*/\n    ZPOS64_T pos_in_central_dir;   /* pos of the current file in the central dir*/\n    ZPOS64_T current_file_ok;      /* flag about the usability of the current file*/\n    ZPOS64_T central_pos;          /* position of the beginning of the central dir*/\n\n    ZPOS64_T size_central_dir;     /* size of the central directory  */\n    ZPOS64_T offset_central_dir;   /* offset of start of central directory with\n                                   respect to the starting disk number */\n\n    unz_file_info64 cur_file_info; /* public info about the current file in zip*/\n    unz_file_info64_internal cur_file_info_internal; /* private info about it*/\n    file_in_zip64_read_info_s* pfile_in_zip_read; /* structure about the current\n                                        file if we are decompressing it */\n    int encrypted;\n\n    int isZip64;\n\n#    ifndef NOUNCRYPT\n    unsigned long keys[3];     /* keys defining the pseudo-random sequence */\n    const z_crc_t* pcrc_32_tab;\n#    endif\n} unz64_s;",
          {
            "z_filefunc": "zlib_filefunc64_32_def",
            "is64bitOpenFunction": "int",
            "filestream": "voidpf",
            "gi": "unz_global_info64",
            "byte_before_the_zipfile": "ZPOS64_T",
            "num_file": "ZPOS64_T",
            "pos_in_central_dir": "ZPOS64_T",
            "current_file_ok": "ZPOS64_T",
            "central_pos": "ZPOS64_T",
            "size_central_dir": "ZPOS64_T",
            "offset_central_dir": "ZPOS64_T",
            "cur_file_info": "unz_file_info64",
            "cur_file_info_internal": "unz_file_info64_internal",
            "* pfile_in_zip_read": "file_in_zip64_read_info_s",
            "encrypted": "int",
            "isZip64": "int",
            "keys[3]": "unsigned long",
            "z_crc_t": "const"
          },
          "unz64_s",
          [
            155,
            0
          ],
          [
            183,
            10
          ]
        ],
        [
          "typedef struct unz_file_info64_internal_s\n{\n    ZPOS64_T offset_curfile;/* relative offset of local header 8 bytes */\n} unz_file_info64_internal;",
          {
            "offset_curfile": "ZPOS64_T"
          },
          "unz_file_info64_internal",
          [
            116,
            0
          ],
          [
            119,
            27
          ]
        ],
        [
          "typedef struct\n{\n    char  *read_buffer;         /* internal buffer for compressed data */\n    z_stream stream;            /* zLib stream structure for inflate */\n\n#ifdef HAVE_BZIP2\n    bz_stream bstream;          /* bzLib stream structure for bziped */\n#endif\n\n    ZPOS64_T pos_in_zipfile;       /* position in byte on the zipfile, for fseek*/\n    uLong stream_initialised;   /* flag set if stream structure is initialised*/\n\n    ZPOS64_T offset_local_extrafield;/* offset of the local extra field */\n    uInt  size_local_extrafield;/* size of the local extra field */\n    ZPOS64_T pos_local_extrafield;   /* position in the local extra field in read*/\n    ZPOS64_T total_out_64;\n\n    uLong crc32;                /* crc32 of all data uncompressed */\n    uLong crc32_wait;           /* crc32 we must obtain after decompress all */\n    ZPOS64_T rest_read_compressed; /* number of byte to be decompressed */\n    ZPOS64_T rest_read_uncompressed;/*number of byte to be obtained after decomp*/\n    zlib_filefunc64_32_def z_filefunc;\n    voidpf filestream;        /* io structure of the zipfile */\n    uLong compression_method;   /* compression method (0==store) */\n    ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/\n    int   raw;\n} file_in_zip64_read_info_s;",
          {
            "*read_buffer": "char",
            "stream": "z_stream",
            "bstream": "bz_stream",
            "pos_in_zipfile": "ZPOS64_T",
            "stream_initialised": "uLong",
            "offset_local_extrafield": "ZPOS64_T",
            "size_local_extrafield": "uInt",
            "pos_local_extrafield": "ZPOS64_T",
            "total_out_64": "ZPOS64_T",
            "crc32": "uLong",
            "crc32_wait": "uLong",
            "rest_read_compressed": "ZPOS64_T",
            "rest_read_uncompressed": "ZPOS64_T",
            "z_filefunc": "zlib_filefunc64_32_def",
            "filestream": "voidpf",
            "compression_method": "uLong",
            "byte_before_the_zipfile": "ZPOS64_T",
            "raw": "int"
          },
          "file_in_zip64_read_info_s",
          [
            124,
            0
          ],
          [
            150,
            28
          ]
        ],
        [
          "typedef struct\n{\n    zlib_filefunc64_32_def z_filefunc;\n    int is64bitOpenFunction;\n    voidpf filestream;        /* io structure of the zipfile */\n    unz_global_info64 gi;       /* public global information */\n    ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/\n    ZPOS64_T num_file;             /* number of the current file in the zipfile*/\n    ZPOS64_T pos_in_central_dir;   /* pos of the current file in the central dir*/\n    ZPOS64_T current_file_ok;      /* flag about the usability of the current file*/\n    ZPOS64_T central_pos;          /* position of the beginning of the central dir*/\n\n    ZPOS64_T size_central_dir;     /* size of the central directory  */\n    ZPOS64_T offset_central_dir;   /* offset of start of central directory with\n                                   respect to the starting disk number */\n\n    unz_file_info64 cur_file_info; /* public info about the current file in zip*/\n    unz_file_info64_internal cur_file_info_internal; /* private info about it*/\n    file_in_zip64_read_info_s* pfile_in_zip_read; /* structure about the current\n                                        file if we are decompressing it */\n    int encrypted;\n\n    int isZip64;\n\n#    ifndef NOUNCRYPT\n    unsigned long keys[3];     /* keys defining the pseudo-random sequence */\n    const z_crc_t* pcrc_32_tab;\n#    endif\n} unz64_s;",
          {
            "z_filefunc": "zlib_filefunc64_32_def",
            "is64bitOpenFunction": "int",
            "filestream": "voidpf",
            "gi": "unz_global_info64",
            "byte_before_the_zipfile": "ZPOS64_T",
            "num_file": "ZPOS64_T",
            "pos_in_central_dir": "ZPOS64_T",
            "current_file_ok": "ZPOS64_T",
            "central_pos": "ZPOS64_T",
            "size_central_dir": "ZPOS64_T",
            "offset_central_dir": "ZPOS64_T",
            "cur_file_info": "unz_file_info64",
            "cur_file_info_internal": "unz_file_info64_internal",
            "* pfile_in_zip_read": "file_in_zip64_read_info_s",
            "encrypted": "int",
            "isZip64": "int",
            "keys[3]": "unsigned long",
            "z_crc_t": "const"
          },
          "unz64_s",
          [
            155,
            0
          ],
          [
            183,
            10
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            66,
            0
          ],
          [
            67,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            67,
            0
          ],
          [
            68,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            68,
            0
          ],
          [
            69,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            70,
            0
          ],
          [
            71,
            0
          ]
        ],
        [
          "#include \"unzip.h\"\n",
          [
            71,
            0
          ],
          [
            72,
            0
          ]
        ],
        [
          "#  include <stddef.h>\n",
          [
            74,
            0
          ],
          [
            75,
            0
          ]
        ],
        [
          "#   include <errno.h>\n",
          [
            79,
            0
          ],
          [
            80,
            0
          ]
        ],
        [
          "#include \"crypt.h\"\n",
          [
            187,
            0
          ],
          [
            188,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/minizip/miniunz.c": {
      "fn_def_list": [
        {
          "fn_code": "static void change_file_date(const char *filename, uLong dosdate, tm_unz tmu_date) {\n#ifdef _WIN32\n  (void)tmu_date;\n  HANDLE hFile;\n  FILETIME ftm,ftLocal,ftCreate,ftLastAcc,ftLastWrite;\n\n  hFile = CreateFileA(filename,GENERIC_READ | GENERIC_WRITE,\n                      0,NULL,OPEN_EXISTING,0,NULL);\n  GetFileTime(hFile,&ftCreate,&ftLastAcc,&ftLastWrite);\n  DosDateTimeToFileTime((WORD)(dosdate>>16),(WORD)dosdate,&ftLocal);\n  LocalFileTimeToFileTime(&ftLocal,&ftm);\n  SetFileTime(hFile,&ftm,&ftLastAcc,&ftm);\n  CloseHandle(hFile);\n#elif defined(__unix__) || defined(__unix) || defined(__APPLE__)\n  (void)dosdate;\n  struct utimbuf ut;\n  struct tm newdate;\n  newdate.tm_sec = tmu_date.tm_sec;\n  newdate.tm_min=tmu_date.tm_min;\n  newdate.tm_hour=tmu_date.tm_hour;\n  newdate.tm_mday=tmu_date.tm_mday;\n  newdate.tm_mon=tmu_date.tm_mon;\n  if (tmu_date.tm_year > 1900)\n      newdate.tm_year=tmu_date.tm_year - 1900;\n  else\n      newdate.tm_year=tmu_date.tm_year ;\n  newdate.tm_isdst=-1;\n\n  ut.actime=ut.modtime=mktime(&newdate);\n  utime(filename,&ut);\n#else\n  (void)filename;\n  (void)dosdate;\n  (void)tmu_date;\n#endif\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              121,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "change_file_date",
            "parameters": {
              "filename": "char",
              "dosdate": "uLong",
              "tmu_date": "tm_unz"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int mymkdir(const char* dirname) {\n    int ret=0;\n#ifdef _WIN32\n    ret = _mkdir(dirname);\n#elif defined(__unix__) || defined(__unix) || defined(__APPLE__)\n    ret = mkdir (dirname,0775);\n#else\n    (void)dirname;\n#endif\n    return ret;\n}",
          "fn_code_pos": [
            [
              127,
              0
            ],
            [
              137,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mymkdir",
            "parameters": {
              "dirname": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int makedir(const char *newdir) {\n  char *buffer ;\n  char *p;\n  size_t len = strlen(newdir);\n\n  if (len == 0)\n    return 0;\n\n  buffer = (char*)malloc(len+1);\n        if (buffer==NULL)\n        {\n                printf(\"Error allocating memory\\n\");\n                return UNZ_INTERNALERROR;\n        }\n  strcpy(buffer,newdir);\n\n  if (buffer[len-1] == '/') {\n    buffer[len-1] = '\\0';\n  }\n  if (mymkdir(buffer) == 0)\n    {\n      free(buffer);\n      return 1;\n    }\n\n  p = buffer+1;\n  while (1)\n    {\n      char hold;\n\n      while(*p && *p != '\\\\' && *p != '/')\n        p++;\n      hold = *p;\n      *p = 0;\n      if ((mymkdir(buffer) == -1) && (errno == ENOENT))\n        {\n          printf(\"couldn't create directory %s\\n\",buffer);\n          free(buffer);\n          return 0;\n        }\n      if (hold == 0)\n        break;\n      *p++ = hold;\n    }\n  free(buffer);\n  return 1;\n}",
          "fn_code_pos": [
            [
              139,
              0
            ],
            [
              185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "makedir",
            "parameters": {
              "newdir": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void do_banner(void) {\n    printf(\"MiniUnz 1.1, demo of zLib + Unz package written by Gilles Vollant\\n\");\n    printf(\"more info at http://www.winimage.com/zLibDll/unzip.html\\n\\n\");\n}",
          "fn_code_pos": [
            [
              187,
              0
            ],
            [
              190,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "do_banner",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void do_help(void) {\n    printf(\"Usage : miniunz [-e] [-x] [-v] [-l] [-o] [-p password] file.zip [file_to_extr.] [-d extractdir]\\n\\n\" \\\n           \"  -e  Extract without pathname (junk paths)\\n\" \\\n           \"  -x  Extract with pathname\\n\" \\\n           \"  -v  list files\\n\" \\\n           \"  -l  list files\\n\" \\\n           \"  -d  directory to extract into\\n\" \\\n           \"  -o  overwrite files without prompting\\n\" \\\n           \"  -p  extract encrypted file using password\\n\\n\");\n}",
          "fn_code_pos": [
            [
              192,
              0
            ],
            [
              201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "do_help",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void Display64BitsSize(ZPOS64_T n, int size_char) {\n  /* to avoid compatibility problem , we do here the conversion */\n  char number[21];\n  int offset=19;\n  int pos_string = 19;\n  number[20]=0;\n  for (;;) {\n      number[offset]=(char)((n%10)+'0');\n      if (number[offset] != '0')\n          pos_string=offset;\n      n/=10;\n      if (offset==0)\n          break;\n      offset--;\n  }\n  {\n      int size_display_string = 19-pos_string;\n      while (size_char > size_display_string)\n      {\n          size_char--;\n          printf(\" \");\n      }\n  }\n\n  printf(\"%s\",&number[pos_string]);\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              228,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Display64BitsSize",
            "parameters": {
              "n": "ZPOS64_T",
              "size_char": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int do_list(unzFile uf) {\n    uLong i;\n    unz_global_info64 gi;\n    int err;\n\n    err = unzGetGlobalInfo64(uf,&gi);\n    if (err!=UNZ_OK)\n        printf(\"error %d with zipfile in unzGetGlobalInfo \\n\",err);\n    printf(\"  Length  Method     Size Ratio   Date    Time   CRC-32     Name\\n\");\n    printf(\"  ------  ------     ---- -----   ----    ----   ------     ----\\n\");\n    for (i=0;i<gi.number_entry;i++)\n    {\n        char filename_inzip[65536+1];\n        unz_file_info64 file_info;\n        uLong ratio=0;\n        const char *string_method = \"\";\n        char charCrypt=' ';\n        err = unzGetCurrentFileInfo64(uf,&file_info,filename_inzip,sizeof(filename_inzip),NULL,0,NULL,0);\n        if (err!=UNZ_OK)\n        {\n            printf(\"error %d with zipfile in unzGetCurrentFileInfo\\n\",err);\n            break;\n        }\n        if (file_info.uncompressed_size>0)\n            ratio = (uLong)((file_info.compressed_size*100)/file_info.uncompressed_size);\n\n        /* display a '*' if the file is encrypted */\n        if ((file_info.flag & 1) != 0)\n            charCrypt='*';\n\n        if (file_info.compression_method==0)\n            string_method=\"Stored\";\n        else\n        if (file_info.compression_method==Z_DEFLATED)\n        {\n            uInt iLevel=(uInt)((file_info.flag & 0x6)/2);\n            if (iLevel==0)\n              string_method=\"Defl:N\";\n            else if (iLevel==1)\n              string_method=\"Defl:X\";\n            else if ((iLevel==2) || (iLevel==3))\n              string_method=\"Defl:F\"; /* 2:fast , 3 : extra fast*/\n        }\n        else\n        if (file_info.compression_method==Z_BZIP2ED)\n        {\n              string_method=\"BZip2 \";\n        }\n        else\n            string_method=\"Unkn. \";\n\n        Display64BitsSize(file_info.uncompressed_size,7);\n        printf(\"  %6s%c\",string_method,charCrypt);\n        Display64BitsSize(file_info.compressed_size,7);\n        printf(\" %3lu%%  %2.2lu-%2.2lu-%2.2lu  %2.2lu:%2.2lu  %8.8lx   %s\\n\",\n                ratio,\n                (uLong)file_info.tmu_date.tm_mon + 1,\n                (uLong)file_info.tmu_date.tm_mday,\n                (uLong)file_info.tmu_date.tm_year % 100,\n                (uLong)file_info.tmu_date.tm_hour,(uLong)file_info.tmu_date.tm_min,\n                (uLong)file_info.crc,filename_inzip);\n        if ((i+1)<gi.number_entry)\n        {\n            err = unzGoToNextFile(uf);\n            if (err!=UNZ_OK)\n            {\n                printf(\"error %d with zipfile in unzGoToNextFile\\n\",err);\n                break;\n            }\n        }\n    }\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              230,
              0
            ],
            [
              303,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "do_list",
            "parameters": {
              "uf": "unzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int do_extract_currentfile(unzFile uf, const int* popt_extract_without_path, int* popt_overwrite, const char* password) {\n    char filename_inzip[65536+1];\n    char* filename_withoutpath;\n    char* p;\n    int err=UNZ_OK;\n    FILE *fout=NULL;\n    void* buf;\n    uInt size_buf;\n\n    unz_file_info64 file_info;\n    err = unzGetCurrentFileInfo64(uf,&file_info,filename_inzip,sizeof(filename_inzip),NULL,0,NULL,0);\n\n    if (err!=UNZ_OK)\n    {\n        printf(\"error %d with zipfile in unzGetCurrentFileInfo\\n\",err);\n        return err;\n    }\n\n    size_buf = WRITEBUFFERSIZE;\n    buf = (void*)malloc(size_buf);\n    if (buf==NULL)\n    {\n        printf(\"Error allocating memory\\n\");\n        return UNZ_INTERNALERROR;\n    }\n\n    p = filename_withoutpath = filename_inzip;\n    while ((*p) != '\\0')\n    {\n        if (((*p)=='/') || ((*p)=='\\\\'))\n            filename_withoutpath = p+1;\n        p++;\n    }\n\n    if ((*filename_withoutpath)=='\\0')\n    {\n        if ((*popt_extract_without_path)==0)\n        {\n            printf(\"creating directory: %s\\n\",filename_inzip);\n            mymkdir(filename_inzip);\n        }\n    }\n    else\n    {\n        const char* write_filename;\n        int skip=0;\n\n        if ((*popt_extract_without_path)==0)\n            write_filename = filename_inzip;\n        else\n            write_filename = filename_withoutpath;\n\n        if (write_filename[0]!='\\0')\n        {\n            const char* relative_check = write_filename;\n            while (relative_check[1]!='\\0')\n            {\n                if (relative_check[0]=='.' && relative_check[1]=='.')\n                    write_filename = relative_check;\n                relative_check++;\n            }\n        }\n\n        while (write_filename[0]=='/' || write_filename[0]=='.')\n            write_filename++;\n\n        err = unzOpenCurrentFilePassword(uf,password);\n        if (err!=UNZ_OK)\n        {\n            printf(\"error %d with zipfile in unzOpenCurrentFilePassword\\n\",err);\n        }\n\n        if (((*popt_overwrite)==0) && (err==UNZ_OK))\n        {\n            char rep=0;\n            FILE* ftestexist;\n            ftestexist = FOPEN_FUNC(write_filename,\"rb\");\n            if (ftestexist!=NULL)\n            {\n                fclose(ftestexist);\n                do\n                {\n                    char answer[128];\n                    int ret;\n\n                    printf(\"The file %s exists. Overwrite ? [y]es, [n]o, [A]ll: \",write_filename);\n                    ret = scanf(\"%1s\",answer);\n                    if (ret != 1)\n                    {\n                       exit(EXIT_FAILURE);\n                    }\n                    rep = answer[0] ;\n                    if ((rep>='a') && (rep<='z'))\n                        rep -= 0x20;\n                }\n                while ((rep!='Y') && (rep!='N') && (rep!='A'));\n            }\n\n            if (rep == 'N')\n                skip = 1;\n\n            if (rep == 'A')\n                *popt_overwrite=1;\n        }\n\n        if ((skip==0) && (err==UNZ_OK))\n        {\n            fout=FOPEN_FUNC(write_filename,\"wb\");\n            /* some zipfile don't contain directory alone before file */\n            if ((fout==NULL) && ((*popt_extract_without_path)==0) &&\n                                (filename_withoutpath!=(char*)filename_inzip))\n            {\n                char c=*(filename_withoutpath-1);\n                *(filename_withoutpath-1)='\\0';\n                makedir(write_filename);\n                *(filename_withoutpath-1)=c;\n                fout=FOPEN_FUNC(write_filename,\"wb\");\n            }\n\n            if (fout==NULL)\n            {\n                printf(\"error opening %s\\n\",write_filename);\n            }\n        }\n\n        if (fout!=NULL)\n        {\n            printf(\" extracting: %s\\n\",write_filename);\n\n            do\n            {\n                err = unzReadCurrentFile(uf,buf,size_buf);\n                if (err<0)\n                {\n                    printf(\"error %d with zipfile in unzReadCurrentFile\\n\",err);\n                    break;\n                }\n                if (err>0)\n                    if (fwrite(buf,(unsigned)err,1,fout)!=1)\n                    {\n                        printf(\"error in writing extracted file\\n\");\n                        err=UNZ_ERRNO;\n                        break;\n                    }\n            }\n            while (err>0);\n            if (fout)\n                    fclose(fout);\n\n            if (err==0)\n                change_file_date(write_filename,file_info.dosDate,\n                                 file_info.tmu_date);\n        }\n\n        if (err==UNZ_OK)\n        {\n            err = unzCloseCurrentFile (uf);\n            if (err!=UNZ_OK)\n            {\n                printf(\"error %d with zipfile in unzCloseCurrentFile\\n\",err);\n            }\n        }\n        else\n            unzCloseCurrentFile(uf); /* don't lose the error */\n    }\n\n    free(buf);\n    return err;\n}",
          "fn_code_pos": [
            [
              306,
              0
            ],
            [
              474,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "do_extract_currentfile",
            "parameters": {
              "uf": "unzFile",
              "popt_extract_without_path": "int",
              "popt_overwrite": "int",
              "password": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int do_extract(unzFile uf, int opt_extract_without_path, int opt_overwrite, const char* password) {\n    uLong i;\n    unz_global_info64 gi;\n    int err;\n\n    err = unzGetGlobalInfo64(uf,&gi);\n    if (err!=UNZ_OK)\n        printf(\"error %d with zipfile in unzGetGlobalInfo \\n\",err);\n\n    for (i=0;i<gi.number_entry;i++)\n    {\n        if (do_extract_currentfile(uf,&opt_extract_without_path,\n                                      &opt_overwrite,\n                                      password) != UNZ_OK)\n            break;\n\n        if ((i+1)<gi.number_entry)\n        {\n            err = unzGoToNextFile(uf);\n            if (err!=UNZ_OK)\n            {\n                printf(\"error %d with zipfile in unzGoToNextFile\\n\",err);\n                break;\n            }\n        }\n    }\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              477,
              0
            ],
            [
              505,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "do_extract",
            "parameters": {
              "uf": "unzFile",
              "opt_extract_without_path": "int",
              "opt_overwrite": "int",
              "password": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int do_extract_onefile(unzFile uf, const char* filename, int opt_extract_without_path, int opt_overwrite, const char* password) {\n    if (unzLocateFile(uf,filename,CASESENSITIVITY)!=UNZ_OK)\n    {\n        printf(\"file %s not found in the zipfile\\n\",filename);\n        return 2;\n    }\n\n    if (do_extract_currentfile(uf,&opt_extract_without_path,\n                                      &opt_overwrite,\n                                      password) == UNZ_OK)\n        return 0;\n    else\n        return 1;\n}",
          "fn_code_pos": [
            [
              507,
              0
            ],
            [
              520,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "do_extract_onefile",
            "parameters": {
              "uf": "unzFile",
              "filename": "char",
              "opt_extract_without_path": "int",
              "opt_overwrite": "int",
              "password": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[]) {\n    const char *zipfilename=NULL;\n    const char *filename_to_extract=NULL;\n    const char *password=NULL;\n    char filename_try[MAXFILENAME+16] = \"\";\n    int i;\n    int ret_value=0;\n    int opt_do_list=0;\n    int opt_do_extract=1;\n    int opt_do_extract_withoutpath=0;\n    int opt_overwrite=0;\n    int opt_extractdir=0;\n    const char *dirname=NULL;\n    unzFile uf=NULL;\n\n    do_banner();\n    if (argc==1)\n    {\n        do_help();\n        return 0;\n    }\n    else\n    {\n        for (i=1;i<argc;i++)\n        {\n            if ((*argv[i])=='-')\n            {\n                const char *p=argv[i]+1;\n\n                while ((*p)!='\\0')\n                {\n                    char c=*(p++);\n                    if ((c=='l') || (c=='L'))\n                        opt_do_list = 1;\n                    if ((c=='v') || (c=='V'))\n                        opt_do_list = 1;\n                    if ((c=='x') || (c=='X'))\n                        opt_do_extract = 1;\n                    if ((c=='e') || (c=='E'))\n                        opt_do_extract = opt_do_extract_withoutpath = 1;\n                    if ((c=='o') || (c=='O'))\n                        opt_overwrite=1;\n                    if ((c=='d') || (c=='D'))\n                    {\n                        opt_extractdir=1;\n                        dirname=argv[i+1];\n                    }\n\n                    if (((c=='p') || (c=='P')) && (i+1<argc))\n                    {\n                        password=argv[i+1];\n                        i++;\n                    }\n                }\n            }\n            else\n            {\n                if (zipfilename == NULL)\n                    zipfilename = argv[i];\n                else if ((filename_to_extract==NULL) && (!opt_extractdir))\n                        filename_to_extract = argv[i] ;\n            }\n        }\n    }\n\n    if (zipfilename!=NULL)\n    {\n\n#        ifdef USEWIN32IOAPI\n        zlib_filefunc64_def ffunc;\n#        endif\n\n        strncpy(filename_try, zipfilename,MAXFILENAME-1);\n        /* strncpy doesn't append the trailing NULL, of the string is too long. */\n        filename_try[ MAXFILENAME ] = '\\0';\n\n#        ifdef USEWIN32IOAPI\n        fill_win32_filefunc64A(&ffunc);\n        uf = unzOpen2_64(zipfilename,&ffunc);\n#        else\n        uf = unzOpen64(zipfilename);\n#        endif\n        if (uf==NULL)\n        {\n            strcat(filename_try,\".zip\");\n#            ifdef USEWIN32IOAPI\n            uf = unzOpen2_64(filename_try,&ffunc);\n#            else\n            uf = unzOpen64(filename_try);\n#            endif\n        }\n    }\n\n    if (uf==NULL)\n    {\n        printf(\"Cannot open %s or %s.zip\\n\",zipfilename,zipfilename);\n        return 1;\n    }\n    printf(\"%s opened\\n\",filename_try);\n\n    if (opt_do_list==1)\n        ret_value = do_list(uf);\n    else if (opt_do_extract==1)\n    {\n#ifdef _WIN32\n        if (opt_extractdir && _chdir(dirname))\n#else\n        if (opt_extractdir && chdir(dirname))\n#endif\n        {\n          printf(\"Error changing into %s, aborting\\n\", dirname);\n          exit(-1);\n        }\n\n        if (filename_to_extract == NULL)\n            ret_value = do_extract(uf, opt_do_extract_withoutpath, opt_overwrite, password);\n        else\n            ret_value = do_extract_onefile(uf, filename_to_extract, opt_do_extract_withoutpath, opt_overwrite, password);\n    }\n\n    unzClose(uf);\n\n    return ret_value;\n}",
          "fn_code_pos": [
            [
              523,
              0
            ],
            [
              646,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct utimbuf",
          {},
          "",
          [
            101,
            2
          ],
          [
            101,
            16
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            102,
            2
          ],
          [
            102,
            11
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <time.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <sys/stat.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "# include <direct.h>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "# include <io.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "# include <utime.h>\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#include \"unzip.h\"\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ],
        [
          "#include \"iowin32.h\"\n",
          [
            69,
            0
          ],
          [
            70,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/minizip/mztools.c": {
      "fn_def_list": [
        {
          "fn_code": "extern int ZEXPORT unzRepair(const char* file, const char* fileOut, const char* fileOutTmp, uLong* nRecovered, uLong* bytesRecovered) {\n  int err = Z_OK;\n  FILE* fpZip = fopen(file, \"rb\");\n  FILE* fpOut = fopen(fileOut, \"wb\");\n  FILE* fpOutCD = fopen(fileOutTmp, \"wb\");\n  if (fpZip != NULL &&  fpOut != NULL) {\n    int entries = 0;\n    uLong totalBytes = 0;\n    char header[30];\n    char filename[1024];\n    char extra[1024];\n    int offset = 0;\n    int offsetCD = 0;\n    while ( fread(header, 1, 30, fpZip) == 30 ) {\n      int currentOffset = offset;\n\n      /* File entry */\n      if (READ_32(header) == 0x04034b50) {\n        unsigned int version = READ_16(header + 4);\n        unsigned int gpflag = READ_16(header + 6);\n        unsigned int method = READ_16(header + 8);\n        unsigned int filetime = READ_16(header + 10);\n        unsigned int filedate = READ_16(header + 12);\n        unsigned int crc = READ_32(header + 14); /* crc */\n        unsigned int cpsize = READ_32(header + 18); /* compressed size */\n        unsigned int uncpsize = READ_32(header + 22); /* uncompressed sz */\n        unsigned int fnsize = READ_16(header + 26); /* file name length */\n        unsigned int extsize = READ_16(header + 28); /* extra field length */\n        filename[0] = extra[0] = '\\0';\n\n        /* Header */\n        if (fwrite(header, 1, 30, fpOut) == 30) {\n          offset += 30;\n        } else {\n          err = Z_ERRNO;\n          break;\n        }\n\n        /* Filename */\n        if (fnsize > 0) {\n          if (fnsize < sizeof(filename)) {\n            if (fread(filename, 1, fnsize, fpZip) == fnsize) {\n                if (fwrite(filename, 1, fnsize, fpOut) == fnsize) {\n                offset += fnsize;\n              } else {\n                err = Z_ERRNO;\n                break;\n              }\n            } else {\n              err = Z_ERRNO;\n              break;\n            }\n          } else {\n            err = Z_ERRNO;\n            break;\n          }\n        } else {\n          err = Z_STREAM_ERROR;\n          break;\n        }\n\n        /* Extra field */\n        if (extsize > 0) {\n          if (extsize < sizeof(extra)) {\n            if (fread(extra, 1, extsize, fpZip) == extsize) {\n              if (fwrite(extra, 1, extsize, fpOut) == extsize) {\n                offset += extsize;\n                } else {\n                err = Z_ERRNO;\n                break;\n              }\n            } else {\n              err = Z_ERRNO;\n              break;\n            }\n          } else {\n            err = Z_ERRNO;\n            break;\n          }\n        }\n\n        /* Data */\n        {\n          int dataSize = cpsize;\n          if (dataSize == 0) {\n            dataSize = uncpsize;\n          }\n          if (dataSize > 0) {\n            char* data = malloc(dataSize);\n            if (data != NULL) {\n              if ((int)fread(data, 1, dataSize, fpZip) == dataSize) {\n                if ((int)fwrite(data, 1, dataSize, fpOut) == dataSize) {\n                  offset += dataSize;\n                  totalBytes += dataSize;\n                } else {\n                  err = Z_ERRNO;\n                }\n              } else {\n                err = Z_ERRNO;\n              }\n              free(data);\n              if (err != Z_OK) {\n                break;\n              }\n            } else {\n              err = Z_MEM_ERROR;\n              break;\n            }\n          }\n        }\n\n        /* Central directory entry */\n        {\n          char central[46];\n          char* comment = \"\";\n          int comsize = (int) strlen(comment);\n          WRITE_32(central, 0x02014b50);\n          WRITE_16(central + 4, version);\n          WRITE_16(central + 6, version);\n          WRITE_16(central + 8, gpflag);\n          WRITE_16(central + 10, method);\n          WRITE_16(central + 12, filetime);\n          WRITE_16(central + 14, filedate);\n          WRITE_32(central + 16, crc);\n          WRITE_32(central + 20, cpsize);\n          WRITE_32(central + 24, uncpsize);\n          WRITE_16(central + 28, fnsize);\n          WRITE_16(central + 30, extsize);\n          WRITE_16(central + 32, comsize);\n          WRITE_16(central + 34, 0);    /* disk # */\n          WRITE_16(central + 36, 0);    /* int attrb */\n          WRITE_32(central + 38, 0);    /* ext attrb */\n          WRITE_32(central + 42, currentOffset);\n          /* Header */\n          if (fwrite(central, 1, 46, fpOutCD) == 46) {\n            offsetCD += 46;\n\n            /* Filename */\n            if (fnsize > 0) {\n              if (fwrite(filename, 1, fnsize, fpOutCD) == fnsize) {\n                offsetCD += fnsize;\n              } else {\n                err = Z_ERRNO;\n                break;\n              }\n            } else {\n              err = Z_STREAM_ERROR;\n              break;\n            }\n\n            /* Extra field */\n            if (extsize > 0) {\n              if (fwrite(extra, 1, extsize, fpOutCD) == extsize) {\n                offsetCD += extsize;\n              } else {\n                err = Z_ERRNO;\n                break;\n              }\n            }\n\n            /* Comment field */\n            if (comsize > 0) {\n              if ((int)fwrite(comment, 1, comsize, fpOutCD) == comsize) {\n                offsetCD += comsize;\n              } else {\n                err = Z_ERRNO;\n                break;\n              }\n            }\n\n\n          } else {\n            err = Z_ERRNO;\n            break;\n          }\n        }\n\n        /* Success */\n        entries++;\n\n      } else {\n        break;\n      }\n    }\n\n    /* Final central directory  */\n    {\n      int entriesZip = entries;\n      char end[22];\n      char* comment = \"\"; // \"ZIP File recovered by zlib/minizip/mztools\";\n      int comsize = (int) strlen(comment);\n      if (entriesZip > 0xffff) {\n        entriesZip = 0xffff;\n      }\n      WRITE_32(end, 0x06054b50);\n      WRITE_16(end + 4, 0);         /* disk # */\n      WRITE_16(end + 6, 0);         /* disk # */\n      WRITE_16(end + 8, entriesZip);        /* hack */\n      WRITE_16(end + 10, entriesZip);       /* hack */\n      WRITE_32(end + 12, offsetCD);         /* size of CD */\n      WRITE_32(end + 16, offset);           /* offset to CD */\n      WRITE_16(end + 20, comsize);          /* comment */\n\n      /* Header */\n      if (fwrite(end, 1, 22, fpOutCD) == 22) {\n\n        /* Comment field */\n        if (comsize > 0) {\n          if ((int)fwrite(comment, 1, comsize, fpOutCD) != comsize) {\n            err = Z_ERRNO;\n          }\n        }\n\n      } else {\n        err = Z_ERRNO;\n      }\n    }\n\n    /* Final merge (file + central directory) */\n    fclose(fpOutCD);\n    if (err == Z_OK) {\n      fpOutCD = fopen(fileOutTmp, \"rb\");\n      if (fpOutCD != NULL) {\n        int nRead;\n        char buffer[8192];\n        while ( (nRead = (int)fread(buffer, 1, sizeof(buffer), fpOutCD)) > 0) {\n          if ((int)fwrite(buffer, 1, nRead, fpOut) != nRead) {\n            err = Z_ERRNO;\n            break;\n          }\n        }\n        fclose(fpOutCD);\n      }\n    }\n\n    /* Close */\n    fclose(fpZip);\n    fclose(fpOut);\n\n    /* Wipe temporary file */\n    (void)remove(fileOutTmp);\n\n    /* Number of recovered entries */\n    if (err == Z_OK) {\n      if (nRecovered != NULL) {\n        *nRecovered = entries;\n      }\n      if (bytesRecovered != NULL) {\n        *bytesRecovered = totalBytes;\n      }\n    }\n  } else {\n    err = Z_STREAM_ERROR;\n  }\n  return err;\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzRepair",
            "parameters": {
              "file": "char",
              "fileOut": "char",
              "fileOutTmp": "char",
              "nRecovered": "uLong",
              "bytesRecovered": "uLong"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"unzip.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/puff/pufftest.c": {
      "fn_def_list": [
        {
          "fn_code": "local size_t bythirds(size_t size)\n{\n    int n;\n    size_t m;\n\n    m = size;\n    for (n = 0; m; n++)\n        m >>= 1;\n    if (n < 3)\n        return size + 1;\n    n -= 3;\n    m = size >> n;\n    m += m == 6 ? 2 : 1;\n    m <<= n;\n    return m > size ? m : (size_t)(-1);\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bythirds",
            "parameters": {
              "size": "size_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void *load(const char *name, size_t *len)\n{\n    size_t size;\n    void *buf, *swap;\n    FILE *in;\n\n    *len = 0;\n    buf = malloc(size = 4096);\n    if (buf == NULL)\n        return NULL;\n    in = name == NULL ? stdin : fopen(name, \"rb\");\n    if (in != NULL) {\n        for (;;) {\n            *len += fread((char *)buf + *len, 1, size - *len, in);\n            if (*len < size) break;\n            size = bythirds(size);\n            if (size == *len || (swap = realloc(buf, size)) == NULL) {\n                free(buf);\n                buf = NULL;\n                break;\n            }\n            buf = swap;\n        }\n        fclose(in);\n    }\n    return buf;\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              89,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "load",
            "parameters": {
              "name": "char",
              "len": "size_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int main(int argc, char **argv)\n{\n    int ret, put = 0, fail = 0;\n    unsigned skip = 0;\n    char *arg, *name = NULL;\n    unsigned char *source = NULL, *dest;\n    size_t len = 0;\n    unsigned long sourcelen, destlen;\n\n    /* process arguments */\n    while (arg = *++argv, --argc)\n        if (arg[0] == '-') {\n            if (arg[1] == 'w' && arg[2] == 0)\n                put = 1;\n            else if (arg[1] == 'f' && arg[2] == 0)\n                fail = 1, put = 1;\n            else if (arg[1] >= '0' && arg[1] <= '9')\n                skip = (unsigned)atoi(arg + 1);\n            else {\n                fprintf(stderr, \"invalid option %s\\n\", arg);\n                return 3;\n            }\n        }\n        else if (name != NULL) {\n            fprintf(stderr, \"only one file name allowed\\n\");\n            return 3;\n        }\n        else\n            name = arg;\n    source = load(name, &len);\n    if (source == NULL) {\n        fprintf(stderr, \"memory allocation failure\\n\");\n        return 4;\n    }\n    if (len == 0) {\n        fprintf(stderr, \"could not read %s, or it was empty\\n\",\n                name == NULL ? \"<stdin>\" : name);\n        free(source);\n        return 3;\n    }\n    if (skip >= len) {\n        fprintf(stderr, \"skip request of %d leaves no input\\n\", skip);\n        free(source);\n        return 3;\n    }\n\n    /* test inflate data with offset skip */\n    len -= skip;\n    sourcelen = (unsigned long)len;\n    ret = puff(NIL, &destlen, source + skip, &sourcelen);\n    if (ret)\n        fprintf(stderr, \"puff() failed with return code %d\\n\", ret);\n    else {\n        fprintf(stderr, \"puff() succeeded uncompressing %lu bytes\\n\", destlen);\n        if (sourcelen < len) fprintf(stderr, \"%lu compressed bytes unused\\n\",\n                                     len - sourcelen);\n    }\n\n    /* if requested, inflate again and write decompressed data to stdout */\n    if (put && ret == 0) {\n        if (fail)\n            destlen >>= 1;\n        dest = malloc(destlen);\n        if (dest == NULL) {\n            fprintf(stderr, \"memory allocation failure\\n\");\n            free(source);\n            return 4;\n        }\n        puff(dest, &destlen, source + skip, &sourcelen);\n        SET_BINARY_MODE(stdout);\n        fwrite(dest, 1, destlen, stdout);\n        free(dest);\n    }\n\n    /* clean up */\n    free(source);\n    return ret;\n}",
          "fn_code_pos": [
            [
              91,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "load(const char *name, size_t *len)",
          "fn_dec_pos": [
            [
              63,
              12
            ],
            [
              63,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "load",
            "parameters": {
              "name": "char",
              "len": "size_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"puff.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#  include <fcntl.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <io.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/puff/puff.c": {
      "fn_def_list": [
        {
          "fn_code": "local int bits(struct state *s, int need)\n{\n    long val;           /* bit accumulator (can use up to 20 bits) */\n\n    /* load at least need bits into val */\n    val = s->bitbuf;\n    while (s->bitcnt < need) {\n        if (s->incnt == s->inlen)\n            longjmp(s->env, 1);         /* out of input */\n        val |= (long)(s->in[s->incnt++]) << s->bitcnt;  /* load eight bits */\n        s->bitcnt += 8;\n    }\n\n    /* drop need bits and update buffer, always zero to seven bits left */\n    s->bitbuf = (int)(val >> need);\n    s->bitcnt -= need;\n\n    /* return need bits, zeroing the bits above that */\n    return (int)(val & ((1L << need) - 1));\n}",
          "fn_code_pos": [
            [
              125,
              0
            ],
            [
              144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bits",
            "parameters": {
              "s": "struct state",
              "need": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int stored(struct state *s)\n{\n    unsigned len;       /* length of stored block */\n\n    /* discard leftover bits from current byte (assumes s->bitcnt < 8) */\n    s->bitbuf = 0;\n    s->bitcnt = 0;\n\n    /* get length and check against its one's complement */\n    if (s->incnt + 4 > s->inlen)\n        return 2;                               /* not enough input */\n    len = s->in[s->incnt++];\n    len |= s->in[s->incnt++] << 8;\n    if (s->in[s->incnt++] != (~len & 0xff) ||\n        s->in[s->incnt++] != ((~len >> 8) & 0xff))\n        return -2;                              /* didn't match complement! */\n\n    /* copy len bytes from in to out */\n    if (s->incnt + len > s->inlen)\n        return 2;                               /* not enough input */\n    if (s->out != NIL) {\n        if (s->outcnt + len > s->outlen)\n            return 1;                           /* not enough output space */\n        while (len--)\n            s->out[s->outcnt++] = s->in[s->incnt++];\n    }\n    else {                                      /* just scanning */\n        s->outcnt += len;\n        s->incnt += len;\n    }\n\n    /* done with a valid stored block */\n    return 0;\n}",
          "fn_code_pos": [
            [
              163,
              0
            ],
            [
              196,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "stored",
            "parameters": {
              "s": "struct state"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int decode(struct state *s, const struct huffman *h)\n{\n    int len;            /* current number of bits in code */\n    int code;           /* len bits being decoded */\n    int first;          /* first code of length len */\n    int count;          /* number of codes of length len */\n    int index;          /* index of first code of length len in symbol table */\n\n    code = first = index = 0;\n    for (len = 1; len <= MAXBITS; len++) {\n        code |= bits(s, 1);             /* get next bit */\n        count = h->count[len];\n        if (code - count < first)       /* if length len, return symbol */\n            return h->symbol[index + (code - first)];\n        index += count;                 /* else update for next length */\n        first += count;\n        first <<= 1;\n        code <<= 1;\n    }\n    return -10;                         /* ran out of codes */\n}",
          "fn_code_pos": [
            [
              234,
              0
            ],
            [
              254,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "decode",
            "parameters": {
              "s": "struct state",
              "h": "struct huffman"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int decode(struct state *s, const struct huffman *h)\n{\n    int len;            /* current number of bits in code */\n    int code;           /* len bits being decoded */\n    int first;          /* first code of length len */\n    int count;          /* number of codes of length len */\n    int index;          /* index of first code of length len in symbol table */\n    int bitbuf;         /* bits from stream */\n    int left;           /* bits left in next or left to process */\n    short *next;        /* next number of codes */\n\n    bitbuf = s->bitbuf;\n    left = s->bitcnt;\n    code = first = index = 0;\n    len = 1;\n    next = h->count + 1;\n    while (1) {\n        while (left--) {\n            code |= bitbuf & 1;\n            bitbuf >>= 1;\n            count = *next++;\n            if (code - count < first) { /* if length len, return symbol */\n                s->bitbuf = bitbuf;\n                s->bitcnt = (s->bitcnt - len) & 7;\n                return h->symbol[index + (code - first)];\n            }\n            index += count;             /* else update for next length */\n            first += count;\n            first <<= 1;\n            code <<= 1;\n            len++;\n        }\n        left = (MAXBITS+1) - len;\n        if (left == 0)\n            break;\n        if (s->incnt == s->inlen)\n            longjmp(s->env, 1);         /* out of input */\n        bitbuf = s->in[s->incnt++];\n        if (left > 8)\n            left = 8;\n    }\n    return -10;                         /* ran out of codes */\n}",
          "fn_code_pos": [
            [
              262,
              0
            ],
            [
              304,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "decode",
            "parameters": {
              "s": "struct state",
              "h": "struct huffman"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int construct(struct huffman *h, const short *length, int n)\n{\n    int symbol;         /* current symbol when stepping through length[] */\n    int len;            /* current length when stepping through h->count[] */\n    int left;           /* number of possible codes left of current length */\n    short offs[MAXBITS+1];      /* offsets in symbol table for each length */\n\n    /* count number of codes of each length */\n    for (len = 0; len <= MAXBITS; len++)\n        h->count[len] = 0;\n    for (symbol = 0; symbol < n; symbol++)\n        (h->count[length[symbol]])++;   /* assumes lengths are within bounds */\n    if (h->count[0] == n)               /* no codes! */\n        return 0;                       /* complete, but decode() will fail */\n\n    /* check for an over-subscribed or incomplete set of lengths */\n    left = 1;                           /* one possible code of zero length */\n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;                     /* one more bit, double codes left */\n        left -= h->count[len];          /* deduct count from possible codes */\n        if (left < 0)\n            return left;                /* over-subscribed--return negative */\n    }                                   /* left > 0 means incomplete */\n\n    /* generate offsets into symbol table for each length for sorting */\n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + h->count[len];\n\n    /*\n     * put symbols in table sorted by length, by symbol order within each\n     * length\n     */\n    for (symbol = 0; symbol < n; symbol++)\n        if (length[symbol] != 0)\n            h->symbol[offs[length[symbol]]++] = symbol;\n\n    /* return zero for complete set, positive for incomplete set */\n    return left;\n}",
          "fn_code_pos": [
            [
              339,
              0
            ],
            [
              378,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "construct",
            "parameters": {
              "h": "struct huffman",
              "length": "short",
              "n": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int codes(struct state *s,\n                const struct huffman *lencode,\n                const struct huffman *distcode)\n{\n    int symbol;         /* decoded symbol */\n    int len;            /* length for copy */\n    unsigned dist;      /* distance for copy */\n    static const short lens[29] = { /* Size base for length codes 257..285 */\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};\n    static const short lext[29] = { /* Extra bits for length codes 257..285 */\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n    static const short dists[30] = { /* Offset base for distance codes 0..29 */\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577};\n    static const short dext[30] = { /* Extra bits for distance codes 0..29 */\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13};\n\n    /* decode literals and length/distance pairs */\n    do {\n        symbol = decode(s, lencode);\n        if (symbol < 0)\n            return symbol;              /* invalid symbol */\n        if (symbol < 256) {             /* literal: symbol is the byte */\n            /* write out the literal */\n            if (s->out != NIL) {\n                if (s->outcnt == s->outlen)\n                    return 1;\n                s->out[s->outcnt] = symbol;\n            }\n            s->outcnt++;\n        }\n        else if (symbol > 256) {        /* length */\n            /* get and compute length */\n            symbol -= 257;\n            if (symbol >= 29)\n                return -10;             /* invalid fixed code */\n            len = lens[symbol] + bits(s, lext[symbol]);\n\n            /* get and check distance */\n            symbol = decode(s, distcode);\n            if (symbol < 0)\n                return symbol;          /* invalid symbol */\n            dist = dists[symbol] + bits(s, dext[symbol]);\n#ifndef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n            if (dist > s->outcnt)\n                return -11;     /* distance too far back */\n#endif\n\n            /* copy length bytes from distance bytes back */\n            if (s->out != NIL) {\n                if (s->outcnt + len > s->outlen)\n                    return 1;\n                while (len--) {\n                    s->out[s->outcnt] =\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                        dist > s->outcnt ?\n                            0 :\n#endif\n                            s->out[s->outcnt - dist];\n                    s->outcnt++;\n                }\n            }\n            else\n                s->outcnt += len;\n        }\n    } while (symbol != 256);            /* end of block symbol */\n\n    /* done with a valid fixed or dynamic block */\n    return 0;\n}",
          "fn_code_pos": [
            [
              435,
              0
            ],
            [
              509,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "codes",
            "parameters": {
              "s": "struct state",
              "lencode": "struct huffman",
              "distcode": "struct huffman"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int fixed(struct state *s)\n{\n    static int virgin = 1;\n    static short lencnt[MAXBITS+1], lensym[FIXLCODES];\n    static short distcnt[MAXBITS+1], distsym[MAXDCODES];\n    static struct huffman lencode, distcode;\n\n    /* build fixed huffman tables if first call (may not be thread safe) */\n    if (virgin) {\n        int symbol;\n        short lengths[FIXLCODES];\n\n        /* construct lencode and distcode */\n        lencode.count = lencnt;\n        lencode.symbol = lensym;\n        distcode.count = distcnt;\n        distcode.symbol = distsym;\n\n        /* literal/length table */\n        for (symbol = 0; symbol < 144; symbol++)\n            lengths[symbol] = 8;\n        for (; symbol < 256; symbol++)\n            lengths[symbol] = 9;\n        for (; symbol < 280; symbol++)\n            lengths[symbol] = 7;\n        for (; symbol < FIXLCODES; symbol++)\n            lengths[symbol] = 8;\n        construct(&lencode, lengths, FIXLCODES);\n\n        /* distance table */\n        for (symbol = 0; symbol < MAXDCODES; symbol++)\n            lengths[symbol] = 5;\n        construct(&distcode, lengths, MAXDCODES);\n\n        /* do this just once */\n        virgin = 0;\n    }\n\n    /* decode data until end-of-block code */\n    return codes(s, &lencode, &distcode);\n}",
          "fn_code_pos": [
            [
              535,
              0
            ],
            [
              575,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fixed",
            "parameters": {
              "s": "struct state"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int dynamic(struct state *s)\n{\n    int nlen, ndist, ncode;             /* number of lengths in descriptor */\n    int index;                          /* index of lengths[] */\n    int err;                            /* construct() return value */\n    short lengths[MAXCODES];            /* descriptor code lengths */\n    short lencnt[MAXBITS+1], lensym[MAXLCODES];         /* lencode memory */\n    short distcnt[MAXBITS+1], distsym[MAXDCODES];       /* distcode memory */\n    struct huffman lencode, distcode;   /* length and distance codes */\n    static const short order[19] =      /* permutation of code length codes */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\n    /* construct lencode and distcode */\n    lencode.count = lencnt;\n    lencode.symbol = lensym;\n    distcode.count = distcnt;\n    distcode.symbol = distsym;\n\n    /* get number of lengths in each table, check lengths */\n    nlen = bits(s, 5) + 257;\n    ndist = bits(s, 5) + 1;\n    ncode = bits(s, 4) + 4;\n    if (nlen > MAXLCODES || ndist > MAXDCODES)\n        return -3;                      /* bad counts */\n\n    /* read code length code lengths (really), missing lengths are zero */\n    for (index = 0; index < ncode; index++)\n        lengths[order[index]] = bits(s, 3);\n    for (; index < 19; index++)\n        lengths[order[index]] = 0;\n\n    /* build huffman table for code lengths codes (use lencode temporarily) */\n    err = construct(&lencode, lengths, 19);\n    if (err != 0)               /* require complete code set here */\n        return -4;\n\n    /* read length/literal and distance code length tables */\n    index = 0;\n    while (index < nlen + ndist) {\n        int symbol;             /* decoded value */\n        int len;                /* last length to repeat */\n\n        symbol = decode(s, &lencode);\n        if (symbol < 0)\n            return symbol;          /* invalid symbol */\n        if (symbol < 16)                /* length in 0..15 */\n            lengths[index++] = symbol;\n        else {                          /* repeat instruction */\n            len = 0;                    /* assume repeating zeros */\n            if (symbol == 16) {         /* repeat last length 3..6 times */\n                if (index == 0)\n                    return -5;          /* no last length! */\n                len = lengths[index - 1];       /* last length */\n                symbol = 3 + bits(s, 2);\n            }\n            else if (symbol == 17)      /* repeat zero 3..10 times */\n                symbol = 3 + bits(s, 3);\n            else                        /* == 18, repeat zero 11..138 times */\n                symbol = 11 + bits(s, 7);\n            if (index + symbol > nlen + ndist)\n                return -6;              /* too many lengths! */\n            while (symbol--)            /* repeat last or zero symbol times */\n                lengths[index++] = len;\n        }\n    }\n\n    /* check for end-of-block code -- there better be one! */\n    if (lengths[256] == 0)\n        return -9;\n\n    /* build huffman table for literal/length codes */\n    err = construct(&lencode, lengths, nlen);\n    if (err && (err < 0 || nlen != lencode.count[0] + lencode.count[1]))\n        return -7;      /* incomplete code ok only for single length 1 code */\n\n    /* build huffman table for distance codes */\n    err = construct(&distcode, lengths + nlen, ndist);\n    if (err && (err < 0 || ndist != distcode.count[0] + distcode.count[1]))\n        return -8;      /* incomplete code ok only for single length 1 code */\n\n    /* decode data until end-of-block code */\n    return codes(s, &lencode, &distcode);\n}",
          "fn_code_pos": [
            [
              664,
              0
            ],
            [
              746,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dynamic",
            "parameters": {
              "s": "struct state"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int puff(unsigned char *dest,           /* pointer to destination pointer */\n         unsigned long *destlen,        /* amount of output space */\n         const unsigned char *source,   /* pointer to source data pointer */\n         unsigned long *sourcelen)      /* amount of input available */\n{\n    struct state s;             /* input/output state */\n    int last, type;             /* block information */\n    int err;                    /* return value */\n\n    /* initialize output state */\n    s.out = dest;\n    s.outlen = *destlen;                /* ignored if dest is NIL */\n    s.outcnt = 0;\n\n    /* initialize input state */\n    s.in = source;\n    s.inlen = *sourcelen;\n    s.incnt = 0;\n    s.bitbuf = 0;\n    s.bitcnt = 0;\n\n    /* return if bits() or decode() tries to read past available input */\n    if (setjmp(s.env) != 0)             /* if came back here via longjmp() */\n        err = 2;                        /* then skip do-loop, return error */\n    else {\n        /* process blocks until last block or error */\n        do {\n            last = bits(&s, 1);         /* one if last block */\n            type = bits(&s, 2);         /* block type 0..3 */\n            err = type == 0 ?\n                    stored(&s) :\n                    (type == 1 ?\n                        fixed(&s) :\n                        (type == 2 ?\n                            dynamic(&s) :\n                            -1));       /* type == 3, invalid */\n            if (err != 0)\n                break;                  /* return with error */\n        } while (!last);\n    }\n\n    /* update the lengths and return */\n    if (err <= 0) {\n        *destlen = s.outcnt;\n        *sourcelen = s.incnt;\n    }\n    return err;\n}",
          "fn_code_pos": [
            [
              792,
              0
            ],
            [
              839,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "puff",
            "parameters": {
              "dest": "unsigned char",
              "destlen": "unsigned long",
              "source": "unsigned char",
              "sourcelen": "unsigned long"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct state {\n    /* output state */\n    unsigned char *out;         /* output buffer */\n    unsigned long outlen;       /* available space at out */\n    unsigned long outcnt;       /* bytes written to out so far */\n\n    /* input state */\n    const unsigned char *in;    /* input buffer */\n    unsigned long inlen;        /* available input at in */\n    unsigned long incnt;        /* bytes read so far */\n    int bitbuf;                 /* bit buffer */\n    int bitcnt;                 /* number of bits in bit buffer */\n\n    /* input limit error return state for bits() and decode() */\n    jmp_buf env;\n}",
          {
            "*out": "unsigned char",
            "outlen": "unsigned long",
            "outcnt": "unsigned long",
            "unsigned char": "const",
            "inlen": "unsigned long",
            "incnt": "unsigned long",
            "bitbuf": "int",
            "bitcnt": "int",
            "env": "jmp_buf"
          },
          "state",
          [
            97,
            0
          ],
          [
            112,
            1
          ]
        ],
        [
          "struct huffman {\n    short *count;       /* number of symbols of each length */\n    short *symbol;      /* canonically ordered symbols */\n}",
          {
            "*count": "short",
            "*symbol": "short"
          },
          "huffman",
          [
            205,
            0
          ],
          [
            208,
            1
          ]
        ],
        [
          "struct state {\n    /* output state */\n    unsigned char *out;         /* output buffer */\n    unsigned long outlen;       /* available space at out */\n    unsigned long outcnt;       /* bytes written to out so far */\n\n    /* input state */\n    const unsigned char *in;    /* input buffer */\n    unsigned long inlen;        /* available input at in */\n    unsigned long incnt;        /* bytes read so far */\n    int bitbuf;                 /* bit buffer */\n    int bitcnt;                 /* number of bits in bit buffer */\n\n    /* input limit error return state for bits() and decode() */\n    jmp_buf env;\n}",
          {
            "*out": "unsigned char",
            "outlen": "unsigned long",
            "outcnt": "unsigned long",
            "unsigned char": "const",
            "inlen": "unsigned long",
            "incnt": "unsigned long",
            "bitbuf": "int",
            "bitcnt": "int",
            "env": "jmp_buf"
          },
          "state",
          [
            97,
            0
          ],
          [
            112,
            1
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            125,
            15
          ],
          [
            125,
            27
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            163,
            17
          ],
          [
            163,
            29
          ]
        ],
        [
          "struct huffman {\n    short *count;       /* number of symbols of each length */\n    short *symbol;      /* canonically ordered symbols */\n}",
          {
            "*count": "short",
            "*symbol": "short"
          },
          "huffman",
          [
            205,
            0
          ],
          [
            208,
            1
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            234,
            17
          ],
          [
            234,
            29
          ]
        ],
        [
          "struct huffman",
          {},
          "",
          [
            234,
            40
          ],
          [
            234,
            54
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            262,
            17
          ],
          [
            262,
            29
          ]
        ],
        [
          "struct huffman",
          {},
          "",
          [
            262,
            40
          ],
          [
            262,
            54
          ]
        ],
        [
          "struct huffman",
          {},
          "",
          [
            339,
            20
          ],
          [
            339,
            34
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            435,
            16
          ],
          [
            435,
            28
          ]
        ],
        [
          "struct huffman",
          {},
          "",
          [
            436,
            22
          ],
          [
            436,
            36
          ]
        ],
        [
          "struct huffman",
          {},
          "",
          [
            437,
            22
          ],
          [
            437,
            36
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            535,
            16
          ],
          [
            535,
            28
          ]
        ],
        [
          "struct huffman",
          {},
          "",
          [
            540,
            11
          ],
          [
            540,
            25
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            664,
            18
          ],
          [
            664,
            30
          ]
        ],
        [
          "struct huffman",
          {},
          "",
          [
            672,
            4
          ],
          [
            672,
            18
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            797,
            4
          ],
          [
            797,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include <setjmp.h>             /* for setjmp(), longjmp(), and jmp_buf */\n",
          [
            81,
            0
          ],
          [
            82,
            0
          ]
        ],
        [
          "#include \"puff.h\"               /* prototype for puff() */\n",
          [
            82,
            0
          ],
          [
            83,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/testzlib/testzlib.c": {
      "fn_def_list": [
        {
          "fn_code": "void MyDoMinus64(LARGE_INTEGER *R,LARGE_INTEGER A,LARGE_INTEGER B)\n{\n    R->HighPart = A.HighPart - B.HighPart;\n    if (A.LowPart >= B.LowPart)\n        R->LowPart = A.LowPart - B.LowPart;\n    else\n    {\n        R->LowPart = A.LowPart - B.LowPart;\n        R->HighPart --;\n    }\n}",
          "fn_code_pos": [
            [
              7,
              0
            ],
            [
              17,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyDoMinus64",
            "parameters": {
              "R": "LARGE_INTEGER",
              "A": "LARGE_INTEGER",
              "B": "LARGE_INTEGER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)\n{\n //   printf(\"rdtsc = %I64x\\n\",__rdtsc());\n   pbeginTime64->QuadPart=__rdtsc();\n}",
          "fn_code_pos": [
            [
              22,
              0
            ],
            [
              26,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BeginCountRdtsc",
            "parameters": {
              "pbeginTime64": "LARGE_INTEGER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)\n{\n    LARGE_INTEGER LIres;\n    unsigned _int64 res=__rdtsc()-((unsigned _int64)(beginTime64.QuadPart));\n    LIres.QuadPart=res;\n   // printf(\"rdtsc = %I64x\\n\",__rdtsc());\n    return LIres;\n}",
          "fn_code_pos": [
            [
              28,
              0
            ],
            [
              35,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetResRdtsc",
            "parameters": {
              "beginTime64": "LARGE_INTEGER",
              "fComputeTimeQueryPerf": "BOOL"
            },
            "return_type": "LARGE_INTEGER"
          }
        },
        {
          "fn_code": "void myGetRDTSC32(LARGE_INTEGER * pbeginTime64)\n{\n    DWORD dwEdx,dwEax;\n    _asm\n    {\n        rdtsc\n        mov dwEax,eax\n        mov dwEdx,edx\n    }\n    pbeginTime64->LowPart=dwEax;\n    pbeginTime64->HighPart=dwEdx;\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              49,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "myGetRDTSC32",
            "parameters": {
              "pbeginTime64": "LARGE_INTEGER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)\n{\n    myGetRDTSC32(pbeginTime64);\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BeginCountRdtsc",
            "parameters": {
              "pbeginTime64": "LARGE_INTEGER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)\n{\n    LARGE_INTEGER LIres,endTime64;\n    myGetRDTSC32(&endTime64);\n\n    LIres.LowPart=LIres.HighPart=0;\n    MyDoMinus64(&LIres,endTime64,beginTime64);\n    return LIres;\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              64,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetResRdtsc",
            "parameters": {
              "beginTime64": "LARGE_INTEGER",
              "fComputeTimeQueryPerf": "BOOL"
            },
            "return_type": "LARGE_INTEGER"
          }
        },
        {
          "fn_code": "void myGetRDTSC32(LARGE_INTEGER * pbeginTime64)\n{\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              68,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "myGetRDTSC32",
            "parameters": {
              "pbeginTime64": "LARGE_INTEGER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)\n{\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              72,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BeginCountRdtsc",
            "parameters": {
              "pbeginTime64": "LARGE_INTEGER"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)\n{\n    LARGE_INTEGER lr;\n    lr.QuadPart=0;\n    return lr;\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetResRdtsc",
            "parameters": {
              "beginTime64": "LARGE_INTEGER",
              "fComputeTimeQueryPerf": "BOOL"
            },
            "return_type": "LARGE_INTEGER"
          }
        },
        {
          "fn_code": "void BeginCountPerfCounter(LARGE_INTEGER * pbeginTime64,BOOL fComputeTimeQueryPerf)\n{\n    if ((!fComputeTimeQueryPerf) || (!QueryPerformanceCounter(pbeginTime64)))\n    {\n        pbeginTime64->LowPart = GetTickCount();\n        pbeginTime64->HighPart = 0;\n    }\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              90,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BeginCountPerfCounter",
            "parameters": {
              "pbeginTime64": "LARGE_INTEGER",
              "fComputeTimeQueryPerf": "BOOL"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "DWORD GetMsecSincePerfCounter(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)\n{\n    LARGE_INTEGER endTime64,ticksPerSecond,ticks;\n    DWORDLONG ticksShifted,tickSecShifted;\n    DWORD dwLog=16+0;\n    DWORD dwRet;\n    if ((!fComputeTimeQueryPerf) || (!QueryPerformanceCounter(&endTime64)))\n        dwRet = (GetTickCount() - beginTime64.LowPart)*1;\n    else\n    {\n        MyDoMinus64(&ticks,endTime64,beginTime64);\n        QueryPerformanceFrequency(&ticksPerSecond);\n\n\n        {\n            ticksShifted = Int64ShrlMod32(*(DWORDLONG*)&ticks,dwLog);\n            tickSecShifted = Int64ShrlMod32(*(DWORDLONG*)&ticksPerSecond,dwLog);\n\n        }\n\n        dwRet = (DWORD)((((DWORD)ticksShifted)*1000)/(DWORD)(tickSecShifted));\n        dwRet *=1;\n    }\n    return dwRet;\n}",
          "fn_code_pos": [
            [
              92,
              0
            ],
            [
              116,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetMsecSincePerfCounter",
            "parameters": {
              "beginTime64": "LARGE_INTEGER",
              "fComputeTimeQueryPerf": "BOOL"
            },
            "return_type": "DWORD"
          }
        },
        {
          "fn_code": "int ReadFileMemory(const char* filename,long* plFileSize,unsigned char** pFilePtr)\n{\n    FILE* stream;\n    unsigned char* ptr;\n    int retVal=1;\n    stream=fopen(filename, \"rb\");\n    if (stream==NULL)\n        return 0;\n\n    fseek(stream,0,SEEK_END);\n\n    *plFileSize=ftell(stream);\n    fseek(stream,0,SEEK_SET);\n    ptr=malloc((*plFileSize)+1);\n    if (ptr==NULL)\n        retVal=0;\n    else\n    {\n        if (fread(ptr, 1, *plFileSize,stream) != (*plFileSize))\n            retVal=0;\n    }\n    fclose(stream);\n    *pFilePtr=ptr;\n    return retVal;\n}",
          "fn_code_pos": [
            [
              118,
              0
            ],
            [
              142,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadFileMemory",
            "parameters": {
              "filename": "char",
              "plFileSize": "long",
              "pFilePtr": "unsigned char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[])\n{\n    int BlockSizeCompress=0x8000;\n    int BlockSizeUncompress=0x8000;\n    int cprLevel=Z_DEFAULT_COMPRESSION ;\n    long lFileSize;\n    unsigned char* FilePtr;\n    long lBufferSizeCpr;\n    long lBufferSizeUncpr;\n    long lCompressedSize=0;\n    unsigned char* CprPtr;\n    unsigned char* UncprPtr;\n    long lSizeCpr,lSizeUncpr;\n    DWORD dwGetTick,dwMsecQP;\n    LARGE_INTEGER li_qp,li_rdtsc,dwResRdtsc;\n\n    if (argc<=1)\n    {\n        printf(\"run TestZlib <File> [BlockSizeCompress] [BlockSizeUncompress] [compres. level]\\n\");\n        return 0;\n    }\n\n    if (ReadFileMemory(argv[1],&lFileSize,&FilePtr)==0)\n    {\n        printf(\"error reading %s\\n\",argv[1]);\n        return 1;\n    }\n    else printf(\"file %s read, %ld bytes\\n\",argv[1],lFileSize);\n\n    if (argc>=3)\n        BlockSizeCompress=atol(argv[2]);\n\n    if (argc>=4)\n        BlockSizeUncompress=atol(argv[3]);\n\n    if (argc>=5)\n        cprLevel=(int)atol(argv[4]);\n\n    lBufferSizeCpr = lFileSize + (lFileSize/0x10) + 0x200;\n    lBufferSizeUncpr = lBufferSizeCpr;\n\n    CprPtr=(unsigned char*)malloc(lBufferSizeCpr + BlockSizeCompress);\n\n    BeginCountPerfCounter(&li_qp,TRUE);\n    dwGetTick=GetTickCount();\n    BeginCountRdtsc(&li_rdtsc);\n    {\n        z_stream zcpr;\n        int ret=Z_OK;\n        long lOrigToDo = lFileSize;\n        long lOrigDone = 0;\n        int step=0;\n        memset(&zcpr,0,sizeof(z_stream));\n        deflateInit(&zcpr,cprLevel);\n\n        zcpr.next_in = FilePtr;\n        zcpr.next_out = CprPtr;\n\n\n        do\n        {\n            long all_read_before = zcpr.total_in;\n            zcpr.avail_in = min(lOrigToDo,BlockSizeCompress);\n            zcpr.avail_out = BlockSizeCompress;\n            ret=deflate(&zcpr,(zcpr.avail_in==lOrigToDo) ? Z_FINISH : Z_SYNC_FLUSH);\n            lOrigDone += (zcpr.total_in-all_read_before);\n            lOrigToDo -= (zcpr.total_in-all_read_before);\n            step++;\n        } while (ret==Z_OK);\n\n        lSizeCpr=zcpr.total_out;\n        deflateEnd(&zcpr);\n        dwGetTick=GetTickCount()-dwGetTick;\n        dwMsecQP=GetMsecSincePerfCounter(li_qp,TRUE);\n        dwResRdtsc=GetResRdtsc(li_rdtsc,TRUE);\n        printf(\"total compress size = %u, in %u step\\n\",lSizeCpr,step);\n        printf(\"time = %u msec = %f sec\\n\",dwGetTick,dwGetTick/(double)1000.);\n        printf(\"defcpr time QP = %u msec = %f sec\\n\",dwMsecQP,dwMsecQP/(double)1000.);\n        printf(\"defcpr result rdtsc = %I64x\\n\\n\",dwResRdtsc.QuadPart);\n    }\n\n    CprPtr=(unsigned char*)realloc(CprPtr,lSizeCpr);\n    UncprPtr=(unsigned char*)malloc(lBufferSizeUncpr + BlockSizeUncompress);\n\n    BeginCountPerfCounter(&li_qp,TRUE);\n    dwGetTick=GetTickCount();\n    BeginCountRdtsc(&li_rdtsc);\n    {\n        z_stream zcpr;\n        int ret=Z_OK;\n        long lOrigToDo = lSizeCpr;\n        long lOrigDone = 0;\n        int step=0;\n        memset(&zcpr,0,sizeof(z_stream));\n        inflateInit(&zcpr);\n\n        zcpr.next_in = CprPtr;\n        zcpr.next_out = UncprPtr;\n\n\n        do\n        {\n            long all_read_before = zcpr.total_in;\n            zcpr.avail_in = min(lOrigToDo,BlockSizeUncompress);\n            zcpr.avail_out = BlockSizeUncompress;\n            ret=inflate(&zcpr,Z_SYNC_FLUSH);\n            lOrigDone += (zcpr.total_in-all_read_before);\n            lOrigToDo -= (zcpr.total_in-all_read_before);\n            step++;\n        } while (ret==Z_OK);\n\n        lSizeUncpr=zcpr.total_out;\n        inflateEnd(&zcpr);\n        dwGetTick=GetTickCount()-dwGetTick;\n        dwMsecQP=GetMsecSincePerfCounter(li_qp,TRUE);\n        dwResRdtsc=GetResRdtsc(li_rdtsc,TRUE);\n        printf(\"total uncompress size = %u, in %u step\\n\",lSizeUncpr,step);\n        printf(\"time = %u msec = %f sec\\n\",dwGetTick,dwGetTick/(double)1000.);\n        printf(\"uncpr  time QP = %u msec = %f sec\\n\",dwMsecQP,dwMsecQP/(double)1000.);\n        printf(\"uncpr  result rdtsc = %I64x\\n\\n\",dwResRdtsc.QuadPart);\n    }\n\n    if (lSizeUncpr==lFileSize)\n    {\n        if (memcmp(FilePtr,UncprPtr,lFileSize)==0)\n            printf(\"compare ok\\n\");\n\n    }\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              144,
              0
            ],
            [
              274,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "__rdtsc(void)",
          "fn_dec_pos": [
            [
              21,
              17
            ],
            [
              21,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "__rdtsc",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include <windows.h>\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            4,
            0
          ],
          [
            5,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/blast/blast.c": {
      "fn_def_list": [
        {
          "fn_code": "local int bits(struct state *s, int need)\n{\n    int val;            /* bit accumulator */\n\n    /* load at least need bits into val */\n    val = s->bitbuf;\n    while (s->bitcnt < need) {\n        if (s->left == 0) {\n            s->left = s->infun(s->inhow, &(s->in));\n            if (s->left == 0) longjmp(s->env, 1);       /* out of input */\n        }\n        val |= (int)(*(s->in)++) << s->bitcnt;          /* load eight bits */\n        s->left--;\n        s->bitcnt += 8;\n    }\n\n    /* drop need bits and update buffer, always zero to seven bits left */\n    s->bitbuf = val >> need;\n    s->bitcnt -= need;\n\n    /* return need bits, zeroing the bits above that */\n    return val & ((1 << need) - 1);\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              93,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bits",
            "parameters": {
              "s": "struct state",
              "need": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int decode(struct state *s, struct huffman *h)\n{\n    int len;            /* current number of bits in code */\n    int code;           /* len bits being decoded */\n    int first;          /* first code of length len */\n    int count;          /* number of codes of length len */\n    int index;          /* index of first code of length len in symbol table */\n    int bitbuf;         /* bits from stream */\n    int left;           /* bits left in next or left to process */\n    short *next;        /* next number of codes */\n\n    bitbuf = s->bitbuf;\n    left = s->bitcnt;\n    code = first = index = 0;\n    len = 1;\n    next = h->count + 1;\n    while (1) {\n        while (left--) {\n            code |= (bitbuf & 1) ^ 1;   /* invert code */\n            bitbuf >>= 1;\n            count = *next++;\n            if (code < first + count) { /* if length len, return symbol */\n                s->bitbuf = bitbuf;\n                s->bitcnt = (s->bitcnt - len) & 7;\n                return h->symbol[index + (code - first)];\n            }\n            index += count;             /* else update for next length */\n            first += count;\n            first <<= 1;\n            code <<= 1;\n            len++;\n        }\n        left = (MAXBITS+1) - len;\n        if (left == 0) break;\n        if (s->left == 0) {\n            s->left = s->infun(s->inhow, &(s->in));\n            if (s->left == 0) longjmp(s->env, 1);       /* out of input */\n        }\n        bitbuf = *(s->in)++;\n        s->left--;\n        if (left > 8) left = 8;\n    }\n    return -9;                          /* ran out of codes */\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              171,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "decode",
            "parameters": {
              "s": "struct state",
              "h": "struct huffman"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int construct(struct huffman *h, const unsigned char *rep, int n)\n{\n    int symbol;         /* current symbol when stepping through length[] */\n    int len;            /* current length when stepping through h->count[] */\n    int left;           /* number of possible codes left of current length */\n    short offs[MAXBITS+1];      /* offsets in symbol table for each length */\n    short length[256];  /* code lengths */\n\n    /* convert compact repeat counts into symbol bit length list */\n    symbol = 0;\n    do {\n        len = *rep++;\n        left = (len >> 4) + 1;\n        len &= 15;\n        do {\n            length[symbol++] = len;\n        } while (--left);\n    } while (--n);\n    n = symbol;\n\n    /* count number of codes of each length */\n    for (len = 0; len <= MAXBITS; len++)\n        h->count[len] = 0;\n    for (symbol = 0; symbol < n; symbol++)\n        (h->count[length[symbol]])++;   /* assumes lengths are within bounds */\n    if (h->count[0] == n)               /* no codes! */\n        return 0;                       /* complete, but decode() will fail */\n\n    /* check for an over-subscribed or incomplete set of lengths */\n    left = 1;                           /* one possible code of zero length */\n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;                     /* one more bit, double codes left */\n        left -= h->count[len];          /* deduct count from possible codes */\n        if (left < 0) return left;      /* over-subscribed--return negative */\n    }                                   /* left > 0 means incomplete */\n\n    /* generate offsets into symbol table for each length for sorting */\n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + h->count[len];\n\n    /*\n     * put symbols in table sorted by length, by symbol order within each\n     * length\n     */\n    for (symbol = 0; symbol < n; symbol++)\n        if (length[symbol] != 0)\n            h->symbol[offs[length[symbol]]++] = symbol;\n\n    /* return zero for complete set, positive for incomplete set */\n    return left;\n}",
          "fn_code_pos": [
            [
              190,
              0
            ],
            [
              241,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "construct",
            "parameters": {
              "h": "struct huffman",
              "rep": "unsigned char",
              "n": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int decomp(struct state *s)\n{\n    int lit;            /* true if literals are coded */\n    int dict;           /* log2(dictionary size) - 6 */\n    int symbol;         /* decoded symbol, extra bits for distance */\n    int len;            /* length for copy */\n    unsigned dist;      /* distance for copy */\n    int copy;           /* copy counter */\n    unsigned char *from, *to;   /* copy pointers */\n    static int virgin = 1;                              /* build tables once */\n    static short litcnt[MAXBITS+1], litsym[256];        /* litcode memory */\n    static short lencnt[MAXBITS+1], lensym[16];         /* lencode memory */\n    static short distcnt[MAXBITS+1], distsym[64];       /* distcode memory */\n    static struct huffman litcode = {litcnt, litsym};   /* length code */\n    static struct huffman lencode = {lencnt, lensym};   /* length code */\n    static struct huffman distcode = {distcnt, distsym};/* distance code */\n        /* bit lengths of literal codes */\n    static const unsigned char litlen[] = {\n        11, 124, 8, 7, 28, 7, 188, 13, 76, 4, 10, 8, 12, 10, 12, 10, 8, 23, 8,\n        9, 7, 6, 7, 8, 7, 6, 55, 8, 23, 24, 12, 11, 7, 9, 11, 12, 6, 7, 22, 5,\n        7, 24, 6, 11, 9, 6, 7, 22, 7, 11, 38, 7, 9, 8, 25, 11, 8, 11, 9, 12,\n        8, 12, 5, 38, 5, 38, 5, 11, 7, 5, 6, 21, 6, 10, 53, 8, 7, 24, 10, 27,\n        44, 253, 253, 253, 252, 252, 252, 13, 12, 45, 12, 45, 12, 61, 12, 45,\n        44, 173};\n        /* bit lengths of length codes 0..15 */\n    static const unsigned char lenlen[] = {2, 35, 36, 53, 38, 23};\n        /* bit lengths of distance codes 0..63 */\n    static const unsigned char distlen[] = {2, 20, 53, 230, 247, 151, 248};\n    static const short base[16] = {     /* base for length codes */\n        3, 2, 4, 5, 6, 7, 8, 9, 10, 12, 16, 24, 40, 72, 136, 264};\n    static const char extra[16] = {     /* extra bits for length codes */\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8};\n\n    /* set up decoding tables (once--might not be thread-safe) */\n    if (virgin) {\n        construct(&litcode, litlen, sizeof(litlen));\n        construct(&lencode, lenlen, sizeof(lenlen));\n        construct(&distcode, distlen, sizeof(distlen));\n        virgin = 0;\n    }\n\n    /* read header */\n    lit = bits(s, 8);\n    if (lit > 1) return -1;\n    dict = bits(s, 8);\n    if (dict < 4 || dict > 6) return -2;\n\n    /* decode literals and length/distance pairs */\n    do {\n        if (bits(s, 1)) {\n            /* get length */\n            symbol = decode(s, &lencode);\n            len = base[symbol] + bits(s, extra[symbol]);\n            if (len == 519) break;              /* end code */\n\n            /* get distance */\n            symbol = len == 2 ? 2 : dict;\n            dist = decode(s, &distcode) << symbol;\n            dist += bits(s, symbol);\n            dist++;\n            if (s->first && dist > s->next)\n                return -3;              /* distance too far back */\n\n            /* copy length bytes from distance bytes back */\n            do {\n                to = s->out + s->next;\n                from = to - dist;\n                copy = MAXWIN;\n                if (s->next < dist) {\n                    from += copy;\n                    copy = dist;\n                }\n                copy -= s->next;\n                if (copy > len) copy = len;\n                len -= copy;\n                s->next += copy;\n                do {\n                    *to++ = *from++;\n                } while (--copy);\n                if (s->next == MAXWIN) {\n                    if (s->outfun(s->outhow, s->out, s->next)) return 1;\n                    s->next = 0;\n                    s->first = 0;\n                }\n            } while (len != 0);\n        }\n        else {\n            /* get literal and write it */\n            symbol = lit ? decode(s, &litcode) : bits(s, 8);\n            s->out[s->next++] = symbol;\n            if (s->next == MAXWIN) {\n                if (s->outfun(s->outhow, s->out, s->next)) return 1;\n                s->next = 0;\n                s->first = 0;\n            }\n        }\n    } while (1);\n    return 0;\n}",
          "fn_code_pos": [
            [
              281,
              0
            ],
            [
              379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "decomp",
            "parameters": {
              "s": "struct state"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int blast(blast_in infun, void *inhow, blast_out outfun, void *outhow,\n          unsigned *left, unsigned char **in)\n{\n    struct state s;             /* input/output state */\n    int err;                    /* return value */\n\n    /* initialize input state */\n    s.infun = infun;\n    s.inhow = inhow;\n    if (left != NULL && *left) {\n        s.left = *left;\n        s.in = *in;\n    }\n    else\n        s.left = 0;\n    s.bitbuf = 0;\n    s.bitcnt = 0;\n\n    /* initialize output state */\n    s.outfun = outfun;\n    s.outhow = outhow;\n    s.next = 0;\n    s.first = 1;\n\n    /* return if bits() or decode() tries to read past available input */\n    if (setjmp(s.env) != 0)             /* if came back here via longjmp(), */\n        err = 2;                        /*  then skip decomp(), return error */\n    else\n        err = decomp(&s);               /* decompress */\n\n    /* return unused input */\n    if (left != NULL)\n        *left = s.left;\n    if (in != NULL)\n        *in = s.left ? s.in : NULL;\n\n    /* write any leftover output and update the error code if needed */\n    if (err != 1 && s.next && s.outfun(s.outhow, s.out, s.next) && err == 0)\n        err = 1;\n    return err;\n}",
          "fn_code_pos": [
            [
              382,
              0
            ],
            [
              422,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "blast",
            "parameters": {
              "infun": "blast_in",
              "inhow": "void",
              "outfun": "blast_out",
              "outhow": "void",
              "left": "unsigned",
              "in": "unsigned char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "local unsigned inf(void *how, unsigned char **buf)\n{\n    static unsigned char hold[CHUNK];\n\n    *buf = hold;\n    return fread(hold, 1, CHUNK, (FILE *)how);\n}",
          "fn_code_pos": [
            [
              431,
              0
            ],
            [
              437,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inf",
            "parameters": {
              "how": "void",
              "buf": "unsigned char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "local int outf(void *how, unsigned char *buf, unsigned len)\n{\n    return fwrite(buf, 1, len, (FILE *)how) != len;\n}",
          "fn_code_pos": [
            [
              439,
              0
            ],
            [
              442,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "outf",
            "parameters": {
              "how": "void",
              "buf": "unsigned char",
              "len": "unsigned"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int main(void)\n{\n    int ret;\n    unsigned left;\n\n    /* decompress to stdout */\n    left = 0;\n    ret = blast(inf, stdin, outf, stdout, &left, NULL);\n    if (ret != 0)\n        fprintf(stderr, \"blast error: %d\\n\", ret);\n\n    /* count any leftover bytes */\n    while (getchar() != EOF)\n        left++;\n    if (left)\n        fprintf(stderr, \"blast warning: %u unused bytes of input\\n\", left);\n\n    /* return blast() error code */\n    return ret;\n}",
          "fn_code_pos": [
            [
              445,
              0
            ],
            [
              464,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct state {\n    /* input state */\n    blast_in infun;             /* input function provided by user */\n    void *inhow;                /* opaque information passed to infun() */\n    unsigned char *in;          /* next input location */\n    unsigned left;              /* available input at in */\n    int bitbuf;                 /* bit buffer */\n    int bitcnt;                 /* number of bits in bit buffer */\n\n    /* input limit error return state for bits() and decode() */\n    jmp_buf env;\n\n    /* output state */\n    blast_out outfun;           /* output function provided by user */\n    void *outhow;               /* opaque information passed to outfun() */\n    unsigned next;              /* index of next write location in out[] */\n    int first;                  /* true to check distances (for first 4K) */\n    unsigned char out[MAXWIN];  /* output buffer and sliding window */\n}",
          {
            "infun": "blast_in",
            "*inhow": "void",
            "*in": "unsigned char",
            "left": "unsigned",
            "bitbuf": "int",
            "bitcnt": "int",
            "env": "jmp_buf",
            "outfun": "blast_out",
            "*outhow": "void",
            "next": "unsigned",
            "first": "int",
            "out[MAXWIN]": "unsigned char"
          },
          "state",
          [
            40,
            0
          ],
          [
            58,
            1
          ]
        ],
        [
          "struct huffman {\n    short *count;       /* number of symbols of each length */\n    short *symbol;      /* canonically ordered symbols */\n}",
          {
            "*count": "short",
            "*symbol": "short"
          },
          "huffman",
          [
            102,
            0
          ],
          [
            105,
            1
          ]
        ],
        [
          "struct state {\n    /* input state */\n    blast_in infun;             /* input function provided by user */\n    void *inhow;                /* opaque information passed to infun() */\n    unsigned char *in;          /* next input location */\n    unsigned left;              /* available input at in */\n    int bitbuf;                 /* bit buffer */\n    int bitcnt;                 /* number of bits in bit buffer */\n\n    /* input limit error return state for bits() and decode() */\n    jmp_buf env;\n\n    /* output state */\n    blast_out outfun;           /* output function provided by user */\n    void *outhow;               /* opaque information passed to outfun() */\n    unsigned next;              /* index of next write location in out[] */\n    int first;                  /* true to check distances (for first 4K) */\n    unsigned char out[MAXWIN];  /* output buffer and sliding window */\n}",
          {
            "infun": "blast_in",
            "*inhow": "void",
            "*in": "unsigned char",
            "left": "unsigned",
            "bitbuf": "int",
            "bitcnt": "int",
            "env": "jmp_buf",
            "outfun": "blast_out",
            "*outhow": "void",
            "next": "unsigned",
            "first": "int",
            "out[MAXWIN]": "unsigned char"
          },
          "state",
          [
            40,
            0
          ],
          [
            58,
            1
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            71,
            15
          ],
          [
            71,
            27
          ]
        ],
        [
          "struct huffman {\n    short *count;       /* number of symbols of each length */\n    short *symbol;      /* canonically ordered symbols */\n}",
          {
            "*count": "short",
            "*symbol": "short"
          },
          "huffman",
          [
            102,
            0
          ],
          [
            105,
            1
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            128,
            17
          ],
          [
            128,
            29
          ]
        ],
        [
          "struct huffman",
          {},
          "",
          [
            128,
            34
          ],
          [
            128,
            48
          ]
        ],
        [
          "struct huffman",
          {},
          "",
          [
            190,
            20
          ],
          [
            190,
            34
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            281,
            17
          ],
          [
            281,
            29
          ]
        ],
        [
          "struct huffman",
          {},
          "",
          [
            294,
            11
          ],
          [
            294,
            25
          ]
        ],
        [
          "struct huffman",
          {},
          "",
          [
            295,
            11
          ],
          [
            295,
            25
          ]
        ],
        [
          "struct huffman",
          {},
          "",
          [
            296,
            11
          ],
          [
            296,
            25
          ]
        ],
        [
          "struct state",
          {},
          "",
          [
            385,
            4
          ],
          [
            385,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stddef.h>             /* for NULL */\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <setjmp.h>             /* for setjmp(), longjmp(), and jmp_buf */\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include \"blast.h\"              /* prototype for blast() */\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            426,
            0
          ],
          [
            427,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            427,
            0
          ],
          [
            428,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/iostream/test.cpp": {
      "fn_def_list": [
        {
          "fn_code": "int main() {\n\n  // Construct a stream object with this filebuffer.  Anything sent\n  // to this stream will go to standard out.\n  gzofstream os( 1, ios::out );\n\n  // This text is getting compressed and sent to stdout.\n  // To prove this, run 'test | zcat'.\n  os << \"Hello, Mommy\" << endl;\n\n  os << setcompressionlevel( Z_NO_COMPRESSION );\n  os << \"hello, hello, hi, ho!\" << endl;\n\n  setcompressionlevel( os, Z_DEFAULT_COMPRESSION )\n    << \"I'm compressing again\" << endl;\n\n  os.close();\n\n  return 0;\n\n}",
          "fn_code_pos": [
            [
              3,
              0
            ],
            [
              23,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"zfstream.h\"\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/iostream/zfstream.cpp": {
      "fn_def_list": [
        {
          "fn_code": "gzfilebuf::gzfilebuf() :\n  file(NULL),\n  mode(0),\n  own_file_descriptor(0)\n{ }",
          "fn_code_pos": [
            [
              3,
              0
            ],
            [
              7,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::gzfilebuf",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzfilebuf::~gzfilebuf() {\n\n  sync();\n  if ( own_file_descriptor )\n    close();\n\n}",
          "fn_code_pos": [
            [
              9,
              0
            ],
            [
              15,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::~gzfilebuf",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzfilebuf *gzfilebuf::open( const char *name,\n                            int io_mode ) {\n\n  if ( is_open() )\n    return NULL;\n\n  char char_mode[10];\n  char *p = char_mode;\n\n  if ( io_mode & ios::in ) {\n    mode = ios::in;\n    *p++ = 'r';\n  } else if ( io_mode & ios::app ) {\n    mode = ios::app;\n    *p++ = 'a';\n  } else {\n    mode = ios::out;\n    *p++ = 'w';\n  }\n\n  if ( io_mode & ios::binary ) {\n    mode |= ios::binary;\n    *p++ = 'b';\n  }\n\n  // Hard code the compression level\n  if ( io_mode & (ios::out|ios::app )) {\n    *p++ = '9';\n  }\n\n  // Put the end-of-string indicator\n  *p = '\\0';\n\n  if ( (file = gzopen(name, char_mode)) == NULL )\n    return NULL;\n\n  own_file_descriptor = 1;\n\n  return this;\n\n}",
          "fn_code_pos": [
            [
              17,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::open",
            "parameters": {
              "name": "char",
              "io_mode": "int"
            },
            "return_type": "gzfilebuf"
          }
        },
        {
          "fn_code": "gzfilebuf *gzfilebuf::attach( int file_descriptor,\n                              int io_mode ) {\n\n  if ( is_open() )\n    return NULL;\n\n  char char_mode[10];\n  char *p = char_mode;\n\n  if ( io_mode & ios::in ) {\n    mode = ios::in;\n    *p++ = 'r';\n  } else if ( io_mode & ios::app ) {\n    mode = ios::app;\n    *p++ = 'a';\n  } else {\n    mode = ios::out;\n    *p++ = 'w';\n  }\n\n  if ( io_mode & ios::binary ) {\n    mode |= ios::binary;\n    *p++ = 'b';\n  }\n\n  // Hard code the compression level\n  if ( io_mode & (ios::out|ios::app )) {\n    *p++ = '9';\n  }\n\n  // Put the end-of-string indicator\n  *p = '\\0';\n\n  if ( (file = gzdopen(file_descriptor, char_mode)) == NULL )\n    return NULL;\n\n  own_file_descriptor = 0;\n\n  return this;\n\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::attach",
            "parameters": {
              "file_descriptor": "int",
              "io_mode": "int"
            },
            "return_type": "gzfilebuf"
          }
        },
        {
          "fn_code": "gzfilebuf *gzfilebuf::close() {\n\n  if ( is_open() ) {\n\n    sync();\n    gzclose( file );\n    file = NULL;\n\n  }\n\n  return this;\n\n}",
          "fn_code_pos": [
            [
              101,
              0
            ],
            [
              113,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::close",
            "parameters": {},
            "return_type": "gzfilebuf"
          }
        },
        {
          "fn_code": "int gzfilebuf::setcompressionlevel( int comp_level ) {\n\n  return gzsetparams(file, comp_level, -2);\n\n}",
          "fn_code_pos": [
            [
              115,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::setcompressionlevel",
            "parameters": {
              "comp_level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int gzfilebuf::setcompressionstrategy( int comp_strategy ) {\n\n  return gzsetparams(file, -2, comp_strategy);\n\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::setcompressionstrategy",
            "parameters": {
              "comp_strategy": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "streampos gzfilebuf::seekoff( streamoff off, ios::seek_dir dir, int which ) {\n\n  return streampos(EOF);\n\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              132,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::seekoff",
            "parameters": {
              "off": "streamoff",
              "dir": "ios::seek_dir",
              "which": "int"
            },
            "return_type": "streampos"
          }
        },
        {
          "fn_code": "int gzfilebuf::underflow() {\n\n  // If the file hasn't been opened for reading, error.\n  if ( !is_open() || !(mode & ios::in) )\n    return EOF;\n\n  // if a buffer doesn't exists, allocate one.\n  if ( !base() ) {\n\n    if ( (allocate()) == EOF )\n      return EOF;\n    setp(0,0);\n\n  } else {\n\n    if ( in_avail() )\n      return (unsigned char) *gptr();\n\n    if ( out_waiting() ) {\n      if ( flushbuf() == EOF )\n        return EOF;\n    }\n\n  }\n\n  // Attempt to fill the buffer.\n\n  int result = fillbuf();\n  if ( result == EOF ) {\n    // disable get area\n    setg(0,0,0);\n    return EOF;\n  }\n\n  return (unsigned char) *gptr();\n\n}",
          "fn_code_pos": [
            [
              134,
              0
            ],
            [
              170,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::underflow",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int gzfilebuf::overflow( int c ) {\n\n  if ( !is_open() || !(mode & ios::out) )\n    return EOF;\n\n  if ( !base() ) {\n    if ( allocate() == EOF )\n      return EOF;\n    setg(0,0,0);\n  } else {\n    if (in_avail()) {\n        return EOF;\n    }\n    if (out_waiting()) {\n      if (flushbuf() == EOF)\n        return EOF;\n    }\n  }\n\n  int bl = blen();\n  setp( base(), base() + bl);\n\n  if ( c != EOF ) {\n\n    *pptr() = c;\n    pbump(1);\n\n  }\n\n  return 0;\n\n}",
          "fn_code_pos": [
            [
              172,
              0
            ],
            [
              203,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::overflow",
            "parameters": {
              "c": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int gzfilebuf::sync() {\n\n  if ( !is_open() )\n    return EOF;\n\n  if ( out_waiting() )\n    return flushbuf();\n\n  return 0;\n\n}",
          "fn_code_pos": [
            [
              205,
              0
            ],
            [
              215,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::sync",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int gzfilebuf::flushbuf() {\n\n  int n;\n  char *q;\n\n  q = pbase();\n  n = pptr() - q;\n\n  if ( gzwrite( file, q, n) < n )\n    return EOF;\n\n  setp(0,0);\n\n  return 0;\n\n}",
          "fn_code_pos": [
            [
              217,
              0
            ],
            [
              232,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::flushbuf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int gzfilebuf::fillbuf() {\n\n  int required;\n  char *p;\n\n  p = base();\n\n  required = blen();\n\n  int t = gzread( file, p, required );\n\n  if ( t <= 0) return EOF;\n\n  setg( base(), base(), base()+t);\n\n  return t;\n\n}",
          "fn_code_pos": [
            [
              234,
              0
            ],
            [
              251,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::fillbuf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "gzfilestream_common::gzfilestream_common() :\n  ios( gzfilestream_common::rdbuf() )\n{ }",
          "fn_code_pos": [
            [
              253,
              0
            ],
            [
              255,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilestream_common::gzfilestream_common",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzfilestream_common::~gzfilestream_common()\n{ }",
          "fn_code_pos": [
            [
              257,
              0
            ],
            [
              258,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilestream_common::~gzfilestream_common",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void gzfilestream_common::attach( int fd, int io_mode ) {\n\n  if ( !buffer.attach( fd, io_mode) )\n    clear( ios::failbit | ios::badbit );\n  else\n    clear();\n\n}",
          "fn_code_pos": [
            [
              260,
              0
            ],
            [
              267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilestream_common::attach",
            "parameters": {
              "fd": "int",
              "io_mode": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void gzfilestream_common::open( const char *name, int io_mode ) {\n\n  if ( !buffer.open( name, io_mode ) )\n    clear( ios::failbit | ios::badbit );\n  else\n    clear();\n\n}",
          "fn_code_pos": [
            [
              269,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilestream_common::open",
            "parameters": {
              "name": "char",
              "io_mode": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void gzfilestream_common::close() {\n\n  if ( !buffer.close() )\n    clear( ios::failbit | ios::badbit );\n\n}",
          "fn_code_pos": [
            [
              278,
              0
            ],
            [
              283,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilestream_common::close",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "gzfilebuf *gzfilestream_common::rdbuf()\n{\n  return &buffer;\n}",
          "fn_code_pos": [
            [
              285,
              0
            ],
            [
              288,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilestream_common::rdbuf",
            "parameters": {},
            "return_type": "gzfilebuf"
          }
        },
        {
          "fn_code": "gzifstream::gzifstream() :\n  ios( gzfilestream_common::rdbuf() )\n{\n  clear( ios::badbit );\n}",
          "fn_code_pos": [
            [
              290,
              0
            ],
            [
              294,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzifstream::gzifstream",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzifstream::gzifstream( const char *name, int io_mode ) :\n  ios( gzfilestream_common::rdbuf() )\n{\n  gzfilestream_common::open( name, io_mode );\n}",
          "fn_code_pos": [
            [
              296,
              0
            ],
            [
              300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzifstream::gzifstream",
            "parameters": {
              "name": "char",
              "io_mode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzifstream::gzifstream( int fd, int io_mode ) :\n  ios( gzfilestream_common::rdbuf() )\n{\n  gzfilestream_common::attach( fd, io_mode );\n}",
          "fn_code_pos": [
            [
              302,
              0
            ],
            [
              306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzifstream::gzifstream",
            "parameters": {
              "fd": "int",
              "io_mode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzifstream::~gzifstream() { }",
          "fn_code_pos": [
            [
              308,
              0
            ],
            [
              308,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzifstream::~gzifstream",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzofstream::gzofstream() :\n  ios( gzfilestream_common::rdbuf() )\n{\n  clear( ios::badbit );\n}",
          "fn_code_pos": [
            [
              310,
              0
            ],
            [
              314,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzofstream::gzofstream",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzofstream::gzofstream( const char *name, int io_mode ) :\n  ios( gzfilestream_common::rdbuf() )\n{\n  gzfilestream_common::open( name, io_mode );\n}",
          "fn_code_pos": [
            [
              316,
              0
            ],
            [
              320,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzofstream::gzofstream",
            "parameters": {
              "name": "char",
              "io_mode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzofstream::gzofstream( int fd, int io_mode ) :\n  ios( gzfilestream_common::rdbuf() )\n{\n  gzfilestream_common::attach( fd, io_mode );\n}",
          "fn_code_pos": [
            [
              322,
              0
            ],
            [
              326,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzofstream::gzofstream",
            "parameters": {
              "fd": "int",
              "io_mode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzofstream::~gzofstream() { }",
          "fn_code_pos": [
            [
              328,
              0
            ],
            [
              328,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzofstream::~gzofstream",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "gzfilebuf::open( const char *name,\n                            int io_mode )",
          "fn_dec_pos": [
            [
              17,
              11
            ],
            [
              18,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::open",
            "parameters": {
              "name": "char",
              "io_mode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzfilebuf::attach( int file_descriptor,\n                              int io_mode )",
          "fn_dec_pos": [
            [
              59,
              11
            ],
            [
              60,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::attach",
            "parameters": {
              "file_descriptor": "int",
              "io_mode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzfilebuf::close()",
          "fn_dec_pos": [
            [
              101,
              11
            ],
            [
              101,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilebuf::close",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzfilestream_common::rdbuf()",
          "fn_dec_pos": [
            [
              285,
              11
            ],
            [
              285,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfilestream_common::rdbuf",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"zfstream.h\"\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/untgz/untgz.c": {
      "fn_def_list": [
        {
          "fn_code": "void error(const char *msg)\n{\n  fprintf(stderr, \"%s: %s\\n\", prog, msg);\n  exit(1);\n}",
          "fn_code_pos": [
            [
              119,
              0
            ],
            [
              123,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "error",
            "parameters": {
              "msg": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "char *TGZfname (const char *arcname)\n{\n  static char buffer[1024];\n  int origlen,i;\n\n  strcpy(buffer,arcname);\n  origlen = strlen(buffer);\n\n  for (i=0; TGZsuffix[i]; i++)\n    {\n       strcpy(buffer+origlen,TGZsuffix[i]);\n       if (access(buffer,F_OK) == 0)\n         return buffer;\n    }\n  return NULL;\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TGZfname",
            "parameters": {
              "arcname": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "void TGZnotfound (const char *arcname)\n{\n  int i;\n\n  fprintf(stderr,\"%s: Couldn't find \",prog);\n  for (i=0;TGZsuffix[i];i++)\n    fprintf(stderr,(TGZsuffix[i+1]) ? \"%s%s, \" : \"or %s%s\\n\",\n            arcname,\n            TGZsuffix[i]);\n  exit(1);\n}",
          "fn_code_pos": [
            [
              150,
              0
            ],
            [
              160,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TGZnotfound",
            "parameters": {
              "arcname": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int getoct (char *p,int width)\n{\n  int result = 0;\n  char c;\n\n  while (width--)\n    {\n      c = *p++;\n      if (c == 0)\n        break;\n      if (c == ' ')\n        continue;\n      if (c < '0' || c > '7')\n        return -1;\n      result = result * 8 + (c - '0');\n    }\n  return result;\n}",
          "fn_code_pos": [
            [
              166,
              0
            ],
            [
              183,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getoct",
            "parameters": {
              "p": "char",
              "width": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "char *strtime (time_t *t)\n{\n  struct tm   *local;\n  static char result[32];\n\n  local = localtime(t);\n  sprintf(result,\"%4d/%02d/%02d %02d:%02d:%02d\",\n          local->tm_year+1900, local->tm_mon+1, local->tm_mday,\n          local->tm_hour, local->tm_min, local->tm_sec);\n  return result;\n}",
          "fn_code_pos": [
            [
              189,
              0
            ],
            [
              199,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strtime",
            "parameters": {
              "t": "time_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int setfiletime (char *fname,time_t ftime)\n{\n#ifdef _WIN32\n  static int isWinNT = -1;\n  SYSTEMTIME st;\n  FILETIME locft, modft;\n  struct tm *loctm;\n  HANDLE hFile;\n  int result;\n\n  loctm = localtime(&ftime);\n  if (loctm == NULL)\n    return -1;\n\n  st.wYear         = (WORD)loctm->tm_year + 1900;\n  st.wMonth        = (WORD)loctm->tm_mon + 1;\n  st.wDayOfWeek    = (WORD)loctm->tm_wday;\n  st.wDay          = (WORD)loctm->tm_mday;\n  st.wHour         = (WORD)loctm->tm_hour;\n  st.wMinute       = (WORD)loctm->tm_min;\n  st.wSecond       = (WORD)loctm->tm_sec;\n  st.wMilliseconds = 0;\n  if (!SystemTimeToFileTime(&st, &locft) ||\n      !LocalFileTimeToFileTime(&locft, &modft))\n    return -1;\n\n  if (isWinNT < 0)\n    isWinNT = (GetVersion() < 0x80000000) ? 1 : 0;\n  hFile = CreateFile(fname, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,\n                     (isWinNT ? FILE_FLAG_BACKUP_SEMANTICS : 0),\n                     NULL);\n  if (hFile == INVALID_HANDLE_VALUE)\n    return -1;\n  result = SetFileTime(hFile, NULL, NULL, &modft) ? 0 : -1;\n  CloseHandle(hFile);\n  return result;\n#else\n  struct utimbuf settime;\n\n  settime.actime = settime.modtime = ftime;\n  return utime(fname,&settime);\n#endif\n}",
          "fn_code_pos": [
            [
              204,
              0
            ],
            [
              246,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setfiletime",
            "parameters": {
              "fname": "char",
              "ftime": "time_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void push_attr(struct attr_item **list,char *fname,int mode,time_t time)\n{\n  struct attr_item *item;\n\n  item = (struct attr_item *)malloc(sizeof(struct attr_item));\n  if (item == NULL)\n    error(\"Out of memory\");\n  item->fname = strdup(fname);\n  item->mode  = mode;\n  item->time  = time;\n  item->next  = *list;\n  *list       = item;\n}",
          "fn_code_pos": [
            [
              251,
              0
            ],
            [
              263,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "push_attr",
            "parameters": {
              "list": "struct attr_item",
              "fname": "char",
              "mode": "int",
              "time": "time_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void restore_attr(struct attr_item **list)\n{\n  struct attr_item *item, *prev;\n\n  for (item = *list; item != NULL; )\n    {\n      setfiletime(item->fname,item->time);\n      chmod(item->fname,item->mode);\n      prev = item;\n      item = item->next;\n      free(prev);\n    }\n  *list = NULL;\n}",
          "fn_code_pos": [
            [
              268,
              0
            ],
            [
              281,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "restore_attr",
            "parameters": {
              "list": "struct attr_item"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ExprMatch (char *string,char *expr)\n{\n  while (1)\n    {\n      if (ISSPECIAL(*expr))\n        {\n          if (*expr == '/')\n            {\n              if (*string != '\\\\' && *string != '/')\n                return 0;\n              string ++; expr++;\n            }\n          else if (*expr == '*')\n            {\n              if (*expr ++ == 0)\n                return 1;\n              while (*++string != *expr)\n                if (*string == 0)\n                  return 0;\n            }\n        }\n      else\n        {\n          if (*string != *expr)\n            return 0;\n          if (*expr++ == 0)\n            return 1;\n          string++;\n        }\n    }\n}",
          "fn_code_pos": [
            [
              288,
              0
            ],
            [
              318,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ExprMatch",
            "parameters": {
              "string": "char",
              "expr": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int makedir (char *newdir)\n{\n  char *buffer = strdup(newdir);\n  char *p;\n  int  len = strlen(buffer);\n\n  if (len <= 0) {\n    free(buffer);\n    return 0;\n  }\n  if (buffer[len-1] == '/') {\n    buffer[len-1] = '\\0';\n  }\n  if (mkdir(buffer, 0755) == 0)\n    {\n      free(buffer);\n      return 1;\n    }\n\n  p = buffer+1;\n  while (1)\n    {\n      char hold;\n\n      while(*p && *p != '\\\\' && *p != '/')\n        p++;\n      hold = *p;\n      *p = 0;\n      if ((mkdir(buffer, 0755) == -1) && (errno == ENOENT))\n        {\n          fprintf(stderr,\"%s: Couldn't create directory %s\\n\",prog,buffer);\n          free(buffer);\n          return 0;\n        }\n      if (hold == 0)\n        break;\n      *p++ = hold;\n    }\n  free(buffer);\n  return 1;\n}",
          "fn_code_pos": [
            [
              326,
              0
            ],
            [
              366,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "makedir",
            "parameters": {
              "newdir": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int matchname (int arg,int argc,char **argv,char *fname)\n{\n  if (arg == argc)      /* no arguments given (untgz tgzarchive) */\n    return 1;\n\n  while (arg < argc)\n    if (ExprMatch(fname,argv[arg++]))\n      return 1;\n\n  return 0; /* ignore this for the moment being */\n}",
          "fn_code_pos": [
            [
              369,
              0
            ],
            [
              379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "matchname",
            "parameters": {
              "arg": "int",
              "argc": "int",
              "argv": "char",
              "fname": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int tar (gzFile in,int action,int arg,int argc,char **argv)\n{\n  union  tar_buffer buffer;\n  int    len;\n  int    err;\n  int    getheader = 1;\n  int    remaining = 0;\n  FILE   *outfile = NULL;\n  char   fname[BLOCKSIZE];\n  int    tarmode;\n  time_t tartime;\n  struct attr_item *attributes = NULL;\n\n  if (action == TGZ_LIST)\n    printf(\"    date      time     size                       file\\n\"\n           \" ---------- -------- --------- -------------------------------------\\n\");\n  while (1)\n    {\n      len = gzread(in, &buffer, BLOCKSIZE);\n      if (len < 0)\n        error(gzerror(in, &err));\n      /*\n       * Always expect complete blocks to process\n       * the tar information.\n       */\n      if (len != BLOCKSIZE)\n        {\n          action = TGZ_INVALID; /* force error exit */\n          remaining = 0;        /* force I/O cleanup */\n        }\n\n      /*\n       * If we have to get a tar header\n       */\n      if (getheader >= 1)\n        {\n          /*\n           * if we met the end of the tar\n           * or the end-of-tar block,\n           * we are done\n           */\n          if (len == 0 || buffer.header.name[0] == 0)\n            break;\n\n          tarmode = getoct(buffer.header.mode,8);\n          tartime = (time_t)getoct(buffer.header.mtime,12);\n          if (tarmode == -1 || tartime == (time_t)-1)\n            {\n              buffer.header.name[0] = 0;\n              action = TGZ_INVALID;\n            }\n\n          if (getheader == 1)\n            {\n              strncpy(fname,buffer.header.name,SHORTNAMESIZE);\n              if (fname[SHORTNAMESIZE-1] != 0)\n                  fname[SHORTNAMESIZE] = 0;\n            }\n          else\n            {\n              /*\n               * The file name is longer than SHORTNAMESIZE\n               */\n              if (strncmp(fname,buffer.header.name,SHORTNAMESIZE-1) != 0)\n                  error(\"bad long name\");\n              getheader = 1;\n            }\n\n          /*\n           * Act according to the type flag\n           */\n          switch (buffer.header.typeflag)\n            {\n            case DIRTYPE:\n              if (action == TGZ_LIST)\n                printf(\" %s     <dir> %s\\n\",strtime(&tartime),fname);\n              if (action == TGZ_EXTRACT)\n                {\n                  makedir(fname);\n                  push_attr(&attributes,fname,tarmode,tartime);\n                }\n              break;\n            case REGTYPE:\n            case AREGTYPE:\n              remaining = getoct(buffer.header.size,12);\n              if (remaining == -1)\n                {\n                  action = TGZ_INVALID;\n                  break;\n                }\n              if (action == TGZ_LIST)\n                printf(\" %s %9d %s\\n\",strtime(&tartime),remaining,fname);\n              else if (action == TGZ_EXTRACT)\n                {\n                  if (matchname(arg,argc,argv,fname))\n                    {\n                      outfile = fopen(fname,\"wb\");\n                      if (outfile == NULL) {\n                        /* try creating directory */\n                        char *p = strrchr(fname, '/');\n                        if (p != NULL) {\n                          *p = '\\0';\n                          makedir(fname);\n                          *p = '/';\n                          outfile = fopen(fname,\"wb\");\n                        }\n                      }\n                      if (outfile != NULL)\n                        printf(\"Extracting %s\\n\",fname);\n                      else\n                        fprintf(stderr, \"%s: Couldn't create %s\",prog,fname);\n                    }\n                  else\n                    outfile = NULL;\n                }\n              getheader = 0;\n              break;\n            case GNUTYPE_LONGLINK:\n            case GNUTYPE_LONGNAME:\n              remaining = getoct(buffer.header.size,12);\n              if (remaining < 0 || remaining >= BLOCKSIZE)\n                {\n                  action = TGZ_INVALID;\n                  break;\n                }\n              len = gzread(in, fname, BLOCKSIZE);\n              if (len < 0)\n                error(gzerror(in, &err));\n              if (fname[BLOCKSIZE-1] != 0 || (int)strlen(fname) > remaining)\n                {\n                  action = TGZ_INVALID;\n                  break;\n                }\n              getheader = 2;\n              break;\n            default:\n              if (action == TGZ_LIST)\n                printf(\" %s     <---> %s\\n\",strtime(&tartime),fname);\n              break;\n            }\n        }\n      else\n        {\n          unsigned int bytes = (remaining > BLOCKSIZE) ? BLOCKSIZE : remaining;\n\n          if (outfile != NULL)\n            {\n              if (fwrite(&buffer,sizeof(char),bytes,outfile) != bytes)\n                {\n                  fprintf(stderr,\n                    \"%s: Error writing %s -- skipping\\n\",prog,fname);\n                  fclose(outfile);\n                  outfile = NULL;\n                  remove(fname);\n                }\n            }\n          remaining -= bytes;\n        }\n\n      if (remaining == 0)\n        {\n          getheader = 1;\n          if (outfile != NULL)\n            {\n              fclose(outfile);\n              outfile = NULL;\n              if (action != TGZ_INVALID)\n                push_attr(&attributes,fname,tarmode,tartime);\n            }\n        }\n\n      /*\n       * Abandon if errors are found\n       */\n      if (action == TGZ_INVALID)\n        {\n          error(\"broken archive\");\n          break;\n        }\n    }\n\n  /*\n   * Restore file modes and time stamps\n   */\n  restore_attr(&attributes);\n\n  if (gzclose(in) != Z_OK)\n    error(\"failed gzclose\");\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              384,
              0
            ],
            [
              574,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tar",
            "parameters": {
              "in": "gzFile",
              "action": "int",
              "arg": "int",
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void help(int exitval)\n{\n  printf(\"untgz version 0.2.1\\n\"\n         \"  using zlib version %s\\n\\n\",\n         zlibVersion());\n  printf(\"Usage: untgz file.tgz            extract all files\\n\"\n         \"       untgz file.tgz fname ...  extract selected files\\n\"\n         \"       untgz -l file.tgz         list archive contents\\n\"\n         \"       untgz -h                  display this help\\n\");\n  exit(exitval);\n}",
          "fn_code_pos": [
            [
              579,
              0
            ],
            [
              589,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "help",
            "parameters": {
              "exitval": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc,char **argv)\n{\n    int         action = TGZ_EXTRACT;\n    int         arg = 1;\n    char        *TGZfile;\n    gzFile      f;\n\n    prog = strrchr(argv[0],'\\\\');\n    if (prog == NULL)\n      {\n        prog = strrchr(argv[0],'/');\n        if (prog == NULL)\n          {\n            prog = strrchr(argv[0],':');\n            if (prog == NULL)\n              prog = argv[0];\n            else\n              prog++;\n          }\n        else\n          prog++;\n      }\n    else\n      prog++;\n\n    if (argc == 1)\n      help(0);\n\n    if (strcmp(argv[arg],\"-l\") == 0)\n      {\n        action = TGZ_LIST;\n        if (argc == ++arg)\n          help(0);\n      }\n    else if (strcmp(argv[arg],\"-h\") == 0)\n      {\n        help(0);\n      }\n\n    if ((TGZfile = TGZfname(argv[arg])) == NULL)\n      TGZnotfound(argv[arg]);\n\n    ++arg;\n    if ((action == TGZ_LIST) && (arg != argc))\n      help(1);\n\n/*\n *  Process the TGZ file\n */\n    switch(action)\n      {\n      case TGZ_LIST:\n      case TGZ_EXTRACT:\n        f = gzopen(TGZfile,\"rb\");\n        if (f == NULL)\n          {\n            fprintf(stderr,\"%s: Couldn't gzopen %s\\n\",prog,TGZfile);\n            return 1;\n          }\n        exit(tar(f, action, arg, argc, argv));\n      break;\n\n      default:\n        error(\"Unknown option\");\n        exit(1);\n      }\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              598,
              0
            ],
            [
              666,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TGZfname (const char *arcname)",
          "fn_dec_pos": [
            [
              130,
              6
            ],
            [
              130,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TGZfname",
            "parameters": {
              "arcname": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "strtime (time_t *t)",
          "fn_dec_pos": [
            [
              189,
              6
            ],
            [
              189,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strtime",
            "parameters": {
              "t": "time_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct tar_header\n{                               /* byte offset */\n  char name[100];               /*   0 */\n  char mode[8];                 /* 100 */\n  char uid[8];                  /* 108 */\n  char gid[8];                  /* 116 */\n  char size[12];                /* 124 */\n  char mtime[12];               /* 136 */\n  char chksum[8];               /* 148 */\n  char typeflag;                /* 156 */\n  char linkname[100];           /* 157 */\n  char magic[6];                /* 257 */\n  char version[2];              /* 263 */\n  char uname[32];               /* 265 */\n  char gname[32];               /* 297 */\n  char devmajor[8];             /* 329 */\n  char devminor[8];             /* 337 */\n  char prefix[155];             /* 345 */\n                                /* 500 */\n}",
          {
            "name[100]": "char",
            "mode[8]": "char",
            "uid[8]": "char",
            "gid[8]": "char",
            "size[12]": "char",
            "mtime[12]": "char",
            "chksum[8]": "char",
            "typeflag": "char",
            "linkname[100]": "char",
            "magic[6]": "char",
            "version[2]": "char",
            "uname[32]": "char",
            "gname[32]": "char",
            "devmajor[8]": "char",
            "devminor[8]": "char",
            "prefix[155]": "char"
          },
          "tar_header",
          [
            80,
            0
          ],
          [
            99,
            1
          ]
        ],
        [
          "struct attr_item\n{\n  struct attr_item  *next;\n  char              *fname;\n  int                mode;\n  time_t             time;\n}",
          {
            "*next": "struct attr_item",
            "*fname": "char",
            "mode": "int",
            "time": "time_t"
          },
          "attr_item",
          [
            107,
            0
          ],
          [
            113,
            1
          ]
        ],
        [
          "struct tar_header\n{                               /* byte offset */\n  char name[100];               /*   0 */\n  char mode[8];                 /* 100 */\n  char uid[8];                  /* 108 */\n  char gid[8];                  /* 116 */\n  char size[12];                /* 124 */\n  char mtime[12];               /* 136 */\n  char chksum[8];               /* 148 */\n  char typeflag;                /* 156 */\n  char linkname[100];           /* 157 */\n  char magic[6];                /* 257 */\n  char version[2];              /* 263 */\n  char uname[32];               /* 265 */\n  char gname[32];               /* 297 */\n  char devmajor[8];             /* 329 */\n  char devminor[8];             /* 337 */\n  char prefix[155];             /* 345 */\n                                /* 500 */\n}",
          {
            "name[100]": "char",
            "mode[8]": "char",
            "uid[8]": "char",
            "gid[8]": "char",
            "size[12]": "char",
            "mtime[12]": "char",
            "chksum[8]": "char",
            "typeflag": "char",
            "linkname[100]": "char",
            "magic[6]": "char",
            "version[2]": "char",
            "uname[32]": "char",
            "gname[32]": "char",
            "devmajor[8]": "char",
            "devminor[8]": "char",
            "prefix[155]": "char"
          },
          "tar_header",
          [
            80,
            0
          ],
          [
            99,
            1
          ]
        ],
        [
          "struct tar_header",
          {},
          "",
          [
            104,
            2
          ],
          [
            104,
            19
          ]
        ],
        [
          "struct attr_item\n{\n  struct attr_item  *next;\n  char              *fname;\n  int                mode;\n  time_t             time;\n}",
          {
            "*next": "struct attr_item",
            "*fname": "char",
            "mode": "int",
            "time": "time_t"
          },
          "attr_item",
          [
            107,
            0
          ],
          [
            113,
            1
          ]
        ],
        [
          "struct attr_item",
          {},
          "",
          [
            109,
            2
          ],
          [
            109,
            18
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            191,
            2
          ],
          [
            191,
            11
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            210,
            2
          ],
          [
            210,
            11
          ]
        ],
        [
          "struct utimbuf",
          {},
          "",
          [
            241,
            2
          ],
          [
            241,
            16
          ]
        ],
        [
          "struct attr_item",
          {},
          "",
          [
            251,
            15
          ],
          [
            251,
            31
          ]
        ],
        [
          "struct attr_item",
          {},
          "",
          [
            253,
            2
          ],
          [
            253,
            18
          ]
        ],
        [
          "struct attr_item",
          {},
          "",
          [
            255,
            10
          ],
          [
            255,
            26
          ]
        ],
        [
          "struct attr_item",
          {},
          "",
          [
            255,
            43
          ],
          [
            255,
            59
          ]
        ],
        [
          "struct attr_item",
          {},
          "",
          [
            268,
            18
          ],
          [
            268,
            34
          ]
        ],
        [
          "struct attr_item",
          {},
          "",
          [
            270,
            2
          ],
          [
            270,
            18
          ]
        ],
        [
          "struct attr_item",
          {},
          "",
          [
            395,
            2
          ],
          [
            395,
            18
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <time.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#  include <direct.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <io.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <windows.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#  include <sys/stat.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#  include <unistd.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#  include <utime.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "enum { TGZ_EXTRACT, TGZ_LIST, TGZ_INVALID }",
          {
            "TGZ_EXTRACT": "",
            "TGZ_LIST": "",
            "TGZ_INVALID": ""
          },
          "",
          [
            115,
            0
          ],
          [
            115,
            43
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/infback9/infback9.c": {
      "fn_def_list": [
        {
          "fn_code": "int ZEXPORT inflateBack9Init_(z_stream FAR *strm, unsigned char FAR *window,\n                              const char *version, int stream_size) {\n    struct inflate_state FAR *state;\n\n    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||\n        stream_size != (int)(sizeof(z_stream)))\n        return Z_VERSION_ERROR;\n    if (strm == Z_NULL || window == Z_NULL)\n        return Z_STREAM_ERROR;\n    strm->msg = Z_NULL;                 /* in case we return an error */\n    if (strm->zalloc == (alloc_func)0) {\n        strm->zalloc = zcalloc;\n        strm->opaque = (voidpf)0;\n    }\n    if (strm->zfree == (free_func)0) strm->zfree = zcfree;\n    state = (struct inflate_state FAR *)ZALLOC(strm, 1,\n                                               sizeof(struct inflate_state));\n    if (state == Z_NULL) return Z_MEM_ERROR;\n    Tracev((stderr, \"inflate: allocated\\n\"));\n    strm->state = (voidpf)state;\n    state->window = window;\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              18,
              0
            ],
            [
              40,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateBack9Init_",
            "parameters": {
              "FAR": "unsigned char",
              "version": "char",
              "stream_size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void makefixed9(void) {\n    unsigned sym, bits, low, size;\n    code *next, *lenfix, *distfix;\n    struct inflate_state state;\n    code fixed[544];\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) state.lens[sym++] = 8;\n    while (sym < 256) state.lens[sym++] = 9;\n    while (sym < 280) state.lens[sym++] = 7;\n    while (sym < 288) state.lens[sym++] = 8;\n    next = fixed;\n    lenfix = next;\n    bits = 9;\n    inflate_table9(LENS, state.lens, 288, &(next), &(bits), state.work);\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) state.lens[sym++] = 5;\n    distfix = next;\n    bits = 5;\n    inflate_table9(DISTS, state.lens, 32, &(next), &(bits), state.work);\n\n    /* write tables */\n    puts(\"    /* inffix9.h -- table for decoding deflate64 fixed codes\");\n    puts(\"     * Generated automatically by makefixed9().\");\n    puts(\"     */\");\n    puts(\"\");\n    puts(\"    /* WARNING: this file should *not* be used by applications.\");\n    puts(\"       It is part of the implementation of this library and is\");\n    puts(\"       subject to change. Applications should only use zlib.h.\");\n    puts(\"     */\");\n    puts(\"\");\n    size = 1U << 9;\n    printf(\"    static const code lenfix[%u] = {\", size);\n    low = 0;\n    for (;;) {\n        if ((low % 6) == 0) printf(\"\\n        \");\n        printf(\"{%u,%u,%d}\", lenfix[low].op, lenfix[low].bits,\n               lenfix[low].val);\n        if (++low == size) break;\n        putchar(',');\n    }\n    puts(\"\\n    };\");\n    size = 1U << 5;\n    printf(\"\\n    static const code distfix[%u] = {\", size);\n    low = 0;\n    for (;;) {\n        if ((low % 5) == 0) printf(\"\\n        \");\n        printf(\"{%u,%u,%d}\", distfix[low].op, distfix[low].bits,\n               distfix[low].val);\n        if (++low == size) break;\n        putchar(',');\n    }\n    puts(\"\\n    };\");\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "makefixed9",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ZEXPORT inflateBack9(z_stream FAR *strm, in_func in, void FAR *in_desc,\n                         out_func out, void FAR *out_desc) {\n    struct inflate_state FAR *state;\n    z_const unsigned char FAR *next;    /* next input */\n    unsigned char FAR *put;     /* next output */\n    unsigned have;              /* available input */\n    unsigned long left;         /* available output */\n    inflate_mode mode;          /* current inflate mode */\n    int lastblock;              /* true if processing last block */\n    int wrap;                   /* true if the window has wrapped */\n    unsigned char FAR *window;  /* allocated sliding window, if needed */\n    unsigned long hold;         /* bit buffer */\n    unsigned bits;              /* bits in bit buffer */\n    unsigned extra;             /* extra bits needed */\n    unsigned long length;       /* literal or length of data to copy */\n    unsigned long offset;       /* distance back to copy string from */\n    unsigned long copy;         /* number of stored or match bytes to copy */\n    unsigned char FAR *from;    /* where to copy match bytes from */\n    code const FAR *lencode;    /* starting table for length/literal codes */\n    code const FAR *distcode;   /* starting table for distance codes */\n    unsigned lenbits;           /* index bits for lencode */\n    unsigned distbits;          /* index bits for distcode */\n    code here;                  /* current decoding table entry */\n    code last;                  /* parent table entry */\n    unsigned len;               /* length to copy for repeats, bits to drop */\n    int ret;                    /* return code */\n    static const unsigned short order[19] = /* permutation of code lengths */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n#include \"inffix9.h\"\n\n    /* Check that the strm exists and that the state was initialized */\n    if (strm == Z_NULL || strm->state == Z_NULL)\n        return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n\n    /* Reset the state */\n    strm->msg = Z_NULL;\n    mode = TYPE;\n    lastblock = 0;\n    wrap = 0;\n    window = state->window;\n    next = strm->next_in;\n    have = next != Z_NULL ? strm->avail_in : 0;\n    hold = 0;\n    bits = 0;\n    put = window;\n    left = WSIZE;\n    lencode = Z_NULL;\n    distcode = Z_NULL;\n\n    /* Inflate until end of block marked as last */\n    for (;;)\n        switch (mode) {\n        case TYPE:\n            /* determine and dispatch block type */\n            if (lastblock) {\n                BYTEBITS();\n                mode = DONE;\n                break;\n            }\n            NEEDBITS(3);\n            lastblock = BITS(1);\n            DROPBITS(1);\n            switch (BITS(2)) {\n            case 0:                             /* stored block */\n                Tracev((stderr, \"inflate:     stored block%s\\n\",\n                        lastblock ? \" (last)\" : \"\"));\n                mode = STORED;\n                break;\n            case 1:                             /* fixed block */\n                lencode = lenfix;\n                lenbits = 9;\n                distcode = distfix;\n                distbits = 5;\n                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                        lastblock ? \" (last)\" : \"\"));\n                mode = LEN;                     /* decode codes */\n                break;\n            case 2:                             /* dynamic block */\n                Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                        lastblock ? \" (last)\" : \"\"));\n                mode = TABLE;\n                break;\n            case 3:\n                strm->msg = (z_const char *)\"invalid block type\";\n                mode = BAD;\n            }\n            DROPBITS(2);\n            break;\n\n        case STORED:\n            /* get and verify stored block length */\n            BYTEBITS();                         /* go to byte boundary */\n            NEEDBITS(32);\n            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                strm->msg = (z_const char *)\"invalid stored block lengths\";\n                mode = BAD;\n                break;\n            }\n            length = (unsigned)hold & 0xffff;\n            Tracev((stderr, \"inflate:       stored length %lu\\n\",\n                    length));\n            INITBITS();\n\n            /* copy stored block from input to output */\n            while (length != 0) {\n                copy = length;\n                PULL();\n                ROOM();\n                if (copy > have) copy = have;\n                if (copy > left) copy = left;\n                zmemcpy(put, next, copy);\n                have -= copy;\n                next += copy;\n                left -= copy;\n                put += copy;\n                length -= copy;\n            }\n            Tracev((stderr, \"inflate:       stored end\\n\"));\n            mode = TYPE;\n            break;\n\n        case TABLE:\n            /* get dynamic table entries descriptor */\n            NEEDBITS(14);\n            state->nlen = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5) + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n            DROPBITS(4);\n            if (state->nlen > 286) {\n                strm->msg = (z_const char *)\"too many length symbols\";\n                mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n\n            /* get code length code lengths (not a typo) */\n            state->have = 0;\n            while (state->have < state->ncode) {\n                NEEDBITS(3);\n                state->lens[order[state->have++]] = (unsigned short)BITS(3);\n                DROPBITS(3);\n            }\n            while (state->have < 19)\n                state->lens[order[state->have++]] = 0;\n            state->next = state->codes;\n            lencode = (code const FAR *)(state->next);\n            lenbits = 7;\n            ret = inflate_table9(CODES, state->lens, 19, &(state->next),\n                                &(lenbits), state->work);\n            if (ret) {\n                strm->msg = (z_const char *)\"invalid code lengths set\";\n                mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n\n            /* get length and distance code code lengths */\n            state->have = 0;\n            while (state->have < state->nlen + state->ndist) {\n                for (;;) {\n                    here = lencode[BITS(lenbits)];\n                    if ((unsigned)(here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                if (here.val < 16) {\n                    NEEDBITS(here.bits);\n                    DROPBITS(here.bits);\n                    state->lens[state->have++] = here.val;\n                }\n                else {\n                    if (here.val == 16) {\n                        NEEDBITS(here.bits + 2);\n                        DROPBITS(here.bits);\n                        if (state->have == 0) {\n                            strm->msg = (z_const char *)\"invalid bit length repeat\";\n                            mode = BAD;\n                            break;\n                        }\n                        len = (unsigned)(state->lens[state->have - 1]);\n                        copy = 3 + BITS(2);\n                        DROPBITS(2);\n                    }\n                    else if (here.val == 17) {\n                        NEEDBITS(here.bits + 3);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 3 + BITS(3);\n                        DROPBITS(3);\n                    }\n                    else {\n                        NEEDBITS(here.bits + 7);\n                        DROPBITS(here.bits);\n                        len = 0;\n                        copy = 11 + BITS(7);\n                        DROPBITS(7);\n                    }\n                    if (state->have + copy > state->nlen + state->ndist) {\n                        strm->msg = (z_const char *)\"invalid bit length repeat\";\n                        mode = BAD;\n                        break;\n                    }\n                    while (copy--)\n                        state->lens[state->have++] = (unsigned short)len;\n                }\n            }\n\n            /* handle error breaks in while */\n            if (mode == BAD) break;\n\n            /* check for end-of-block code (better have one) */\n            if (state->lens[256] == 0) {\n                strm->msg = (z_const char *)\"invalid code -- missing end-of-block\";\n                mode = BAD;\n                break;\n            }\n\n            /* build code tables -- note: do not change the lenbits or distbits\n               values here (9 and 6) without reading the comments in inftree9.h\n               concerning the ENOUGH constants, which depend on those values */\n            state->next = state->codes;\n            lencode = (code const FAR *)(state->next);\n            lenbits = 9;\n            ret = inflate_table9(LENS, state->lens, state->nlen,\n                            &(state->next), &(lenbits), state->work);\n            if (ret) {\n                strm->msg = (z_const char *)\"invalid literal/lengths set\";\n                mode = BAD;\n                break;\n            }\n            distcode = (code const FAR *)(state->next);\n            distbits = 6;\n            ret = inflate_table9(DISTS, state->lens + state->nlen,\n                            state->ndist, &(state->next), &(distbits),\n                            state->work);\n            if (ret) {\n                strm->msg = (z_const char *)\"invalid distances set\";\n                mode = BAD;\n                break;\n            }\n            Tracev((stderr, \"inflate:       codes ok\\n\"));\n            mode = LEN;\n\n        case LEN:\n            /* get a literal, length, or end-of-block code */\n            for (;;) {\n                here = lencode[BITS(lenbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if (here.op && (here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = lencode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n            }\n            DROPBITS(here.bits);\n            length = (unsigned)here.val;\n\n            /* process literal */\n            if (here.op == 0) {\n                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                        \"inflate:         literal '%c'\\n\" :\n                        \"inflate:         literal 0x%02x\\n\", here.val));\n                ROOM();\n                *put++ = (unsigned char)(length);\n                left--;\n                mode = LEN;\n                break;\n            }\n\n            /* process end of block */\n            if (here.op & 32) {\n                Tracevv((stderr, \"inflate:         end of block\\n\"));\n                mode = TYPE;\n                break;\n            }\n\n            /* invalid code */\n            if (here.op & 64) {\n                strm->msg = (z_const char *)\"invalid literal/length code\";\n                mode = BAD;\n                break;\n            }\n\n            /* length code -- get extra bits, if any */\n            extra = (unsigned)(here.op) & 31;\n            if (extra != 0) {\n                NEEDBITS(extra);\n                length += BITS(extra);\n                DROPBITS(extra);\n            }\n            Tracevv((stderr, \"inflate:         length %lu\\n\", length));\n\n            /* get distance code */\n            for (;;) {\n                here = distcode[BITS(distbits)];\n                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n            }\n            if ((here.op & 0xf0) == 0) {\n                last = here;\n                for (;;) {\n                    here = distcode[last.val +\n                            (BITS(last.bits + last.op) >> last.bits)];\n                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n                    PULLBYTE();\n                }\n                DROPBITS(last.bits);\n            }\n            DROPBITS(here.bits);\n            if (here.op & 64) {\n                strm->msg = (z_const char *)\"invalid distance code\";\n                mode = BAD;\n                break;\n            }\n            offset = (unsigned)here.val;\n\n            /* get distance extra bits, if any */\n            extra = (unsigned)(here.op) & 15;\n            if (extra != 0) {\n                NEEDBITS(extra);\n                offset += BITS(extra);\n                DROPBITS(extra);\n            }\n            if (offset > WSIZE - (wrap ? 0: left)) {\n                strm->msg = (z_const char *)\"invalid distance too far back\";\n                mode = BAD;\n                break;\n            }\n            Tracevv((stderr, \"inflate:         distance %lu\\n\", offset));\n\n            /* copy match from window to output */\n            do {\n                ROOM();\n                copy = WSIZE - offset;\n                if (copy < left) {\n                    from = put + copy;\n                    copy = left - copy;\n                }\n                else {\n                    from = put - offset;\n                    copy = left;\n                }\n                if (copy > length) copy = length;\n                length -= copy;\n                left -= copy;\n                do {\n                    *put++ = *from++;\n                } while (--copy);\n            } while (length != 0);\n            break;\n\n        case DONE:\n            /* inflate stream terminated properly -- write leftover output */\n            ret = Z_STREAM_END;\n            if (left < WSIZE) {\n                if (out(out_desc, window, (unsigned)(WSIZE - left)))\n                    ret = Z_BUF_ERROR;\n            }\n            goto inf_leave;\n\n        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n\n        default:                /* can't happen, but makes compilers happy */\n            ret = Z_STREAM_ERROR;\n            goto inf_leave;\n        }\n\n    /* Return unused input */\n  inf_leave:\n    strm->next_in = next;\n    strm->avail_in = have;\n    return ret;\n}",
          "fn_code_pos": [
            [
              211,
              0
            ],
            [
              593,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateBack9",
            "parameters": {
              "FAR": "void",
              "in": "in_func",
              "out": "out_func"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int ZEXPORT inflateBack9End(z_stream FAR *strm) {\n    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)\n        return Z_STREAM_ERROR;\n    ZFREE(strm, strm->state);\n    strm->state = Z_NULL;\n    Tracev((stderr, \"inflate: end\\n\"));\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              595,
              0
            ],
            [
              602,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateBack9End",
            "parameters": {
              "FAR": "z_stream"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct inflate_state",
          {},
          "",
          [
            20,
            4
          ],
          [
            20,
            24
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            33,
            13
          ],
          [
            33,
            33
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            34,
            54
          ],
          [
            34,
            74
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            52,
            4
          ],
          [
            52,
            24
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            213,
            4
          ],
          [
            213,
            24
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            244,
            13
          ],
          [
            244,
            33
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"zutil.h\"\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ],
        [
          "#include \"infback9.h\"\n",
          [
            6,
            0
          ],
          [
            7,
            0
          ]
        ],
        [
          "#include \"inftree9.h\"\n",
          [
            7,
            0
          ],
          [
            8,
            0
          ]
        ],
        [
          "#include \"inflate9.h\"\n",
          [
            8,
            0
          ],
          [
            9,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"inffix9.h\"\n",
          [
            239,
            0
          ],
          [
            240,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/infback9/inftree9.c": {
      "fn_def_list": [
        {
          "fn_code": "int inflate_table9(codetype type, unsigned short FAR *lens, unsigned codes,\n                   code FAR * FAR *table, unsigned FAR *bits,\n                   unsigned short FAR *work) {\n    unsigned len;               /* a code's length in bits */\n    unsigned sym;               /* index of code symbols */\n    unsigned min, max;          /* minimum and maximum code lengths */\n    unsigned root;              /* number of index bits for root table */\n    unsigned curr;              /* number of index bits for current table */\n    unsigned drop;              /* code bits to drop for sub-table */\n    int left;                   /* number of prefix codes available */\n    unsigned used;              /* code entries in table used */\n    unsigned huff;              /* Huffman code */\n    unsigned incr;              /* for incrementing code, index */\n    unsigned fill;              /* index for replicating entries */\n    unsigned low;               /* low bits for current root entry */\n    unsigned mask;              /* mask for low root bits */\n    code this;                  /* table entry for duplication */\n    code FAR *next;             /* next available space in table */\n    const unsigned short FAR *base;     /* base value table to use */\n    const unsigned short FAR *extra;    /* extra bits table to use */\n    int end;                    /* use base and extra for symbol > end */\n    unsigned short count[MAXBITS+1];    /* number of codes of each length */\n    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */\n    static const unsigned short lbase[31] = { /* Length codes 257..285 base */\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17,\n        19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115,\n        131, 163, 195, 227, 3, 0, 0};\n    static const unsigned short lext[31] = { /* Length codes 257..285 extra */\n        128, 128, 128, 128, 128, 128, 128, 128, 129, 129, 129, 129,\n        130, 130, 130, 130, 131, 131, 131, 131, 132, 132, 132, 132,\n        133, 133, 133, 133, 144, 73, 200};\n    static const unsigned short dbase[32] = { /* Distance codes 0..31 base */\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49,\n        65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073,\n        4097, 6145, 8193, 12289, 16385, 24577, 32769, 49153};\n    static const unsigned short dext[32] = { /* Distance codes 0..31 extra */\n        128, 128, 128, 128, 129, 129, 130, 130, 131, 131, 132, 132,\n        133, 133, 134, 134, 135, 135, 136, 136, 137, 137, 138, 138,\n        139, 139, 140, 140, 141, 141, 142, 142};\n\n    /*\n       Process a set of code lengths to create a canonical Huffman code.  The\n       code lengths are lens[0..codes-1].  Each length corresponds to the\n       symbols 0..codes-1.  The Huffman code is generated by first sorting the\n       symbols by length from short to long, and retaining the symbol order\n       for codes with equal lengths.  Then the code starts with all zero bits\n       for the first code of the shortest length, and the codes are integer\n       increments for the same length, and zeros are appended as the length\n       increases.  For the deflate format, these bits are stored backwards\n       from their more natural integer increment ordering, and so when the\n       decoding tables are built in the large loop below, the integer codes\n       are incremented backwards.\n\n       This routine assumes, but does not check, that all of the entries in\n       lens[] are in the range 0..MAXBITS.  The caller must assure this.\n       1..MAXBITS is interpreted as that code length.  zero means that that\n       symbol does not occur in this code.\n\n       The codes are sorted by computing a count of codes for each length,\n       creating from that a table of starting indices for each length in the\n       sorted table, and then entering the symbols in order in the sorted\n       table.  The sorted table is work[], with that space being provided by\n       the caller.\n\n       The length counts are used for other purposes as well, i.e. finding\n       the minimum and maximum length codes, determining if there are any\n       codes at all, checking for a valid set of lengths, and looking ahead\n       at length counts to determine sub-table sizes when building the\n       decoding tables.\n     */\n\n    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n    for (len = 0; len <= MAXBITS; len++)\n        count[len] = 0;\n    for (sym = 0; sym < codes; sym++)\n        count[lens[sym]]++;\n\n    /* bound code lengths, force root to be within code lengths */\n    root = *bits;\n    for (max = MAXBITS; max >= 1; max--)\n        if (count[max] != 0) break;\n    if (root > max) root = max;\n    if (max == 0) return -1;            /* no codes! */\n    for (min = 1; min <= MAXBITS; min++)\n        if (count[min] != 0) break;\n    if (root < min) root = min;\n\n    /* check for an over-subscribed or incomplete set of lengths */\n    left = 1;\n    for (len = 1; len <= MAXBITS; len++) {\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) return -1;        /* over-subscribed */\n    }\n    if (left > 0 && (type == CODES || max != 1))\n        return -1;                      /* incomplete set */\n\n    /* generate offsets into symbol table for each length for sorting */\n    offs[1] = 0;\n    for (len = 1; len < MAXBITS; len++)\n        offs[len + 1] = offs[len] + count[len];\n\n    /* sort symbols by length, by symbol order within each length */\n    for (sym = 0; sym < codes; sym++)\n        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;\n\n    /*\n       Create and fill in decoding tables.  In this loop, the table being\n       filled is at next and has curr index bits.  The code being used is huff\n       with length len.  That code is converted to an index by dropping drop\n       bits off of the bottom.  For codes where len is less than drop + curr,\n       those top drop + curr - len bits are incremented through all values to\n       fill the table with replicated entries.\n\n       root is the number of index bits for the root table.  When len exceeds\n       root, sub-tables are created pointed to by the root entry with an index\n       of the low root bits of huff.  This is saved in low to check for when a\n       new sub-table should be started.  drop is zero when the root table is\n       being filled, and drop is root when sub-tables are being filled.\n\n       When a new sub-table is needed, it is necessary to look ahead in the\n       code lengths to determine what size sub-table is needed.  The length\n       counts are used for this, and so count[] is decremented as codes are\n       entered in the tables.\n\n       used keeps track of how many table entries have been allocated from the\n       provided *table space.  It is checked for LENS and DIST tables against\n       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n       the initial root table size constants.  See the comments in inftree9.h\n       for more information.\n\n       sym increments through all symbols, and the loop terminates when\n       all codes of length max, i.e. all codes, have been processed.  This\n       routine permits incomplete codes, so another loop after this one fills\n       in the rest of the decoding tables with invalid code markers.\n     */\n\n    /* set up for code type */\n    switch (type) {\n    case CODES:\n        base = extra = work;    /* dummy value--not used */\n        end = 19;\n        break;\n    case LENS:\n        base = lbase;\n        base -= 257;\n        extra = lext;\n        extra -= 257;\n        end = 256;\n        break;\n    default:            /* DISTS */\n        base = dbase;\n        extra = dext;\n        end = -1;\n    }\n\n    /* initialize state for loop */\n    huff = 0;                   /* starting code */\n    sym = 0;                    /* starting code symbol */\n    len = min;                  /* starting code length */\n    next = *table;              /* current table to fill in */\n    curr = root;                /* current table index bits */\n    drop = 0;                   /* current bits to drop from code for index */\n    low = (unsigned)(-1);       /* trigger new sub-table when len > root */\n    used = 1U << root;          /* use root table entries */\n    mask = used - 1;            /* mask for comparing low */\n\n    /* check available table space */\n    if ((type == LENS && used >= ENOUGH_LENS) ||\n        (type == DISTS && used >= ENOUGH_DISTS))\n        return 1;\n\n    /* process all codes and make table entries */\n    for (;;) {\n        /* create table entry */\n        this.bits = (unsigned char)(len - drop);\n        if ((int)(work[sym]) < end) {\n            this.op = (unsigned char)0;\n            this.val = work[sym];\n        }\n        else if ((int)(work[sym]) > end) {\n            this.op = (unsigned char)(extra[work[sym]]);\n            this.val = base[work[sym]];\n        }\n        else {\n            this.op = (unsigned char)(32 + 64);         /* end of block */\n            this.val = 0;\n        }\n\n        /* replicate for those indices with low len bits equal to huff */\n        incr = 1U << (len - drop);\n        fill = 1U << curr;\n        do {\n            fill -= incr;\n            next[(huff >> drop) + fill] = this;\n        } while (fill != 0);\n\n        /* backwards increment the len-bit code huff */\n        incr = 1U << (len - 1);\n        while (huff & incr)\n            incr >>= 1;\n        if (incr != 0) {\n            huff &= incr - 1;\n            huff += incr;\n        }\n        else\n            huff = 0;\n\n        /* go to next symbol, update count, len */\n        sym++;\n        if (--(count[len]) == 0) {\n            if (len == max) break;\n            len = lens[work[sym]];\n        }\n\n        /* create new sub-table if needed */\n        if (len > root && (huff & mask) != low) {\n            /* if first time, transition to sub-tables */\n            if (drop == 0)\n                drop = root;\n\n            /* increment past last table */\n            next += 1U << curr;\n\n            /* determine length of next table */\n            curr = len - drop;\n            left = (int)(1 << curr);\n            while (curr + drop < max) {\n                left -= count[curr + drop];\n                if (left <= 0) break;\n                curr++;\n                left <<= 1;\n            }\n\n            /* check for enough space */\n            used += 1U << curr;\n            if ((type == LENS && used >= ENOUGH_LENS) ||\n                (type == DISTS && used >= ENOUGH_DISTS))\n                return 1;\n\n            /* point entry in root table to sub-table */\n            low = huff & mask;\n            (*table)[low].op = (unsigned char)curr;\n            (*table)[low].bits = (unsigned char)root;\n            (*table)[low].val = (unsigned short)(next - *table);\n        }\n    }\n\n    /*\n       Fill in rest of table for incomplete codes.  This loop is similar to the\n       loop above in incrementing huff for table indices.  It is assumed that\n       len is equal to curr + drop, so there is no loop needed to increment\n       through high index bits.  When the current sub-table is filled, the loop\n       drops back to the root table to fill in any remaining entries there.\n     */\n    this.op = (unsigned char)64;                /* invalid code marker */\n    this.bits = (unsigned char)(len - drop);\n    this.val = (unsigned short)0;\n    while (huff != 0) {\n        /* when done with sub-table, drop back to root table */\n        if (drop != 0 && (huff & mask) != low) {\n            drop = 0;\n            len = root;\n            next = *table;\n            curr = root;\n            this.bits = (unsigned char)len;\n        }\n\n        /* put invalid code marker in table */\n        next[huff >> drop] = this;\n\n        /* backwards increment the len-bit code huff */\n        incr = 1U << (len - 1);\n        while (huff & incr)\n            incr >>= 1;\n        if (incr != 0) {\n            huff &= incr - 1;\n            huff += incr;\n        }\n        else\n            huff = 0;\n    }\n\n    /* set return parameters */\n    *table += used;\n    *bits = root;\n    return 0;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              318,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflate_table9",
            "parameters": {
              "type": "codetype",
              "lens": "unsigned short FAR",
              "codes": "unsigned",
              "FAR": "code",
              "bits": "unsigned FAR",
              "work": "unsigned short FAR"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"zutil.h\"\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ],
        [
          "#include \"inftree9.h\"\n",
          [
            6,
            0
          ],
          [
            7,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/examples/zran.c": {
      "fn_def_list": [
        {
          "fn_code": "void deflate_index_free(struct deflate_index *index) {\n    if (index != NULL) {\n        size_t i = index->have;\n        while (i)\n            free(index->list[--i].window);\n        free(index->list);\n        inflateEnd(&index->strm);\n        free(index);\n    }\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              80,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflate_index_free",
            "parameters": {
              "index": "struct deflate_index"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static struct deflate_index *add_point(struct deflate_index *index, off_t in,\n                                       off_t out, off_t beg,\n                                       unsigned char *window) {\n    if (index->have == index->mode) {\n        // The list is full. Make it bigger.\n        index->mode = index->mode ? index->mode << 1 : 8;\n        point_t *next = realloc(index->list, sizeof(point_t) * index->mode);\n        if (next == NULL) {\n            deflate_index_free(index);\n            return NULL;\n        }\n        index->list = next;\n    }\n\n    // Fill in the access point and increment how many we have.\n    point_t *next = (point_t *)(index->list) + index->have++;\n    if (index->have < 0) {\n        // Overflowed the int!\n        deflate_index_free(index);\n        return NULL;\n    }\n    next->out = out;\n    next->in = in;\n    next->bits = index->strm.data_type & 7;\n    next->dict = out - beg > WINSIZE ? WINSIZE : (unsigned)(out - beg);\n    next->window = malloc(next->dict);\n    if (next->window == NULL) {\n        deflate_index_free(index);\n        return NULL;\n    }\n    unsigned recent = WINSIZE - index->strm.avail_out;\n    unsigned copy = recent > next->dict ? next->dict : recent;\n    memcpy(next->window + next->dict - copy, window + recent - copy, copy);\n    copy = next->dict - copy;\n    memcpy(next->window, window + WINSIZE - copy, copy);\n\n    // Return the index, which may have been newly allocated or destroyed.\n    return index;\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_point",
            "parameters": {
              "index": "struct deflate_index",
              "in": "off_t",
              "out": "off_t",
              "beg": "off_t",
              "window": "unsigned char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "int deflate_index_build(FILE *in, off_t span, struct deflate_index **built) {\n    // If this returns with an error, any attempt to use the index will cleanly\n    // return an error.\n    *built = NULL;\n\n    // Create and initialize the index list.\n    struct deflate_index *index = malloc(sizeof(struct deflate_index));\n    if (index == NULL)\n        return Z_MEM_ERROR;\n    index->have = 0;\n    index->mode = 0;            // entries in index->list allocation\n    index->list = NULL;\n    index->strm.state = Z_NULL; // so inflateEnd() can work\n\n    // Set up the inflation state.\n    index->strm.avail_in = 0;\n    index->strm.avail_out = 0;\n    unsigned char buf[CHUNK];   // input buffer\n    unsigned char win[WINSIZE] = {0};   // output sliding window\n    off_t totin = 0;            // total bytes read from input\n    off_t totout = 0;           // total bytes uncompressed\n    off_t beg = 0;              // starting offset of last history reset\n    int mode = 0;               // mode: RAW, ZLIB, or GZIP (0 => not set yet)\n\n    // Decompress from in, generating access points along the way.\n    int ret;                    // the return value from zlib, or Z_ERRNO\n    off_t last;                 // last access point uncompressed offset\n    do {\n        // Assure available input, at least until reaching EOF.\n        if (index->strm.avail_in == 0) {\n            index->strm.avail_in = fread(buf, 1, sizeof(buf), in);\n            totin += index->strm.avail_in;\n            index->strm.next_in = buf;\n            if (index->strm.avail_in < sizeof(buf) && ferror(in)) {\n                ret = Z_ERRNO;\n                break;\n            }\n\n            if (mode == 0) {\n                // At the start of the input -- determine the type. Assume raw\n                // if it is neither zlib nor gzip. This could in theory result\n                // in a false positive for zlib, but in practice the fill bits\n                // after a stored block are always zeros, so a raw stream won't\n                // start with an 8 in the low nybble.\n                mode = index->strm.avail_in == 0 ? RAW :    // will fail\n                       (index->strm.next_in[0] & 0xf) == 8 ? ZLIB :\n                       index->strm.next_in[0] == 0x1f ? GZIP :\n                       /* else */ RAW;\n                index->strm.zalloc = Z_NULL;\n                index->strm.zfree = Z_NULL;\n                index->strm.opaque = Z_NULL;\n                ret = inflateInit2(&index->strm, mode);\n                if (ret != Z_OK)\n                    break;\n            }\n        }\n\n        // Assure available output. This rotates the output through, for use as\n        // a sliding window on the uncompressed data.\n        if (index->strm.avail_out == 0) {\n            index->strm.avail_out = sizeof(win);\n            index->strm.next_out = win;\n        }\n\n        if (mode == RAW && index->have == 0)\n            // We skip the inflate() call at the start of raw deflate data in\n            // order generate an access point there. Set data_type to imitate\n            // the end of a header.\n            index->strm.data_type = 0x80;\n        else {\n            // Inflate and update the number of uncompressed bytes.\n            unsigned before = index->strm.avail_out;\n            ret = inflate(&index->strm, Z_BLOCK);\n            totout += before - index->strm.avail_out;\n        }\n\n        if ((index->strm.data_type & 0xc0) == 0x80 &&\n            (index->have == 0 || totout - last >= span)) {\n            // We are at the end of a header or a non-last deflate block, so we\n            // can add an access point here. Furthermore, we are either at the\n            // very start for the first access point, or there has been span or\n            // more uncompressed bytes since the last access point, so we want\n            // to add an access point here.\n            index = add_point(index, totin - index->strm.avail_in, totout, beg,\n                              win);\n            if (index == NULL) {\n                ret = Z_MEM_ERROR;\n                break;\n            }\n            last = totout;\n        }\n\n        if (ret == Z_STREAM_END && mode == GZIP &&\n            (index->strm.avail_in || ungetc(getc(in), in) != EOF)) {\n            // There is more input after the end of a gzip member. Reset the\n            // inflate state to read another gzip member. On success, this will\n            // set ret to Z_OK to continue decompressing.\n            ret = inflateReset2(&index->strm, GZIP);\n            beg = totout;           // reset history\n        }\n\n        // Keep going until Z_STREAM_END or error. If the compressed data ends\n        // prematurely without a file read error, Z_BUF_ERROR is returned.\n    } while (ret == Z_OK);\n\n    if (ret != Z_STREAM_END) {\n        // An error was encountered. Discard the index and return a negative\n        // error code.\n        deflate_index_free(index);\n        return ret == Z_NEED_DICT ? Z_DATA_ERROR : ret;\n    }\n\n    // Return the index.\n    index->mode = mode;\n    index->length = totout;\n    *built = index;\n    return index->have;\n}",
          "fn_code_pos": [
            [
              132,
              0
            ],
            [
              249,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflate_index_build",
            "parameters": {
              "in": "FILE",
              "span": "off_t",
              "built": "struct deflate_index"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static inline void append_bits(unsigned value, int bits,\n                               unsigned char *in, int *have) {\n    in += *have >> 3;           // where the first bits from value will go\n    int k = *have & 7;          // the number of bits already there\n    *have += bits;\n    if (k)\n        *in |= value << k;      // write value above the low k bits\n    else\n        *in = value;\n    k = 8 - k;                  // the number of bits just appended\n    while (bits > k) {\n        value >>= k;            // drop the bits appended\n        bits -= k;\n        k = 8;                  // now at a byte boundary\n        *++in = value;\n    }\n}",
          "fn_code_pos": [
            [
              262,
              0
            ],
            [
              278,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "append_bits",
            "parameters": {
              "value": "unsigned",
              "bits": "int",
              "in": "unsigned char",
              "have": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int inflatePreface(z_stream *strm, int bits, int value) {\n    // Check input.\n    if (strm == Z_NULL || bits < 0 || bits > 16)\n        return Z_STREAM_ERROR;\n    if (bits == 0)\n        return Z_OK;\n    value &= (2 << (bits - 1)) - 1;\n\n    // An empty dynamic block with an odd number of bits (95). The high bit of\n    // the last byte is unused.\n    static const unsigned char dyn[] = {\n        4, 0xe0, 0x81, 8, 0, 0, 0, 0, 0x20, 0xa8, 0xab, 0x1f\n    };\n    const int dynlen = 95;          // number of bits in the block\n\n    // Build an input buffer for inflate that is a multiple of eight bits in\n    // length, and that ends with the low bits bits of value.\n    unsigned char in[(dynlen + 3 * 10 + 16 + 7) / 8];\n    int have = 0;\n    if (bits & 1) {\n        // Insert an empty dynamic block to get to an odd number of bits, so\n        // when bits bits from value are appended, we are at an even number of\n        // bits.\n        memcpy(in, dyn, sizeof(dyn));\n        have = dynlen;\n    }\n    while ((have + bits) & 7)\n        // Insert empty fixed blocks until appending bits bits would put us on\n        // a byte boundary. This will insert at most three fixed blocks.\n        append_bits(2, 10, in, &have);\n\n    // Append the bits bits from value, which takes us to a byte boundary.\n    append_bits(value, bits, in, &have);\n\n    // Deliver the input to inflate(). There is no output space provided, but\n    // inflate() can't get stuck waiting on output not ingesting all of the\n    // provided input. The reason is that there will be at most 16 bits of\n    // input from value after the empty deflate blocks (which themselves\n    // generate no output). At least ten bits are needed to generate the first\n    // output byte from a fixed block. The last two bytes of the buffer have to\n    // be ingested in order to get ten bits, which is the most that value can\n    // occupy.\n    strm->avail_in = have >> 3;\n    strm->next_in = in;\n    strm->avail_out = 0;\n    strm->next_out = in;                // not used, but can't be NULL\n    return inflate(strm, Z_NO_FLUSH);\n}",
          "fn_code_pos": [
            [
              286,
              0
            ],
            [
              333,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflatePreface",
            "parameters": {
              "strm": "z_stream",
              "bits": "int",
              "value": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ptrdiff_t deflate_index_extract(FILE *in, struct deflate_index *index,\n                                off_t offset, unsigned char *buf, size_t len) {\n    // Do a quick sanity check on the index.\n    if (index == NULL || index->have < 1 || index->list[0].out != 0 ||\n        index->strm.state == Z_NULL)\n        return Z_STREAM_ERROR;\n\n    // If nothing to extract, return zero bytes extracted.\n    if (len == 0 || offset < 0 || offset >= index->length)\n        return 0;\n\n    // Find the access point closest to but not after offset.\n    int lo = -1, hi = index->have;\n    point_t *point = index->list;\n    while (hi - lo > 1) {\n        int mid = (lo + hi) >> 1;\n        if (offset < point[mid].out)\n            hi = mid;\n        else\n            lo = mid;\n    }\n    point += lo;\n\n    // Initialize the input file and prime the inflate engine to start there.\n    int ret = fseeko(in, point->in - (point->bits ? 1 : 0), SEEK_SET);\n    if (ret == -1)\n        return Z_ERRNO;\n    int ch = 0;\n    if (point->bits && (ch = getc(in)) == EOF)\n        return ferror(in) ? Z_ERRNO : Z_BUF_ERROR;\n    index->strm.avail_in = 0;\n    ret = inflateReset2(&index->strm, RAW);\n    if (ret != Z_OK)\n        return ret;\n    if (point->bits)\n        INFLATEPRIME(&index->strm, point->bits, ch >> (8 - point->bits));\n    inflateSetDictionary(&index->strm, point->window, point->dict);\n\n    // Skip uncompressed bytes until offset reached, then satisfy request.\n    unsigned char input[CHUNK];\n    unsigned char discard[WINSIZE];\n    offset -= point->out;       // number of bytes to skip to get to offset\n    size_t left = len;          // number of bytes left to read after offset\n    do {\n        if (offset) {\n            // Discard up to offset uncompressed bytes.\n            index->strm.avail_out = offset < WINSIZE ? (unsigned)offset :\n                                                       WINSIZE;\n            index->strm.next_out = discard;\n        }\n        else {\n            // Uncompress up to left bytes into buf.\n            index->strm.avail_out = left < (unsigned)-1 ? (unsigned)left :\n                                                          (unsigned)-1;\n            index->strm.next_out = buf + len - left;\n        }\n\n        // Uncompress, setting got to the number of bytes uncompressed.\n        if (index->strm.avail_in == 0) {\n            // Assure available input.\n            index->strm.avail_in = fread(input, 1, CHUNK, in);\n            if (index->strm.avail_in < CHUNK && ferror(in)) {\n                ret = Z_ERRNO;\n                break;\n            }\n            index->strm.next_in = input;\n        }\n        unsigned got = index->strm.avail_out;\n        ret = inflate(&index->strm, Z_NO_FLUSH);\n        got -= index->strm.avail_out;\n\n        // Update the appropriate count.\n        if (offset)\n            offset -= got;\n        else {\n            left -= got;\n            if (left == 0)\n                // Request satisfied.\n                break;\n        }\n\n        // If we're at the end of a gzip member and there's more to read,\n        // continue to the next gzip member.\n        if (ret == Z_STREAM_END && index->mode == GZIP) {\n            // Discard the gzip trailer.\n            unsigned drop = 8;              // length of gzip trailer\n            if (index->strm.avail_in >= drop) {\n                index->strm.avail_in -= drop;\n                index->strm.next_in += drop;\n            }\n            else {\n                // Read and discard the remainder of the gzip trailer.\n                drop -= index->strm.avail_in;\n                index->strm.avail_in = 0;\n                do {\n                    if (getc(in) == EOF)\n                        // The input does not have a complete trailer.\n                        return ferror(in) ? Z_ERRNO : Z_BUF_ERROR;\n                } while (--drop);\n            }\n\n            if (index->strm.avail_in || ungetc(getc(in), in) != EOF) {\n                // There's more after the gzip trailer. Use inflate to skip the\n                // gzip header and resume the raw inflate there.\n                inflateReset2(&index->strm, GZIP);\n                do {\n                    if (index->strm.avail_in == 0) {\n                        index->strm.avail_in = fread(input, 1, CHUNK, in);\n                        if (index->strm.avail_in < CHUNK && ferror(in)) {\n                            ret = Z_ERRNO;\n                            break;\n                        }\n                        index->strm.next_in = input;\n                    }\n                    index->strm.avail_out = WINSIZE;\n                    index->strm.next_out = discard;\n                    ret = inflate(&index->strm, Z_BLOCK);  // stop after header\n                } while (ret == Z_OK && (index->strm.data_type & 0x80) == 0);\n                if (ret != Z_OK)\n                    break;\n                inflateReset2(&index->strm, RAW);\n            }\n        }\n\n        // Continue until we have the requested data, the deflate data has\n        // ended, or an error is encountered.\n    } while (ret == Z_OK);\n\n    // Return the number of uncompressed bytes read into buf, or the error.\n    return ret == Z_OK || ret == Z_STREAM_END ? len - left : ret;\n}",
          "fn_code_pos": [
            [
              340,
              0
            ],
            [
              470,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflate_index_extract",
            "parameters": {
              "in": "FILE",
              "index": "struct deflate_index",
              "offset": "off_t",
              "buf": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ptrdiff_t"
          }
        },
        {
          "fn_code": "int main(int argc, char **argv) {\n    // Open the input file.\n    if (argc < 2 || argc > 3) {\n        fprintf(stderr, \"usage: zran file.raw [offset]\\n\");\n        return 1;\n    }\n    FILE *in = fopen(argv[1], \"rb\");\n    if (in == NULL) {\n        fprintf(stderr, \"zran: could not open %s for reading\\n\", argv[1]);\n        return 1;\n    }\n\n    // Get optional offset.\n    off_t offset = -1;\n    if (argc == 3) {\n        char *end;\n        offset = strtoll(argv[2], &end, 10);\n        if (*end || offset < 0) {\n            fprintf(stderr, \"zran: %s is not a valid offset\\n\", argv[2]);\n            return 1;\n        }\n    }\n\n    // Build index.\n    struct deflate_index *index = NULL;\n    int len = deflate_index_build(in, SPAN, &index);\n    if (len < 0) {\n        fclose(in);\n        switch (len) {\n        case Z_MEM_ERROR:\n            fprintf(stderr, \"zran: out of memory\\n\");\n            break;\n        case Z_BUF_ERROR:\n            fprintf(stderr, \"zran: %s ended prematurely\\n\", argv[1]);\n            break;\n        case Z_DATA_ERROR:\n            fprintf(stderr, \"zran: compressed data error in %s\\n\", argv[1]);\n            break;\n        case Z_ERRNO:\n            fprintf(stderr, \"zran: read error on %s\\n\", argv[1]);\n            break;\n        default:\n            fprintf(stderr, \"zran: error %d while building index\\n\", len);\n        }\n        return 1;\n    }\n    fprintf(stderr, \"zran: built index with %d access points\\n\", len);\n\n    // Use index by reading some bytes from an arbitrary offset.\n    unsigned char buf[LEN];\n    if (offset == -1)\n        offset = ((index->length + 1) << 1) / 3;\n    ptrdiff_t got = deflate_index_extract(in, index, offset, buf, LEN);\n    if (got < 0)\n        fprintf(stderr, \"zran: extraction failed: %s error\\n\",\n                got == Z_MEM_ERROR ? \"out of memory\" : \"input corrupted\");\n    else {\n        fwrite(buf, 1, got, stdout);\n        fprintf(stderr, \"zran: extracted %ld bytes at %lld\\n\", got, offset);\n    }\n\n    // Clean up and exit.\n    deflate_index_free(index);\n    fclose(in);\n    return 0;\n}",
          "fn_code_pos": [
            [
              482,
              0
            ],
            [
              547,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "add_point(struct deflate_index *index, off_t in,\n                                       off_t out, off_t beg,\n                                       unsigned char *window)",
          "fn_dec_pos": [
            [
              86,
              29
            ],
            [
              88,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_point",
            "parameters": {
              "index": "struct deflate_index",
              "in": "off_t",
              "out": "off_t",
              "beg": "off_t",
              "window": "unsigned char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct deflate_index",
          {},
          "",
          [
            71,
            24
          ],
          [
            71,
            44
          ]
        ],
        [
          "struct deflate_index",
          {},
          "",
          [
            86,
            7
          ],
          [
            86,
            27
          ]
        ],
        [
          "struct deflate_index",
          {},
          "",
          [
            86,
            39
          ],
          [
            86,
            59
          ]
        ],
        [
          "struct deflate_index",
          {},
          "",
          [
            132,
            46
          ],
          [
            132,
            66
          ]
        ],
        [
          "struct deflate_index",
          {},
          "",
          [
            138,
            4
          ],
          [
            138,
            24
          ]
        ],
        [
          "struct deflate_index",
          {},
          "",
          [
            138,
            48
          ],
          [
            138,
            68
          ]
        ],
        [
          "struct deflate_index",
          {},
          "",
          [
            340,
            42
          ],
          [
            340,
            62
          ]
        ],
        [
          "struct deflate_index",
          {},
          "",
          [
            506,
            4
          ],
          [
            506,
            24
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            62,
            0
          ],
          [
            63,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ],
        [
          "#include \"zran.h\"\n",
          [
            65,
            0
          ],
          [
            66,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/examples/gznorm.c": {
      "fn_def_list": [
        {
          "fn_code": "local char *aprintf(char *fmt, ...) {\n    // Get the length of the result of the printf.\n    va_list args;\n    va_start(args, fmt);\n    int len = vsnprintf(NULL, 0, fmt, args);\n    va_end(args);\n    if (len < 0)\n        return NULL;\n\n    // Allocate the required space and printf to it.\n    char *str = malloc(len + 1);\n    if (str == NULL)\n        return NULL;\n    va_start(args, fmt);\n    vsnprintf(str, len + 1, fmt, args);\n    va_end(args);\n    return str;\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              56,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "aprintf",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int gzip_normalize(FILE *in, FILE *out, char **err) {\n    // initialize the inflate engine to process a gzip member\n    z_stream strm;\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    if (inflateInit2(&strm, 15 + 16) != Z_OK)\n        BYE(\"out of memory\");\n\n    // State while processing the input gzip stream.\n    enum {              // BETWEEN -> HEAD -> BLOCK -> TAIL -> BETWEEN -> ...\n        BETWEEN,        // between gzip members (must end in this state)\n        HEAD,           // reading a gzip header\n        BLOCK,          // reading deflate blocks\n        TAIL            // reading a gzip trailer\n    } state = BETWEEN;              // current component being processed\n    unsigned long crc = 0;          // accumulated CRC of uncompressed data\n    unsigned long len = 0;          // accumulated length of uncompressed data\n    unsigned long buf = 0;          // deflate stream bit buffer of num bits\n    int num = 0;                    // number of bits in buf (at bottom)\n\n    // Write a canonical gzip header (no mod time, file name, comment, extra\n    // block, or extra flags, and OS is marked as unknown).\n    fwrite(\"\\x1f\\x8b\\x08\\0\\0\\0\\0\\0\\0\\xff\", 1, 10, out);\n\n    // Process the gzip stream from in until reaching the end of the input,\n    // encountering invalid input, or experiencing an i/o error.\n    int more;                       // true if not at the end of the input\n    do {\n        // State inside this loop.\n        unsigned char *put;         // next input buffer location to process\n        int prev;                   // number of bits from previous block in\n                                    // the bit buffer, or -1 if not at the\n                                    // start of a block\n        unsigned long long memb;    // uncompressed length of member\n        size_t tail;                // number of trailer bytes read (0..8)\n        unsigned long part;         // accumulated trailer component\n\n        // Get the next chunk of input from in.\n        unsigned char dat[CHUNK];\n        strm.avail_in = fread(dat, 1, CHUNK, in);\n        if (strm.avail_in == 0)\n            break;\n        more = strm.avail_in == CHUNK;\n        strm.next_in = put = dat;\n\n        // Run that chunk of input through the inflate engine to exhaustion.\n        do {\n            // At this point it is assured that strm.avail_in > 0.\n\n            // Inflate until the end of a gzip component (header, deflate\n            // block, trailer) is reached, or until all of the chunk is\n            // consumed. The resulting decompressed data is discarded, though\n            // the total size of the decompressed data in each member is\n            // tracked, for the calculation of the total CRC.\n            do {\n                // inflate and handle any errors\n                unsigned char scrap[CHUNK];\n                strm.avail_out = CHUNK;\n                strm.next_out = scrap;\n                int ret = inflate(&strm, Z_BLOCK);\n                if (ret == Z_MEM_ERROR)\n                    BYE(\"out of memory\");\n                if (ret == Z_DATA_ERROR)\n                    BYE(\"input invalid: %s\", strm.msg);\n                if (ret != Z_OK && ret != Z_BUF_ERROR && ret != Z_STREAM_END)\n                    BYE(\"internal error\");\n\n                // Update the number of uncompressed bytes generated in this\n                // member. The actual count (not modulo 2^32) is required to\n                // correctly compute the total CRC.\n                unsigned got = CHUNK - strm.avail_out;\n                memb += got;\n                if (memb < got)\n                    BYE(\"overflow error\");\n\n                // Continue to process this chunk until it is consumed, or\n                // until the end of a component (header, deflate block, or\n                // trailer) is reached.\n            } while (strm.avail_out == 0 && (strm.data_type & 0x80) == 0);\n\n            // Since strm.avail_in was > 0 for the inflate call, some input was\n            // just consumed. It is therefore assured that put < strm.next_in.\n\n            // Disposition the consumed component or part of a component.\n            switch (state) {\n                case BETWEEN:\n                    state = HEAD;\n                    // Fall through to HEAD when some or all of the header is\n                    // processed.\n\n                case HEAD:\n                    // Discard the header.\n                    if (strm.data_type & 0x80) {\n                        // End of header reached -- deflate blocks follow.\n                        put = strm.next_in;\n                        prev = num;\n                        memb = 0;\n                        state = BLOCK;\n                    }\n                    break;\n\n                case BLOCK:\n                    // Copy the deflate stream to the output, but with the\n                    // last-block-bit cleared. Re-synchronize stored block\n                    // headers to the output byte boundaries. The bytes at\n                    // put..strm.next_in-1 is the compressed data that has been\n                    // processed and is ready to be copied to the output.\n\n                    // At this point, it is assured that new compressed data is\n                    // available, i.e., put < strm.next_in. If prev is -1, then\n                    // that compressed data starts in the middle of a deflate\n                    // block. If prev is not -1, then the bits in the bit\n                    // buffer, possibly combined with the bits in *put, contain\n                    // the three-bit header of the new deflate block. In that\n                    // case, prev is the number of bits from the previous block\n                    // that remain in the bit buffer. Since num is the number\n                    // of bits in the bit buffer, we have that num - prev is\n                    // the number of bits from the new block currently in the\n                    // bit buffer.\n\n                    // If strm.data_type & 0xc0 is 0x80, then the last byte of\n                    // the available compressed data includes the last bits of\n                    // the end of a deflate block. In that case, that last byte\n                    // also has strm.data_type & 0x1f bits of the next deflate\n                    // block, in the range 0..7. If strm.data_type & 0xc0 is\n                    // 0xc0, then the last byte of the compressed data is the\n                    // end of the deflate stream, followed by strm.data_type &\n                    // 0x1f pad bits, also in the range 0..7.\n\n                    // Set bits to the number of bits not yet consumed from the\n                    // last byte. If we are at the end of the block, bits is\n                    // either the number of bits in the last byte belonging to\n                    // the next block, or the number of pad bits after the\n                    // final block. In either of those cases, bits is in the\n                    // range 0..7.\n                    ;                   // (required due to C syntax oddity)\n                    int bits = strm.data_type & 0x1f;\n\n                    if (prev != -1) {\n                        // We are at the start of a new block. Clear the last\n                        // block bit, and check for special cases. If it is a\n                        // stored block, then emit the header and pad to the\n                        // next byte boundary. If it is a final, empty fixed\n                        // block, then excise it.\n\n                        // Some or all of the three header bits for this block\n                        // may already be in the bit buffer. Load any remaining\n                        // header bits into the bit buffer.\n                        if (num - prev < 3) {\n                            buf += (unsigned long)*put++ << num;\n                            num += 8;\n                        }\n\n                        // Set last to have a 1 in the position of the last\n                        // block bit in the bit buffer.\n                        unsigned long last = (unsigned long)1 << prev;\n\n                        if (((buf >> prev) & 7) == 3) {\n                            // This is a final fixed block. Load at least ten\n                            // bits from this block, including the header, into\n                            // the bit buffer. We already have at least three,\n                            // so at most one more byte needs to be loaded.\n                            if (num - prev < 10) {\n                                if (put == strm.next_in)\n                                    // Need to go get and process more input.\n                                    // We'll end up back here to finish this.\n                                    break;\n                                buf += (unsigned long)*put++ << num;\n                                num += 8;\n                            }\n                            if (((buf >> prev) & 0x3ff) == 3) {\n                                // That final fixed block is empty. Delete it\n                                // to avoid adding an empty block every time a\n                                // gzip stream is normalized.\n                                num = prev;\n                                buf &= last - 1;    // zero the pad bits\n                            }\n                        }\n                        else if (((buf >> prev) & 6) == 0) {\n                            // This is a stored block. Flush to the next\n                            // byte boundary after the three-bit header.\n                            num = (prev + 10) & ~7;\n                            buf &= last - 1;        // zero the pad bits\n                        }\n\n                        // Clear the last block bit.\n                        buf &= ~last;\n\n                        // Write out complete bytes in the bit buffer.\n                        while (num >= 8) {\n                            putc(buf, out);\n                            buf >>= 8;\n                            num -= 8;\n                        }\n\n                        // If no more bytes left to process, then we have\n                        // consumed the byte that had bits from the next block.\n                        if (put == strm.next_in)\n                            bits = 0;\n                    }\n\n                    // We are done handling the deflate block header. Now copy\n                    // all or almost all of the remaining compressed data that\n                    // has been processed so far. Don't copy one byte at the\n                    // end if it contains bits from the next deflate block or\n                    // pad bits at the end of a deflate block.\n\n                    // mix is 1 if we are at the end of a deflate block, and if\n                    // some of the bits in the last byte follow this block. mix\n                    // is 0 if we are in the middle of a deflate block, if the\n                    // deflate block ended on a byte boundary, or if all of the\n                    // compressed data processed so far has been consumed.\n                    int mix = (strm.data_type & 0x80) && bits;\n\n                    // Copy all of the processed compressed data to the output,\n                    // except for the last byte if it contains bits from the\n                    // next deflate block or pad bits at the end of the deflate\n                    // stream. Copy the data after shifting in num bits from\n                    // buf in front of it, leaving num bits from the end of the\n                    // compressed data in buf when done.\n                    unsigned char *end = strm.next_in - mix;\n                    if (put < end) {\n                        if (num)\n                            // Insert num bits from buf before the data being\n                            // copied.\n                            do {\n                                buf += (unsigned)(*put++) << num;\n                                putc(buf, out);\n                                buf >>= 8;\n                            } while (put < end);\n                        else {\n                            // No shifting needed -- write directly.\n                            fwrite(put, 1, end - put, out);\n                            put = end;\n                        }\n                    }\n\n                    // Process the last processed byte if it wasn't written.\n                    if (mix) {\n                        // Load the last byte into the bit buffer.\n                        buf += (unsigned)(*put++) << num;\n                        num += 8;\n\n                        if (strm.data_type & 0x40) {\n                            // We are at the end of the deflate stream and\n                            // there are bits pad bits. Discard the pad bits\n                            // and write a byte to the output, if available.\n                            // Leave the num bits left over in buf to prepend\n                            // to the next deflate stream.\n                            num -= bits;\n                            if (num >= 8) {\n                                putc(buf, out);\n                                num -= 8;\n                                buf >>= 8;\n                            }\n\n                            // Force the pad bits in the bit buffer to zeros.\n                            buf &= ((unsigned long)1 << num) - 1;\n\n                            // Don't need to set prev here since going to TAIL.\n                        }\n                        else\n                            // At the end of an internal deflate block. Leave\n                            // the last byte in the bit buffer to examine on\n                            // the next entry to BLOCK, when more bits from the\n                            // next block will be available.\n                            prev = num - bits;      // number of bits in buffer\n                                                    // from current block\n                    }\n\n                    // Don't have a byte left over, so we are in the middle of\n                    // a deflate block, or the deflate block ended on a byte\n                    // boundary. Set prev appropriately for the next entry into\n                    // BLOCK.\n                    else if (strm.data_type & 0x80)\n                        // The block ended on a byte boundary, so no header\n                        // bits are in the bit buffer.\n                        prev = num;\n                    else\n                        // In the middle of a deflate block, so no header here.\n                        prev = -1;\n\n                    // Check for the end of the deflate stream.\n                    if ((strm.data_type & 0xc0) == 0xc0) {\n                        // That ends the deflate stream on the input side, the\n                        // pad bits were discarded, and any remaining bits from\n                        // the last block in the stream are saved in the bit\n                        // buffer to prepend to the next stream. Process the\n                        // gzip trailer next.\n                        tail = 0;\n                        part = 0;\n                        state = TAIL;\n                    }\n                    break;\n\n                case TAIL:\n                    // Accumulate available trailer bytes to update the total\n                    // CRC and the total uncompressed length.\n                    do {\n                        part = (part >> 8) + ((unsigned long)(*put++) << 24);\n                        tail++;\n                        if (tail == 4) {\n                            // Update the total CRC.\n                            z_off_t len2 = memb;\n                            if (len2 < 0 || (unsigned long long)len2 != memb)\n                                BYE(\"overflow error\");\n                            crc = crc ? crc32_combine(crc, part, len2) : part;\n                            part = 0;\n                        }\n                        else if (tail == 8) {\n                            // Update the total uncompressed length. (It's ok\n                            // if this sum is done modulo 2^32.)\n                            len += part;\n\n                            // At the end of a member. Set up to inflate an\n                            // immediately following gzip member. (If we made\n                            // it this far, then the trailer was valid.)\n                            if (inflateReset(&strm) != Z_OK)\n                                BYE(\"internal error\");\n                            state = BETWEEN;\n                            break;\n                        }\n                    } while (put < strm.next_in);\n                    break;\n            }\n\n            // Process the input buffer until completely consumed.\n        } while (strm.avail_in > 0);\n\n        // Process input until end of file, invalid input, or i/o error.\n    } while (more);\n\n    // Done with the inflate engine.\n    inflateEnd(&strm);\n\n    // Verify the validity of the input.\n    if (state != BETWEEN)\n        BYE(\"input invalid: incomplete gzip stream\");\n\n    // Write the remaining deflate stream bits, followed by a terminating\n    // deflate fixed block.\n    buf += (unsigned long)3 << num;\n    putc(buf, out);\n    putc(buf >> 8, out);\n    if (num > 6)\n        putc(0, out);\n\n    // Write the gzip trailer, which is the CRC and the uncompressed length\n    // modulo 2^32, both in little-endian order.\n    putc(crc, out);\n    putc(crc >> 8, out);\n    putc(crc >> 16, out);\n    putc(crc >> 24, out);\n    putc(len, out);\n    putc(len >> 8, out);\n    putc(len >> 16, out);\n    putc(len >> 24, out);\n    fflush(out);\n\n    // Check for any i/o errors.\n    if (ferror(in) || ferror(out))\n        BYE(\"i/o error: %s\", strerror(errno));\n\n    // All good!\n    *err = NULL;\n    return 0;\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              458,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzip_normalize",
            "parameters": {
              "in": "FILE",
              "out": "FILE",
              "err": "char"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int main(void) {\n    // Avoid end-of-line conversions on evil operating systems.\n    SET_BINARY_MODE(stdin);\n    SET_BINARY_MODE(stdout);\n\n    // Normalize from stdin to stdout, returning 1 on error, 0 if ok.\n    char *err;\n    int ret = gzip_normalize(stdin, stdout, &err);\n    if (ret)\n        fprintf(stderr, \"gznorm error: %s\\n\", err);\n    free(err);\n    return ret;\n}",
          "fn_code_pos": [
            [
              461,
              0
            ],
            [
              473,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "aprintf(char *fmt, ...)",
          "fn_dec_pos": [
            [
              39,
              12
            ],
            [
              39,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "aprintf",
            "parameters": {
              "fmt": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>      // fread, fwrite, putc, fflush, ferror, fprintf,\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include <stdlib.h>     // malloc, free\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include <string.h>     // strerror\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include <errno.h>      // errno\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include <stdarg.h>     // va_list, va_start, va_end\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#include \"zlib.h\"       // inflateInit2, inflate, inflateReset, inflateEnd,\n",
          [
            22,
            0
          ],
          [
            23,
            0
          ]
        ],
        [
          "#  include <fcntl.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <io.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "enum {              // BETWEEN -> HEAD -> BLOCK -> TAIL -> BETWEEN -> ...\n        BETWEEN,        // between gzip members (must end in this state)\n        HEAD,           // reading a gzip header\n        BLOCK,          // reading deflate blocks\n        TAIL            // reading a gzip trailer\n    }",
          {
            "BETWEEN": "",
            "HEAD": "",
            "BLOCK": "",
            "TAIL": ""
          },
          "",
          [
            101,
            4
          ],
          [
            106,
            5
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/examples/enough.c": {
      "fn_def_list": [
        {
          "fn_code": "local void string_clear(string_t *s) {\n    s->str[0] = 0;\n    s->len = 0;\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              183,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "string_clear",
            "parameters": {
              "s": "string_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void string_init(string_t *s) {\n    s->size = 16;\n    s->str = malloc(s->size);\n    assert(s->str != NULL && \"out of memory\");\n    string_clear(s);\n}",
          "fn_code_pos": [
            [
              186,
              0
            ],
            [
              191,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "string_init",
            "parameters": {
              "s": "string_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void string_free(string_t *s) {\n    free(s->str);\n    s->str = NULL;\n    s->size = 0;\n    s->len = 0;\n}",
          "fn_code_pos": [
            [
              194,
              0
            ],
            [
              199,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "string_free",
            "parameters": {
              "s": "string_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void string_printf(string_t *s, char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    size_t len = s->len;\n    int ret = vsnprintf(s->str + len, s->size - len, fmt, ap);\n    assert(ret >= 0 && \"out of memory\");\n    s->len += ret;\n    if (s->size < s->len + 1) {\n        do {\n            s->size <<= 1;\n            assert(s->size != 0 && \"overflow\");\n        } while (s->size < s->len + 1);\n        s->str = realloc(s->str, s->size);\n        assert(s->str != NULL && \"out of memory\");\n        vsnprintf(s->str + len, s->size - len, fmt, ap);\n    }\n    va_end(ap);\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              220,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "string_printf",
            "parameters": {
              "s": "string_t",
              "fmt": "char"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local inline size_t map(int syms, int left, int len) {\n    return ((size_t)((syms - 1) >> 1) * ((syms - 2) >> 1) +\n            (left >> 1) - 1) * (g.max - 1) +\n           len - 1;\n}",
          "fn_code_pos": [
            [
              236,
              0
            ],
            [
              240,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "map",
            "parameters": {
              "syms": "int",
              "left": "int",
              "len": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void cleanup(void) {\n    if (g.done != NULL) {\n        for (size_t n = 0; n < g.size; n++)\n            if (g.done[n].len)\n                free(g.done[n].vec);\n        g.size = 0;\n        free(g.done);   g.done = NULL;\n    }\n    free(g.num);    g.num = NULL;\n    free(g.code);   g.code = NULL;\n    string_free(&g.out);\n}",
          "fn_code_pos": [
            [
              243,
              0
            ],
            [
              254,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cleanup",
            "parameters": {},
            "return_type": "local"
          }
        },
        {
          "fn_code": "local big_t count(int syms, int left, int len) {\n    // see if only one possible code\n    if (syms == left)\n        return 1;\n\n    // note and verify the expected state\n    assert(syms > left && left > 0 && len < g.max);\n\n    // see if we've done this one already\n    size_t index = map(syms, left, len);\n    big_t got = g.num[index];\n    if (got)\n        return got;         // we have -- return the saved result\n\n    // we need to use at least this many bit patterns so that the code won't be\n    // incomplete at the next length (more bit patterns than symbols)\n    int least = (left << 1) - syms;\n    if (least < 0)\n        least = 0;\n\n    // we can use at most this many bit patterns, lest there not be enough\n    // available for the remaining symbols at the maximum length (if there were\n    // no limit to the code length, this would become: most = left - 1)\n    int most = (((code_t)left << (g.max - len)) - syms) /\n               (((code_t)1 << (g.max - len)) - 1);\n\n    // count all possible codes from this juncture and add them up\n    big_t sum = 0;\n    for (int use = least; use <= most; use++) {\n        got = count(syms - use, (left - use) << 1, len + 1);\n        sum += got;\n        if (got == (big_t)-1 || sum < got)      // overflow\n            return (big_t)-1;\n    }\n\n    // verify that all recursive calls are productive\n    assert(sum != 0);\n\n    // save the result and return it\n    g.num[index] = sum;\n    return sum;\n}",
          "fn_code_pos": [
            [
              260,
              0
            ],
            [
              301,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "count",
            "parameters": {
              "syms": "int",
              "left": "int",
              "len": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int been_here(int syms, int left, int len, int mem, int rem) {\n    // point to vector for (syms,left,len), bit in vector for (mem,rem)\n    size_t index = map(syms, left, len);\n    mem -= 1 << g.root;             // mem always includes the root table\n    mem >>= 1;                      // mem and rem are always even\n    rem >>= 1;\n    size_t offset = (mem >> 3) + rem;\n    offset = ((offset * (offset + 1)) >> 1) + rem;\n    int bit = 1 << (mem & 7);\n\n    // see if we've been here\n    size_t length = g.done[index].len;\n    if (offset < length && (g.done[index].vec[offset] & bit) != 0)\n        return 1;       // done this!\n\n    // we haven't been here before -- set the bit to show we have now\n\n    // see if we need to lengthen the vector in order to set the bit\n    if (length <= offset) {\n        // if we have one already, enlarge it, zero out the appended space\n        char *vector;\n        if (length) {\n            do {\n                length <<= 1;\n            } while (length <= offset);\n            vector = realloc(g.done[index].vec, length);\n            assert(vector != NULL && \"out of memory\");\n            memset(vector + g.done[index].len, 0, length - g.done[index].len);\n        }\n\n        // otherwise we need to make a new vector and zero it out\n        else {\n            length = 16;\n            while (length <= offset)\n                length <<= 1;\n            vector = calloc(length, 1);\n            assert(vector != NULL && \"out of memory\");\n        }\n\n        // install the new vector\n        g.done[index].len = length;\n        g.done[index].vec = vector;\n    }\n\n    // set the bit\n    g.done[index].vec[offset] |= bit;\n    return 0;\n}",
          "fn_code_pos": [
            [
              307,
              0
            ],
            [
              354,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "been_here",
            "parameters": {
              "syms": "int",
              "left": "int",
              "len": "int",
              "mem": "int",
              "rem": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void examine(int syms, int left, int len, int mem, int rem) {\n    // see if we have a complete code\n    if (syms == left) {\n        // set the last code entry\n        g.code[len] = left;\n\n        // complete computation of memory used by this code\n        while (rem < left) {\n            left -= rem;\n            rem = 1 << (len - g.root);\n            mem += rem;\n        }\n        assert(rem == left);\n\n        // if this is at the maximum, show the sub-code\n        if (mem >= g.large) {\n            // if this is a new maximum, update the maximum and clear out the\n            // printed sub-codes from the previous maximum\n            if (mem > g.large) {\n                g.large = mem;\n                string_clear(&g.out);\n            }\n\n            // compute the starting state for this sub-code\n            syms = 0;\n            left = 1 << g.max;\n            for (int bits = g.max; bits > g.root; bits--) {\n                syms += g.code[bits];\n                left -= g.code[bits];\n                assert((left & 1) == 0);\n                left >>= 1;\n            }\n\n            // print the starting state and the resulting sub-code to g.out\n            string_printf(&g.out, \"<%u, %u, %u>:\",\n                          syms, g.root + 1, ((1 << g.root) - left) << 1);\n            for (int bits = g.root + 1; bits <= g.max; bits++)\n                if (g.code[bits])\n                    string_printf(&g.out, \" %d[%d]\", g.code[bits], bits);\n            string_printf(&g.out, \"\\n\");\n        }\n\n        // remove entries as we drop back down in the recursion\n        g.code[len] = 0;\n        return;\n    }\n\n    // prune the tree if we can\n    if (been_here(syms, left, len, mem, rem))\n        return;\n\n    // we need to use at least this many bit patterns so that the code won't be\n    // incomplete at the next length (more bit patterns than symbols)\n    int least = (left << 1) - syms;\n    if (least < 0)\n        least = 0;\n\n    // we can use at most this many bit patterns, lest there not be enough\n    // available for the remaining symbols at the maximum length (if there were\n    // no limit to the code length, this would become: most = left - 1)\n    int most = (((code_t)left << (g.max - len)) - syms) /\n               (((code_t)1 << (g.max - len)) - 1);\n\n    // occupy least table spaces, creating new sub-tables as needed\n    int use = least;\n    while (rem < use) {\n        use -= rem;\n        rem = 1 << (len - g.root);\n        mem += rem;\n    }\n    rem -= use;\n\n    // examine codes from here, updating table space as we go\n    for (use = least; use <= most; use++) {\n        g.code[len] = use;\n        examine(syms - use, (left - use) << 1, len + 1,\n                mem + (rem ? 1 << (len - g.root) : 0), rem << 1);\n        if (rem == 0) {\n            rem = 1 << (len - g.root);\n            mem += rem;\n        }\n        rem--;\n    }\n\n    // remove entries as we drop back down in the recursion\n    g.code[len] = 0;\n}",
          "fn_code_pos": [
            [
              360,
              0
            ],
            [
              446,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "examine",
            "parameters": {
              "syms": "int",
              "left": "int",
              "len": "int",
              "mem": "int",
              "rem": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void enough(int syms) {\n    // clear code\n    for (int n = 0; n <= g.max; n++)\n        g.code[n] = 0;\n\n    // look at all (root + 1) bit and longer codes\n    string_clear(&g.out);           // empty saved results\n    g.large = 1 << g.root;          // base table\n    if (g.root < g.max)             // otherwise, there's only a base table\n        for (int n = 3; n <= syms; n++)\n            for (int left = 2; left < n; left += 2) {\n                // look at all reachable (root + 1) bit nodes, and the\n                // resulting codes (complete at root + 2 or more)\n                size_t index = map(n, left, g.root + 1);\n                if (g.root + 1 < g.max && g.num[index]) // reachable node\n                    examine(n, left, g.root + 1, 1 << g.root, 0);\n\n                // also look at root bit codes with completions at root + 1\n                // bits (not saved in num, since complete), just in case\n                if (g.num[index - 1] && n <= left << 1)\n                    examine((n - left) << 1, (n - left) << 1, g.root + 1,\n                            1 << g.root, 0);\n            }\n\n    // done\n    printf(\"maximum of %d table entries for root = %d\\n\", g.large, g.root);\n    fputs(g.out.str, stdout);\n}",
          "fn_code_pos": [
            [
              453,
              0
            ],
            [
              480,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "enough",
            "parameters": {
              "syms": "int"
            },
            "return_type": "local"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "main(int argc, char **argv)",
          "fn_dec_pos": [
            [
              497,
              4
            ],
            [
              497,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct tab {                // type for been-here check\n    size_t len;             // allocated length of bit vector in octets\n    char *vec;              // allocated bit vector\n}",
          {
            "len": "size_t",
            "*vec": "char"
          },
          "tab",
          [
            117,
            0
          ],
          [
            120,
            1
          ]
        ],
        [
          "typedef struct {\n    char *str;          // pointer to allocated string\n    size_t size;        // size of allocation\n    size_t len;         // length of string, not including terminating zero\n} string_t;",
          {
            "*str": "char",
            "size": "size_t",
            "len": "size_t"
          },
          "string_t",
          [
            173,
            0
          ],
          [
            177,
            11
          ]
        ],
        [
          "struct {\n    int max;            // maximum allowed bit length for the codes\n    int root;           // size of base code table in bits\n    int large;          // largest code table so far\n    size_t size;        // number of elements in num and done\n    big_t tot;          // total number of codes with maximum tables size\n    string_t out;       // display of subcodes for maximum tables size\n    int *code;          // number of symbols assigned to each bit length\n    big_t *num;         // saved results array for code counting\n    struct tab *done;   // states already evaluated array\n}",
          {
            "max": "int",
            "root": "int",
            "large": "int",
            "size": "size_t",
            "tot": "big_t",
            "out": "string_t",
            "*code": "int",
            "*num": "big_t",
            "*done": "struct tab"
          },
          "",
          [
            223,
            0
          ],
          [
            233,
            1
          ]
        ],
        [
          "struct tab {                // type for been-here check\n    size_t len;             // allocated length of bit vector in octets\n    char *vec;              // allocated bit vector\n}",
          {
            "len": "size_t",
            "*vec": "char"
          },
          "tab",
          [
            117,
            0
          ],
          [
            120,
            1
          ]
        ],
        [
          "typedef struct {\n    char *str;          // pointer to allocated string\n    size_t size;        // size of allocation\n    size_t len;         // length of string, not including terminating zero\n} string_t;",
          {
            "*str": "char",
            "size": "size_t",
            "len": "size_t"
          },
          "string_t",
          [
            173,
            0
          ],
          [
            177,
            11
          ]
        ],
        [
          "struct {\n    int max;            // maximum allowed bit length for the codes\n    int root;           // size of base code table in bits\n    int large;          // largest code table so far\n    size_t size;        // number of elements in num and done\n    big_t tot;          // total number of codes with maximum tables size\n    string_t out;       // display of subcodes for maximum tables size\n    int *code;          // number of symbols assigned to each bit length\n    big_t *num;         // saved results array for code counting\n    struct tab *done;   // states already evaluated array\n}",
          {
            "max": "int",
            "root": "int",
            "large": "int",
            "size": "size_t",
            "tot": "big_t",
            "out": "string_t",
            "*code": "int",
            "*num": "big_t",
            "*done": "struct tab"
          },
          "",
          [
            223,
            0
          ],
          [
            233,
            1
          ]
        ],
        [
          "struct tab",
          {},
          "",
          [
            232,
            4
          ],
          [
            232,
            14
          ]
        ],
        [
          "struct tab",
          {},
          "",
          [
            581,
            39
          ],
          [
            581,
            49
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            105,
            0
          ],
          [
            106,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            106,
            0
          ],
          [
            107,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            107,
            0
          ],
          [
            108,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            108,
            0
          ],
          [
            109,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            109,
            0
          ],
          [
            110,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/examples/gzjoin.c": {
      "fn_def_list": [
        {
          "fn_code": "local int bail(char *why1, char *why2)\n{\n    fprintf(stderr, \"gzjoin error: %s%s, output incomplete\\n\", why1, why2);\n    exit(1);\n    return 0;\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bail",
            "parameters": {
              "why1": "char",
              "why2": "char"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void bclose(bin *in)\n{\n    if (in != NULL) {\n        if (in->fd != -1)\n            close(in->fd);\n        if (in->buf != NULL)\n            free(in->buf);\n        free(in);\n    }\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              95,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bclose",
            "parameters": {
              "in": "bin"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local bin *bopen(char *name)\n{\n    bin *in;\n\n    in = malloc(sizeof(bin));\n    if (in == NULL)\n        return NULL;\n    in->buf = malloc(CHUNK);\n    in->fd = open(name, O_RDONLY, 0);\n    if (in->buf == NULL || in->fd == -1) {\n        bclose(in);\n        return NULL;\n    }\n    in->left = 0;\n    in->next = in->buf;\n    in->name = name;\n    return in;\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              116,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bopen",
            "parameters": {
              "name": "char"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int bload(bin *in)\n{\n    long len;\n\n    if (in == NULL)\n        return -1;\n    if (in->left != 0)\n        return 0;\n    in->next = in->buf;\n    do {\n        len = (long)read(in->fd, in->buf + in->left, CHUNK - in->left);\n        if (len < 0)\n            return -1;\n        in->left += (unsigned)len;\n    } while (len != 0 && in->left < CHUNK);\n    return len == 0 ? 1 : 0;\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bload",
            "parameters": {
              "in": "bin"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local unsigned long bget4(bin *in)\n{\n    unsigned long val;\n\n    val = bget(in);\n    val += (unsigned long)(bget(in)) << 8;\n    val += (unsigned long)(bget(in)) << 16;\n    val += (unsigned long)(bget(in)) << 24;\n    return val;\n}",
          "fn_code_pos": [
            [
              144,
              0
            ],
            [
              153,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bget4",
            "parameters": {
              "in": "bin"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "local void bskip(bin *in, unsigned skip)\n{\n    /* check pointer */\n    if (in == NULL)\n        return;\n\n    /* easy case -- skip bytes in buffer */\n    if (skip <= in->left) {\n        in->left -= skip;\n        in->next += skip;\n        return;\n    }\n\n    /* skip what's in buffer, discard buffer contents */\n    skip -= in->left;\n    in->left = 0;\n\n    /* seek past multiples of CHUNK bytes */\n    if (skip > CHUNK) {\n        unsigned left;\n\n        left = skip & (CHUNK - 1);\n        if (left == 0) {\n            /* exact number of chunks: seek all the way minus one byte to check\n               for end-of-file with a read */\n            lseek(in->fd, skip - 1, SEEK_CUR);\n            if (read(in->fd, in->buf, 1) != 1)\n                bail(\"unexpected end of file on \", in->name);\n            return;\n        }\n\n        /* skip the integral chunks, update skip with remainder */\n        lseek(in->fd, skip - left, SEEK_CUR);\n        skip = left;\n    }\n\n    /* read more input and skip remainder */\n    bload(in);\n    if (skip > in->left)\n        bail(\"unexpected end of file on \", in->name);\n    in->left -= skip;\n    in->next += skip;\n}",
          "fn_code_pos": [
            [
              156,
              0
            ],
            [
              198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bskip",
            "parameters": {
              "in": "bin",
              "skip": "unsigned"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void gzhead(bin *in)\n{\n    int flags;\n\n    /* verify gzip magic header and compression method */\n    if (bget(in) != 0x1f || bget(in) != 0x8b || bget(in) != 8)\n        bail(in->name, \" is not a valid gzip file\");\n\n    /* get and verify flags */\n    flags = bget(in);\n    if ((flags & 0xe0) != 0)\n        bail(\"unknown reserved bits set in \", in->name);\n\n    /* skip modification time, extra flags, and os */\n    bskip(in, 6);\n\n    /* skip extra field if present */\n    if (flags & 4) {\n        unsigned len;\n\n        len = bget(in);\n        len += (unsigned)(bget(in)) << 8;\n        bskip(in, len);\n    }\n\n    /* skip file name if present */\n    if (flags & 8)\n        while (bget(in) != 0)\n            ;\n\n    /* skip comment if present */\n    if (flags & 16)\n        while (bget(in) != 0)\n            ;\n\n    /* skip header crc if present */\n    if (flags & 2)\n        bskip(in, 2);\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              241,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzhead",
            "parameters": {
              "in": "bin"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void put4(unsigned long val, FILE *out)\n{\n    putc(val & 0xff, out);\n    putc((val >> 8) & 0xff, out);\n    putc((val >> 16) & 0xff, out);\n    putc((val >> 24) & 0xff, out);\n}",
          "fn_code_pos": [
            [
              244,
              0
            ],
            [
              250,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "put4",
            "parameters": {
              "val": "unsigned long",
              "out": "FILE"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void zpull(z_streamp strm, bin *in)\n{\n    if (in->left == 0)\n        bload(in);\n    if (in->left == 0)\n        bail(\"unexpected end of file on \", in->name);\n    strm->avail_in = in->left;\n    strm->next_in = in->next;\n}",
          "fn_code_pos": [
            [
              253,
              0
            ],
            [
              261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zpull",
            "parameters": {
              "strm": "z_streamp",
              "in": "bin"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void gzinit(unsigned long *crc, unsigned long *tot, FILE *out)\n{\n    fwrite(\"\\x1f\\x8b\\x08\\0\\0\\0\\0\\0\\0\\xff\", 1, 10, out);\n    *crc = crc32(0L, Z_NULL, 0);\n    *tot = 0;\n}",
          "fn_code_pos": [
            [
              264,
              0
            ],
            [
              269,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzinit",
            "parameters": {
              "crc": "unsigned long",
              "tot": "unsigned long",
              "out": "FILE"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void gzcopy(char *name, int clr, unsigned long *crc, unsigned long *tot,\n                  FILE *out)\n{\n    int ret;                /* return value from zlib functions */\n    int pos;                /* where the \"last block\" bit is in byte */\n    int last;               /* true if processing the last block */\n    bin *in;                /* buffered input file */\n    unsigned char *start;   /* start of compressed data in buffer */\n    unsigned char *junk;    /* buffer for uncompressed data -- discarded */\n    z_off_t len;            /* length of uncompressed data (support > 4 GB) */\n    z_stream strm;          /* zlib inflate stream */\n\n    /* open gzip file and skip header */\n    in = bopen(name);\n    if (in == NULL)\n        bail(\"could not open \", name);\n    gzhead(in);\n\n    /* allocate buffer for uncompressed data and initialize raw inflate\n       stream */\n    junk = malloc(CHUNK);\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit2(&strm, -15);\n    if (junk == NULL || ret != Z_OK)\n        bail(\"out of memory\", \"\");\n\n    /* inflate and copy compressed data, clear last-block bit if requested */\n    len = 0;\n    zpull(&strm, in);\n    start = in->next;\n    last = start[0] & 1;\n    if (last && clr)\n        start[0] &= ~1;\n    strm.avail_out = 0;\n    for (;;) {\n        /* if input used and output done, write used input and get more */\n        if (strm.avail_in == 0 && strm.avail_out != 0) {\n            fwrite(start, 1, strm.next_in - start, out);\n            start = in->buf;\n            in->left = 0;\n            zpull(&strm, in);\n        }\n\n        /* decompress -- return early when end-of-block reached */\n        strm.avail_out = CHUNK;\n        strm.next_out = junk;\n        ret = inflate(&strm, Z_BLOCK);\n        switch (ret) {\n        case Z_MEM_ERROR:\n            bail(\"out of memory\", \"\");\n        case Z_DATA_ERROR:\n            bail(\"invalid compressed data in \", in->name);\n        }\n\n        /* update length of uncompressed data */\n        len += CHUNK - strm.avail_out;\n\n        /* check for block boundary (only get this when block copied out) */\n        if (strm.data_type & 128) {\n            /* if that was the last block, then done */\n            if (last)\n                break;\n\n            /* number of unused bits in last byte */\n            pos = strm.data_type & 7;\n\n            /* find the next last-block bit */\n            if (pos != 0) {\n                /* next last-block bit is in last used byte */\n                pos = 0x100 >> pos;\n                last = strm.next_in[-1] & pos;\n                if (last && clr)\n                    in->buf[strm.next_in - in->buf - 1] &= ~pos;\n            }\n            else {\n                /* next last-block bit is in next unused byte */\n                if (strm.avail_in == 0) {\n                    /* don't have that byte yet -- get it */\n                    fwrite(start, 1, strm.next_in - start, out);\n                    start = in->buf;\n                    in->left = 0;\n                    zpull(&strm, in);\n                }\n                last = strm.next_in[0] & 1;\n                if (last && clr)\n                    in->buf[strm.next_in - in->buf] &= ~1;\n            }\n        }\n    }\n\n    /* update buffer with unused input */\n    in->left = strm.avail_in;\n    in->next = in->buf + (strm.next_in - in->buf);\n\n    /* copy used input, write empty blocks to get to byte boundary */\n    pos = strm.data_type & 7;\n    fwrite(start, 1, in->next - start - 1, out);\n    last = in->next[-1];\n    if (pos == 0 || !clr)\n        /* already at byte boundary, or last file: write last byte */\n        putc(last, out);\n    else {\n        /* append empty blocks to last byte */\n        last &= ((0x100 >> pos) - 1);       /* assure unused bits are zero */\n        if (pos & 1) {\n            /* odd -- append an empty stored block */\n            putc(last, out);\n            if (pos == 1)\n                putc(0, out);               /* two more bits in block header */\n            fwrite(\"\\0\\0\\xff\\xff\", 1, 4, out);\n        }\n        else {\n            /* even -- append 1, 2, or 3 empty fixed blocks */\n            switch (pos) {\n            case 6:\n                putc(last | 8, out);\n                last = 0;\n            case 4:\n                putc(last | 0x20, out);\n                last = 0;\n            case 2:\n                putc(last | 0x80, out);\n                putc(0, out);\n            }\n        }\n    }\n\n    /* update crc and tot */\n    *crc = crc32_combine(*crc, bget4(in), len);\n    *tot += (unsigned long)len;\n\n    /* clean up */\n    inflateEnd(&strm);\n    free(junk);\n    bclose(in);\n\n    /* write trailer if this is the last gzip file */\n    if (!clr) {\n        put4(*crc, out);\n        put4(*tot, out);\n    }\n}",
          "fn_code_pos": [
            [
              278,
              0
            ],
            [
              423,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzcopy",
            "parameters": {
              "name": "char",
              "clr": "int",
              "crc": "unsigned long",
              "tot": "unsigned long",
              "out": "FILE"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int main(int argc, char **argv)\n{\n    unsigned long crc, tot;     /* running crc and total uncompressed length */\n\n    /* skip command name */\n    argc--;\n    argv++;\n\n    /* show usage if no arguments */\n    if (argc == 0) {\n        fputs(\"gzjoin usage: gzjoin f1.gz [f2.gz [f3.gz ...]] > fjoin.gz\\n\",\n              stderr);\n        return 0;\n    }\n\n    /* join gzip files on command line and write to stdout */\n    gzinit(&crc, &tot, stdout);\n    while (argc--)\n        gzcopy(*argv++, argc, &crc, &tot, stdout);\n\n    /* done */\n    return 0;\n}",
          "fn_code_pos": [
            [
              426,
              0
            ],
            [
              448,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "bopen(char *name)",
          "fn_dec_pos": [
            [
              99,
              11
            ],
            [
              99,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bopen",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n    char *name;             /* name of file for error messages */\n    int fd;                 /* file descriptor */\n    unsigned left;          /* bytes remaining at next */\n    unsigned char *next;    /* next byte to read */\n    unsigned char *buf;     /* allocated buffer of length CHUNK */\n} bin;",
          {
            "*name": "char",
            "fd": "int",
            "left": "unsigned",
            "*next": "unsigned char",
            "*buf": "unsigned char"
          },
          "bin",
          [
            77,
            0
          ],
          [
            83,
            6
          ]
        ],
        [
          "typedef struct {\n    char *name;             /* name of file for error messages */\n    int fd;                 /* file descriptor */\n    unsigned left;          /* bytes remaining at next */\n    unsigned char *next;    /* next byte to read */\n    unsigned char *buf;     /* allocated buffer of length CHUNK */\n} bin;",
          {
            "*name": "char",
            "fd": "int",
            "left": "unsigned",
            "*next": "unsigned char",
            "*buf": "unsigned char"
          },
          "bin",
          [
            77,
            0
          ],
          [
            83,
            6
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>      /* fputs(), fprintf(), fwrite(), putc() */\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include <stdlib.h>     /* exit(), malloc(), free() */\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include <fcntl.h>      /* open() */\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#include <unistd.h>     /* close(), read(), lseek() */\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/examples/fitblk.c": {
      "fn_def_list": [
        {
          "fn_code": "local void quit(char *why)\n{\n    fprintf(stderr, \"fitblk abort: %s\\n\", why);\n    exit(1);\n}",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "quit",
            "parameters": {
              "why": "char"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int partcompress(FILE *in, z_streamp def)\n{\n    int ret, flush;\n    unsigned char raw[RAWLEN];\n\n    flush = Z_NO_FLUSH;\n    do {\n        def->avail_in = fread(raw, 1, RAWLEN, in);\n        if (ferror(in))\n            return Z_ERRNO;\n        def->next_in = raw;\n        if (feof(in))\n            flush = Z_FINISH;\n        ret = deflate(def, flush);\n        assert(ret != Z_STREAM_ERROR);\n    } while (def->avail_out != 0 && flush == Z_NO_FLUSH);\n    return ret;\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              89,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "partcompress",
            "parameters": {
              "in": "FILE",
              "def": "z_streamp"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int recompress(z_streamp inf, z_streamp def)\n{\n    int ret, flush;\n    unsigned char raw[RAWLEN];\n\n    flush = Z_NO_FLUSH;\n    do {\n        /* decompress */\n        inf->avail_out = RAWLEN;\n        inf->next_out = raw;\n        ret = inflate(inf, Z_NO_FLUSH);\n        assert(ret != Z_STREAM_ERROR && ret != Z_DATA_ERROR &&\n               ret != Z_NEED_DICT);\n        if (ret == Z_MEM_ERROR)\n            return ret;\n\n        /* compress what was decompressed until done or no room */\n        def->avail_in = RAWLEN - inf->avail_out;\n        def->next_in = raw;\n        if (inf->avail_out != 0)\n            flush = Z_FINISH;\n        ret = deflate(def, flush);\n        assert(ret != Z_STREAM_ERROR);\n    } while (ret != Z_STREAM_END && def->avail_out != 0);\n    return ret;\n}",
          "fn_code_pos": [
            [
              95,
              0
            ],
            [
              120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "recompress",
            "parameters": {
              "inf": "z_streamp",
              "def": "z_streamp"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int main(int argc, char **argv)\n{\n    int ret;                /* return code */\n    unsigned size;          /* requested fixed output block size */\n    unsigned have;          /* bytes written by deflate() call */\n    unsigned char *blk;     /* intermediate and final stream */\n    unsigned char *tmp;     /* close to desired size stream */\n    z_stream def, inf;      /* zlib deflate and inflate states */\n\n    /* get requested output size */\n    if (argc != 2)\n        quit(\"need one argument: size of output block\");\n    ret = strtol(argv[1], argv + 1, 10);\n    if (argv[1][0] != 0)\n        quit(\"argument must be a number\");\n    if (ret < 8)            /* 8 is minimum zlib stream size */\n        quit(\"need positive size of 8 or greater\");\n    size = (unsigned)ret;\n\n    /* allocate memory for buffers and compression engine */\n    blk = malloc(size + EXCESS);\n    def.zalloc = Z_NULL;\n    def.zfree = Z_NULL;\n    def.opaque = Z_NULL;\n    ret = deflateInit(&def, Z_DEFAULT_COMPRESSION);\n    if (ret != Z_OK || blk == NULL)\n        quit(\"out of memory\");\n\n    /* compress from stdin until output full, or no more input */\n    def.avail_out = size + EXCESS;\n    def.next_out = blk;\n    ret = partcompress(stdin, &def);\n    if (ret == Z_ERRNO)\n        quit(\"error reading input\");\n\n    /* if it all fit, then size was undersubscribed -- done! */\n    if (ret == Z_STREAM_END && def.avail_out >= EXCESS) {\n        /* write block to stdout */\n        have = size + EXCESS - def.avail_out;\n        if (fwrite(blk, 1, have, stdout) != have || ferror(stdout))\n            quit(\"error writing output\");\n\n        /* clean up and print results to stderr */\n        ret = deflateEnd(&def);\n        assert(ret != Z_STREAM_ERROR);\n        free(blk);\n        fprintf(stderr,\n                \"%u bytes unused out of %u requested (all input)\\n\",\n                size - have, size);\n        return 0;\n    }\n\n    /* it didn't all fit -- set up for recompression */\n    inf.zalloc = Z_NULL;\n    inf.zfree = Z_NULL;\n    inf.opaque = Z_NULL;\n    inf.avail_in = 0;\n    inf.next_in = Z_NULL;\n    ret = inflateInit(&inf);\n    tmp = malloc(size + EXCESS);\n    if (ret != Z_OK || tmp == NULL)\n        quit(\"out of memory\");\n    ret = deflateReset(&def);\n    assert(ret != Z_STREAM_ERROR);\n\n    /* do first recompression close to the right amount */\n    inf.avail_in = size + EXCESS;\n    inf.next_in = blk;\n    def.avail_out = size + EXCESS;\n    def.next_out = tmp;\n    ret = recompress(&inf, &def);\n    if (ret == Z_MEM_ERROR)\n        quit(\"out of memory\");\n\n    /* set up for next recompression */\n    ret = inflateReset(&inf);\n    assert(ret != Z_STREAM_ERROR);\n    ret = deflateReset(&def);\n    assert(ret != Z_STREAM_ERROR);\n\n    /* do second and final recompression (third compression) */\n    inf.avail_in = size - MARGIN;   /* assure stream will complete */\n    inf.next_in = tmp;\n    def.avail_out = size;\n    def.next_out = blk;\n    ret = recompress(&inf, &def);\n    if (ret == Z_MEM_ERROR)\n        quit(\"out of memory\");\n    assert(ret == Z_STREAM_END);    /* otherwise MARGIN too small */\n\n    /* done -- write block to stdout */\n    have = size - def.avail_out;\n    if (fwrite(blk, 1, have, stdout) != have || ferror(stdout))\n        quit(\"error writing output\");\n\n    /* clean up and print results to stderr */\n    free(tmp);\n    ret = inflateEnd(&inf);\n    assert(ret != Z_STREAM_ERROR);\n    ret = deflateEnd(&def);\n    assert(ret != Z_STREAM_ERROR);\n    free(blk);\n    fprintf(stderr,\n            \"%u bytes unused out of %u requested (%lu input)\\n\",\n            size - have, size, def.total_in);\n    return 0;\n}",
          "fn_code_pos": [
            [
              126,
              0
            ],
            [
              232,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/examples/zpipe.c": {
      "fn_def_list": [
        {
          "fn_code": "int def(FILE *source, FILE *dest, int level)\n{\n    int ret, flush;\n    unsigned have;\n    z_stream strm;\n    unsigned char in[CHUNK];\n    unsigned char out[CHUNK];\n\n    /* allocate deflate state */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    ret = deflateInit(&strm, level);\n    if (ret != Z_OK)\n        return ret;\n\n    /* compress until end of file */\n    do {\n        strm.avail_in = fread(in, 1, CHUNK, source);\n        if (ferror(source)) {\n            (void)deflateEnd(&strm);\n            return Z_ERRNO;\n        }\n        flush = feof(source) ? Z_FINISH : Z_NO_FLUSH;\n        strm.next_in = in;\n\n        /* run deflate() on input until output buffer not full, finish\n           compression if all of source has been read in */\n        do {\n            strm.avail_out = CHUNK;\n            strm.next_out = out;\n            ret = deflate(&strm, flush);    /* no bad return value */\n            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */\n            have = CHUNK - strm.avail_out;\n            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {\n                (void)deflateEnd(&strm);\n                return Z_ERRNO;\n            }\n        } while (strm.avail_out == 0);\n        assert(strm.avail_in == 0);     /* all input will be used */\n\n        /* done when last data in file processed */\n    } while (flush != Z_FINISH);\n    assert(ret == Z_STREAM_END);        /* stream will be complete */\n\n    /* clean up and return */\n    (void)deflateEnd(&strm);\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "def",
            "parameters": {
              "source": "FILE",
              "dest": "FILE",
              "level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int inf(FILE *source, FILE *dest)\n{\n    int ret;\n    unsigned have;\n    z_stream strm;\n    unsigned char in[CHUNK];\n    unsigned char out[CHUNK];\n\n    /* allocate inflate state */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit(&strm);\n    if (ret != Z_OK)\n        return ret;\n\n    /* decompress until deflate stream ends or end of file */\n    do {\n        strm.avail_in = fread(in, 1, CHUNK, source);\n        if (ferror(source)) {\n            (void)inflateEnd(&strm);\n            return Z_ERRNO;\n        }\n        if (strm.avail_in == 0)\n            break;\n        strm.next_in = in;\n\n        /* run inflate() on input until output buffer not full */\n        do {\n            strm.avail_out = CHUNK;\n            strm.next_out = out;\n            ret = inflate(&strm, Z_NO_FLUSH);\n            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */\n            switch (ret) {\n            case Z_NEED_DICT:\n                ret = Z_DATA_ERROR;     /* and fall through */\n            case Z_DATA_ERROR:\n            case Z_MEM_ERROR:\n                (void)inflateEnd(&strm);\n                return ret;\n            }\n            have = CHUNK - strm.avail_out;\n            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {\n                (void)inflateEnd(&strm);\n                return Z_ERRNO;\n            }\n        } while (strm.avail_out == 0);\n\n        /* done when inflate() says it's done */\n    } while (ret != Z_STREAM_END);\n\n    /* clean up and return */\n    (void)inflateEnd(&strm);\n    return ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR;\n}",
          "fn_code_pos": [
            [
              95,
              0
            ],
            [
              151,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inf",
            "parameters": {
              "source": "FILE",
              "dest": "FILE"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void zerr(int ret)\n{\n    fputs(\"zpipe: \", stderr);\n    switch (ret) {\n    case Z_ERRNO:\n        if (ferror(stdin))\n            fputs(\"error reading stdin\\n\", stderr);\n        if (ferror(stdout))\n            fputs(\"error writing stdout\\n\", stderr);\n        break;\n    case Z_STREAM_ERROR:\n        fputs(\"invalid compression level\\n\", stderr);\n        break;\n    case Z_DATA_ERROR:\n        fputs(\"invalid or incomplete deflate data\\n\", stderr);\n        break;\n    case Z_MEM_ERROR:\n        fputs(\"out of memory\\n\", stderr);\n        break;\n    case Z_VERSION_ERROR:\n        fputs(\"zlib version mismatch!\\n\", stderr);\n    }\n}",
          "fn_code_pos": [
            [
              154,
              0
            ],
            [
              176,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zerr",
            "parameters": {
              "ret": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char **argv)\n{\n    int ret;\n\n    /* avoid end-of-line conversions */\n    SET_BINARY_MODE(stdin);\n    SET_BINARY_MODE(stdout);\n\n    /* do compression if no arguments */\n    if (argc == 1) {\n        ret = def(stdin, stdout, Z_DEFAULT_COMPRESSION);\n        if (ret != Z_OK)\n            zerr(ret);\n        return ret;\n    }\n\n    /* do decompression if -d specified */\n    else if (argc == 2 && strcmp(argv[1], \"-d\") == 0) {\n        ret = inf(stdin, stdout);\n        if (ret != Z_OK)\n            zerr(ret);\n        return ret;\n    }\n\n    /* otherwise, report usage */\n    else {\n        fputs(\"zpipe usage: zpipe [-d] < source > dest\\n\", stderr);\n        return 1;\n    }\n}",
          "fn_code_pos": [
            [
              179,
              0
            ],
            [
              208,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            18,
            0
          ],
          [
            19,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            19,
            0
          ],
          [
            20,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            20,
            0
          ],
          [
            21,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#  include <fcntl.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#  include <io.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/examples/gzlog.c": {
      "fn_def_list": [
        {
          "fn_code": "local int log_lock(struct log *log)\n{\n    int fd;\n    struct stat st;\n\n    strcpy(log->end, \".lock\");\n    while ((fd = open(log->path, O_CREAT | O_EXCL, 0644)) < 0) {\n        if (errno != EEXIST)\n            return -1;\n        if (stat(log->path, &st) == 0 && time(NULL) - st.st_mtime > PATIENCE) {\n            unlink(log->path);\n            continue;\n        }\n        sleep(2);       /* relinquish the CPU for two seconds while waiting */\n    }\n    close(fd);\n    if (stat(log->path, &st) == 0)\n        log->lock = st.st_mtime;\n    return 0;\n}",
          "fn_code_pos": [
            [
              347,
              0
            ],
            [
              366,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "log_lock",
            "parameters": {
              "log": "struct log"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void log_touch(struct log *log)\n{\n    struct stat st;\n\n    strcpy(log->end, \".lock\");\n    utimes(log->path, NULL);\n    if (stat(log->path, &st) == 0)\n        log->lock = st.st_mtime;\n}",
          "fn_code_pos": [
            [
              371,
              0
            ],
            [
              379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "log_touch",
            "parameters": {
              "log": "struct log"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int log_check(struct log *log)\n{\n    struct stat st;\n\n    strcpy(log->end, \".lock\");\n    if (stat(log->path, &st) || st.st_mtime != log->lock)\n        return 1;\n    log_touch(log);\n    return 0;\n}",
          "fn_code_pos": [
            [
              383,
              0
            ],
            [
              392,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "log_check",
            "parameters": {
              "log": "struct log"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void log_unlock(struct log *log)\n{\n    if (log_check(log))\n        return;\n    strcpy(log->end, \".lock\");\n    unlink(log->path);\n    log->lock = 0;\n}",
          "fn_code_pos": [
            [
              395,
              0
            ],
            [
              402,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "log_unlock",
            "parameters": {
              "log": "struct log"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int log_head(struct log *log)\n{\n    int op;\n    unsigned char buf[HEAD + EXTRA];\n\n    if (lseek(log->fd, 0, SEEK_SET) < 0 ||\n        read(log->fd, buf, HEAD + EXTRA) != HEAD + EXTRA ||\n        memcmp(buf, log_gzhead, HEAD)) {\n        return -1;\n    }\n    log->first = PULL8(buf + HEAD);\n    log->last = PULL8(buf + HEAD + 8);\n    log->ccrc = PULL4(buf + HEAD + 16);\n    log->clen = PULL4(buf + HEAD + 20);\n    log->tcrc = PULL4(buf + HEAD + 24);\n    log->tlen = PULL4(buf + HEAD + 28);\n    log->stored = PULL2(buf + HEAD + 32);\n    log->back = 3 + (buf[HEAD + 34] & 7);\n    op = (buf[HEAD + 34] >> 3) & 3;\n    return op;\n}",
          "fn_code_pos": [
            [
              409,
              0
            ],
            [
              429,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "log_head",
            "parameters": {
              "log": "struct log"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int log_mark(struct log *log, int op)\n{\n    int ret;\n    unsigned char ext[EXTRA];\n\n    PUT8(ext, log->first);\n    PUT8(ext + 8, log->last);\n    PUT4(ext + 16, log->ccrc);\n    PUT4(ext + 20, log->clen);\n    PUT4(ext + 24, log->tcrc);\n    PUT4(ext + 28, log->tlen);\n    PUT2(ext + 32, log->stored);\n    ext[34] = log->back - 3 + (op << 3);\n    fsync(log->fd);\n    ret = lseek(log->fd, HEAD, SEEK_SET) < 0 ||\n          write(log->fd, ext, EXTRA) != EXTRA ? -1 : 0;\n    fsync(log->fd);\n    return ret;\n}",
          "fn_code_pos": [
            [
              436,
              0
            ],
            [
              454,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "log_mark",
            "parameters": {
              "log": "struct log",
              "op": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int log_last(struct log *log, int last)\n{\n    int back, len, mask;\n    unsigned char buf[6];\n\n    /* determine the locations of the bytes and bits to modify */\n    back = log->last == log->first ? log->back : 8;\n    len = back > 8 ? 2 : 1;                 /* bytes back from log->last */\n    mask = 0x80 >> ((back - 1) & 7);        /* mask for block last-bit */\n\n    /* get the byte to modify (one or two back) into buf[0] -- don't need to\n       read the byte if the last-bit is eight bits back, since in that case\n       the entire byte will be modified */\n    buf[0] = 0;\n    if (back != 8 && (lseek(log->fd, log->last - len, SEEK_SET) < 0 ||\n                      read(log->fd, buf, 1) != 1))\n        return -1;\n\n    /* change the last-bit of the last stored block as requested -- note\n       that all bits above the last-bit are set to zero, per the type bits\n       of a stored block being 00 and per the convention that the bits to\n       bring the stream to a byte boundary are also zeros */\n    buf[1] = 0;\n    buf[2 - len] = (*buf & (mask - 1)) + (last ? mask : 0);\n\n    /* write the modified stored block header and lengths, move the file\n       pointer to after the last stored block data */\n    PUT2(buf + 2, log->stored);\n    PUT2(buf + 4, log->stored ^ 0xffff);\n    return lseek(log->fd, log->last - len, SEEK_SET) < 0 ||\n           write(log->fd, buf + 2 - len, len + 4) != len + 4 ||\n           lseek(log->fd, log->stored, SEEK_CUR) < 0 ? -1 : 0;\n}",
          "fn_code_pos": [
            [
              461,
              0
            ],
            [
              493,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "log_last",
            "parameters": {
              "log": "struct log",
              "last": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int log_append(struct log *log, unsigned char *data, size_t len)\n{\n    uint put;\n    off_t end;\n    unsigned char buf[8];\n\n    /* set the last block last-bit and length, in case recovering an\n       interrupted append, then position the file pointer to append to the\n       block */\n    if (log_last(log, 1))\n        return -1;\n\n    /* append, adding stored blocks and updating the offset of the last stored\n       block as needed, and update the total crc and length */\n    while (len) {\n        /* append as much as we can to the last block */\n        put = (MAX_STORE << 10) - log->stored;\n        if (put > len)\n            put = (uint)len;\n        if (put) {\n            if (write(log->fd, data, put) != put)\n                return -1;\n            BAIL(1);\n            log->tcrc = crc32(log->tcrc, data, put);\n            log->tlen += put;\n            log->stored += put;\n            data += put;\n            len -= put;\n        }\n\n        /* if we need to, add a new empty stored block */\n        if (len) {\n            /* mark current block as not last */\n            if (log_last(log, 0))\n                return -1;\n\n            /* point to new, empty stored block */\n            log->last += 4 + log->stored + 1;\n            log->stored = 0;\n        }\n\n        /* mark last block as last, update its length */\n        if (log_last(log, 1))\n            return -1;\n        BAIL(2);\n    }\n\n    /* write the new crc and length trailer, and truncate just in case (could\n       be recovering from partial append with a missing foo.add file) */\n    PUT4(buf, log->tcrc);\n    PUT4(buf + 4, log->tlen);\n    if (write(log->fd, buf, 8) != 8 ||\n        (end = lseek(log->fd, 0, SEEK_CUR)) < 0 || ftruncate(log->fd, end))\n        return -1;\n\n    /* write the extra field, marking the log file as done, delete .add file */\n    if (log_mark(log, NO_OP))\n        return -1;\n    strcpy(log->end, \".add\");\n    unlink(log->path);          /* ignore error, since may not exist */\n    return 0;\n}",
          "fn_code_pos": [
            [
              500,
              0
            ],
            [
              561,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "log_append",
            "parameters": {
              "log": "struct log",
              "data": "unsigned char",
              "len": "size_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int log_replace(struct log *log)\n{\n    int ret;\n    char *dest;\n\n    /* delete foo.add file */\n    strcpy(log->end, \".add\");\n    unlink(log->path);         /* ignore error, since may not exist */\n    BAIL(3);\n\n    /* rename foo.name to foo.dict, replacing foo.dict if it exists */\n    strcpy(log->end, \".dict\");\n    dest = malloc(strlen(log->path) + 1);\n    if (dest == NULL)\n        return -2;\n    strcpy(dest, log->path);\n    strcpy(log->end, \".temp\");\n    ret = rename(log->path, dest);\n    free(dest);\n    if (ret && errno != ENOENT)\n        return -1;\n    BAIL(4);\n\n    /* mark the foo.gz file as done */\n    return log_mark(log, NO_OP);\n}",
          "fn_code_pos": [
            [
              570,
              0
            ],
            [
              595,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "log_replace",
            "parameters": {
              "log": "struct log"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int log_compress(struct log *log, unsigned char *data, size_t len)\n{\n    int fd;\n    uint got, max;\n    ssize_t dict;\n    off_t end;\n    z_stream strm;\n    unsigned char buf[DICT];\n\n    /* compress and append compressed data */\n    if (len) {\n        /* set up for deflate, allocating memory */\n        strm.zalloc = Z_NULL;\n        strm.zfree = Z_NULL;\n        strm.opaque = Z_NULL;\n        if (deflateInit2(&strm, Z_DEFAULT_COMPRESSION, Z_DEFLATED, -15, 8,\n                         Z_DEFAULT_STRATEGY) != Z_OK)\n            return -2;\n\n        /* read in dictionary (last 32K of data that was compressed) */\n        strcpy(log->end, \".dict\");\n        fd = open(log->path, O_RDONLY, 0);\n        if (fd >= 0) {\n            dict = read(fd, buf, DICT);\n            close(fd);\n            if (dict < 0) {\n                deflateEnd(&strm);\n                return -1;\n            }\n            if (dict)\n                deflateSetDictionary(&strm, buf, (uint)dict);\n        }\n        log_touch(log);\n\n        /* prime deflate with last bits of previous block, position write\n           pointer to write those bits and overwrite what follows */\n        if (lseek(log->fd, log->first - (log->back > 8 ? 2 : 1),\n                SEEK_SET) < 0 ||\n            read(log->fd, buf, 1) != 1 || lseek(log->fd, -1, SEEK_CUR) < 0) {\n            deflateEnd(&strm);\n            return -1;\n        }\n        deflatePrime(&strm, (8 - log->back) & 7, *buf);\n\n        /* compress, finishing with a partial non-last empty static block */\n        strm.next_in = data;\n        max = (((uint)0 - 1) >> 1) + 1; /* in case int smaller than size_t */\n        do {\n            strm.avail_in = len > max ? max : (uint)len;\n            len -= strm.avail_in;\n            do {\n                strm.avail_out = DICT;\n                strm.next_out = buf;\n                deflate(&strm, len ? Z_NO_FLUSH : Z_PARTIAL_FLUSH);\n                got = DICT - strm.avail_out;\n                if (got && write(log->fd, buf, got) != got) {\n                    deflateEnd(&strm);\n                    return -1;\n                }\n                log_touch(log);\n            } while (strm.avail_out == 0);\n        } while (len);\n        deflateEnd(&strm);\n        BAIL(5);\n\n        /* find start of empty static block -- scanning backwards the first one\n           bit is the second bit of the block, if the last byte is zero, then\n           we know the byte before that has a one in the top bit, since an\n           empty static block is ten bits long */\n        if ((log->first = lseek(log->fd, -1, SEEK_CUR)) < 0 ||\n            read(log->fd, buf, 1) != 1)\n            return -1;\n        log->first++;\n        if (*buf) {\n            log->back = 1;\n            while ((*buf & ((uint)1 << (8 - log->back++))) == 0)\n                ;       /* guaranteed to terminate, since *buf != 0 */\n        }\n        else\n            log->back = 10;\n\n        /* update compressed crc and length */\n        log->ccrc = log->tcrc;\n        log->clen = log->tlen;\n    }\n    else {\n        /* no data to compress -- fix up existing gzip stream */\n        log->tcrc = log->ccrc;\n        log->tlen = log->clen;\n    }\n\n    /* complete and truncate gzip stream */\n    log->last = log->first;\n    log->stored = 0;\n    PUT4(buf, log->tcrc);\n    PUT4(buf + 4, log->tlen);\n    if (log_last(log, 1) || write(log->fd, buf, 8) != 8 ||\n        (end = lseek(log->fd, 0, SEEK_CUR)) < 0 || ftruncate(log->fd, end))\n        return -1;\n    BAIL(6);\n\n    /* mark as being in the replace operation */\n    if (log_mark(log, REPLACE_OP))\n        return -1;\n\n    /* execute the replace operation and mark the file as done */\n    return log_replace(log);\n}",
          "fn_code_pos": [
            [
              607,
              0
            ],
            [
              714,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "log_compress",
            "parameters": {
              "log": "struct log",
              "data": "unsigned char",
              "len": "size_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void log_log(struct log *log, int op, char *record)\n{\n    time_t now;\n    FILE *rec;\n\n    now = time(NULL);\n    strcpy(log->end, \".repairs\");\n    rec = fopen(log->path, \"a\");\n    if (rec == NULL)\n        return;\n    fprintf(rec, \"%.24s %s recovery: %s\\n\", ctime(&now), op == APPEND_OP ?\n            \"append\" : (op == COMPRESS_OP ? \"compress\" : \"replace\"), record);\n    fclose(rec);\n    return;\n}",
          "fn_code_pos": [
            [
              717,
              0
            ],
            [
              731,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "log_log",
            "parameters": {
              "log": "struct log",
              "op": "int",
              "record": "char"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int log_recover(struct log *log, int op)\n{\n    int fd, ret = 0;\n    unsigned char *data = NULL;\n    size_t len = 0;\n    struct stat st;\n\n    /* log recovery */\n    log_log(log, op, \"start\");\n\n    /* load foo.add file if expected and present */\n    if (op == APPEND_OP || op == COMPRESS_OP) {\n        strcpy(log->end, \".add\");\n        if (stat(log->path, &st) == 0 && st.st_size) {\n            len = (size_t)(st.st_size);\n            if ((off_t)len != st.st_size ||\n                    (data = malloc(st.st_size)) == NULL) {\n                log_log(log, op, \"allocation failure\");\n                return -2;\n            }\n            if ((fd = open(log->path, O_RDONLY, 0)) < 0) {\n                free(data);\n                log_log(log, op, \".add file read failure\");\n                return -1;\n            }\n            ret = (size_t)read(fd, data, len) != len;\n            close(fd);\n            if (ret) {\n                free(data);\n                log_log(log, op, \".add file read failure\");\n                return -1;\n            }\n            log_log(log, op, \"loaded .add file\");\n        }\n        else\n            log_log(log, op, \"missing .add file!\");\n    }\n\n    /* recover the interrupted operation */\n    switch (op) {\n    case APPEND_OP:\n        ret = log_append(log, data, len);\n        break;\n    case COMPRESS_OP:\n        ret = log_compress(log, data, len);\n        break;\n    case REPLACE_OP:\n        ret = log_replace(log);\n    }\n\n    /* log status */\n    log_log(log, op, ret ? \"failure\" : \"complete\");\n\n    /* clean up */\n    if (data != NULL)\n        free(data);\n    return ret;\n}",
          "fn_code_pos": [
            [
              737,
              0
            ],
            [
              794,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "log_recover",
            "parameters": {
              "log": "struct log",
              "op": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void log_close(struct log *log)\n{\n    if (log->fd >= 0)\n        close(log->fd);\n    log->fd = -1;\n    log_unlock(log);\n}",
          "fn_code_pos": [
            [
              797,
              0
            ],
            [
              803,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "log_close",
            "parameters": {
              "log": "struct log"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int log_open(struct log *log)\n{\n    int op;\n\n    /* release open file resource if left over -- can occur if lock lost\n       between gzlog_open() and gzlog_write() */\n    if (log->fd >= 0)\n        close(log->fd);\n    log->fd = -1;\n\n    /* negotiate exclusive access */\n    if (log_lock(log) < 0)\n        return -1;\n\n    /* open the log file, foo.gz */\n    strcpy(log->end, \".gz\");\n    log->fd = open(log->path, O_RDWR | O_CREAT, 0644);\n    if (log->fd < 0) {\n        log_close(log);\n        return -1;\n    }\n\n    /* if new, initialize foo.gz with an empty log, delete old dictionary */\n    if (lseek(log->fd, 0, SEEK_END) == 0) {\n        if (write(log->fd, log_gzhead, HEAD) != HEAD ||\n            write(log->fd, log_gzext, EXTRA) != EXTRA ||\n            write(log->fd, log_gzbody, BODY) != BODY) {\n            log_close(log);\n            return -1;\n        }\n        strcpy(log->end, \".dict\");\n        unlink(log->path);\n    }\n\n    /* verify log file and load extra field information */\n    if ((op = log_head(log)) < 0) {\n        log_close(log);\n        return -1;\n    }\n\n    /* check for interrupted process and if so, recover */\n    if (op != NO_OP && log_recover(log, op)) {\n        log_close(log);\n        return -1;\n    }\n\n    /* touch the lock file to prevent another process from grabbing it */\n    log_touch(log);\n    return 0;\n}",
          "fn_code_pos": [
            [
              814,
              0
            ],
            [
              863,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "log_open",
            "parameters": {
              "log": "struct log"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "gzlog *gzlog_open(char *path)\n{\n    size_t n;\n    struct log *log;\n\n    /* check arguments */\n    if (path == NULL || *path == 0)\n        return NULL;\n\n    /* allocate and initialize log structure */\n    log = malloc(sizeof(struct log));\n    if (log == NULL)\n        return NULL;\n    strcpy(log->id, LOGID);\n    log->fd = -1;\n\n    /* save path and end of path for name construction */\n    n = strlen(path);\n    log->path = malloc(n + 9);              /* allow for \".repairs\" */\n    if (log->path == NULL) {\n        free(log);\n        return NULL;\n    }\n    strcpy(log->path, path);\n    log->end = log->path + n;\n\n    /* gain exclusive access and verify log file -- may perform a\n       recovery operation if needed */\n    if (log_open(log)) {\n        free(log->path);\n        free(log);\n        return NULL;\n    }\n\n    /* return pointer to log structure */\n    return log;\n}",
          "fn_code_pos": [
            [
              866,
              0
            ],
            [
              902,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzlog_open",
            "parameters": {
              "path": "char"
            },
            "return_type": "gzlog"
          }
        },
        {
          "fn_code": "int gzlog_compress(gzlog *logd)\n{\n    int fd, ret;\n    uint block;\n    size_t len, next;\n    unsigned char *data, buf[5];\n    struct log *log = logd;\n\n    /* check arguments */\n    if (log == NULL || strcmp(log->id, LOGID))\n        return -3;\n\n    /* see if we lost the lock -- if so get it again and reload the extra\n       field information (it probably changed), recover last operation if\n       necessary */\n    if (log_check(log) && log_open(log))\n        return -1;\n\n    /* create space for uncompressed data */\n    len = ((size_t)(log->last - log->first) & ~(((size_t)1 << 10) - 1)) +\n          log->stored;\n    if ((data = malloc(len)) == NULL)\n        return -2;\n\n    /* do statement here is just a cheap trick for error handling */\n    do {\n        /* read in the uncompressed data */\n        if (lseek(log->fd, log->first - 1, SEEK_SET) < 0)\n            break;\n        next = 0;\n        while (next < len) {\n            if (read(log->fd, buf, 5) != 5)\n                break;\n            block = PULL2(buf + 1);\n            if (next + block > len ||\n                read(log->fd, (char *)data + next, block) != block)\n                break;\n            next += block;\n        }\n        if (lseek(log->fd, 0, SEEK_CUR) != log->last + 4 + log->stored)\n            break;\n        log_touch(log);\n\n        /* write the uncompressed data to the .add file */\n        strcpy(log->end, \".add\");\n        fd = open(log->path, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n        if (fd < 0)\n            break;\n        ret = (size_t)write(fd, data, len) != len;\n        if (ret | close(fd))\n            break;\n        log_touch(log);\n\n        /* write the dictionary for the next compress to the .temp file */\n        strcpy(log->end, \".temp\");\n        fd = open(log->path, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n        if (fd < 0)\n            break;\n        next = DICT > len ? len : DICT;\n        ret = (size_t)write(fd, (char *)data + len - next, next) != next;\n        if (ret | close(fd))\n            break;\n        log_touch(log);\n\n        /* roll back to compressed data, mark the compress in progress */\n        log->last = log->first;\n        log->stored = 0;\n        if (log_mark(log, COMPRESS_OP))\n            break;\n        BAIL(7);\n\n        /* compress and append the data (clears mark) */\n        ret = log_compress(log, data, len);\n        free(data);\n        return ret;\n    } while (0);\n\n    /* broke out of do above on i/o error */\n    free(data);\n    return -1;\n}",
          "fn_code_pos": [
            [
              909,
              0
            ],
            [
              989,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzlog_compress",
            "parameters": {
              "logd": "gzlog"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int gzlog_write(gzlog *logd, void *data, size_t len)\n{\n    int fd, ret;\n    struct log *log = logd;\n\n    /* check arguments */\n    if (log == NULL || strcmp(log->id, LOGID))\n        return -3;\n    if (data == NULL || len <= 0)\n        return 0;\n\n    /* see if we lost the lock -- if so get it again and reload the extra\n       field information (it probably changed), recover last operation if\n       necessary */\n    if (log_check(log) && log_open(log))\n        return -1;\n\n    /* create and write .add file */\n    strcpy(log->end, \".add\");\n    fd = open(log->path, O_WRONLY | O_CREAT | O_TRUNC, 0644);\n    if (fd < 0)\n        return -1;\n    ret = (size_t)write(fd, data, len) != len;\n    if (ret | close(fd))\n        return -1;\n    log_touch(log);\n\n    /* mark log file with append in progress */\n    if (log_mark(log, APPEND_OP))\n        return -1;\n    BAIL(8);\n\n    /* append data (clears mark) */\n    if (log_append(log, data, len))\n        return -1;\n\n    /* check to see if it's time to compress -- if not, then done */\n    if (((log->last - log->first) >> 10) + (log->stored >> 10) < TRIGGER)\n        return 0;\n\n    /* time to compress */\n    return gzlog_compress(log);\n}",
          "fn_code_pos": [
            [
              996,
              0
            ],
            [
              1038,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzlog_write",
            "parameters": {
              "logd": "gzlog",
              "data": "void",
              "len": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int gzlog_close(gzlog *logd)\n{\n    struct log *log = logd;\n\n    /* check arguments */\n    if (log == NULL || strcmp(log->id, LOGID))\n        return -3;\n\n    /* close the log file and release the lock */\n    log_close(log);\n\n    /* free structure and return */\n    if (log->path != NULL)\n        free(log->path);\n    strcpy(log->id, \"bad\");\n    free(log);\n    return 0;\n}",
          "fn_code_pos": [
            [
              1043,
              0
            ],
            [
              1060,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzlog_close",
            "parameters": {
              "logd": "gzlog"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "gzlog_open(char *path)",
          "fn_dec_pos": [
            [
              866,
              7
            ],
            [
              866,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzlog_open",
            "parameters": {
              "path": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct log {\n    char id[4];     /* contains LOGID to detect inadvertent overwrites */\n    int fd;         /* file descriptor for .gz file, opened read/write */\n    char *path;     /* allocated path, e.g. \"/var/log/foo\" or \"foo\" */\n    char *end;      /* end of path, for appending suffices such as \".gz\" */\n    off_t first;    /* offset of first stored block first length byte */\n    int back;       /* location of first block id in bits back from first */\n    uint stored;    /* bytes currently in last stored block */\n    off_t last;     /* offset of last stored block first length byte */\n    ulong ccrc;     /* crc of compressed data */\n    ulong clen;     /* length (modulo 2^32) of compressed data */\n    ulong tcrc;     /* crc of total data */\n    ulong tlen;     /* length (modulo 2^32) of total data */\n    time_t lock;    /* last modify time of our lock file */\n}",
          {
            "id[4]": "char",
            "fd": "int",
            "*path": "char",
            "*end": "char",
            "first": "off_t",
            "back": "int",
            "stored": "uint",
            "last": "off_t",
            "ccrc": "ulong",
            "clen": "ulong",
            "tcrc": "ulong",
            "tlen": "ulong",
            "lock": "time_t"
          },
          "log",
          [
            288,
            0
          ],
          [
            302,
            1
          ]
        ],
        [
          "struct log {\n    char id[4];     /* contains LOGID to detect inadvertent overwrites */\n    int fd;         /* file descriptor for .gz file, opened read/write */\n    char *path;     /* allocated path, e.g. \"/var/log/foo\" or \"foo\" */\n    char *end;      /* end of path, for appending suffices such as \".gz\" */\n    off_t first;    /* offset of first stored block first length byte */\n    int back;       /* location of first block id in bits back from first */\n    uint stored;    /* bytes currently in last stored block */\n    off_t last;     /* offset of last stored block first length byte */\n    ulong ccrc;     /* crc of compressed data */\n    ulong clen;     /* length (modulo 2^32) of compressed data */\n    ulong tcrc;     /* crc of total data */\n    ulong tlen;     /* length (modulo 2^32) of total data */\n    time_t lock;    /* last modify time of our lock file */\n}",
          {
            "id[4]": "char",
            "fd": "int",
            "*path": "char",
            "*end": "char",
            "first": "off_t",
            "back": "int",
            "stored": "uint",
            "last": "off_t",
            "ccrc": "ulong",
            "clen": "ulong",
            "tcrc": "ulong",
            "tlen": "ulong",
            "lock": "time_t"
          },
          "log",
          [
            288,
            0
          ],
          [
            302,
            1
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            347,
            19
          ],
          [
            347,
            29
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            350,
            4
          ],
          [
            350,
            15
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            371,
            21
          ],
          [
            371,
            31
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            373,
            4
          ],
          [
            373,
            15
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            383,
            20
          ],
          [
            383,
            30
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            385,
            4
          ],
          [
            385,
            15
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            395,
            22
          ],
          [
            395,
            32
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            409,
            19
          ],
          [
            409,
            29
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            436,
            19
          ],
          [
            436,
            29
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            461,
            19
          ],
          [
            461,
            29
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            500,
            21
          ],
          [
            500,
            31
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            570,
            22
          ],
          [
            570,
            32
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            607,
            23
          ],
          [
            607,
            33
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            717,
            19
          ],
          [
            717,
            29
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            737,
            22
          ],
          [
            737,
            32
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            742,
            4
          ],
          [
            742,
            15
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            797,
            21
          ],
          [
            797,
            31
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            814,
            19
          ],
          [
            814,
            29
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            869,
            4
          ],
          [
            869,
            14
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            876,
            24
          ],
          [
            876,
            34
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            915,
            4
          ],
          [
            915,
            14
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            999,
            4
          ],
          [
            999,
            14
          ]
        ],
        [
          "struct log",
          {},
          "",
          [
            1045,
            4
          ],
          [
            1045,
            14
          ]
        ]
      ],
      "include_list": [
        [
          "#include <sys/types.h>\n",
          [
            225,
            0
          ],
          [
            226,
            0
          ]
        ],
        [
          "#include <stdio.h>      /* rename, fopen, fprintf, fclose */\n",
          [
            226,
            0
          ],
          [
            227,
            0
          ]
        ],
        [
          "#include <stdlib.h>     /* malloc, free */\n",
          [
            227,
            0
          ],
          [
            228,
            0
          ]
        ],
        [
          "#include <string.h>     /* strlen, strrchr, strcpy, strncpy, strcmp */\n",
          [
            228,
            0
          ],
          [
            229,
            0
          ]
        ],
        [
          "#include <fcntl.h>      /* open */\n",
          [
            229,
            0
          ],
          [
            230,
            0
          ]
        ],
        [
          "#include <unistd.h>     /* lseek, read, write, close, unlink, sleep, */\n",
          [
            230,
            0
          ],
          [
            231,
            0
          ]
        ],
        [
          "#include <errno.h>      /* errno */\n",
          [
            232,
            0
          ],
          [
            233,
            0
          ]
        ],
        [
          "#include <time.h>       /* time, ctime */\n",
          [
            233,
            0
          ],
          [
            234,
            0
          ]
        ],
        [
          "#include <sys/stat.h>   /* stat */\n",
          [
            234,
            0
          ],
          [
            235,
            0
          ]
        ],
        [
          "#include <sys/time.h>   /* utimes */\n",
          [
            235,
            0
          ],
          [
            236,
            0
          ]
        ],
        [
          "#include \"zlib.h\"       /* crc32 */\n",
          [
            236,
            0
          ],
          [
            237,
            0
          ]
        ],
        [
          "#include \"gzlog.h\"      /* header for external access */\n",
          [
            238,
            0
          ],
          [
            239,
            0
          ]
        ],
        [
          "#include <setjmp.h>         /* longjmp */\n",
          [
            246,
            4
          ],
          [
            247,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/examples/gun.c": {
      "fn_def_list": [
        {
          "fn_code": "local unsigned in(void *in_desc, z_const unsigned char **buf)\n{\n    int ret;\n    unsigned len;\n    unsigned char *next;\n    struct ind *me = (struct ind *)in_desc;\n\n    next = me->inbuf;\n    *buf = next;\n    len = 0;\n    do {\n        ret = PIECE;\n        if ((unsigned)ret > SIZE - len)\n            ret = (int)(SIZE - len);\n        ret = (int)read(me->infile, next, ret);\n        if (ret == -1) {\n            len = 0;\n            break;\n        }\n        next += ret;\n        len += ret;\n    } while (ret != 0 && len < SIZE);\n    return len;\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "in",
            "parameters": {
              "in_desc": "void",
              "char": "z_const unsigned"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "local int out(void *out_desc, unsigned char *buf, unsigned len)\n{\n    int ret;\n    struct outd *me = (struct outd *)out_desc;\n\n    if (me->check) {\n        me->crc = crc32(me->crc, buf, len);\n        me->total += len;\n    }\n    if (me->outfile != -1)\n        do {\n            ret = PIECE;\n            if ((unsigned)ret > len)\n                ret = (int)len;\n            ret = (int)write(me->outfile, buf, ret);\n            if (ret == -1)\n                return 1;\n            buf += ret;\n            len -= ret;\n        } while (len != 0);\n    return 0;\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              151,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "out",
            "parameters": {
              "out_desc": "void",
              "buf": "unsigned char",
              "len": "unsigned"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int lunpipe(unsigned have, z_const unsigned char *next, struct ind *indp,\n                  int outfile, z_stream *strm)\n{\n    int last;                   /* last byte read by NEXT(), or -1 if EOF */\n    unsigned chunk;             /* bytes left in current chunk */\n    int left;                   /* bits left in rem */\n    unsigned rem;               /* unused bits from input */\n    int bits;                   /* current bits per code */\n    unsigned code;              /* code, table traversal index */\n    unsigned mask;              /* mask for current bits codes */\n    int max;                    /* maximum bits per code for this stream */\n    unsigned flags;             /* compress flags, then block compress flag */\n    unsigned end;               /* last valid entry in prefix/suffix tables */\n    unsigned temp;              /* current code */\n    unsigned prev;              /* previous code */\n    unsigned final;             /* last character written for previous code */\n    unsigned stack;             /* next position for reversed string */\n    unsigned outcnt;            /* bytes in output buffer */\n    struct outd outd;           /* output structure */\n    unsigned char *p;\n\n    /* set up output */\n    outd.outfile = outfile;\n    outd.check = 0;\n\n    /* process remainder of compress header -- a flags byte */\n    flags = NEXT();\n    if (last == -1)\n        return Z_BUF_ERROR;\n    if (flags & 0x60) {\n        strm->msg = (z_const char *)\"unknown lzw flags set\";\n        return Z_DATA_ERROR;\n    }\n    max = flags & 0x1f;\n    if (max < 9 || max > 16) {\n        strm->msg = (z_const char *)\"lzw bits out of range\";\n        return Z_DATA_ERROR;\n    }\n    if (max == 9)                           /* 9 doesn't really mean 9 */\n        max = 10;\n    flags &= 0x80;                          /* true if block compress */\n\n    /* clear table */\n    bits = 9;\n    mask = 0x1ff;\n    end = flags ? 256 : 255;\n\n    /* set up: get first 9-bit code, which is the first decompressed byte, but\n       don't create a table entry until the next code */\n    if (NEXT() == -1)                       /* no compressed data is ok */\n        return Z_OK;\n    final = prev = (unsigned)last;          /* low 8 bits of code */\n    if (NEXT() == -1)                       /* missing a bit */\n        return Z_BUF_ERROR;\n    if (last & 1) {                         /* code must be < 256 */\n        strm->msg = (z_const char *)\"invalid lzw code\";\n        return Z_DATA_ERROR;\n    }\n    rem = (unsigned)last >> 1;              /* remaining 7 bits */\n    left = 7;\n    chunk = bits - 2;                       /* 7 bytes left in this chunk */\n    outbuf[0] = (unsigned char)final;       /* write first decompressed byte */\n    outcnt = 1;\n\n    /* decode codes */\n    stack = 0;\n    for (;;) {\n        /* if the table will be full after this, increment the code size */\n        if (end >= mask && bits < max) {\n            FLUSHCODE();\n            bits++;\n            mask <<= 1;\n            mask++;\n        }\n\n        /* get a code of length bits */\n        if (chunk == 0)                     /* decrement chunk modulo bits */\n            chunk = bits;\n        code = rem;                         /* low bits of code */\n        if (NEXT() == -1) {                 /* EOF is end of compressed data */\n            /* write remaining buffered output */\n            if (outcnt && out(&outd, outbuf, outcnt)) {\n                strm->next_in = outbuf;     /* signal write error */\n                return Z_BUF_ERROR;\n            }\n            return Z_OK;\n        }\n        code += (unsigned)last << left;     /* middle (or high) bits of code */\n        left += 8;\n        chunk--;\n        if (bits > left) {                  /* need more bits */\n            if (NEXT() == -1)               /* can't end in middle of code */\n                return Z_BUF_ERROR;\n            code += (unsigned)last << left; /* high bits of code */\n            left += 8;\n            chunk--;\n        }\n        code &= mask;                       /* mask to current code length */\n        left -= bits;                       /* number of unused bits */\n        rem = (unsigned)last >> (8 - left); /* unused bits from last byte */\n\n        /* process clear code (256) */\n        if (code == 256 && flags) {\n            FLUSHCODE();\n            bits = 9;                       /* initialize bits and mask */\n            mask = 0x1ff;\n            end = 255;                      /* empty table */\n            continue;                       /* get next code */\n        }\n\n        /* special code to reuse last match */\n        temp = code;                        /* save the current code */\n        if (code > end) {\n            /* Be picky on the allowed code here, and make sure that the code\n               we drop through (prev) will be a valid index so that random\n               input does not cause an exception.  The code != end + 1 check is\n               empirically derived, and not checked in the original uncompress\n               code.  If this ever causes a problem, that check could be safely\n               removed.  Leaving this check in greatly improves gun's ability\n               to detect random or corrupted input after a compress header.\n               In any case, the prev > end check must be retained. */\n            if (code != end + 1 || prev > end) {\n                strm->msg = (z_const char *)\"invalid lzw code\";\n                return Z_DATA_ERROR;\n            }\n            match[stack++] = (unsigned char)final;\n            code = prev;\n        }\n\n        /* walk through linked list to generate output in reverse order */\n        p = match + stack;\n        while (code >= 256) {\n            *p++ = suffix[code];\n            code = prefix[code];\n        }\n        stack = p - match;\n        match[stack++] = (unsigned char)code;\n        final = code;\n\n        /* link new table entry */\n        if (end < mask) {\n            end++;\n            prefix[end] = (unsigned short)prev;\n            suffix[end] = (unsigned char)final;\n        }\n\n        /* set previous code for next iteration */\n        prev = temp;\n\n        /* write output in forward order */\n        while (stack > SIZE - outcnt) {\n            while (outcnt < SIZE)\n                outbuf[outcnt++] = match[--stack];\n            if (out(&outd, outbuf, outcnt)) {\n                strm->next_in = outbuf; /* signal write error */\n                return Z_BUF_ERROR;\n            }\n            outcnt = 0;\n        }\n        p = match + stack;\n        do {\n            outbuf[outcnt++] = *--p;\n        } while (p > match);\n        stack = 0;\n\n        /* loop for next code with final and prev as the last match, rem and\n           left provide the first 0..7 bits of the next code, end is the last\n           valid table entry */\n    }\n}",
          "fn_code_pos": [
            [
              199,
              0
            ],
            [
              368,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lunpipe",
            "parameters": {
              "have": "unsigned",
              "char": "z_const unsigned",
              "indp": "struct ind",
              "outfile": "int",
              "strm": "z_stream"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int gunpipe(z_stream *strm, int infile, int outfile)\n{\n    int ret, first, last;\n    unsigned have, flags, len;\n    z_const unsigned char *next = NULL;\n    struct ind ind, *indp;\n    struct outd outd;\n\n    /* setup input buffer */\n    ind.infile = infile;\n    ind.inbuf = inbuf;\n    indp = &ind;\n\n    /* decompress concatenated gzip streams */\n    have = 0;                               /* no input data read in yet */\n    first = 1;                              /* looking for first gzip header */\n    strm->next_in = Z_NULL;                 /* so Z_BUF_ERROR means EOF */\n    for (;;) {\n        /* look for the two magic header bytes for a gzip stream */\n        if (NEXT() == -1) {\n            ret = Z_OK;\n            break;                          /* empty gzip stream is ok */\n        }\n        if (last != 31 || (NEXT() != 139 && last != 157)) {\n            strm->msg = (z_const char *)\"incorrect header check\";\n            ret = first ? Z_DATA_ERROR : Z_ERRNO;\n            break;                          /* not a gzip or compress header */\n        }\n        first = 0;                          /* next non-header is junk */\n\n        /* process a compress (LZW) file -- can't be concatenated after this */\n        if (last == 157) {\n            ret = lunpipe(have, next, indp, outfile, strm);\n            break;\n        }\n\n        /* process remainder of gzip header */\n        ret = Z_BUF_ERROR;\n        if (NEXT() != 8) {                  /* only deflate method allowed */\n            if (last == -1) break;\n            strm->msg = (z_const char *)\"unknown compression method\";\n            ret = Z_DATA_ERROR;\n            break;\n        }\n        flags = NEXT();                     /* header flags */\n        NEXT();                             /* discard mod time, xflgs, os */\n        NEXT();\n        NEXT();\n        NEXT();\n        NEXT();\n        NEXT();\n        if (last == -1) break;\n        if (flags & 0xe0) {\n            strm->msg = (z_const char *)\"unknown header flags set\";\n            ret = Z_DATA_ERROR;\n            break;\n        }\n        if (flags & 4) {                    /* extra field */\n            len = NEXT();\n            len += (unsigned)(NEXT()) << 8;\n            if (last == -1) break;\n            while (len > have) {\n                len -= have;\n                have = 0;\n                if (NEXT() == -1) break;\n                len--;\n            }\n            if (last == -1) break;\n            have -= len;\n            next += len;\n        }\n        if (flags & 8)                      /* file name */\n            while (NEXT() != 0 && last != -1)\n                ;\n        if (flags & 16)                     /* comment */\n            while (NEXT() != 0 && last != -1)\n                ;\n        if (flags & 2) {                    /* header crc */\n            NEXT();\n            NEXT();\n        }\n        if (last == -1) break;\n\n        /* set up output */\n        outd.outfile = outfile;\n        outd.check = 1;\n        outd.crc = crc32(0L, Z_NULL, 0);\n        outd.total = 0;\n\n        /* decompress data to output */\n        strm->next_in = next;\n        strm->avail_in = have;\n        ret = inflateBack(strm, in, indp, out, &outd);\n        if (ret != Z_STREAM_END) break;\n        next = strm->next_in;\n        have = strm->avail_in;\n        strm->next_in = Z_NULL;             /* so Z_BUF_ERROR means EOF */\n\n        /* check trailer */\n        ret = Z_BUF_ERROR;\n        if (NEXT() != (int)(outd.crc & 0xff) ||\n            NEXT() != (int)((outd.crc >> 8) & 0xff) ||\n            NEXT() != (int)((outd.crc >> 16) & 0xff) ||\n            NEXT() != (int)((outd.crc >> 24) & 0xff)) {\n            /* crc error */\n            if (last != -1) {\n                strm->msg = (z_const char *)\"incorrect data check\";\n                ret = Z_DATA_ERROR;\n            }\n            break;\n        }\n        if (NEXT() != (int)(outd.total & 0xff) ||\n            NEXT() != (int)((outd.total >> 8) & 0xff) ||\n            NEXT() != (int)((outd.total >> 16) & 0xff) ||\n            NEXT() != (int)((outd.total >> 24) & 0xff)) {\n            /* length error */\n            if (last != -1) {\n                strm->msg = (z_const char *)\"incorrect length check\";\n                ret = Z_DATA_ERROR;\n            }\n            break;\n        }\n\n        /* go back and look for another gzip stream */\n    }\n\n    /* clean up and return */\n    return ret;\n}",
          "fn_code_pos": [
            [
              382,
              0
            ],
            [
              510,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gunpipe",
            "parameters": {
              "strm": "z_stream",
              "infile": "int",
              "outfile": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void copymeta(char *from, char *to)\n{\n    struct stat was;\n    struct utimbuf when;\n\n    /* get all of from's Unix meta data, return if not a regular file */\n    if (stat(from, &was) != 0 || (was.st_mode & S_IFMT) != S_IFREG)\n        return;\n\n    /* set to's mode bits, ignore errors */\n    (void)chmod(to, was.st_mode & 07777);\n\n    /* copy owner's user and group, ignore errors */\n    (void)chown(to, was.st_uid, was.st_gid);\n\n    /* copy access and modify times, ignore errors */\n    when.actime = was.st_atime;\n    when.modtime = was.st_mtime;\n    (void)utime(to, &when);\n}",
          "fn_code_pos": [
            [
              516,
              0
            ],
            [
              535,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copymeta",
            "parameters": {
              "from": "char",
              "to": "char"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int gunzip(z_stream *strm, char *inname, char *outname, int test)\n{\n    int ret;\n    int infile, outfile;\n\n    /* open files */\n    if (inname == NULL || *inname == 0) {\n        inname = \"-\";\n        infile = 0;     /* stdin */\n    }\n    else {\n        infile = open(inname, O_RDONLY, 0);\n        if (infile == -1) {\n            fprintf(stderr, \"gun cannot open %s\\n\", inname);\n            return 0;\n        }\n    }\n    if (test)\n        outfile = -1;\n    else if (outname == NULL || *outname == 0) {\n        outname = \"-\";\n        outfile = 1;    /* stdout */\n    }\n    else {\n        outfile = open(outname, O_CREAT | O_TRUNC | O_WRONLY, 0666);\n        if (outfile == -1) {\n            close(infile);\n            fprintf(stderr, \"gun cannot create %s\\n\", outname);\n            return 0;\n        }\n    }\n    errno = 0;\n\n    /* decompress */\n    ret = gunpipe(strm, infile, outfile);\n    if (outfile > 2) close(outfile);\n    if (infile > 2) close(infile);\n\n    /* interpret result */\n    switch (ret) {\n    case Z_OK:\n    case Z_ERRNO:\n        if (infile > 2 && outfile > 2) {\n            copymeta(inname, outname);          /* copy attributes */\n            unlink(inname);\n        }\n        if (ret == Z_ERRNO)\n            fprintf(stderr, \"gun warning: trailing garbage ignored in %s\\n\",\n                    inname);\n        break;\n    case Z_DATA_ERROR:\n        if (outfile > 2) unlink(outname);\n        fprintf(stderr, \"gun data error on %s: %s\\n\", inname, strm->msg);\n        break;\n    case Z_MEM_ERROR:\n        if (outfile > 2) unlink(outname);\n        fprintf(stderr, \"gun out of memory error--aborting\\n\");\n        return 1;\n    case Z_BUF_ERROR:\n        if (outfile > 2) unlink(outname);\n        if (strm->next_in != Z_NULL) {\n            fprintf(stderr, \"gun write error on %s: %s\\n\",\n                    outname, strerror(errno));\n        }\n        else if (errno) {\n            fprintf(stderr, \"gun read error on %s: %s\\n\",\n                    inname, strerror(errno));\n        }\n        else {\n            fprintf(stderr, \"gun unexpected end of file on %s\\n\",\n                    inname);\n        }\n        break;\n    default:\n        if (outfile > 2) unlink(outname);\n        fprintf(stderr, \"gun internal error--aborting\\n\");\n        return 1;\n    }\n    return 0;\n}",
          "fn_code_pos": [
            [
              547,
              0
            ],
            [
              626,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gunzip",
            "parameters": {
              "strm": "z_stream",
              "inname": "char",
              "outname": "char",
              "test": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int main(int argc, char **argv)\n{\n    int ret, len, test;\n    char *outname;\n    unsigned char *window;\n    z_stream strm;\n\n    /* initialize inflateBack state for repeated use */\n    window = match;                         /* reuse LZW match buffer */\n    strm.zalloc = Z_NULL;\n    strm.zfree = Z_NULL;\n    strm.opaque = Z_NULL;\n    ret = inflateBackInit(&strm, 15, window);\n    if (ret != Z_OK) {\n        fprintf(stderr, \"gun out of memory error--aborting\\n\");\n        return 1;\n    }\n\n    /* decompress each file to the same name with the suffix removed */\n    argc--;\n    argv++;\n    test = 0;\n    if (argc && strcmp(*argv, \"-h\") == 0) {\n        fprintf(stderr, \"gun 1.6 (17 Jan 2010)\\n\");\n        fprintf(stderr, \"Copyright (C) 2003-2010 Mark Adler\\n\");\n        fprintf(stderr, \"usage: gun [-t] [file1.gz [file2.Z ...]]\\n\");\n        return 0;\n    }\n    if (argc && strcmp(*argv, \"-t\") == 0) {\n        test = 1;\n        argc--;\n        argv++;\n    }\n    if (argc)\n        do {\n            if (test)\n                outname = NULL;\n            else {\n                len = (int)strlen(*argv);\n                if (strcmp(*argv + len - 3, \".gz\") == 0 ||\n                    strcmp(*argv + len - 3, \"-gz\") == 0)\n                    len -= 3;\n                else if (strcmp(*argv + len - 2, \".z\") == 0 ||\n                    strcmp(*argv + len - 2, \"-z\") == 0 ||\n                    strcmp(*argv + len - 2, \"_z\") == 0 ||\n                    strcmp(*argv + len - 2, \".Z\") == 0)\n                    len -= 2;\n                else {\n                    fprintf(stderr, \"gun error: no gz type on %s--skipping\\n\",\n                            *argv);\n                    continue;\n                }\n                outname = malloc(len + 1);\n                if (outname == NULL) {\n                    fprintf(stderr, \"gun out of memory error--aborting\\n\");\n                    ret = 1;\n                    break;\n                }\n                memcpy(outname, *argv, len);\n                outname[len] = 0;\n            }\n            ret = gunzip(&strm, *argv, outname, test);\n            if (outname != NULL) free(outname);\n            if (ret) break;\n        } while (argv++, --argc);\n    else\n        ret = gunzip(&strm, NULL, NULL, test);\n\n    /* clean up */\n    inflateBackEnd(&strm);\n    return ret;\n}",
          "fn_code_pos": [
            [
              630,
              0
            ],
            [
              701,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct ind {\n    int infile;\n    unsigned char *inbuf;\n}",
          {
            "infile": "int",
            "*inbuf": "unsigned char"
          },
          "ind",
          [
            80,
            0
          ],
          [
            83,
            1
          ]
        ],
        [
          "struct outd {\n    int outfile;\n    int check;                  /* true if checking crc and total */\n    unsigned long crc;\n    unsigned long total;\n}",
          {
            "outfile": "int",
            "check": "int",
            "crc": "unsigned long",
            "total": "unsigned long"
          },
          "outd",
          [
            118,
            0
          ],
          [
            123,
            1
          ]
        ],
        [
          "struct ind {\n    int infile;\n    unsigned char *inbuf;\n}",
          {
            "infile": "int",
            "*inbuf": "unsigned char"
          },
          "ind",
          [
            80,
            0
          ],
          [
            83,
            1
          ]
        ],
        [
          "struct ind",
          {},
          "",
          [
            93,
            4
          ],
          [
            93,
            14
          ]
        ],
        [
          "struct ind",
          {},
          "",
          [
            93,
            22
          ],
          [
            93,
            32
          ]
        ],
        [
          "struct outd {\n    int outfile;\n    int check;                  /* true if checking crc and total */\n    unsigned long crc;\n    unsigned long total;\n}",
          {
            "outfile": "int",
            "check": "int",
            "crc": "unsigned long",
            "total": "unsigned long"
          },
          "outd",
          [
            118,
            0
          ],
          [
            123,
            1
          ]
        ],
        [
          "struct outd",
          {},
          "",
          [
            133,
            4
          ],
          [
            133,
            15
          ]
        ],
        [
          "struct outd",
          {},
          "",
          [
            133,
            23
          ],
          [
            133,
            34
          ]
        ],
        [
          "struct ind",
          {},
          "",
          [
            199,
            62
          ],
          [
            199,
            72
          ]
        ],
        [
          "struct outd",
          {},
          "",
          [
            217,
            4
          ],
          [
            217,
            15
          ]
        ],
        [
          "struct ind",
          {},
          "",
          [
            387,
            4
          ],
          [
            387,
            14
          ]
        ],
        [
          "struct outd",
          {},
          "",
          [
            388,
            4
          ],
          [
            388,
            15
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            518,
            4
          ],
          [
            518,
            15
          ]
        ],
        [
          "struct utimbuf",
          {},
          "",
          [
            519,
            4
          ],
          [
            519,
            18
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>          /* fprintf() */\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ],
        [
          "#include <stdlib.h>         /* malloc(), free() */\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include <string.h>         /* strerror(), strcmp(), strlen(), memcpy() */\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ],
        [
          "#include <errno.h>          /* errno */\n",
          [
            62,
            0
          ],
          [
            63,
            0
          ]
        ],
        [
          "#include <fcntl.h>          /* open() */\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include <unistd.h>         /* read(), write(), close(), chown(), unlink() */\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            65,
            0
          ],
          [
            66,
            0
          ]
        ],
        [
          "#include <sys/stat.h>       /* stat(), chmod() */\n",
          [
            66,
            0
          ],
          [
            67,
            0
          ]
        ],
        [
          "#include <utime.h>          /* utime() */\n",
          [
            67,
            0
          ],
          [
            68,
            0
          ]
        ],
        [
          "#include \"zlib.h\"           /* inflateBackInit(), inflateBack(), */\n",
          [
            68,
            0
          ],
          [
            69,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/examples/gzappend.c": {
      "fn_def_list": [
        {
          "fn_code": "local void bye(char *msg1, char *msg2)\n{\n    fprintf(stderr, \"gzappend error: %s%s\\n\", msg1, msg2);\n    exit(1);\n}",
          "fn_code_pos": [
            [
              92,
              0
            ],
            [
              96,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "bye",
            "parameters": {
              "msg1": "char",
              "msg2": "char"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local unsigned gcd(unsigned a, unsigned b)\n{\n    unsigned c;\n\n    while (a && b)\n        if (a > b) {\n            c = b;\n            while (a - c >= c)\n                c <<= 1;\n            a -= c;\n        }\n        else {\n            c = a;\n            while (b - c >= c)\n                c <<= 1;\n            b -= c;\n        }\n    return a + b;\n}",
          "fn_code_pos": [
            [
              101,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gcd",
            "parameters": {
              "a": "unsigned",
              "b": "unsigned"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "local void rotate(unsigned char *list, unsigned len, unsigned rot)\n{\n    unsigned char tmp;\n    unsigned cycles;\n    unsigned char *start, *last, *to, *from;\n\n    /* normalize rot and handle degenerate cases */\n    if (len < 2) return;\n    if (rot >= len) rot %= len;\n    if (rot == 0) return;\n\n    /* pointer to last entry in list */\n    last = list + (len - 1);\n\n    /* do simple left shift by one */\n    if (rot == 1) {\n        tmp = *list;\n        memmove(list, list + 1, len - 1);\n        *last = tmp;\n        return;\n    }\n\n    /* do simple right shift by one */\n    if (rot == len - 1) {\n        tmp = *last;\n        memmove(list + 1, list, len - 1);\n        *list = tmp;\n        return;\n    }\n\n    /* otherwise do rotate as a set of cycles in place */\n    cycles = gcd(len, rot);             /* number of cycles */\n    do {\n        start = from = list + cycles;   /* start index is arbitrary */\n        tmp = *from;                    /* save entry to be overwritten */\n        for (;;) {\n            to = from;                  /* next step in cycle */\n            from += rot;                /* go right rot positions */\n            if (from > last) from -= len;   /* (pointer better not wrap) */\n            if (from == start) break;   /* all but one shifted */\n            *to = *from;                /* shift left */\n        }\n        *to = tmp;                      /* complete the circle */\n    } while (--cycles);\n}",
          "fn_code_pos": [
            [
              122,
              0
            ],
            [
              166,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rotate",
            "parameters": {
              "list": "unsigned char",
              "len": "unsigned",
              "rot": "unsigned"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int readin(file *in)\n{\n    int len;\n\n    len = read(in->fd, in->buf, 1 << in->size);\n    if (len == -1) bye(\"error reading \", in->name);\n    in->left = (unsigned)len;\n    in->next = in->buf;\n    return len;\n}",
          "fn_code_pos": [
            [
              179,
              0
            ],
            [
              188,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readin",
            "parameters": {
              "in": "file"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int readmore(file *in)\n{\n    if (readin(in) == 0) bye(\"unexpected end of \", in->name);\n    return 0;\n}",
          "fn_code_pos": [
            [
              191,
              0
            ],
            [
              195,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readmore",
            "parameters": {
              "in": "file"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void skip(file *in, unsigned n)\n{\n    unsigned bypass;\n\n    if (n > in->left) {\n        n -= in->left;\n        bypass = n & ~((1U << in->size) - 1);\n        if (bypass) {\n            if (lseek(in->fd, (off_t)bypass, SEEK_CUR) == -1)\n                bye(\"seeking \", in->name);\n            n -= bypass;\n        }\n        readmore(in);\n        if (n > in->left)\n            bye(\"unexpected end of \", in->name);\n    }\n    in->left -= n;\n    in->next += n;\n}",
          "fn_code_pos": [
            [
              201,
              0
            ],
            [
              219,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "skip",
            "parameters": {
              "in": "file",
              "n": "unsigned"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "unsigned long read4(file *in)\n{\n    unsigned long val;\n\n    val = read1(in);\n    val += (unsigned)read1(in) << 8;\n    val += (unsigned long)read1(in) << 16;\n    val += (unsigned long)read1(in) << 24;\n    return val;\n}",
          "fn_code_pos": [
            [
              222,
              0
            ],
            [
              231,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read4",
            "parameters": {
              "in": "file"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "local void gzheader(file *in)\n{\n    int flags;\n    unsigned n;\n\n    if (read1(in) != 31 || read1(in) != 139) bye(in->name, \" not a gzip file\");\n    if (read1(in) != 8) bye(\"unknown compression method in\", in->name);\n    flags = read1(in);\n    if (flags & 0xe0) bye(\"unknown header flags set in\", in->name);\n    skip(in, 6);\n    if (flags & 4) {\n        n = read1(in);\n        n += (unsigned)(read1(in)) << 8;\n        skip(in, n);\n    }\n    if (flags & 8) while (read1(in) != 0) ;\n    if (flags & 16) while (read1(in) != 0) ;\n    if (flags & 2) skip(in, 2);\n}",
          "fn_code_pos": [
            [
              234,
              0
            ],
            [
              252,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzheader",
            "parameters": {
              "in": "file"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local int gzscan(char *name, z_stream *strm, int level)\n{\n    int ret, lastbit, left, full;\n    unsigned have;\n    unsigned long crc, tot;\n    unsigned char *window;\n    off_t lastoff, end;\n    file gz;\n\n    /* open gzip file */\n    gz.name = name;\n    gz.fd = open(name, O_RDWR, 0);\n    if (gz.fd == -1) bye(\"cannot open \", name);\n    gz.buf = malloc(CHUNK);\n    if (gz.buf == NULL) bye(\"out of memory\", \"\");\n    gz.size = LGCHUNK;\n    gz.left = 0;\n\n    /* skip gzip header */\n    gzheader(&gz);\n\n    /* prepare to decompress */\n    window = malloc(DSIZE);\n    if (window == NULL) bye(\"out of memory\", \"\");\n    strm->zalloc = Z_NULL;\n    strm->zfree = Z_NULL;\n    strm->opaque = Z_NULL;\n    ret = inflateInit2(strm, -15);\n    if (ret != Z_OK) bye(\"out of memory\", \" or library mismatch\");\n\n    /* decompress the deflate stream, saving append information */\n    lastbit = 0;\n    lastoff = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;\n    left = 0;\n    strm->avail_in = gz.left;\n    strm->next_in = gz.next;\n    crc = crc32(0L, Z_NULL, 0);\n    have = full = 0;\n    do {\n        /* if needed, get more input */\n        if (strm->avail_in == 0) {\n            readmore(&gz);\n            strm->avail_in = gz.left;\n            strm->next_in = gz.next;\n        }\n\n        /* set up output to next available section of sliding window */\n        strm->avail_out = DSIZE - have;\n        strm->next_out = window + have;\n\n        /* inflate and check for errors */\n        ret = inflate(strm, Z_BLOCK);\n        if (ret == Z_STREAM_ERROR) bye(\"internal stream error!\", \"\");\n        if (ret == Z_MEM_ERROR) bye(\"out of memory\", \"\");\n        if (ret == Z_DATA_ERROR)\n            bye(\"invalid compressed data--format violated in\", name);\n\n        /* update crc and sliding window pointer */\n        crc = crc32(crc, window + have, DSIZE - have - strm->avail_out);\n        if (strm->avail_out)\n            have = DSIZE - strm->avail_out;\n        else {\n            have = 0;\n            full = 1;\n        }\n\n        /* process end of block */\n        if (strm->data_type & 128) {\n            if (strm->data_type & 64)\n                left = strm->data_type & 0x1f;\n            else {\n                lastbit = strm->data_type & 0x1f;\n                lastoff = lseek(gz.fd, 0L, SEEK_CUR) - strm->avail_in;\n            }\n        }\n    } while (ret != Z_STREAM_END);\n    inflateEnd(strm);\n    gz.left = strm->avail_in;\n    gz.next = strm->next_in;\n\n    /* save the location of the end of the compressed data */\n    end = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;\n\n    /* check gzip trailer and save total for deflate */\n    if (crc != read4(&gz))\n        bye(\"invalid compressed data--crc mismatch in \", name);\n    tot = strm->total_out;\n    if ((tot & 0xffffffffUL) != read4(&gz))\n        bye(\"invalid compressed data--length mismatch in\", name);\n\n    /* if not at end of file, warn */\n    if (gz.left || readin(&gz))\n        fprintf(stderr,\n            \"gzappend warning: junk at end of gzip file overwritten\\n\");\n\n    /* clear last block bit */\n    lseek(gz.fd, lastoff - (lastbit != 0), SEEK_SET);\n    if (read(gz.fd, gz.buf, 1) != 1) bye(\"reading after seek on \", name);\n    *gz.buf = (unsigned char)(*gz.buf ^ (1 << ((8 - lastbit) & 7)));\n    lseek(gz.fd, -1L, SEEK_CUR);\n    if (write(gz.fd, gz.buf, 1) != 1) bye(\"writing after seek to \", name);\n\n    /* if window wrapped, build dictionary from window by rotating */\n    if (full) {\n        rotate(window, DSIZE, have);\n        have = DSIZE;\n    }\n\n    /* set up deflate stream with window, crc, total_in, and leftover bits */\n    ret = deflateInit2(strm, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);\n    if (ret != Z_OK) bye(\"out of memory\", \"\");\n    deflateSetDictionary(strm, window, have);\n    strm->adler = crc;\n    strm->total_in = tot;\n    if (left) {\n        lseek(gz.fd, --end, SEEK_SET);\n        if (read(gz.fd, gz.buf, 1) != 1) bye(\"reading after seek on \", name);\n        deflatePrime(strm, 8 - left, *gz.buf);\n    }\n    lseek(gz.fd, end, SEEK_SET);\n\n    /* clean up and return */\n    free(window);\n    free(gz.buf);\n    return gz.fd;\n}",
          "fn_code_pos": [
            [
              258,
              0
            ],
            [
              383,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzscan",
            "parameters": {
              "name": "char",
              "strm": "z_stream",
              "level": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void gztack(char *name, int gd, z_stream *strm, int last)\n{\n    int fd, len, ret;\n    unsigned left;\n    unsigned char *in, *out;\n\n    /* open file to compress and append */\n    fd = 0;\n    if (name != NULL) {\n        fd = open(name, O_RDONLY, 0);\n        if (fd == -1)\n            fprintf(stderr, \"gzappend warning: %s not found, skipping ...\\n\",\n                    name);\n    }\n\n    /* allocate buffers */\n    in = malloc(CHUNK);\n    out = malloc(CHUNK);\n    if (in == NULL || out == NULL) bye(\"out of memory\", \"\");\n\n    /* compress input file and append to gzip file */\n    do {\n        /* get more input */\n        len = read(fd, in, CHUNK);\n        if (len == -1) {\n            fprintf(stderr,\n                    \"gzappend warning: error reading %s, skipping rest ...\\n\",\n                    name);\n            len = 0;\n        }\n        strm->avail_in = (unsigned)len;\n        strm->next_in = in;\n        if (len) strm->adler = crc32(strm->adler, in, (unsigned)len);\n\n        /* compress and write all available output */\n        do {\n            strm->avail_out = CHUNK;\n            strm->next_out = out;\n            ret = deflate(strm, last && len == 0 ? Z_FINISH : Z_NO_FLUSH);\n            left = CHUNK - strm->avail_out;\n            while (left) {\n                len = write(gd, out + CHUNK - strm->avail_out - left, left);\n                if (len == -1) bye(\"writing gzip file\", \"\");\n                left -= (unsigned)len;\n            }\n        } while (strm->avail_out == 0 && ret != Z_STREAM_END);\n    } while (len != 0);\n\n    /* write trailer after last entry */\n    if (last) {\n        deflateEnd(strm);\n        out[0] = (unsigned char)(strm->adler);\n        out[1] = (unsigned char)(strm->adler >> 8);\n        out[2] = (unsigned char)(strm->adler >> 16);\n        out[3] = (unsigned char)(strm->adler >> 24);\n        out[4] = (unsigned char)(strm->total_in);\n        out[5] = (unsigned char)(strm->total_in >> 8);\n        out[6] = (unsigned char)(strm->total_in >> 16);\n        out[7] = (unsigned char)(strm->total_in >> 24);\n        len = 8;\n        do {\n            ret = write(gd, out + 8 - len, len);\n            if (ret == -1) bye(\"writing gzip file\", \"\");\n            len -= ret;\n        } while (len);\n        close(gd);\n    }\n\n    /* clean up and return */\n    free(out);\n    free(in);\n    if (fd > 0) close(fd);\n}",
          "fn_code_pos": [
            [
              387,
              0
            ],
            [
              459,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gztack",
            "parameters": {
              "name": "char",
              "gd": "int",
              "strm": "z_stream",
              "last": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "int main(int argc, char **argv)\n{\n    int gd, level;\n    z_stream strm;\n\n    /* ignore command name */\n    argc--; argv++;\n\n    /* provide usage if no arguments */\n    if (*argv == NULL) {\n        printf(\n            \"gzappend 1.2 (11 Oct 2012) Copyright (C) 2003, 2012 Mark Adler\\n\"\n               );\n        printf(\n            \"usage: gzappend [-level] file.gz [ addthis [ andthis ... ]]\\n\");\n        return 0;\n    }\n\n    /* set compression level */\n    level = Z_DEFAULT_COMPRESSION;\n    if (argv[0][0] == '-') {\n        if (argv[0][1] < '0' || argv[0][1] > '9' || argv[0][2] != 0)\n            bye(\"invalid compression level\", \"\");\n        level = argv[0][1] - '0';\n        if (*++argv == NULL) bye(\"no gzip file name after options\", \"\");\n    }\n\n    /* prepare to append to gzip file */\n    gd = gzscan(*argv++, &strm, level);\n\n    /* append files on command line, or from stdin if none */\n    if (*argv == NULL)\n        gztack(NULL, gd, &strm, 1);\n    else\n        do {\n            gztack(*argv, gd, &strm, argv[1] == NULL);\n        } while (*++argv != NULL);\n    return 0;\n}",
          "fn_code_pos": [
            [
              465,
              0
            ],
            [
              503,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n    int fd;                     /* file descriptor */\n    int size;                   /* 1 << size is bytes in buf */\n    unsigned left;              /* bytes available at next */\n    unsigned char *buf;         /* buffer */\n    z_const unsigned char *next;    /* next byte in buffer */\n    char *name;                 /* file name for error messages */\n} file;",
          {
            "fd": "int",
            "size": "int",
            "left": "unsigned",
            "*buf": "unsigned char",
            "char": "z_const unsigned",
            "*name": "char"
          },
          "file",
          [
            169,
            0
          ],
          [
            176,
            7
          ]
        ],
        [
          "typedef struct {\n    int fd;                     /* file descriptor */\n    int size;                   /* 1 << size is bytes in buf */\n    unsigned left;              /* bytes available at next */\n    unsigned char *buf;         /* buffer */\n    z_const unsigned char *next;    /* next byte in buffer */\n    char *name;                 /* file name for error messages */\n} file;",
          {
            "fd": "int",
            "size": "int",
            "left": "unsigned",
            "*buf": "unsigned char",
            "char": "z_const unsigned",
            "*name": "char"
          },
          "file",
          [
            169,
            0
          ],
          [
            176,
            7
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            79,
            0
          ],
          [
            80,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            80,
            0
          ],
          [
            81,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            81,
            0
          ],
          [
            82,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            82,
            0
          ],
          [
            83,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            83,
            0
          ],
          [
            84,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            84,
            0
          ],
          [
            85,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    }
  },
  "head": {
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/trees.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/zutil.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "farfree( void *block )",
          "fn_dec_pos": [
            [
              99,
              21
            ],
            [
              99,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "farfree",
            "parameters": {
              "block": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "farmalloc( unsigned long nbytes )",
          "fn_dec_pos": [
            [
              100,
              22
            ],
            [
              100,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "farmalloc",
            "parameters": {
              "nbytes": "unsigned long"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "adler32_combine64(uLong, uLong, z_off64_t)",
          "fn_dec_pos": [
            [
              173,
              25
            ],
            [
              173,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "adler32_combine64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "crc32_combine64(uLong, uLong, z_off64_t)",
          "fn_dec_pos": [
            [
              174,
              25
            ],
            [
              174,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_combine64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "crc32_combine_gen64(z_off64_t)",
          "fn_dec_pos": [
            [
              175,
              25
            ],
            [
              175,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_combine_gen64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "ZLIB_INTERNAL zmemcpy(Bytef* dest, const Bytef* source, uInt len)",
          "fn_dec_pos": [
            [
              214,
              8
            ],
            [
              214,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL zmemcpy",
            "parameters": {
              "dest": "Bytef",
              "source": "Bytef",
              "len": "uInt"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ZLIB_INTERNAL zmemcmp(const Bytef* s1, const Bytef* s2, uInt len)",
          "fn_dec_pos": [
            [
              215,
              7
            ],
            [
              215,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL zmemcmp",
            "parameters": {
              "s1": "Bytef",
              "s2": "Bytef",
              "len": "uInt"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ZLIB_INTERNAL zmemzero(Bytef* dest, uInt len)",
          "fn_dec_pos": [
            [
              216,
              8
            ],
            [
              216,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL zmemzero",
            "parameters": {
              "dest": "Bytef",
              "len": "uInt"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ZLIB_INTERNAL z_error(char *m)",
          "fn_dec_pos": [
            [
              223,
              15
            ],
            [
              223,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL z_error",
            "parameters": {
              "m": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items,\n                                unsigned size)",
          "fn_dec_pos": [
            [
              240,
              10
            ],
            [
              241,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL zcalloc",
            "parameters": {
              "opaque": "voidpf",
              "items": "unsigned",
              "size": "unsigned"
            },
            "return_type": "voidpf"
          }
        },
        {
          "fn_code": "ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr)",
          "fn_dec_pos": [
            [
              242,
              8
            ],
            [
              242,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL zcfree",
            "parameters": {
              "opaque": "voidpf",
              "ptr": "voidpf"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"zlib.h\"\n",
          [
            21,
            0
          ],
          [
            22,
            0
          ]
        ],
        [
          "#    include <stddef.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#  include <string.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#  include <stdlib.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#        include <alloc.h>\n",
          [
            102,
            0
          ],
          [
            103,
            0
          ]
        ],
        [
          "#      include <malloc.h>\n",
          [
            105,
            0
          ],
          [
            106,
            0
          ]
        ],
        [
          "#    include <malloc.h>\n",
          [
            137,
            0
          ],
          [
            138,
            0
          ]
        ],
        [
          "#  include <stdio.h>\n",
          [
            221,
            0
          ],
          [
            222,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/inffast.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ZLIB_INTERNAL inflate_fast(z_streamp strm, unsigned start)",
          "fn_dec_pos": [
            [
              10,
              5
            ],
            [
              10,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL inflate_fast",
            "parameters": {
              "strm": "z_streamp",
              "start": "unsigned"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/deflate.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ZLIB_INTERNAL _tr_init(deflate_state *s)",
          "fn_dec_pos": [
            [
              307,
              5
            ],
            [
              307,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL _tr_init",
            "parameters": {
              "s": "deflate_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ZLIB_INTERNAL _tr_tally(deflate_state *s, unsigned dist, unsigned lc)",
          "fn_dec_pos": [
            [
              308,
              4
            ],
            [
              308,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL _tr_tally",
            "parameters": {
              "s": "deflate_state",
              "dist": "unsigned",
              "lc": "unsigned"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ZLIB_INTERNAL _tr_flush_block(deflate_state *s, charf *buf,\n                                   ulg stored_len, int last)",
          "fn_dec_pos": [
            [
              309,
              5
            ],
            [
              310,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL _tr_flush_block",
            "parameters": {
              "s": "deflate_state",
              "buf": "charf",
              "stored_len": "ulg",
              "last": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ZLIB_INTERNAL _tr_flush_bits(deflate_state *s)",
          "fn_dec_pos": [
            [
              311,
              5
            ],
            [
              311,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL _tr_flush_bits",
            "parameters": {
              "s": "deflate_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ZLIB_INTERNAL _tr_align(deflate_state *s)",
          "fn_dec_pos": [
            [
              312,
              5
            ],
            [
              312,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL _tr_align",
            "parameters": {
              "s": "deflate_state"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ZLIB_INTERNAL _tr_stored_block(deflate_state *s, charf *buf,\n                                    ulg stored_len, int last)",
          "fn_dec_pos": [
            [
              313,
              5
            ],
            [
              314,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL _tr_stored_block",
            "parameters": {
              "s": "deflate_state",
              "buf": "charf",
              "stored_len": "ulg",
              "last": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct ct_data_s {\n    union {\n        ush  freq;       /* frequency count */\n        ush  code;       /* bit string */\n    } fc;\n    union {\n        ush  dad;        /* father node in Huffman tree */\n        ush  len;        /* length of bit string */\n    } dl;\n} FAR ct_data;",
          {
            "fc": "union {\n        ush  freq;       /* frequency count */\n        ush  code;       /* bit string */\n    }",
            "freq": "ush",
            "code": "ush",
            "dl": "union {\n        ush  dad;        /* father node in Huffman tree */\n        ush  len;        /* length of bit string */\n    }",
            "dad": "ush",
            "len": "ush"
          },
          "FAR",
          [
            71,
            0
          ],
          [
            80,
            14
          ]
        ],
        [
          "typedef struct ct_data_s {\n    union {\n        ush  freq;       /* frequency count */\n        ush  code;       /* bit string */\n    } fc;\n    union {\n        ush  dad;        /* father node in Huffman tree */\n        ush  len;        /* length of bit string */\n    } dl;\n} FAR ct_data;",
          {
            "fc": "union {\n        ush  freq;       /* frequency count */\n        ush  code;       /* bit string */\n    }",
            "freq": "ush",
            "code": "ush",
            "dl": "union {\n        ush  dad;        /* father node in Huffman tree */\n        ush  len;        /* length of bit string */\n    }",
            "dad": "ush",
            "len": "ush"
          },
          "ct_data",
          [
            71,
            0
          ],
          [
            80,
            14
          ]
        ],
        [
          "typedef struct tree_desc_s {\n    ct_data *dyn_tree;           /* the dynamic tree */\n    int     max_code;            /* largest code with non zero frequency */\n    const static_tree_desc *stat_desc;  /* the corresponding static tree */\n} FAR tree_desc;",
          {
            "*dyn_tree": "ct_data",
            "max_code": "int",
            "static_tree_desc": "const"
          },
          "FAR",
          [
            89,
            0
          ],
          [
            93,
            16
          ]
        ],
        [
          "typedef struct tree_desc_s {\n    ct_data *dyn_tree;           /* the dynamic tree */\n    int     max_code;            /* largest code with non zero frequency */\n    const static_tree_desc *stat_desc;  /* the corresponding static tree */\n} FAR tree_desc;",
          {
            "*dyn_tree": "ct_data",
            "max_code": "int",
            "static_tree_desc": "const"
          },
          "tree_desc",
          [
            89,
            0
          ],
          [
            93,
            16
          ]
        ],
        [
          "typedef struct internal_state {\n    z_streamp strm;      /* pointer back to this zlib stream */\n    int   status;        /* as the name implies */\n    Bytef *pending_buf;  /* output still pending */\n    ulg   pending_buf_size; /* size of pending_buf */\n    Bytef *pending_out;  /* next pending byte to output to the stream */\n    ulg   pending;       /* nb of bytes in the pending buffer */\n    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */\n    gz_headerp  gzhead;  /* gzip header information to write */\n    ulg   gzindex;       /* where in extra, name, or comment */\n    Byte  method;        /* can only be DEFLATED */\n    int   last_flush;    /* value of flush param for previous deflate call */\n\n                /* used by deflate.c: */\n\n    uInt  w_size;        /* LZ77 window size (32K by default) */\n    uInt  w_bits;        /* log2(w_size)  (8..16) */\n    uInt  w_mask;        /* w_size - 1 */\n\n    Bytef *window;\n    /* Sliding window. Input bytes are read into the second half of the window,\n     * and move to the first half later to keep a dictionary of at least wSize\n     * bytes. With this organization, matches are limited to a distance of\n     * wSize-MAX_MATCH bytes, but this ensures that IO is always\n     * performed with a length multiple of the block size. Also, it limits\n     * the window size to 64K, which is quite useful on MSDOS.\n     * To do: use the user input buffer as sliding window.\n     */\n\n    ulg window_size;\n    /* Actual size of window: 2*wSize, except when the user input buffer\n     * is directly used as sliding window.\n     */\n\n    Posf *prev;\n    /* Link to older string with same hash index. To limit the size of this\n     * array to 64K, this link is maintained only for the last 32K strings.\n     * An index in this array is thus a window index modulo 32K.\n     */\n\n    Posf *head; /* Heads of the hash chains or NIL. */\n\n    uInt  ins_h;          /* hash index of string to be inserted */\n    uInt  hash_size;      /* number of elements in hash table */\n    uInt  hash_bits;      /* log2(hash_size) */\n    uInt  hash_mask;      /* hash_size-1 */\n\n    uInt  hash_shift;\n    /* Number of bits by which ins_h must be shifted at each input\n     * step. It must be such that after MIN_MATCH steps, the oldest\n     * byte no longer takes part in the hash key, that is:\n     *   hash_shift * MIN_MATCH >= hash_bits\n     */\n\n    long block_start;\n    /* Window position at the beginning of the current output block. Gets\n     * negative when the window is moved backwards.\n     */\n\n    uInt match_length;           /* length of best match */\n    IPos prev_match;             /* previous match */\n    int match_available;         /* set if previous match exists */\n    uInt strstart;               /* start of string to insert */\n    uInt match_start;            /* start of matching string */\n    uInt lookahead;              /* number of valid bytes ahead in window */\n\n    uInt prev_length;\n    /* Length of the best match at previous step. Matches not greater than this\n     * are discarded. This is used in the lazy match evaluation.\n     */\n\n    uInt max_chain_length;\n    /* To speed up deflation, hash chains are never searched beyond this\n     * length.  A higher limit improves compression ratio but degrades the\n     * speed.\n     */\n\n    uInt max_lazy_match;\n    /* Attempt to find a better match only when the current match is strictly\n     * smaller than this value. This mechanism is used only for compression\n     * levels >= 4.\n     */\n#   define max_insert_length  max_lazy_match\n    /* Insert new strings in the hash table only if the match length is not\n     * greater than this length. This saves time but degrades compression.\n     * max_insert_length is used only for compression levels <= 3.\n     */\n\n    int level;    /* compression level (1..9) */\n    int strategy; /* favor or force Huffman coding*/\n\n    uInt good_match;\n    /* Use a faster search when the previous match is longer than this */\n\n    int nice_match; /* Stop searching when current match exceeds this */\n\n                /* used by trees.c: */\n    /* Didn't use ct_data typedef below to suppress compiler warning */\n    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n    struct tree_desc_s l_desc;               /* desc. for literal tree */\n    struct tree_desc_s d_desc;               /* desc. for distance tree */\n    struct tree_desc_s bl_desc;              /* desc. for bit length tree */\n\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n    int heap_len;               /* number of elements in the heap */\n    int heap_max;               /* element of largest frequency */\n    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n     * The same heap array is used to build all trees.\n     */\n\n    uch depth[2*L_CODES+1];\n    /* Depth of each subtree used as tie breaker for trees of equal frequency\n     */\n\n#ifdef LIT_MEM\n#   define LIT_BUFS 5\n    ushf *d_buf;          /* buffer for distances */\n    uchf *l_buf;          /* buffer for literals/lengths */\n#else\n#   define LIT_BUFS 4\n    uchf *sym_buf;        /* buffer for distances and literals/lengths */\n#endif\n\n    uInt  lit_bufsize;\n    /* Size of match buffer for literals/lengths.  There are 4 reasons for\n     * limiting lit_bufsize to 64K:\n     *   - frequencies can be kept in 16 bit counters\n     *   - if compression is not successful for the first block, all input\n     *     data is still in the window so we can still emit a stored block even\n     *     when input comes from standard input.  (This can also be done for\n     *     all blocks if lit_bufsize is not greater than 32K.)\n     *   - if compression is not successful for a file smaller than 64K, we can\n     *     even emit a stored file instead of a stored block (saving 5 bytes).\n     *     This is applicable only for zip (not gzip or zlib).\n     *   - creating new Huffman trees less frequently may not provide fast\n     *     adaptation to changes in the input data statistics. (Take for\n     *     example a binary file with poorly compressible code followed by\n     *     a highly compressible string table.) Smaller buffer sizes give\n     *     fast adaptation but have of course the overhead of transmitting\n     *     trees more frequently.\n     *   - I can't count above 4\n     */\n\n    uInt sym_next;      /* running index in symbol buffer */\n    uInt sym_end;       /* symbol table full when sym_next reaches this */\n\n    ulg opt_len;        /* bit length of current block with optimal trees */\n    ulg static_len;     /* bit length of current block with static trees */\n    uInt matches;       /* number of string matches in current block */\n    uInt insert;        /* bytes at end of window left to insert */\n\n#ifdef ZLIB_DEBUG\n    ulg compressed_len; /* total bit length of compressed file mod 2^32 */\n    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */\n#endif\n\n    ush bi_buf;\n    /* Output buffer. bits are inserted starting at the bottom (least\n     * significant bits).\n     */\n    int bi_valid;\n    /* Number of valid bits in bi_buf.  All bits above the last valid bit\n     * are always zero.\n     */\n    int bi_used;\n    /* Last number of used bits when going to a byte boundary.\n     */\n\n    ulg high_water;\n    /* High water mark offset in window for initialized bytes -- bytes above\n     * this are set to zero in order to avoid memory check warnings when\n     * longest match routines access bytes past the input.  This is then\n     * updated to the new high water mark.\n     */\n\n} FAR deflate_state;",
          {
            "strm": "z_streamp",
            "status": "int",
            "*pending_buf": "Bytef",
            "pending_buf_size": "ulg",
            "*pending_out": "Bytef",
            "pending": "ulg",
            "wrap": "int",
            "gzhead": "gz_headerp",
            "gzindex": "ulg",
            "method": "Byte",
            "last_flush": "int",
            "w_size": "uInt",
            "w_bits": "uInt",
            "w_mask": "uInt",
            "*window": "Bytef",
            "window_size": "ulg",
            "*prev": "Posf",
            "*head": "Posf",
            "ins_h": "uInt",
            "hash_size": "uInt",
            "hash_bits": "uInt",
            "hash_mask": "uInt",
            "hash_shift": "uInt",
            "block_start": "long",
            "match_length": "uInt",
            "prev_match": "IPos",
            "match_available": "int",
            "strstart": "uInt",
            "match_start": "uInt",
            "lookahead": "uInt",
            "prev_length": "uInt",
            "max_chain_length": "uInt",
            "max_lazy_match": "uInt",
            "level": "int",
            "strategy": "int",
            "good_match": "uInt",
            "nice_match": "int",
            "dyn_ltree[HEAP_SIZE]": "struct ct_data_s",
            "dyn_dtree[2*D_CODES+1]": "struct ct_data_s",
            "bl_tree[2*BL_CODES+1]": "struct ct_data_s",
            "l_desc": "struct tree_desc_s",
            "d_desc": "struct tree_desc_s",
            "bl_desc": "struct tree_desc_s",
            "bl_count[MAX_BITS+1]": "ush",
            "heap[2*L_CODES+1]": "int",
            "heap_len": "int",
            "heap_max": "int",
            "depth[2*L_CODES+1]": "uch",
            "*d_buf": "ushf",
            "*l_buf": "uchf",
            "*sym_buf": "uchf",
            "lit_bufsize": "uInt",
            "sym_next": "uInt",
            "sym_end": "uInt",
            "opt_len": "ulg",
            "static_len": "ulg",
            "matches": "uInt",
            "insert": "uInt",
            "compressed_len": "ulg",
            "bits_sent": "ulg",
            "bi_buf": "ush",
            "bi_valid": "int",
            "bi_used": "int",
            "high_water": "ulg"
          },
          "FAR",
          [
            103,
            0
          ],
          [
            284,
            20
          ]
        ],
        [
          "typedef struct internal_state {\n    z_streamp strm;      /* pointer back to this zlib stream */\n    int   status;        /* as the name implies */\n    Bytef *pending_buf;  /* output still pending */\n    ulg   pending_buf_size; /* size of pending_buf */\n    Bytef *pending_out;  /* next pending byte to output to the stream */\n    ulg   pending;       /* nb of bytes in the pending buffer */\n    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */\n    gz_headerp  gzhead;  /* gzip header information to write */\n    ulg   gzindex;       /* where in extra, name, or comment */\n    Byte  method;        /* can only be DEFLATED */\n    int   last_flush;    /* value of flush param for previous deflate call */\n\n                /* used by deflate.c: */\n\n    uInt  w_size;        /* LZ77 window size (32K by default) */\n    uInt  w_bits;        /* log2(w_size)  (8..16) */\n    uInt  w_mask;        /* w_size - 1 */\n\n    Bytef *window;\n    /* Sliding window. Input bytes are read into the second half of the window,\n     * and move to the first half later to keep a dictionary of at least wSize\n     * bytes. With this organization, matches are limited to a distance of\n     * wSize-MAX_MATCH bytes, but this ensures that IO is always\n     * performed with a length multiple of the block size. Also, it limits\n     * the window size to 64K, which is quite useful on MSDOS.\n     * To do: use the user input buffer as sliding window.\n     */\n\n    ulg window_size;\n    /* Actual size of window: 2*wSize, except when the user input buffer\n     * is directly used as sliding window.\n     */\n\n    Posf *prev;\n    /* Link to older string with same hash index. To limit the size of this\n     * array to 64K, this link is maintained only for the last 32K strings.\n     * An index in this array is thus a window index modulo 32K.\n     */\n\n    Posf *head; /* Heads of the hash chains or NIL. */\n\n    uInt  ins_h;          /* hash index of string to be inserted */\n    uInt  hash_size;      /* number of elements in hash table */\n    uInt  hash_bits;      /* log2(hash_size) */\n    uInt  hash_mask;      /* hash_size-1 */\n\n    uInt  hash_shift;\n    /* Number of bits by which ins_h must be shifted at each input\n     * step. It must be such that after MIN_MATCH steps, the oldest\n     * byte no longer takes part in the hash key, that is:\n     *   hash_shift * MIN_MATCH >= hash_bits\n     */\n\n    long block_start;\n    /* Window position at the beginning of the current output block. Gets\n     * negative when the window is moved backwards.\n     */\n\n    uInt match_length;           /* length of best match */\n    IPos prev_match;             /* previous match */\n    int match_available;         /* set if previous match exists */\n    uInt strstart;               /* start of string to insert */\n    uInt match_start;            /* start of matching string */\n    uInt lookahead;              /* number of valid bytes ahead in window */\n\n    uInt prev_length;\n    /* Length of the best match at previous step. Matches not greater than this\n     * are discarded. This is used in the lazy match evaluation.\n     */\n\n    uInt max_chain_length;\n    /* To speed up deflation, hash chains are never searched beyond this\n     * length.  A higher limit improves compression ratio but degrades the\n     * speed.\n     */\n\n    uInt max_lazy_match;\n    /* Attempt to find a better match only when the current match is strictly\n     * smaller than this value. This mechanism is used only for compression\n     * levels >= 4.\n     */\n#   define max_insert_length  max_lazy_match\n    /* Insert new strings in the hash table only if the match length is not\n     * greater than this length. This saves time but degrades compression.\n     * max_insert_length is used only for compression levels <= 3.\n     */\n\n    int level;    /* compression level (1..9) */\n    int strategy; /* favor or force Huffman coding*/\n\n    uInt good_match;\n    /* Use a faster search when the previous match is longer than this */\n\n    int nice_match; /* Stop searching when current match exceeds this */\n\n                /* used by trees.c: */\n    /* Didn't use ct_data typedef below to suppress compiler warning */\n    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n    struct tree_desc_s l_desc;               /* desc. for literal tree */\n    struct tree_desc_s d_desc;               /* desc. for distance tree */\n    struct tree_desc_s bl_desc;              /* desc. for bit length tree */\n\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n    int heap_len;               /* number of elements in the heap */\n    int heap_max;               /* element of largest frequency */\n    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n     * The same heap array is used to build all trees.\n     */\n\n    uch depth[2*L_CODES+1];\n    /* Depth of each subtree used as tie breaker for trees of equal frequency\n     */\n\n#ifdef LIT_MEM\n#   define LIT_BUFS 5\n    ushf *d_buf;          /* buffer for distances */\n    uchf *l_buf;          /* buffer for literals/lengths */\n#else\n#   define LIT_BUFS 4\n    uchf *sym_buf;        /* buffer for distances and literals/lengths */\n#endif\n\n    uInt  lit_bufsize;\n    /* Size of match buffer for literals/lengths.  There are 4 reasons for\n     * limiting lit_bufsize to 64K:\n     *   - frequencies can be kept in 16 bit counters\n     *   - if compression is not successful for the first block, all input\n     *     data is still in the window so we can still emit a stored block even\n     *     when input comes from standard input.  (This can also be done for\n     *     all blocks if lit_bufsize is not greater than 32K.)\n     *   - if compression is not successful for a file smaller than 64K, we can\n     *     even emit a stored file instead of a stored block (saving 5 bytes).\n     *     This is applicable only for zip (not gzip or zlib).\n     *   - creating new Huffman trees less frequently may not provide fast\n     *     adaptation to changes in the input data statistics. (Take for\n     *     example a binary file with poorly compressible code followed by\n     *     a highly compressible string table.) Smaller buffer sizes give\n     *     fast adaptation but have of course the overhead of transmitting\n     *     trees more frequently.\n     *   - I can't count above 4\n     */\n\n    uInt sym_next;      /* running index in symbol buffer */\n    uInt sym_end;       /* symbol table full when sym_next reaches this */\n\n    ulg opt_len;        /* bit length of current block with optimal trees */\n    ulg static_len;     /* bit length of current block with static trees */\n    uInt matches;       /* number of string matches in current block */\n    uInt insert;        /* bytes at end of window left to insert */\n\n#ifdef ZLIB_DEBUG\n    ulg compressed_len; /* total bit length of compressed file mod 2^32 */\n    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */\n#endif\n\n    ush bi_buf;\n    /* Output buffer. bits are inserted starting at the bottom (least\n     * significant bits).\n     */\n    int bi_valid;\n    /* Number of valid bits in bi_buf.  All bits above the last valid bit\n     * are always zero.\n     */\n    int bi_used;\n    /* Last number of used bits when going to a byte boundary.\n     */\n\n    ulg high_water;\n    /* High water mark offset in window for initialized bytes -- bytes above\n     * this are set to zero in order to avoid memory check warnings when\n     * longest match routines access bytes past the input.  This is then\n     * updated to the new high water mark.\n     */\n\n} FAR deflate_state;",
          {
            "strm": "z_streamp",
            "status": "int",
            "*pending_buf": "Bytef",
            "pending_buf_size": "ulg",
            "*pending_out": "Bytef",
            "pending": "ulg",
            "wrap": "int",
            "gzhead": "gz_headerp",
            "gzindex": "ulg",
            "method": "Byte",
            "last_flush": "int",
            "w_size": "uInt",
            "w_bits": "uInt",
            "w_mask": "uInt",
            "*window": "Bytef",
            "window_size": "ulg",
            "*prev": "Posf",
            "*head": "Posf",
            "ins_h": "uInt",
            "hash_size": "uInt",
            "hash_bits": "uInt",
            "hash_mask": "uInt",
            "hash_shift": "uInt",
            "block_start": "long",
            "match_length": "uInt",
            "prev_match": "IPos",
            "match_available": "int",
            "strstart": "uInt",
            "match_start": "uInt",
            "lookahead": "uInt",
            "prev_length": "uInt",
            "max_chain_length": "uInt",
            "max_lazy_match": "uInt",
            "level": "int",
            "strategy": "int",
            "good_match": "uInt",
            "nice_match": "int",
            "dyn_ltree[HEAP_SIZE]": "struct ct_data_s",
            "dyn_dtree[2*D_CODES+1]": "struct ct_data_s",
            "bl_tree[2*BL_CODES+1]": "struct ct_data_s",
            "l_desc": "struct tree_desc_s",
            "d_desc": "struct tree_desc_s",
            "bl_desc": "struct tree_desc_s",
            "bl_count[MAX_BITS+1]": "ush",
            "heap[2*L_CODES+1]": "int",
            "heap_len": "int",
            "heap_max": "int",
            "depth[2*L_CODES+1]": "uch",
            "*d_buf": "ushf",
            "*l_buf": "uchf",
            "*sym_buf": "uchf",
            "lit_bufsize": "uInt",
            "sym_next": "uInt",
            "sym_end": "uInt",
            "opt_len": "ulg",
            "static_len": "ulg",
            "matches": "uInt",
            "insert": "uInt",
            "compressed_len": "ulg",
            "bits_sent": "ulg",
            "bi_buf": "ush",
            "bi_valid": "int",
            "bi_used": "int",
            "high_water": "ulg"
          },
          "deflate_state",
          [
            103,
            0
          ],
          [
            284,
            20
          ]
        ],
        [
          "typedef struct ct_data_s {\n    union {\n        ush  freq;       /* frequency count */\n        ush  code;       /* bit string */\n    } fc;\n    union {\n        ush  dad;        /* father node in Huffman tree */\n        ush  len;        /* length of bit string */\n    } dl;\n} FAR ct_data;",
          {
            "fc": "union {\n        ush  freq;       /* frequency count */\n        ush  code;       /* bit string */\n    }",
            "freq": "ush",
            "code": "ush",
            "dl": "union {\n        ush  dad;        /* father node in Huffman tree */\n        ush  len;        /* length of bit string */\n    }",
            "dad": "ush",
            "len": "ush"
          },
          "FAR",
          [
            71,
            0
          ],
          [
            80,
            14
          ]
        ],
        [
          "typedef struct ct_data_s {\n    union {\n        ush  freq;       /* frequency count */\n        ush  code;       /* bit string */\n    } fc;\n    union {\n        ush  dad;        /* father node in Huffman tree */\n        ush  len;        /* length of bit string */\n    } dl;\n} FAR ct_data;",
          {
            "fc": "union {\n        ush  freq;       /* frequency count */\n        ush  code;       /* bit string */\n    }",
            "freq": "ush",
            "code": "ush",
            "dl": "union {\n        ush  dad;        /* father node in Huffman tree */\n        ush  len;        /* length of bit string */\n    }",
            "dad": "ush",
            "len": "ush"
          },
          "ct_data",
          [
            71,
            0
          ],
          [
            80,
            14
          ]
        ],
        [
          "typedef struct static_tree_desc_s  static_tree_desc;",
          {},
          "static_tree_desc",
          [
            87,
            0
          ],
          [
            87,
            52
          ]
        ],
        [
          "typedef struct tree_desc_s {\n    ct_data *dyn_tree;           /* the dynamic tree */\n    int     max_code;            /* largest code with non zero frequency */\n    const static_tree_desc *stat_desc;  /* the corresponding static tree */\n} FAR tree_desc;",
          {
            "*dyn_tree": "ct_data",
            "max_code": "int",
            "static_tree_desc": "const"
          },
          "FAR",
          [
            89,
            0
          ],
          [
            93,
            16
          ]
        ],
        [
          "typedef struct tree_desc_s {\n    ct_data *dyn_tree;           /* the dynamic tree */\n    int     max_code;            /* largest code with non zero frequency */\n    const static_tree_desc *stat_desc;  /* the corresponding static tree */\n} FAR tree_desc;",
          {
            "*dyn_tree": "ct_data",
            "max_code": "int",
            "static_tree_desc": "const"
          },
          "tree_desc",
          [
            89,
            0
          ],
          [
            93,
            16
          ]
        ],
        [
          "typedef struct internal_state {\n    z_streamp strm;      /* pointer back to this zlib stream */\n    int   status;        /* as the name implies */\n    Bytef *pending_buf;  /* output still pending */\n    ulg   pending_buf_size; /* size of pending_buf */\n    Bytef *pending_out;  /* next pending byte to output to the stream */\n    ulg   pending;       /* nb of bytes in the pending buffer */\n    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */\n    gz_headerp  gzhead;  /* gzip header information to write */\n    ulg   gzindex;       /* where in extra, name, or comment */\n    Byte  method;        /* can only be DEFLATED */\n    int   last_flush;    /* value of flush param for previous deflate call */\n\n                /* used by deflate.c: */\n\n    uInt  w_size;        /* LZ77 window size (32K by default) */\n    uInt  w_bits;        /* log2(w_size)  (8..16) */\n    uInt  w_mask;        /* w_size - 1 */\n\n    Bytef *window;\n    /* Sliding window. Input bytes are read into the second half of the window,\n     * and move to the first half later to keep a dictionary of at least wSize\n     * bytes. With this organization, matches are limited to a distance of\n     * wSize-MAX_MATCH bytes, but this ensures that IO is always\n     * performed with a length multiple of the block size. Also, it limits\n     * the window size to 64K, which is quite useful on MSDOS.\n     * To do: use the user input buffer as sliding window.\n     */\n\n    ulg window_size;\n    /* Actual size of window: 2*wSize, except when the user input buffer\n     * is directly used as sliding window.\n     */\n\n    Posf *prev;\n    /* Link to older string with same hash index. To limit the size of this\n     * array to 64K, this link is maintained only for the last 32K strings.\n     * An index in this array is thus a window index modulo 32K.\n     */\n\n    Posf *head; /* Heads of the hash chains or NIL. */\n\n    uInt  ins_h;          /* hash index of string to be inserted */\n    uInt  hash_size;      /* number of elements in hash table */\n    uInt  hash_bits;      /* log2(hash_size) */\n    uInt  hash_mask;      /* hash_size-1 */\n\n    uInt  hash_shift;\n    /* Number of bits by which ins_h must be shifted at each input\n     * step. It must be such that after MIN_MATCH steps, the oldest\n     * byte no longer takes part in the hash key, that is:\n     *   hash_shift * MIN_MATCH >= hash_bits\n     */\n\n    long block_start;\n    /* Window position at the beginning of the current output block. Gets\n     * negative when the window is moved backwards.\n     */\n\n    uInt match_length;           /* length of best match */\n    IPos prev_match;             /* previous match */\n    int match_available;         /* set if previous match exists */\n    uInt strstart;               /* start of string to insert */\n    uInt match_start;            /* start of matching string */\n    uInt lookahead;              /* number of valid bytes ahead in window */\n\n    uInt prev_length;\n    /* Length of the best match at previous step. Matches not greater than this\n     * are discarded. This is used in the lazy match evaluation.\n     */\n\n    uInt max_chain_length;\n    /* To speed up deflation, hash chains are never searched beyond this\n     * length.  A higher limit improves compression ratio but degrades the\n     * speed.\n     */\n\n    uInt max_lazy_match;\n    /* Attempt to find a better match only when the current match is strictly\n     * smaller than this value. This mechanism is used only for compression\n     * levels >= 4.\n     */\n#   define max_insert_length  max_lazy_match\n    /* Insert new strings in the hash table only if the match length is not\n     * greater than this length. This saves time but degrades compression.\n     * max_insert_length is used only for compression levels <= 3.\n     */\n\n    int level;    /* compression level (1..9) */\n    int strategy; /* favor or force Huffman coding*/\n\n    uInt good_match;\n    /* Use a faster search when the previous match is longer than this */\n\n    int nice_match; /* Stop searching when current match exceeds this */\n\n                /* used by trees.c: */\n    /* Didn't use ct_data typedef below to suppress compiler warning */\n    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n    struct tree_desc_s l_desc;               /* desc. for literal tree */\n    struct tree_desc_s d_desc;               /* desc. for distance tree */\n    struct tree_desc_s bl_desc;              /* desc. for bit length tree */\n\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n    int heap_len;               /* number of elements in the heap */\n    int heap_max;               /* element of largest frequency */\n    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n     * The same heap array is used to build all trees.\n     */\n\n    uch depth[2*L_CODES+1];\n    /* Depth of each subtree used as tie breaker for trees of equal frequency\n     */\n\n#ifdef LIT_MEM\n#   define LIT_BUFS 5\n    ushf *d_buf;          /* buffer for distances */\n    uchf *l_buf;          /* buffer for literals/lengths */\n#else\n#   define LIT_BUFS 4\n    uchf *sym_buf;        /* buffer for distances and literals/lengths */\n#endif\n\n    uInt  lit_bufsize;\n    /* Size of match buffer for literals/lengths.  There are 4 reasons for\n     * limiting lit_bufsize to 64K:\n     *   - frequencies can be kept in 16 bit counters\n     *   - if compression is not successful for the first block, all input\n     *     data is still in the window so we can still emit a stored block even\n     *     when input comes from standard input.  (This can also be done for\n     *     all blocks if lit_bufsize is not greater than 32K.)\n     *   - if compression is not successful for a file smaller than 64K, we can\n     *     even emit a stored file instead of a stored block (saving 5 bytes).\n     *     This is applicable only for zip (not gzip or zlib).\n     *   - creating new Huffman trees less frequently may not provide fast\n     *     adaptation to changes in the input data statistics. (Take for\n     *     example a binary file with poorly compressible code followed by\n     *     a highly compressible string table.) Smaller buffer sizes give\n     *     fast adaptation but have of course the overhead of transmitting\n     *     trees more frequently.\n     *   - I can't count above 4\n     */\n\n    uInt sym_next;      /* running index in symbol buffer */\n    uInt sym_end;       /* symbol table full when sym_next reaches this */\n\n    ulg opt_len;        /* bit length of current block with optimal trees */\n    ulg static_len;     /* bit length of current block with static trees */\n    uInt matches;       /* number of string matches in current block */\n    uInt insert;        /* bytes at end of window left to insert */\n\n#ifdef ZLIB_DEBUG\n    ulg compressed_len; /* total bit length of compressed file mod 2^32 */\n    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */\n#endif\n\n    ush bi_buf;\n    /* Output buffer. bits are inserted starting at the bottom (least\n     * significant bits).\n     */\n    int bi_valid;\n    /* Number of valid bits in bi_buf.  All bits above the last valid bit\n     * are always zero.\n     */\n    int bi_used;\n    /* Last number of used bits when going to a byte boundary.\n     */\n\n    ulg high_water;\n    /* High water mark offset in window for initialized bytes -- bytes above\n     * this are set to zero in order to avoid memory check warnings when\n     * longest match routines access bytes past the input.  This is then\n     * updated to the new high water mark.\n     */\n\n} FAR deflate_state;",
          {
            "strm": "z_streamp",
            "status": "int",
            "*pending_buf": "Bytef",
            "pending_buf_size": "ulg",
            "*pending_out": "Bytef",
            "pending": "ulg",
            "wrap": "int",
            "gzhead": "gz_headerp",
            "gzindex": "ulg",
            "method": "Byte",
            "last_flush": "int",
            "w_size": "uInt",
            "w_bits": "uInt",
            "w_mask": "uInt",
            "*window": "Bytef",
            "window_size": "ulg",
            "*prev": "Posf",
            "*head": "Posf",
            "ins_h": "uInt",
            "hash_size": "uInt",
            "hash_bits": "uInt",
            "hash_mask": "uInt",
            "hash_shift": "uInt",
            "block_start": "long",
            "match_length": "uInt",
            "prev_match": "IPos",
            "match_available": "int",
            "strstart": "uInt",
            "match_start": "uInt",
            "lookahead": "uInt",
            "prev_length": "uInt",
            "max_chain_length": "uInt",
            "max_lazy_match": "uInt",
            "level": "int",
            "strategy": "int",
            "good_match": "uInt",
            "nice_match": "int",
            "dyn_ltree[HEAP_SIZE]": "struct ct_data_s",
            "dyn_dtree[2*D_CODES+1]": "struct ct_data_s",
            "bl_tree[2*BL_CODES+1]": "struct ct_data_s",
            "l_desc": "struct tree_desc_s",
            "d_desc": "struct tree_desc_s",
            "bl_desc": "struct tree_desc_s",
            "bl_count[MAX_BITS+1]": "ush",
            "heap[2*L_CODES+1]": "int",
            "heap_len": "int",
            "heap_max": "int",
            "depth[2*L_CODES+1]": "uch",
            "*d_buf": "ushf",
            "*l_buf": "uchf",
            "*sym_buf": "uchf",
            "lit_bufsize": "uInt",
            "sym_next": "uInt",
            "sym_end": "uInt",
            "opt_len": "ulg",
            "static_len": "ulg",
            "matches": "uInt",
            "insert": "uInt",
            "compressed_len": "ulg",
            "bits_sent": "ulg",
            "bi_buf": "ush",
            "bi_valid": "int",
            "bi_used": "int",
            "high_water": "ulg"
          },
          "FAR",
          [
            103,
            0
          ],
          [
            284,
            20
          ]
        ],
        [
          "typedef struct internal_state {\n    z_streamp strm;      /* pointer back to this zlib stream */\n    int   status;        /* as the name implies */\n    Bytef *pending_buf;  /* output still pending */\n    ulg   pending_buf_size; /* size of pending_buf */\n    Bytef *pending_out;  /* next pending byte to output to the stream */\n    ulg   pending;       /* nb of bytes in the pending buffer */\n    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */\n    gz_headerp  gzhead;  /* gzip header information to write */\n    ulg   gzindex;       /* where in extra, name, or comment */\n    Byte  method;        /* can only be DEFLATED */\n    int   last_flush;    /* value of flush param for previous deflate call */\n\n                /* used by deflate.c: */\n\n    uInt  w_size;        /* LZ77 window size (32K by default) */\n    uInt  w_bits;        /* log2(w_size)  (8..16) */\n    uInt  w_mask;        /* w_size - 1 */\n\n    Bytef *window;\n    /* Sliding window. Input bytes are read into the second half of the window,\n     * and move to the first half later to keep a dictionary of at least wSize\n     * bytes. With this organization, matches are limited to a distance of\n     * wSize-MAX_MATCH bytes, but this ensures that IO is always\n     * performed with a length multiple of the block size. Also, it limits\n     * the window size to 64K, which is quite useful on MSDOS.\n     * To do: use the user input buffer as sliding window.\n     */\n\n    ulg window_size;\n    /* Actual size of window: 2*wSize, except when the user input buffer\n     * is directly used as sliding window.\n     */\n\n    Posf *prev;\n    /* Link to older string with same hash index. To limit the size of this\n     * array to 64K, this link is maintained only for the last 32K strings.\n     * An index in this array is thus a window index modulo 32K.\n     */\n\n    Posf *head; /* Heads of the hash chains or NIL. */\n\n    uInt  ins_h;          /* hash index of string to be inserted */\n    uInt  hash_size;      /* number of elements in hash table */\n    uInt  hash_bits;      /* log2(hash_size) */\n    uInt  hash_mask;      /* hash_size-1 */\n\n    uInt  hash_shift;\n    /* Number of bits by which ins_h must be shifted at each input\n     * step. It must be such that after MIN_MATCH steps, the oldest\n     * byte no longer takes part in the hash key, that is:\n     *   hash_shift * MIN_MATCH >= hash_bits\n     */\n\n    long block_start;\n    /* Window position at the beginning of the current output block. Gets\n     * negative when the window is moved backwards.\n     */\n\n    uInt match_length;           /* length of best match */\n    IPos prev_match;             /* previous match */\n    int match_available;         /* set if previous match exists */\n    uInt strstart;               /* start of string to insert */\n    uInt match_start;            /* start of matching string */\n    uInt lookahead;              /* number of valid bytes ahead in window */\n\n    uInt prev_length;\n    /* Length of the best match at previous step. Matches not greater than this\n     * are discarded. This is used in the lazy match evaluation.\n     */\n\n    uInt max_chain_length;\n    /* To speed up deflation, hash chains are never searched beyond this\n     * length.  A higher limit improves compression ratio but degrades the\n     * speed.\n     */\n\n    uInt max_lazy_match;\n    /* Attempt to find a better match only when the current match is strictly\n     * smaller than this value. This mechanism is used only for compression\n     * levels >= 4.\n     */\n#   define max_insert_length  max_lazy_match\n    /* Insert new strings in the hash table only if the match length is not\n     * greater than this length. This saves time but degrades compression.\n     * max_insert_length is used only for compression levels <= 3.\n     */\n\n    int level;    /* compression level (1..9) */\n    int strategy; /* favor or force Huffman coding*/\n\n    uInt good_match;\n    /* Use a faster search when the previous match is longer than this */\n\n    int nice_match; /* Stop searching when current match exceeds this */\n\n                /* used by trees.c: */\n    /* Didn't use ct_data typedef below to suppress compiler warning */\n    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n    struct tree_desc_s l_desc;               /* desc. for literal tree */\n    struct tree_desc_s d_desc;               /* desc. for distance tree */\n    struct tree_desc_s bl_desc;              /* desc. for bit length tree */\n\n    ush bl_count[MAX_BITS+1];\n    /* number of codes at each bit length for an optimal tree */\n\n    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n    int heap_len;               /* number of elements in the heap */\n    int heap_max;               /* element of largest frequency */\n    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n     * The same heap array is used to build all trees.\n     */\n\n    uch depth[2*L_CODES+1];\n    /* Depth of each subtree used as tie breaker for trees of equal frequency\n     */\n\n#ifdef LIT_MEM\n#   define LIT_BUFS 5\n    ushf *d_buf;          /* buffer for distances */\n    uchf *l_buf;          /* buffer for literals/lengths */\n#else\n#   define LIT_BUFS 4\n    uchf *sym_buf;        /* buffer for distances and literals/lengths */\n#endif\n\n    uInt  lit_bufsize;\n    /* Size of match buffer for literals/lengths.  There are 4 reasons for\n     * limiting lit_bufsize to 64K:\n     *   - frequencies can be kept in 16 bit counters\n     *   - if compression is not successful for the first block, all input\n     *     data is still in the window so we can still emit a stored block even\n     *     when input comes from standard input.  (This can also be done for\n     *     all blocks if lit_bufsize is not greater than 32K.)\n     *   - if compression is not successful for a file smaller than 64K, we can\n     *     even emit a stored file instead of a stored block (saving 5 bytes).\n     *     This is applicable only for zip (not gzip or zlib).\n     *   - creating new Huffman trees less frequently may not provide fast\n     *     adaptation to changes in the input data statistics. (Take for\n     *     example a binary file with poorly compressible code followed by\n     *     a highly compressible string table.) Smaller buffer sizes give\n     *     fast adaptation but have of course the overhead of transmitting\n     *     trees more frequently.\n     *   - I can't count above 4\n     */\n\n    uInt sym_next;      /* running index in symbol buffer */\n    uInt sym_end;       /* symbol table full when sym_next reaches this */\n\n    ulg opt_len;        /* bit length of current block with optimal trees */\n    ulg static_len;     /* bit length of current block with static trees */\n    uInt matches;       /* number of string matches in current block */\n    uInt insert;        /* bytes at end of window left to insert */\n\n#ifdef ZLIB_DEBUG\n    ulg compressed_len; /* total bit length of compressed file mod 2^32 */\n    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */\n#endif\n\n    ush bi_buf;\n    /* Output buffer. bits are inserted starting at the bottom (least\n     * significant bits).\n     */\n    int bi_valid;\n    /* Number of valid bits in bi_buf.  All bits above the last valid bit\n     * are always zero.\n     */\n    int bi_used;\n    /* Last number of used bits when going to a byte boundary.\n     */\n\n    ulg high_water;\n    /* High water mark offset in window for initialized bytes -- bytes above\n     * this are set to zero in order to avoid memory check warnings when\n     * longest match routines access bytes past the input.  This is then\n     * updated to the new high water mark.\n     */\n\n} FAR deflate_state;",
          {
            "strm": "z_streamp",
            "status": "int",
            "*pending_buf": "Bytef",
            "pending_buf_size": "ulg",
            "*pending_out": "Bytef",
            "pending": "ulg",
            "wrap": "int",
            "gzhead": "gz_headerp",
            "gzindex": "ulg",
            "method": "Byte",
            "last_flush": "int",
            "w_size": "uInt",
            "w_bits": "uInt",
            "w_mask": "uInt",
            "*window": "Bytef",
            "window_size": "ulg",
            "*prev": "Posf",
            "*head": "Posf",
            "ins_h": "uInt",
            "hash_size": "uInt",
            "hash_bits": "uInt",
            "hash_mask": "uInt",
            "hash_shift": "uInt",
            "block_start": "long",
            "match_length": "uInt",
            "prev_match": "IPos",
            "match_available": "int",
            "strstart": "uInt",
            "match_start": "uInt",
            "lookahead": "uInt",
            "prev_length": "uInt",
            "max_chain_length": "uInt",
            "max_lazy_match": "uInt",
            "level": "int",
            "strategy": "int",
            "good_match": "uInt",
            "nice_match": "int",
            "dyn_ltree[HEAP_SIZE]": "struct ct_data_s",
            "dyn_dtree[2*D_CODES+1]": "struct ct_data_s",
            "bl_tree[2*BL_CODES+1]": "struct ct_data_s",
            "l_desc": "struct tree_desc_s",
            "d_desc": "struct tree_desc_s",
            "bl_desc": "struct tree_desc_s",
            "bl_count[MAX_BITS+1]": "ush",
            "heap[2*L_CODES+1]": "int",
            "heap_len": "int",
            "heap_max": "int",
            "depth[2*L_CODES+1]": "uch",
            "*d_buf": "ushf",
            "*l_buf": "uchf",
            "*sym_buf": "uchf",
            "lit_bufsize": "uInt",
            "sym_next": "uInt",
            "sym_end": "uInt",
            "opt_len": "ulg",
            "static_len": "ulg",
            "matches": "uInt",
            "insert": "uInt",
            "compressed_len": "ulg",
            "bits_sent": "ulg",
            "bi_buf": "ush",
            "bi_valid": "int",
            "bi_used": "int",
            "high_water": "ulg"
          },
          "deflate_state",
          [
            103,
            0
          ],
          [
            284,
            20
          ]
        ],
        [
          "struct ct_data_s",
          {},
          "",
          [
            201,
            4
          ],
          [
            201,
            20
          ]
        ],
        [
          "struct ct_data_s",
          {},
          "",
          [
            202,
            4
          ],
          [
            202,
            20
          ]
        ],
        [
          "struct ct_data_s",
          {},
          "",
          [
            203,
            4
          ],
          [
            203,
            20
          ]
        ],
        [
          "struct tree_desc_s",
          {},
          "",
          [
            205,
            4
          ],
          [
            205,
            22
          ]
        ],
        [
          "struct tree_desc_s",
          {},
          "",
          [
            206,
            4
          ],
          [
            206,
            22
          ]
        ],
        [
          "struct tree_desc_s",
          {},
          "",
          [
            207,
            4
          ],
          [
            207,
            22
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"zutil.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/zconf.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#    include <stddef.h>\n",
          [
            254,
            0
          ],
          [
            255,
            0
          ]
        ],
        [
          "#    include <windows.h>\n",
          [
            354,
            0
          ],
          [
            355,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            420,
            0
          ],
          [
            421,
            0
          ]
        ],
        [
          "#    include <sys/types.h>      /* for off_t */\n",
          [
            446,
            0
          ],
          [
            447,
            0
          ]
        ],
        [
          "#    include <stdarg.h>         /* for va_list */\n",
          [
            452,
            0
          ],
          [
            453,
            0
          ]
        ],
        [
          "#    include <stddef.h>         /* for wchar_t */\n",
          [
            458,
            0
          ],
          [
            459,
            0
          ]
        ],
        [
          "#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */\n",
          [
            480,
            0
          ],
          [
            481,
            0
          ]
        ],
        [
          "#      include <unixio.h>       /* for off_t */\n",
          [
            482,
            0
          ],
          [
            483,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/zlib.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*alloc_func)(voidpf opaque, uInt items, uInt size)",
          "fn_dec_pos": [
            [
              80,
              15
            ],
            [
              80,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "opaque": "voidpf",
              "items": "uInt",
              "size": "uInt"
            },
            "return_type": "voidpf"
          }
        },
        {
          "fn_code": "(*free_func)(voidpf opaque, voidpf address)",
          "fn_dec_pos": [
            [
              81,
              15
            ],
            [
              81,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "opaque": "voidpf",
              "address": "voidpf"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "zlibVersion(void)",
          "fn_dec_pos": [
            [
              219,
              29
            ],
            [
              219,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zlibVersion",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "deflate(z_streamp strm, int flush)",
          "fn_dec_pos": [
            [
              249,
              20
            ],
            [
              249,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflate",
            "parameters": {
              "strm": "z_streamp",
              "flush": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "deflateEnd(z_streamp strm)",
          "fn_dec_pos": [
            [
              362,
              20
            ],
            [
              362,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateEnd",
            "parameters": {
              "strm": "z_streamp"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflate(z_streamp strm, int flush)",
          "fn_dec_pos": [
            [
              400,
              20
            ],
            [
              400,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflate",
            "parameters": {
              "strm": "z_streamp",
              "flush": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflateEnd(z_streamp strm)",
          "fn_dec_pos": [
            [
              520,
              20
            ],
            [
              520,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateEnd",
            "parameters": {
              "strm": "z_streamp"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "deflateSetDictionary(z_streamp strm,\n                                         const Bytef *dictionary,\n                                         uInt  dictLength)",
          "fn_dec_pos": [
            [
              613,
              20
            ],
            [
              615,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateSetDictionary",
            "parameters": {
              "strm": "z_streamp",
              "dictionary": "Bytef",
              "dictLength": "uInt"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "deflateGetDictionary(z_streamp strm,\n                                         Bytef *dictionary,\n                                         uInt  *dictLength)",
          "fn_dec_pos": [
            [
              657,
              20
            ],
            [
              659,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateGetDictionary",
            "parameters": {
              "strm": "z_streamp",
              "dictionary": "Bytef",
              "dictLength": "uInt"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "deflateCopy(z_streamp dest,\n                                z_streamp source)",
          "fn_dec_pos": [
            [
              679,
              20
            ],
            [
              680,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateCopy",
            "parameters": {
              "dest": "z_streamp",
              "source": "z_streamp"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "deflateReset(z_streamp strm)",
          "fn_dec_pos": [
            [
              697,
              20
            ],
            [
              697,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateReset",
            "parameters": {
              "strm": "z_streamp"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "deflateParams(z_streamp strm,\n                                  int level,\n                                  int strategy)",
          "fn_dec_pos": [
            [
              708,
              20
            ],
            [
              710,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateParams",
            "parameters": {
              "strm": "z_streamp",
              "level": "int",
              "strategy": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "deflateTune(z_streamp strm,\n                                int good_length,\n                                int max_lazy,\n                                int nice_length,\n                                int max_chain)",
          "fn_dec_pos": [
            [
              746,
              20
            ],
            [
              750,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateTune",
            "parameters": {
              "strm": "z_streamp",
              "good_length": "int",
              "max_lazy": "int",
              "nice_length": "int",
              "max_chain": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "deflateBound(z_streamp strm,\n                                   uLong sourceLen)",
          "fn_dec_pos": [
            [
              763,
              22
            ],
            [
              764,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateBound",
            "parameters": {
              "strm": "z_streamp",
              "sourceLen": "uLong"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "deflatePending(z_streamp strm,\n                                   unsigned *pending,\n                                   int *bits)",
          "fn_dec_pos": [
            [
              778,
              20
            ],
            [
              780,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflatePending",
            "parameters": {
              "strm": "z_streamp",
              "pending": "unsigned",
              "bits": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "deflateUsed(z_streamp strm,\n                                int *bits)",
          "fn_dec_pos": [
            [
              793,
              20
            ],
            [
              794,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateUsed",
            "parameters": {
              "strm": "z_streamp",
              "bits": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "deflatePrime(z_streamp strm,\n                                 int bits,\n                                 int value)",
          "fn_dec_pos": [
            [
              805,
              20
            ],
            [
              807,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflatePrime",
            "parameters": {
              "strm": "z_streamp",
              "bits": "int",
              "value": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "deflateSetHeader(z_streamp strm,\n                                     gz_headerp head)",
          "fn_dec_pos": [
            [
              822,
              20
            ],
            [
              823,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateSetHeader",
            "parameters": {
              "strm": "z_streamp",
              "head": "gz_headerp"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflateSetDictionary(z_streamp strm,\n                                         const Bytef *dictionary,\n                                         uInt  dictLength)",
          "fn_dec_pos": [
            [
              902,
              20
            ],
            [
              904,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateSetDictionary",
            "parameters": {
              "strm": "z_streamp",
              "dictionary": "Bytef",
              "dictLength": "uInt"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflateGetDictionary(z_streamp strm,\n                                         Bytef *dictionary,\n                                         uInt  *dictLength)",
          "fn_dec_pos": [
            [
              925,
              20
            ],
            [
              927,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateGetDictionary",
            "parameters": {
              "strm": "z_streamp",
              "dictionary": "Bytef",
              "dictLength": "uInt"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflateSync(z_streamp strm)",
          "fn_dec_pos": [
            [
              940,
              20
            ],
            [
              940,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateSync",
            "parameters": {
              "strm": "z_streamp"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflateCopy(z_streamp dest,\n                                z_streamp source)",
          "fn_dec_pos": [
            [
              959,
              20
            ],
            [
              960,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateCopy",
            "parameters": {
              "dest": "z_streamp",
              "source": "z_streamp"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflateReset(z_streamp strm)",
          "fn_dec_pos": [
            [
              975,
              20
            ],
            [
              975,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateReset",
            "parameters": {
              "strm": "z_streamp"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflateReset2(z_streamp strm,\n                                  int windowBits)",
          "fn_dec_pos": [
            [
              986,
              20
            ],
            [
              987,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateReset2",
            "parameters": {
              "strm": "z_streamp",
              "windowBits": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflatePrime(z_streamp strm,\n                                 int bits,\n                                 int value)",
          "fn_dec_pos": [
            [
              1000,
              20
            ],
            [
              1002,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflatePrime",
            "parameters": {
              "strm": "z_streamp",
              "bits": "int",
              "value": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflateMark(z_streamp strm)",
          "fn_dec_pos": [
            [
              1021,
              21
            ],
            [
              1021,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateMark",
            "parameters": {
              "strm": "z_streamp"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "inflateGetHeader(z_streamp strm,\n                                     gz_headerp head)",
          "fn_dec_pos": [
            [
              1049,
              20
            ],
            [
              1050,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateGetHeader",
            "parameters": {
              "strm": "z_streamp",
              "head": "gz_headerp"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "(*in_func)(void FAR *,\n                            z_const unsigned char FAR * FAR *)",
          "fn_dec_pos": [
            [
              1111,
              17
            ],
            [
              1112,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "FAR": "void",
              "char": "z_const unsigned"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*out_func)(void FAR *, unsigned char FAR *, unsigned)",
          "fn_dec_pos": [
            [
              1113,
              12
            ],
            [
              1113,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "FAR": "unsigned char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "inflateBack(z_streamp strm,\n                                in_func in, void FAR *in_desc,\n                                out_func out, void FAR *out_desc)",
          "fn_dec_pos": [
            [
              1115,
              20
            ],
            [
              1117,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateBack",
            "parameters": {
              "strm": "z_streamp",
              "in": "in_func",
              "FAR": "void",
              "out": "out_func"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflateBackEnd(z_streamp strm)",
          "fn_dec_pos": [
            [
              1185,
              20
            ],
            [
              1185,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateBackEnd",
            "parameters": {
              "strm": "z_streamp"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "zlibCompileFlags(void)",
          "fn_dec_pos": [
            [
              1193,
              22
            ],
            [
              1193,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zlibCompileFlags",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "compress(Bytef *dest,   uLongf *destLen,\n                             const Bytef *source, uLong sourceLen)",
          "fn_dec_pos": [
            [
              1246,
              20
            ],
            [
              1247,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compress",
            "parameters": {
              "dest": "Bytef",
              "destLen": "uLongf",
              "source": "Bytef",
              "sourceLen": "uLong"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "compress2(Bytef *dest,   uLongf *destLen,\n                              const Bytef *source, uLong sourceLen,\n                              int level)",
          "fn_dec_pos": [
            [
              1261,
              20
            ],
            [
              1263,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compress2",
            "parameters": {
              "dest": "Bytef",
              "destLen": "uLongf",
              "source": "Bytef",
              "sourceLen": "uLong",
              "level": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "compressBound(uLong sourceLen)",
          "fn_dec_pos": [
            [
              1277,
              22
            ],
            [
              1277,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compressBound",
            "parameters": {
              "sourceLen": "uLong"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "uncompress(Bytef *dest,   uLongf *destLen,\n                               const Bytef *source, uLong sourceLen)",
          "fn_dec_pos": [
            [
              1284,
              20
            ],
            [
              1285,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "uncompress",
            "parameters": {
              "dest": "Bytef",
              "destLen": "uLongf",
              "source": "Bytef",
              "sourceLen": "uLong"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "uncompress2(Bytef *dest,   uLongf *destLen,\n                                const Bytef *source, uLong *sourceLen)",
          "fn_dec_pos": [
            [
              1302,
              20
            ],
            [
              1303,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "uncompress2",
            "parameters": {
              "dest": "Bytef",
              "destLen": "uLongf",
              "source": "Bytef",
              "sourceLen": "uLong"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzdopen(int fd, const char *mode)",
          "fn_dec_pos": [
            [
              1359,
              23
            ],
            [
              1359,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzdopen",
            "parameters": {
              "fd": "int",
              "mode": "char"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzbuffer(gzFile file, unsigned size)",
          "fn_dec_pos": [
            [
              1382,
              20
            ],
            [
              1382,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzbuffer",
            "parameters": {
              "file": "gzFile",
              "size": "unsigned"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzsetparams(gzFile file, int level, int strategy)",
          "fn_dec_pos": [
            [
              1398,
              20
            ],
            [
              1398,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzsetparams",
            "parameters": {
              "file": "gzFile",
              "level": "int",
              "strategy": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzread(gzFile file, voidp buf, unsigned len)",
          "fn_dec_pos": [
            [
              1409,
              20
            ],
            [
              1409,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzread",
            "parameters": {
              "file": "gzFile",
              "buf": "voidp",
              "len": "unsigned"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzfread(voidp buf, z_size_t size, z_size_t nitems,\n                                 gzFile file)",
          "fn_dec_pos": [
            [
              1439,
              25
            ],
            [
              1440,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfread",
            "parameters": {
              "buf": "voidp",
              "size": "z_size_t",
              "nitems": "z_size_t",
              "file": "gzFile"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzwrite(gzFile file, voidpc buf, unsigned len)",
          "fn_dec_pos": [
            [
              1465,
              20
            ],
            [
              1465,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzwrite",
            "parameters": {
              "file": "gzFile",
              "buf": "voidpc",
              "len": "unsigned"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzfwrite(voidpc buf, z_size_t size,\n                                  z_size_t nitems, gzFile file)",
          "fn_dec_pos": [
            [
              1471,
              25
            ],
            [
              1472,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzfwrite",
            "parameters": {
              "buf": "voidpc",
              "size": "z_size_t",
              "nitems": "z_size_t",
              "file": "gzFile"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzprintf(gzFile file, const char *format, ...)",
          "fn_dec_pos": [
            [
              1485,
              22
            ],
            [
              1485,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzprintf",
            "parameters": {
              "file": "gzFile",
              "format": "char"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzputs(gzFile file, const char *s)",
          "fn_dec_pos": [
            [
              1500,
              20
            ],
            [
              1500,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzputs",
            "parameters": {
              "file": "gzFile",
              "s": "char"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzgets(gzFile file, char *buf, int len)",
          "fn_dec_pos": [
            [
              1508,
              23
            ],
            [
              1508,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzgets",
            "parameters": {
              "file": "gzFile",
              "buf": "char",
              "len": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzputc(gzFile file, int c)",
          "fn_dec_pos": [
            [
              1522,
              20
            ],
            [
              1522,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzputc",
            "parameters": {
              "file": "gzFile",
              "c": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzgetc(gzFile file)",
          "fn_dec_pos": [
            [
              1528,
              20
            ],
            [
              1528,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzgetc",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzungetc(int c, gzFile file)",
          "fn_dec_pos": [
            [
              1537,
              20
            ],
            [
              1537,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzungetc",
            "parameters": {
              "c": "int",
              "file": "gzFile"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzflush(gzFile file, int flush)",
          "fn_dec_pos": [
            [
              1549,
              20
            ],
            [
              1549,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzflush",
            "parameters": {
              "file": "gzFile",
              "flush": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzrewind(gzFile file)",
          "fn_dec_pos": [
            [
              1584,
              23
            ],
            [
              1584,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzrewind",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzeof(gzFile file)",
          "fn_dec_pos": [
            [
              1612,
              20
            ],
            [
              1612,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzeof",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzdirect(gzFile file)",
          "fn_dec_pos": [
            [
              1627,
              20
            ],
            [
              1627,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzdirect",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzclose(gzFile file)",
          "fn_dec_pos": [
            [
              1648,
              23
            ],
            [
              1648,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzclose",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzclose_r(gzFile file)",
          "fn_dec_pos": [
            [
              1661,
              20
            ],
            [
              1661,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzclose_r",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzclose_w(gzFile file)",
          "fn_dec_pos": [
            [
              1662,
              20
            ],
            [
              1662,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzclose_w",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzerror(gzFile file, int *errnum)",
          "fn_dec_pos": [
            [
              1673,
              29
            ],
            [
              1673,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzerror",
            "parameters": {
              "file": "gzFile",
              "errnum": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzclearerr(gzFile file)",
          "fn_dec_pos": [
            [
              1689,
              21
            ],
            [
              1689,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzclearerr",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "adler32(uLong adler, const Bytef *buf, uInt len)",
          "fn_dec_pos": [
            [
              1706,
              22
            ],
            [
              1706,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "adler32",
            "parameters": {
              "adler": "uLong",
              "buf": "Bytef",
              "len": "uInt"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "adler32_z(uLong adler, const Bytef *buf,\n                                z_size_t len)",
          "fn_dec_pos": [
            [
              1726,
              22
            ],
            [
              1727,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "adler32_z",
            "parameters": {
              "adler": "uLong",
              "buf": "Bytef",
              "len": "z_size_t"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "crc32(uLong crc, const Bytef *buf, uInt len)",
          "fn_dec_pos": [
            [
              1744,
              22
            ],
            [
              1744,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32",
            "parameters": {
              "crc": "uLong",
              "buf": "Bytef",
              "len": "uInt"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "crc32_z(uLong crc, const Bytef *buf,\n                              z_size_t len)",
          "fn_dec_pos": [
            [
              1762,
              22
            ],
            [
              1763,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_z",
            "parameters": {
              "crc": "uLong",
              "buf": "Bytef",
              "len": "z_size_t"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "crc32_combine_op(uLong crc1, uLong crc2, uLong op)",
          "fn_dec_pos": [
            [
              1785,
              22
            ],
            [
              1785,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_combine_op",
            "parameters": {
              "crc1": "uLong",
              "crc2": "uLong",
              "op": "uLong"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "deflateInit_(z_streamp strm, int level,\n                                 const char *version, int stream_size)",
          "fn_dec_pos": [
            [
              1798,
              20
            ],
            [
              1799,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateInit_",
            "parameters": {
              "strm": "z_streamp",
              "level": "int",
              "version": "char",
              "stream_size": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflateInit_(z_streamp strm,\n                                 const char *version, int stream_size)",
          "fn_dec_pos": [
            [
              1800,
              20
            ],
            [
              1801,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateInit_",
            "parameters": {
              "strm": "z_streamp",
              "version": "char",
              "stream_size": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "deflateInit2_(z_streamp strm, int  level, int  method,\n                                  int windowBits, int memLevel,\n                                  int strategy, const char *version,\n                                  int stream_size)",
          "fn_dec_pos": [
            [
              1802,
              20
            ],
            [
              1805,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateInit2_",
            "parameters": {
              "strm": "z_streamp",
              "level": "int",
              "method": "int",
              "windowBits": "int",
              "memLevel": "int",
              "strategy": "int",
              "version": "char",
              "stream_size": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflateInit2_(z_streamp strm, int  windowBits,\n                                  const char *version, int stream_size)",
          "fn_dec_pos": [
            [
              1806,
              20
            ],
            [
              1807,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateInit2_",
            "parameters": {
              "strm": "z_streamp",
              "windowBits": "int",
              "version": "char",
              "stream_size": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflateBackInit_(z_streamp strm, int windowBits,\n                                     unsigned char FAR *window,\n                                     const char *version,\n                                     int stream_size)",
          "fn_dec_pos": [
            [
              1808,
              20
            ],
            [
              1811,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateBackInit_",
            "parameters": {
              "strm": "z_streamp",
              "windowBits": "int",
              "FAR": "unsigned char",
              "version": "char",
              "stream_size": "int"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzgetc_(gzFile file)",
          "fn_dec_pos": [
            [
              1856,
              20
            ],
            [
              1856,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzgetc_",
            "parameters": {
              "file": "gzFile"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzopen64(const char *, const char *)",
          "fn_dec_pos": [
            [
              1873,
              26
            ],
            [
              1873,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzopen64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzseek64(gzFile, z_off64_t, int)",
          "fn_dec_pos": [
            [
              1874,
              29
            ],
            [
              1874,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzseek64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gztell64(gzFile)",
          "fn_dec_pos": [
            [
              1875,
              29
            ],
            [
              1875,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gztell64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzoffset64(gzFile)",
          "fn_dec_pos": [
            [
              1876,
              29
            ],
            [
              1876,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzoffset64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "adler32_combine64(uLong, uLong, z_off64_t)",
          "fn_dec_pos": [
            [
              1877,
              25
            ],
            [
              1877,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "adler32_combine64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "crc32_combine64(uLong, uLong, z_off64_t)",
          "fn_dec_pos": [
            [
              1878,
              25
            ],
            [
              1878,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_combine64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "crc32_combine_gen64(z_off64_t)",
          "fn_dec_pos": [
            [
              1879,
              25
            ],
            [
              1879,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_combine_gen64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzopen64(const char *, const char *)",
          "fn_dec_pos": [
            [
              1901,
              28
            ],
            [
              1901,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzopen64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzseek64(gzFile, z_off_t, int)",
          "fn_dec_pos": [
            [
              1902,
              29
            ],
            [
              1902,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzseek64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gztell64(gzFile)",
          "fn_dec_pos": [
            [
              1903,
              29
            ],
            [
              1903,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gztell64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzoffset64(gzFile)",
          "fn_dec_pos": [
            [
              1904,
              29
            ],
            [
              1904,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzoffset64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "adler32_combine64(uLong, uLong, z_off64_t)",
          "fn_dec_pos": [
            [
              1905,
              27
            ],
            [
              1905,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "adler32_combine64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "crc32_combine64(uLong, uLong, z_off64_t)",
          "fn_dec_pos": [
            [
              1906,
              27
            ],
            [
              1906,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_combine64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "crc32_combine_gen64(z_off64_t)",
          "fn_dec_pos": [
            [
              1907,
              27
            ],
            [
              1907,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_combine_gen64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzopen(const char *, const char *)",
          "fn_dec_pos": [
            [
              1910,
              26
            ],
            [
              1910,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzopen",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzseek(gzFile, z_off_t, int)",
          "fn_dec_pos": [
            [
              1911,
              27
            ],
            [
              1911,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzseek",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gztell(gzFile)",
          "fn_dec_pos": [
            [
              1912,
              27
            ],
            [
              1912,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gztell",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzoffset(gzFile)",
          "fn_dec_pos": [
            [
              1913,
              27
            ],
            [
              1913,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzoffset",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "adler32_combine(uLong, uLong, z_off_t)",
          "fn_dec_pos": [
            [
              1914,
              25
            ],
            [
              1914,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "adler32_combine",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "crc32_combine(uLong, uLong, z_off_t)",
          "fn_dec_pos": [
            [
              1915,
              25
            ],
            [
              1915,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_combine",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "crc32_combine_gen(z_off_t)",
          "fn_dec_pos": [
            [
              1916,
              25
            ],
            [
              1916,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_combine_gen",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "adler32_combine(uLong, uLong, z_off_t)",
          "fn_dec_pos": [
            [
              1921,
              25
            ],
            [
              1921,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "adler32_combine",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "crc32_combine(uLong, uLong, z_off_t)",
          "fn_dec_pos": [
            [
              1922,
              25
            ],
            [
              1922,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_combine",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "crc32_combine_gen(z_off_t)",
          "fn_dec_pos": [
            [
              1923,
              25
            ],
            [
              1923,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crc32_combine_gen",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "zError(int)",
          "fn_dec_pos": [
            [
              1928,
              31
            ],
            [
              1928,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zError",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "inflateSyncPoint(z_streamp)",
          "fn_dec_pos": [
            [
              1929,
              31
            ],
            [
              1929,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateSyncPoint",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "get_crc_table(void)",
          "fn_dec_pos": [
            [
              1930,
              36
            ],
            [
              1930,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_crc_table",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "inflateUndermine(z_streamp, int)",
          "fn_dec_pos": [
            [
              1931,
              31
            ],
            [
              1931,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateUndermine",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflateValidate(z_streamp, int)",
          "fn_dec_pos": [
            [
              1932,
              31
            ],
            [
              1932,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateValidate",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflateCodesUsed(z_streamp)",
          "fn_dec_pos": [
            [
              1933,
              31
            ],
            [
              1933,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateCodesUsed",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "inflateResetKeep(z_streamp)",
          "fn_dec_pos": [
            [
              1934,
              31
            ],
            [
              1934,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateResetKeep",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "deflateResetKeep(z_streamp)",
          "fn_dec_pos": [
            [
              1935,
              31
            ],
            [
              1935,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflateResetKeep",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzopen_w(const wchar_t *path,\n                                        const char *mode)",
          "fn_dec_pos": [
            [
              1937,
              31
            ],
            [
              1938,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzopen_w",
            "parameters": {
              "path": "wchar_t",
              "mode": "char"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzvprintf(gzFile file,\n                                           const char *format,\n                                           va_list va)",
          "fn_dec_pos": [
            [
              1942,
              33
            ],
            [
              1944,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzvprintf",
            "parameters": {
              "file": "gzFile",
              "format": "char",
              "va": "va_list"
            },
            "return_type": "ZEXTERN"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct z_stream_s {\n    z_const Bytef *next_in;     /* next input byte */\n    uInt     avail_in;  /* number of bytes available at next_in */\n    uLong    total_in;  /* total number of input bytes read so far */\n\n    Bytef    *next_out; /* next output byte will go here */\n    uInt     avail_out; /* remaining free space at next_out */\n    uLong    total_out; /* total number of bytes output so far */\n\n    z_const char *msg;  /* last error message, NULL if no error */\n    struct internal_state FAR *state; /* not visible by applications */\n\n    alloc_func zalloc;  /* used to allocate the internal state */\n    free_func  zfree;   /* used to free the internal state */\n    voidpf     opaque;  /* private data object passed to zalloc and zfree */\n\n    int     data_type;  /* best guess about the data type: binary or text\n                           for deflate, or the decoding state for inflate */\n    uLong   adler;      /* Adler-32 or CRC-32 value of the uncompressed data */\n    uLong   reserved;   /* reserved for future use */\n} z_stream;",
          {
            "Bytef": "z_const",
            "avail_in": "uInt",
            "total_in": "uLong",
            "*next_out": "Bytef",
            "avail_out": "uInt",
            "total_out": "uLong",
            "char": "z_const",
            "FAR": "struct internal_state",
            "zalloc": "alloc_func",
            "zfree": "free_func",
            "opaque": "voidpf",
            "data_type": "int",
            "adler": "uLong",
            "reserved": "uLong"
          },
          "z_stream",
          [
            85,
            0
          ],
          [
            105,
            11
          ]
        ],
        [
          "typedef struct gz_header_s {\n    int     text;       /* true if compressed data believed to be text */\n    uLong   time;       /* modification time */\n    int     xflags;     /* extra flags (not used when writing a gzip file) */\n    int     os;         /* operating system */\n    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */\n    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */\n    uInt    extra_max;  /* space at extra (only when reading header) */\n    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */\n    uInt    name_max;   /* space at name (only when reading header) */\n    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */\n    uInt    comm_max;   /* space at comment (only when reading header) */\n    int     hcrc;       /* true if there was or will be a header crc */\n    int     done;       /* true when done reading gzip header (not used\n                           when writing a gzip file) */\n} gz_header;",
          {
            "text": "int",
            "time": "uLong",
            "xflags": "int",
            "os": "int",
            "*extra": "Bytef",
            "extra_len": "uInt",
            "extra_max": "uInt",
            "*name": "Bytef",
            "name_max": "uInt",
            "*comment": "Bytef",
            "comm_max": "uInt",
            "hcrc": "int",
            "done": "int"
          },
          "gz_header",
          [
            113,
            0
          ],
          [
            128,
            12
          ]
        ],
        [
          "struct gzFile_s {\n    unsigned have;\n    unsigned char *next;\n    z_off64_t pos;\n}",
          {
            "have": "unsigned",
            "*next": "unsigned char",
            "pos": "z_off64_t"
          },
          "gzFile_s",
          [
            1851,
            0
          ],
          [
            1855,
            1
          ]
        ],
        [
          "struct internal_state",
          {},
          "",
          [
            83,
            0
          ],
          [
            83,
            21
          ]
        ],
        [
          "typedef struct z_stream_s {\n    z_const Bytef *next_in;     /* next input byte */\n    uInt     avail_in;  /* number of bytes available at next_in */\n    uLong    total_in;  /* total number of input bytes read so far */\n\n    Bytef    *next_out; /* next output byte will go here */\n    uInt     avail_out; /* remaining free space at next_out */\n    uLong    total_out; /* total number of bytes output so far */\n\n    z_const char *msg;  /* last error message, NULL if no error */\n    struct internal_state FAR *state; /* not visible by applications */\n\n    alloc_func zalloc;  /* used to allocate the internal state */\n    free_func  zfree;   /* used to free the internal state */\n    voidpf     opaque;  /* private data object passed to zalloc and zfree */\n\n    int     data_type;  /* best guess about the data type: binary or text\n                           for deflate, or the decoding state for inflate */\n    uLong   adler;      /* Adler-32 or CRC-32 value of the uncompressed data */\n    uLong   reserved;   /* reserved for future use */\n} z_stream;",
          {
            "Bytef": "z_const",
            "avail_in": "uInt",
            "total_in": "uLong",
            "*next_out": "Bytef",
            "avail_out": "uInt",
            "total_out": "uLong",
            "char": "z_const",
            "FAR": "struct internal_state",
            "zalloc": "alloc_func",
            "zfree": "free_func",
            "opaque": "voidpf",
            "data_type": "int",
            "adler": "uLong",
            "reserved": "uLong"
          },
          "z_stream",
          [
            85,
            0
          ],
          [
            105,
            11
          ]
        ],
        [
          "struct internal_state",
          {},
          "",
          [
            95,
            4
          ],
          [
            95,
            25
          ]
        ],
        [
          "typedef struct gz_header_s {\n    int     text;       /* true if compressed data believed to be text */\n    uLong   time;       /* modification time */\n    int     xflags;     /* extra flags (not used when writing a gzip file) */\n    int     os;         /* operating system */\n    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */\n    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */\n    uInt    extra_max;  /* space at extra (only when reading header) */\n    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */\n    uInt    name_max;   /* space at name (only when reading header) */\n    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */\n    uInt    comm_max;   /* space at comment (only when reading header) */\n    int     hcrc;       /* true if there was or will be a header crc */\n    int     done;       /* true when done reading gzip header (not used\n                           when writing a gzip file) */\n} gz_header;",
          {
            "text": "int",
            "time": "uLong",
            "xflags": "int",
            "os": "int",
            "*extra": "Bytef",
            "extra_len": "uInt",
            "extra_max": "uInt",
            "*name": "Bytef",
            "name_max": "uInt",
            "*comment": "Bytef",
            "comm_max": "uInt",
            "hcrc": "int",
            "done": "int"
          },
          "gz_header",
          [
            113,
            0
          ],
          [
            128,
            12
          ]
        ],
        [
          "typedef struct gzFile_s *gzFile;",
          {},
          "gzFile",
          [
            1319,
            0
          ],
          [
            1319,
            32
          ]
        ],
        [
          "struct gzFile_s {\n    unsigned have;\n    unsigned char *next;\n    z_off64_t pos;\n}",
          {
            "have": "unsigned",
            "*next": "unsigned char",
            "pos": "z_off64_t"
          },
          "gzFile_s",
          [
            1851,
            0
          ],
          [
            1855,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"zconf.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/inftrees.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "ZLIB_INTERNAL inflate_table(codetype type, unsigned short FAR *lens,\n                                unsigned codes, code FAR * FAR *table,\n                                unsigned FAR *bits, unsigned short FAR *work)",
          "fn_dec_pos": [
            [
              59,
              4
            ],
            [
              61,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL inflate_table",
            "parameters": {
              "type": "codetype",
              "lens": "unsigned short FAR",
              "codes": "unsigned",
              "FAR": "code",
              "bits": "unsigned FAR",
              "work": "unsigned short FAR"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n    unsigned char op;           /* operation, extra bits, table bits */\n    unsigned char bits;         /* bits in this part of the code */\n    unsigned short val;         /* offset in table or code value */\n} code;",
          {
            "op": "unsigned char",
            "bits": "unsigned char",
            "val": "unsigned short"
          },
          "code",
          [
            23,
            0
          ],
          [
            27,
            7
          ]
        ],
        [
          "typedef struct {\n    unsigned char op;           /* operation, extra bits, table bits */\n    unsigned char bits;         /* bits in this part of the code */\n    unsigned short val;         /* offset in table or code value */\n} code;",
          {
            "op": "unsigned char",
            "bits": "unsigned char",
            "val": "unsigned short"
          },
          "code",
          [
            23,
            0
          ],
          [
            27,
            7
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n    CODES,\n    LENS,\n    DISTS\n} codetype;",
          {
            "CODES": "",
            "LENS": "",
            "DISTS": ""
          },
          "codetype",
          [
            53,
            0
          ],
          [
            57,
            11
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/inffixed.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/crc32.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/gzguts.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "malloc(uInt size)",
          "fn_dec_pos": [
            [
              121,
              16
            ],
            [
              121,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "malloc",
            "parameters": {
              "size": "uInt"
            },
            "return_type": "voidp"
          }
        },
        {
          "fn_code": "free(voidpf ptr)",
          "fn_dec_pos": [
            [
              122,
              16
            ],
            [
              122,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "free",
            "parameters": {
              "ptr": "voidpf"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "gzopen64(const char *, const char *)",
          "fn_dec_pos": [
            [
              140,
              27
            ],
            [
              140,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzopen64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzseek64(gzFile, z_off64_t, int)",
          "fn_dec_pos": [
            [
              141,
              30
            ],
            [
              141,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzseek64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gztell64(gzFile)",
          "fn_dec_pos": [
            [
              142,
              30
            ],
            [
              142,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gztell64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "gzoffset64(gzFile)",
          "fn_dec_pos": [
            [
              143,
              30
            ],
            [
              143,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzoffset64",
            "parameters": {},
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "ZLIB_INTERNAL gz_error(gz_statep, int, const char *)",
          "fn_dec_pos": [
            [
              205,
              5
            ],
            [
              205,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZLIB_INTERNAL gz_error",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "gz_strwinerror(DWORD error)",
          "fn_dec_pos": [
            [
              207,
              20
            ],
            [
              207,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "error": "DWORD"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gz_intmax(void)",
          "fn_dec_pos": [
            [
              213,
              23
            ],
            [
              213,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_intmax",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n        /* exposed contents for gzgetc() macro */\n    struct gzFile_s x;      /* \"x\" for exposed */\n                            /* x.have: number of bytes available at x.next */\n                            /* x.next: next output data to deliver or write */\n                            /* x.pos: current position in uncompressed data */\n        /* used for both reading and writing */\n    int mode;               /* see gzip modes above */\n    int fd;                 /* file descriptor */\n    char *path;             /* path or fd for error messages */\n    unsigned size;          /* buffer size, zero if not allocated yet */\n    unsigned want;          /* requested buffer size, default is GZBUFSIZE */\n    unsigned char *in;      /* input buffer (double-sized when writing) */\n    unsigned char *out;     /* output buffer (double-sized when reading) */\n    int direct;             /* 0 if processing gzip, 1 if transparent */\n        /* just for reading */\n    int how;                /* 0: get header, 1: copy, 2: decompress */\n    z_off64_t start;        /* where the gzip data started, for rewinding */\n    int eof;                /* true if end of input file reached */\n    int past;               /* true if read requested past end */\n        /* just for writing */\n    int level;              /* compression level */\n    int strategy;           /* compression strategy */\n    int reset;              /* true if a reset is pending after a Z_FINISH */\n        /* seek request */\n    z_off64_t skip;         /* amount to skip (already rewound if backwards) */\n    int seek;               /* true if seek request pending */\n        /* error information */\n    int err;                /* error code */\n    char *msg;              /* error message */\n        /* zlib inflate or deflate stream */\n    z_stream strm;          /* stream structure in-place (not a pointer) */\n} gz_state;",
          {
            "x": "struct gzFile_s",
            "mode": "int",
            "fd": "int",
            "*path": "char",
            "size": "unsigned",
            "want": "unsigned",
            "*in": "unsigned char",
            "*out": "unsigned char",
            "direct": "int",
            "how": "int",
            "start": "z_off64_t",
            "eof": "int",
            "past": "int",
            "level": "int",
            "strategy": "int",
            "reset": "int",
            "skip": "z_off64_t",
            "seek": "int",
            "err": "int",
            "*msg": "char",
            "strm": "z_stream"
          },
          "gz_state",
          [
            169,
            0
          ],
          [
            201,
            11
          ]
        ],
        [
          "typedef struct {\n        /* exposed contents for gzgetc() macro */\n    struct gzFile_s x;      /* \"x\" for exposed */\n                            /* x.have: number of bytes available at x.next */\n                            /* x.next: next output data to deliver or write */\n                            /* x.pos: current position in uncompressed data */\n        /* used for both reading and writing */\n    int mode;               /* see gzip modes above */\n    int fd;                 /* file descriptor */\n    char *path;             /* path or fd for error messages */\n    unsigned size;          /* buffer size, zero if not allocated yet */\n    unsigned want;          /* requested buffer size, default is GZBUFSIZE */\n    unsigned char *in;      /* input buffer (double-sized when writing) */\n    unsigned char *out;     /* output buffer (double-sized when reading) */\n    int direct;             /* 0 if processing gzip, 1 if transparent */\n        /* just for reading */\n    int how;                /* 0: get header, 1: copy, 2: decompress */\n    z_off64_t start;        /* where the gzip data started, for rewinding */\n    int eof;                /* true if end of input file reached */\n    int past;               /* true if read requested past end */\n        /* just for writing */\n    int level;              /* compression level */\n    int strategy;           /* compression strategy */\n    int reset;              /* true if a reset is pending after a Z_FINISH */\n        /* seek request */\n    z_off64_t skip;         /* amount to skip (already rewound if backwards) */\n    int seek;               /* true if seek request pending */\n        /* error information */\n    int err;                /* error code */\n    char *msg;              /* error message */\n        /* zlib inflate or deflate stream */\n    z_stream strm;          /* stream structure in-place (not a pointer) */\n} gz_state;",
          {
            "x": "struct gzFile_s",
            "mode": "int",
            "fd": "int",
            "*path": "char",
            "size": "unsigned",
            "want": "unsigned",
            "*in": "unsigned char",
            "*out": "unsigned char",
            "direct": "int",
            "how": "int",
            "start": "z_off64_t",
            "eof": "int",
            "past": "int",
            "level": "int",
            "strategy": "int",
            "reset": "int",
            "skip": "z_off64_t",
            "seek": "int",
            "err": "int",
            "*msg": "char",
            "strm": "z_stream"
          },
          "gz_state",
          [
            169,
            0
          ],
          [
            201,
            11
          ]
        ],
        [
          "struct gzFile_s",
          {},
          "",
          [
            171,
            4
          ],
          [
            171,
            19
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <string.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <stdlib.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#  include <limits.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <fcntl.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#  include <stddef.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#  include <io.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#  include <sys/stat.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#  include <windows.h>\n",
          [
            127,
            0
          ],
          [
            128,
            0
          ]
        ],
        [
          "#    include <errno.h>\n",
          [
            131,
            0
          ],
          [
            132,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/inflate.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct inflate_state {\n    z_streamp strm;             /* pointer back to this zlib stream */\n    inflate_mode mode;          /* current inflate mode */\n    int last;                   /* true if processing last block */\n    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip,\n                                   bit 2 true to validate check value */\n    int havedict;               /* true if dictionary provided */\n    int flags;                  /* gzip header method and flags, 0 if zlib, or\n                                   -1 if raw or no header yet */\n    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */\n    unsigned long check;        /* protected copy of check value */\n    unsigned long total;        /* protected copy of output count */\n    gz_headerp head;            /* where to save gzip header information */\n        /* sliding window */\n    unsigned wbits;             /* log base 2 of requested window size */\n    unsigned wsize;             /* window size or zero if not using window */\n    unsigned whave;             /* valid bytes in the window */\n    unsigned wnext;             /* window write index */\n    unsigned char FAR *window;  /* allocated sliding window, if needed */\n        /* bit accumulator */\n    unsigned long hold;         /* input bit accumulator */\n    unsigned bits;              /* number of bits in hold */\n        /* for string and stored block copying */\n    unsigned length;            /* literal or length of data to copy */\n    unsigned offset;            /* distance back to copy string from */\n        /* for table and code decoding */\n    unsigned extra;             /* extra bits needed */\n        /* fixed and dynamic code tables */\n    code const FAR *lencode;    /* starting table for length/literal codes */\n    code const FAR *distcode;   /* starting table for distance codes */\n    unsigned lenbits;           /* index bits for lencode */\n    unsigned distbits;          /* index bits for distcode */\n        /* dynamic table building */\n    unsigned ncode;             /* number of code length code lengths */\n    unsigned nlen;              /* number of length code lengths */\n    unsigned ndist;             /* number of distance code lengths */\n    unsigned have;              /* number of code lengths in lens[] */\n    code FAR *next;             /* next available space in codes[] */\n    unsigned short lens[320];   /* temporary storage for code lengths */\n    unsigned short work[288];   /* work area for code table building */\n    code codes[ENOUGH];         /* space for code tables */\n    int sane;                   /* if false, allow invalid distance too far */\n    int back;                   /* bits back of last unprocessed length/lit */\n    unsigned was;               /* initial length of match */\n}",
          {
            "strm": "z_streamp",
            "mode": "inflate_mode",
            "last": "int",
            "wrap": "int",
            "havedict": "int",
            "flags": "int",
            "dmax": "unsigned",
            "check": "unsigned long",
            "total": "unsigned long",
            "head": "gz_headerp",
            "wbits": "unsigned",
            "wsize": "unsigned",
            "whave": "unsigned",
            "wnext": "unsigned",
            "FAR": "code",
            "hold": "unsigned long",
            "bits": "unsigned",
            "length": "unsigned",
            "offset": "unsigned",
            "extra": "unsigned",
            "const": "code",
            "lenbits": "unsigned",
            "distbits": "unsigned",
            "ncode": "unsigned",
            "nlen": "unsigned",
            "ndist": "unsigned",
            "have": "unsigned",
            "lens[320]": "unsigned short",
            "work[288]": "unsigned short",
            "codes[ENOUGH]": "code",
            "sane": "int",
            "back": "int",
            "was": "unsigned"
          },
          "inflate_state",
          [
            81,
            0
          ],
          [
            125,
            1
          ]
        ],
        [
          "struct inflate_state {\n    z_streamp strm;             /* pointer back to this zlib stream */\n    inflate_mode mode;          /* current inflate mode */\n    int last;                   /* true if processing last block */\n    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip,\n                                   bit 2 true to validate check value */\n    int havedict;               /* true if dictionary provided */\n    int flags;                  /* gzip header method and flags, 0 if zlib, or\n                                   -1 if raw or no header yet */\n    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */\n    unsigned long check;        /* protected copy of check value */\n    unsigned long total;        /* protected copy of output count */\n    gz_headerp head;            /* where to save gzip header information */\n        /* sliding window */\n    unsigned wbits;             /* log base 2 of requested window size */\n    unsigned wsize;             /* window size or zero if not using window */\n    unsigned whave;             /* valid bytes in the window */\n    unsigned wnext;             /* window write index */\n    unsigned char FAR *window;  /* allocated sliding window, if needed */\n        /* bit accumulator */\n    unsigned long hold;         /* input bit accumulator */\n    unsigned bits;              /* number of bits in hold */\n        /* for string and stored block copying */\n    unsigned length;            /* literal or length of data to copy */\n    unsigned offset;            /* distance back to copy string from */\n        /* for table and code decoding */\n    unsigned extra;             /* extra bits needed */\n        /* fixed and dynamic code tables */\n    code const FAR *lencode;    /* starting table for length/literal codes */\n    code const FAR *distcode;   /* starting table for distance codes */\n    unsigned lenbits;           /* index bits for lencode */\n    unsigned distbits;          /* index bits for distcode */\n        /* dynamic table building */\n    unsigned ncode;             /* number of code length code lengths */\n    unsigned nlen;              /* number of length code lengths */\n    unsigned ndist;             /* number of distance code lengths */\n    unsigned have;              /* number of code lengths in lens[] */\n    code FAR *next;             /* next available space in codes[] */\n    unsigned short lens[320];   /* temporary storage for code lengths */\n    unsigned short work[288];   /* work area for code table building */\n    code codes[ENOUGH];         /* space for code tables */\n    int sane;                   /* if false, allow invalid distance too far */\n    int back;                   /* bits back of last unprocessed length/lit */\n    unsigned was;               /* initial length of match */\n}",
          {
            "strm": "z_streamp",
            "mode": "inflate_mode",
            "last": "int",
            "wrap": "int",
            "havedict": "int",
            "flags": "int",
            "dmax": "unsigned",
            "check": "unsigned long",
            "total": "unsigned long",
            "head": "gz_headerp",
            "wbits": "unsigned",
            "wsize": "unsigned",
            "whave": "unsigned",
            "wnext": "unsigned",
            "FAR": "code",
            "hold": "unsigned long",
            "bits": "unsigned",
            "length": "unsigned",
            "offset": "unsigned",
            "extra": "unsigned",
            "const": "code",
            "lenbits": "unsigned",
            "distbits": "unsigned",
            "ncode": "unsigned",
            "nlen": "unsigned",
            "ndist": "unsigned",
            "have": "unsigned",
            "lens[320]": "unsigned short",
            "work[288]": "unsigned short",
            "codes[ENOUGH]": "code",
            "sane": "int",
            "back": "int",
            "was": "unsigned"
          },
          "inflate_state",
          [
            81,
            0
          ],
          [
            125,
            1
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n    HEAD = 16180,   /* i: waiting for magic header */\n    FLAGS,      /* i: waiting for method and flags (gzip) */\n    TIME,       /* i: waiting for modification time (gzip) */\n    OS,         /* i: waiting for extra flags and operating system (gzip) */\n    EXLEN,      /* i: waiting for extra length (gzip) */\n    EXTRA,      /* i: waiting for extra bytes (gzip) */\n    NAME,       /* i: waiting for end of file name (gzip) */\n    COMMENT,    /* i: waiting for end of comment (gzip) */\n    HCRC,       /* i: waiting for header crc (gzip) */\n    DICTID,     /* i: waiting for dictionary check value */\n    DICT,       /* waiting for inflateSetDictionary() call */\n        TYPE,       /* i: waiting for type bits, including last-flag bit */\n        TYPEDO,     /* i: same, but skip check to exit inflate on new block */\n        STORED,     /* i: waiting for stored size (length and complement) */\n        COPY_,      /* i/o: same as COPY below, but only first time in */\n        COPY,       /* i/o: waiting for input or output to copy stored block */\n        TABLE,      /* i: waiting for dynamic block table lengths */\n        LENLENS,    /* i: waiting for code length code lengths */\n        CODELENS,   /* i: waiting for length/lit and distance code lengths */\n            LEN_,       /* i: same as LEN below, but only first time in */\n            LEN,        /* i: waiting for length/lit/eob code */\n            LENEXT,     /* i: waiting for length extra bits */\n            DIST,       /* i: waiting for distance code */\n            DISTEXT,    /* i: waiting for distance extra bits */\n            MATCH,      /* o: waiting for output space to copy string */\n            LIT,        /* o: waiting for output space to write literal */\n    CHECK,      /* i: waiting for 32-bit check value */\n    LENGTH,     /* i: waiting for 32-bit length (gzip) */\n    DONE,       /* finished check, done -- remain here until reset */\n    BAD,        /* got a data error -- remain here until reset */\n    MEM,        /* got an inflate() memory error -- remain here until reset */\n    SYNC        /* looking for synchronization bytes to restart inflate() */\n} inflate_mode;",
          {
            "HEAD": "",
            "FLAGS": "",
            "TIME": "",
            "OS": "",
            "EXLEN": "",
            "EXTRA": "",
            "NAME": "",
            "COMMENT": "",
            "HCRC": "",
            "DICTID": "",
            "DICT": "",
            "TYPE": "",
            "TYPEDO": "",
            "STORED": "",
            "COPY_": "",
            "COPY": "",
            "TABLE": "",
            "LENLENS": "",
            "CODELENS": "",
            "LEN_": "",
            "LEN": "",
            "LENEXT": "",
            "DIST": "",
            "DISTEXT": "",
            "MATCH": "",
            "LIT": "",
            "CHECK": "",
            "LENGTH": "",
            "DONE": "",
            "BAD": "",
            "MEM": "",
            "SYNC": ""
          },
          "inflate_mode",
          [
            19,
            0
          ],
          [
            52,
            15
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/iostream3/zfstream.h": {
      "fn_def_list": [
        {
          "fn_code": "template<typename T1, typename T2>\n  inline\n  gzomanip2<T1,T2>::gzomanip2(gzofstream &(*f)(gzofstream &, T1, T2),\n                              T1 v1,\n                              T2 v2)\n  : func(f), val1(v1), val2(v2)\n  { }",
          "fn_code_pos": [
            [
              446,
              0
            ],
            [
              452,
              5
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template<typename T1, typename T2>\n  inline gzofstream&\n  operator<<(gzofstream& s, const gzomanip2<T1,T2>& m)\n  { return (*m.func)(s, m.val1, m.val2); }",
          "fn_code_pos": [
            [
              455,
              0
            ],
            [
              458,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "bool\n  is_open() const { return (file != NULL); }",
          "fn_code_pos": [
            [
              55,
              2
            ],
            [
              56,
              44
            ]
          ],
          "class_code": "7dc9871026b3a337986f7b3db33c2342ad211d48d888f630ecc67889083a20dd",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "is_open",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "gzfilebuf*\n  rdbuf() const\n  { return const_cast<gzfilebuf*>(&sb); }",
          "fn_code_pos": [
            [
              260,
              2
            ],
            [
              262,
              41
            ]
          ],
          "class_code": "8763078d9252ea2fb45d4cc68c31444632056ce072b80c78489644b5b1b0c048",
          "class_node_pos": [
            [
              233,
              0
            ],
            [
              312,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rdbuf",
            "parameters": {},
            "return_type": "gzfilebuf"
          }
        },
        {
          "fn_code": "bool\n  is_open() { return sb.is_open(); }",
          "fn_code_pos": [
            [
              268,
              2
            ],
            [
              269,
              36
            ]
          ],
          "class_code": "8763078d9252ea2fb45d4cc68c31444632056ce072b80c78489644b5b1b0c048",
          "class_node_pos": [
            [
              233,
              0
            ],
            [
              312,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "is_open",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "gzfilebuf*\n  rdbuf() const\n  { return const_cast<gzfilebuf*>(&sb); }",
          "fn_code_pos": [
            [
              349,
              2
            ],
            [
              351,
              41
            ]
          ],
          "class_code": "e3dc7b7db977b179361aa61ef3ae8dcb6a7c615c0b68c6b76ed313482e13dad3",
          "class_node_pos": [
            [
              322,
              0
            ],
            [
              401,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rdbuf",
            "parameters": {},
            "return_type": "gzfilebuf"
          }
        },
        {
          "fn_code": "bool\n  is_open() { return sb.is_open(); }",
          "fn_code_pos": [
            [
              357,
              2
            ],
            [
              358,
              36
            ]
          ],
          "class_code": "e3dc7b7db977b179361aa61ef3ae8dcb6a7c615c0b68c6b76ed313482e13dad3",
          "class_node_pos": [
            [
              322,
              0
            ],
            [
              401,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "is_open",
            "parameters": {},
            "return_type": "bool"
          }
        },
        {
          "fn_code": "inline gzofstream&\nsetcompression(gzofstream &gzs, int l, int s = Z_DEFAULT_STRATEGY)\n{\n  (gzs.rdbuf())->setcompression(l, s);\n  return gzs;\n}",
          "fn_code_pos": [
            [
              438,
              0
            ],
            [
              443,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "gzofstream"
          }
        },
        {
          "fn_code": "inline gzomanip2<int,int>\nsetcompression(int l, int s = Z_DEFAULT_STRATEGY)\n{ return gzomanip2<int,int>(&setcompression, l, s); }",
          "fn_code_pos": [
            [
              461,
              0
            ],
            [
              463,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setcompression",
            "parameters": {
              "l": "int"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "gzfilebuf()",
          "fn_dec_pos": [
            [
              30,
              2
            ],
            [
              30,
              13
            ]
          ],
          "class_code": "7dc9871026b3a337986f7b3db33c2342ad211d48d888f630ecc67889083a20dd",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "gzfilebuf",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~gzfilebuf()",
          "fn_dec_pos": [
            [
              34,
              2
            ],
            [
              34,
              14
            ]
          ],
          "class_code": "7dc9871026b3a337986f7b3db33c2342ad211d48d888f630ecc67889083a20dd",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "setcompression(int comp_level,\n                 int comp_strategy = Z_DEFAULT_STRATEGY)",
          "fn_dec_pos": [
            [
              48,
              2
            ],
            [
              49,
              56
            ]
          ],
          "class_code": "7dc9871026b3a337986f7b3db33c2342ad211d48d888f630ecc67889083a20dd",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "setcompression",
            "parameters": {
              "comp_level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "open(const char* name,\n       std::ios_base::openmode mode)",
          "fn_dec_pos": [
            [
              65,
              2
            ],
            [
              66,
              36
            ]
          ],
          "class_code": "7dc9871026b3a337986f7b3db33c2342ad211d48d888f630ecc67889083a20dd",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "open",
            "parameters": {
              "name": "char",
              "mode": "std::ios_base::openmode"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "attach(int fd,\n         std::ios_base::openmode mode)",
          "fn_dec_pos": [
            [
              75,
              2
            ],
            [
              76,
              38
            ]
          ],
          "class_code": "7dc9871026b3a337986f7b3db33c2342ad211d48d888f630ecc67889083a20dd",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "attach",
            "parameters": {
              "fd": "int",
              "mode": "std::ios_base::openmode"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "close()",
          "fn_dec_pos": [
            [
              83,
              2
            ],
            [
              83,
              9
            ]
          ],
          "class_code": "7dc9871026b3a337986f7b3db33c2342ad211d48d888f630ecc67889083a20dd",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "close",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "open_mode(std::ios_base::openmode mode,\n            char* c_mode) const",
          "fn_dec_pos": [
            [
              91,
              2
            ],
            [
              92,
              31
            ]
          ],
          "class_code": "7dc9871026b3a337986f7b3db33c2342ad211d48d888f630ecc67889083a20dd",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "open_mode",
            "parameters": {
              "mode": "std::ios_base::openmode",
              "c_mode": "char"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "showmanyc()",
          "fn_dec_pos": [
            [
              102,
              2
            ],
            [
              102,
              13
            ]
          ],
          "class_code": "7dc9871026b3a337986f7b3db33c2342ad211d48d888f630ecc67889083a20dd",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "showmanyc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "underflow()",
          "fn_dec_pos": [
            [
              112,
              2
            ],
            [
              112,
              13
            ]
          ],
          "class_code": "7dc9871026b3a337986f7b3db33c2342ad211d48d888f630ecc67889083a20dd",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "underflow",
            "parameters": {},
            "return_type": "int_type"
          }
        },
        {
          "fn_code": "overflow(int_type c = traits_type::eof())",
          "fn_dec_pos": [
            [
              124,
              2
            ],
            [
              124,
              43
            ]
          ],
          "class_code": "7dc9871026b3a337986f7b3db33c2342ad211d48d888f630ecc67889083a20dd",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "overflow",
            "parameters": {},
            "return_type": "int_type"
          }
        },
        {
          "fn_code": "setbuf(char_type* p,\n         std::streamsize n)",
          "fn_dec_pos": [
            [
              135,
              2
            ],
            [
              136,
              27
            ]
          ],
          "class_code": "7dc9871026b3a337986f7b3db33c2342ad211d48d888f630ecc67889083a20dd",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "setbuf",
            "parameters": {
              "p": "char_type",
              "n": "std::streamsize"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "sync()",
          "fn_dec_pos": [
            [
              145,
              2
            ],
            [
              145,
              8
            ]
          ],
          "class_code": "7dc9871026b3a337986f7b3db33c2342ad211d48d888f630ecc67889083a20dd",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "sync",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "enable_buffer()",
          "fn_dec_pos": [
            [
              170,
              2
            ],
            [
              170,
              17
            ]
          ],
          "class_code": "7dc9871026b3a337986f7b3db33c2342ad211d48d888f630ecc67889083a20dd",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "enable_buffer",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "disable_buffer()",
          "fn_dec_pos": [
            [
              180,
              2
            ],
            [
              180,
              18
            ]
          ],
          "class_code": "7dc9871026b3a337986f7b3db33c2342ad211d48d888f630ecc67889083a20dd",
          "class_node_pos": [
            [
              26,
              0
            ],
            [
              223,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "disable_buffer",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "gzifstream()",
          "fn_dec_pos": [
            [
              237,
              2
            ],
            [
              237,
              14
            ]
          ],
          "class_code": "8763078d9252ea2fb45d4cc68c31444632056ce072b80c78489644b5b1b0c048",
          "class_node_pos": [
            [
              233,
              0
            ],
            [
              312,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "gzifstream",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzifstream(const char* name,\n             std::ios_base::openmode mode = std::ios_base::in)",
          "fn_dec_pos": [
            [
              245,
              2
            ],
            [
              246,
              62
            ]
          ],
          "class_code": "8763078d9252ea2fb45d4cc68c31444632056ce072b80c78489644b5b1b0c048",
          "class_node_pos": [
            [
              233,
              0
            ],
            [
              312,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "gzifstream",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzifstream(int fd,\n             std::ios_base::openmode mode = std::ios_base::in)",
          "fn_dec_pos": [
            [
              254,
              2
            ],
            [
              255,
              62
            ]
          ],
          "class_code": "8763078d9252ea2fb45d4cc68c31444632056ce072b80c78489644b5b1b0c048",
          "class_node_pos": [
            [
              233,
              0
            ],
            [
              312,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "gzifstream",
            "parameters": {
              "fd": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "rdbuf() const",
          "fn_dec_pos": [
            [
              261,
              2
            ],
            [
              261,
              15
            ]
          ],
          "class_code": "8763078d9252ea2fb45d4cc68c31444632056ce072b80c78489644b5b1b0c048",
          "class_node_pos": [
            [
              233,
              0
            ],
            [
              312,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rdbuf",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "open(const char* name,\n       std::ios_base::openmode mode = std::ios_base::in)",
          "fn_dec_pos": [
            [
              284,
              2
            ],
            [
              285,
              56
            ]
          ],
          "class_code": "8763078d9252ea2fb45d4cc68c31444632056ce072b80c78489644b5b1b0c048",
          "class_node_pos": [
            [
              233,
              0
            ],
            [
              312,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "open",
            "parameters": {
              "name": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "attach(int fd,\n         std::ios_base::openmode mode = std::ios_base::in)",
          "fn_dec_pos": [
            [
              296,
              2
            ],
            [
              297,
              58
            ]
          ],
          "class_code": "8763078d9252ea2fb45d4cc68c31444632056ce072b80c78489644b5b1b0c048",
          "class_node_pos": [
            [
              233,
              0
            ],
            [
              312,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "attach",
            "parameters": {
              "fd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "close()",
          "fn_dec_pos": [
            [
              305,
              2
            ],
            [
              305,
              9
            ]
          ],
          "class_code": "8763078d9252ea2fb45d4cc68c31444632056ce072b80c78489644b5b1b0c048",
          "class_node_pos": [
            [
              233,
              0
            ],
            [
              312,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "close",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "gzofstream()",
          "fn_dec_pos": [
            [
              326,
              2
            ],
            [
              326,
              14
            ]
          ],
          "class_code": "e3dc7b7db977b179361aa61ef3ae8dcb6a7c615c0b68c6b76ed313482e13dad3",
          "class_node_pos": [
            [
              322,
              0
            ],
            [
              401,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "gzofstream",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzofstream(const char* name,\n             std::ios_base::openmode mode = std::ios_base::out)",
          "fn_dec_pos": [
            [
              334,
              2
            ],
            [
              335,
              63
            ]
          ],
          "class_code": "e3dc7b7db977b179361aa61ef3ae8dcb6a7c615c0b68c6b76ed313482e13dad3",
          "class_node_pos": [
            [
              322,
              0
            ],
            [
              401,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "gzofstream",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzofstream(int fd,\n             std::ios_base::openmode mode = std::ios_base::out)",
          "fn_dec_pos": [
            [
              343,
              2
            ],
            [
              344,
              63
            ]
          ],
          "class_code": "e3dc7b7db977b179361aa61ef3ae8dcb6a7c615c0b68c6b76ed313482e13dad3",
          "class_node_pos": [
            [
              322,
              0
            ],
            [
              401,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "gzofstream",
            "parameters": {
              "fd": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "rdbuf() const",
          "fn_dec_pos": [
            [
              350,
              2
            ],
            [
              350,
              15
            ]
          ],
          "class_code": "e3dc7b7db977b179361aa61ef3ae8dcb6a7c615c0b68c6b76ed313482e13dad3",
          "class_node_pos": [
            [
              322,
              0
            ],
            [
              401,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rdbuf",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "open(const char* name,\n       std::ios_base::openmode mode = std::ios_base::out)",
          "fn_dec_pos": [
            [
              373,
              2
            ],
            [
              374,
              57
            ]
          ],
          "class_code": "e3dc7b7db977b179361aa61ef3ae8dcb6a7c615c0b68c6b76ed313482e13dad3",
          "class_node_pos": [
            [
              322,
              0
            ],
            [
              401,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "open",
            "parameters": {
              "name": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "attach(int fd,\n         std::ios_base::openmode mode = std::ios_base::out)",
          "fn_dec_pos": [
            [
              385,
              2
            ],
            [
              386,
              59
            ]
          ],
          "class_code": "e3dc7b7db977b179361aa61ef3ae8dcb6a7c615c0b68c6b76ed313482e13dad3",
          "class_node_pos": [
            [
              322,
              0
            ],
            [
              401,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "attach",
            "parameters": {
              "fd": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "close()",
          "fn_dec_pos": [
            [
              394,
              2
            ],
            [
              394,
              9
            ]
          ],
          "class_code": "e3dc7b7db977b179361aa61ef3ae8dcb6a7c615c0b68c6b76ed313482e13dad3",
          "class_node_pos": [
            [
              322,
              0
            ],
            [
              401,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "close",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "operator<<(gzofstream&,\n                 const gzomanip2<Ta,Tb>&)",
          "fn_dec_pos": [
            [
              418,
              6
            ],
            [
              419,
              41
            ]
          ],
          "class_code": "9e49096f0000b2e3698634712355bd6242eafb2624035ae7462aa017600e5c5d",
          "class_node_pos": [
            [
              412,
              2
            ],
            [
              433,
              3
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzomanip2(gzofstream& (*f)(gzofstream&, T1, T2),\n              T1 v1,\n              T2 v2)",
          "fn_dec_pos": [
            [
              422,
              4
            ],
            [
              424,
              20
            ]
          ],
          "class_code": "9e49096f0000b2e3698634712355bd6242eafb2624035ae7462aa017600e5c5d",
          "class_node_pos": [
            [
              412,
              2
            ],
            [
              433,
              3
            ]
          ],
          "fn_meta": {
            "identifier": "gzomanip2",
            "parameters": {
              "f": "gzofstream",
              "v1": "T1",
              "v2": "T2"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*f)(gzofstream&, T1, T2)",
          "fn_dec_pos": [
            [
              422,
              26
            ],
            [
              422,
              51
            ]
          ],
          "class_code": "9e49096f0000b2e3698634712355bd6242eafb2624035ae7462aa017600e5c5d",
          "class_node_pos": [
            [
              412,
              2
            ],
            [
              433,
              3
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "(*func)(gzofstream&, T1, T2)",
          "fn_dec_pos": [
            [
              428,
              4
            ],
            [
              428,
              32
            ]
          ],
          "class_code": "9e49096f0000b2e3698634712355bd6242eafb2624035ae7462aa017600e5c5d",
          "class_node_pos": [
            [
              412,
              2
            ],
            [
              433,
              3
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "setcompression(gzofstream &gzs, int l, int s = Z_DEFAULT_STRATEGY)",
          "fn_dec_pos": [
            [
              439,
              0
            ],
            [
              439,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setcompression",
            "parameters": {
              "gzs": "gzofstream",
              "l": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*f)(gzofstream &, T1, T2)",
          "fn_dec_pos": [
            [
              448,
              42
            ],
            [
              448,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(gzofstream& s, const gzomanip2<T1,T2>& m)",
          "fn_dec_pos": [
            [
              457,
              2
            ],
            [
              457,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "s": "gzofstream",
              "m": "gzomanip2<T1,T2>"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "7dc9871026b3a337986f7b3db33c2342ad211d48d888f630ecc67889083a20dd": {
          "class_code": "class gzfilebuf : public std::streambuf\n{\npublic:\n  //  Default constructor.\n  gzfilebuf();\n\n  //  Destructor.\n  virtual\n  ~gzfilebuf();\n\n  /**\n   *  @brief  Set compression level and strategy on the fly.\n   *  @param  comp_level  Compression level (see zlib.h for allowed values)\n   *  @param  comp_strategy  Compression strategy (see zlib.h for allowed values)\n   *  @return  Z_OK on success, Z_STREAM_ERROR otherwise.\n   *\n   *  Unfortunately, these parameters cannot be modified separately, as the\n   *  previous zfstream version assumed. Since the strategy is seldom changed,\n   *  it can default and setcompression(level) then becomes like the old\n   *  setcompressionlevel(level).\n  */\n  int\n  setcompression(int comp_level,\n                 int comp_strategy = Z_DEFAULT_STRATEGY);\n\n  /**\n   *  @brief  Check if file is open.\n   *  @return  True if file is open.\n  */\n  bool\n  is_open() const { return (file != NULL); }\n\n  /**\n   *  @brief  Open gzipped file.\n   *  @param  name  File name.\n   *  @param  mode  Open mode flags.\n   *  @return  @c this on success, NULL on failure.\n  */\n  gzfilebuf*\n  open(const char* name,\n       std::ios_base::openmode mode);\n\n  /**\n   *  @brief  Attach to already open gzipped file.\n   *  @param  fd  File descriptor.\n   *  @param  mode  Open mode flags.\n   *  @return  @c this on success, NULL on failure.\n  */\n  gzfilebuf*\n  attach(int fd,\n         std::ios_base::openmode mode);\n\n  /**\n   *  @brief  Close gzipped file.\n   *  @return  @c this on success, NULL on failure.\n  */\n  gzfilebuf*\n  close();\n\nprotected:\n  /**\n   *  @brief  Convert ios open mode int to mode string used by zlib.\n   *  @return  True if valid mode flag combination.\n  */\n  bool\n  open_mode(std::ios_base::openmode mode,\n            char* c_mode) const;\n\n  /**\n   *  @brief  Number of characters available in stream buffer.\n   *  @return  Number of characters.\n   *\n   *  This indicates number of characters in get area of stream buffer.\n   *  These characters can be read without accessing the gzipped file.\n  */\n  virtual std::streamsize\n  showmanyc();\n\n  /**\n   *  @brief  Fill get area from gzipped file.\n   *  @return  First character in get area on success, EOF on error.\n   *\n   *  This actually reads characters from gzipped file to stream\n   *  buffer. Always buffered.\n  */\n  virtual int_type\n  underflow();\n\n  /**\n   *  @brief  Write put area to gzipped file.\n   *  @param  c  Extra character to add to buffer contents.\n   *  @return  Non-EOF on success, EOF on error.\n   *\n   *  This actually writes characters in stream buffer to\n   *  gzipped file. With unbuffered output this is done one\n   *  character at a time.\n  */\n  virtual int_type\n  overflow(int_type c = traits_type::eof());\n\n  /**\n   *  @brief  Installs external stream buffer.\n   *  @param  p  Pointer to char buffer.\n   *  @param  n  Size of external buffer.\n   *  @return  @c this on success, NULL on failure.\n   *\n   *  Call setbuf(0,0) to enable unbuffered output.\n  */\n  virtual std::streambuf*\n  setbuf(char_type* p,\n         std::streamsize n);\n\n  /**\n   *  @brief  Flush stream buffer to file.\n   *  @return  0 on success, -1 on error.\n   *\n   *  This calls underflow(EOF) to do the job.\n  */\n  virtual int\n  sync();\n\n//\n// Some future enhancements\n//\n//  virtual int_type uflow();\n//  virtual int_type pbackfail(int_type c = traits_type::eof());\n//  virtual pos_type\n//  seekoff(off_type off,\n//          std::ios_base::seekdir way,\n//          std::ios_base::openmode mode = std::ios_base::in|std::ios_base::out);\n//  virtual pos_type\n//  seekpos(pos_type sp,\n//          std::ios_base::openmode mode = std::ios_base::in|std::ios_base::out);\n\nprivate:\n  /**\n   *  @brief  Allocate internal buffer.\n   *\n   *  This function is safe to call multiple times. It will ensure\n   *  that a proper internal buffer exists if it is required. If the\n   *  buffer already exists or is external, the buffer pointers will be\n   *  reset to their original state.\n  */\n  void\n  enable_buffer();\n\n  /**\n   *  @brief  Destroy internal buffer.\n   *\n   *  This function is safe to call multiple times. It will ensure\n   *  that the internal buffer is deallocated if it exists. In any\n   *  case, it will also reset the buffer pointers.\n  */\n  void\n  disable_buffer();\n\n  /**\n   *  Underlying file pointer.\n  */\n  gzFile file;\n\n  /**\n   *  Mode in which file was opened.\n  */\n  std::ios_base::openmode io_mode;\n\n  /**\n   *  @brief  True if this object owns file descriptor.\n   *\n   *  This makes the class responsible for closing the file\n   *  upon destruction.\n  */\n  bool own_fd;\n\n  /**\n   *  @brief  Stream buffer.\n   *\n   *  For simplicity this remains allocated on the free store for the\n   *  entire life span of the gzfilebuf object, unless replaced by setbuf.\n  */\n  char_type* buffer;\n\n  /**\n   *  @brief  Stream buffer size.\n   *\n   *  Defaults to system default buffer size (typically 8192 bytes).\n   *  Modified by setbuf.\n  */\n  std::streamsize buffer_size;\n\n  /**\n   *  @brief  True if this object owns stream buffer.\n   *\n   *  This makes the class responsible for deleting the buffer\n   *  upon destruction.\n  */\n  bool own_buffer;\n}",
          "class_name": "gzfilebuf",
          "class_pos": [
            [
              26,
              0
            ],
            [
              223,
              1
            ]
          ]
        },
        "8763078d9252ea2fb45d4cc68c31444632056ce072b80c78489644b5b1b0c048": {
          "class_code": "class gzifstream : public std::istream\n{\npublic:\n  //  Default constructor\n  gzifstream();\n\n  /**\n   *  @brief  Construct stream on gzipped file to be opened.\n   *  @param  name  File name.\n   *  @param  mode  Open mode flags (forced to contain ios::in).\n  */\n  explicit\n  gzifstream(const char* name,\n             std::ios_base::openmode mode = std::ios_base::in);\n\n  /**\n   *  @brief  Construct stream on already open gzipped file.\n   *  @param  fd    File descriptor.\n   *  @param  mode  Open mode flags (forced to contain ios::in).\n  */\n  explicit\n  gzifstream(int fd,\n             std::ios_base::openmode mode = std::ios_base::in);\n\n  /**\n   *  Obtain underlying stream buffer.\n  */\n  gzfilebuf*\n  rdbuf() const\n  { return const_cast<gzfilebuf*>(&sb); }\n\n  /**\n   *  @brief  Check if file is open.\n   *  @return  True if file is open.\n  */\n  bool\n  is_open() { return sb.is_open(); }\n\n  /**\n   *  @brief  Open gzipped file.\n   *  @param  name  File name.\n   *  @param  mode  Open mode flags (forced to contain ios::in).\n   *\n   *  Stream will be in state good() if file opens successfully;\n   *  otherwise in state fail(). This differs from the behavior of\n   *  ifstream, which never sets the state to good() and therefore\n   *  won't allow you to reuse the stream for a second file unless\n   *  you manually clear() the state. The choice is a matter of\n   *  convenience.\n  */\n  void\n  open(const char* name,\n       std::ios_base::openmode mode = std::ios_base::in);\n\n  /**\n   *  @brief  Attach to already open gzipped file.\n   *  @param  fd  File descriptor.\n   *  @param  mode  Open mode flags (forced to contain ios::in).\n   *\n   *  Stream will be in state good() if attach succeeded; otherwise\n   *  in state fail().\n  */\n  void\n  attach(int fd,\n         std::ios_base::openmode mode = std::ios_base::in);\n\n  /**\n   *  @brief  Close gzipped file.\n   *\n   *  Stream will be in state fail() if close failed.\n  */\n  void\n  close();\n\nprivate:\n  /**\n   *  Underlying stream buffer.\n  */\n  gzfilebuf sb;\n}",
          "class_name": "gzifstream",
          "class_pos": [
            [
              233,
              0
            ],
            [
              312,
              1
            ]
          ]
        },
        "e3dc7b7db977b179361aa61ef3ae8dcb6a7c615c0b68c6b76ed313482e13dad3": {
          "class_code": "class gzofstream : public std::ostream\n{\npublic:\n  //  Default constructor\n  gzofstream();\n\n  /**\n   *  @brief  Construct stream on gzipped file to be opened.\n   *  @param  name  File name.\n   *  @param  mode  Open mode flags (forced to contain ios::out).\n  */\n  explicit\n  gzofstream(const char* name,\n             std::ios_base::openmode mode = std::ios_base::out);\n\n  /**\n   *  @brief  Construct stream on already open gzipped file.\n   *  @param  fd    File descriptor.\n   *  @param  mode  Open mode flags (forced to contain ios::out).\n  */\n  explicit\n  gzofstream(int fd,\n             std::ios_base::openmode mode = std::ios_base::out);\n\n  /**\n   *  Obtain underlying stream buffer.\n  */\n  gzfilebuf*\n  rdbuf() const\n  { return const_cast<gzfilebuf*>(&sb); }\n\n  /**\n   *  @brief  Check if file is open.\n   *  @return  True if file is open.\n  */\n  bool\n  is_open() { return sb.is_open(); }\n\n  /**\n   *  @brief  Open gzipped file.\n   *  @param  name  File name.\n   *  @param  mode  Open mode flags (forced to contain ios::out).\n   *\n   *  Stream will be in state good() if file opens successfully;\n   *  otherwise in state fail(). This differs from the behavior of\n   *  ofstream, which never sets the state to good() and therefore\n   *  won't allow you to reuse the stream for a second file unless\n   *  you manually clear() the state. The choice is a matter of\n   *  convenience.\n  */\n  void\n  open(const char* name,\n       std::ios_base::openmode mode = std::ios_base::out);\n\n  /**\n   *  @brief  Attach to already open gzipped file.\n   *  @param  fd  File descriptor.\n   *  @param  mode  Open mode flags (forced to contain ios::out).\n   *\n   *  Stream will be in state good() if attach succeeded; otherwise\n   *  in state fail().\n  */\n  void\n  attach(int fd,\n         std::ios_base::openmode mode = std::ios_base::out);\n\n  /**\n   *  @brief  Close gzipped file.\n   *\n   *  Stream will be in state fail() if close failed.\n  */\n  void\n  close();\n\nprivate:\n  /**\n   *  Underlying stream buffer.\n  */\n  gzfilebuf sb;\n}",
          "class_name": "gzofstream",
          "class_pos": [
            [
              322,
              0
            ],
            [
              401,
              1
            ]
          ]
        },
        "d2cef285f878b4d54ab3adcfc38bcd1719322cd67a6b71f6dc8abee471bc6f8c": {
          "class_code": "template<typename T1, typename T2>\n  class gzomanip2\n  {\n  public:\n    // Allows inserter to peek at internals\n    template <typename Ta, typename Tb>\n      friend gzofstream&\n      operator<<(gzofstream&,\n                 const gzomanip2<Ta,Tb>&);\n\n    // Constructor\n    gzomanip2(gzofstream& (*f)(gzofstream&, T1, T2),\n              T1 v1,\n              T2 v2);\n  private:\n    // Underlying manipulator function\n    gzofstream&\n    (*func)(gzofstream&, T1, T2);\n\n    // Arguments for manipulator function\n    T1 val1;\n    T2 val2;\n  };",
          "class_name": "gzomanip2",
          "class_pos": [
            [
              411,
              0
            ],
            [
              433,
              4
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <istream>  // not iostream, since we don't need cin/cout\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#include <ostream>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/minizip/mztools.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "unzRepair(const char* file,\n                             const char* fileOut,\n                             const char* fileOutTmp,\n                             uLong* nRecovered,\n                             uLong* bytesRecovered)",
          "fn_dec_pos": [
            [
              24,
              19
            ],
            [
              28,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzRepair",
            "parameters": {
              "file": "char",
              "fileOut": "char",
              "fileOutTmp": "char",
              "nRecovered": "uLong",
              "bytesRecovered": "uLong"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"zlib.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ],
        [
          "#include \"unzip.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/minizip/crypt.h": {
      "fn_def_list": [
        {
          "fn_code": "static int decrypt_byte(unsigned long* pkeys, const z_crc_t* pcrc_32_tab) {\n    unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an\n                     * unpredictable manner on 16-bit systems; not a problem\n                     * with any known compiler so far, though */\n\n    (void)pcrc_32_tab;\n    temp = ((unsigned)(*(pkeys+2)) & 0xffff) | 2;\n    return (int)(((temp * (temp ^ 1)) >> 8) & 0xff);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              42,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "decrypt_byte",
            "parameters": {
              "pkeys": "unsigned long",
              "pcrc_32_tab": "z_crc_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int update_keys(unsigned long* pkeys, const z_crc_t* pcrc_32_tab, int c) {\n    (*(pkeys+0)) = CRC32((*(pkeys+0)), c);\n    (*(pkeys+1)) += (*(pkeys+0)) & 0xff;\n    (*(pkeys+1)) = (*(pkeys+1)) * 134775813L + 1;\n    {\n      register int keyshift = (int)((*(pkeys+1)) >> 24);\n      (*(pkeys+2)) = CRC32((*(pkeys+2)), keyshift);\n    }\n    return c;\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              56,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "update_keys",
            "parameters": {
              "pkeys": "unsigned long",
              "pcrc_32_tab": "z_crc_t",
              "c": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void init_keys(const char* passwd, unsigned long* pkeys, const z_crc_t* pcrc_32_tab) {\n    *(pkeys+0) = 305419896L;\n    *(pkeys+1) = 591751049L;\n    *(pkeys+2) = 878082192L;\n    while (*passwd != '\\0') {\n        update_keys(pkeys,pcrc_32_tab,(int)*passwd);\n        passwd++;\n    }\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              71,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "init_keys",
            "parameters": {
              "passwd": "char",
              "pkeys": "unsigned long",
              "pcrc_32_tab": "z_crc_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static unsigned crypthead(const char* passwd,       /* password string */\n                          unsigned char* buf,       /* where to write header */\n                          int bufSize,\n                          unsigned long* pkeys,\n                          const z_crc_t* pcrc_32_tab,\n                          unsigned long crcForCrypting) {\n    unsigned n;                  /* index in random header */\n    int t;                       /* temporary */\n    int c;                       /* random byte */\n    unsigned char header[RAND_HEAD_LEN-2]; /* random header */\n    static unsigned calls = 0;   /* ensure different random header each time */\n\n    if (bufSize<RAND_HEAD_LEN)\n      return 0;\n\n    /* First generate RAND_HEAD_LEN-2 random bytes. We encrypt the\n     * output of rand() to get less predictability, since rand() is\n     * often poorly implemented.\n     */\n    if (++calls == 1)\n    {\n        srand((unsigned)(time(NULL) ^ ZCR_SEED2));\n    }\n    init_keys(passwd, pkeys, pcrc_32_tab);\n    for (n = 0; n < RAND_HEAD_LEN-2; n++)\n    {\n        c = (rand() >> 7) & 0xff;\n        header[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, c, t);\n    }\n    /* Encrypt random header (last two bytes is high word of crc) */\n    init_keys(passwd, pkeys, pcrc_32_tab);\n    for (n = 0; n < RAND_HEAD_LEN-2; n++)\n    {\n        buf[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, header[n], t);\n    }\n    buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 16) & 0xff, t);\n    buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 24) & 0xff, t);\n    return n;\n}",
          "fn_code_pos": [
            [
              87,
              0
            ],
            [
              125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "crypthead",
            "parameters": {
              "passwd": "char",
              "buf": "unsigned char",
              "bufSize": "int",
              "pkeys": "unsigned long",
              "pcrc_32_tab": "z_crc_t",
              "crcForCrypting": "unsigned long"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/minizip/iowin32.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "fill_win32_filefunc(zlib_filefunc_def* pzlib_filefunc_def)",
          "fn_dec_pos": [
            [
              20,
              5
            ],
            [
              20,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fill_win32_filefunc",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc_def"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "fill_win32_filefunc64(zlib_filefunc64_def* pzlib_filefunc_def)",
          "fn_dec_pos": [
            [
              21,
              5
            ],
            [
              21,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fill_win32_filefunc64",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_def"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "fill_win32_filefunc64A(zlib_filefunc64_def* pzlib_filefunc_def)",
          "fn_dec_pos": [
            [
              22,
              5
            ],
            [
              22,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fill_win32_filefunc64A",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_def"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "fill_win32_filefunc64W(zlib_filefunc64_def* pzlib_filefunc_def)",
          "fn_dec_pos": [
            [
              23,
              5
            ],
            [
              23,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fill_win32_filefunc64W",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_def"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <windows.h>\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/minizip/unzip.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "unzStringFileNameCompare(const char* fileName1,\n                                            const char* fileName2,\n                                            int iCaseSensitivity)",
          "fn_dec_pos": [
            [
              152,
              19
            ],
            [
              154,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzStringFileNameCompare",
            "parameters": {
              "fileName1": "char",
              "fileName2": "char",
              "iCaseSensitivity": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzOpen(const char *path)",
          "fn_dec_pos": [
            [
              165,
              23
            ],
            [
              165,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpen",
            "parameters": {
              "path": "char"
            },
            "return_type": "unzFile"
          }
        },
        {
          "fn_code": "unzOpen64(const void *path)",
          "fn_dec_pos": [
            [
              166,
              23
            ],
            [
              166,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpen64",
            "parameters": {
              "path": "void"
            },
            "return_type": "unzFile"
          }
        },
        {
          "fn_code": "unzOpen2(const char *path,\n                                zlib_filefunc_def* pzlib_filefunc_def)",
          "fn_dec_pos": [
            [
              183,
              23
            ],
            [
              184,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpen2",
            "parameters": {
              "path": "char",
              "pzlib_filefunc_def": "zlib_filefunc_def"
            },
            "return_type": "unzFile"
          }
        },
        {
          "fn_code": "unzOpen2_64(const void *path,\n                                   zlib_filefunc64_def* pzlib_filefunc_def)",
          "fn_dec_pos": [
            [
              190,
              23
            ],
            [
              191,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpen2_64",
            "parameters": {
              "path": "void",
              "pzlib_filefunc_def": "zlib_filefunc64_def"
            },
            "return_type": "unzFile"
          }
        },
        {
          "fn_code": "unzClose(unzFile file)",
          "fn_dec_pos": [
            [
              197,
              19
            ],
            [
              197,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzClose",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzGetGlobalInfo(unzFile file,\n                                    unz_global_info *pglobal_info)",
          "fn_dec_pos": [
            [
              204,
              19
            ],
            [
              205,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetGlobalInfo",
            "parameters": {
              "file": "unzFile",
              "pglobal_info": "unz_global_info"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzGetGlobalInfo64(unzFile file,\n                                      unz_global_info64 *pglobal_info)",
          "fn_dec_pos": [
            [
              207,
              19
            ],
            [
              208,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetGlobalInfo64",
            "parameters": {
              "file": "unzFile",
              "pglobal_info": "unz_global_info64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzGetGlobalComment(unzFile file,\n                                       char *szComment,\n                                       uLong uSizeBuf)",
          "fn_dec_pos": [
            [
              215,
              19
            ],
            [
              217,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetGlobalComment",
            "parameters": {
              "file": "unzFile",
              "szComment": "char",
              "uSizeBuf": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzGoToFirstFile(unzFile file)",
          "fn_dec_pos": [
            [
              228,
              19
            ],
            [
              228,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGoToFirstFile",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzGoToNextFile(unzFile file)",
          "fn_dec_pos": [
            [
              234,
              19
            ],
            [
              234,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGoToNextFile",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzLocateFile(unzFile file,\n                                 const char *szFileName,\n                                 int iCaseSensitivity)",
          "fn_dec_pos": [
            [
              241,
              19
            ],
            [
              243,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzLocateFile",
            "parameters": {
              "file": "unzFile",
              "szFileName": "char",
              "iCaseSensitivity": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzGetFilePos(\n    unzFile file,\n    unz_file_pos* file_pos)",
          "fn_dec_pos": [
            [
              263,
              19
            ],
            [
              265,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetFilePos",
            "parameters": {
              "file": "unzFile",
              "file_pos": "unz_file_pos"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzGoToFilePos(\n    unzFile file,\n    unz_file_pos* file_pos)",
          "fn_dec_pos": [
            [
              267,
              19
            ],
            [
              269,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGoToFilePos",
            "parameters": {
              "file": "unzFile",
              "file_pos": "unz_file_pos"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzGetFilePos64(\n    unzFile file,\n    unz64_file_pos* file_pos)",
          "fn_dec_pos": [
            [
              277,
              19
            ],
            [
              279,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetFilePos64",
            "parameters": {
              "file": "unzFile",
              "file_pos": "unz64_file_pos"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzGoToFilePos64(\n    unzFile file,\n    const unz64_file_pos* file_pos)",
          "fn_dec_pos": [
            [
              281,
              19
            ],
            [
              283,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGoToFilePos64",
            "parameters": {
              "file": "unzFile",
              "file_pos": "unz64_file_pos"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzGetCurrentFileInfo64(unzFile file,\n                                           unz_file_info64 *pfile_info,\n                                           char *szFileName,\n                                           uLong fileNameBufferSize,\n                                           void *extraField,\n                                           uLong extraFieldBufferSize,\n                                           char *szComment,\n                                           uLong commentBufferSize)",
          "fn_dec_pos": [
            [
              287,
              19
            ],
            [
              294,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetCurrentFileInfo64",
            "parameters": {
              "file": "unzFile",
              "pfile_info": "unz_file_info64",
              "szFileName": "char",
              "fileNameBufferSize": "uLong",
              "extraField": "void",
              "extraFieldBufferSize": "uLong",
              "szComment": "char",
              "commentBufferSize": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzGetCurrentFileInfo(unzFile file,\n                                         unz_file_info *pfile_info,\n                                         char *szFileName,\n                                         uLong fileNameBufferSize,\n                                         void *extraField,\n                                         uLong extraFieldBufferSize,\n                                         char *szComment,\n                                         uLong commentBufferSize)",
          "fn_dec_pos": [
            [
              296,
              19
            ],
            [
              303,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetCurrentFileInfo",
            "parameters": {
              "file": "unzFile",
              "pfile_info": "unz_file_info",
              "szFileName": "char",
              "fileNameBufferSize": "uLong",
              "extraField": "void",
              "extraFieldBufferSize": "uLong",
              "szComment": "char",
              "commentBufferSize": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzGetCurrentFileZStreamPos64(unzFile file)",
          "fn_dec_pos": [
            [
              324,
              24
            ],
            [
              324,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetCurrentFileZStreamPos64",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "ZPOS64_T"
          }
        },
        {
          "fn_code": "unzOpenCurrentFile(unzFile file)",
          "fn_dec_pos": [
            [
              334,
              19
            ],
            [
              334,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpenCurrentFile",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzOpenCurrentFilePassword(unzFile file,\n                                              const char* password)",
          "fn_dec_pos": [
            [
              340,
              19
            ],
            [
              341,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpenCurrentFilePassword",
            "parameters": {
              "file": "unzFile",
              "password": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzOpenCurrentFile2(unzFile file,\n                                       int* method,\n                                       int* level,\n                                       int raw)",
          "fn_dec_pos": [
            [
              348,
              19
            ],
            [
              351,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpenCurrentFile2",
            "parameters": {
              "file": "unzFile",
              "method": "int",
              "level": "int",
              "raw": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzOpenCurrentFile3(unzFile file,\n                                       int* method,\n                                       int* level,\n                                       int raw,\n                                       const char* password)",
          "fn_dec_pos": [
            [
              361,
              19
            ],
            [
              365,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzOpenCurrentFile3",
            "parameters": {
              "file": "unzFile",
              "method": "int",
              "level": "int",
              "raw": "int",
              "password": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzCloseCurrentFile(unzFile file)",
          "fn_dec_pos": [
            [
              376,
              19
            ],
            [
              376,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzCloseCurrentFile",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzReadCurrentFile(unzFile file,\n                                      voidp buf,\n                                      unsigned len)",
          "fn_dec_pos": [
            [
              382,
              19
            ],
            [
              384,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzReadCurrentFile",
            "parameters": {
              "file": "unzFile",
              "buf": "voidp",
              "len": "unsigned"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unztell(unzFile file)",
          "fn_dec_pos": [
            [
              396,
              23
            ],
            [
              396,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unztell",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "z_off_t"
          }
        },
        {
          "fn_code": "unztell64(unzFile file)",
          "fn_dec_pos": [
            [
              398,
              24
            ],
            [
              398,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unztell64",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "ZPOS64_T"
          }
        },
        {
          "fn_code": "unzeof(unzFile file)",
          "fn_dec_pos": [
            [
              403,
              19
            ],
            [
              403,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzeof",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzGetLocalExtrafield(unzFile file,\n                                         voidp buf,\n                                         unsigned len)",
          "fn_dec_pos": [
            [
              408,
              19
            ],
            [
              410,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetLocalExtrafield",
            "parameters": {
              "file": "unzFile",
              "buf": "voidp",
              "len": "unsigned"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzGetOffset64 (unzFile file)",
          "fn_dec_pos": [
            [
              427,
              24
            ],
            [
              427,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetOffset64",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "ZPOS64_T"
          }
        },
        {
          "fn_code": "unzGetOffset (unzFile file)",
          "fn_dec_pos": [
            [
              428,
              21
            ],
            [
              428,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzGetOffset",
            "parameters": {
              "file": "unzFile"
            },
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "unzSetOffset64 (unzFile file, ZPOS64_T pos)",
          "fn_dec_pos": [
            [
              431,
              19
            ],
            [
              431,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzSetOffset64",
            "parameters": {
              "file": "unzFile",
              "pos": "ZPOS64_T"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unzSetOffset (unzFile file, uLong pos)",
          "fn_dec_pos": [
            [
              432,
              19
            ],
            [
              432,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unzSetOffset",
            "parameters": {
              "file": "unzFile",
              "pos": "uLong"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct TagunzFile__ { int unused; } unzFile__;",
          {
            "unused": "int"
          },
          "unzFile__",
          [
            66,
            0
          ],
          [
            66,
            54
          ]
        ],
        [
          "typedef struct tm_unz_s\n{\n    int tm_sec;             /* seconds after the minute - [0,59] */\n    int tm_min;             /* minutes after the hour - [0,59] */\n    int tm_hour;            /* hours since midnight - [0,23] */\n    int tm_mday;            /* day of the month - [1,31] */\n    int tm_mon;             /* months since January - [0,11] */\n    int tm_year;            /* years - [1980..2044] */\n} tm_unz;",
          {
            "tm_sec": "int",
            "tm_min": "int",
            "tm_hour": "int",
            "tm_mday": "int",
            "tm_mon": "int",
            "tm_year": "int"
          },
          "tm_unz",
          [
            83,
            0
          ],
          [
            91,
            9
          ]
        ],
        [
          "typedef struct unz_global_info64_s\n{\n    ZPOS64_T number_entry;         /* total number of entries in\n                                     the central dir on this disk */\n    uLong size_comment;         /* size of the global comment of the zipfile */\n} unz_global_info64;",
          {
            "number_entry": "ZPOS64_T",
            "size_comment": "uLong"
          },
          "unz_global_info64",
          [
            95,
            0
          ],
          [
            100,
            20
          ]
        ],
        [
          "typedef struct unz_global_info_s\n{\n    uLong number_entry;         /* total number of entries in\n                                     the central dir on this disk */\n    uLong size_comment;         /* size of the global comment of the zipfile */\n} unz_global_info;",
          {
            "number_entry": "uLong",
            "size_comment": "uLong"
          },
          "unz_global_info",
          [
            102,
            0
          ],
          [
            107,
            18
          ]
        ],
        [
          "typedef struct unz_file_info64_s\n{\n    uLong version;              /* version made by                 2 bytes */\n    uLong version_needed;       /* version needed to extract       2 bytes */\n    uLong flag;                 /* general purpose bit flag        2 bytes */\n    uLong compression_method;   /* compression method              2 bytes */\n    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */\n    uLong crc;                  /* crc-32                          4 bytes */\n    ZPOS64_T compressed_size;   /* compressed size                 8 bytes */\n    ZPOS64_T uncompressed_size; /* uncompressed size               8 bytes */\n    uLong size_filename;        /* filename length                 2 bytes */\n    uLong size_file_extra;      /* extra field length              2 bytes */\n    uLong size_file_comment;    /* file comment length             2 bytes */\n\n    uLong disk_num_start;       /* disk number start               2 bytes */\n    uLong internal_fa;          /* internal file attributes        2 bytes */\n    uLong external_fa;          /* external file attributes        4 bytes */\n\n    tm_unz tmu_date;\n} unz_file_info64;",
          {
            "version": "uLong",
            "version_needed": "uLong",
            "flag": "uLong",
            "compression_method": "uLong",
            "dosDate": "uLong",
            "crc": "uLong",
            "compressed_size": "ZPOS64_T",
            "uncompressed_size": "ZPOS64_T",
            "size_filename": "uLong",
            "size_file_extra": "uLong",
            "size_file_comment": "uLong",
            "disk_num_start": "uLong",
            "internal_fa": "uLong",
            "external_fa": "uLong",
            "tmu_date": "tm_unz"
          },
          "unz_file_info64",
          [
            110,
            0
          ],
          [
            129,
            18
          ]
        ],
        [
          "typedef struct unz_file_info_s\n{\n    uLong version;              /* version made by                 2 bytes */\n    uLong version_needed;       /* version needed to extract       2 bytes */\n    uLong flag;                 /* general purpose bit flag        2 bytes */\n    uLong compression_method;   /* compression method              2 bytes */\n    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */\n    uLong crc;                  /* crc-32                          4 bytes */\n    uLong compressed_size;      /* compressed size                 4 bytes */\n    uLong uncompressed_size;    /* uncompressed size               4 bytes */\n    uLong size_filename;        /* filename length                 2 bytes */\n    uLong size_file_extra;      /* extra field length              2 bytes */\n    uLong size_file_comment;    /* file comment length             2 bytes */\n\n    uLong disk_num_start;       /* disk number start               2 bytes */\n    uLong internal_fa;          /* internal file attributes        2 bytes */\n    uLong external_fa;          /* external file attributes        4 bytes */\n\n    tm_unz tmu_date;\n} unz_file_info;",
          {
            "version": "uLong",
            "version_needed": "uLong",
            "flag": "uLong",
            "compression_method": "uLong",
            "dosDate": "uLong",
            "crc": "uLong",
            "compressed_size": "uLong",
            "uncompressed_size": "uLong",
            "size_filename": "uLong",
            "size_file_extra": "uLong",
            "size_file_comment": "uLong",
            "disk_num_start": "uLong",
            "internal_fa": "uLong",
            "external_fa": "uLong",
            "tmu_date": "tm_unz"
          },
          "unz_file_info",
          [
            131,
            0
          ],
          [
            150,
            16
          ]
        ],
        [
          "typedef struct unz_file_pos_s\n{\n    uLong pos_in_zip_directory;   /* offset in zip file directory */\n    uLong num_of_file;            /* # of file */\n} unz_file_pos;",
          {
            "pos_in_zip_directory": "uLong",
            "num_of_file": "uLong"
          },
          "unz_file_pos",
          [
            257,
            0
          ],
          [
            261,
            15
          ]
        ],
        [
          "typedef struct unz64_file_pos_s\n{\n    ZPOS64_T pos_in_zip_directory;   /* offset in zip file directory */\n    ZPOS64_T num_of_file;            /* # of file */\n} unz64_file_pos;",
          {
            "pos_in_zip_directory": "ZPOS64_T",
            "num_of_file": "ZPOS64_T"
          },
          "unz64_file_pos",
          [
            271,
            0
          ],
          [
            275,
            17
          ]
        ],
        [
          "typedef struct TagunzFile__ { int unused; } unzFile__;",
          {
            "unused": "int"
          },
          "unzFile__",
          [
            66,
            0
          ],
          [
            66,
            54
          ]
        ],
        [
          "typedef struct tm_unz_s\n{\n    int tm_sec;             /* seconds after the minute - [0,59] */\n    int tm_min;             /* minutes after the hour - [0,59] */\n    int tm_hour;            /* hours since midnight - [0,23] */\n    int tm_mday;            /* day of the month - [1,31] */\n    int tm_mon;             /* months since January - [0,11] */\n    int tm_year;            /* years - [1980..2044] */\n} tm_unz;",
          {
            "tm_sec": "int",
            "tm_min": "int",
            "tm_hour": "int",
            "tm_mday": "int",
            "tm_mon": "int",
            "tm_year": "int"
          },
          "tm_unz",
          [
            83,
            0
          ],
          [
            91,
            9
          ]
        ],
        [
          "typedef struct unz_global_info64_s\n{\n    ZPOS64_T number_entry;         /* total number of entries in\n                                     the central dir on this disk */\n    uLong size_comment;         /* size of the global comment of the zipfile */\n} unz_global_info64;",
          {
            "number_entry": "ZPOS64_T",
            "size_comment": "uLong"
          },
          "unz_global_info64",
          [
            95,
            0
          ],
          [
            100,
            20
          ]
        ],
        [
          "typedef struct unz_global_info_s\n{\n    uLong number_entry;         /* total number of entries in\n                                     the central dir on this disk */\n    uLong size_comment;         /* size of the global comment of the zipfile */\n} unz_global_info;",
          {
            "number_entry": "uLong",
            "size_comment": "uLong"
          },
          "unz_global_info",
          [
            102,
            0
          ],
          [
            107,
            18
          ]
        ],
        [
          "typedef struct unz_file_info64_s\n{\n    uLong version;              /* version made by                 2 bytes */\n    uLong version_needed;       /* version needed to extract       2 bytes */\n    uLong flag;                 /* general purpose bit flag        2 bytes */\n    uLong compression_method;   /* compression method              2 bytes */\n    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */\n    uLong crc;                  /* crc-32                          4 bytes */\n    ZPOS64_T compressed_size;   /* compressed size                 8 bytes */\n    ZPOS64_T uncompressed_size; /* uncompressed size               8 bytes */\n    uLong size_filename;        /* filename length                 2 bytes */\n    uLong size_file_extra;      /* extra field length              2 bytes */\n    uLong size_file_comment;    /* file comment length             2 bytes */\n\n    uLong disk_num_start;       /* disk number start               2 bytes */\n    uLong internal_fa;          /* internal file attributes        2 bytes */\n    uLong external_fa;          /* external file attributes        4 bytes */\n\n    tm_unz tmu_date;\n} unz_file_info64;",
          {
            "version": "uLong",
            "version_needed": "uLong",
            "flag": "uLong",
            "compression_method": "uLong",
            "dosDate": "uLong",
            "crc": "uLong",
            "compressed_size": "ZPOS64_T",
            "uncompressed_size": "ZPOS64_T",
            "size_filename": "uLong",
            "size_file_extra": "uLong",
            "size_file_comment": "uLong",
            "disk_num_start": "uLong",
            "internal_fa": "uLong",
            "external_fa": "uLong",
            "tmu_date": "tm_unz"
          },
          "unz_file_info64",
          [
            110,
            0
          ],
          [
            129,
            18
          ]
        ],
        [
          "typedef struct unz_file_info_s\n{\n    uLong version;              /* version made by                 2 bytes */\n    uLong version_needed;       /* version needed to extract       2 bytes */\n    uLong flag;                 /* general purpose bit flag        2 bytes */\n    uLong compression_method;   /* compression method              2 bytes */\n    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */\n    uLong crc;                  /* crc-32                          4 bytes */\n    uLong compressed_size;      /* compressed size                 4 bytes */\n    uLong uncompressed_size;    /* uncompressed size               4 bytes */\n    uLong size_filename;        /* filename length                 2 bytes */\n    uLong size_file_extra;      /* extra field length              2 bytes */\n    uLong size_file_comment;    /* file comment length             2 bytes */\n\n    uLong disk_num_start;       /* disk number start               2 bytes */\n    uLong internal_fa;          /* internal file attributes        2 bytes */\n    uLong external_fa;          /* external file attributes        4 bytes */\n\n    tm_unz tmu_date;\n} unz_file_info;",
          {
            "version": "uLong",
            "version_needed": "uLong",
            "flag": "uLong",
            "compression_method": "uLong",
            "dosDate": "uLong",
            "crc": "uLong",
            "compressed_size": "uLong",
            "uncompressed_size": "uLong",
            "size_filename": "uLong",
            "size_file_extra": "uLong",
            "size_file_comment": "uLong",
            "disk_num_start": "uLong",
            "internal_fa": "uLong",
            "external_fa": "uLong",
            "tmu_date": "tm_unz"
          },
          "unz_file_info",
          [
            131,
            0
          ],
          [
            150,
            16
          ]
        ],
        [
          "typedef struct unz_file_pos_s\n{\n    uLong pos_in_zip_directory;   /* offset in zip file directory */\n    uLong num_of_file;            /* # of file */\n} unz_file_pos;",
          {
            "pos_in_zip_directory": "uLong",
            "num_of_file": "uLong"
          },
          "unz_file_pos",
          [
            257,
            0
          ],
          [
            261,
            15
          ]
        ],
        [
          "typedef struct unz64_file_pos_s\n{\n    ZPOS64_T pos_in_zip_directory;   /* offset in zip file directory */\n    ZPOS64_T num_of_file;            /* # of file */\n} unz64_file_pos;",
          {
            "pos_in_zip_directory": "ZPOS64_T",
            "num_of_file": "ZPOS64_T"
          },
          "unz64_file_pos",
          [
            271,
            0
          ],
          [
            275,
            17
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"zlib.h\"\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include \"ioapi.h\"\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include \"bzlib.h\"\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/minizip/ints.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <limits.h>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/minizip/zip.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "zipOpen(const char *pathname, int append)",
          "fn_dec_pos": [
            [
              115,
              23
            ],
            [
              115,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpen",
            "parameters": {
              "pathname": "char",
              "append": "int"
            },
            "return_type": "zipFile"
          }
        },
        {
          "fn_code": "zipOpen64(const void *pathname, int append)",
          "fn_dec_pos": [
            [
              116,
              23
            ],
            [
              116,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpen64",
            "parameters": {
              "pathname": "void",
              "append": "int"
            },
            "return_type": "zipFile"
          }
        },
        {
          "fn_code": "zipOpen2(const char *pathname,\n                                int append,\n                                zipcharpc* globalcomment,\n                                zlib_filefunc_def* pzlib_filefunc_def)",
          "fn_dec_pos": [
            [
              136,
              23
            ],
            [
              139,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpen2",
            "parameters": {
              "pathname": "char",
              "append": "int",
              "globalcomment": "zipcharpc",
              "pzlib_filefunc_def": "zlib_filefunc_def"
            },
            "return_type": "zipFile"
          }
        },
        {
          "fn_code": "zipOpen2_64(const void *pathname,\n                                   int append,\n                                   zipcharpc* globalcomment,\n                                   zlib_filefunc64_def* pzlib_filefunc_def)",
          "fn_dec_pos": [
            [
              141,
              23
            ],
            [
              144,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpen2_64",
            "parameters": {
              "pathname": "void",
              "append": "int",
              "globalcomment": "zipcharpc",
              "pzlib_filefunc_def": "zlib_filefunc64_def"
            },
            "return_type": "zipFile"
          }
        },
        {
          "fn_code": "zipOpen3(const void *pathname,\n                                int append,\n                                zipcharpc* globalcomment,\n                                zlib_filefunc64_32_def* pzlib_filefunc64_32_def)",
          "fn_dec_pos": [
            [
              146,
              23
            ],
            [
              149,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpen3",
            "parameters": {
              "pathname": "void",
              "append": "int",
              "globalcomment": "zipcharpc",
              "pzlib_filefunc64_32_def": "zlib_filefunc64_32_def"
            },
            "return_type": "zipFile"
          }
        },
        {
          "fn_code": "zipOpenNewFileInZip(zipFile file,\n                                       const char* filename,\n                                       const zip_fileinfo* zipfi,\n                                       const void* extrafield_local,\n                                       uInt size_extrafield_local,\n                                       const void* extrafield_global,\n                                       uInt size_extrafield_global,\n                                       const char* comment,\n                                       int method,\n                                       int level)",
          "fn_dec_pos": [
            [
              151,
              19
            ],
            [
              160,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpenNewFileInZip",
            "parameters": {
              "file": "zipFile",
              "filename": "char",
              "zipfi": "zip_fileinfo",
              "extrafield_local": "void",
              "size_extrafield_local": "uInt",
              "extrafield_global": "void",
              "size_extrafield_global": "uInt",
              "comment": "char",
              "method": "int",
              "level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "zipOpenNewFileInZip64(zipFile file,\n                                         const char* filename,\n                                         const zip_fileinfo* zipfi,\n                                         const void* extrafield_local,\n                                         uInt size_extrafield_local,\n                                         const void* extrafield_global,\n                                         uInt size_extrafield_global,\n                                         const char* comment,\n                                         int method,\n                                         int level,\n                                         int zip64)",
          "fn_dec_pos": [
            [
              162,
              19
            ],
            [
              172,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpenNewFileInZip64",
            "parameters": {
              "file": "zipFile",
              "filename": "char",
              "zipfi": "zip_fileinfo",
              "extrafield_local": "void",
              "size_extrafield_local": "uInt",
              "extrafield_global": "void",
              "size_extrafield_global": "uInt",
              "comment": "char",
              "method": "int",
              "level": "int",
              "zip64": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "zipOpenNewFileInZip2(zipFile file,\n                                        const char* filename,\n                                        const zip_fileinfo* zipfi,\n                                        const void* extrafield_local,\n                                        uInt size_extrafield_local,\n                                        const void* extrafield_global,\n                                        uInt size_extrafield_global,\n                                        const char* comment,\n                                        int method,\n                                        int level,\n                                        int raw)",
          "fn_dec_pos": [
            [
              191,
              19
            ],
            [
              201,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpenNewFileInZip2",
            "parameters": {
              "file": "zipFile",
              "filename": "char",
              "zipfi": "zip_fileinfo",
              "extrafield_local": "void",
              "size_extrafield_local": "uInt",
              "extrafield_global": "void",
              "size_extrafield_global": "uInt",
              "comment": "char",
              "method": "int",
              "level": "int",
              "raw": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "zipOpenNewFileInZip2_64(zipFile file,\n                                           const char* filename,\n                                           const zip_fileinfo* zipfi,\n                                           const void* extrafield_local,\n                                           uInt size_extrafield_local,\n                                           const void* extrafield_global,\n                                           uInt size_extrafield_global,\n                                           const char* comment,\n                                           int method,\n                                           int level,\n                                           int raw,\n                                           int zip64)",
          "fn_dec_pos": [
            [
              204,
              19
            ],
            [
              215,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpenNewFileInZip2_64",
            "parameters": {
              "file": "zipFile",
              "filename": "char",
              "zipfi": "zip_fileinfo",
              "extrafield_local": "void",
              "size_extrafield_local": "uInt",
              "extrafield_global": "void",
              "size_extrafield_global": "uInt",
              "comment": "char",
              "method": "int",
              "level": "int",
              "raw": "int",
              "zip64": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "zipOpenNewFileInZip3(zipFile file,\n                                        const char* filename,\n                                        const zip_fileinfo* zipfi,\n                                        const void* extrafield_local,\n                                        uInt size_extrafield_local,\n                                        const void* extrafield_global,\n                                        uInt size_extrafield_global,\n                                        const char* comment,\n                                        int method,\n                                        int level,\n                                        int raw,\n                                        int windowBits,\n                                        int memLevel,\n                                        int strategy,\n                                        const char* password,\n                                        uLong crcForCrypting)",
          "fn_dec_pos": [
            [
              220,
              19
            ],
            [
              235,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpenNewFileInZip3",
            "parameters": {
              "file": "zipFile",
              "filename": "char",
              "zipfi": "zip_fileinfo",
              "extrafield_local": "void",
              "size_extrafield_local": "uInt",
              "extrafield_global": "void",
              "size_extrafield_global": "uInt",
              "comment": "char",
              "method": "int",
              "level": "int",
              "raw": "int",
              "windowBits": "int",
              "memLevel": "int",
              "strategy": "int",
              "password": "char",
              "crcForCrypting": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "zipOpenNewFileInZip3_64(zipFile file,\n                                           const char* filename,\n                                           const zip_fileinfo* zipfi,\n                                           const void* extrafield_local,\n                                           uInt size_extrafield_local,\n                                           const void* extrafield_global,\n                                           uInt size_extrafield_global,\n                                           const char* comment,\n                                           int method,\n                                           int level,\n                                           int raw,\n                                           int windowBits,\n                                           int memLevel,\n                                           int strategy,\n                                           const char* password,\n                                           uLong crcForCrypting,\n                                           int zip64)",
          "fn_dec_pos": [
            [
              237,
              19
            ],
            [
              253,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpenNewFileInZip3_64",
            "parameters": {
              "file": "zipFile",
              "filename": "char",
              "zipfi": "zip_fileinfo",
              "extrafield_local": "void",
              "size_extrafield_local": "uInt",
              "extrafield_global": "void",
              "size_extrafield_global": "uInt",
              "comment": "char",
              "method": "int",
              "level": "int",
              "raw": "int",
              "windowBits": "int",
              "memLevel": "int",
              "strategy": "int",
              "password": "char",
              "crcForCrypting": "uLong",
              "zip64": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "zipOpenNewFileInZip4(zipFile file,\n                                        const char* filename,\n                                        const zip_fileinfo* zipfi,\n                                        const void* extrafield_local,\n                                        uInt size_extrafield_local,\n                                        const void* extrafield_global,\n                                        uInt size_extrafield_global,\n                                        const char* comment,\n                                        int method,\n                                        int level,\n                                        int raw,\n                                        int windowBits,\n                                        int memLevel,\n                                        int strategy,\n                                        const char* password,\n                                        uLong crcForCrypting,\n                                        uLong versionMadeBy,\n                                        uLong flagBase)",
          "fn_dec_pos": [
            [
              262,
              19
            ],
            [
              279,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpenNewFileInZip4",
            "parameters": {
              "file": "zipFile",
              "filename": "char",
              "zipfi": "zip_fileinfo",
              "extrafield_local": "void",
              "size_extrafield_local": "uInt",
              "extrafield_global": "void",
              "size_extrafield_global": "uInt",
              "comment": "char",
              "method": "int",
              "level": "int",
              "raw": "int",
              "windowBits": "int",
              "memLevel": "int",
              "strategy": "int",
              "password": "char",
              "crcForCrypting": "uLong",
              "versionMadeBy": "uLong",
              "flagBase": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "zipOpenNewFileInZip4_64(zipFile file,\n                                           const char* filename,\n                                           const zip_fileinfo* zipfi,\n                                           const void* extrafield_local,\n                                           uInt size_extrafield_local,\n                                           const void* extrafield_global,\n                                           uInt size_extrafield_global,\n                                           const char* comment,\n                                           int method,\n                                           int level,\n                                           int raw,\n                                           int windowBits,\n                                           int memLevel,\n                                           int strategy,\n                                           const char* password,\n                                           uLong crcForCrypting,\n                                           uLong versionMadeBy,\n                                           uLong flagBase,\n                                           int zip64)",
          "fn_dec_pos": [
            [
              282,
              19
            ],
            [
              300,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipOpenNewFileInZip4_64",
            "parameters": {
              "file": "zipFile",
              "filename": "char",
              "zipfi": "zip_fileinfo",
              "extrafield_local": "void",
              "size_extrafield_local": "uInt",
              "extrafield_global": "void",
              "size_extrafield_global": "uInt",
              "comment": "char",
              "method": "int",
              "level": "int",
              "raw": "int",
              "windowBits": "int",
              "memLevel": "int",
              "strategy": "int",
              "password": "char",
              "crcForCrypting": "uLong",
              "versionMadeBy": "uLong",
              "flagBase": "uLong",
              "zip64": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "zipWriteInFileInZip(zipFile file,\n                                       const void* buf,\n                                       unsigned len)",
          "fn_dec_pos": [
            [
              308,
              19
            ],
            [
              310,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipWriteInFileInZip",
            "parameters": {
              "file": "zipFile",
              "buf": "void",
              "len": "unsigned"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "zipCloseFileInZip(zipFile file)",
          "fn_dec_pos": [
            [
              315,
              19
            ],
            [
              315,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipCloseFileInZip",
            "parameters": {
              "file": "zipFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "zipCloseFileInZipRaw(zipFile file,\n                                        uLong uncompressed_size,\n                                        uLong crc32)",
          "fn_dec_pos": [
            [
              320,
              19
            ],
            [
              322,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipCloseFileInZipRaw",
            "parameters": {
              "file": "zipFile",
              "uncompressed_size": "uLong",
              "crc32": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "zipCloseFileInZipRaw64(zipFile file,\n                                          ZPOS64_T uncompressed_size,\n                                          uLong crc32)",
          "fn_dec_pos": [
            [
              324,
              19
            ],
            [
              326,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipCloseFileInZipRaw64",
            "parameters": {
              "file": "zipFile",
              "uncompressed_size": "ZPOS64_T",
              "crc32": "uLong"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "zipAlreadyThere(zipFile file,\n                                   char const* name)",
          "fn_dec_pos": [
            [
              328,
              19
            ],
            [
              329,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipAlreadyThere",
            "parameters": {
              "file": "zipFile",
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "zipClose(zipFile file,\n                            const char* global_comment)",
          "fn_dec_pos": [
            [
              340,
              19
            ],
            [
              341,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipClose",
            "parameters": {
              "file": "zipFile",
              "global_comment": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "zipRemoveExtraInfoBlock(char* pData, int* dataLen, short sHeader)",
          "fn_dec_pos": [
            [
              347,
              19
            ],
            [
              347,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zipRemoveExtraInfoBlock",
            "parameters": {
              "pData": "char",
              "dataLen": "int",
              "sHeader": "short"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct TagzipFile__ { int unused; } zipFile__;",
          {
            "unused": "int"
          },
          "zipFile__",
          [
            65,
            0
          ],
          [
            65,
            54
          ]
        ],
        [
          "typedef struct tm_zip_s\n{\n    int tm_sec;             /* seconds after the minute - [0,59] */\n    int tm_min;             /* minutes after the hour - [0,59] */\n    int tm_hour;            /* hours since midnight - [0,23] */\n    int tm_mday;            /* day of the month - [1,31] */\n    int tm_mon;             /* months since January - [0,11] */\n    int tm_year;            /* years - [1980..2044] */\n} tm_zip;",
          {
            "tm_sec": "int",
            "tm_min": "int",
            "tm_hour": "int",
            "tm_mday": "int",
            "tm_mon": "int",
            "tm_year": "int"
          },
          "tm_zip",
          [
            88,
            0
          ],
          [
            96,
            9
          ]
        ],
        [
          "typedef struct\n{\n    tm_zip      tmz_date;       /* date in understandable format           */\n    uLong       dosDate;       /* if dos_date == 0, tmu_date is used      */\n/*    uLong       flag;        */   /* general purpose bit flag        2 bytes */\n\n    uLong       internal_fa;    /* internal file attributes        2 bytes */\n    uLong       external_fa;    /* external file attributes        4 bytes */\n} zip_fileinfo;",
          {
            "tmz_date": "tm_zip",
            "dosDate": "uLong",
            "internal_fa": "uLong",
            "external_fa": "uLong"
          },
          "zip_fileinfo",
          [
            98,
            0
          ],
          [
            106,
            15
          ]
        ],
        [
          "typedef struct TagzipFile__ { int unused; } zipFile__;",
          {
            "unused": "int"
          },
          "zipFile__",
          [
            65,
            0
          ],
          [
            65,
            54
          ]
        ],
        [
          "typedef struct tm_zip_s\n{\n    int tm_sec;             /* seconds after the minute - [0,59] */\n    int tm_min;             /* minutes after the hour - [0,59] */\n    int tm_hour;            /* hours since midnight - [0,23] */\n    int tm_mday;            /* day of the month - [1,31] */\n    int tm_mon;             /* months since January - [0,11] */\n    int tm_year;            /* years - [1980..2044] */\n} tm_zip;",
          {
            "tm_sec": "int",
            "tm_min": "int",
            "tm_hour": "int",
            "tm_mday": "int",
            "tm_mon": "int",
            "tm_year": "int"
          },
          "tm_zip",
          [
            88,
            0
          ],
          [
            96,
            9
          ]
        ],
        [
          "typedef struct\n{\n    tm_zip      tmz_date;       /* date in understandable format           */\n    uLong       dosDate;       /* if dos_date == 0, tmu_date is used      */\n/*    uLong       flag;        */   /* general purpose bit flag        2 bytes */\n\n    uLong       internal_fa;    /* internal file attributes        2 bytes */\n    uLong       external_fa;    /* external file attributes        4 bytes */\n} zip_fileinfo;",
          {
            "tmz_date": "tm_zip",
            "dosDate": "uLong",
            "internal_fa": "uLong",
            "external_fa": "uLong"
          },
          "zip_fileinfo",
          [
            98,
            0
          ],
          [
            106,
            15
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"zlib.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include \"ioapi.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include \"bzlib.h\"\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/minizip/skipset.h": {
      "fn_def_list": [
        {
          "fn_code": "void set_seed(set_rand_t *gen, ui64_t seed, ui64_t seq) {\n    gen->inc = (seq << 1) | 1;\n    gen->state = (seed + gen->inc) * 6364136223846793005ULL + gen->inc;\n}",
          "fn_code_pos": [
            [
              82,
              0
            ],
            [
              85,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_seed",
            "parameters": {
              "gen": "set_rand_t",
              "seed": "ui64_t",
              "seq": "ui64_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "ui32_t set_rand(set_rand_t *gen) {\n    ui64_t state = gen->state;\n    gen->state = state * 6364136223846793005ULL + gen->inc;\n    ui32_t mix = (ui32_t)(((state >> 18) ^ state) >> 27);\n    int rot = state >> 59;\n    return (mix >> rot) | (mix << ((-rot) & 31));\n}",
          "fn_code_pos": [
            [
              87,
              0
            ],
            [
              93,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_rand",
            "parameters": {
              "gen": "set_rand_t"
            },
            "return_type": "ui32_t"
          }
        },
        {
          "fn_code": "void *set_alloc(set_t *set, void *ptr, size_t size) {\n    size_t had = ptr == NULL ? 0 : SET_ALLOC_SIZE(ptr);\n    void *mem = realloc(ptr, size);\n    if (mem == NULL)\n        longjmp(set->env, ENOMEM);\n    set->allocs += ptr == NULL;\n    set->memory += SET_ALLOC_SIZE(mem) - had;\n    return mem;\n}",
          "fn_code_pos": [
            [
              147,
              0
            ],
            [
              155,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_alloc",
            "parameters": {
              "set": "set_t",
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void set_free(set_t *set, void *ptr) {\n    if (ptr != NULL) {\n        set->allocs--;\n        set->memory -= SET_ALLOC_SIZE(ptr);\n        free(ptr);\n    }\n}",
          "fn_code_pos": [
            [
              156,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_free",
            "parameters": {
              "set": "set_t",
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void *set_alloc(set_t *set, void *ptr, size_t size) {\n    void *mem = realloc(ptr, size);\n    if (mem == NULL)\n        longjmp(set->env, ENOMEM);\n    return mem;\n}",
          "fn_code_pos": [
            [
              165,
              0
            ],
            [
              170,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_alloc",
            "parameters": {
              "set": "set_t",
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void set_free(set_t *set, void *ptr) {\n    (void)set;\n    free(ptr);\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              174,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_free",
            "parameters": {
              "set": "set_t",
              "ptr": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void set_grow(set_t *set, set_node_t *node, int want, int fill) {\n    if (node->size < want) {\n        int more = node->size ? node->size : 1;\n        while (more < want)\n            more <<= 1;\n        node->right = set_alloc(set, node->right, more * sizeof(set_node_t *));\n        node->size = (i16_t)more;\n    }\n    int i;\n    if (fill)\n        for (i = node->fill; i < want; i++)\n            node->right[i] = set->head;\n    node->fill = (i16_t)want;\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              194,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_grow",
            "parameters": {
              "set": "set_t",
              "node": "set_node_t",
              "want": "int",
              "fill": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "set_node_t *set_node(set_t *set) {\n    set_node_t *node = set_alloc(set, NULL, sizeof(set_node_t));\n    node->size = 0;\n    node->fill = 0;\n    node->right = NULL;\n    return node;\n}",
          "fn_code_pos": [
            [
              197,
              0
            ],
            [
              203,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_node",
            "parameters": {
              "set": "set_t"
            },
            "return_type": "set_node_t"
          }
        },
        {
          "fn_code": "void set_sweep(set_t *set) {\n    set_node_t *step = set->head->right[0];\n    while (step != set->head) {\n        set_node_t *next = step->right[0];      // save link to next node\n        set_drop(set, step->key);\n        set_free(set, step->right);\n        set_free(set, step);\n        step = next;\n    }\n}",
          "fn_code_pos": [
            [
              206,
              0
            ],
            [
              215,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_sweep",
            "parameters": {
              "set": "set_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void set_start(set_t *set) {\n#ifdef SET_TRACK\n    set->allocs = 0;\n    set->memory = 0;\n#endif\n    set->head = set->path = set->node = NULL;   // in case set_node() fails\n    set->path = set_node(set);\n    set->head = set_node(set);\n    set_grow(set, set->head, 1, 1); // one link back to head for an empty set\n    *(unsigned char *)&set->head->key = 137;    // set id\n    set->depth = 0;\n    set_seed(&set->gen, ((ui64_t)(ptrdiff_t)set << 32) ^\n                        ((ui64_t)time(NULL) << 12) ^ clock(), 0);\n    set->ran = 1;\n}",
          "fn_code_pos": [
            [
              223,
              0
            ],
            [
              237,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_start",
            "parameters": {
              "set": "set_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int set_ok(set_t *set) {\n    return set->head != NULL &&\n           set->head->right != NULL &&\n           *(unsigned char *)&set->head->key == 137;\n}",
          "fn_code_pos": [
            [
              241,
              0
            ],
            [
              245,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_ok",
            "parameters": {
              "set": "set_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void set_clear(set_t *set) {\n    assert(set_ok(set) && \"improper use\");\n\n    // Free all the keys and their nodes.\n    set_sweep(set);\n\n    // Leave the head and path allocations as is. Clear their contents, with\n    // head pointing to itself and setting depth to zero, for an empty set.\n    set->head->right[0] = set->head;\n    set->head->fill = 1;\n    set->path->fill = 0;\n    set->depth = 0;\n}",
          "fn_code_pos": [
            [
              249,
              0
            ],
            [
              261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_clear",
            "parameters": {
              "set": "set_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void set_end(set_t *set) {\n    if (set->head != NULL) {\n        // Empty the set and free the head node.\n        if (set->head->right != NULL) {\n            set_sweep(set);\n            set_free(set, set->head->right);\n        }\n        set_free(set, set->head);\n        set->head = NULL;\n    }\n    if (set->path != NULL) {\n        // Free the path work area.\n        set_free(set, set->path->right);\n        set_free(set, set->path);\n        set->path = NULL;\n    }\n    if (set->node != NULL) {\n        // Free the node that was under construction when longjmp() hit.\n        set_drop(set, set->node->key);\n        set_free(set, set->node->right);\n        set_free(set, set->node);\n        set->node = NULL;\n    }\n}",
          "fn_code_pos": [
            [
              267,
              0
            ],
            [
              290,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_end",
            "parameters": {
              "set": "set_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int set_found(set_t *set, set_key_t key) {\n    assert(set_ok(set) && \"improper use\");\n\n    // Start at depth and work down and right as determined by key comparisons.\n    set_node_t *head = set->head, *here = head;\n    int i = set->depth;\n    set_grow(set, set->path, i + 1, 0);\n    do {\n        while (here->right[i] != head &&\n               set_cmp(here->right[i]->key, key) < 0)\n            here = here->right[i];\n        set->path->right[i] = here;\n    } while (i--);\n\n    // See if the key matches.\n    here = here->right[0];\n    return here != head && set_cmp(here->key, key) == 0;\n}",
          "fn_code_pos": [
            [
              294,
              0
            ],
            [
              311,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_found",
            "parameters": {
              "set": "set_t",
              "key": "set_key_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int set_insert(set_t *set, set_key_t key) {\n    assert(set_ok(set) && \"improper use\");\n\n    if (set_found(set, key))\n        // That key is already in the set.\n        return 1;\n\n    // Randomly generate a new level-- level 0 with probability 1/2, 1 with\n    // probability 1/4, 2 with probability 1/8, etc.\n    int level = 0;\n    for (;;) {\n        if (set->ran == 1)\n            // Ran out. Get another 32 random bits.\n            set->ran = set_rand(&set->gen) | (1ULL << 32);\n        int bit = set->ran & 1;\n        set->ran >>= 1;\n        if (bit)\n            break;\n        assert(level < 32767 &&\n               \"Overhead, without any fuss, the stars were going out.\");\n        level++;\n    }\n    if (level > set->depth) {\n        // The maximum depth is now deeper. Update the structures.\n        set_grow(set, set->path, level + 1, 1);\n        set_grow(set, set->head, level + 1, 1);\n        set->depth = (i16_t)level;\n    }\n\n    // Make a new node for the provided key, and insert it in the lists up to\n    // and including level.\n    set->node = set_node(set);\n    set->node->key = key;\n    set_grow(set, set->node, level + 1, 0);\n    int i;\n    for (i = 0; i <= level; i++) {\n        set->node->right[i] = set->path->right[i]->right[i];\n        set->path->right[i]->right[i] = set->node;\n    }\n    set->node = NULL;\n    return 0;\n}",
          "fn_code_pos": [
            [
              314,
              0
            ],
            [
              355,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_insert",
            "parameters": {
              "set": "set_t",
              "key": "set_key_t"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "set_alloc(set_t *set, void *ptr, size_t size)",
          "fn_dec_pos": [
            [
              147,
              6
            ],
            [
              147,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_alloc",
            "parameters": {
              "set": "set_t",
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "set_alloc(set_t *set, void *ptr, size_t size)",
          "fn_dec_pos": [
            [
              165,
              6
            ],
            [
              165,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_alloc",
            "parameters": {
              "set": "set_t",
              "ptr": "void",
              "size": "size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "set_node(set_t *set)",
          "fn_dec_pos": [
            [
              197,
              12
            ],
            [
              197,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "set_node",
            "parameters": {
              "set": "set_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n    ui64_t state;       // 64-bit generator state\n    ui64_t inc;         // 63-bit sequence id\n} set_rand_t;",
          {
            "state": "ui64_t",
            "inc": "ui64_t"
          },
          "set_rand_t",
          [
            76,
            0
          ],
          [
            79,
            13
          ]
        ],
        [
          "struct set_node_s {\n    set_key_t key;          // the key (not used for head or path)\n    i16_t size;             // number of allocated pointers in right[]\n    i16_t fill;             // number of pointers in right[] filled in\n    set_node_t **right;     // pointer for each level, each to the right\n}",
          {
            "key": "set_key_t",
            "size": "i16_t",
            "fill": "i16_t",
            "**right": "set_node_t"
          },
          "set_node_s",
          [
            98,
            0
          ],
          [
            103,
            1
          ]
        ],
        [
          "typedef struct set_s {\n    set_node_t *head;       // skiplist head -- no key, just links\n    set_node_t *path;       // right[] is path to key from set_found()\n    set_node_t *node;       // node under construction, in case of longjmp()\n    i16_t depth;            // maximum depth of the skiplist\n    ui64_t ran;             // a precious trove of random bits\n    set_rand_t gen;         // random number generator state\n    jmp_buf env;            // setjmp() environment for allocation errors\n#ifdef SET_TRACK\n    size_t allocs;          // number of allocations\n    size_t memory;          // total amount of allocated memory (>= requests)\n#endif\n} set_t;",
          {
            "*head": "set_node_t",
            "*path": "set_node_t",
            "*node": "set_node_t",
            "depth": "i16_t",
            "ran": "ui64_t",
            "gen": "set_rand_t",
            "env": "jmp_buf",
            "allocs": "size_t",
            "memory": "size_t"
          },
          "set_t",
          [
            107,
            0
          ],
          [
            119,
            8
          ]
        ],
        [
          "typedef struct {\n    ui64_t state;       // 64-bit generator state\n    ui64_t inc;         // 63-bit sequence id\n} set_rand_t;",
          {
            "state": "ui64_t",
            "inc": "ui64_t"
          },
          "set_rand_t",
          [
            76,
            0
          ],
          [
            79,
            13
          ]
        ],
        [
          "typedef struct set_node_s set_node_t;",
          {},
          "set_node_t",
          [
            97,
            0
          ],
          [
            97,
            37
          ]
        ],
        [
          "struct set_node_s {\n    set_key_t key;          // the key (not used for head or path)\n    i16_t size;             // number of allocated pointers in right[]\n    i16_t fill;             // number of pointers in right[] filled in\n    set_node_t **right;     // pointer for each level, each to the right\n}",
          {
            "key": "set_key_t",
            "size": "i16_t",
            "fill": "i16_t",
            "**right": "set_node_t"
          },
          "set_node_s",
          [
            98,
            0
          ],
          [
            103,
            1
          ]
        ],
        [
          "typedef struct set_s {\n    set_node_t *head;       // skiplist head -- no key, just links\n    set_node_t *path;       // right[] is path to key from set_found()\n    set_node_t *node;       // node under construction, in case of longjmp()\n    i16_t depth;            // maximum depth of the skiplist\n    ui64_t ran;             // a precious trove of random bits\n    set_rand_t gen;         // random number generator state\n    jmp_buf env;            // setjmp() environment for allocation errors\n#ifdef SET_TRACK\n    size_t allocs;          // number of allocations\n    size_t memory;          // total amount of allocated memory (>= requests)\n#endif\n} set_t;",
          {
            "*head": "set_node_t",
            "*path": "set_node_t",
            "*node": "set_node_t",
            "depth": "i16_t",
            "ran": "ui64_t",
            "gen": "set_rand_t",
            "env": "jmp_buf",
            "allocs": "size_t",
            "memory": "size_t"
          },
          "set_t",
          [
            107,
            0
          ],
          [
            119,
            8
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdlib.h>     // realloc(), free(), NULL, size_t\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#include <stddef.h>     // ptrdiff_t\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include <setjmp.h>     // jmp_buf, longjmp()\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ],
        [
          "#include <errno.h>      // ENOMEM\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include <time.h>       // time(), clock()\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ],
        [
          "#include <assert.h>     // assert.h\n",
          [
            62,
            0
          ],
          [
            63,
            0
          ]
        ],
        [
          "#include \"ints.h\"       // i16_t, ui32_t, ui64_t\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#    include <malloc.h>\n",
          [
            129,
            0
          ],
          [
            130,
            0
          ]
        ],
        [
          "#    include <malloc/malloc.h>\n",
          [
            132,
            0
          ],
          [
            133,
            0
          ]
        ],
        [
          "#    include <malloc.h>\n",
          [
            135,
            0
          ],
          [
            136,
            0
          ]
        ],
        [
          "#    include <malloc_np.h>\n",
          [
            138,
            0
          ],
          [
            139,
            0
          ]
        ],
        [
          "#    include <jemalloc/jemalloc.h>\n",
          [
            141,
            0
          ],
          [
            142,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/minizip/ioapi.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(ZCALLBACK *open_file_func)      (voidpf opaque, const char* filename, int mode)",
          "fn_dec_pos": [
            [
              109,
              17
            ],
            [
              109,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "opaque": "voidpf",
              "filename": "char",
              "mode": "int"
            },
            "return_type": "voidpf"
          }
        },
        {
          "fn_code": "(ZCALLBACK *read_file_func)      (voidpf opaque, voidpf stream, void* buf, uLong size)",
          "fn_dec_pos": [
            [
              110,
              17
            ],
            [
              110,
              103
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf",
              "buf": "void",
              "size": "uLong"
            },
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "(ZCALLBACK *write_file_func)     (voidpf opaque, voidpf stream, const void* buf, uLong size)",
          "fn_dec_pos": [
            [
              111,
              17
            ],
            [
              111,
              109
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf",
              "buf": "void",
              "size": "uLong"
            },
            "return_type": "uLong"
          }
        },
        {
          "fn_code": "(ZCALLBACK *close_file_func)     (voidpf opaque, voidpf stream)",
          "fn_dec_pos": [
            [
              112,
              17
            ],
            [
              112,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(ZCALLBACK *testerror_file_func) (voidpf opaque, voidpf stream)",
          "fn_dec_pos": [
            [
              113,
              17
            ],
            [
              113,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(ZCALLBACK *tell_file_func)      (voidpf opaque, voidpf stream)",
          "fn_dec_pos": [
            [
              115,
              17
            ],
            [
              115,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(ZCALLBACK *seek_file_func)      (voidpf opaque, voidpf stream, uLong offset, int origin)",
          "fn_dec_pos": [
            [
              116,
              17
            ],
            [
              116,
              106
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf",
              "offset": "uLong",
              "origin": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(ZCALLBACK *tell64_file_func)    (voidpf opaque, voidpf stream)",
          "fn_dec_pos": [
            [
              132,
              17
            ],
            [
              132,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf"
            },
            "return_type": "ZPOS64_T"
          }
        },
        {
          "fn_code": "(ZCALLBACK *seek64_file_func)    (voidpf opaque, voidpf stream, ZPOS64_T offset, int origin)",
          "fn_dec_pos": [
            [
              133,
              17
            ],
            [
              133,
              109
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "opaque": "voidpf",
              "stream": "voidpf",
              "offset": "ZPOS64_T",
              "origin": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(ZCALLBACK *open64_file_func)    (voidpf opaque, const void* filename, int mode)",
          "fn_dec_pos": [
            [
              134,
              17
            ],
            [
              134,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "opaque": "voidpf",
              "filename": "void",
              "mode": "int"
            },
            "return_type": "voidpf"
          }
        },
        {
          "fn_code": "fill_fopen64_filefunc(zlib_filefunc64_def* pzlib_filefunc_def)",
          "fn_dec_pos": [
            [
              148,
              5
            ],
            [
              148,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fill_fopen64_filefunc",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc64_def"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "fill_fopen_filefunc(zlib_filefunc_def* pzlib_filefunc_def)",
          "fn_dec_pos": [
            [
              149,
              5
            ],
            [
              149,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fill_fopen_filefunc",
            "parameters": {
              "pzlib_filefunc_def": "zlib_filefunc_def"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "call_zopen64(const zlib_filefunc64_32_def* pfilefunc,const void*filename,int mode)",
          "fn_dec_pos": [
            [
              168,
              7
            ],
            [
              168,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "call_zopen64",
            "parameters": {
              "pfilefunc": "zlib_filefunc64_32_def",
              "filename": "void",
              "mode": "int"
            },
            "return_type": "voidpf"
          }
        },
        {
          "fn_code": "call_zseek64(const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin)",
          "fn_dec_pos": [
            [
              169,
              5
            ],
            [
              169,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "call_zseek64",
            "parameters": {
              "pfilefunc": "zlib_filefunc64_32_def",
              "filestream": "voidpf",
              "offset": "ZPOS64_T",
              "origin": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "call_ztell64(const zlib_filefunc64_32_def* pfilefunc,voidpf filestream)",
          "fn_dec_pos": [
            [
              170,
              9
            ],
            [
              170,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "call_ztell64",
            "parameters": {
              "pfilefunc": "zlib_filefunc64_32_def",
              "filestream": "voidpf"
            },
            "return_type": "ZPOS64_T"
          }
        },
        {
          "fn_code": "fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def* p_filefunc64_32,const zlib_filefunc_def* p_filefunc32)",
          "fn_dec_pos": [
            [
              172,
              5
            ],
            [
              172,
              127
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fill_zlib_filefunc64_32_def_from_filefunc32",
            "parameters": {
              "p_filefunc64_32": "zlib_filefunc64_32_def",
              "p_filefunc32": "zlib_filefunc_def"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct zlib_filefunc_def_s\n{\n    open_file_func      zopen_file;\n    read_file_func      zread_file;\n    write_file_func     zwrite_file;\n    tell_file_func      ztell_file;\n    seek_file_func      zseek_file;\n    close_file_func     zclose_file;\n    testerror_file_func zerror_file;\n    voidpf              opaque;\n} zlib_filefunc_def;",
          {
            "zopen_file": "open_file_func",
            "zread_file": "read_file_func",
            "zwrite_file": "write_file_func",
            "ztell_file": "tell_file_func",
            "zseek_file": "seek_file_func",
            "zclose_file": "close_file_func",
            "zerror_file": "testerror_file_func",
            "opaque": "voidpf"
          },
          "zlib_filefunc_def",
          [
            120,
            0
          ],
          [
            130,
            20
          ]
        ],
        [
          "typedef struct zlib_filefunc64_def_s\n{\n    open64_file_func    zopen64_file;\n    read_file_func      zread_file;\n    write_file_func     zwrite_file;\n    tell64_file_func    ztell64_file;\n    seek64_file_func    zseek64_file;\n    close_file_func     zclose_file;\n    testerror_file_func zerror_file;\n    voidpf              opaque;\n} zlib_filefunc64_def;",
          {
            "zopen64_file": "open64_file_func",
            "zread_file": "read_file_func",
            "zwrite_file": "write_file_func",
            "ztell64_file": "tell64_file_func",
            "zseek64_file": "seek64_file_func",
            "zclose_file": "close_file_func",
            "zerror_file": "testerror_file_func",
            "opaque": "voidpf"
          },
          "zlib_filefunc64_def",
          [
            136,
            0
          ],
          [
            146,
            22
          ]
        ],
        [
          "typedef struct zlib_filefunc64_32_def_s\n{\n    zlib_filefunc64_def zfile_func64;\n    open_file_func      zopen32_file;\n    tell_file_func      ztell32_file;\n    seek_file_func      zseek32_file;\n} zlib_filefunc64_32_def;",
          {
            "zfile_func64": "zlib_filefunc64_def",
            "zopen32_file": "open_file_func",
            "ztell32_file": "tell_file_func",
            "zseek32_file": "seek_file_func"
          },
          "zlib_filefunc64_32_def",
          [
            152,
            0
          ],
          [
            158,
            25
          ]
        ],
        [
          "typedef struct zlib_filefunc_def_s\n{\n    open_file_func      zopen_file;\n    read_file_func      zread_file;\n    write_file_func     zwrite_file;\n    tell_file_func      ztell_file;\n    seek_file_func      zseek_file;\n    close_file_func     zclose_file;\n    testerror_file_func zerror_file;\n    voidpf              opaque;\n} zlib_filefunc_def;",
          {
            "zopen_file": "open_file_func",
            "zread_file": "read_file_func",
            "zwrite_file": "write_file_func",
            "ztell_file": "tell_file_func",
            "zseek_file": "seek_file_func",
            "zclose_file": "close_file_func",
            "zerror_file": "testerror_file_func",
            "opaque": "voidpf"
          },
          "zlib_filefunc_def",
          [
            120,
            0
          ],
          [
            130,
            20
          ]
        ],
        [
          "typedef struct zlib_filefunc64_def_s\n{\n    open64_file_func    zopen64_file;\n    read_file_func      zread_file;\n    write_file_func     zwrite_file;\n    tell64_file_func    ztell64_file;\n    seek64_file_func    zseek64_file;\n    close_file_func     zclose_file;\n    testerror_file_func zerror_file;\n    voidpf              opaque;\n} zlib_filefunc64_def;",
          {
            "zopen64_file": "open64_file_func",
            "zread_file": "read_file_func",
            "zwrite_file": "write_file_func",
            "ztell64_file": "tell64_file_func",
            "zseek64_file": "seek64_file_func",
            "zclose_file": "close_file_func",
            "zerror_file": "testerror_file_func",
            "opaque": "voidpf"
          },
          "zlib_filefunc64_def",
          [
            136,
            0
          ],
          [
            146,
            22
          ]
        ],
        [
          "typedef struct zlib_filefunc64_32_def_s\n{\n    zlib_filefunc64_def zfile_func64;\n    open_file_func      zopen32_file;\n    tell_file_func      ztell32_file;\n    seek_file_func      zseek32_file;\n} zlib_filefunc64_32_def;",
          {
            "zfile_func64": "zlib_filefunc64_def",
            "zopen32_file": "open_file_func",
            "ztell32_file": "tell_file_func",
            "zseek32_file": "seek_file_func"
          },
          "zlib_filefunc64_32_def",
          [
            152,
            0
          ],
          [
            158,
            25
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include \"mz64conf.h\"\n",
          [
            70,
            0
          ],
          [
            71,
            0
          ]
        ],
        [
          "#include \"ints.h\"\n",
          [
            73,
            0
          ],
          [
            74,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/puff/puff.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "puff(unsigned char *dest,           /* pointer to destination pointer */\n         unsigned long *destlen,        /* amount of output space */\n         const unsigned char *source,   /* pointer to source data pointer */\n         unsigned long *sourcelen)",
          "fn_dec_pos": [
            [
              31,
              4
            ],
            [
              34,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "puff",
            "parameters": {
              "dest": "unsigned char",
              "destlen": "unsigned long",
              "source": "unsigned char",
              "sourcelen": "unsigned long"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/iostream2/zstream.h": {
      "fn_def_list": [
        {
          "fn_code": "template <class T, class Items>\ninline int read(izstream& zs, T* x, Items items) {\n    return ::gzread(zs.fp(), x, items*sizeof(T));\n}",
          "fn_code_pos": [
            [
              113,
              0
            ],
            [
              116,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <class T>\ninline izstream& operator>(izstream& zs, T& x) {\n    ::gzread(zs.fp(), &x, sizeof(T));\n    return zs;\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <class T, class Items>\ninline int write(ozstream& zs, const T* x, Items items) {\n    return ::gzwrite(zs.fp(), (voidp) x, items*sizeof(T));\n}",
          "fn_code_pos": [
            [
              262,
              0
            ],
            [
              265,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <class T>\ninline ozstream& operator<(ozstream& zs, const T& x) {\n    ::gzwrite(zs.fp(), (voidp) &x, sizeof(T));\n    return zs;\n}",
          "fn_code_pos": [
            [
              270,
              0
            ],
            [
              274,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "template <class T>\ninline ostream& operator<<(ozstream& zs, const T& x) {\n    zs.os_flush();\n    return zs.os() << x;\n}",
          "fn_code_pos": [
            [
              300,
              0
            ],
            [
              304,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "size_t value() const { return val.word; }",
          "fn_code_pos": [
            [
              43,
              4
            ],
            [
              43,
              45
            ]
          ],
          "class_code": "a5dc1040e5cf0f45a19f18b7b0f21a25ec298b2eb070d978a74b88b94b20c223",
          "class_node_pos": [
            [
              39,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "value",
            "parameters": {},
            "return_type": "size_t"
          }
        },
        {
          "fn_code": "izstream() : m_fp(0) {}",
          "fn_code_pos": [
            [
              53,
              8
            ],
            [
              53,
              31
            ]
          ],
          "class_code": "98a55a4abbd115de8118d419cd4a41437842da43b66326d4b2b0b91de6734cbe",
          "class_node_pos": [
            [
              50,
              0
            ],
            [
              104,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "izstream",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "izstream(FILE* fp) : m_fp(0) { open(fp); }",
          "fn_code_pos": [
            [
              54,
              8
            ],
            [
              54,
              50
            ]
          ],
          "class_code": "98a55a4abbd115de8118d419cd4a41437842da43b66326d4b2b0b91de6734cbe",
          "class_node_pos": [
            [
              50,
              0
            ],
            [
              104,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "izstream",
            "parameters": {
              "fp": "FILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "izstream(const char* name) : m_fp(0) { open(name); }",
          "fn_code_pos": [
            [
              55,
              8
            ],
            [
              55,
              60
            ]
          ],
          "class_code": "98a55a4abbd115de8118d419cd4a41437842da43b66326d4b2b0b91de6734cbe",
          "class_node_pos": [
            [
              50,
              0
            ],
            [
              104,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "izstream",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~izstream() { close(); }",
          "fn_code_pos": [
            [
              56,
              8
            ],
            [
              56,
              32
            ]
          ],
          "class_code": "98a55a4abbd115de8118d419cd4a41437842da43b66326d4b2b0b91de6734cbe",
          "class_node_pos": [
            [
              50,
              0
            ],
            [
              104,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void open(const char* name) {\n            if (m_fp) close();\n            m_fp = ::gzopen(name, \"rb\");\n        }",
          "fn_code_pos": [
            [
              64,
              8
            ],
            [
              67,
              9
            ]
          ],
          "class_code": "98a55a4abbd115de8118d419cd4a41437842da43b66326d4b2b0b91de6734cbe",
          "class_node_pos": [
            [
              50,
              0
            ],
            [
              104,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "open",
            "parameters": {
              "name": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void open(FILE* fp) {\n            SET_BINARY_MODE(fp);\n            if (m_fp) close();\n            m_fp = ::gzdopen(fileno(fp), \"rb\");\n        }",
          "fn_code_pos": [
            [
              69,
              8
            ],
            [
              73,
              9
            ]
          ],
          "class_code": "98a55a4abbd115de8118d419cd4a41437842da43b66326d4b2b0b91de6734cbe",
          "class_node_pos": [
            [
              50,
              0
            ],
            [
              104,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "open",
            "parameters": {
              "fp": "FILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int close() {\n            int r = ::gzclose(m_fp);\n            m_fp = 0; return r;\n        }",
          "fn_code_pos": [
            [
              79,
              8
            ],
            [
              82,
              9
            ]
          ],
          "class_code": "98a55a4abbd115de8118d419cd4a41437842da43b66326d4b2b0b91de6734cbe",
          "class_node_pos": [
            [
              50,
              0
            ],
            [
              104,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "close",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int read(void* buf, size_t len) {\n            return ::gzread(m_fp, buf, len);\n        }",
          "fn_code_pos": [
            [
              86,
              8
            ],
            [
              88,
              9
            ]
          ],
          "class_code": "98a55a4abbd115de8118d419cd4a41437842da43b66326d4b2b0b91de6734cbe",
          "class_node_pos": [
            [
              50,
              0
            ],
            [
              104,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "read",
            "parameters": {
              "buf": "void",
              "len": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char* error(int* errnum) {\n            return ::gzerror(m_fp, errnum);\n        }",
          "fn_code_pos": [
            [
              96,
              8
            ],
            [
              98,
              9
            ]
          ],
          "class_code": "98a55a4abbd115de8118d419cd4a41437842da43b66326d4b2b0b91de6734cbe",
          "class_node_pos": [
            [
              50,
              0
            ],
            [
              104,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "error",
            "parameters": {
              "errnum": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "gzFile fp() { return m_fp; }",
          "fn_code_pos": [
            [
              100,
              8
            ],
            [
              100,
              36
            ]
          ],
          "class_code": "98a55a4abbd115de8118d419cd4a41437842da43b66326d4b2b0b91de6734cbe",
          "class_node_pos": [
            [
              50,
              0
            ],
            [
              104,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "fp",
            "parameters": {},
            "return_type": "gzFile"
          }
        },
        {
          "fn_code": "inline zstringlen::zstringlen(izstream& zs) {\n    zs > val.byte;\n    if (val.byte == 255) zs > val.word;\n    else val.word = val.byte;\n}",
          "fn_code_pos": [
            [
              128,
              0
            ],
            [
              132,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zstringlen::zstringlen",
            "parameters": {
              "zs": "izstream"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "inline izstream& operator>(izstream& zs, char* x) {\n    zstringlen len(zs);\n    ::gzread(zs.fp(), x, len.value());\n    x[len.value()] = '\\0';\n    return zs;\n}",
          "fn_code_pos": [
            [
              137,
              0
            ],
            [
              142,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "izstream"
          }
        },
        {
          "fn_code": "inline char* read_string(izstream& zs) {\n    zstringlen len(zs);\n    char* x = new char[len.value()+1];\n    ::gzread(zs.fp(), x, len.value());\n    x[len.value()] = '\\0';\n    return x;\n}",
          "fn_code_pos": [
            [
              144,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_string",
            "parameters": {
              "zs": "izstream"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "ozstream() : m_fp(0), m_os(0) {\n        }",
          "fn_code_pos": [
            [
              157,
              8
            ],
            [
              158,
              9
            ]
          ],
          "class_code": "e6152a4d88610c53412e5edd11a9bf109d2d7bde6f12f3cad518e73fe16b28ca",
          "class_node_pos": [
            [
              154,
              0
            ],
            [
              255,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ozstream",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "ozstream(FILE* fp, int level = Z_DEFAULT_COMPRESSION)\n            : m_fp(0), m_os(0) {\n            open(fp, level);\n        }",
          "fn_code_pos": [
            [
              159,
              8
            ],
            [
              162,
              9
            ]
          ],
          "class_code": "e6152a4d88610c53412e5edd11a9bf109d2d7bde6f12f3cad518e73fe16b28ca",
          "class_node_pos": [
            [
              154,
              0
            ],
            [
              255,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ozstream",
            "parameters": {
              "fp": "FILE"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "ozstream(const char* name, int level = Z_DEFAULT_COMPRESSION)\n            : m_fp(0), m_os(0) {\n            open(name, level);\n        }",
          "fn_code_pos": [
            [
              163,
              8
            ],
            [
              166,
              9
            ]
          ],
          "class_code": "e6152a4d88610c53412e5edd11a9bf109d2d7bde6f12f3cad518e73fe16b28ca",
          "class_node_pos": [
            [
              154,
              0
            ],
            [
              255,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "ozstream",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~ozstream() {\n            close();\n        }",
          "fn_code_pos": [
            [
              167,
              8
            ],
            [
              169,
              9
            ]
          ],
          "class_code": "e6152a4d88610c53412e5edd11a9bf109d2d7bde6f12f3cad518e73fe16b28ca",
          "class_node_pos": [
            [
              154,
              0
            ],
            [
              255,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "void open(const char* name, int level = Z_DEFAULT_COMPRESSION) {\n            char mode[4] = \"wb\\0\";\n            if (level != Z_DEFAULT_COMPRESSION) mode[2] = '0'+level;\n            if (m_fp) close();\n            m_fp = ::gzopen(name, mode);\n        }",
          "fn_code_pos": [
            [
              176,
              8
            ],
            [
              181,
              9
            ]
          ],
          "class_code": "e6152a4d88610c53412e5edd11a9bf109d2d7bde6f12f3cad518e73fe16b28ca",
          "class_node_pos": [
            [
              154,
              0
            ],
            [
              255,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "open",
            "parameters": {
              "name": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void open(FILE* fp, int level = Z_DEFAULT_COMPRESSION) {\n            SET_BINARY_MODE(fp);\n            char mode[4] = \"wb\\0\";\n            if (level != Z_DEFAULT_COMPRESSION) mode[2] = '0'+level;\n            if (m_fp) close();\n            m_fp = ::gzdopen(fileno(fp), mode);\n        }",
          "fn_code_pos": [
            [
              185,
              8
            ],
            [
              191,
              9
            ]
          ],
          "class_code": "e6152a4d88610c53412e5edd11a9bf109d2d7bde6f12f3cad518e73fe16b28ca",
          "class_node_pos": [
            [
              154,
              0
            ],
            [
              255,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "open",
            "parameters": {
              "fp": "FILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int close() {\n            if (m_os) {\n                ::gzwrite(m_fp, m_os->str(), m_os->pcount());\n                delete[] m_os->str(); delete m_os; m_os = 0;\n            }\n            int r = ::gzclose(m_fp); m_fp = 0; return r;\n        }",
          "fn_code_pos": [
            [
              197,
              8
            ],
            [
              203,
              9
            ]
          ],
          "class_code": "e6152a4d88610c53412e5edd11a9bf109d2d7bde6f12f3cad518e73fe16b28ca",
          "class_node_pos": [
            [
              154,
              0
            ],
            [
              255,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "close",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int write(const void* buf, size_t len) {\n            return ::gzwrite(m_fp, (voidp) buf, len);\n        }",
          "fn_code_pos": [
            [
              207,
              8
            ],
            [
              209,
              9
            ]
          ],
          "class_code": "e6152a4d88610c53412e5edd11a9bf109d2d7bde6f12f3cad518e73fe16b28ca",
          "class_node_pos": [
            [
              154,
              0
            ],
            [
              255,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "write",
            "parameters": {
              "buf": "void",
              "len": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int flush(int _flush) {\n            os_flush();\n            return ::gzflush(m_fp, _flush);\n        }",
          "fn_code_pos": [
            [
              218,
              8
            ],
            [
              221,
              9
            ]
          ],
          "class_code": "e6152a4d88610c53412e5edd11a9bf109d2d7bde6f12f3cad518e73fe16b28ca",
          "class_node_pos": [
            [
              154,
              0
            ],
            [
              255,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "flush",
            "parameters": {
              "_flush": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const char* error(int* errnum) {\n            return ::gzerror(m_fp, errnum);\n        }",
          "fn_code_pos": [
            [
              229,
              8
            ],
            [
              231,
              9
            ]
          ],
          "class_code": "e6152a4d88610c53412e5edd11a9bf109d2d7bde6f12f3cad518e73fe16b28ca",
          "class_node_pos": [
            [
              154,
              0
            ],
            [
              255,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "error",
            "parameters": {
              "errnum": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "gzFile fp() { return m_fp; }",
          "fn_code_pos": [
            [
              233,
              8
            ],
            [
              233,
              36
            ]
          ],
          "class_code": "e6152a4d88610c53412e5edd11a9bf109d2d7bde6f12f3cad518e73fe16b28ca",
          "class_node_pos": [
            [
              154,
              0
            ],
            [
              255,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "fp",
            "parameters": {},
            "return_type": "gzFile"
          }
        },
        {
          "fn_code": "ostream& os() {\n            if (m_os == 0) m_os = new ostrstream;\n            return *m_os;\n        }",
          "fn_code_pos": [
            [
              235,
              8
            ],
            [
              238,
              9
            ]
          ],
          "class_code": "e6152a4d88610c53412e5edd11a9bf109d2d7bde6f12f3cad518e73fe16b28ca",
          "class_node_pos": [
            [
              154,
              0
            ],
            [
              255,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "ostream"
          }
        },
        {
          "fn_code": "void os_flush() {\n            if (m_os && m_os->pcount()>0) {\n                ostrstream* oss = new ostrstream;\n                oss->fill(m_os->fill());\n                oss->flags(m_os->flags());\n                oss->precision(m_os->precision());\n                oss->width(m_os->width());\n                ::gzwrite(m_fp, m_os->str(), m_os->pcount());\n                delete[] m_os->str(); delete m_os; m_os = oss;\n            }\n        }",
          "fn_code_pos": [
            [
              240,
              8
            ],
            [
              250,
              9
            ]
          ],
          "class_code": "e6152a4d88610c53412e5edd11a9bf109d2d7bde6f12f3cad518e73fe16b28ca",
          "class_node_pos": [
            [
              154,
              0
            ],
            [
              255,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "os_flush",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "inline zstringlen::zstringlen(ozstream& zs, const char* x) {\n    val.byte = 255;  val.word = ::strlen(x);\n    if (val.word < 255) zs < (val.byte = val.word);\n    else zs < val;\n}",
          "fn_code_pos": [
            [
              276,
              0
            ],
            [
              280,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "zstringlen::zstringlen",
            "parameters": {
              "zs": "ozstream",
              "x": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "inline ozstream& operator<(ozstream& zs, const char* x) {\n    zstringlen len(zs, x);\n    ::gzwrite(zs.fp(), (voidp) x, len.value());\n    return zs;\n}",
          "fn_code_pos": [
            [
              285,
              0
            ],
            [
              289,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "ozstream"
          }
        },
        {
          "fn_code": "inline ozstream& operator<(ozstream& zs, char* const& x) {\n    return zs < (const char*) x;\n}",
          "fn_code_pos": [
            [
              292,
              0
            ],
            [
              294,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "ozstream"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "zstringlen(class izstream&)",
          "fn_dec_pos": [
            [
              41,
              4
            ],
            [
              41,
              31
            ]
          ],
          "class_code": "a5dc1040e5cf0f45a19f18b7b0f21a25ec298b2eb070d978a74b88b94b20c223",
          "class_node_pos": [
            [
              39,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "zstringlen",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "zstringlen(class ozstream&, const char*)",
          "fn_dec_pos": [
            [
              42,
              4
            ],
            [
              42,
              44
            ]
          ],
          "class_code": "a5dc1040e5cf0f45a19f18b7b0f21a25ec298b2eb070d978a74b88b94b20c223",
          "class_node_pos": [
            [
              39,
              0
            ],
            [
              46,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "zstringlen",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "error(int* errnum)",
          "fn_dec_pos": [
            [
              96,
              20
            ],
            [
              96,
              38
            ]
          ],
          "class_code": "98a55a4abbd115de8118d419cd4a41437842da43b66326d4b2b0b91de6734cbe",
          "class_node_pos": [
            [
              50,
              0
            ],
            [
              104,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "error",
            "parameters": {
              "errnum": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator>(izstream& zs, T& x)",
          "fn_dec_pos": [
            [
              122,
              17
            ],
            [
              122,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "zs": "izstream",
              "x": "T"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator>(izstream& zs, char* x)",
          "fn_dec_pos": [
            [
              137,
              17
            ],
            [
              137,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "zs": "izstream",
              "x": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "len(zs)",
          "fn_dec_pos": [
            [
              138,
              15
            ],
            [
              138,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "len",
            "parameters": {},
            "return_type": "zstringlen"
          }
        },
        {
          "fn_code": "read_string(izstream& zs)",
          "fn_dec_pos": [
            [
              144,
              13
            ],
            [
              144,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_string",
            "parameters": {
              "zs": "izstream"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "len(zs)",
          "fn_dec_pos": [
            [
              145,
              15
            ],
            [
              145,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "len",
            "parameters": {},
            "return_type": "zstringlen"
          }
        },
        {
          "fn_code": "error(int* errnum)",
          "fn_dec_pos": [
            [
              229,
              20
            ],
            [
              229,
              38
            ]
          ],
          "class_code": "e6152a4d88610c53412e5edd11a9bf109d2d7bde6f12f3cad518e73fe16b28ca",
          "class_node_pos": [
            [
              154,
              0
            ],
            [
              255,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "error",
            "parameters": {
              "errnum": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "os()",
          "fn_dec_pos": [
            [
              235,
              17
            ],
            [
              235,
              21
            ]
          ],
          "class_code": "e6152a4d88610c53412e5edd11a9bf109d2d7bde6f12f3cad518e73fe16b28ca",
          "class_node_pos": [
            [
              154,
              0
            ],
            [
              255,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "os",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "operator<(ozstream& zs, const T& x)",
          "fn_dec_pos": [
            [
              271,
              17
            ],
            [
              271,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "zs": "ozstream",
              "x": "T"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<(ozstream& zs, const char* x)",
          "fn_dec_pos": [
            [
              285,
              17
            ],
            [
              285,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "zs": "ozstream",
              "x": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "len(zs, x)",
          "fn_dec_pos": [
            [
              286,
              15
            ],
            [
              286,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "len",
            "parameters": {},
            "return_type": "zstringlen"
          }
        },
        {
          "fn_code": "operator<(ozstream& zs, char* const& x)",
          "fn_dec_pos": [
            [
              292,
              17
            ],
            [
              292,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "zs": "ozstream",
              "x": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(ozstream& zs, const T& x)",
          "fn_dec_pos": [
            [
              301,
              16
            ],
            [
              301,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "zs": "ozstream",
              "x": "T"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "a5dc1040e5cf0f45a19f18b7b0f21a25ec298b2eb070d978a74b88b94b20c223": {
          "class_code": "class zstringlen {\npublic:\n    zstringlen(class izstream&);\n    zstringlen(class ozstream&, const char*);\n    size_t value() const { return val.word; }\nprivate:\n    struct Val { unsigned char byte; size_t word; } val;\n}",
          "class_name": "zstringlen",
          "class_pos": [
            [
              39,
              0
            ],
            [
              46,
              1
            ]
          ]
        },
        "ecf340cd60bfa3587927387b16e43e657cb994ef9a3a91888c1ba1d8b0304171": {
          "class_code": "class izstream",
          "class_name": "izstream",
          "class_pos": [
            [
              41,
              15
            ],
            [
              41,
              29
            ]
          ]
        },
        "a6319d318cf4b583e8fcc5bced685d83059255114fed12d0902c37adad91df92": {
          "class_code": "class ozstream",
          "class_name": "ozstream",
          "class_pos": [
            [
              42,
              15
            ],
            [
              42,
              29
            ]
          ]
        },
        "98a55a4abbd115de8118d419cd4a41437842da43b66326d4b2b0b91de6734cbe": {
          "class_code": "class izstream\n{\n    public:\n        izstream() : m_fp(0) {}\n        izstream(FILE* fp) : m_fp(0) { open(fp); }\n        izstream(const char* name) : m_fp(0) { open(name); }\n        ~izstream() { close(); }\n\n        /* Opens a gzip (.gz) file for reading.\n         * open() can be used to read a file which is not in gzip format;\n         * in this case read() will directly read from the file without\n         * decompression. errno can be checked to distinguish two error\n         * cases (if errno is zero, the zlib error is Z_MEM_ERROR).\n         */\n        void open(const char* name) {\n            if (m_fp) close();\n            m_fp = ::gzopen(name, \"rb\");\n        }\n\n        void open(FILE* fp) {\n            SET_BINARY_MODE(fp);\n            if (m_fp) close();\n            m_fp = ::gzdopen(fileno(fp), \"rb\");\n        }\n\n        /* Flushes all pending input if necessary, closes the compressed file\n         * and deallocates all the (de)compression state. The return value is\n         * the zlib error number (see function error() below).\n         */\n        int close() {\n            int r = ::gzclose(m_fp);\n            m_fp = 0; return r;\n        }\n\n        /* Binary read the given number of bytes from the compressed file.\n         */\n        int read(void* buf, size_t len) {\n            return ::gzread(m_fp, buf, len);\n        }\n\n        /* Returns the error message for the last error which occurred on the\n         * given compressed file. errnum is set to zlib error number. If an\n         * error occurred in the file system and not in the compression library,\n         * errnum is set to Z_ERRNO and the application may consult errno\n         * to get the exact error code.\n         */\n        const char* error(int* errnum) {\n            return ::gzerror(m_fp, errnum);\n        }\n\n        gzFile fp() { return m_fp; }\n\n    private:\n        gzFile m_fp;\n}",
          "class_name": "izstream",
          "class_pos": [
            [
              50,
              0
            ],
            [
              104,
              1
            ]
          ]
        },
        "e6152a4d88610c53412e5edd11a9bf109d2d7bde6f12f3cad518e73fe16b28ca": {
          "class_code": "class ozstream\n{\n    public:\n        ozstream() : m_fp(0), m_os(0) {\n        }\n        ozstream(FILE* fp, int level = Z_DEFAULT_COMPRESSION)\n            : m_fp(0), m_os(0) {\n            open(fp, level);\n        }\n        ozstream(const char* name, int level = Z_DEFAULT_COMPRESSION)\n            : m_fp(0), m_os(0) {\n            open(name, level);\n        }\n        ~ozstream() {\n            close();\n        }\n\n        /* Opens a gzip (.gz) file for writing.\n         * The compression level parameter should be in 0..9\n         * errno can be checked to distinguish two error cases\n         * (if errno is zero, the zlib error is Z_MEM_ERROR).\n         */\n        void open(const char* name, int level = Z_DEFAULT_COMPRESSION) {\n            char mode[4] = \"wb\\0\";\n            if (level != Z_DEFAULT_COMPRESSION) mode[2] = '0'+level;\n            if (m_fp) close();\n            m_fp = ::gzopen(name, mode);\n        }\n\n        /* open from a FILE pointer.\n         */\n        void open(FILE* fp, int level = Z_DEFAULT_COMPRESSION) {\n            SET_BINARY_MODE(fp);\n            char mode[4] = \"wb\\0\";\n            if (level != Z_DEFAULT_COMPRESSION) mode[2] = '0'+level;\n            if (m_fp) close();\n            m_fp = ::gzdopen(fileno(fp), mode);\n        }\n\n        /* Flushes all pending output if necessary, closes the compressed file\n         * and deallocates all the (de)compression state. The return value is\n         * the zlib error number (see function error() below).\n         */\n        int close() {\n            if (m_os) {\n                ::gzwrite(m_fp, m_os->str(), m_os->pcount());\n                delete[] m_os->str(); delete m_os; m_os = 0;\n            }\n            int r = ::gzclose(m_fp); m_fp = 0; return r;\n        }\n\n        /* Binary write the given number of bytes into the compressed file.\n         */\n        int write(const void* buf, size_t len) {\n            return ::gzwrite(m_fp, (voidp) buf, len);\n        }\n\n        /* Flushes all pending output into the compressed file. The parameter\n         * _flush is as in the deflate() function. The return value is the zlib\n         * error number (see function gzerror below). flush() returns Z_OK if\n         * the flush_ parameter is Z_FINISH and all output could be flushed.\n         * flush() should be called only when strictly necessary because it can\n         * degrade compression.\n         */\n        int flush(int _flush) {\n            os_flush();\n            return ::gzflush(m_fp, _flush);\n        }\n\n        /* Returns the error message for the last error which occurred on the\n         * given compressed file. errnum is set to zlib error number. If an\n         * error occurred in the file system and not in the compression library,\n         * errnum is set to Z_ERRNO and the application may consult errno\n         * to get the exact error code.\n         */\n        const char* error(int* errnum) {\n            return ::gzerror(m_fp, errnum);\n        }\n\n        gzFile fp() { return m_fp; }\n\n        ostream& os() {\n            if (m_os == 0) m_os = new ostrstream;\n            return *m_os;\n        }\n\n        void os_flush() {\n            if (m_os && m_os->pcount()>0) {\n                ostrstream* oss = new ostrstream;\n                oss->fill(m_os->fill());\n                oss->flags(m_os->flags());\n                oss->precision(m_os->precision());\n                oss->width(m_os->width());\n                ::gzwrite(m_fp, m_os->str(), m_os->pcount());\n                delete[] m_os->str(); delete m_os; m_os = oss;\n            }\n        }\n\n    private:\n        gzFile m_fp;\n        ostrstream* m_os;\n}",
          "class_name": "ozstream",
          "class_pos": [
            [
              154,
              0
            ],
            [
              255,
              1
            ]
          ]
        }
      },
      "struct_node_list": [
        [
          "struct Val { unsigned char byte; size_t word; }",
          {
            "byte": "unsigned char",
            "word": "size_t"
          },
          "Val",
          [
            45,
            4
          ],
          [
            45,
            51
          ]
        ],
        [
          "struct Val { unsigned char byte; size_t word; }",
          {
            "byte": "unsigned char",
            "word": "size_t"
          },
          "Val",
          [
            45,
            4
          ],
          [
            45,
            51
          ]
        ]
      ],
      "include_list": [
        [
          "#include <strstream.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#   include <fcntl.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#   include <io.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/blast/blast.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*blast_in)(void *how, unsigned char **buf)",
          "fn_dec_pos": [
            [
              37,
              17
            ],
            [
              37,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "how": "void",
              "buf": "unsigned char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*blast_out)(void *how, unsigned char *buf, unsigned len)",
          "fn_dec_pos": [
            [
              38,
              12
            ],
            [
              38,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "how": "void",
              "buf": "unsigned char",
              "len": "unsigned"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "blast(blast_in infun, void *inhow, blast_out outfun, void *outhow,\n          unsigned *left, unsigned char **in)",
          "fn_dec_pos": [
            [
              44,
              4
            ],
            [
              45,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "blast",
            "parameters": {
              "infun": "blast_in",
              "inhow": "void",
              "outfun": "blast_out",
              "outhow": "void",
              "left": "unsigned",
              "in": "unsigned char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/iostream/zfstream.h": {
      "fn_def_list": [
        {
          "fn_code": "template<class T> gzofstream &operator<<(gzofstream &s, const gzomanip<T> &m)\n{\n  return (*m.func)(s, m.val);\n}",
          "fn_code_pos": [
            [
              100,
              0
            ],
            [
              103,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "inline int is_open() const { return (file !=NULL); }",
          "fn_code_pos": [
            [
              21,
              2
            ],
            [
              21,
              54
            ]
          ],
          "class_code": "c66c78b023ad3235dfe94684e7bd64ce2f47cd8c5ec5fca3f3191b97a9eb823a",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              41,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "is_open",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "gzomanip(gzofstream &(*f)(gzofstream &, T), T v) : func(f), val(v) { }",
          "fn_code_pos": [
            [
              94,
              2
            ],
            [
              94,
              72
            ]
          ],
          "class_code": "037b96f1337c5e85b9501a9da4e8dca2dd4760dcf148f05b9dbb502f5040b63b",
          "class_node_pos": [
            [
              91,
              18
            ],
            [
              98,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "gzomanip",
            "parameters": {
              "f": "gzofstream",
              "v": "T"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "inline gzofstream &setcompressionlevel( gzofstream &s, int l )\n{\n  (s.rdbuf())->setcompressionlevel(l);\n  return s;\n}",
          "fn_code_pos": [
            [
              105,
              0
            ],
            [
              109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "gzofstream"
          }
        },
        {
          "fn_code": "inline gzofstream &setcompressionstrategy( gzofstream &s, int l )\n{\n  (s.rdbuf())->setcompressionstrategy(l);\n  return s;\n}",
          "fn_code_pos": [
            [
              111,
              0
            ],
            [
              115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "gzofstream"
          }
        },
        {
          "fn_code": "inline gzomanip<int> setcompressionlevel(int l)\n{\n  return gzomanip<int>(&setcompressionlevel,l);\n}",
          "fn_code_pos": [
            [
              117,
              0
            ],
            [
              120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setcompressionlevel",
            "parameters": {
              "l": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "inline gzomanip<int> setcompressionstrategy(int l)\n{\n  return gzomanip<int>(&setcompressionstrategy,l);\n}",
          "fn_code_pos": [
            [
              122,
              0
            ],
            [
              125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setcompressionstrategy",
            "parameters": {
              "l": "int"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "gzfilebuf( )",
          "fn_dec_pos": [
            [
              11,
              2
            ],
            [
              11,
              14
            ]
          ],
          "class_code": "c66c78b023ad3235dfe94684e7bd64ce2f47cd8c5ec5fca3f3191b97a9eb823a",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              41,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "gzfilebuf",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~gzfilebuf()",
          "fn_dec_pos": [
            [
              12,
              10
            ],
            [
              12,
              22
            ]
          ],
          "class_code": "c66c78b023ad3235dfe94684e7bd64ce2f47cd8c5ec5fca3f3191b97a9eb823a",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              41,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "open( const char *name, int io_mode )",
          "fn_dec_pos": [
            [
              14,
              13
            ],
            [
              14,
              50
            ]
          ],
          "class_code": "c66c78b023ad3235dfe94684e7bd64ce2f47cd8c5ec5fca3f3191b97a9eb823a",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              41,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "open",
            "parameters": {
              "name": "char",
              "io_mode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "attach( int file_descriptor, int io_mode )",
          "fn_dec_pos": [
            [
              15,
              13
            ],
            [
              15,
              55
            ]
          ],
          "class_code": "c66c78b023ad3235dfe94684e7bd64ce2f47cd8c5ec5fca3f3191b97a9eb823a",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              41,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "attach",
            "parameters": {
              "file_descriptor": "int",
              "io_mode": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "close()",
          "fn_dec_pos": [
            [
              16,
              13
            ],
            [
              16,
              20
            ]
          ],
          "class_code": "c66c78b023ad3235dfe94684e7bd64ce2f47cd8c5ec5fca3f3191b97a9eb823a",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              41,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "close",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "setcompressionlevel( int comp_level )",
          "fn_dec_pos": [
            [
              18,
              6
            ],
            [
              18,
              43
            ]
          ],
          "class_code": "c66c78b023ad3235dfe94684e7bd64ce2f47cd8c5ec5fca3f3191b97a9eb823a",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              41,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "setcompressionlevel",
            "parameters": {
              "comp_level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "setcompressionstrategy( int comp_strategy )",
          "fn_dec_pos": [
            [
              19,
              6
            ],
            [
              19,
              49
            ]
          ],
          "class_code": "c66c78b023ad3235dfe94684e7bd64ce2f47cd8c5ec5fca3f3191b97a9eb823a",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              41,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "setcompressionstrategy",
            "parameters": {
              "comp_strategy": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "seekoff( streamoff, ios::seek_dir, int )",
          "fn_dec_pos": [
            [
              23,
              20
            ],
            [
              23,
              60
            ]
          ],
          "class_code": "c66c78b023ad3235dfe94684e7bd64ce2f47cd8c5ec5fca3f3191b97a9eb823a",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              41,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "seekoff",
            "parameters": {},
            "return_type": "streampos"
          }
        },
        {
          "fn_code": "sync()",
          "fn_dec_pos": [
            [
              25,
              14
            ],
            [
              25,
              20
            ]
          ],
          "class_code": "c66c78b023ad3235dfe94684e7bd64ce2f47cd8c5ec5fca3f3191b97a9eb823a",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              41,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "sync",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "underflow()",
          "fn_dec_pos": [
            [
              29,
              14
            ],
            [
              29,
              25
            ]
          ],
          "class_code": "c66c78b023ad3235dfe94684e7bd64ce2f47cd8c5ec5fca3f3191b97a9eb823a",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              41,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "underflow",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "overflow( int = EOF )",
          "fn_dec_pos": [
            [
              30,
              14
            ],
            [
              30,
              35
            ]
          ],
          "class_code": "c66c78b023ad3235dfe94684e7bd64ce2f47cd8c5ec5fca3f3191b97a9eb823a",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              41,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "overflow",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "flushbuf()",
          "fn_dec_pos": [
            [
              38,
              6
            ],
            [
              38,
              16
            ]
          ],
          "class_code": "c66c78b023ad3235dfe94684e7bd64ce2f47cd8c5ec5fca3f3191b97a9eb823a",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              41,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "flushbuf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "fillbuf()",
          "fn_dec_pos": [
            [
              39,
              6
            ],
            [
              39,
              15
            ]
          ],
          "class_code": "c66c78b023ad3235dfe94684e7bd64ce2f47cd8c5ec5fca3f3191b97a9eb823a",
          "class_node_pos": [
            [
              7,
              0
            ],
            [
              41,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "fillbuf",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "setcompressionlevel( gzofstream &, int )",
          "fn_dec_pos": [
            [
              47,
              21
            ],
            [
              47,
              61
            ]
          ],
          "class_code": "e5caa8339a79b5ecf67f37f4cdaf2c2c5ebf2ce56d50af352b868cb832df9e2c",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              65,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "setcompressionlevel",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "setcompressionstrategy( gzofstream &, int )",
          "fn_dec_pos": [
            [
              48,
              21
            ],
            [
              48,
              64
            ]
          ],
          "class_code": "e5caa8339a79b5ecf67f37f4cdaf2c2c5ebf2ce56d50af352b868cb832df9e2c",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              65,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "setcompressionstrategy",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~gzfilestream_common()",
          "fn_dec_pos": [
            [
              51,
              10
            ],
            [
              51,
              32
            ]
          ],
          "class_code": "e5caa8339a79b5ecf67f37f4cdaf2c2c5ebf2ce56d50af352b868cb832df9e2c",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              65,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "attach( int fd, int io_mode )",
          "fn_dec_pos": [
            [
              53,
              7
            ],
            [
              53,
              36
            ]
          ],
          "class_code": "e5caa8339a79b5ecf67f37f4cdaf2c2c5ebf2ce56d50af352b868cb832df9e2c",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              65,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "attach",
            "parameters": {
              "fd": "int",
              "io_mode": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "open( const char *name, int io_mode )",
          "fn_dec_pos": [
            [
              54,
              7
            ],
            [
              54,
              44
            ]
          ],
          "class_code": "e5caa8339a79b5ecf67f37f4cdaf2c2c5ebf2ce56d50af352b868cb832df9e2c",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              65,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "open",
            "parameters": {
              "name": "char",
              "io_mode": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "close()",
          "fn_dec_pos": [
            [
              55,
              7
            ],
            [
              55,
              14
            ]
          ],
          "class_code": "e5caa8339a79b5ecf67f37f4cdaf2c2c5ebf2ce56d50af352b868cb832df9e2c",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              65,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "close",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "gzfilestream_common()",
          "fn_dec_pos": [
            [
              58,
              2
            ],
            [
              58,
              23
            ]
          ],
          "class_code": "e5caa8339a79b5ecf67f37f4cdaf2c2c5ebf2ce56d50af352b868cb832df9e2c",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              65,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "gzfilestream_common",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "rdbuf()",
          "fn_dec_pos": [
            [
              61,
              13
            ],
            [
              61,
              20
            ]
          ],
          "class_code": "e5caa8339a79b5ecf67f37f4cdaf2c2c5ebf2ce56d50af352b868cb832df9e2c",
          "class_node_pos": [
            [
              43,
              0
            ],
            [
              65,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "rdbuf",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzifstream()",
          "fn_dec_pos": [
            [
              71,
              2
            ],
            [
              71,
              14
            ]
          ],
          "class_code": "73be6e5a99293529c4b51ab07959d92c3286e23f3023fd4df17092bbcd53d676",
          "class_node_pos": [
            [
              67,
              0
            ],
            [
              77,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "gzifstream",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzifstream( const char *name, int io_mode = ios::in )",
          "fn_dec_pos": [
            [
              72,
              2
            ],
            [
              72,
              55
            ]
          ],
          "class_code": "73be6e5a99293529c4b51ab07959d92c3286e23f3023fd4df17092bbcd53d676",
          "class_node_pos": [
            [
              67,
              0
            ],
            [
              77,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "gzifstream",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzifstream( int fd, int io_mode = ios::in )",
          "fn_dec_pos": [
            [
              73,
              2
            ],
            [
              73,
              45
            ]
          ],
          "class_code": "73be6e5a99293529c4b51ab07959d92c3286e23f3023fd4df17092bbcd53d676",
          "class_node_pos": [
            [
              67,
              0
            ],
            [
              77,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "gzifstream",
            "parameters": {
              "fd": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~gzifstream()",
          "fn_dec_pos": [
            [
              75,
              10
            ],
            [
              75,
              23
            ]
          ],
          "class_code": "73be6e5a99293529c4b51ab07959d92c3286e23f3023fd4df17092bbcd53d676",
          "class_node_pos": [
            [
              67,
              0
            ],
            [
              77,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzofstream()",
          "fn_dec_pos": [
            [
              83,
              2
            ],
            [
              83,
              14
            ]
          ],
          "class_code": "2f476c61cc2ab939997cb35e88bc808b1859630fcbf3e6c0c05ed897660bc6eb",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "gzofstream",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "gzofstream( const char *name, int io_mode = ios::out )",
          "fn_dec_pos": [
            [
              84,
              2
            ],
            [
              84,
              56
            ]
          ],
          "class_code": "2f476c61cc2ab939997cb35e88bc808b1859630fcbf3e6c0c05ed897660bc6eb",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "gzofstream",
            "parameters": {
              "name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzofstream( int fd, int io_mode = ios::out )",
          "fn_dec_pos": [
            [
              85,
              2
            ],
            [
              85,
              46
            ]
          ],
          "class_code": "2f476c61cc2ab939997cb35e88bc808b1859630fcbf3e6c0c05ed897660bc6eb",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "gzofstream",
            "parameters": {
              "fd": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "~gzofstream()",
          "fn_dec_pos": [
            [
              87,
              10
            ],
            [
              87,
              23
            ]
          ],
          "class_code": "2f476c61cc2ab939997cb35e88bc808b1859630fcbf3e6c0c05ed897660bc6eb",
          "class_node_pos": [
            [
              79,
              0
            ],
            [
              89,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(gzofstream &, const gzomanip<T> &)",
          "fn_dec_pos": [
            [
              92,
              21
            ],
            [
              92,
              66
            ]
          ],
          "class_code": "037b96f1337c5e85b9501a9da4e8dca2dd4760dcf148f05b9dbb502f5040b63b",
          "class_node_pos": [
            [
              91,
              18
            ],
            [
              98,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "(*f)(gzofstream &, T)",
          "fn_dec_pos": [
            [
              94,
              23
            ],
            [
              94,
              44
            ]
          ],
          "class_code": "037b96f1337c5e85b9501a9da4e8dca2dd4760dcf148f05b9dbb502f5040b63b",
          "class_node_pos": [
            [
              91,
              18
            ],
            [
              98,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "(*func)(gzofstream &, T)",
          "fn_dec_pos": [
            [
              96,
              14
            ],
            [
              96,
              38
            ]
          ],
          "class_code": "037b96f1337c5e85b9501a9da4e8dca2dd4760dcf148f05b9dbb502f5040b63b",
          "class_node_pos": [
            [
              91,
              18
            ],
            [
              98,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "operator<<(gzofstream &s, const gzomanip<T> &m)",
          "fn_dec_pos": [
            [
              100,
              30
            ],
            [
              100,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "s": "gzofstream",
              "m": "gzomanip<T>"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "setcompressionlevel( gzofstream &s, int l )",
          "fn_dec_pos": [
            [
              105,
              19
            ],
            [
              105,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setcompressionlevel",
            "parameters": {
              "s": "gzofstream",
              "l": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "setcompressionstrategy( gzofstream &s, int l )",
          "fn_dec_pos": [
            [
              111,
              19
            ],
            [
              111,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setcompressionstrategy",
            "parameters": {
              "s": "gzofstream",
              "l": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {
        "c66c78b023ad3235dfe94684e7bd64ce2f47cd8c5ec5fca3f3191b97a9eb823a": {
          "class_code": "class gzfilebuf : public streambuf {\n\npublic:\n\n  gzfilebuf( );\n  virtual ~gzfilebuf();\n\n  gzfilebuf *open( const char *name, int io_mode );\n  gzfilebuf *attach( int file_descriptor, int io_mode );\n  gzfilebuf *close();\n\n  int setcompressionlevel( int comp_level );\n  int setcompressionstrategy( int comp_strategy );\n\n  inline int is_open() const { return (file !=NULL); }\n\n  virtual streampos seekoff( streamoff, ios::seek_dir, int );\n\n  virtual int sync();\n\nprotected:\n\n  virtual int underflow();\n  virtual int overflow( int = EOF );\n\nprivate:\n\n  gzFile file;\n  short mode;\n  short own_file_descriptor;\n\n  int flushbuf();\n  int fillbuf();\n\n}",
          "class_name": "gzfilebuf",
          "class_pos": [
            [
              7,
              0
            ],
            [
              41,
              1
            ]
          ]
        },
        "e5caa8339a79b5ecf67f37f4cdaf2c2c5ebf2ce56d50af352b868cb832df9e2c": {
          "class_code": "class gzfilestream_common : virtual public ios {\n\n  friend class gzifstream;\n  friend class gzofstream;\n  friend gzofstream &setcompressionlevel( gzofstream &, int );\n  friend gzofstream &setcompressionstrategy( gzofstream &, int );\n\npublic:\n  virtual ~gzfilestream_common();\n\n  void attach( int fd, int io_mode );\n  void open( const char *name, int io_mode );\n  void close();\n\nprotected:\n  gzfilestream_common();\n\nprivate:\n  gzfilebuf *rdbuf();\n\n  gzfilebuf buffer;\n\n}",
          "class_name": "gzfilestream_common",
          "class_pos": [
            [
              43,
              0
            ],
            [
              65,
              1
            ]
          ]
        },
        "73be6e5a99293529c4b51ab07959d92c3286e23f3023fd4df17092bbcd53d676": {
          "class_code": "class gzifstream : public gzfilestream_common, public istream {\n\npublic:\n\n  gzifstream();\n  gzifstream( const char *name, int io_mode = ios::in );\n  gzifstream( int fd, int io_mode = ios::in );\n\n  virtual ~gzifstream();\n\n}",
          "class_name": "gzifstream",
          "class_pos": [
            [
              67,
              0
            ],
            [
              77,
              1
            ]
          ]
        },
        "2f476c61cc2ab939997cb35e88bc808b1859630fcbf3e6c0c05ed897660bc6eb": {
          "class_code": "class gzofstream : public gzfilestream_common, public ostream {\n\npublic:\n\n  gzofstream();\n  gzofstream( const char *name, int io_mode = ios::out );\n  gzofstream( int fd, int io_mode = ios::out );\n\n  virtual ~gzofstream();\n\n}",
          "class_name": "gzofstream",
          "class_pos": [
            [
              79,
              0
            ],
            [
              89,
              1
            ]
          ]
        },
        "3e40ad0347106296884cc3d80e8089c2009faa054642757db2c91c09831cdf95": {
          "class_code": "template<class T> class gzomanip {\n  friend gzofstream &operator<<(gzofstream &, const gzomanip<T> &);\npublic:\n  gzomanip(gzofstream &(*f)(gzofstream &, T), T v) : func(f), val(v) { }\nprivate:\n  gzofstream &(*func)(gzofstream &, T);\n  T val;\n};",
          "class_name": "gzomanip",
          "class_pos": [
            [
              91,
              0
            ],
            [
              98,
              2
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <fstream.h>\n",
          [
            4,
            0
          ],
          [
            5,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/infback9/inftree9.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "inflate_table9(codetype type, unsigned short FAR *lens,\n                          unsigned codes, code FAR * FAR *table,\n                          unsigned FAR *bits, unsigned short FAR *work)",
          "fn_dec_pos": [
            [
              58,
              11
            ],
            [
              60,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflate_table9",
            "parameters": {
              "type": "codetype",
              "lens": "unsigned short FAR",
              "codes": "unsigned",
              "FAR": "code",
              "bits": "unsigned FAR",
              "work": "unsigned short FAR"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n    unsigned char op;           /* operation, extra bits, table bits */\n    unsigned char bits;         /* bits in this part of the code */\n    unsigned short val;         /* offset in table or code value */\n} code;",
          {
            "op": "unsigned char",
            "bits": "unsigned char",
            "val": "unsigned short"
          },
          "code",
          [
            23,
            0
          ],
          [
            27,
            7
          ]
        ],
        [
          "typedef struct {\n    unsigned char op;           /* operation, extra bits, table bits */\n    unsigned char bits;         /* bits in this part of the code */\n    unsigned short val;         /* offset in table or code value */\n} code;",
          {
            "op": "unsigned char",
            "bits": "unsigned char",
            "val": "unsigned short"
          },
          "code",
          [
            23,
            0
          ],
          [
            27,
            7
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n    CODES,\n    LENS,\n    DISTS\n} codetype;",
          {
            "CODES": "",
            "LENS": "",
            "DISTS": ""
          },
          "codetype",
          [
            52,
            0
          ],
          [
            56,
            11
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/infback9/inffix9.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/infback9/infback9.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "inflateBack9(z_stream FAR *strm,\n                                 in_func in, void FAR *in_desc,\n                                 out_func out, void FAR *out_desc)",
          "fn_dec_pos": [
            [
              22,
              20
            ],
            [
              24,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateBack9",
            "parameters": {
              "FAR": "void",
              "in": "in_func",
              "out": "out_func"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflateBack9End(z_stream FAR *strm)",
          "fn_dec_pos": [
            [
              25,
              20
            ],
            [
              25,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateBack9End",
            "parameters": {
              "FAR": "z_stream"
            },
            "return_type": "ZEXTERN"
          }
        },
        {
          "fn_code": "inflateBack9Init_(z_stream FAR *strm,\n                                      unsigned char FAR *window,\n                                      const char *version,\n                                      int stream_size)",
          "fn_dec_pos": [
            [
              26,
              20
            ],
            [
              29,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inflateBack9Init_",
            "parameters": {
              "FAR": "unsigned char",
              "version": "char",
              "stream_size": "int"
            },
            "return_type": "ZEXTERN"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/infback9/inflate9.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct inflate_state {\n        /* sliding window */\n    unsigned char FAR *window;  /* allocated sliding window, if needed */\n        /* dynamic table building */\n    unsigned ncode;             /* number of code length code lengths */\n    unsigned nlen;              /* number of length code lengths */\n    unsigned ndist;             /* number of distance code lengths */\n    unsigned have;              /* number of code lengths in lens[] */\n    code FAR *next;             /* next available space in codes[] */\n    unsigned short lens[320];   /* temporary storage for code lengths */\n    unsigned short work[288];   /* work area for code table building */\n    code codes[ENOUGH];         /* space for code tables */\n}",
          {
            "FAR": "code",
            "ncode": "unsigned",
            "nlen": "unsigned",
            "ndist": "unsigned",
            "have": "unsigned",
            "lens[320]": "unsigned short",
            "work[288]": "unsigned short",
            "codes[ENOUGH]": "code"
          },
          "inflate_state",
          [
            34,
            0
          ],
          [
            46,
            1
          ]
        ],
        [
          "struct inflate_state {\n        /* sliding window */\n    unsigned char FAR *window;  /* allocated sliding window, if needed */\n        /* dynamic table building */\n    unsigned ncode;             /* number of code length code lengths */\n    unsigned nlen;              /* number of length code lengths */\n    unsigned ndist;             /* number of distance code lengths */\n    unsigned have;              /* number of code lengths in lens[] */\n    code FAR *next;             /* next available space in codes[] */\n    unsigned short lens[320];   /* temporary storage for code lengths */\n    unsigned short work[288];   /* work area for code table building */\n    code codes[ENOUGH];         /* space for code tables */\n}",
          {
            "FAR": "code",
            "ncode": "unsigned",
            "nlen": "unsigned",
            "ndist": "unsigned",
            "have": "unsigned",
            "lens[320]": "unsigned short",
            "work[288]": "unsigned short",
            "codes[ENOUGH]": "code"
          },
          "inflate_state",
          [
            34,
            0
          ],
          [
            46,
            1
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n        TYPE,       /* i: waiting for type bits, including last-flag bit */\n        STORED,     /* i: waiting for stored size (length and complement) */\n        TABLE,      /* i: waiting for dynamic block table lengths */\n            LEN,        /* i: waiting for length/lit code */\n    DONE,       /* finished check, done -- remain here until reset */\n    BAD         /* got a data error -- remain here until reset */\n} inflate_mode;",
          {
            "TYPE": "",
            "STORED": "",
            "TABLE": "",
            "LEN": "",
            "DONE": "",
            "BAD": ""
          },
          "inflate_mode",
          [
            11,
            0
          ],
          [
            18,
            15
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/os400/zlib.inc": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "based(z_streamp)",
          "fn_dec_pos": [
            [
              92,
              49
            ],
            [
              92,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "alignment"
          }
        },
        {
          "fn_code": "extproc('compress')",
          "fn_dec_pos": [
            [
              113,
              43
            ],
            [
              113,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "D"
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              114,
              43
            ],
            [
              114,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "D"
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              116,
              49
            ],
            [
              116,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "level"
          }
        },
        {
          "fn_code": "extproc('compress2')",
          "fn_dec_pos": [
            [
              119,
              43
            ],
            [
              119,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "D"
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              120,
              43
            ],
            [
              120,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "D"
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              122,
              49
            ],
            [
              122,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('compressBound')",
          "fn_dec_pos": [
            [
              126,
              43
            ],
            [
              126,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "D"
          }
        },
        {
          "fn_code": "extproc('uncompress')",
          "fn_dec_pos": [
            [
              129,
              43
            ],
            [
              129,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "D"
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              130,
              43
            ],
            [
              130,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "D"
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              132,
              49
            ],
            [
              132,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "Source"
          }
        },
        {
          "fn_code": "extproc('uncompress2')",
          "fn_dec_pos": [
            [
              135,
              43
            ],
            [
              135,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "D"
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              136,
              43
            ],
            [
              136,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "D"
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              138,
              49
            ],
            [
              138,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              143,
              43
            ],
            [
              143,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*string)",
          "fn_dec_pos": [
            [
              144,
              49
            ],
            [
              144,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*string)",
          "fn_dec_pos": [
            [
              145,
              49
            ],
            [
              145,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzopen64')",
          "fn_dec_pos": [
            [
              147,
              43
            ],
            [
              147,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              148,
              43
            ],
            [
              148,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*string)",
          "fn_dec_pos": [
            [
              149,
              49
            ],
            [
              149,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*string)",
          "fn_dec_pos": [
            [
              150,
              49
            ],
            [
              150,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzopen64')",
          "fn_dec_pos": [
            [
              152,
              43
            ],
            [
              152,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              153,
              43
            ],
            [
              153,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*string)",
          "fn_dec_pos": [
            [
              154,
              49
            ],
            [
              154,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*string)",
          "fn_dec_pos": [
            [
              155,
              49
            ],
            [
              155,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzdopen')",
          "fn_dec_pos": [
            [
              158,
              43
            ],
            [
              158,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              159,
              43
            ],
            [
              159,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*string)",
          "fn_dec_pos": [
            [
              161,
              49
            ],
            [
              161,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzbuffer')",
          "fn_dec_pos": [
            [
              163,
              43
            ],
            [
              163,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              164,
              49
            ],
            [
              164,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzsetparams')",
          "fn_dec_pos": [
            [
              167,
              43
            ],
            [
              167,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              168,
              49
            ],
            [
              168,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzread')",
          "fn_dec_pos": [
            [
              172,
              43
            ],
            [
              172,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              173,
              49
            ],
            [
              173,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              174,
              43
            ],
            [
              174,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzfread')",
          "fn_dec_pos": [
            [
              177,
              43
            ],
            [
              177,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              178,
              43
            ],
            [
              178,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              181,
              49
            ],
            [
              181,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzwrite')",
          "fn_dec_pos": [
            [
              183,
              43
            ],
            [
              183,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              184,
              49
            ],
            [
              184,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              185,
              49
            ],
            [
              185,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "options",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzfwrite')",
          "fn_dec_pos": [
            [
              188,
              43
            ],
            [
              188,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              189,
              43
            ],
            [
              189,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              192,
              49
            ],
            [
              192,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzputs')",
          "fn_dec_pos": [
            [
              194,
              43
            ],
            [
              194,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              195,
              49
            ],
            [
              195,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*string)",
          "fn_dec_pos": [
            [
              196,
              49
            ],
            [
              196,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzgets')",
          "fn_dec_pos": [
            [
              198,
              43
            ],
            [
              198,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              199,
              49
            ],
            [
              199,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              200,
              43
            ],
            [
              200,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzputc')",
          "fn_dec_pos": [
            [
              203,
              43
            ],
            [
              203,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              204,
              49
            ],
            [
              204,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzgetc')",
          "fn_dec_pos": [
            [
              207,
              43
            ],
            [
              207,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              208,
              49
            ],
            [
              208,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzgetc_')",
          "fn_dec_pos": [
            [
              210,
              43
            ],
            [
              210,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              211,
              49
            ],
            [
              211,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzungetc')",
          "fn_dec_pos": [
            [
              213,
              43
            ],
            [
              213,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              215,
              49
            ],
            [
              215,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzflush')",
          "fn_dec_pos": [
            [
              217,
              43
            ],
            [
              217,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              218,
              49
            ],
            [
              218,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzseek')",
          "fn_dec_pos": [
            [
              222,
              43
            ],
            [
              222,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_off_t)",
          "fn_dec_pos": [
            [
              223,
              43
            ],
            [
              223,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              224,
              49
            ],
            [
              224,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_off_t)",
          "fn_dec_pos": [
            [
              225,
              49
            ],
            [
              225,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzseek64')",
          "fn_dec_pos": [
            [
              228,
              43
            ],
            [
              228,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_off_t)",
          "fn_dec_pos": [
            [
              229,
              43
            ],
            [
              229,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              230,
              49
            ],
            [
              230,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_off_t)",
          "fn_dec_pos": [
            [
              231,
              49
            ],
            [
              231,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzseek64')",
          "fn_dec_pos": [
            [
              234,
              43
            ],
            [
              234,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_off64_t)",
          "fn_dec_pos": [
            [
              235,
              43
            ],
            [
              235,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              236,
              49
            ],
            [
              236,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_off64_t)",
          "fn_dec_pos": [
            [
              237,
              49
            ],
            [
              237,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzrewind')",
          "fn_dec_pos": [
            [
              241,
              43
            ],
            [
              241,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              242,
              49
            ],
            [
              242,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gztell')",
          "fn_dec_pos": [
            [
              245,
              43
            ],
            [
              245,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_off_t)",
          "fn_dec_pos": [
            [
              246,
              43
            ],
            [
              246,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              247,
              49
            ],
            [
              247,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gztell64')",
          "fn_dec_pos": [
            [
              249,
              43
            ],
            [
              249,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_off_t)",
          "fn_dec_pos": [
            [
              250,
              43
            ],
            [
              250,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              251,
              49
            ],
            [
              251,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gztell64')",
          "fn_dec_pos": [
            [
              253,
              43
            ],
            [
              253,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_off64_t)",
          "fn_dec_pos": [
            [
              254,
              43
            ],
            [
              254,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              255,
              49
            ],
            [
              255,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzoffset')",
          "fn_dec_pos": [
            [
              259,
              43
            ],
            [
              259,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_off_t)",
          "fn_dec_pos": [
            [
              260,
              43
            ],
            [
              260,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              261,
              49
            ],
            [
              261,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzoffset64')",
          "fn_dec_pos": [
            [
              263,
              43
            ],
            [
              263,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_off_t)",
          "fn_dec_pos": [
            [
              264,
              43
            ],
            [
              264,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              265,
              49
            ],
            [
              265,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzoffset64')",
          "fn_dec_pos": [
            [
              267,
              43
            ],
            [
              267,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_off64_t)",
          "fn_dec_pos": [
            [
              268,
              43
            ],
            [
              268,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              269,
              49
            ],
            [
              269,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzeof')",
          "fn_dec_pos": [
            [
              272,
              43
            ],
            [
              272,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              273,
              49
            ],
            [
              273,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzdirect')",
          "fn_dec_pos": [
            [
              275,
              43
            ],
            [
              275,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              276,
              49
            ],
            [
              276,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzclose_r')",
          "fn_dec_pos": [
            [
              278,
              43
            ],
            [
              278,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              279,
              49
            ],
            [
              279,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzclose_w')",
          "fn_dec_pos": [
            [
              281,
              43
            ],
            [
              281,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              282,
              49
            ],
            [
              282,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzclose')",
          "fn_dec_pos": [
            [
              284,
              43
            ],
            [
              284,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              285,
              49
            ],
            [
              285,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzerror')",
          "fn_dec_pos": [
            [
              287,
              43
            ],
            [
              287,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              288,
              49
            ],
            [
              288,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('gzclearerr')",
          "fn_dec_pos": [
            [
              291,
              43
            ],
            [
              291,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(gzFile)",
          "fn_dec_pos": [
            [
              292,
              49
            ],
            [
              292,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('zlibVersion')",
          "fn_dec_pos": [
            [
              298,
              43
            ],
            [
              298,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('deflateInit_')",
          "fn_dec_pos": [
            [
              300,
              43
            ],
            [
              300,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              301,
              43
            ],
            [
              301,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*string)",
          "fn_dec_pos": [
            [
              303,
              49
            ],
            [
              303,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('deflate')",
          "fn_dec_pos": [
            [
              306,
              43
            ],
            [
              306,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              307,
              43
            ],
            [
              307,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('deflateEnd')",
          "fn_dec_pos": [
            [
              310,
              43
            ],
            [
              310,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              311,
              43
            ],
            [
              311,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateInit_')",
          "fn_dec_pos": [
            [
              313,
              43
            ],
            [
              313,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              314,
              43
            ],
            [
              314,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*string)",
          "fn_dec_pos": [
            [
              315,
              49
            ],
            [
              315,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflate')",
          "fn_dec_pos": [
            [
              318,
              43
            ],
            [
              318,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              319,
              43
            ],
            [
              319,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateEnd')",
          "fn_dec_pos": [
            [
              322,
              43
            ],
            [
              322,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              323,
              43
            ],
            [
              323,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('deflateInit2_')",
          "fn_dec_pos": [
            [
              329,
              43
            ],
            [
              329,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              330,
              43
            ],
            [
              330,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "log2(window size)",
          "fn_dec_pos": [
            [
              333,
              80
            ],
            [
              333,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "options(*string)",
          "fn_dec_pos": [
            [
              336,
              49
            ],
            [
              336,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('deflateSetDictionary')",
          "fn_dec_pos": [
            [
              340,
              43
            ],
            [
              340,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              341,
              43
            ],
            [
              341,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              342,
              49
            ],
            [
              342,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "options",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('deflateCopy')",
          "fn_dec_pos": [
            [
              345,
              43
            ],
            [
              345,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              346,
              43
            ],
            [
              346,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              347,
              43
            ],
            [
              347,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('deflateReset')",
          "fn_dec_pos": [
            [
              349,
              43
            ],
            [
              349,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              350,
              43
            ],
            [
              350,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('deflateParams')",
          "fn_dec_pos": [
            [
              352,
              43
            ],
            [
              352,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              353,
              43
            ],
            [
              353,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('deflateTune')",
          "fn_dec_pos": [
            [
              357,
              43
            ],
            [
              357,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              358,
              43
            ],
            [
              358,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('deflateBound')",
          "fn_dec_pos": [
            [
              364,
              43
            ],
            [
              364,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              365,
              43
            ],
            [
              365,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('deflatePending')",
          "fn_dec_pos": [
            [
              368,
              43
            ],
            [
              368,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              369,
              43
            ],
            [
              369,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('deflateUsed')",
          "fn_dec_pos": [
            [
              373,
              43
            ],
            [
              373,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              374,
              43
            ],
            [
              374,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('deflatePrime')",
          "fn_dec_pos": [
            [
              377,
              43
            ],
            [
              377,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              378,
              43
            ],
            [
              378,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateInit2_')",
          "fn_dec_pos": [
            [
              382,
              43
            ],
            [
              382,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              383,
              43
            ],
            [
              383,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "log2(window size)",
          "fn_dec_pos": [
            [
              384,
              80
            ],
            [
              384,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "options(*string)",
          "fn_dec_pos": [
            [
              385,
              49
            ],
            [
              385,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateSetDictionary')",
          "fn_dec_pos": [
            [
              389,
              43
            ],
            [
              389,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              390,
              43
            ],
            [
              390,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {
              "size": "window"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              391,
              49
            ],
            [
              391,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "options",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateGetDictionary')",
          "fn_dec_pos": [
            [
              395,
              43
            ],
            [
              395,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              396,
              43
            ],
            [
              396,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              397,
              43
            ],
            [
              397,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('deflateGetDictionary')",
          "fn_dec_pos": [
            [
              401,
              43
            ],
            [
              401,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              402,
              43
            ],
            [
              402,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              403,
              43
            ],
            [
              403,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateSync')",
          "fn_dec_pos": [
            [
              406,
              43
            ],
            [
              406,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              407,
              43
            ],
            [
              407,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateCopy')",
          "fn_dec_pos": [
            [
              409,
              43
            ],
            [
              409,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              410,
              43
            ],
            [
              410,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              411,
              43
            ],
            [
              411,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateReset')",
          "fn_dec_pos": [
            [
              413,
              43
            ],
            [
              413,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              414,
              43
            ],
            [
              414,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateReset2')",
          "fn_dec_pos": [
            [
              416,
              43
            ],
            [
              416,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              417,
              43
            ],
            [
              417,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Log2(buffer size)",
          "fn_dec_pos": [
            [
              418,
              80
            ],
            [
              418,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflatePrime')",
          "fn_dec_pos": [
            [
              420,
              43
            ],
            [
              420,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              421,
              43
            ],
            [
              421,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateMark')",
          "fn_dec_pos": [
            [
              425,
              43
            ],
            [
              425,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              426,
              43
            ],
            [
              426,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateCodesUsed')",
          "fn_dec_pos": [
            [
              429,
              43
            ],
            [
              429,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              430,
              43
            ],
            [
              430,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateValidate')",
          "fn_dec_pos": [
            [
              433,
              43
            ],
            [
              433,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              434,
              43
            ],
            [
              434,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateGetHeader')",
          "fn_dec_pos": [
            [
              438,
              43
            ],
            [
              438,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              439,
              43
            ],
            [
              439,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(gz_headerp)",
          "fn_dec_pos": [
            [
              440,
              43
            ],
            [
              440,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('deflateSetHeader')",
          "fn_dec_pos": [
            [
              443,
              43
            ],
            [
              443,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              444,
              43
            ],
            [
              444,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(gz_headerp)",
          "fn_dec_pos": [
            [
              445,
              43
            ],
            [
              445,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateBackInit_')",
          "fn_dec_pos": [
            [
              448,
              43
            ],
            [
              448,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              449,
              43
            ],
            [
              449,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "Log2(buffer size)",
          "fn_dec_pos": [
            [
              450,
              80
            ],
            [
              450,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              451,
              43
            ],
            [
              451,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "options(*string)",
          "fn_dec_pos": [
            [
              452,
              49
            ],
            [
              452,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateBack')",
          "fn_dec_pos": [
            [
              455,
              43
            ],
            [
              455,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              456,
              43
            ],
            [
              456,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateBackEnd')",
          "fn_dec_pos": [
            [
              462,
              43
            ],
            [
              462,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              463,
              43
            ],
            [
              463,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('zlibCompileFlags')",
          "fn_dec_pos": [
            [
              466,
              43
            ],
            [
              466,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {
              "size": "buffer"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('adler32')",
          "fn_dec_pos": [
            [
              472,
              43
            ],
            [
              472,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              474,
              49
            ],
            [
              474,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "options",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('adler32_combine')",
          "fn_dec_pos": [
            [
              478,
              43
            ],
            [
              478,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('adler32_z')",
          "fn_dec_pos": [
            [
              483,
              43
            ],
            [
              483,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              485,
              49
            ],
            [
              485,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "options",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('crc32')",
          "fn_dec_pos": [
            [
              488,
              43
            ],
            [
              488,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              490,
              49
            ],
            [
              490,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "options",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('crc32_combine')",
          "fn_dec_pos": [
            [
              494,
              43
            ],
            [
              494,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('crc32_z')",
          "fn_dec_pos": [
            [
              499,
              43
            ],
            [
              499,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "options(*varsize)",
          "fn_dec_pos": [
            [
              501,
              49
            ],
            [
              501,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "options",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('zError')",
          "fn_dec_pos": [
            [
              508,
              43
            ],
            [
              508,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateSyncPoint')",
          "fn_dec_pos": [
            [
              512,
              43
            ],
            [
              512,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              513,
              43
            ],
            [
              513,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('get_crc_table')",
          "fn_dec_pos": [
            [
              515,
              43
            ],
            [
              515,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extproc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateUndermine')",
          "fn_dec_pos": [
            [
              518,
              43
            ],
            [
              518,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              519,
              43
            ],
            [
              519,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('inflateResetKeep')",
          "fn_dec_pos": [
            [
              523,
              43
            ],
            [
              523,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              524,
              43
            ],
            [
              524,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "extproc('deflateResetKeep')",
          "fn_dec_pos": [
            [
              527,
              43
            ],
            [
              527,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "like(z_stream)",
          "fn_dec_pos": [
            [
              528,
              43
            ],
            [
              528,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "like",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/examples/zran.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "deflate_index_build(FILE *in, off_t span, struct deflate_index **built)",
          "fn_dec_pos": [
            [
              35,
              4
            ],
            [
              35,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflate_index_build",
            "parameters": {
              "in": "FILE",
              "span": "off_t",
              "built": "struct deflate_index"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "deflate_index_extract(FILE *in, struct deflate_index *index,\n                                off_t offset, unsigned char *buf, size_t len)",
          "fn_dec_pos": [
            [
              48,
              10
            ],
            [
              49,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflate_index_extract",
            "parameters": {
              "in": "FILE",
              "index": "struct deflate_index",
              "offset": "off_t",
              "buf": "unsigned char",
              "len": "size_t"
            },
            "return_type": "ptrdiff_t"
          }
        },
        {
          "fn_code": "deflate_index_free(struct deflate_index *index)",
          "fn_dec_pos": [
            [
              52,
              5
            ],
            [
              52,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "deflate_index_free",
            "parameters": {
              "index": "struct deflate_index"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct point {\n    off_t out;          // offset in uncompressed data\n    off_t in;           // offset in compressed file of first full byte\n    int bits;           // 0, or number of bits (1-7) from byte at in-1\n    unsigned dict;      // number of bytes in window to use as a dictionary\n    unsigned char *window;  // preceding 32K (or less) of uncompressed data\n} point_t;",
          {
            "out": "off_t",
            "in": "off_t",
            "bits": "int",
            "dict": "unsigned",
            "*window": "unsigned char"
          },
          "point_t",
          [
            9,
            0
          ],
          [
            15,
            10
          ]
        ],
        [
          "struct deflate_index {\n    int have;           // number of access points in list\n    int mode;           // -15 for raw, 15 for zlib, or 31 for gzip\n    off_t length;       // total length of uncompressed data\n    point_t *list;      // allocated list of access points\n    z_stream strm;      // re-usable inflate engine for extraction\n}",
          {
            "have": "int",
            "mode": "int",
            "length": "off_t",
            "*list": "point_t",
            "strm": "z_stream"
          },
          "deflate_index",
          [
            18,
            0
          ],
          [
            24,
            1
          ]
        ],
        [
          "typedef struct point {\n    off_t out;          // offset in uncompressed data\n    off_t in;           // offset in compressed file of first full byte\n    int bits;           // 0, or number of bits (1-7) from byte at in-1\n    unsigned dict;      // number of bytes in window to use as a dictionary\n    unsigned char *window;  // preceding 32K (or less) of uncompressed data\n} point_t;",
          {
            "out": "off_t",
            "in": "off_t",
            "bits": "int",
            "dict": "unsigned",
            "*window": "unsigned char"
          },
          "point_t",
          [
            9,
            0
          ],
          [
            15,
            10
          ]
        ],
        [
          "struct deflate_index {\n    int have;           // number of access points in list\n    int mode;           // -15 for raw, 15 for zlib, or 31 for gzip\n    off_t length;       // total length of uncompressed data\n    point_t *list;      // allocated list of access points\n    z_stream strm;      // re-usable inflate engine for extraction\n}",
          {
            "have": "int",
            "mode": "int",
            "length": "off_t",
            "*list": "point_t",
            "strm": "z_stream"
          },
          "deflate_index",
          [
            18,
            0
          ],
          [
            24,
            1
          ]
        ],
        [
          "struct deflate_index",
          {},
          "",
          [
            35,
            46
          ],
          [
            35,
            66
          ]
        ],
        [
          "struct deflate_index",
          {},
          "",
          [
            48,
            42
          ],
          [
            48,
            62
          ]
        ],
        [
          "struct deflate_index",
          {},
          "",
          [
            52,
            24
          ],
          [
            52,
            44
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            6,
            0
          ],
          [
            7,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/examples/gzlog.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "gzlog_open(char *path)",
          "fn_dec_pos": [
            [
              65,
              7
            ],
            [
              65,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzlog_open",
            "parameters": {
              "path": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzlog_write(gzlog *log, void *data, size_t len)",
          "fn_dec_pos": [
            [
              76,
              4
            ],
            [
              76,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzlog_write",
            "parameters": {
              "log": "gzlog",
              "data": "void",
              "len": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "gzlog_compress(gzlog *log)",
          "fn_dec_pos": [
            [
              84,
              4
            ],
            [
              84,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzlog_compress",
            "parameters": {
              "log": "gzlog"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "gzlog_close(gzlog *log)",
          "fn_dec_pos": [
            [
              88,
              4
            ],
            [
              88,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzlog_close",
            "parameters": {
              "log": "gzlog"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    }
  }
}