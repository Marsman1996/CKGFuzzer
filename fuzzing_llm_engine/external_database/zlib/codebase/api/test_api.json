{
  "src": {
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/contrib/iostream2/zstream_test.cpp": {
      "fn_def_list": [
        {
          "fn_code": "void main() {\n    char h[256] = \"Hello\";\n    char* g = \"Goodbye\";\n    ozstream out(\"temp.gz\");\n    out < \"This works well\" < h < g;\n    out.close();\n\n    izstream in(\"temp.gz\"); // read it back\n    char *x = read_string(in), *y = new char[256], z[256];\n    in > y > z;\n    in.close();\n    cout << x << endl << y << endl << z << endl;\n\n    out.open(\"temp.gz\"); // try ascii output; zcat temp.gz to see the results\n    out << setw(50) << setfill('#') << setprecision(20) << x << endl << y << endl << z << endl;\n    out << z << endl << y << endl << x << endl;\n    out << 1.1234567890123456789 << endl;\n\n    delete[] x; delete[] y;\n}",
          "fn_code_pos": [
            [
              5,
              0
            ],
            [
              24,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"zstream.h\"\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ],
        [
          "#include <iomanip.h>\n",
          [
            3,
            0
          ],
          [
            4,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/test/example.c": {
      "fn_def_list": [
        {
          "fn_code": "static void *myalloc(void *q, unsigned n, unsigned m) {\n    (void)q;\n    return calloc(n, m);\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              47,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "myalloc",
            "parameters": {
              "q": "void",
              "n": "unsigned",
              "m": "unsigned"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void myfree(void *q, void *p) {\n    (void)q;\n    free(p);\n}",
          "fn_code_pos": [
            [
              49,
              0
            ],
            [
              52,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "myfree",
            "parameters": {
              "q": "void",
              "p": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void test_compress(Byte *compr, uLong comprLen, Byte *uncompr,\n                   uLong uncomprLen) {\n    int err;\n    uLong len = (uLong)strlen(hello)+1;\n\n    err = compress(compr, &comprLen, (const Bytef*)hello, len);\n    CHECK_ERR(err, \"compress\");\n\n    strcpy((char*)uncompr, \"garbage\");\n\n    err = uncompress(uncompr, &uncomprLen, compr, comprLen);\n    CHECK_ERR(err, \"uncompress\");\n\n    if (strcmp((char*)uncompr, hello)) {\n        fprintf(stderr, \"bad uncompress\\n\");\n        exit(1);\n    } else {\n        printf(\"uncompress(): %s\\n\", (char *)uncompr);\n    }\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "test_compress",
            "parameters": {
              "compr": "Byte",
              "comprLen": "uLong",
              "uncompr": "Byte",
              "uncomprLen": "uLong"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void test_gzio(const char *fname, Byte *uncompr, uLong uncomprLen) {\n#ifdef NO_GZCOMPRESS\n    fprintf(stderr, \"NO_GZCOMPRESS -- gz* functions cannot compress\\n\");\n#else\n    int err;\n    int len = (int)strlen(hello)+1;\n    gzFile file;\n    z_off_t pos;\n\n    file = gzopen(fname, \"wb\");\n    if (file == NULL) {\n        fprintf(stderr, \"gzopen error\\n\");\n        exit(1);\n    }\n    gzputc(file, 'h');\n    if (gzputs(file, \"ello\") != 4) {\n        fprintf(stderr, \"gzputs err: %s\\n\", gzerror(file, &err));\n        exit(1);\n    }\n    if (gzprintf(file, \", %s!\", \"hello\") != 8) {\n        fprintf(stderr, \"gzprintf err: %s\\n\", gzerror(file, &err));\n        exit(1);\n    }\n    gzseek(file, 1L, SEEK_CUR); /* add one zero byte */\n    gzclose(file);\n\n    file = gzopen(fname, \"rb\");\n    if (file == NULL) {\n        fprintf(stderr, \"gzopen error\\n\");\n        exit(1);\n    }\n    strcpy((char*)uncompr, \"garbage\");\n\n    if (gzread(file, uncompr, (unsigned)uncomprLen) != len) {\n        fprintf(stderr, \"gzread err: %s\\n\", gzerror(file, &err));\n        exit(1);\n    }\n    if (strcmp((char*)uncompr, hello)) {\n        fprintf(stderr, \"bad gzread: %s\\n\", (char*)uncompr);\n        exit(1);\n    } else {\n        printf(\"gzread(): %s\\n\", (char*)uncompr);\n    }\n\n    pos = gzseek(file, -8L, SEEK_CUR);\n    if (pos != 6 || gztell(file) != pos) {\n        fprintf(stderr, \"gzseek error, pos=%ld, gztell=%ld\\n\",\n                (long)pos, (long)gztell(file));\n        exit(1);\n    }\n\n    if (gzgetc(file) != ' ') {\n        fprintf(stderr, \"gzgetc error\\n\");\n        exit(1);\n    }\n\n    if (gzungetc(' ', file) != ' ') {\n        fprintf(stderr, \"gzungetc error\\n\");\n        exit(1);\n    }\n\n    gzgets(file, (char*)uncompr, (int)uncomprLen);\n    if (strlen((char*)uncompr) != 7) { /* \" hello!\" */\n        fprintf(stderr, \"gzgets err after gzseek: %s\\n\", gzerror(file, &err));\n        exit(1);\n    }\n    if (strcmp((char*)uncompr, hello + 6)) {\n        fprintf(stderr, \"bad gzgets after gzseek\\n\");\n        exit(1);\n    } else {\n        printf(\"gzgets() after gzseek: %s\\n\", (char*)uncompr);\n    }\n\n    gzclose(file);\n#endif\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              164,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "test_gzio",
            "parameters": {
              "fname": "char",
              "uncompr": "Byte",
              "uncomprLen": "uLong"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void test_deflate(Byte *compr, uLong comprLen) {\n    z_stream c_stream; /* compression stream */\n    int err;\n    uLong len = (uLong)strlen(hello)+1;\n\n    c_stream.zalloc = zalloc;\n    c_stream.zfree = zfree;\n    c_stream.opaque = (voidpf)0;\n\n    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);\n    CHECK_ERR(err, \"deflateInit\");\n\n    c_stream.next_in  = (z_const unsigned char *)hello;\n    c_stream.next_out = compr;\n\n    while (c_stream.total_in != len && c_stream.total_out < comprLen) {\n        c_stream.avail_in = c_stream.avail_out = 1; /* force small buffers */\n        err = deflate(&c_stream, Z_NO_FLUSH);\n        CHECK_ERR(err, \"deflate\");\n    }\n    /* Finish the stream, still forcing small buffers: */\n    for (;;) {\n        c_stream.avail_out = 1;\n        err = deflate(&c_stream, Z_FINISH);\n        if (err == Z_STREAM_END) break;\n        CHECK_ERR(err, \"deflate\");\n    }\n\n    err = deflateEnd(&c_stream);\n    CHECK_ERR(err, \"deflateEnd\");\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "test_deflate",
            "parameters": {
              "compr": "Byte",
              "comprLen": "uLong"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "myalloc(void *q, unsigned n, unsigned m)",
          "fn_dec_pos": [
            [
              44,
              13
            ],
            [
              44,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "myalloc",
            "parameters": {
              "q": "void",
              "n": "unsigned",
              "m": "unsigned"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "test_inflate(Byte *compr, uLong comprLen, Byte *uncompr,\n                  uLong uncomprLen)",
          "fn_dec_pos": [
            [
              206,
              12
            ],
            [
              207,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "test_inflate",
            "parameters": {
              "compr": "Byte",
              "comprLen": "uLong",
              "uncompr": "Byte",
              "uncomprLen": "uLong"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"zlib.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "#  include <string.h>\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#  include <stdlib.h>\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/test/minigzip.c": {
      "fn_def_list": [
        {
          "fn_code": "static char *string_copy(char *dst, char const *src, z_size_t len) {\n    if (len == 0)\n        return NULL;\n    while (--len) {\n        *dst = *src++;\n        if (*dst == 0)\n            return dst;\n        dst++;\n    }\n    *dst = 0;\n    return dst;\n}",
          "fn_code_pos": [
            [
              159,
              0
            ],
            [
              170,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "string_copy",
            "parameters": {
              "dst": "char",
              "src": "char",
              "len": "z_size_t"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static void *myalloc(void *q, unsigned n, unsigned m) {\n    (void)q;\n    return calloc(n, m);\n}",
          "fn_code_pos": [
            [
              179,
              0
            ],
            [
              182,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "myalloc",
            "parameters": {
              "q": "void",
              "n": "unsigned",
              "m": "unsigned"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void myfree(void *q, void *p) {\n    (void)q;\n    free(p);\n}",
          "fn_code_pos": [
            [
              184,
              0
            ],
            [
              187,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "myfree",
            "parameters": {
              "q": "void",
              "p": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static gzFile gz_open(const char *path, int fd, const char *mode) {\n    gzFile gz;\n    int ret;\n\n    gz = malloc(sizeof(struct gzFile_s));\n    if (gz == NULL)\n        return NULL;\n    gz->write = strchr(mode, 'w') != NULL;\n    gz->strm.zalloc = myalloc;\n    gz->strm.zfree = myfree;\n    gz->strm.opaque = Z_NULL;\n    if (gz->write)\n        ret = deflateInit2(&(gz->strm), -1, 8, 15 + 16, 8, 0);\n    else {\n        gz->strm.next_in = 0;\n        gz->strm.avail_in = Z_NULL;\n        ret = inflateInit2(&(gz->strm), 15 + 16);\n    }\n    if (ret != Z_OK) {\n        free(gz);\n        return NULL;\n    }\n    gz->file = path == NULL ? fdopen(fd, gz->write ? \"wb\" : \"rb\") :\n                              fopen(path, gz->write ? \"wb\" : \"rb\");\n    if (gz->file == NULL) {\n        gz->write ? deflateEnd(&(gz->strm)) : inflateEnd(&(gz->strm));\n        free(gz);\n        return NULL;\n    }\n    gz->err = 0;\n    gz->msg = \"\";\n    return gz;\n}",
          "fn_code_pos": [
            [
              197,
              0
            ],
            [
              229,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_open",
            "parameters": {
              "path": "char",
              "fd": "int",
              "mode": "char"
            },
            "return_type": "gzFile"
          }
        },
        {
          "fn_code": "static gzFile gzopen(const char *path, const char *mode) {\n    return gz_open(path, -1, mode);\n}",
          "fn_code_pos": [
            [
              231,
              0
            ],
            [
              233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzopen",
            "parameters": {
              "path": "char",
              "mode": "char"
            },
            "return_type": "gzFile"
          }
        },
        {
          "fn_code": "static gzFile gzdopen(int fd, const char *mode) {\n    return gz_open(NULL, fd, mode);\n}",
          "fn_code_pos": [
            [
              235,
              0
            ],
            [
              237,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzdopen",
            "parameters": {
              "fd": "int",
              "mode": "char"
            },
            "return_type": "gzFile"
          }
        },
        {
          "fn_code": "static int gzwrite(gzFile gz, const void *buf, unsigned len) {\n    z_stream *strm;\n    unsigned char out[BUFLEN];\n\n    if (gz == NULL || !gz->write)\n        return 0;\n    strm = &(gz->strm);\n    strm->next_in = (void *)buf;\n    strm->avail_in = len;\n    do {\n        strm->next_out = out;\n        strm->avail_out = BUFLEN;\n        (void)deflate(strm, Z_NO_FLUSH);\n        fwrite(out, 1, BUFLEN - strm->avail_out, gz->file);\n    } while (strm->avail_out == 0);\n    return len;\n}",
          "fn_code_pos": [
            [
              239,
              0
            ],
            [
              255,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzwrite",
            "parameters": {
              "gz": "gzFile",
              "buf": "void",
              "len": "unsigned"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int gzread(gzFile gz, void *buf, unsigned len) {\n    int ret;\n    unsigned got;\n    unsigned char in[1];\n    z_stream *strm;\n\n    if (gz == NULL || gz->write)\n        return 0;\n    if (gz->err)\n        return 0;\n    strm = &(gz->strm);\n    strm->next_out = (void *)buf;\n    strm->avail_out = len;\n    do {\n        got = fread(in, 1, 1, gz->file);\n        if (got == 0)\n            break;\n        strm->next_in = in;\n        strm->avail_in = 1;\n        ret = inflate(strm, Z_NO_FLUSH);\n        if (ret == Z_DATA_ERROR) {\n            gz->err = Z_DATA_ERROR;\n            gz->msg = strm->msg;\n            return 0;\n        }\n        if (ret == Z_STREAM_END)\n            inflateReset(strm);\n    } while (strm->avail_out);\n    return len - strm->avail_out;\n}",
          "fn_code_pos": [
            [
              257,
              0
            ],
            [
              286,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzread",
            "parameters": {
              "gz": "gzFile",
              "buf": "void",
              "len": "unsigned"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int gzclose(gzFile gz) {\n    z_stream *strm;\n    unsigned char out[BUFLEN];\n\n    if (gz == NULL)\n        return Z_STREAM_ERROR;\n    strm = &(gz->strm);\n    if (gz->write) {\n        strm->next_in = Z_NULL;\n        strm->avail_in = 0;\n        do {\n            strm->next_out = out;\n            strm->avail_out = BUFLEN;\n            (void)deflate(strm, Z_FINISH);\n            fwrite(out, 1, BUFLEN - strm->avail_out, gz->file);\n        } while (strm->avail_out == 0);\n        deflateEnd(strm);\n    }\n    else\n        inflateEnd(strm);\n    fclose(gz->file);\n    free(gz);\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              288,
              0
            ],
            [
              311,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzclose",
            "parameters": {
              "gz": "gzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static const char *gzerror(gzFile gz, int *err) {\n    *err = gz->err;\n    return gz->msg;\n}",
          "fn_code_pos": [
            [
              313,
              0
            ],
            [
              316,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzerror",
            "parameters": {
              "gz": "gzFile",
              "err": "int"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static void error(const char *msg) {\n    fprintf(stderr, \"%s: %s\\n\", prog, msg);\n    exit(1);\n}",
          "fn_code_pos": [
            [
              325,
              0
            ],
            [
              328,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "error",
            "parameters": {
              "msg": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int gz_compress_mmap(FILE *in, gzFile out) {\n    int len;\n    int err;\n    int ifd = fileno(in);\n    caddr_t buf;    /* mmap'ed buffer for the entire input file */\n    off_t buf_len;  /* length of the input file */\n    struct stat sb;\n\n    /* Determine the size of the file, needed for mmap: */\n    if (fstat(ifd, &sb) < 0) return Z_ERRNO;\n    buf_len = sb.st_size;\n    if (buf_len <= 0) return Z_ERRNO;\n\n    /* Now do the actual mmap: */\n    buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t)0);\n    if (buf == (caddr_t)(-1)) return Z_ERRNO;\n\n    /* Compress the whole file at once: */\n    len = gzwrite(out, (char *)buf, (unsigned)buf_len);\n\n    if (len != (int)buf_len) error(gzerror(out, &err));\n\n    munmap(buf, buf_len);\n    fclose(in);\n    if (gzclose(out) != Z_OK) error(\"failed gzclose\");\n    return Z_OK;\n}",
          "fn_code_pos": [
            [
              335,
              0
            ],
            [
              361,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_compress_mmap",
            "parameters": {
              "in": "FILE",
              "out": "gzFile"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void gz_compress(FILE *in, gzFile out) {\n    local char buf[BUFLEN];\n    int len;\n    int err;\n\n#ifdef USE_MMAP\n    /* Try first compressing with mmap. If mmap fails (minigzip used in a\n     * pipe), use the normal fread loop.\n     */\n    if (gz_compress_mmap(in, out) == Z_OK) return;\n#endif\n    for (;;) {\n        len = (int)fread(buf, 1, sizeof(buf), in);\n        if (ferror(in)) {\n            perror(\"fread\");\n            exit(1);\n        }\n        if (len == 0) break;\n\n        if (gzwrite(out, buf, (unsigned)len) != len) error(gzerror(out, &err));\n    }\n    fclose(in);\n    if (gzclose(out) != Z_OK) error(\"failed gzclose\");\n}",
          "fn_code_pos": [
            [
              368,
              0
            ],
            [
              391,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_compress",
            "parameters": {
              "in": "FILE",
              "out": "gzFile"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void gz_uncompress(gzFile in, FILE *out) {\n    local char buf[BUFLEN];\n    int len;\n    int err;\n\n    for (;;) {\n        len = gzread(in, buf, sizeof(buf));\n        if (len < 0) error (gzerror(in, &err));\n        if (len == 0) break;\n\n        if ((int)fwrite(buf, 1, (unsigned)len, out) != len) {\n            error(\"failed fwrite\");\n        }\n    }\n    if (fclose(out)) error(\"failed fclose\");\n\n    if (gzclose(in) != Z_OK) error(\"failed gzclose\");\n}",
          "fn_code_pos": [
            [
              396,
              0
            ],
            [
              413,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gz_uncompress",
            "parameters": {
              "in": "gzFile",
              "out": "FILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void file_compress(char *file, char *mode) {\n    local char outfile[MAX_NAME_LEN+1], *end;\n    FILE  *in;\n    gzFile out;\n\n    if (strlen(file) + strlen(GZ_SUFFIX) >= sizeof(outfile)) {\n        fprintf(stderr, \"%s: filename too long\\n\", prog);\n        exit(1);\n    }\n\n    end = string_copy(outfile, file, sizeof(outfile));\n    string_copy(end, GZ_SUFFIX, sizeof(outfile) - (z_size_t)(end - outfile));\n\n    in = fopen(file, \"rb\");\n    if (in == NULL) {\n        perror(file);\n        exit(1);\n    }\n    out = gzopen(outfile, mode);\n    if (out == NULL) {\n        fprintf(stderr, \"%s: can't gzopen %s\\n\", prog, outfile);\n        exit(1);\n    }\n    gz_compress(in, out);\n\n    unlink(file);\n}",
          "fn_code_pos": [
            [
              420,
              0
            ],
            [
              446,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_compress",
            "parameters": {
              "file": "char",
              "mode": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void file_uncompress(char *file) {\n    local char buf[MAX_NAME_LEN+1];\n    char *infile, *outfile;\n    FILE  *out;\n    gzFile in;\n    z_size_t len = strlen(file);\n\n    if (len + strlen(GZ_SUFFIX) >= sizeof(buf)) {\n        fprintf(stderr, \"%s: filename too long\\n\", prog);\n        exit(1);\n    }\n\n    string_copy(buf, file, sizeof(buf));\n\n    if (len > SUFFIX_LEN && strcmp(file+len-SUFFIX_LEN, GZ_SUFFIX) == 0) {\n        infile = file;\n        outfile = buf;\n        outfile[len-3] = '\\0';\n    } else {\n        outfile = file;\n        infile = buf;\n        string_copy(buf + len, GZ_SUFFIX, sizeof(buf) - len);\n    }\n    in = gzopen(infile, \"rb\");\n    if (in == NULL) {\n        fprintf(stderr, \"%s: can't gzopen %s\\n\", prog, infile);\n        exit(1);\n    }\n    out = fopen(outfile, \"wb\");\n    if (out == NULL) {\n        perror(file);\n        exit(1);\n    }\n\n    gz_uncompress(in, out);\n\n    unlink(infile);\n}",
          "fn_code_pos": [
            [
              452,
              0
            ],
            [
              489,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "file_uncompress",
            "parameters": {
              "file": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[]) {\n    int copyout = 0;\n    int uncompr = 0;\n    gzFile file;\n    char *bname, outmode[5];\n\n    string_copy(outmode, \"wb6 \", sizeof(outmode));\n    prog = argv[0];\n    bname = strrchr(argv[0], '/');\n    if (bname)\n      bname++;\n    else\n      bname = argv[0];\n    argc--, argv++;\n\n    if (!strcmp(bname, \"gunzip\"))\n      uncompr = 1;\n    else if (!strcmp(bname, \"zcat\"))\n      copyout = uncompr = 1;\n\n    while (argc > 0) {\n      if (strcmp(*argv, \"-c\") == 0)\n        copyout = 1;\n      else if (strcmp(*argv, \"-d\") == 0)\n        uncompr = 1;\n      else if (strcmp(*argv, \"-f\") == 0)\n        outmode[3] = 'f';\n      else if (strcmp(*argv, \"-h\") == 0)\n        outmode[3] = 'h';\n      else if (strcmp(*argv, \"-r\") == 0)\n        outmode[3] = 'R';\n      else if ((*argv)[0] == '-' && (*argv)[1] >= '1' && (*argv)[1] <= '9' &&\n               (*argv)[2] == 0)\n        outmode[2] = (*argv)[1];\n      else\n        break;\n      argc--, argv++;\n    }\n    if (outmode[3] == ' ')\n        outmode[3] = 0;\n    if (argc == 0) {\n        SET_BINARY_MODE(stdin);\n        SET_BINARY_MODE(stdout);\n        if (uncompr) {\n            file = gzdopen(fileno(stdin), \"rb\");\n            if (file == NULL) error(\"can't gzdopen stdin\");\n            gz_uncompress(file, stdout);\n        } else {\n            file = gzdopen(fileno(stdout), outmode);\n            if (file == NULL) error(\"can't gzdopen stdout\");\n            gz_compress(stdin, file);\n        }\n    } else {\n        if (copyout) {\n            SET_BINARY_MODE(stdout);\n        }\n        do {\n            if (uncompr) {\n                if (copyout) {\n                    file = gzopen(*argv, \"rb\");\n                    if (file == NULL)\n                        fprintf(stderr, \"%s: can't gzopen %s\\n\", prog, *argv);\n                    else\n                        gz_uncompress(file, stdout);\n                } else {\n                    file_uncompress(*argv);\n                }\n            } else {\n                if (copyout) {\n                    FILE * in = fopen(*argv, \"rb\");\n\n                    if (in == NULL) {\n                        perror(*argv);\n                    } else {\n                        file = gzdopen(fileno(stdout), outmode);\n                        if (file == NULL) error(\"can't gzdopen stdout\");\n\n                        gz_compress(in, file);\n                    }\n\n                } else {\n                    file_compress(*argv, outmode);\n                }\n            }\n        } while (argv++, --argc);\n    }\n    return 0;\n}",
          "fn_code_pos": [
            [
              502,
              0
            ],
            [
              589,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "unlink(const char *)",
          "fn_dec_pos": [
            [
              70,
              13
            ],
            [
              70,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unlink",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "strwinerror (error)",
          "fn_dec_pos": [
            [
              88,
              13
            ],
            [
              88,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strwinerror",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "pwinerror (s)\n    const",
          "fn_dec_pos": [
            [
              127,
              12
            ],
            [
              128,
              9
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pwinerror",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "string_copy(char *dst, char const *src, z_size_t len)",
          "fn_dec_pos": [
            [
              159,
              13
            ],
            [
              159,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "string_copy",
            "parameters": {
              "dst": "char",
              "src": "char",
              "len": "z_size_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "myalloc(void *q, unsigned n, unsigned m)",
          "fn_dec_pos": [
            [
              179,
              13
            ],
            [
              179,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "myalloc",
            "parameters": {
              "q": "void",
              "n": "unsigned",
              "m": "unsigned"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "gzerror(gzFile gz, int *err)",
          "fn_dec_pos": [
            [
              313,
              19
            ],
            [
              313,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gzerror",
            "parameters": {
              "gz": "gzFile",
              "err": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct gzFile_s {\n    FILE *file;\n    int write;\n    int err;\n    char *msg;\n    z_stream strm;\n} *gzFile;",
          {
            "*file": "FILE",
            "write": "int",
            "err": "int",
            "*msg": "char",
            "strm": "z_stream"
          },
          "gzFile",
          [
            189,
            0
          ],
          [
            195,
            10
          ]
        ],
        [
          "typedef struct gzFile_s {\n    FILE *file;\n    int write;\n    int err;\n    char *msg;\n    z_stream strm;\n} *gzFile;",
          {
            "*file": "FILE",
            "write": "int",
            "err": "int",
            "*msg": "char",
            "strm": "z_stream"
          },
          "gzFile",
          [
            189,
            0
          ],
          [
            195,
            10
          ]
        ],
        [
          "struct gzFile_s",
          {},
          "",
          [
            201,
            23
          ],
          [
            201,
            38
          ]
        ],
        [
          "struct stat",
          {},
          "",
          [
            341,
            4
          ],
          [
            341,
            15
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"zlib.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#  include <string.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#  include <stdlib.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#  include <sys/types.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#  include <sys/mman.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#  include <sys/stat.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#  include <fcntl.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#  include <io.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#    include <stdlib.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#  include <unix.h> /* for fileno */\n",
          [
            65,
            0
          ],
          [
            66,
            0
          ]
        ],
        [
          "#  include <windows.h>\n",
          [
            75,
            0
          ],
          [
            76,
            0
          ]
        ],
        [
          "#  include <unistd.h>       /* for unlink() */\n",
          [
            176,
            0
          ],
          [
            177,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/zlib/test/infcover.c": {
      "fn_def_list": [
        {
          "fn_code": "local void *mem_alloc(void *mem, unsigned count, unsigned size)\n{\n    void *ptr;\n    struct mem_item *item;\n    struct mem_zone *zone = mem;\n    size_t len = count * (size_t)size;\n\n    /* induced allocation failure */\n    if (zone == NULL || (zone->limit && zone->total + len > zone->limit))\n        return NULL;\n\n    /* perform allocation using the standard library, fill memory with a\n       non-zero value to make sure that the code isn't depending on zeros */\n    ptr = malloc(len);\n    if (ptr == NULL)\n        return NULL;\n    memset(ptr, 0xa5, len);\n\n    /* create a new item for the list */\n    item = malloc(sizeof(struct mem_item));\n    if (item == NULL) {\n        free(ptr);\n        return NULL;\n    }\n    item->ptr = ptr;\n    item->size = len;\n\n    /* insert item at the beginning of the list */\n    item->next = zone->first;\n    zone->first = item;\n\n    /* update the statistics */\n    zone->total += item->size;\n    if (zone->total > zone->highwater)\n        zone->highwater = zone->total;\n\n    /* return the allocated memory */\n    return ptr;\n}",
          "fn_code_pos": [
            [
              70,
              0
            ],
            [
              108,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mem_alloc",
            "parameters": {
              "mem": "void",
              "count": "unsigned",
              "size": "unsigned"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void mem_free(void *mem, void *ptr)\n{\n    struct mem_item *item, *next;\n    struct mem_zone *zone = mem;\n\n    /* if no zone, just do a free */\n    if (zone == NULL) {\n        free(ptr);\n        return;\n    }\n\n    /* point next to the item that matches ptr, or NULL if not found -- remove\n       the item from the linked list if found */\n    next = zone->first;\n    if (next) {\n        if (next->ptr == ptr)\n            zone->first = next->next;   /* first one is it, remove from list */\n        else {\n            do {                        /* search the linked list */\n                item = next;\n                next = item->next;\n            } while (next != NULL && next->ptr != ptr);\n            if (next) {                 /* if found, remove from linked list */\n                item->next = next->next;\n                zone->notlifo++;        /* not a LIFO free */\n            }\n\n        }\n    }\n\n    /* if found, update the statistics and free the item */\n    if (next) {\n        zone->total -= next->size;\n        free(next);\n    }\n\n    /* if not found, update the rogue count */\n    else\n        zone->rogue++;\n\n    /* in any case, do the requested free with the standard library function */\n    free(ptr);\n}",
          "fn_code_pos": [
            [
              111,
              0
            ],
            [
              153,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mem_free",
            "parameters": {
              "mem": "void",
              "ptr": "void"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void mem_setup(z_stream *strm)\n{\n    struct mem_zone *zone;\n\n    zone = malloc(sizeof(struct mem_zone));\n    assert(zone != NULL);\n    zone->first = NULL;\n    zone->total = 0;\n    zone->highwater = 0;\n    zone->limit = 0;\n    zone->notlifo = 0;\n    zone->rogue = 0;\n    strm->opaque = zone;\n    strm->zalloc = mem_alloc;\n    strm->zfree = mem_free;\n}",
          "fn_code_pos": [
            [
              157,
              0
            ],
            [
              172,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mem_setup",
            "parameters": {
              "strm": "z_stream"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void mem_limit(z_stream *strm, size_t limit)\n{\n    struct mem_zone *zone = strm->opaque;\n\n    zone->limit = limit;\n}",
          "fn_code_pos": [
            [
              175,
              0
            ],
            [
              180,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mem_limit",
            "parameters": {
              "strm": "z_stream",
              "limit": "size_t"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void mem_used(z_stream *strm, char *prefix)\n{\n    struct mem_zone *zone = strm->opaque;\n\n    fprintf(stderr, \"%s: %zu allocated\\n\", prefix, zone->total);\n}",
          "fn_code_pos": [
            [
              183,
              0
            ],
            [
              188,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mem_used",
            "parameters": {
              "strm": "z_stream",
              "prefix": "char"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void mem_high(z_stream *strm, char *prefix)\n{\n    struct mem_zone *zone = strm->opaque;\n\n    fprintf(stderr, \"%s: %zu high water mark\\n\", prefix, zone->highwater);\n}",
          "fn_code_pos": [
            [
              191,
              0
            ],
            [
              196,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mem_high",
            "parameters": {
              "strm": "z_stream",
              "prefix": "char"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void mem_done(z_stream *strm, char *prefix)\n{\n    int count = 0;\n    struct mem_item *item, *next;\n    struct mem_zone *zone = strm->opaque;\n\n    /* show high water mark */\n    mem_high(strm, prefix);\n\n    /* free leftover allocations and item structures, if any */\n    item = zone->first;\n    while (item != NULL) {\n        free(item->ptr);\n        next = item->next;\n        free(item);\n        item = next;\n        count++;\n    }\n\n    /* issue alerts about anything unexpected */\n    if (count || zone->total)\n        fprintf(stderr, \"** %s: %zu bytes in %d blocks not freed\\n\",\n                prefix, zone->total, count);\n    if (zone->notlifo)\n        fprintf(stderr, \"** %s: %d frees not LIFO\\n\", prefix, zone->notlifo);\n    if (zone->rogue)\n        fprintf(stderr, \"** %s: %d frees not recognized\\n\",\n                prefix, zone->rogue);\n\n    /* free the zone and delete from the stream */\n    free(zone);\n    strm->opaque = Z_NULL;\n    strm->zalloc = Z_NULL;\n    strm->zfree = Z_NULL;\n}",
          "fn_code_pos": [
            [
              199,
              0
            ],
            [
              233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mem_done",
            "parameters": {
              "strm": "z_stream",
              "prefix": "char"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local unsigned char *h2b(const char *hex, unsigned *len)\n{\n    unsigned char *in, *re;\n    unsigned next, val;\n\n    in = malloc((strlen(hex) + 1) >> 1);\n    if (in == NULL)\n        return NULL;\n    next = 0;\n    val = 1;\n    do {\n        if (*hex >= '0' && *hex <= '9')\n            val = (val << 4) + *hex - '0';\n        else if (*hex >= 'A' && *hex <= 'F')\n            val = (val << 4) + *hex - 'A' + 10;\n        else if (*hex >= 'a' && *hex <= 'f')\n            val = (val << 4) + *hex - 'a' + 10;\n        else if (val != 1 && val < 32)  /* one digit followed by delimiter */\n            val += 240;                 /* make it look like two digits */\n        if (val > 255) {                /* have two digits */\n            in[next++] = val & 0xff;    /* save the decoded byte */\n            val = 1;                    /* start over */\n        }\n    } while (*hex++);       /* go through the loop with the terminating null */\n    if (len != NULL)\n        *len = next;\n    re = realloc(in, next);\n    return re == NULL ? in : re;\n}",
          "fn_code_pos": [
            [
              244,
              0
            ],
            [
              272,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "h2b",
            "parameters": {
              "hex": "char",
              "len": "unsigned"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "local void inf(char *hex, char *what, unsigned step, int win, unsigned len,\n               int err)\n{\n    int ret;\n    unsigned have;\n    unsigned char *in, *out;\n    z_stream strm, copy;\n    gz_header head;\n\n    mem_setup(&strm);\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit2(&strm, win);\n    if (ret != Z_OK) {\n        mem_done(&strm, what);\n        return;\n    }\n    out = malloc(len);                          assert(out != NULL);\n    if (win == 47) {\n        head.extra = out;\n        head.extra_max = len;\n        head.name = out;\n        head.name_max = len;\n        head.comment = out;\n        head.comm_max = len;\n        ret = inflateGetHeader(&strm, &head);   assert(ret == Z_OK);\n    }\n    in = h2b(hex, &have);                       assert(in != NULL);\n    if (step == 0 || step > have)\n        step = have;\n    strm.avail_in = step;\n    have -= step;\n    strm.next_in = in;\n    do {\n        strm.avail_out = len;\n        strm.next_out = out;\n        ret = inflate(&strm, Z_NO_FLUSH);       assert(err == 9 || ret == err);\n        if (ret != Z_OK && ret != Z_BUF_ERROR && ret != Z_NEED_DICT)\n            break;\n        if (ret == Z_NEED_DICT) {\n            ret = inflateSetDictionary(&strm, in, 1);\n                                                assert(ret == Z_DATA_ERROR);\n            mem_limit(&strm, 1);\n            ret = inflateSetDictionary(&strm, out, 0);\n                                                assert(ret == Z_MEM_ERROR);\n            mem_limit(&strm, 0);\n            ((struct inflate_state *)strm.state)->mode = DICT;\n            ret = inflateSetDictionary(&strm, out, 0);\n                                                assert(ret == Z_OK);\n            ret = inflate(&strm, Z_NO_FLUSH);   assert(ret == Z_BUF_ERROR);\n        }\n        ret = inflateCopy(&copy, &strm);        assert(ret == Z_OK);\n        ret = inflateEnd(&copy);                assert(ret == Z_OK);\n        err = 9;                        /* don't care next time around */\n        have += strm.avail_in;\n        strm.avail_in = step > have ? have : step;\n        have -= strm.avail_in;\n    } while (strm.avail_in);\n    free(in);\n    free(out);\n    ret = inflateReset2(&strm, -8);             assert(ret == Z_OK);\n    ret = inflateEnd(&strm);                    assert(ret == Z_OK);\n    mem_done(&strm, what);\n}",
          "fn_code_pos": [
            [
              283,
              0
            ],
            [
              346,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "inf",
            "parameters": {
              "hex": "char",
              "what": "char",
              "step": "unsigned",
              "win": "int",
              "len": "unsigned",
              "err": "int"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void cover_support(void)\n{\n    int ret;\n    z_stream strm;\n\n    mem_setup(&strm);\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit(&strm);                   assert(ret == Z_OK);\n    mem_used(&strm, \"inflate init\");\n    ret = inflatePrime(&strm, 5, 31);           assert(ret == Z_OK);\n    ret = inflatePrime(&strm, -1, 0);           assert(ret == Z_OK);\n    ret = inflateSetDictionary(&strm, Z_NULL, 0);\n                                                assert(ret == Z_STREAM_ERROR);\n    ret = inflateEnd(&strm);                    assert(ret == Z_OK);\n    mem_done(&strm, \"prime\");\n\n    inf(\"63 0\", \"force window allocation\", 0, -15, 1, Z_OK);\n    inf(\"63 18 5\", \"force window replacement\", 0, -8, 259, Z_OK);\n    inf(\"63 18 68 30 d0 0 0\", \"force split window update\", 4, -8, 259, Z_OK);\n    inf(\"3 0\", \"use fixed blocks\", 0, -15, 1, Z_STREAM_END);\n    inf(\"\", \"bad window size\", 0, 1, 0, Z_STREAM_ERROR);\n\n    mem_setup(&strm);\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit_(&strm, \"!\", (int)sizeof(z_stream));\n                                                assert(ret == Z_VERSION_ERROR);\n    mem_done(&strm, \"wrong version\");\n\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit(&strm);                   assert(ret == Z_OK);\n    ret = inflateEnd(&strm);                    assert(ret == Z_OK);\n    fputs(\"inflate built-in memory routines\\n\", stderr);\n}",
          "fn_code_pos": [
            [
              349,
              0
            ],
            [
              384,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cover_support",
            "parameters": {},
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void cover_wrap(void)\n{\n    int ret;\n    z_stream strm, copy;\n    unsigned char dict[257];\n\n    ret = inflate(Z_NULL, 0);                   assert(ret == Z_STREAM_ERROR);\n    ret = inflateEnd(Z_NULL);                   assert(ret == Z_STREAM_ERROR);\n    ret = inflateCopy(Z_NULL, Z_NULL);          assert(ret == Z_STREAM_ERROR);\n    fputs(\"inflate bad parameters\\n\", stderr);\n\n    inf(\"1f 8b 0 0\", \"bad gzip method\", 0, 31, 0, Z_DATA_ERROR);\n    inf(\"1f 8b 8 80\", \"bad gzip flags\", 0, 31, 0, Z_DATA_ERROR);\n    inf(\"77 85\", \"bad zlib method\", 0, 15, 0, Z_DATA_ERROR);\n    inf(\"8 99\", \"set window size from header\", 0, 0, 0, Z_OK);\n    inf(\"78 9c\", \"bad zlib window size\", 0, 8, 0, Z_DATA_ERROR);\n    inf(\"78 9c 63 0 0 0 1 0 1\", \"check adler32\", 0, 15, 1, Z_STREAM_END);\n    inf(\"1f 8b 8 1e 0 0 0 0 0 0 1 0 0 0 0 0 0\", \"bad header crc\", 0, 47, 1,\n        Z_DATA_ERROR);\n    inf(\"1f 8b 8 2 0 0 0 0 0 0 1d 26 3 0 0 0 0 0 0 0 0 0\", \"check gzip length\",\n        0, 47, 0, Z_STREAM_END);\n    inf(\"78 90\", \"bad zlib header check\", 0, 47, 0, Z_DATA_ERROR);\n    inf(\"8 b8 0 0 0 1\", \"need dictionary\", 0, 8, 0, Z_NEED_DICT);\n    inf(\"78 9c 63 0\", \"compute adler32\", 0, 15, 1, Z_OK);\n\n    mem_setup(&strm);\n    strm.avail_in = 0;\n    strm.next_in = Z_NULL;\n    ret = inflateInit2(&strm, -8);\n    strm.avail_in = 2;\n    strm.next_in = (void *)\"\\x63\";\n    strm.avail_out = 1;\n    strm.next_out = (void *)&ret;\n    mem_limit(&strm, 1);\n    ret = inflate(&strm, Z_NO_FLUSH);           assert(ret == Z_MEM_ERROR);\n    ret = inflate(&strm, Z_NO_FLUSH);           assert(ret == Z_MEM_ERROR);\n    mem_limit(&strm, 0);\n    memset(dict, 0, 257);\n    ret = inflateSetDictionary(&strm, dict, 257);\n                                                assert(ret == Z_OK);\n    mem_limit(&strm, (sizeof(struct inflate_state) << 1) + 256);\n    ret = inflatePrime(&strm, 16, 0);           assert(ret == Z_OK);\n    strm.avail_in = 2;\n    strm.next_in = (void *)\"\\x80\";\n    ret = inflateSync(&strm);                   assert(ret == Z_DATA_ERROR);\n    ret = inflate(&strm, Z_NO_FLUSH);           assert(ret == Z_STREAM_ERROR);\n    strm.avail_in = 4;\n    strm.next_in = (void *)\"\\0\\0\\xff\\xff\";\n    ret = inflateSync(&strm);                   assert(ret == Z_OK);\n    (void)inflateSyncPoint(&strm);\n    ret = inflateCopy(&copy, &strm);            assert(ret == Z_MEM_ERROR);\n    mem_limit(&strm, 0);\n    ret = inflateUndermine(&strm, 1);           assert(ret == Z_DATA_ERROR);\n    (void)inflateMark(&strm);\n    ret = inflateEnd(&strm);                    assert(ret == Z_OK);\n    mem_done(&strm, \"miscellaneous, force memory errors\");\n}",
          "fn_code_pos": [
            [
              387,
              0
            ],
            [
              443,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cover_wrap",
            "parameters": {},
            "return_type": "local"
          }
        },
        {
          "fn_code": "local unsigned pull(void *desc, unsigned char z_const **buf)\n{\n    static unsigned int next = 0;\n    static unsigned char dat[] = {0x63, 0, 2, 0};\n    struct inflate_state *state;\n\n    if (desc == Z_NULL) {\n        next = 0;\n        return 0;   /* no input (already provided at next_in) */\n    }\n    state = (void *)((z_stream *)desc)->state;\n    if (state != Z_NULL)\n        state->mode = SYNC;     /* force an otherwise impossible situation */\n    return next < sizeof(dat) ? (*buf = dat + next++, 1) : 0;\n}",
          "fn_code_pos": [
            [
              446,
              0
            ],
            [
              460,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pull",
            "parameters": {
              "desc": "void",
              "z_const": "unsigned char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "local int push(void *desc, unsigned char *buf, unsigned len)\n{\n    (void)buf;\n    (void)len;\n    return desc != Z_NULL;      /* force error if desc not null */\n}",
          "fn_code_pos": [
            [
              462,
              0
            ],
            [
              467,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "push",
            "parameters": {
              "desc": "void",
              "buf": "unsigned char",
              "len": "unsigned"
            },
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void cover_back(void)\n{\n    int ret;\n    z_stream strm;\n    unsigned char win[32768];\n\n    ret = inflateBackInit_(Z_NULL, 0, win, 0, 0);\n                                                assert(ret == Z_VERSION_ERROR);\n    ret = inflateBackInit(Z_NULL, 0, win);      assert(ret == Z_STREAM_ERROR);\n    ret = inflateBack(Z_NULL, Z_NULL, Z_NULL, Z_NULL, Z_NULL);\n                                                assert(ret == Z_STREAM_ERROR);\n    ret = inflateBackEnd(Z_NULL);               assert(ret == Z_STREAM_ERROR);\n    fputs(\"inflateBack bad parameters\\n\", stderr);\n\n    mem_setup(&strm);\n    ret = inflateBackInit(&strm, 15, win);      assert(ret == Z_OK);\n    strm.avail_in = 2;\n    strm.next_in = (void *)\"\\x03\";\n    ret = inflateBack(&strm, pull, Z_NULL, push, Z_NULL);\n                                                assert(ret == Z_STREAM_END);\n        /* force output error */\n    strm.avail_in = 3;\n    strm.next_in = (void *)\"\\x63\\x00\";\n    ret = inflateBack(&strm, pull, Z_NULL, push, &strm);\n                                                assert(ret == Z_BUF_ERROR);\n        /* force mode error by mucking with state */\n    ret = inflateBack(&strm, pull, &strm, push, Z_NULL);\n                                                assert(ret == Z_STREAM_ERROR);\n    ret = inflateBackEnd(&strm);                assert(ret == Z_OK);\n    mem_done(&strm, \"inflateBack bad state\");\n\n    ret = inflateBackInit(&strm, 15, win);      assert(ret == Z_OK);\n    ret = inflateBackEnd(&strm);                assert(ret == Z_OK);\n    fputs(\"inflateBack built-in memory routines\\n\", stderr);\n}",
          "fn_code_pos": [
            [
              470,
              0
            ],
            [
              504,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cover_back",
            "parameters": {},
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void cover_inflate(void)\n{\n    try(\"0 0 0 0 0\", \"invalid stored block lengths\", 1);\n    try(\"3 0\", \"fixed\", 0);\n    try(\"6\", \"invalid block type\", 1);\n    try(\"1 1 0 fe ff 0\", \"stored\", 0);\n    try(\"fc 0 0\", \"too many length or distance symbols\", 1);\n    try(\"4 0 fe ff\", \"invalid code lengths set\", 1);\n    try(\"4 0 24 49 0\", \"invalid bit length repeat\", 1);\n    try(\"4 0 24 e9 ff ff\", \"invalid bit length repeat\", 1);\n    try(\"4 0 24 e9 ff 6d\", \"invalid code -- missing end-of-block\", 1);\n    try(\"4 80 49 92 24 49 92 24 71 ff ff 93 11 0\",\n        \"invalid literal/lengths set\", 1);\n    try(\"4 80 49 92 24 49 92 24 f b4 ff ff c3 84\", \"invalid distances set\", 1);\n    try(\"4 c0 81 8 0 0 0 0 20 7f eb b 0 0\", \"invalid literal/length code\", 1);\n    try(\"2 7e ff ff\", \"invalid distance code\", 1);\n    try(\"c c0 81 0 0 0 0 0 90 ff 6b 4 0\", \"invalid distance too far back\", 1);\n\n    /* also trailer mismatch just in inflate() */\n    try(\"1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 1\", \"incorrect data check\", -1);\n    try(\"1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 1\",\n        \"incorrect length check\", -1);\n    try(\"5 c0 21 d 0 0 0 80 b0 fe 6d 2f 91 6c\", \"pull 17\", 0);\n    try(\"5 e0 81 91 24 cb b2 2c 49 e2 f 2e 8b 9a 47 56 9f fb fe ec d2 ff 1f\",\n        \"long code\", 0);\n    try(\"ed c0 1 1 0 0 0 40 20 ff 57 1b 42 2c 4f\", \"length extra\", 0);\n    try(\"ed cf c1 b1 2c 47 10 c4 30 fa 6f 35 1d 1 82 59 3d fb be 2e 2a fc f c\",\n        \"long distance and extra\", 0);\n    try(\"ed c0 81 0 0 0 0 80 a0 fd a9 17 a9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \"\n        \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6\", \"window end\", 0);\n    inf(\"2 8 20 80 0 3 0\", \"inflate_fast TYPE return\", 0, -15, 258,\n        Z_STREAM_END);\n    inf(\"63 18 5 40 c 0\", \"window wrap\", 3, -8, 300, Z_OK);\n}",
          "fn_code_pos": [
            [
              581,
              0
            ],
            [
              614,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cover_inflate",
            "parameters": {},
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void cover_trees(void)\n{\n    int ret;\n    unsigned bits;\n    unsigned short lens[16], work[16];\n    code *next, table[ENOUGH_DISTS];\n\n    /* we need to call inflate_table() directly in order to manifest not-\n       enough errors, since zlib insures that enough is always enough */\n    for (bits = 0; bits < 15; bits++)\n        lens[bits] = (unsigned short)(bits + 1);\n    lens[15] = 15;\n    next = table;\n    bits = 15;\n    ret = inflate_table(DISTS, lens, 16, &next, &bits, work);\n                                                assert(ret == 1);\n    next = table;\n    bits = 1;\n    ret = inflate_table(DISTS, lens, 16, &next, &bits, work);\n                                                assert(ret == 1);\n    fputs(\"inflate_table not enough errors\\n\", stderr);\n}",
          "fn_code_pos": [
            [
              617,
              0
            ],
            [
              638,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cover_trees",
            "parameters": {},
            "return_type": "local"
          }
        },
        {
          "fn_code": "local void cover_fast(void)\n{\n    inf(\"e5 e0 81 ad 6d cb b2 2c c9 01 1e 59 63 ae 7d ee fb 4d fd b5 35 41 68\"\n        \" ff 7f 0f 0 0 0\", \"fast length extra bits\", 0, -8, 258, Z_DATA_ERROR);\n    inf(\"25 fd 81 b5 6d 59 b6 6a 49 ea af 35 6 34 eb 8c b9 f6 b9 1e ef 67 49\"\n        \" 50 fe ff ff 3f 0 0\", \"fast distance extra bits\", 0, -8, 258,\n        Z_DATA_ERROR);\n    inf(\"3 7e 0 0 0 0 0\", \"fast invalid distance code\", 0, -8, 258,\n        Z_DATA_ERROR);\n    inf(\"1b 7 0 0 0 0 0\", \"fast invalid literal/length code\", 0, -8, 258,\n        Z_DATA_ERROR);\n    inf(\"d c7 1 ae eb 38 c 4 41 a0 87 72 de df fb 1f b8 36 b1 38 5d ff ff 0\",\n        \"fast 2nd level codes and too far back\", 0, -8, 258, Z_DATA_ERROR);\n    inf(\"63 18 5 8c 10 8 0 0 0 0\", \"very common case\", 0, -8, 259, Z_OK);\n    inf(\"63 60 60 18 c9 0 8 18 18 18 26 c0 28 0 29 0 0 0\",\n        \"contiguous and wrap around window\", 6, -8, 259, Z_OK);\n    inf(\"63 0 3 0 0 0 0 0\", \"copy direct from output\", 0, -8, 259,\n        Z_STREAM_END);\n}",
          "fn_code_pos": [
            [
              641,
              0
            ],
            [
              659,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cover_fast",
            "parameters": {},
            "return_type": "local"
          }
        },
        {
          "fn_code": "int main(void)\n{\n    fprintf(stderr, \"%s\\n\", zlibVersion());\n    cover_support();\n    cover_wrap();\n    cover_back();\n    cover_inflate();\n    cover_trees();\n    cover_fast();\n    return 0;\n}",
          "fn_code_pos": [
            [
              661,
              0
            ],
            [
              671,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "mem_alloc(void *mem, unsigned count, unsigned size)",
          "fn_dec_pos": [
            [
              70,
              12
            ],
            [
              70,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mem_alloc",
            "parameters": {
              "mem": "void",
              "count": "unsigned",
              "size": "unsigned"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "h2b(const char *hex, unsigned *len)",
          "fn_dec_pos": [
            [
              244,
              21
            ],
            [
              244,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "h2b",
            "parameters": {
              "hex": "char",
              "len": "unsigned"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct mem_item {\n    void *ptr;                  /* pointer to allocated memory */\n    size_t size;                /* requested size of allocation */\n    struct mem_item *next;      /* pointer to next item in list, or NULL */\n}",
          {
            "*ptr": "void",
            "size": "size_t",
            "*next": "struct mem_item"
          },
          "mem_item",
          [
            55,
            0
          ],
          [
            59,
            1
          ]
        ],
        [
          "struct mem_zone {\n    struct mem_item *first;     /* pointer to first item in list, or NULL */\n    size_t total, highwater;    /* total allocations, and largest total */\n    size_t limit;               /* memory allocation limit, or 0 if no limit */\n    int notlifo, rogue;         /* counts of non-LIFO frees and rogue frees */\n}",
          {
            "*first": "struct mem_item",
            "total": "size_t",
            "limit": "size_t",
            "notlifo": "int"
          },
          "mem_zone",
          [
            62,
            0
          ],
          [
            67,
            1
          ]
        ],
        [
          "struct mem_item {\n    void *ptr;                  /* pointer to allocated memory */\n    size_t size;                /* requested size of allocation */\n    struct mem_item *next;      /* pointer to next item in list, or NULL */\n}",
          {
            "*ptr": "void",
            "size": "size_t",
            "*next": "struct mem_item"
          },
          "mem_item",
          [
            55,
            0
          ],
          [
            59,
            1
          ]
        ],
        [
          "struct mem_item",
          {},
          "",
          [
            58,
            4
          ],
          [
            58,
            19
          ]
        ],
        [
          "struct mem_zone {\n    struct mem_item *first;     /* pointer to first item in list, or NULL */\n    size_t total, highwater;    /* total allocations, and largest total */\n    size_t limit;               /* memory allocation limit, or 0 if no limit */\n    int notlifo, rogue;         /* counts of non-LIFO frees and rogue frees */\n}",
          {
            "*first": "struct mem_item",
            "total": "size_t",
            "limit": "size_t",
            "notlifo": "int"
          },
          "mem_zone",
          [
            62,
            0
          ],
          [
            67,
            1
          ]
        ],
        [
          "struct mem_item",
          {},
          "",
          [
            63,
            4
          ],
          [
            63,
            19
          ]
        ],
        [
          "struct mem_item",
          {},
          "",
          [
            73,
            4
          ],
          [
            73,
            19
          ]
        ],
        [
          "struct mem_zone",
          {},
          "",
          [
            74,
            4
          ],
          [
            74,
            19
          ]
        ],
        [
          "struct mem_item",
          {},
          "",
          [
            89,
            25
          ],
          [
            89,
            40
          ]
        ],
        [
          "struct mem_item",
          {},
          "",
          [
            113,
            4
          ],
          [
            113,
            19
          ]
        ],
        [
          "struct mem_zone",
          {},
          "",
          [
            114,
            4
          ],
          [
            114,
            19
          ]
        ],
        [
          "struct mem_zone",
          {},
          "",
          [
            159,
            4
          ],
          [
            159,
            19
          ]
        ],
        [
          "struct mem_zone",
          {},
          "",
          [
            161,
            25
          ],
          [
            161,
            40
          ]
        ],
        [
          "struct mem_zone",
          {},
          "",
          [
            177,
            4
          ],
          [
            177,
            19
          ]
        ],
        [
          "struct mem_zone",
          {},
          "",
          [
            185,
            4
          ],
          [
            185,
            19
          ]
        ],
        [
          "struct mem_zone",
          {},
          "",
          [
            193,
            4
          ],
          [
            193,
            19
          ]
        ],
        [
          "struct mem_item",
          {},
          "",
          [
            202,
            4
          ],
          [
            202,
            19
          ]
        ],
        [
          "struct mem_zone",
          {},
          "",
          [
            203,
            4
          ],
          [
            203,
            19
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            329,
            14
          ],
          [
            329,
            34
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            427,
            29
          ],
          [
            427,
            49
          ]
        ],
        [
          "struct inflate_state",
          {},
          "",
          [
            450,
            4
          ],
          [
            450,
            24
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            7,
            0
          ],
          [
            8,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            8,
            0
          ],
          [
            9,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#include \"inftrees.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ],
        [
          "#include \"inflate.h\"\n",
          [
            17,
            0
          ],
          [
            18,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    }
  },
  "head": {}
}