{
  "src": {
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_wince.c": {
      "fn_def_list": [
        {
          "fn_code": "assistance you may require and contribute the results\n\n\n/*\n * Open a TIFF file for read/writing.\n */\nTIFF*\nTIFFOpen(const char* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpen\";\n\tthandle_t fd;\n\tint m;\n\tDWORD dwMode;\n\tTIFF* tif;\n    size_t nLen;\n    size_t nWideLen;\n    wchar_t* wchName;\n\n\tm = _TIFFgetMode(mode, module);\n\n\tswitch(m)\n\t{\n\tcase O_RDONLY:\n\t\tdwMode = OPEN_EXISTING;\n\t\tbreak;\n\tcase O_RDWR:\n\t\tdwMode = OPEN_ALWAYS;\n\t\tbreak;\n\tcase O_RDWR|O_CREAT:\n\t\tdwMode = OPEN_ALWAYS;\n\t\tbreak;\n\tcase O_RDWR|O_TRUNC:\n\t\tdwMode = CREATE_ALWAYS;\n\t\tbreak;\n\tcase O_RDWR|O_CREAT|O_TRUNC:\n\t\tdwMode = CREATE_ALWAYS;\n\t\tbreak;\n\tdefault:\n\t\treturn ((TIFF*)0);\n\t}\n\n    /* On Windows CE, CreateFile is mapped to CreateFileW,\n     * but file path is passed as char-based string,\n     * so the path has to be converted to wchar_t.\n     */\n\n    nWideLen = 0;\n    wchName = NULL;\n    nLen = strlen(name) + 1;\n    \n    nWideLen = MultiByteToWideChar(CP_ACP, 0, name, nLen, NULL, 0);\n    wchName = (wchar_t*)malloc(sizeof(wchar_t) * nWideLen);\n    if (NULL == wchName)\n    {\n        TIFFErrorExt(0, module, \"Memory allocation error!\");\n\t\treturn ((TIFF *)0);\n    }\n    memset(wchName, 0, sizeof(wchar_t) * nWideLen);\n    MultiByteToWideChar(CP_ACP, 0, name, nLen, wchName, nWideLen);\n\n\tfd = (thandle_t)CreateFile(wchName,\n\t\t(m == O_RDONLY)?GENERIC_READ:(GENERIC_READ | GENERIC_WRITE),\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, dwMode,\n\t\t(m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL,\n\t\tNULL);\n\n    free(wchName);\n\n    if (fd == INVALID_HANDLE_VALUE) {\n\t\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\n\t\treturn ((TIFF *)0);\n\t}\n\n    /* TODO - mloskot: change to TIFFdOpenW and pass wchar path */\n\n\ttif = TIFFFdOpen((int)fd, name, mode);\n\tif(!tif)\n\t\tCloseHandle(fd);\n\treturn tif;\n}",
          "fn_code_pos": [
            [
              39,
              8
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFOpen",
            "parameters": {
              "name": "char",
              "mode": "char"
            },
            "return_type": "assistance"
          }
        },
        {
          "fn_code": "TIFF*\nTIFFOpenW(const wchar_t* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpenW\";\n\tthandle_t fd;\n\tint m;\n\tDWORD dwMode;\n\tint mbsize;\n\tchar *mbname;\n\tTIFF *tif;\n\n\tm = _TIFFgetMode(mode, module);\n\n\tswitch(m) {\n\t\tcase O_RDONLY:\t\t\tdwMode = OPEN_EXISTING; break;\n\t\tcase O_RDWR:\t\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_CREAT:\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_TRUNC:\t\tdwMode = CREATE_ALWAYS; break;\n\t\tcase O_RDWR|O_CREAT|O_TRUNC:\tdwMode = CREATE_ALWAYS; break;\n\t\tdefault:\t\t\treturn ((TIFF*)0);\n\t}\n\n    /* On Windows CE, CreateFile is mapped to CreateFileW,\n     * so no conversion of wchar_t to char is required.\n     */\n\n\tfd = (thandle_t)CreateFile(name,\n\t\t(m == O_RDONLY)?GENERIC_READ:(GENERIC_READ|GENERIC_WRITE),\n\t\tFILE_SHARE_READ, NULL, dwMode,\n\t\t(m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL,\n\t\tNULL);\n\tif (fd == INVALID_HANDLE_VALUE) {\n\t\tTIFFErrorExt(0, module, \"%S: Cannot open\", name);\n\t\treturn ((TIFF *)0);\n\t}\n\n\tmbname = NULL;\n\tmbsize = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL);\n\tif (mbsize > 0) {\n\t\tmbname = (char *)_TIFFmalloc(mbsize);\n\t\tif (!mbname) {\n\t\t\tTIFFErrorExt(0, module,\n\t\t\t\"Can't allocate space for filename conversion buffer\");\n\t\t\treturn ((TIFF*)0);\n\t\t}\n\n\t\tWideCharToMultiByte(CP_ACP, 0, name, -1, mbname, mbsize,\n\t\t\t\t    NULL, NULL);\n\t}\n\n\ttif = TIFFFdOpen((int)fd,\n\t\t\t (mbname != NULL) ? mbname : \"<unknown>\", mode);\n\tif(!tif)\n\t\tCloseHandle(fd);\n\n\t_TIFFfree(mbname);\n\n\treturn tif;\n}",
          "fn_code_pos": [
            [
              123,
              0
            ],
            [
              181,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFOpenW",
            "parameters": {
              "name": "wchar_t",
              "mode": "char"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "static void\nWin32WarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    /* On Windows CE, MessageBox is mapped to wide-char based MessageBoxW. */\n\n    size_t nWideLen = 0;\n    LPTSTR szWideTitle = NULL;\n    LPTSTR szWideMsg = NULL;\n\n\tLPSTR szTitle;\n\tLPSTR szTmp;\n\tLPCSTR szTitleText = \"%s Warning\";\n\tLPCSTR szDefaultModule = \"LIBTIFF\";\n\tLPCSTR szTmpModule;\n\n\tszTmpModule = (module == NULL) ? szDefaultModule : module;\n\tif ((szTitle = (LPSTR)LocalAlloc(LMEM_FIXED,\n        (strlen(szTmpModule) + strlen(szTitleText)\n        + strlen(fmt) + 128) * sizeof(char))) == NULL)\n\t\treturn;\n\n\tsprintf(szTitle, szTitleText, szTmpModule);\n\tszTmp = szTitle + (strlen(szTitle) + 2) * sizeof(char);\n\tvsprintf(szTmp, fmt, ap);\n\n    /* Convert error message to Unicode. */\n\n    nWideLen = MultiByteToWideChar(CP_ACP, 0, szTitle, -1, NULL, 0);\n    szWideTitle = (wchar_t*)malloc(sizeof(wchar_t) * nWideLen);\n    MultiByteToWideChar(CP_ACP, 0, szTitle, -1, szWideTitle, nWideLen);\n\n    nWideLen = MultiByteToWideChar(CP_ACP, 0, szTmp, -1, NULL, 0);\n    szWideMsg = (wchar_t*)malloc(sizeof(wchar_t) * nWideLen);\n    MultiByteToWideChar(CP_ACP, 0, szTmp, -1, szWideMsg, nWideLen);\n\n    /* Display message */\n\t\n    MessageBox(GetFocus(), szWideMsg, szWideTitle, MB_OK | MB_ICONEXCLAMATION);\n    \n    /* Free resources */\n\n    LocalFree(szTitle);\n    free(szWideMsg);\n    free(szWideTitle);\n}",
          "fn_code_pos": [
            [
              183,
              0
            ],
            [
              227,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Win32WarningHandler",
            "parameters": {
              "module": "char",
              "fmt": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nWin32ErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    /* On Windows CE, MessageBox is mapped to wide-char based MessageBoxW. */\n\n    size_t nWideLen = 0;\n    LPTSTR szWideTitle = NULL;\n    LPTSTR szWideMsg = NULL;\n\n    LPSTR szTitle;\n\tLPSTR szTmp;\n\tLPCSTR szTitleText = \"%s Error\";\n\tLPCSTR szDefaultModule = \"LIBTIFF\";\n\tLPCSTR szTmpModule;\n\n\tszTmpModule = (module == NULL) ? szDefaultModule : module;\n\tif ((szTitle = (LPSTR)LocalAlloc(LMEM_FIXED,\n        (strlen(szTmpModule) + strlen(szTitleText)\n        + strlen(fmt) + 128) * sizeof(char))) == NULL)\n\t\treturn;\n\n\tsprintf(szTitle, szTitleText, szTmpModule);\n\tszTmp = szTitle + (strlen(szTitle) + 2) * sizeof(char);\n\tvsprintf(szTmp, fmt, ap);\n\n    /* Convert error message to Unicode. */\n\n    nWideLen = MultiByteToWideChar(CP_ACP, 0, szTitle, -1, NULL, 0);\n    szWideTitle = (wchar_t*)malloc(sizeof(wchar_t) * nWideLen);\n    MultiByteToWideChar(CP_ACP, 0, szTitle, -1, szWideTitle, nWideLen);\n\n    nWideLen = MultiByteToWideChar(CP_ACP, 0, szTmp, -1, NULL, 0);\n    szWideMsg = (wchar_t*)malloc(sizeof(wchar_t) * nWideLen);\n    MultiByteToWideChar(CP_ACP, 0, szTmp, -1, szWideMsg, nWideLen);\n\n    /* Display message */\n\n\tMessageBox(GetFocus(), szWideMsg, szWideTitle, MB_OK | MB_ICONEXCLAMATION);\n\n    /* Free resources */\n\n    LocalFree(szTitle);\n    free(szWideMsg);\n    free(szWideTitle);\n}",
          "fn_code_pos": [
            [
              231,
              0
            ],
            [
              275,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Win32ErrorHandler",
            "parameters": {
              "module": "char",
              "fmt": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFOpen(const char* name, const char* mode)",
          "fn_dec_pos": [
            [
              46,
              0
            ],
            [
              46,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFOpen",
            "parameters": {
              "name": "char",
              "mode": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFOpenW(const wchar_t* name, const char* mode)",
          "fn_dec_pos": [
            [
              124,
              0
            ],
            [
              124,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFOpenW",
            "parameters": {
              "name": "wchar_t",
              "mode": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <windows.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_webp.c": {
      "fn_def_list": [
        {
          "fn_code": "static\nint TWebPDatasetWriter(const uint8_t* data, size_t data_size,\n                      const WebPPicture* const picture)\n{\n  static const char module[] = \"TWebPDatasetWriter\";\n  TIFF* tif = (TIFF*)(picture->custom_ptr);\n  \n  if ( (tif->tif_rawcc + (tmsize_t)data_size) > tif->tif_rawdatasize ) {\n    TIFFErrorExt(tif->tif_clientdata, module,\n                 \"Buffer too small by \" TIFF_SIZE_FORMAT \" bytes.\",\n                 (size_t) (tif->tif_rawcc + data_size - tif->tif_rawdatasize));\n    return 0;\n  } else {\n    _TIFFmemcpy(tif->tif_rawcp, data, data_size);\n    tif->tif_rawcc += data_size;\n    tif->tif_rawcp += data_size;\n    return 1;    \n  }\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              90,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TWebPDatasetWriter",
            "parameters": {
              "data": "uint8_t",
              "data_size": "size_t",
              "picture": "WebPPicture"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTWebPEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n  static const char module[] = \"TWebPEncode\";\n  WebPState *sp = EncoderState(tif);\n  (void) s;\n\n  assert(sp != NULL);\n  assert(sp->state == LSTATE_INIT_ENCODE);\n    \n  if( (uint64)sp->buffer_offset +\n                            (uint64)cc > sp->buffer_size )\n  {\n      TIFFErrorExt(tif->tif_clientdata, module,\n                   \"Too many bytes to be written\");\n      return 0;\n  }\n\n  memcpy(sp->pBuffer + sp->buffer_offset,\n         bp, cc);\n  sp->buffer_offset += (unsigned)cc;\n\n  return 1;\n  \n}",
          "fn_code_pos": [
            [
              95,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TWebPEncode",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTWebPDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)\n{\n  static const char module[] = \"WebPDecode\";\n  VP8StatusCode status = VP8_STATUS_OK;\n  WebPState *sp = DecoderState(tif);\n  (void) s;  \n\n  assert(sp != NULL);\n  assert(sp->state == LSTATE_INIT_DECODE);\n  \n  if (occ % sp->sDecBuffer.u.RGBA.stride)\n  {\n    TIFFErrorExt(tif->tif_clientdata, module,\n                 \"Fractional scanlines cannot be read\");\n    return 0;\n  }\n\n  status = WebPIAppend(sp->psDecoder, tif->tif_rawcp, tif->tif_rawcc);\n\n  if (status != VP8_STATUS_OK && status != VP8_STATUS_SUSPENDED) {\n    if (status == VP8_STATUS_INVALID_PARAM) {\n       TIFFErrorExt(tif->tif_clientdata, module,\n         \"Invalid parameter used.\");      \n    } else if (status == VP8_STATUS_OUT_OF_MEMORY) {\n      TIFFErrorExt(tif->tif_clientdata, module,\n        \"Out of memory.\");         \n    } else {\n      TIFFErrorExt(tif->tif_clientdata, module,\n        \"Unrecognized error.\");   \n    }\n    return 0;\n  } else {\n    int current_y, stride;\n    uint8_t* buf;\n\n    /* Returns the RGB/A image decoded so far */\n    buf = WebPIDecGetRGB(sp->psDecoder, &current_y, NULL, NULL, &stride);\n    \n    if ((buf != NULL) &&\n        (occ <= stride * (current_y - sp->last_y))) {\n      memcpy(op,   \n         buf + (sp->last_y * stride),\n         occ);\n\n      tif->tif_rawcp += tif->tif_rawcc;\n      tif->tif_rawcc = 0;\n      sp->last_y += occ / sp->sDecBuffer.u.RGBA.stride;\n      return 1;\n    } else {\n      TIFFErrorExt(tif->tif_clientdata, module, \"Unable to decode WebP data.\"); \n      return 0;\n    }\n  }\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TWebPDecode",
            "parameters": {
              "tif": "TIFF",
              "op": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTWebPFixupTags(TIFF* tif)\n{\n  (void) tif;\n  if (tif->tif_dir.td_planarconfig != PLANARCONFIG_CONTIG) {\n    static const char module[] = \"TWebPFixupTags\";\n    TIFFErrorExt(tif->tif_clientdata, module,\n      \"TIFF WEBP requires data to be stored contiguously in RGB e.g. RGBRGBRGB \"\n#if WEBP_ENCODER_ABI_VERSION >= 0x0100\n      \"or RGBARGBARGBA\"\n#endif\n    );\n    return 0;\n  }\n  return 1;\n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TWebPFixupTags",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTWebPSetupDecode(TIFF* tif)\n{\n  static const char module[] = \"WebPSetupDecode\";\n  uint16 nBitsPerSample = tif->tif_dir.td_bitspersample;\n  uint16 sampleFormat = tif->tif_dir.td_sampleformat;\n\n  WebPState* sp = DecoderState(tif);\n  assert(sp != NULL);\n\n  sp->nSamples = tif->tif_dir.td_samplesperpixel;\n\n  /* check band count */\n  if ( sp->nSamples != 3\n#if WEBP_ENCODER_ABI_VERSION >= 0x0100\n    && sp->nSamples != 4\n#endif\n  )\n  {\n    TIFFErrorExt(tif->tif_clientdata, module,\n      \"WEBP driver doesn't support %d bands. Must be 3 (RGB) \"\n  #if WEBP_ENCODER_ABI_VERSION >= 0x0100\n      \"or 4 (RGBA) \"\n  #endif\n    \"bands.\",\n    sp->nSamples );\n    return 0;\n  }\n\n  /* check bits per sample and data type */\n  if ((nBitsPerSample != 8) && (sampleFormat != 1)) {\n    TIFFErrorExt(tif->tif_clientdata, module,\n                \"WEBP driver requires 8 bit unsigned data\");\n    return 0;\n  }\n  \n  /* if we were last encoding, terminate this mode */\n  if (sp->state & LSTATE_INIT_ENCODE) {\n      WebPPictureFree(&sp->sPicture);\n      if (sp->pBuffer != NULL) {\n        _TIFFfree(sp->pBuffer);\n        sp->pBuffer = NULL;\n      }\n      sp->buffer_offset = 0;\n      sp->state = 0;\n  }\n\n  sp->state |= LSTATE_INIT_DECODE;\n\n  return 1;\n}",
          "fn_code_pos": [
            [
              194,
              0
            ],
            [
              244,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TWebPSetupDecode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTWebPPreDecode(TIFF* tif, uint16 s)\n{\n  static const char module[] = \"TWebPPreDecode\";\n  uint32 segment_width, segment_height;\n  WebPState* sp = DecoderState(tif);\n  TIFFDirectory* td = &tif->tif_dir;\n  (void) s;\n  assert(sp != NULL);\n  \n  if (isTiled(tif)) {\n    segment_width = td->td_tilewidth;\n    segment_height = td->td_tilelength;\n  } else {\n    segment_width = td->td_imagewidth;\n    segment_height = td->td_imagelength - tif->tif_row;\n    if (segment_height > td->td_rowsperstrip)\n      segment_height = td->td_rowsperstrip;\n  }\n\n  if( (sp->state & LSTATE_INIT_DECODE) == 0 )\n      tif->tif_setupdecode(tif);\n      \n  if (sp->psDecoder != NULL) {\n    WebPIDelete(sp->psDecoder);\n    WebPFreeDecBuffer(&sp->sDecBuffer);\n    sp->psDecoder = NULL;\n  }\n\n  sp->last_y = 0;\n  \n  WebPInitDecBuffer(&sp->sDecBuffer);\n  \n  sp->sDecBuffer.is_external_memory = 0;\n  sp->sDecBuffer.width = segment_width;\n  sp->sDecBuffer.height = segment_height;\n  sp->sDecBuffer.u.RGBA.stride = segment_width * sp->nSamples;\n  sp->sDecBuffer.u.RGBA.size = segment_width * sp->nSamples * segment_height;\n  \n  if (sp->nSamples > 3) {\n    sp->sDecBuffer.colorspace = MODE_RGBA;\n  } else {\n    sp->sDecBuffer.colorspace = MODE_RGB;\n  }\n  \n  sp->psDecoder = WebPINewDecoder(&sp->sDecBuffer);\n  \n  if (sp->psDecoder == NULL) {\n    TIFFErrorExt(tif->tif_clientdata, module,\n                \"Unable to allocate WebP decoder.\");\n    return 0;\n  }\n  \n  return 1;\n}",
          "fn_code_pos": [
            [
              249,
              0
            ],
            [
              303,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TWebPPreDecode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTWebPSetupEncode(TIFF* tif)\n{\n  static const char module[] = \"WebPSetupEncode\";\n  uint16 nBitsPerSample = tif->tif_dir.td_bitspersample;\n  uint16 sampleFormat = tif->tif_dir.td_sampleformat;\n  \n  WebPState* sp = EncoderState(tif);\n  assert(sp != NULL);\n\n  sp->nSamples = tif->tif_dir.td_samplesperpixel;\n\n  /* check band count */\n  if ( sp->nSamples != 3\n#if WEBP_ENCODER_ABI_VERSION >= 0x0100\n    && sp->nSamples != 4\n#endif\n  )\n  {\n    TIFFErrorExt(tif->tif_clientdata, module,\n      \"WEBP driver doesn't support %d bands. Must be 3 (RGB) \"\n#if WEBP_ENCODER_ABI_VERSION >= 0x0100\n      \"or 4 (RGBA) \"\n#endif\n    \"bands.\",\n    sp->nSamples );\n    return 0;\n  }\n  \n  /* check bits per sample and data type */\n  if ((nBitsPerSample != 8) && (sampleFormat != 1)) {\n    TIFFErrorExt(tif->tif_clientdata, module,\n                \"WEBP driver requires 8 bit unsigned data\");\n    return 0;\n  }\n  \n  if (sp->state & LSTATE_INIT_DECODE) {\n    WebPIDelete(sp->psDecoder);\n    WebPFreeDecBuffer(&sp->sDecBuffer);\n    sp->psDecoder = NULL;\n    sp->last_y = 0;\n    sp->state = 0;\n  }\n\n  sp->state |= LSTATE_INIT_ENCODE;\n\n  if (!WebPPictureInit(&sp->sPicture)) {\n    TIFFErrorExt(tif->tif_clientdata, module,\n        \"Error initializing WebP picture.\");\n    return 0;\n  }\n\n  if (!WebPConfigInitInternal(&sp->sEncoderConfig, WEBP_PRESET_DEFAULT,\n                              sp->quality_level,\n                              WEBP_ENCODER_ABI_VERSION)) {\n    TIFFErrorExt(tif->tif_clientdata, module,\n      \"Error creating WebP encoder configuration.\");\n    return 0;\n  }\n\n  // WebPConfigInitInternal above sets lossless to false\n  #if WEBP_ENCODER_ABI_VERSION >= 0x0100\n    sp->sEncoderConfig.lossless = sp->lossless;\n    if (sp->lossless) {\n      sp->sPicture.use_argb = 1;\n    }\n  #endif\n\n  if (!WebPValidateConfig(&sp->sEncoderConfig)) {\n    TIFFErrorExt(tif->tif_clientdata, module,\n      \"Error with WebP encoder configuration.\");\n    return 0;\n  }\n\n  return 1;\n}",
          "fn_code_pos": [
            [
              305,
              0
            ],
            [
              380,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TWebPSetupEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTWebPPreEncode(TIFF* tif, uint16 s)\n{\n  static const char module[] = \"TWebPPreEncode\";\n  uint32 segment_width, segment_height;\n  WebPState *sp = EncoderState(tif);\n  TIFFDirectory* td = &tif->tif_dir;\n\n  (void) s;\n\n  assert(sp != NULL);\n  if( sp->state != LSTATE_INIT_ENCODE )\n    tif->tif_setupencode(tif);\n\n  /*\n   * Set encoding parameters for this strip/tile.\n   */\n  if (isTiled(tif)) {\n    segment_width = td->td_tilewidth;\n    segment_height = td->td_tilelength;\n  } else {\n    segment_width = td->td_imagewidth;\n    segment_height = td->td_imagelength - tif->tif_row;\n    if (segment_height > td->td_rowsperstrip)\n      segment_height = td->td_rowsperstrip;\n  }\n\n  if( segment_width > 16383 || segment_height > 16383 ) {\n      TIFFErrorExt(tif->tif_clientdata, module, \n                   \"WEBP maximum image dimensions are 16383 x 16383.\");\n      return 0;\n  }\n\n  /* set up buffer for raw data */\n  /* given above check and that nSamples <= 4, buffer_size is <= 1 GB */\n  sp->buffer_size = segment_width * segment_height * sp->nSamples;\n  \n  if (sp->pBuffer != NULL) {\n      _TIFFfree(sp->pBuffer);\n      sp->pBuffer = NULL;    \n  }\n  \n  sp->pBuffer = _TIFFmalloc(sp->buffer_size);\n  if( !sp->pBuffer) {\n      TIFFErrorExt(tif->tif_clientdata, module, \"Cannot allocate buffer\");\n      return 0;\n  }\n  sp->buffer_offset = 0;\n\n  sp->sPicture.width = segment_width;\n  sp->sPicture.height = segment_height;\n  sp->sPicture.writer = TWebPDatasetWriter;\n  sp->sPicture.custom_ptr = tif;\n\n  return 1;\n}",
          "fn_code_pos": [
            [
              385,
              0
            ],
            [
              440,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TWebPPreEncode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTWebPPostEncode(TIFF* tif)\n{\n  static const char module[] = \"WebPPostEncode\";\n  int64_t stride;\n  WebPState *sp = EncoderState(tif);\n  assert(sp != NULL);\n\n  assert(sp->state == LSTATE_INIT_ENCODE);\n\n  stride = (int64_t)sp->sPicture.width * sp->nSamples;\n\n#if WEBP_ENCODER_ABI_VERSION >= 0x0100\n  if (sp->nSamples == 4) {\n      if (!WebPPictureImportRGBA(&sp->sPicture, sp->pBuffer, (int)stride)) {\n          TIFFErrorExt(tif->tif_clientdata, module,\n                    \"WebPPictureImportRGBA() failed\" );\n          return 0;\n      }\n  }\n  else\n#endif\n  if (!WebPPictureImportRGB(&sp->sPicture, sp->pBuffer, (int)stride)) {\n      TIFFErrorExt(tif->tif_clientdata, module,\n                    \"WebPPictureImportRGB() failed\");\n      return 0;\n  }\n  \n  if (!WebPEncode(&sp->sEncoderConfig, &sp->sPicture)) {\n\n#if WEBP_ENCODER_ABI_VERSION >= 0x0100\n    const char* pszErrorMsg = NULL;\n    switch(sp->sPicture.error_code) {\n    case VP8_ENC_ERROR_OUT_OF_MEMORY:\n        pszErrorMsg = \"Out of memory\"; break;\n    case VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY:\n        pszErrorMsg = \"Out of memory while flushing bits\"; break;\n    case VP8_ENC_ERROR_NULL_PARAMETER:\n        pszErrorMsg = \"A pointer parameter is NULL\"; break;\n    case VP8_ENC_ERROR_INVALID_CONFIGURATION:\n        pszErrorMsg = \"Configuration is invalid\"; break;\n    case VP8_ENC_ERROR_BAD_DIMENSION:\n        pszErrorMsg = \"Picture has invalid width/height\"; break;\n    case VP8_ENC_ERROR_PARTITION0_OVERFLOW:\n        pszErrorMsg = \"Partition is bigger than 512k. Try using less \"\n            \"SEGMENTS, or increase PARTITION_LIMIT value\";\n        break;\n    case VP8_ENC_ERROR_PARTITION_OVERFLOW:\n        pszErrorMsg = \"Partition is bigger than 16M\";\n        break;\n    case VP8_ENC_ERROR_BAD_WRITE:\n        pszErrorMsg = \"Error while fludshing bytes\"; break;\n    case VP8_ENC_ERROR_FILE_TOO_BIG:\n        pszErrorMsg = \"File is bigger than 4G\"; break;\n    case VP8_ENC_ERROR_USER_ABORT:\n        pszErrorMsg = \"User interrupted\";\n        break;\n    default:\n        TIFFErrorExt(tif->tif_clientdata, module,\n                \"WebPEncode returned an unknown error code: %d\",\n                sp->sPicture.error_code);\n        pszErrorMsg = \"Unknown WebP error type.\";\n        break;\n    }\n    TIFFErrorExt(tif->tif_clientdata, module,\n             \"WebPEncode() failed : %s\", pszErrorMsg);\n#else\n    TIFFErrorExt(tif->tif_clientdata, module,\n             \"Error in WebPEncode()\");\n#endif\n    return 0;\n  }\n\n  sp->sPicture.custom_ptr = NULL;\n\n  if (!TIFFFlushData1(tif))\n  {\n    TIFFErrorExt(tif->tif_clientdata, module,\n      \"Error flushing TIFF WebP encoder.\");\n    return 0;\n  }\n\n  return 1;\n}",
          "fn_code_pos": [
            [
              445,
              0
            ],
            [
              528,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TWebPPostEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nTWebPCleanup(TIFF* tif)\n{\n  WebPState* sp = LState(tif);\n\n  assert(sp != 0);\n\n  tif->tif_tagmethods.vgetfield = sp->vgetparent;\n  tif->tif_tagmethods.vsetfield = sp->vsetparent;\n\n  if (sp->state & LSTATE_INIT_ENCODE) {\n    WebPPictureFree(&sp->sPicture);\n  }\n\n  if (sp->psDecoder != NULL) {\n    WebPIDelete(sp->psDecoder);\n    WebPFreeDecBuffer(&sp->sDecBuffer);\n    sp->psDecoder = NULL;\n    sp->last_y = 0;\n  }\n  \n  if (sp->pBuffer != NULL) {\n      _TIFFfree(sp->pBuffer);\n      sp->pBuffer = NULL;    \n  }\n  \n  if (tif->tif_data) {\n    _TIFFfree(tif->tif_data);\n    tif->tif_data = NULL;\n  }\n  \n  _TIFFSetDefaultCompressionState(tif);\n}",
          "fn_code_pos": [
            [
              530,
              0
            ],
            [
              562,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TWebPCleanup",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nTWebPVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tstatic const char module[] = \"WebPVSetField\";\n  WebPState* sp = LState(tif);\n\n  switch (tag) {\n  case TIFFTAG_WEBP_LEVEL:\n    sp->quality_level = (int) va_arg(ap, int);\n    if( sp->quality_level <= 0 ||\n        sp->quality_level > 100.0f ) {\n      TIFFWarningExt(tif->tif_clientdata, module,\n                     \"WEBP_LEVEL should be between 1 and 100\");\n    }\n    return 1;\n  case TIFFTAG_WEBP_LOSSLESS:\n    #if WEBP_ENCODER_ABI_VERSION >= 0x0100\n    sp->lossless = va_arg(ap, int);\n    if (sp->lossless){\n      sp->quality_level = 100.0f;      \n    }\n    return 1;\n    #else\n      TIFFErrorExt(tif->tif_clientdata, module,\n                  \"Need to upgrade WEBP driver, this version doesn't support \"\n                  \"lossless compression.\");\n      return 0;\n    #endif \n  default:\n    return (*sp->vsetparent)(tif, tag, ap);\n  }\n  /*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              564,
              0
            ],
            [
              596,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TWebPVSetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTWebPVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n  WebPState* sp = LState(tif);\n\n  switch (tag) {\n  case TIFFTAG_WEBP_LEVEL:\n    *va_arg(ap, int*) = sp->quality_level;\n    break;\n  case TIFFTAG_WEBP_LOSSLESS:\n    *va_arg(ap, int*) = sp->lossless;\n    break;\n  default:\n    return (*sp->vgetparent)(tif, tag, ap);\n  }\n  return 1;\n}",
          "fn_code_pos": [
            [
              598,
              0
            ],
            [
              614,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TWebPVGetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFInitWebP(TIFF* tif, int scheme)\n{\n  static const char module[] = \"TIFFInitWebP\";\n  WebPState* sp;\n\n  assert( scheme == COMPRESSION_WEBP );\n\n  /*\n  * Merge codec-specific tag information.\n  */\n  if ( !_TIFFMergeFields(tif, TWebPFields, TIFFArrayCount(TWebPFields)) ) {\n    TIFFErrorExt(tif->tif_clientdata, module,\n                \"Merging WebP codec-specific tags failed\");\n    return 0;\n  }\n\n  /*\n  * Allocate state block so tag methods have storage to record values.\n  */\n  tif->tif_data = (uint8*) _TIFFmalloc(sizeof(WebPState));\n  if (tif->tif_data == NULL)\n    goto bad;\n  sp = LState(tif);\n\n  /*\n  * Override parent get/set field methods.\n  */\n  sp->vgetparent = tif->tif_tagmethods.vgetfield;\n  tif->tif_tagmethods.vgetfield = TWebPVGetField;\t/* hook for codec tags */\n  sp->vsetparent = tif->tif_tagmethods.vsetfield;\n  tif->tif_tagmethods.vsetfield = TWebPVSetField;\t/* hook for codec tags */\n\n  /* Default values for codec-specific fields */\n  sp->quality_level = 75.0f;\t\t/* default comp. level */\n  sp->lossless = 0; /* default to false */\n  sp->state = 0;\n  sp->nSamples = 0;\n  sp->psDecoder = NULL;\n  sp->last_y = 0;\n  \n  sp->buffer_offset = 0;\n  sp->pBuffer = NULL;\n\n  /*\n  * Install codec methods.\n  * Notes:\n  * encoderow is not supported\n  */\n  tif->tif_fixuptags = TWebPFixupTags;\n  tif->tif_setupdecode = TWebPSetupDecode;\n  tif->tif_predecode = TWebPPreDecode;\n  tif->tif_decoderow = TWebPDecode;\n  tif->tif_decodestrip = TWebPDecode;\n  tif->tif_decodetile = TWebPDecode;\n  tif->tif_setupencode = TWebPSetupEncode;\n  tif->tif_preencode = TWebPPreEncode;\n  tif->tif_postencode = TWebPPostEncode;\n  tif->tif_encoderow = TWebPEncode;\n  tif->tif_encodestrip = TWebPEncode;\n  tif->tif_encodetile = TWebPEncode;\n  tif->tif_cleanup = TWebPCleanup;\n\n  return 1;\nbad:\n  TIFFErrorExt(tif->tif_clientdata, module,\n  \t     \"No space for WebP state block\");\n  return 0;\n}",
          "fn_code_pos": [
            [
              626,
              0
            ],
            [
              694,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitWebP",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TWebPEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              69,
              11
            ],
            [
              69,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TWebPEncode",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TWebPDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)",
          "fn_dec_pos": [
            [
              70,
              11
            ],
            [
              70,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TWebPDecode",
            "parameters": {
              "tif": "TIFF",
              "op": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n  uint16           nSamples;               /* number of samples per pixel */\n  \n  int              lossless;               /* lossy/lossless compression */\n  int              quality_level;          /* compression level */\n  WebPPicture      sPicture;               /* WebP Picture */\n  WebPConfig       sEncoderConfig;         /* WebP encoder config */\n  uint8*           pBuffer;                /* buffer to hold raw data on encoding */\n  unsigned int     buffer_offset;          /* current offset into the buffer */\n  unsigned int     buffer_size;\n  \n  WebPIDecoder*    psDecoder;              /* WebPIDecoder */\n  WebPDecBuffer    sDecBuffer;             /* Decoder buffer */\n  int              last_y;                 /* Last row decoded */\n  \n  int              state;                  /* state flags */\n  \n\tTIFFVGetMethod   vgetparent;             /* super-class method */\n\tTIFFVSetMethod   vsetparent;             /* super-class method */\n} WebPState;",
          {
            "nSamples": "uint16",
            "lossless": "int",
            "quality_level": "int",
            "sPicture": "WebPPicture",
            "sEncoderConfig": "WebPConfig",
            "*           pBuffer": "uint8",
            "buffer_offset": "unsigned int",
            "buffer_size": "unsigned int",
            "*    psDecoder": "WebPIDecoder",
            "sDecBuffer": "WebPDecBuffer",
            "last_y": "int",
            "state": "int",
            "vgetparent": "TIFFVGetMethod",
            "vsetparent": "TIFFVSetMethod"
          },
          "WebPState",
          [
            44,
            0
          ],
          [
            63,
            12
          ]
        ],
        [
          "typedef struct {\n  uint16           nSamples;               /* number of samples per pixel */\n  \n  int              lossless;               /* lossy/lossless compression */\n  int              quality_level;          /* compression level */\n  WebPPicture      sPicture;               /* WebP Picture */\n  WebPConfig       sEncoderConfig;         /* WebP encoder config */\n  uint8*           pBuffer;                /* buffer to hold raw data on encoding */\n  unsigned int     buffer_offset;          /* current offset into the buffer */\n  unsigned int     buffer_size;\n  \n  WebPIDecoder*    psDecoder;              /* WebPIDecoder */\n  WebPDecBuffer    sDecBuffer;             /* Decoder buffer */\n  int              last_y;                 /* Last row decoded */\n  \n  int              state;                  /* state flags */\n  \n\tTIFFVGetMethod   vgetparent;             /* super-class method */\n\tTIFFVSetMethod   vsetparent;             /* super-class method */\n} WebPState;",
          {
            "nSamples": "uint16",
            "lossless": "int",
            "quality_level": "int",
            "sPicture": "WebPPicture",
            "sEncoderConfig": "WebPConfig",
            "*           pBuffer": "uint8",
            "buffer_offset": "unsigned int",
            "buffer_size": "unsigned int",
            "*    psDecoder": "WebPIDecoder",
            "sDecBuffer": "WebPDecBuffer",
            "last_y": "int",
            "state": "int",
            "vgetparent": "TIFFVGetMethod",
            "vsetparent": "TIFFVSetMethod"
          },
          "WebPState",
          [
            44,
            0
          ],
          [
            63,
            12
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"webp/decode.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"webp/encode.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_fax3.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nFax3PreDecode(TIFF* tif, uint16 s)\n{\n\tFax3CodecState* sp = DecoderState(tif);\n\n\t(void) s;\n\tassert(sp != NULL);\n\tsp->bit = 0;\t\t\t/* force initial read */\n\tsp->data = 0;\n\tsp->EOLcnt = 0;\t\t\t/* force initial scan for EOL */\n\t/*\n\t * Decoder assumes lsb-to-msb bit order.  Note that we select\n\t * this here rather than in Fax3SetupState so that viewers can\n\t * hold the image open, fiddle with the FillOrder tag value,\n\t * and then re-decode the image.  Otherwise they'd need to close\n\t * and open the image to get the state reset.\n\t */\n\tsp->bitmap =\n\t    TIFFGetBitRevTable(tif->tif_dir.td_fillorder != FILLORDER_LSB2MSB);\n\tif (sp->refruns) {\t\t/* init reference line to white */\n\t\tsp->refruns[0] = (uint32) sp->b.rowpixels;\n\t\tsp->refruns[1] = 0;\n\t}\n\tsp->line = 0;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              143,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3PreDecode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nFax3Unexpected(const char* module, TIFF* tif, uint32 line, uint32 a0)\n{\n\tTIFFErrorExt(tif->tif_clientdata, module, \"Bad code word at line %u of %s %u (x %u)\",\n\t    line, isTiled(tif) ? \"tile\" : \"strip\",\n\t    (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),\n\t    a0);\n}",
          "fn_code_pos": [
            [
              176,
              0
            ],
            [
              183,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3Unexpected",
            "parameters": {
              "module": "char",
              "tif": "TIFF",
              "line": "uint32",
              "a0": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nFax3Extension(const char* module, TIFF* tif, uint32 line, uint32 a0)\n{\n\tTIFFErrorExt(tif->tif_clientdata, module,\n\t    \"Uncompressed data (not supported) at line %u of %s %u (x %u)\",\n\t    line, isTiled(tif) ? \"tile\" : \"strip\",\n\t    (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),\n\t    a0);\n}",
          "fn_code_pos": [
            [
              186,
              0
            ],
            [
              194,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3Extension",
            "parameters": {
              "module": "char",
              "tif": "TIFF",
              "line": "uint32",
              "a0": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nFax3BadLength(const char* module, TIFF* tif, uint32 line, uint32 a0, uint32 lastx)\n{\n\tTIFFWarningExt(tif->tif_clientdata, module, \"%s at line %u of %s %u (got %u, expected %u)\",\n\t    a0 < lastx ? \"Premature EOL\" : \"Line length mismatch\",\n\t    line, isTiled(tif) ? \"tile\" : \"strip\",\n\t    (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),\n\t    a0, lastx);\n}",
          "fn_code_pos": [
            [
              197,
              0
            ],
            [
              205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3BadLength",
            "parameters": {
              "module": "char",
              "tif": "TIFF",
              "line": "uint32",
              "a0": "uint32",
              "lastx": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nFax3PrematureEOF(const char* module, TIFF* tif, uint32 line, uint32 a0)\n{\n\tTIFFWarningExt(tif->tif_clientdata, module, \"Premature EOF at line %u of %s %u (x %u)\",\n\t    line, isTiled(tif) ? \"tile\" : \"strip\",\n\t    (isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip),\n\t    a0);\n}",
          "fn_code_pos": [
            [
              208,
              0
            ],
            [
              215,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3PrematureEOF",
            "parameters": {
              "module": "char",
              "tif": "TIFF",
              "line": "uint32",
              "a0": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nFax3Decode1D(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)\n{\n\tDECLARE_STATE(tif, sp, \"Fax3Decode1D\");\n\t(void) s;\n\tif (occ % sp->b.rowbytes)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\n\t\treturn (-1);\n\t}\n\tCACHE_STATE(tif, sp);\n\tthisrun = sp->curruns;\n\twhile (occ > 0) {\n\t\ta0 = 0;\n\t\tRunLength = 0;\n\t\tpa = thisrun;\n#ifdef FAX3_DEBUG\n\t\tprintf(\"\\nBitAcc=%08X, BitsAvail = %d\\n\", BitAcc, BitsAvail);\n\t\tprintf(\"-------------------- %d\\n\", tif->tif_row);\n\t\tfflush(stdout);\n#endif\n\t\tSYNC_EOL(EOF1D);\n\t\tEXPAND1D(EOF1Da);\n\t\t(*sp->fill)(buf, thisrun, pa, lastx);\n\t\tbuf += sp->b.rowbytes;\n\t\tocc -= sp->b.rowbytes;\n\t\tsp->line++;\n\t\tcontinue;\n\tEOF1D:\t\t\t\t/* premature EOF */\n\t\tCLEANUP_RUNS();\n\tEOF1Da:\t\t\t\t/* premature EOF */\n\t\t(*sp->fill)(buf, thisrun, pa, lastx);\n\t\tUNCACHE_STATE(tif, sp);\n\t\treturn (-1);\n\t}\n\tUNCACHE_STATE(tif, sp);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              223,
              0
            ],
            [
              260,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3Decode1D",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nFax3Decode2D(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)\n{\n\tDECLARE_STATE_2D(tif, sp, \"Fax3Decode2D\");\n\tint is1D;\t\t\t/* current line is 1d/2d-encoded */\n\t(void) s;\n\tif (occ % sp->b.rowbytes)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\n\t\treturn (-1);\n\t}\n\tCACHE_STATE(tif, sp);\n\twhile (occ > 0) {\n\t\ta0 = 0;\n\t\tRunLength = 0;\n\t\tpa = thisrun = sp->curruns;\n#ifdef FAX3_DEBUG\n\t\tprintf(\"\\nBitAcc=%08X, BitsAvail = %d EOLcnt = %d\",\n\t\t    BitAcc, BitsAvail, EOLcnt);\n#endif\n\t\tSYNC_EOL(EOF2D);\n\t\tNeedBits8(1, EOF2D);\n\t\tis1D = GetBits(1);\t/* 1D/2D-encoding tag bit */\n\t\tClrBits(1);\n#ifdef FAX3_DEBUG\n\t\tprintf(\" %s\\n-------------------- %d\\n\",\n\t\t    is1D ? \"1D\" : \"2D\", tif->tif_row);\n\t\tfflush(stdout);\n#endif\n\t\tpb = sp->refruns;\n\t\tb1 = *pb++;\n\t\tif (is1D)\n\t\t\tEXPAND1D(EOF2Da);\n\t\telse\n\t\t\tEXPAND2D(EOF2Da);\n\t\t(*sp->fill)(buf, thisrun, pa, lastx);\n\t\tSETVALUE(0);\t\t/* imaginary change for reference */\n\t\tSWAP(uint32*, sp->curruns, sp->refruns);\n\t\tbuf += sp->b.rowbytes;\n\t\tocc -= sp->b.rowbytes;\n\t\tsp->line++;\n\t\tcontinue;\n\tEOF2D:\t\t\t\t/* premature EOF */\n\t\tCLEANUP_RUNS();\n\tEOF2Da:\t\t\t\t/* premature EOF */\n\t\t(*sp->fill)(buf, thisrun, pa, lastx);\n\t\tUNCACHE_STATE(tif, sp);\n\t\treturn (-1);\n\t}\n\tUNCACHE_STATE(tif, sp);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              266,
              0
            ],
            [
              317,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3Decode2D",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\n_TIFFFax3fillruns(unsigned char* buf, uint32* runs, uint32* erun, uint32 lastx)\n{\n\tstatic const unsigned char _fillmasks[] =\n\t    { 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff };\n\tunsigned char* cp;\n\tuint32 x, bx, run;\n\tint32 n, nw;\n\tlong* lp;\n\n\tif ((erun-runs)&1)\n\t    *erun++ = 0;\n\tx = 0;\n\tfor (; runs < erun; runs += 2) {\n\t    run = runs[0];\n\t    if (x+run > lastx || run > lastx )\n\t\trun = runs[0] = (uint32) (lastx - x);\n\t    if (run) {\n\t\tcp = buf + (x>>3);\n\t\tbx = x&7;\n\t\tif (run > 8-bx) {\n\t\t    if (bx) {\t\t\t/* align to byte boundary */\n\t\t\t*cp++ &= 0xff << (8-bx);\n\t\t\trun -= 8-bx;\n\t\t    }\n\t\t    if( (n = run >> 3) != 0 ) {\t/* multiple bytes to fill */\n\t\t\tif ((n/sizeof (long)) > 1) {\n\t\t\t    /*\n\t\t\t     * Align to longword boundary and fill.\n\t\t\t     */\n\t\t\t    for (; n && !isAligned(cp, long); n--)\n\t\t\t\t    *cp++ = 0x00;\n\t\t\t    lp = (long*) cp;\n\t\t\t    nw = (int32)(n / sizeof (long));\n\t\t\t    n -= nw * sizeof (long);\n\t\t\t    do {\n\t\t\t\t    *lp++ = 0L;\n\t\t\t    } while (--nw);\n\t\t\t    cp = (unsigned char*) lp;\n\t\t\t}\n\t\t\tZERO(n, cp);\n\t\t\trun &= 7;\n\t\t    }\n\t\t    if (run)\n\t\t\tcp[0] &= 0xff >> run;\n\t\t} else\n\t\t    cp[0] &= ~(_fillmasks[run]>>bx);\n\t\tx += runs[0];\n\t    }\n\t    run = runs[1];\n\t    if (x+run > lastx || run > lastx )\n\t\trun = runs[1] = lastx - x;\n\t    if (run) {\n\t\tcp = buf + (x>>3);\n\t\tbx = x&7;\n\t\tif (run > 8-bx) {\n\t\t    if (bx) {\t\t\t/* align to byte boundary */\n\t\t\t*cp++ |= 0xff >> bx;\n\t\t\trun -= 8-bx;\n\t\t    }\n\t\t    if( (n = run>>3) != 0 ) {\t/* multiple bytes to fill */\n\t\t\tif ((n/sizeof (long)) > 1) {\n\t\t\t    /*\n\t\t\t     * Align to longword boundary and fill.\n\t\t\t     */\n\t\t\t    for (; n && !isAligned(cp, long); n--)\n\t\t\t\t*cp++ = 0xff;\n\t\t\t    lp = (long*) cp;\n\t\t\t    nw = (int32)(n / sizeof (long));\n\t\t\t    n -= nw * sizeof (long);\n\t\t\t    do {\n\t\t\t\t*lp++ = -1L;\n\t\t\t    } while (--nw);\n\t\t\t    cp = (unsigned char*) lp;\n\t\t\t}\n\t\t\tFILL(n, cp);\n\t\t\trun &= 7;\n\t\t    }\n                    /* Explicit 0xff masking to make icc -check=conversions happy */\n\t\t    if (run)\n\t\t\tcp[0] = (unsigned char)((cp[0] | (0xff00 >> run))&0xff);\n\t\t} else\n\t\t    cp[0] |= _fillmasks[run]>>bx;\n\t\tx += runs[1];\n\t    }\n\t}\n\tassert(x == lastx);\n}",
          "fn_code_pos": [
            [
              394,
              0
            ],
            [
              481,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFFax3fillruns",
            "parameters": {
              "buf": "unsigned char",
              "runs": "uint32",
              "erun": "uint32",
              "lastx": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nFax3FixupTags(TIFF* tif)\n{\n\t(void) tif;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              485,
              0
            ],
            [
              490,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3FixupTags",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nFax3SetupState(TIFF* tif)\n{\n\tstatic const char module[] = \"Fax3SetupState\";\n\tTIFFDirectory* td = &tif->tif_dir;\n\tFax3BaseState* sp = Fax3State(tif);\n\tint needsRefLine;\n\tFax3CodecState* dsp = (Fax3CodecState*) Fax3State(tif);\n\ttmsize_t rowbytes;\n\tuint32 rowpixels, nruns;\n\n\tif (td->td_bitspersample != 1) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Bits/sample must be 1 for Group 3/4 encoding/decoding\");\n\t\treturn (0);\n\t}\n\t/*\n\t * Calculate the scanline/tile widths.\n\t */\n\tif (isTiled(tif)) {\n\t\trowbytes = TIFFTileRowSize(tif);\n\t\trowpixels = td->td_tilewidth;\n\t} else {\n\t\trowbytes = TIFFScanlineSize(tif);\n\t\trowpixels = td->td_imagewidth;\n\t}\n\tsp->rowbytes = rowbytes;\n\tsp->rowpixels = rowpixels;\n\t/*\n\t * Allocate any additional space required for decoding/encoding.\n\t */\n\tneedsRefLine = (\n\t    (sp->groupoptions & GROUP3OPT_2DENCODING) ||\n\t    td->td_compression == COMPRESSION_CCITTFAX4\n\t);\n\n\t/*\n\t  Assure that allocation computations do not overflow.\n\t  \n\t  TIFFroundup and TIFFSafeMultiply return zero on integer overflow\n\t*/\n\tdsp->runs=(uint32*) NULL;\n\tnruns = TIFFroundup_32(rowpixels,32);\n\tif (needsRefLine) {\n\t\tnruns = TIFFSafeMultiply(uint32,nruns,2);\n\t}\n\tif ((nruns == 0) || (TIFFSafeMultiply(uint32,nruns,2) == 0)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"Row pixels integer overflow (rowpixels %u)\",\n\t\t\t     rowpixels);\n\t\treturn (0);\n\t}\n\tdsp->runs = (uint32*) _TIFFCheckMalloc(tif,\n\t\t\t\t\t       TIFFSafeMultiply(uint32,nruns,2),\n\t\t\t\t\t       sizeof (uint32),\n\t\t\t\t\t       \"for Group 3/4 run arrays\");\n\tif (dsp->runs == NULL)\n\t\treturn (0);\n\tmemset( dsp->runs, 0, TIFFSafeMultiply(uint32,nruns,2)*sizeof(uint32));\n\tdsp->curruns = dsp->runs;\n\tif (needsRefLine)\n\t\tdsp->refruns = dsp->runs + nruns;\n\telse\n\t\tdsp->refruns = NULL;\n\tif (td->td_compression == COMPRESSION_CCITTFAX3\n\t    && is2DEncoding(dsp)) {\t/* NB: default is 1D routine */\n\t\ttif->tif_decoderow = Fax3Decode2D;\n\t\ttif->tif_decodestrip = Fax3Decode2D;\n\t\ttif->tif_decodetile = Fax3Decode2D;\n\t}\n\n\tif (needsRefLine) {\t\t/* 2d encoding */\n\t\tFax3CodecState* esp = EncoderState(tif);\n\t\t/*\n\t\t * 2d encoding requires a scanline\n\t\t * buffer for the ``reference line''; the\n\t\t * scanline against which delta encoding\n\t\t * is referenced.  The reference line must\n\t\t * be initialized to be ``white'' (done elsewhere).\n\t\t */\n\t\tesp->refline = (unsigned char*) _TIFFmalloc(rowbytes);\n\t\tif (esp->refline == NULL) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"No space for Group 3/4 reference line\");\n\t\t\treturn (0);\n\t\t}\n\t} else\t\t\t\t\t/* 1d encoding */\n\t\tEncoderState(tif)->refline = NULL;\n\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              499,
              0
            ],
            [
              589,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3SetupState",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nFax3PutBits(TIFF* tif, unsigned int bits, unsigned int length)\n{\n\tFax3CodecState* sp = EncoderState(tif);\n\tunsigned int bit = sp->bit;\n\tint data = sp->data;\n\n\t_PutBits(tif, bits, length);\n\n\tsp->data = data;\n\tsp->bit = bit;\n}",
          "fn_code_pos": [
            [
              629,
              0
            ],
            [
              640,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3PutBits",
            "parameters": {
              "tif": "TIFF",
              "bits": "unsigned int",
              "length": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nputspan(TIFF* tif, int32 span, const tableentry* tab)\n{\n\tFax3CodecState* sp = EncoderState(tif);\n\tunsigned int bit = sp->bit;\n\tint data = sp->data;\n\tunsigned int code, length;\n\n\twhile (span >= 2624) {\n\t\tconst tableentry* te = &tab[63 + (2560>>6)];\n\t\tcode = te->code;\n\t\tlength = te->length;\n#ifdef FAX3_DEBUG\n\t\tDEBUG_PRINT(\"MakeUp\", te->runlen);\n#endif\n\t\t_PutBits(tif, code, length);\n\t\tspan -= te->runlen;\n\t}\n\tif (span >= 64) {\n\t\tconst tableentry* te = &tab[63 + (span>>6)];\n\t\tassert(te->runlen == 64*(span>>6));\n\t\tcode = te->code;\n\t\tlength = te->length;\n#ifdef FAX3_DEBUG\n\t\tDEBUG_PRINT(\"MakeUp\", te->runlen);\n#endif\n\t\t_PutBits(tif, code, length);\n\t\tspan -= te->runlen;\n\t}\n\tcode = tab[span].code;\n\tlength = tab[span].length;\n#ifdef FAX3_DEBUG\n\tDEBUG_PRINT(\"  Term\", tab[span].runlen);\n#endif\n\t_PutBits(tif, code, length);\n\n\tsp->data = data;\n\tsp->bit = bit;\n}",
          "fn_code_pos": [
            [
              664,
              0
            ],
            [
              702,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "putspan",
            "parameters": {
              "tif": "TIFF",
              "span": "int32",
              "tab": "tableentry"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nFax3PutEOL(TIFF* tif)\n{\n\tFax3CodecState* sp = EncoderState(tif);\n\tunsigned int bit = sp->bit;\n\tint data = sp->data;\n\tunsigned int code, length, tparm;\n\n\tif (sp->b.groupoptions & GROUP3OPT_FILLBITS) {\n\t\t/*\n\t\t * Force bit alignment so EOL will terminate on\n\t\t * a byte boundary.  That is, force the bit alignment\n\t\t * to 16-12 = 4 before putting out the EOL code.\n\t\t */\n\t\tint align = 8 - 4;\n\t\tif (align != sp->bit) {\n\t\t\tif (align > sp->bit)\n\t\t\t\talign = sp->bit + (8 - align);\n\t\t\telse\n\t\t\t\talign = sp->bit - align;\n\t\t\ttparm=align; \n\t\t\t_PutBits(tif, 0, tparm);\n\t\t}\n\t}\n\tcode = EOL;\n\tlength = 12;\n\tif (is2DEncoding(sp)) {\n\t\tcode = (code<<1) | (sp->tag == G3_1D);\n\t\tlength++;\n\t}\n\t_PutBits(tif, code, length);\n\n\tsp->data = data;\n\tsp->bit = bit;\n}",
          "fn_code_pos": [
            [
              710,
              0
            ],
            [
              744,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3PutEOL",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nFax3PreEncode(TIFF* tif, uint16 s)\n{\n\tFax3CodecState* sp = EncoderState(tif);\n\n\t(void) s;\n\tassert(sp != NULL);\n\tsp->bit = 8;\n\tsp->data = 0;\n\tsp->tag = G3_1D;\n\t/*\n\t * This is necessary for Group 4; otherwise it isn't\n\t * needed because the first scanline of each strip ends\n\t * up being copied into the refline.\n\t */\n\tif (sp->refline)\n\t\t_TIFFmemset(sp->refline, 0x00, sp->b.rowbytes);\n\tif (is2DEncoding(sp)) {\n\t\tfloat res = tif->tif_dir.td_yresolution;\n\t\t/*\n\t\t * The CCITT spec says that when doing 2d encoding, you\n\t\t * should only do it on K consecutive scanlines, where K\n\t\t * depends on the resolution of the image being encoded\n\t\t * (2 for <= 200 lpi, 4 for > 200 lpi).  Since the directory\n\t\t * code initializes td_yresolution to 0, this code will\n\t\t * select a K of 2 unless the YResolution tag is set\n\t\t * appropriately.  (Note also that we fudge a little here\n\t\t * and use 150 lpi to avoid problems with units conversion.)\n\t\t */\n\t\tif (tif->tif_dir.td_resolutionunit == RESUNIT_CENTIMETER)\n\t\t\tres *= 2.54f;\t\t/* convert to inches */\n\t\tsp->maxk = (res > 150 ? 4 : 2);\n\t\tsp->k = sp->maxk-1;\n\t} else\n\t\tsp->k = sp->maxk = 0;\n\tsp->line = 0;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              749,
              0
            ],
            [
              786,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3PreEncode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "inline static int32\nfind0span(unsigned char* bp, int32 bs, int32 be)\n{\n\tint32 bits = be - bs;\n\tint32 n, span;\n\n\tbp += bs>>3;\n\t/*\n\t * Check partial byte on lhs.\n\t */\n\tif (bits > 0 && (n = (bs & 7)) != 0) {\n\t\tspan = zeroruns[(*bp << n) & 0xff];\n\t\tif (span > 8-n)\t\t/* table value too generous */\n\t\t\tspan = 8-n;\n\t\tif (span > bits)\t/* constrain span to bit range */\n\t\t\tspan = bits;\n\t\tif (n+span < 8)\t\t/* doesn't extend to edge of byte */\n\t\t\treturn (span);\n\t\tbits -= span;\n\t\tbp++;\n\t} else\n\t\tspan = 0;\n\tif (bits >= (int32)(2 * 8 * sizeof(long))) {\n\t\tlong* lp;\n\t\t/*\n\t\t * Align to longword boundary and check longwords.\n\t\t */\n\t\twhile (!isAligned(bp, long)) {\n\t\t\tif (*bp != 0x00)\n\t\t\t\treturn (span + zeroruns[*bp]);\n\t\t\tspan += 8;\n\t\t\tbits -= 8;\n\t\t\tbp++;\n\t\t}\n\t\tlp = (long*) bp;\n\t\twhile ((bits >= (int32)(8 * sizeof(long))) && (0 == *lp)) {\n\t\t\tspan += 8*sizeof (long);\n\t\t\tbits -= 8*sizeof (long);\n\t\t\tlp++;\n\t\t}\n\t\tbp = (unsigned char*) lp;\n\t}\n\t/*\n\t * Scan full bytes for all 0's.\n\t */\n\twhile (bits >= 8) {\n\t\tif (*bp != 0x00)\t/* end of run */\n\t\t\treturn (span + zeroruns[*bp]);\n\t\tspan += 8;\n\t\tbits -= 8;\n\t\tbp++;\n\t}\n\t/*\n\t * Check partial byte on rhs.\n\t */\n\tif (bits > 0) {\n\t\tn = zeroruns[*bp];\n\t\tspan += (n > bits ? bits : n);\n\t}\n\treturn (span);\n}",
          "fn_code_pos": [
            [
              840,
              0
            ],
            [
              900,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find0span",
            "parameters": {
              "bp": "unsigned char",
              "bs": "int32",
              "be": "int32"
            },
            "return_type": "int32"
          }
        },
        {
          "fn_code": "inline static int32\nfind1span(unsigned char* bp, int32 bs, int32 be)\n{\n\tint32 bits = be - bs;\n\tint32 n, span;\n\n\tbp += bs>>3;\n\t/*\n\t * Check partial byte on lhs.\n\t */\n\tif (bits > 0 && (n = (bs & 7)) != 0) {\n\t\tspan = oneruns[(*bp << n) & 0xff];\n\t\tif (span > 8-n)\t\t/* table value too generous */\n\t\t\tspan = 8-n;\n\t\tif (span > bits)\t/* constrain span to bit range */\n\t\t\tspan = bits;\n\t\tif (n+span < 8)\t\t/* doesn't extend to edge of byte */\n\t\t\treturn (span);\n\t\tbits -= span;\n\t\tbp++;\n\t} else\n\t\tspan = 0;\n\tif (bits >= (int32)(2 * 8 * sizeof(long))) {\n\t\tlong* lp;\n\t\t/*\n\t\t * Align to longword boundary and check longwords.\n\t\t */\n\t\twhile (!isAligned(bp, long)) {\n\t\t\tif (*bp != 0xff)\n\t\t\t\treturn (span + oneruns[*bp]);\n\t\t\tspan += 8;\n\t\t\tbits -= 8;\n\t\t\tbp++;\n\t\t}\n\t\tlp = (long*) bp;\n\t\twhile ((bits >= (int32)(8 * sizeof(long))) && (~0 == *lp)) {\n\t\t\tspan += 8*sizeof (long);\n\t\t\tbits -= 8*sizeof (long);\n\t\t\tlp++;\n\t\t}\n\t\tbp = (unsigned char*) lp;\n\t}\n\t/*\n\t * Scan full bytes for all 1's.\n\t */\n\twhile (bits >= 8) {\n\t\tif (*bp != 0xff)\t/* end of run */\n\t\t\treturn (span + oneruns[*bp]);\n\t\tspan += 8;\n\t\tbits -= 8;\n\t\tbp++;\n\t}\n\t/*\n\t * Check partial byte on rhs.\n\t */\n\tif (bits > 0) {\n\t\tn = oneruns[*bp];\n\t\tspan += (n > bits ? bits : n);\n\t}\n\treturn (span);\n}",
          "fn_code_pos": [
            [
              902,
              0
            ],
            [
              962,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find1span",
            "parameters": {
              "bp": "unsigned char",
              "bs": "int32",
              "be": "int32"
            },
            "return_type": "int32"
          }
        },
        {
          "fn_code": "static int\nFax3Encode1DRow(TIFF* tif, unsigned char* bp, uint32 bits)\n{\n\tFax3CodecState* sp = EncoderState(tif);\n\tint32 span;\n        uint32 bs = 0;\n\n\tfor (;;) {\n\t\tspan = find0span(bp, bs, bits);\t\t/* white span */\n\t\tputspan(tif, span, TIFFFaxWhiteCodes);\n\t\tbs += span;\n\t\tif (bs >= bits)\n\t\t\tbreak;\n\t\tspan = find1span(bp, bs, bits);\t\t/* black span */\n\t\tputspan(tif, span, TIFFFaxBlackCodes);\n\t\tbs += span;\n\t\tif (bs >= bits)\n\t\t\tbreak;\n\t}\n\tif (sp->b.mode & (FAXMODE_BYTEALIGN|FAXMODE_WORDALIGN)) {\n\t\tif (sp->bit != 8)\t\t\t/* byte-align */\n\t\t\tFax3FlushBits(tif, sp);\n\t\tif ((sp->b.mode&FAXMODE_WORDALIGN) &&\n\t\t    !isAligned(tif->tif_rawcp, uint16))\n\t\t\tFax3FlushBits(tif, sp);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              984,
              0
            ],
            [
              1011,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3Encode1DRow",
            "parameters": {
              "tif": "TIFF",
              "bp": "unsigned char",
              "bits": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nFax3Encode2DRow(TIFF* tif, unsigned char* bp, unsigned char* rp, uint32 bits)\n{\n#define\tPIXEL(buf,ix)\t((((buf)[(ix)>>3]) >> (7-((ix)&7))) & 1)\n        uint32 a0 = 0;\n\tuint32 a1 = (PIXEL(bp, 0) != 0 ? 0 : finddiff(bp, 0, bits, 0));\n\tuint32 b1 = (PIXEL(rp, 0) != 0 ? 0 : finddiff(rp, 0, bits, 0));\n\tuint32 a2, b2;\n\n\tfor (;;) {\n\t\tb2 = finddiff2(rp, b1, bits, PIXEL(rp,b1));\n\t\tif (b2 >= a1) {\n\t\t\t/* Naive computation triggers -fsanitize=undefined,unsigned-integer-overflow */\n\t\t\t/* although it is correct unless the difference between both is < 31 bit */\n\t\t\t/* int32 d = b1 - a1; */\n\t\t\tint32 d = (b1 >= a1 && b1 - a1 <= 3U) ? (int32)(b1 - a1):\n\t\t\t          (b1 < a1 && a1 - b1 <= 3U) ? -(int32)(a1 - b1) : 0x7FFFFFFF;\n\t\t\tif (!(-3 <= d && d <= 3)) {\t/* horizontal mode */\n\t\t\t\ta2 = finddiff2(bp, a1, bits, PIXEL(bp,a1));\n\t\t\t\tputcode(tif, &horizcode);\n\t\t\t\tif (a0+a1 == 0 || PIXEL(bp, a0) == 0) {\n\t\t\t\t\tputspan(tif, a1-a0, TIFFFaxWhiteCodes);\n\t\t\t\t\tputspan(tif, a2-a1, TIFFFaxBlackCodes);\n\t\t\t\t} else {\n\t\t\t\t\tputspan(tif, a1-a0, TIFFFaxBlackCodes);\n\t\t\t\t\tputspan(tif, a2-a1, TIFFFaxWhiteCodes);\n\t\t\t\t}\n\t\t\t\ta0 = a2;\n\t\t\t} else {\t\t\t/* vertical mode */\n\t\t\t\tputcode(tif, &vcodes[d+3]);\n\t\t\t\ta0 = a1;\n\t\t\t}\n\t\t} else {\t\t\t\t/* pass mode */\n\t\t\tputcode(tif, &passcode);\n\t\t\ta0 = b2;\n\t\t}\n\t\tif (a0 >= bits)\n\t\t\tbreak;\n\t\ta1 = finddiff(bp, a0, bits, PIXEL(bp,a0));\n\t\tb1 = finddiff(rp, a0, bits, !PIXEL(bp,a0));\n\t\tb1 = finddiff(rp, b1, bits, PIXEL(bp,a0));\n\t}\n\treturn (1);\n#undef PIXEL\n}",
          "fn_code_pos": [
            [
              1031,
              0
            ],
            [
              1075,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3Encode2DRow",
            "parameters": {
              "tif": "TIFF",
              "bp": "unsigned char",
              "rp": "unsigned char",
              "bits": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nFax3Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\tstatic const char module[] = \"Fax3Encode\";\n\tFax3CodecState* sp = EncoderState(tif);\n\t(void) s;\n\tif (cc % sp->b.rowbytes)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be written\");\n\t\treturn (0);\n\t}\n\twhile (cc > 0) {\n\t\tif ((sp->b.mode & FAXMODE_NOEOL) == 0)\n\t\t\tFax3PutEOL(tif);\n\t\tif (is2DEncoding(sp)) {\n\t\t\tif (sp->tag == G3_1D) {\n\t\t\t\tif (!Fax3Encode1DRow(tif, bp, sp->b.rowpixels))\n\t\t\t\t\treturn (0);\n\t\t\t\tsp->tag = G3_2D;\n\t\t\t} else {\n\t\t\t\tif (!Fax3Encode2DRow(tif, bp, sp->refline,\n\t\t\t\t    sp->b.rowpixels))\n\t\t\t\t\treturn (0);\n\t\t\t\tsp->k--;\n\t\t\t}\n\t\t\tif (sp->k == 0) {\n\t\t\t\tsp->tag = G3_1D;\n\t\t\t\tsp->k = sp->maxk-1;\n\t\t\t} else\n\t\t\t\t_TIFFmemcpy(sp->refline, bp, sp->b.rowbytes);\n\t\t} else {\n\t\t\tif (!Fax3Encode1DRow(tif, bp, sp->b.rowpixels))\n\t\t\t\treturn (0);\n\t\t}\n\t\tbp += sp->b.rowbytes;\n\t\tcc -= sp->b.rowbytes;\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1080,
              0
            ],
            [
              1118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3Encode",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nFax3PostEncode(TIFF* tif)\n{\n\tFax3CodecState* sp = EncoderState(tif);\n\n\tif (sp->bit != 8)\n\t\tFax3FlushBits(tif, sp);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1120,
              0
            ],
            [
              1128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3PostEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nFax3Close(TIFF* tif)\n{\n\tif ((Fax3State(tif)->mode & FAXMODE_NORTC) == 0 && tif->tif_rawcp) {\n\t\tFax3CodecState* sp = EncoderState(tif);\n\t\tunsigned int code = EOL;\n\t\tunsigned int length = 12;\n\t\tint i;\n\n\t\tif (is2DEncoding(sp)) {\n\t\t\tcode = (code<<1) | (sp->tag == G3_1D);\n\t\t\tlength++;\n\t\t}\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tFax3PutBits(tif, code, length);\n\t\tFax3FlushBits(tif, sp);\n\t}\n}",
          "fn_code_pos": [
            [
              1130,
              0
            ],
            [
              1147,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3Close",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nFax3Cleanup(TIFF* tif)\n{\n\tFax3CodecState* sp = DecoderState(tif);\n\t\n\tassert(sp != 0);\n\n\ttif->tif_tagmethods.vgetfield = sp->b.vgetparent;\n\ttif->tif_tagmethods.vsetfield = sp->b.vsetparent;\n\ttif->tif_tagmethods.printdir = sp->b.printdir;\n\n\tif (sp->runs)\n\t\t_TIFFfree(sp->runs);\n\tif (sp->refline)\n\t\t_TIFFfree(sp->refline);\n\n\t_TIFFfree(tif->tif_data);\n\ttif->tif_data = NULL;\n\n\t_TIFFSetDefaultCompressionState(tif);\n}",
          "fn_code_pos": [
            [
              1149,
              0
            ],
            [
              1169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3Cleanup",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nFax3VSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tFax3BaseState* sp = Fax3State(tif);\n\tconst TIFFField* fip;\n\n\tassert(sp != 0);\n\tassert(sp->vsetparent != 0);\n\n\tswitch (tag) {\n\tcase TIFFTAG_FAXMODE:\n\t\tsp->mode = (int) va_arg(ap, int);\n\t\treturn 1;\t\t\t/* NB: pseudo tag */\n\tcase TIFFTAG_FAXFILLFUNC:\n\t\tDecoderState(tif)->fill = va_arg(ap, TIFFFaxFillFunc);\n\t\treturn 1;\t\t\t/* NB: pseudo tag */\n\tcase TIFFTAG_GROUP3OPTIONS:\n\t\t/* XXX: avoid reading options if compression mismatches. */\n\t\tif (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX3)\n\t\t\tsp->groupoptions = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_GROUP4OPTIONS:\n\t\t/* XXX: avoid reading options if compression mismatches. */\n\t\tif (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX4)\n\t\t\tsp->groupoptions = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_BADFAXLINES:\n\t\tsp->badfaxlines = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_CLEANFAXDATA:\n\t\tsp->cleanfaxdata = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_CONSECUTIVEBADFAXLINES:\n\t\tsp->badfaxrun = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tdefault:\n\t\treturn (*sp->vsetparent)(tif, tag, ap);\n\t}\n\t\n\tif ((fip = TIFFFieldWithTag(tif, tag)) != NULL)\n\t\tTIFFSetFieldBit(tif, fip->field_bit);\n\telse\n\t\treturn 0;\n\n\ttif->tif_flags |= TIFF_DIRTYDIRECT;\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              1190,
              0
            ],
            [
              1236,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3VSetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nFax3VGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tFax3BaseState* sp = Fax3State(tif);\n\n\tassert(sp != 0);\n\n\tswitch (tag) {\n\tcase TIFFTAG_FAXMODE:\n\t\t*va_arg(ap, int*) = sp->mode;\n\t\tbreak;\n\tcase TIFFTAG_FAXFILLFUNC:\n\t\t*va_arg(ap, TIFFFaxFillFunc*) = DecoderState(tif)->fill;\n\t\tbreak;\n\tcase TIFFTAG_GROUP3OPTIONS:\n\tcase TIFFTAG_GROUP4OPTIONS:\n\t\t*va_arg(ap, uint32*) = sp->groupoptions;\n\t\tbreak;\n\tcase TIFFTAG_BADFAXLINES:\n\t\t*va_arg(ap, uint32*) = sp->badfaxlines;\n\t\tbreak;\n\tcase TIFFTAG_CLEANFAXDATA:\n\t\t*va_arg(ap, uint16*) = sp->cleanfaxdata;\n\t\tbreak;\n\tcase TIFFTAG_CONSECUTIVEBADFAXLINES:\n\t\t*va_arg(ap, uint32*) = sp->badfaxrun;\n\t\tbreak;\n\tdefault:\n\t\treturn (*sp->vgetparent)(tif, tag, ap);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1238,
              0
            ],
            [
              1269,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3VGetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nFax3PrintDir(TIFF* tif, FILE* fd, long flags)\n{\n\tFax3BaseState* sp = Fax3State(tif);\n\n\tassert(sp != 0);\n\n\t(void) flags;\n\tif (TIFFFieldSet(tif,FIELD_OPTIONS)) {\n\t\tconst char* sep = \" \";\n\t\tif (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX4) {\n\t\t\tfprintf(fd, \"  Group 4 Options:\");\n\t\t\tif (sp->groupoptions & GROUP4OPT_UNCOMPRESSED)\n\t\t\t\tfprintf(fd, \"%suncompressed data\", sep);\n\t\t} else {\n\n\t\t\tfprintf(fd, \"  Group 3 Options:\");\n\t\t\tif (sp->groupoptions & GROUP3OPT_2DENCODING) {\n\t\t\t\tfprintf(fd, \"%s2-d encoding\", sep);\n\t\t\t\tsep = \"+\";\n\t\t\t}\n\t\t\tif (sp->groupoptions & GROUP3OPT_FILLBITS) {\n\t\t\t\tfprintf(fd, \"%sEOL padding\", sep);\n\t\t\t\tsep = \"+\";\n\t\t\t}\n\t\t\tif (sp->groupoptions & GROUP3OPT_UNCOMPRESSED)\n\t\t\t\tfprintf(fd, \"%suncompressed data\", sep);\n\t\t}\n\t\tfprintf(fd, \" (%lu = 0x%lx)\\n\",\n                        (unsigned long) sp->groupoptions,\n                        (unsigned long) sp->groupoptions);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_CLEANFAXDATA)) {\n\t\tfprintf(fd, \"  Fax Data:\");\n\t\tswitch (sp->cleanfaxdata) {\n\t\tcase CLEANFAXDATA_CLEAN:\n\t\t\tfprintf(fd, \" clean\");\n\t\t\tbreak;\n\t\tcase CLEANFAXDATA_REGENERATED:\n\t\t\tfprintf(fd, \" receiver regenerated\");\n\t\t\tbreak;\n\t\tcase CLEANFAXDATA_UNCLEAN:\n\t\t\tfprintf(fd, \" uncorrected errors\");\n\t\t\tbreak;\n\t\t}\n\t\tfprintf(fd, \" (%u = 0x%x)\\n\",\n\t\t    sp->cleanfaxdata, sp->cleanfaxdata);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_BADFAXLINES))\n\t\tfprintf(fd, \"  Bad Fax Lines: %lu\\n\",\n                        (unsigned long) sp->badfaxlines);\n\tif (TIFFFieldSet(tif,FIELD_BADFAXRUN))\n\t\tfprintf(fd, \"  Consecutive Bad Fax Lines: %lu\\n\",\n\t\t    (unsigned long) sp->badfaxrun);\n\tif (sp->printdir)\n\t\t(*sp->printdir)(tif, fd, flags);\n}",
          "fn_code_pos": [
            [
              1271,
              0
            ],
            [
              1327,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3PrintDir",
            "parameters": {
              "tif": "TIFF",
              "fd": "FILE",
              "flags": "long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nInitCCITTFax3(TIFF* tif)\n{\n\tstatic const char module[] = \"InitCCITTFax3\";\n\tFax3BaseState* sp;\n\n\t/*\n\t * Merge codec-specific tag information.\n\t */\n\tif (!_TIFFMergeFields(tif, faxFields, TIFFArrayCount(faxFields))) {\n\t\tTIFFErrorExt(tif->tif_clientdata, \"InitCCITTFax3\",\n\t\t\t\"Merging common CCITT Fax codec-specific tags failed\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate state block so tag methods have storage to record values.\n\t */\n\ttif->tif_data = (uint8*)\n\t\t_TIFFmalloc(sizeof (Fax3CodecState));\n\n\tif (tif->tif_data == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"No space for state block\");\n\t\treturn (0);\n\t}\n\t_TIFFmemset(tif->tif_data, 0, sizeof (Fax3CodecState));\n\n\tsp = Fax3State(tif);\n        sp->rw_mode = tif->tif_mode;\n\n\t/*\n\t * Override parent get/set field methods.\n\t */\n\tsp->vgetparent = tif->tif_tagmethods.vgetfield;\n\ttif->tif_tagmethods.vgetfield = Fax3VGetField; /* hook for codec tags */\n\tsp->vsetparent = tif->tif_tagmethods.vsetfield;\n\ttif->tif_tagmethods.vsetfield = Fax3VSetField; /* hook for codec tags */\n\tsp->printdir = tif->tif_tagmethods.printdir;\n\ttif->tif_tagmethods.printdir = Fax3PrintDir;   /* hook for codec tags */\n\tsp->groupoptions = 0;\t\n\n\tif (sp->rw_mode == O_RDONLY) /* FIXME: improve for in place update */\n\t\ttif->tif_flags |= TIFF_NOBITREV; /* decoder does bit reversal */\n\tDecoderState(tif)->runs = NULL;\n\tTIFFSetField(tif, TIFFTAG_FAXFILLFUNC, _TIFFFax3fillruns);\n\tEncoderState(tif)->refline = NULL;\n\n\t/*\n\t * Install codec methods.\n\t */\n\ttif->tif_fixuptags = Fax3FixupTags;\n\ttif->tif_setupdecode = Fax3SetupState;\n\ttif->tif_predecode = Fax3PreDecode;\n\ttif->tif_decoderow = Fax3Decode1D;\n\ttif->tif_decodestrip = Fax3Decode1D;\n\ttif->tif_decodetile = Fax3Decode1D;\n\ttif->tif_setupencode = Fax3SetupState;\n\ttif->tif_preencode = Fax3PreEncode;\n\ttif->tif_postencode = Fax3PostEncode;\n\ttif->tif_encoderow = Fax3Encode;\n\ttif->tif_encodestrip = Fax3Encode;\n\ttif->tif_encodetile = Fax3Encode;\n\ttif->tif_close = Fax3Close;\n\ttif->tif_cleanup = Fax3Cleanup;\n\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1329,
              0
            ],
            [
              1396,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "InitCCITTFax3",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFInitCCITTFax3(TIFF* tif, int scheme)\n{\n\t(void) scheme;\n\tif (InitCCITTFax3(tif)) {\n\t\t/*\n\t\t * Merge codec-specific tag information.\n\t\t */\n\t\tif (!_TIFFMergeFields(tif, fax3Fields,\n\t\t\t\t      TIFFArrayCount(fax3Fields))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFInitCCITTFax3\",\n\t\t\t\"Merging CCITT Fax 3 codec-specific tags failed\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * The default format is Class/F-style w/o RTC.\n\t\t */\n\t\treturn TIFFSetField(tif, TIFFTAG_FAXMODE, FAXMODE_CLASSF);\n\t} else\n\t\treturn 01;\n}",
          "fn_code_pos": [
            [
              1398,
              0
            ],
            [
              1419,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitCCITTFax3",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nFax4Decode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)\n{\n\tDECLARE_STATE_2D(tif, sp, \"Fax4Decode\");\n\t(void) s;\n\tif (occ % sp->b.rowbytes)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\n\t\treturn (-1);\n\t}\n\tCACHE_STATE(tif, sp);\n\twhile (occ > 0) {\n\t\ta0 = 0;\n\t\tRunLength = 0;\n\t\tpa = thisrun = sp->curruns;\n\t\tpb = sp->refruns;\n\t\tb1 = *pb++;\n#ifdef FAX3_DEBUG\n\t\tprintf(\"\\nBitAcc=%08X, BitsAvail = %d\\n\", BitAcc, BitsAvail);\n\t\tprintf(\"-------------------- %d\\n\", tif->tif_row);\n\t\tfflush(stdout);\n#endif\n\t\tEXPAND2D(EOFG4);\n                if (EOLcnt)\n                    goto EOFG4;\n\t\t(*sp->fill)(buf, thisrun, pa, lastx);\n\t\tSETVALUE(0);\t\t/* imaginary change for reference */\n\t\tSWAP(uint32*, sp->curruns, sp->refruns);\n\t\tbuf += sp->b.rowbytes;\n\t\tocc -= sp->b.rowbytes;\n\t\tsp->line++;\n\t\tcontinue;\n\tEOFG4:\n                NeedBits16( 13, BADG4 );\n        BADG4:\n#ifdef FAX3_DEBUG\n                if( GetBits(13) != 0x1001 )\n                    fputs( \"Bad EOFB\\n\", stderr );\n#endif                \n                ClrBits( 13 );\n\t\t(*sp->fill)(buf, thisrun, pa, lastx);\n\t\tUNCACHE_STATE(tif, sp);\n\t\treturn ( sp->line ? 1 : -1);\t/* don't error on badly-terminated strips */\n\t}\n\tUNCACHE_STATE(tif, sp);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1430,
              0
            ],
            [
              1476,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax4Decode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nFax4Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\tstatic const char module[] = \"Fax4Encode\";\n\tFax3CodecState *sp = EncoderState(tif);\n\t(void) s;\n\tif (cc % sp->b.rowbytes)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be written\");\n\t\treturn (0);\n\t}\n\twhile (cc > 0) {\n\t\tif (!Fax3Encode2DRow(tif, bp, sp->refline, sp->b.rowpixels))\n\t\t\treturn (0);\n\t\t_TIFFmemcpy(sp->refline, bp, sp->b.rowbytes);\n\t\tbp += sp->b.rowbytes;\n\t\tcc -= sp->b.rowbytes;\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1482,
              0
            ],
            [
              1501,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax4Encode",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nFax4PostEncode(TIFF* tif)\n{\n\tFax3CodecState *sp = EncoderState(tif);\n\n\t/* terminate strip w/ EOFB */\n\tFax3PutBits(tif, EOL, 12);\n\tFax3PutBits(tif, EOL, 12);\n\tif (sp->bit != 8)\n\t\tFax3FlushBits(tif, sp);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1503,
              0
            ],
            [
              1514,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax4PostEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFInitCCITTFax4(TIFF* tif, int scheme)\n{\n\t(void) scheme;\n\tif (InitCCITTFax3(tif)) {\t\t/* reuse G3 support */\n\t\t/*\n\t\t * Merge codec-specific tag information.\n\t\t */\n\t\tif (!_TIFFMergeFields(tif, fax4Fields,\n\t\t\t\t      TIFFArrayCount(fax4Fields))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFInitCCITTFax4\",\n\t\t\t\"Merging CCITT Fax 4 codec-specific tags failed\");\n\t\t\treturn 0;\n\t\t}\n\n\t\ttif->tif_decoderow = Fax4Decode;\n\t\ttif->tif_decodestrip = Fax4Decode;\n\t\ttif->tif_decodetile = Fax4Decode;\n\t\ttif->tif_encoderow = Fax4Encode;\n\t\ttif->tif_encodestrip = Fax4Encode;\n\t\ttif->tif_encodetile = Fax4Encode;\n\t\ttif->tif_postencode = Fax4PostEncode;\n\t\t/*\n\t\t * Suppress RTC at the end of each strip.\n\t\t */\n\t\treturn TIFFSetField(tif, TIFFTAG_FAXMODE, FAXMODE_NORTC);\n\t} else\n\t\treturn (0);\n}",
          "fn_code_pos": [
            [
              1516,
              0
            ],
            [
              1544,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitCCITTFax4",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nFax3DecodeRLE(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)\n{\n\tDECLARE_STATE(tif, sp, \"Fax3DecodeRLE\");\n\tint mode = sp->b.mode;\n\t(void) s;\n\tif (occ % sp->b.rowbytes)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\n\t\treturn (-1);\n\t}\n\tCACHE_STATE(tif, sp);\n\tthisrun = sp->curruns;\n\twhile (occ > 0) {\n\t\ta0 = 0;\n\t\tRunLength = 0;\n\t\tpa = thisrun;\n#ifdef FAX3_DEBUG\n\t\tprintf(\"\\nBitAcc=%08X, BitsAvail = %d\\n\", BitAcc, BitsAvail);\n\t\tprintf(\"-------------------- %d\\n\", tif->tif_row);\n\t\tfflush(stdout);\n#endif\n\t\tEXPAND1D(EOFRLE);\n\t\t(*sp->fill)(buf, thisrun, pa, lastx);\n\t\t/*\n\t\t * Cleanup at the end of the row.\n\t\t */\n\t\tif (mode & FAXMODE_BYTEALIGN) {\n\t\t\tint n = BitsAvail - (BitsAvail &~ 7);\n\t\t\tClrBits(n);\n\t\t} else if (mode & FAXMODE_WORDALIGN) {\n\t\t\tint n = BitsAvail - (BitsAvail &~ 15);\n\t\t\tClrBits(n);\n\t\t\tif (BitsAvail == 0 && !isAligned(cp, uint16))\n\t\t\t    cp++;\n\t\t}\n\t\tbuf += sp->b.rowbytes;\n\t\tocc -= sp->b.rowbytes;\n\t\tsp->line++;\n\t\tcontinue;\n\tEOFRLE:\t\t\t\t/* premature EOF */\n\t\t(*sp->fill)(buf, thisrun, pa, lastx);\n\t\tUNCACHE_STATE(tif, sp);\n\t\treturn (-1);\n\t}\n\tUNCACHE_STATE(tif, sp);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1554,
              0
            ],
            [
              1601,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fax3DecodeRLE",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFInitCCITTRLE(TIFF* tif, int scheme)\n{\n\t(void) scheme;\n\tif (InitCCITTFax3(tif)) {\t\t/* reuse G3 support */\n\t\ttif->tif_decoderow = Fax3DecodeRLE;\n\t\ttif->tif_decodestrip = Fax3DecodeRLE;\n\t\ttif->tif_decodetile = Fax3DecodeRLE;\n\t\t/*\n\t\t * Suppress RTC+EOLs when encoding and byte-align data.\n\t\t */\n\t\treturn TIFFSetField(tif, TIFFTAG_FAXMODE,\n\t\t    FAXMODE_NORTC|FAXMODE_NOEOL|FAXMODE_BYTEALIGN);\n\t} else\n\t\treturn (0);\n}",
          "fn_code_pos": [
            [
              1603,
              0
            ],
            [
              1618,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitCCITTRLE",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFInitCCITTRLEW(TIFF* tif, int scheme)\n{\n\t(void) scheme;\n\tif (InitCCITTFax3(tif)) {\t\t/* reuse G3 support */\n\t\ttif->tif_decoderow = Fax3DecodeRLE;\n\t\ttif->tif_decodestrip = Fax3DecodeRLE;\n\t\ttif->tif_decodetile = Fax3DecodeRLE;  \n\t\t/*\n\t\t * Suppress RTC+EOLs when encoding and word-align data.\n\t\t */\n\t\treturn TIFFSetField(tif, TIFFTAG_FAXMODE,\n\t\t    FAXMODE_NORTC|FAXMODE_NOEOL|FAXMODE_WORDALIGN);\n\t} else\n\t\treturn (0);\n}",
          "fn_code_pos": [
            [
              1620,
              0
            ],
            [
              1635,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitCCITTRLEW",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "SWAP(uint32*, sp->curruns, sp->refruns)",
          "fn_dec_pos": [
            [
              303,
              2
            ],
            [
              303,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SWAP",
            "parameters": {
              "curruns": "sp",
              "refruns": "sp"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "find0span(unsigned char*, int32, int32)",
          "fn_dec_pos": [
            [
              830,
              13
            ],
            [
              830,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find0span",
            "parameters": {},
            "return_type": "int32"
          }
        },
        {
          "fn_code": "find1span(unsigned char*, int32, int32)",
          "fn_dec_pos": [
            [
              831,
              13
            ],
            [
              831,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "find1span",
            "parameters": {},
            "return_type": "int32"
          }
        },
        {
          "fn_code": "SWAP(uint32*, sp->curruns, sp->refruns)",
          "fn_dec_pos": [
            [
              1457,
              2
            ],
            [
              1457,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SWAP",
            "parameters": {
              "curruns": "sp",
              "refruns": "sp"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\tint      rw_mode;                /* O_RDONLY for decode, else encode */\n\tint      mode;                   /* operating mode */\n\ttmsize_t rowbytes;               /* bytes in a decoded scanline */\n\tuint32   rowpixels;              /* pixels in a scanline */\n\n\tuint16   cleanfaxdata;           /* CleanFaxData tag */\n\tuint32   badfaxrun;              /* BadFaxRun tag */\n\tuint32   badfaxlines;            /* BadFaxLines tag */\n\tuint32   groupoptions;           /* Group 3/4 options tag */\n\n\tTIFFVGetMethod  vgetparent;      /* super-class method */\n\tTIFFVSetMethod  vsetparent;      /* super-class method */\n\tTIFFPrintMethod printdir;        /* super-class method */\n} Fax3BaseState;",
          {
            "rw_mode": "int",
            "mode": "int",
            "rowbytes": "tmsize_t",
            "rowpixels": "uint32",
            "cleanfaxdata": "uint16",
            "badfaxrun": "uint32",
            "badfaxlines": "uint32",
            "groupoptions": "uint32",
            "vgetparent": "TIFFVGetMethod",
            "vsetparent": "TIFFVSetMethod",
            "printdir": "TIFFPrintMethod"
          },
          "Fax3BaseState",
          [
            47,
            0
          ],
          [
            61,
            16
          ]
        ],
        [
          "typedef struct {\n\tFax3BaseState b;\n\n\t/* Decoder state info */\n\tconst unsigned char* bitmap;\t/* bit reversal table */\n\tuint32\tdata;\t\t\t/* current i/o byte/word */\n\tint\tbit;\t\t\t/* current i/o bit in byte */\n\tint\tEOLcnt;\t\t\t/* count of EOL codes recognized */\n\tTIFFFaxFillFunc fill;\t\t/* fill routine */\n\tuint32*\truns;\t\t\t/* b&w runs for current/previous row */\n\tuint32*\trefruns;\t\t/* runs for reference line */\n\tuint32*\tcurruns;\t\t/* runs for current line */\n\n\t/* Encoder state info */\n\tTtag    tag;\t\t\t/* encoding state */\n\tunsigned char*\trefline;\t/* reference line for 2d decoding */\n\tint\tk;\t\t\t/* #rows left that can be 2d encoded */\n\tint\tmaxk;\t\t\t/* max #rows that can be 2d encoded */\n\n\tint line;\n} Fax3CodecState;",
          {
            "b": "Fax3BaseState",
            "unsigned char": "const",
            "data": "uint32",
            "bit": "int",
            "EOLcnt": "int",
            "fill": "TIFFFaxFillFunc",
            "*\truns": "uint32",
            "*\trefruns": "uint32",
            "*\tcurruns": "uint32",
            "tag": "Ttag",
            "*\trefline": "unsigned char",
            "k": "int",
            "maxk": "int",
            "line": "int"
          },
          "Fax3CodecState",
          [
            65,
            0
          ],
          [
            85,
            17
          ]
        ],
        [
          "typedef struct {\n\tint      rw_mode;                /* O_RDONLY for decode, else encode */\n\tint      mode;                   /* operating mode */\n\ttmsize_t rowbytes;               /* bytes in a decoded scanline */\n\tuint32   rowpixels;              /* pixels in a scanline */\n\n\tuint16   cleanfaxdata;           /* CleanFaxData tag */\n\tuint32   badfaxrun;              /* BadFaxRun tag */\n\tuint32   badfaxlines;            /* BadFaxLines tag */\n\tuint32   groupoptions;           /* Group 3/4 options tag */\n\n\tTIFFVGetMethod  vgetparent;      /* super-class method */\n\tTIFFVSetMethod  vsetparent;      /* super-class method */\n\tTIFFPrintMethod printdir;        /* super-class method */\n} Fax3BaseState;",
          {
            "rw_mode": "int",
            "mode": "int",
            "rowbytes": "tmsize_t",
            "rowpixels": "uint32",
            "cleanfaxdata": "uint16",
            "badfaxrun": "uint32",
            "badfaxlines": "uint32",
            "groupoptions": "uint32",
            "vgetparent": "TIFFVGetMethod",
            "vsetparent": "TIFFVSetMethod",
            "printdir": "TIFFPrintMethod"
          },
          "Fax3BaseState",
          [
            47,
            0
          ],
          [
            61,
            16
          ]
        ],
        [
          "typedef struct {\n\tFax3BaseState b;\n\n\t/* Decoder state info */\n\tconst unsigned char* bitmap;\t/* bit reversal table */\n\tuint32\tdata;\t\t\t/* current i/o byte/word */\n\tint\tbit;\t\t\t/* current i/o bit in byte */\n\tint\tEOLcnt;\t\t\t/* count of EOL codes recognized */\n\tTIFFFaxFillFunc fill;\t\t/* fill routine */\n\tuint32*\truns;\t\t\t/* b&w runs for current/previous row */\n\tuint32*\trefruns;\t\t/* runs for reference line */\n\tuint32*\tcurruns;\t\t/* runs for current line */\n\n\t/* Encoder state info */\n\tTtag    tag;\t\t\t/* encoding state */\n\tunsigned char*\trefline;\t/* reference line for 2d decoding */\n\tint\tk;\t\t\t/* #rows left that can be 2d encoded */\n\tint\tmaxk;\t\t\t/* max #rows that can be 2d encoded */\n\n\tint line;\n} Fax3CodecState;",
          {
            "b": "Fax3BaseState",
            "unsigned char": "const",
            "data": "uint32",
            "bit": "int",
            "EOLcnt": "int",
            "fill": "TIFFFaxFillFunc",
            "*\truns": "uint32",
            "*\trefruns": "uint32",
            "*\tcurruns": "uint32",
            "tag": "Ttag",
            "*\trefline": "unsigned char",
            "k": "int",
            "maxk": "int",
            "line": "int"
          },
          "Fax3CodecState",
          [
            65,
            0
          ],
          [
            85,
            17
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"tif_fax3.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include \"t4.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum { G3_1D, G3_2D } Ttag;",
          {
            "G3_1D": "",
            "G3_2D": ""
          },
          "Ttag",
          [
            64,
            0
          ],
          [
            64,
            35
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_open.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\n_tiffDummyMapProc(thandle_t fd, void** pbase, toff_t* psize)\n{\n\t(void) fd; (void) pbase; (void) psize;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              37,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffDummyMapProc",
            "parameters": {
              "fd": "thandle_t",
              "pbase": "void",
              "psize": "toff_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\n_tiffDummyUnmapProc(thandle_t fd, void* base, toff_t size)\n{\n\t(void) fd; (void) base; (void) size;\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              43,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffDummyUnmapProc",
            "parameters": {
              "fd": "thandle_t",
              "base": "void",
              "size": "toff_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\n_TIFFgetMode(const char* mode, const char* module)\n{\n\tint m = -1;\n\n\tswitch (mode[0]) {\n\tcase 'r':\n\t\tm = O_RDONLY;\n\t\tif (mode[1] == '+')\n\t\t\tm = O_RDWR;\n\t\tbreak;\n\tcase 'w':\n\tcase 'a':\n\t\tm = O_RDWR|O_CREAT;\n\t\tif (mode[0] == 'w')\n\t\t\tm |= O_TRUNC;\n\t\tbreak;\n\tdefault:\n\t\tTIFFErrorExt(0, module, \"\\\"%s\\\": Bad mode\", mode);\n\t\tbreak;\n\t}\n\treturn (m);\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFgetMode",
            "parameters": {
              "mode": "char",
              "module": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFF*\nTIFFClientOpen(\n\tconst char* name, const char* mode,\n\tthandle_t clientdata,\n\tTIFFReadWriteProc readproc,\n\tTIFFReadWriteProc writeproc,\n\tTIFFSeekProc seekproc,\n\tTIFFCloseProc closeproc,\n\tTIFFSizeProc sizeproc,\n\tTIFFMapFileProc mapproc,\n\tTIFFUnmapFileProc unmapproc\n)\n{\n\tstatic const char module[] = \"TIFFClientOpen\";\n\tTIFF *tif;\n\tint m;\n\tconst char* cp;\n\n\t/* The following are configuration checks. They should be redundant, but should not\n\t * compile to any actual code in an optimised release build anyway. If any of them\n\t * fail, (makefile-based or other) configuration is not correct */\n\tassert(sizeof(uint8)==1);\n\tassert(sizeof(int8)==1);\n\tassert(sizeof(uint16)==2);\n\tassert(sizeof(int16)==2);\n\tassert(sizeof(uint32)==4);\n\tassert(sizeof(int32)==4);\n\tassert(sizeof(uint64)==8);\n\tassert(sizeof(int64)==8);\n\tassert(sizeof(tmsize_t)==sizeof(void*));\n\t{\n\t\tunion{\n\t\t\tuint8 a8[2];\n\t\t\tuint16 a16;\n\t\t} n;\n\t\tn.a8[0]=1;\n\t\tn.a8[1]=0;\n\t\t#ifdef WORDS_BIGENDIAN\n\t\tassert(n.a16==256);\n\t\t#else\n\t\tassert(n.a16==1);\n\t\t#endif\n\t}\n\n\tm = _TIFFgetMode(mode, module);\n\tif (m == -1)\n\t\tgoto bad2;\n\ttif = (TIFF *)_TIFFmalloc((tmsize_t)(sizeof (TIFF) + strlen(name) + 1));\n\tif (tif == NULL) {\n\t\tTIFFErrorExt(clientdata, module, \"%s: Out of memory (TIFF structure)\", name);\n\t\tgoto bad2;\n\t}\n\t_TIFFmemset(tif, 0, sizeof (*tif));\n\ttif->tif_name = (char *)tif + sizeof (TIFF);\n\tstrcpy(tif->tif_name, name);\n\ttif->tif_mode = m &~ (O_CREAT|O_TRUNC);\n\ttif->tif_curdir = (uint16) -1;\t\t/* non-existent directory */\n\ttif->tif_curoff = 0;\n\ttif->tif_curstrip = (uint32) -1;\t/* invalid strip */\n\ttif->tif_row = (uint32) -1;\t\t/* read/write pre-increment */\n\ttif->tif_clientdata = clientdata;\n\tif (!readproc || !writeproc || !seekproc || !closeproc || !sizeproc) {\n\t\tTIFFErrorExt(clientdata, module,\n\t\t    \"One of the client procedures is NULL pointer.\");\n\t\tgoto bad2;\n\t}\n\ttif->tif_readproc = readproc;\n\ttif->tif_writeproc = writeproc;\n\ttif->tif_seekproc = seekproc;\n\ttif->tif_closeproc = closeproc;\n\ttif->tif_sizeproc = sizeproc;\n\tif (mapproc)\n\t\ttif->tif_mapproc = mapproc;\n\telse\n\t\ttif->tif_mapproc = _tiffDummyMapProc;\n\tif (unmapproc)\n\t\ttif->tif_unmapproc = unmapproc;\n\telse\n\t\ttif->tif_unmapproc = _tiffDummyUnmapProc;\n\t_TIFFSetDefaultCompressionState(tif);    /* setup default state */\n\t/*\n\t * Default is to return data MSB2LSB and enable the\n\t * use of memory-mapped files and strip chopping when\n\t * a file is opened read-only.\n\t */\n\ttif->tif_flags = FILLORDER_MSB2LSB;\n\tif (m == O_RDONLY )\n\t\ttif->tif_flags |= TIFF_MAPPED;\n\n\t#ifdef STRIPCHOP_DEFAULT\n\tif (m == O_RDONLY || m == O_RDWR)\n\t\ttif->tif_flags |= STRIPCHOP_DEFAULT;\n\t#endif\n\n\t/*\n\t * Process library-specific flags in the open mode string.\n\t * The following flags may be used to control intrinsic library\n\t * behaviour that may or may not be desirable (usually for\n\t * compatibility with some application that claims to support\n\t * TIFF but only supports some brain dead idea of what the\n\t * vendor thinks TIFF is):\n\t *\n\t * 'l' use little-endian byte order for creating a file\n\t * 'b' use big-endian byte order for creating a file\n\t * 'L' read/write information using LSB2MSB bit order\n\t * 'B' read/write information using MSB2LSB bit order\n\t * 'H' read/write information using host bit order\n\t * 'M' enable use of memory-mapped files when supported\n\t * 'm' disable use of memory-mapped files\n\t * 'C' enable strip chopping support when reading\n\t * 'c' disable strip chopping support\n\t * 'h' read TIFF header only, do not load the first IFD\n\t * '4' ClassicTIFF for creating a file (default)\n\t * '8' BigTIFF for creating a file\n\t *\n\t * The use of the 'l' and 'b' flags is strongly discouraged.\n\t * These flags are provided solely because numerous vendors,\n\t * typically on the PC, do not correctly support TIFF; they\n\t * only support the Intel little-endian byte order.  This\n\t * support is not configured by default because it supports\n\t * the violation of the TIFF spec that says that readers *MUST*\n\t * support both byte orders.  It is strongly recommended that\n\t * you not use this feature except to deal with busted apps\n\t * that write invalid TIFF.  And even in those cases you should\n\t * bang on the vendors to fix their software.\n\t *\n\t * The 'L', 'B', and 'H' flags are intended for applications\n\t * that can optimize operations on data by using a particular\n\t * bit order.  By default the library returns data in MSB2LSB\n\t * bit order for compatibility with older versions of this\n\t * library.  Returning data in the bit order of the native CPU\n\t * makes the most sense but also requires applications to check\n\t * the value of the FillOrder tag; something they probably do\n\t * not do right now.\n\t *\n\t * The 'M' and 'm' flags are provided because some virtual memory\n\t * systems exhibit poor behaviour when large images are mapped.\n\t * These options permit clients to control the use of memory-mapped\n\t * files on a per-file basis.\n\t *\n\t * The 'C' and 'c' flags are provided because the library support\n\t * for chopping up large strips into multiple smaller strips is not\n\t * application-transparent and as such can cause problems.  The 'c'\n\t * option permits applications that only want to look at the tags,\n\t * for example, to get the unadulterated TIFF tag information.\n\t */\n\tfor (cp = mode; *cp; cp++)\n\t\tswitch (*cp) {\n\t\t\tcase 'b':\n\t\t\t\t#ifndef WORDS_BIGENDIAN\n\t\t\t\tif (m&O_CREAT)\n\t\t\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\t#ifdef WORDS_BIGENDIAN\n\t\t\t\tif ((m&O_CREAT))\n\t\t\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t\t#endif\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\ttif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |\n\t\t\t\t    FILLORDER_MSB2LSB;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\ttif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |\n\t\t\t\t    FILLORDER_LSB2MSB;\n\t\t\t\tbreak;\n\t\t\tcase 'H':\n\t\t\t\ttif->tif_flags = (tif->tif_flags &~ TIFF_FILLORDER) |\n\t\t\t\t    HOST_FILLORDER;\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags |= TIFF_MAPPED;\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags &= ~TIFF_MAPPED;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags |= TIFF_STRIPCHOP;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tif (m == O_RDONLY)\n\t\t\t\t\ttif->tif_flags &= ~TIFF_STRIPCHOP;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\ttif->tif_flags |= TIFF_HEADERONLY;\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\t\tif (m&O_CREAT)\n\t\t\t\t\ttif->tif_flags |= TIFF_BIGTIFF;\n\t\t\t\tbreak;\n\t\t}\n\t/*\n\t * Read in TIFF header.\n\t */\n\tif ((m & O_TRUNC) ||\n\t    !ReadOK(tif, &tif->tif_header, sizeof (TIFFHeaderClassic))) {\n\t\tif (tif->tif_mode == O_RDONLY) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Cannot read TIFF header\");\n\t\t\tgoto bad;\n\t\t}\n\t\t/*\n\t\t * Setup header and write.\n\t\t */\n\t\t#ifdef WORDS_BIGENDIAN\n\t\ttif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)\n\t\t    ? TIFF_LITTLEENDIAN : TIFF_BIGENDIAN;\n\t\t#else\n\t\ttif->tif_header.common.tiff_magic = (tif->tif_flags & TIFF_SWAB)\n\t\t    ? TIFF_BIGENDIAN : TIFF_LITTLEENDIAN;\n\t\t#endif\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\ttif->tif_header.common.tiff_version = TIFF_VERSION_CLASSIC;\n\t\t\ttif->tif_header.classic.tiff_diroff = 0;\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&tif->tif_header.common.tiff_version);\n\t\t\ttif->tif_header_size = sizeof(TIFFHeaderClassic);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttif->tif_header.common.tiff_version = TIFF_VERSION_BIG;\n\t\t\ttif->tif_header.big.tiff_offsetsize = 8;\n\t\t\ttif->tif_header.big.tiff_unused = 0;\n\t\t\ttif->tif_header.big.tiff_diroff = 0;\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t{\n\t\t\t\tTIFFSwabShort(&tif->tif_header.common.tiff_version);\n\t\t\t\tTIFFSwabShort(&tif->tif_header.big.tiff_offsetsize);\n\t\t\t}\n\t\t\ttif->tif_header_size = sizeof (TIFFHeaderBig);\n\t\t}\n\t\t/*\n\t\t * The doc for \"fopen\" for some STD_C_LIBs says that if you\n\t\t * open a file for modify (\"+\"), then you must fseek (or\n\t\t * fflush?) between any freads and fwrites.  This is not\n\t\t * necessary on most systems, but has been shown to be needed\n\t\t * on Solaris.\n\t\t */\n\t\tTIFFSeekFile( tif, 0, SEEK_SET );\n\t\tif (!WriteOK(tif, &tif->tif_header, (tmsize_t)(tif->tif_header_size))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t\t    \"Error writing TIFF header\");\n\t\t\tgoto bad;\n\t\t}\n\t\t/*\n\t\t * Setup the byte order handling.\n\t\t */\n\t\tif (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {\n\t\t\t#ifndef WORDS_BIGENDIAN\n\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t#endif\n\t\t} else {\n\t\t\t#ifdef WORDS_BIGENDIAN\n\t\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t\t#endif\n\t\t}\n\t\t/*\n\t\t * Setup default directory.\n\t\t */\n\t\tif (!TIFFDefaultDirectory(tif))\n\t\t\tgoto bad;\n\t\ttif->tif_diroff = 0;\n\t\ttif->tif_dirlist = NULL;\n\t\ttif->tif_dirlistsize = 0;\n\t\ttif->tif_dirnumber = 0;\n\t\treturn (tif);\n\t}\n\t/*\n\t * Setup the byte order handling.\n\t */\n\tif (tif->tif_header.common.tiff_magic != TIFF_BIGENDIAN &&\n\t    tif->tif_header.common.tiff_magic != TIFF_LITTLEENDIAN\n\t    #if MDI_SUPPORT\n\t    &&\n\t    #if HOST_BIGENDIAN\n\t    tif->tif_header.common.tiff_magic != MDI_BIGENDIAN\n\t    #else\n\t    tif->tif_header.common.tiff_magic != MDI_LITTLEENDIAN\n\t    #endif\n\t    ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t    \"Not a TIFF or MDI file, bad magic number %d (0x%x)\",\n\t    #else\n\t    ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, name,\n\t\t    \"Not a TIFF file, bad magic number %d (0x%x)\",\n\t    #endif\n\t\t    tif->tif_header.common.tiff_magic,\n\t\t    tif->tif_header.common.tiff_magic);\n\t\tgoto bad;\n\t}\n\tif (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN) {\n\t\t#ifndef WORDS_BIGENDIAN\n\t\ttif->tif_flags |= TIFF_SWAB;\n\t\t#endif\n\t}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              370,
              2
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFClientOpen",
            "parameters": {
              "name": "char",
              "mode": "char",
              "clientdata": "thandle_t",
              "readproc": "TIFFReadWriteProc",
              "writeproc": "TIFFReadWriteProc",
              "seekproc": "TIFFSeekProc",
              "closeproc": "TIFFCloseProc",
              "sizeproc": "TIFFSizeProc",
              "mapproc": "TIFFMapFileProc",
              "unmapproc": "TIFFUnmapFileProc"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "const char *\nTIFFFileName(TIFF* tif)\n{\n\treturn (tif->tif_name);\n}",
          "fn_code_pos": [
            [
              493,
              0
            ],
            [
              497,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFileName",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "const char *\nTIFFSetFileName(TIFF* tif, const char *name)\n{\n\tconst char* old_name = tif->tif_name;\n\ttif->tif_name = (char *)name;\n\treturn (old_name);\n}",
          "fn_code_pos": [
            [
              502,
              0
            ],
            [
              508,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetFileName",
            "parameters": {
              "tif": "TIFF",
              "name": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int\nTIFFFileno(TIFF* tif)\n{\n\treturn (tif->tif_fd);\n}",
          "fn_code_pos": [
            [
              513,
              0
            ],
            [
              517,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFileno",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFSetFileno(TIFF* tif, int fd)\n{\n        int old_fd = tif->tif_fd;\n\ttif->tif_fd = fd;\n\treturn old_fd;\n}",
          "fn_code_pos": [
            [
              522,
              0
            ],
            [
              528,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetFileno",
            "parameters": {
              "tif": "TIFF",
              "fd": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "thandle_t\nTIFFClientdata(TIFF* tif)\n{\n\treturn (tif->tif_clientdata);\n}",
          "fn_code_pos": [
            [
              533,
              0
            ],
            [
              537,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFClientdata",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "thandle_t"
          }
        },
        {
          "fn_code": "thandle_t\nTIFFSetClientdata(TIFF* tif, thandle_t newvalue)\n{\n\tthandle_t m = tif->tif_clientdata;\n\ttif->tif_clientdata = newvalue;\n\treturn m;\n}",
          "fn_code_pos": [
            [
              542,
              0
            ],
            [
              548,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetClientdata",
            "parameters": {
              "tif": "TIFF",
              "newvalue": "thandle_t"
            },
            "return_type": "thandle_t"
          }
        },
        {
          "fn_code": "int\nTIFFGetMode(TIFF* tif)\n{\n\treturn (tif->tif_mode);\n}",
          "fn_code_pos": [
            [
              553,
              0
            ],
            [
              557,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetMode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFSetMode(TIFF* tif, int mode)\n{\n\tint old_mode = tif->tif_mode;\n\ttif->tif_mode = mode;\n\treturn (old_mode);\n}",
          "fn_code_pos": [
            [
              562,
              0
            ],
            [
              568,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetMode",
            "parameters": {
              "tif": "TIFF",
              "mode": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFIsTiled(TIFF* tif)\n{\n\treturn (isTiled(tif));\n}",
          "fn_code_pos": [
            [
              574,
              0
            ],
            [
              578,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFIsTiled",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "uint32\nTIFFCurrentRow(TIFF* tif)\n{\n\treturn (tif->tif_row);\n}",
          "fn_code_pos": [
            [
              583,
              0
            ],
            [
              587,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCurrentRow",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "uint16\nTIFFCurrentDirectory(TIFF* tif)\n{\n\treturn (tif->tif_curdir);\n}",
          "fn_code_pos": [
            [
              592,
              0
            ],
            [
              596,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCurrentDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint16"
          }
        },
        {
          "fn_code": "uint32\nTIFFCurrentStrip(TIFF* tif)\n{\n\treturn (tif->tif_curstrip);\n}",
          "fn_code_pos": [
            [
              601,
              0
            ],
            [
              605,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCurrentStrip",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "uint32\nTIFFCurrentTile(TIFF* tif)\n{\n\treturn (tif->tif_curtile);\n}",
          "fn_code_pos": [
            [
              610,
              0
            ],
            [
              614,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCurrentTile",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "int\nTIFFIsByteSwapped(TIFF* tif)\n{\n\treturn ((tif->tif_flags & TIFF_SWAB) != 0);\n}",
          "fn_code_pos": [
            [
              619,
              0
            ],
            [
              623,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFIsByteSwapped",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFIsUpSampled(TIFF* tif)\n{\n\treturn (isUpSampled(tif));\n}",
          "fn_code_pos": [
            [
              628,
              0
            ],
            [
              632,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFIsUpSampled",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFIsMSB2LSB(TIFF* tif)\n{\n\treturn (isFillOrder(tif, FILLORDER_MSB2LSB));\n}",
          "fn_code_pos": [
            [
              637,
              0
            ],
            [
              641,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFIsMSB2LSB",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFIsBigEndian(TIFF* tif)\n{\n\treturn (tif->tif_header.common.tiff_magic == TIFF_BIGENDIAN);\n}",
          "fn_code_pos": [
            [
              646,
              0
            ],
            [
              650,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFIsBigEndian",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFReadWriteProc\nTIFFGetReadProc(TIFF* tif)\n{\n\treturn (tif->tif_readproc);\n}",
          "fn_code_pos": [
            [
              655,
              0
            ],
            [
              659,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetReadProc",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "TIFFReadWriteProc"
          }
        },
        {
          "fn_code": "TIFFReadWriteProc\nTIFFGetWriteProc(TIFF* tif)\n{\n\treturn (tif->tif_writeproc);\n}",
          "fn_code_pos": [
            [
              664,
              0
            ],
            [
              668,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetWriteProc",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "TIFFReadWriteProc"
          }
        },
        {
          "fn_code": "TIFFSeekProc\nTIFFGetSeekProc(TIFF* tif)\n{\n\treturn (tif->tif_seekproc);\n}",
          "fn_code_pos": [
            [
              673,
              0
            ],
            [
              677,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetSeekProc",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "TIFFSeekProc"
          }
        },
        {
          "fn_code": "TIFFCloseProc\nTIFFGetCloseProc(TIFF* tif)\n{\n\treturn (tif->tif_closeproc);\n}",
          "fn_code_pos": [
            [
              682,
              0
            ],
            [
              686,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetCloseProc",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "TIFFCloseProc"
          }
        },
        {
          "fn_code": "TIFFSizeProc\nTIFFGetSizeProc(TIFF* tif)\n{\n\treturn (tif->tif_sizeproc);\n}",
          "fn_code_pos": [
            [
              691,
              0
            ],
            [
              695,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetSizeProc",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "TIFFSizeProc"
          }
        },
        {
          "fn_code": "TIFFMapFileProc\nTIFFGetMapFileProc(TIFF* tif)\n{\n\treturn (tif->tif_mapproc);\n}",
          "fn_code_pos": [
            [
              700,
              0
            ],
            [
              704,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetMapFileProc",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "TIFFMapFileProc"
          }
        },
        {
          "fn_code": "TIFFUnmapFileProc\nTIFFGetUnmapFileProc(TIFF* tif)\n{\n\treturn (tif->tif_unmapproc);\n}",
          "fn_code_pos": [
            [
              709,
              0
            ],
            [
              713,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetUnmapFileProc",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "TIFFUnmapFileProc"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFClientOpen(\n\tconst char* name, const char* mode,\n\tthandle_t clientdata,\n\tTIFFReadWriteProc readproc,\n\tTIFFReadWriteProc writeproc,\n\tTIFFSeekProc seekproc,\n\tTIFFCloseProc closeproc,\n\tTIFFSizeProc sizeproc,\n\tTIFFMapFileProc mapproc,\n\tTIFFUnmapFileProc unmapproc\n)",
          "fn_dec_pos": [
            [
              70,
              0
            ],
            [
              80,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFClientOpen",
            "parameters": {
              "name": "char",
              "mode": "char",
              "clientdata": "thandle_t",
              "readproc": "TIFFReadWriteProc",
              "writeproc": "TIFFReadWriteProc",
              "seekproc": "TIFFSeekProc",
              "closeproc": "TIFFCloseProc",
              "sizeproc": "TIFFSizeProc",
              "mapproc": "TIFFMapFileProc",
              "unmapproc": "TIFFUnmapFileProc"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFFileName(TIFF* tif)",
          "fn_dec_pos": [
            [
              494,
              0
            ],
            [
              494,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFileName",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFSetFileName(TIFF* tif, const char *name)",
          "fn_dec_pos": [
            [
              503,
              0
            ],
            [
              503,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetFileName",
            "parameters": {
              "tif": "TIFF",
              "name": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_tile.c": {
      "fn_def_list": [
        {
          "fn_code": "uint32\nTIFFComputeTile(TIFF* tif, uint32 x, uint32 y, uint32 z, uint16 s)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 dx = td->td_tilewidth;\n\tuint32 dy = td->td_tilelength;\n\tuint32 dz = td->td_tiledepth;\n\tuint32 tile = 1;\n\n\tif (td->td_imagedepth == 1)\n\t\tz = 0;\n\tif (dx == (uint32) -1)\n\t\tdx = td->td_imagewidth;\n\tif (dy == (uint32) -1)\n\t\tdy = td->td_imagelength;\n\tif (dz == (uint32) -1)\n\t\tdz = td->td_imagedepth;\n\tif (dx != 0 && dy != 0 && dz != 0) {\n\t\tuint32 xpt = TIFFhowmany_32(td->td_imagewidth, dx);\n\t\tuint32 ypt = TIFFhowmany_32(td->td_imagelength, dy);\n\t\tuint32 zpt = TIFFhowmany_32(td->td_imagedepth, dz);\n\n\t\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE) \n\t\t\ttile = (xpt*ypt*zpt)*s +\n\t\t\t     (xpt*ypt)*(z/dz) +\n\t\t\t     xpt*(y/dy) +\n\t\t\t     x/dx;\n\t\telse\n\t\t\ttile = (xpt*ypt)*(z/dz) + xpt*(y/dy) + x/dx;\n\t}\n\treturn (tile);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFComputeTile",
            "parameters": {
              "tif": "TIFF",
              "x": "uint32",
              "y": "uint32",
              "z": "uint32",
              "s": "uint16"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "int\nTIFFCheckTile(TIFF* tif, uint32 x, uint32 y, uint32 z, uint16 s)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\tif (x >= td->td_imagewidth) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"%lu: Col out of range, max %lu\",\n\t\t\t     (unsigned long) x,\n\t\t\t     (unsigned long) (td->td_imagewidth - 1));\n\t\treturn (0);\n\t}\n\tif (y >= td->td_imagelength) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"%lu: Row out of range, max %lu\",\n\t\t\t     (unsigned long) y,\n\t\t\t     (unsigned long) (td->td_imagelength - 1));\n\t\treturn (0);\n\t}\n\tif (z >= td->td_imagedepth) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"%lu: Depth out of range, max %lu\",\n\t\t\t     (unsigned long) z,\n\t\t\t     (unsigned long) (td->td_imagedepth - 1));\n\t\treturn (0);\n\t}\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE &&\n\t    s >= td->td_samplesperpixel) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"%lu: Sample out of range, max %lu\",\n\t\t\t     (unsigned long) s,\n\t\t\t     (unsigned long) (td->td_samplesperpixel - 1));\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              71,
              0
            ],
            [
              106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCheckTile",
            "parameters": {
              "tif": "TIFF",
              "x": "uint32",
              "y": "uint32",
              "z": "uint32",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "uint32\nTIFFNumberOfTiles(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 dx = td->td_tilewidth;\n\tuint32 dy = td->td_tilelength;\n\tuint32 dz = td->td_tiledepth;\n\tuint32 ntiles;\n\n\tif (dx == (uint32) -1)\n\t\tdx = td->td_imagewidth;\n\tif (dy == (uint32) -1)\n\t\tdy = td->td_imagelength;\n\tif (dz == (uint32) -1)\n\t\tdz = td->td_imagedepth;\n\tntiles = (dx == 0 || dy == 0 || dz == 0) ? 0 :\n\t    _TIFFMultiply32(tif, _TIFFMultiply32(tif, TIFFhowmany_32(td->td_imagewidth, dx),\n\t    TIFFhowmany_32(td->td_imagelength, dy),\n\t    \"TIFFNumberOfTiles\"),\n\t    TIFFhowmany_32(td->td_imagedepth, dz), \"TIFFNumberOfTiles\");\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tntiles = _TIFFMultiply32(tif, ntiles, td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfTiles\");\n\treturn (ntiles);\n}",
          "fn_code_pos": [
            [
              111,
              0
            ],
            [
              135,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFNumberOfTiles",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "uint64\nTIFFTileRowSize64(TIFF* tif)\n{\n        static const char module[] = \"TIFFTileRowSize64\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64 rowsize;\n\tuint64 tilerowsize;\n\n\tif (td->td_tilelength == 0)\n        {\n                TIFFErrorExt(tif->tif_clientdata,module,\"Tile length is zero\");\n                return 0;\n        }\n        if (td->td_tilewidth == 0)\n        {\n                TIFFErrorExt(tif->tif_clientdata,module,\"Tile width is zero\");\n\t\treturn (0);\n        }\n\trowsize = _TIFFMultiply64(tif, td->td_bitspersample, td->td_tilewidth,\n\t    \"TIFFTileRowSize\");\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG)\n        {\n                if (td->td_samplesperpixel == 0)\n                {\n                        TIFFErrorExt(tif->tif_clientdata,module,\"Samples per pixel is zero\");\n                        return 0;\n                }\n\t\trowsize = _TIFFMultiply64(tif, rowsize, td->td_samplesperpixel,\n\t\t    \"TIFFTileRowSize\");\n        }\n        tilerowsize=TIFFhowmany8_64(rowsize);\n        if (tilerowsize == 0)\n        {\n                TIFFErrorExt(tif->tif_clientdata,module,\"Computed tile row size is zero\");\n                return 0;\n        }\n\treturn (tilerowsize);\n}",
          "fn_code_pos": [
            [
              140,
              0
            ],
            [
              177,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFTileRowSize64",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFTileRowSize(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFTileRowSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFTileRowSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}",
          "fn_code_pos": [
            [
              178,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFTileRowSize",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "uint64\nTIFFVTileSize64(TIFF* tif, uint32 nrows)\n{\n\tstatic const char module[] = \"TIFFVTileSize64\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tif (td->td_tilelength == 0 || td->td_tilewidth == 0 ||\n\t    td->td_tiledepth == 0)\n\t\treturn (0);\n\tif ((td->td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (td->td_photometric==PHOTOMETRIC_YCBCR)&&\n\t    (td->td_samplesperpixel==3)&&\n\t    (!isUpSampled(tif)))\n\t{\n\t\t/*\n\t\t * Packed YCbCr data contain one Cb+Cr for every\n\t\t * HorizontalSampling*VerticalSampling Y values.\n\t\t * Must also roundup width and height when calculating\n\t\t * since images that are not a multiple of the\n\t\t * horizontal/vertical subsampling area include\n\t\t * YCbCr data for the extended image.\n\t\t */\n\t\tuint16 ycbcrsubsampling[2];\n\t\tuint16 samplingblock_samples;\n\t\tuint32 samplingblocks_hor;\n\t\tuint32 samplingblocks_ver;\n\t\tuint64 samplingrow_samples;\n\t\tuint64 samplingrow_size;\n\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_YCBCRSUBSAMPLING,ycbcrsubsampling+0,\n\t\t    ycbcrsubsampling+1);\n\t\tif ((ycbcrsubsampling[0] != 1 && ycbcrsubsampling[0] != 2 && ycbcrsubsampling[0] != 4)\n\t\t    ||(ycbcrsubsampling[1] != 1 && ycbcrsubsampling[1] != 2 && ycbcrsubsampling[1] != 4))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t\t     \"Invalid YCbCr subsampling (%dx%d)\", \n\t\t\t\t     ycbcrsubsampling[0], \n\t\t\t\t     ycbcrsubsampling[1] );\n\t\t\treturn 0;\n\t\t}\n\t\tsamplingblock_samples=ycbcrsubsampling[0]*ycbcrsubsampling[1]+2;\n\t\tsamplingblocks_hor=TIFFhowmany_32(td->td_tilewidth,ycbcrsubsampling[0]);\n\t\tsamplingblocks_ver=TIFFhowmany_32(nrows,ycbcrsubsampling[1]);\n\t\tsamplingrow_samples=_TIFFMultiply64(tif,samplingblocks_hor,samplingblock_samples,module);\n\t\tsamplingrow_size=TIFFhowmany8_64(_TIFFMultiply64(tif,samplingrow_samples,td->td_bitspersample,module));\n\t\treturn(_TIFFMultiply64(tif,samplingrow_size,samplingblocks_ver,module));\n\t}\n\telse\n\t\treturn(_TIFFMultiply64(tif,nrows,TIFFTileRowSize64(tif),module));\n}",
          "fn_code_pos": [
            [
              197,
              0
            ],
            [
              244,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFVTileSize64",
            "parameters": {
              "tif": "TIFF",
              "nrows": "uint32"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFVTileSize(TIFF* tif, uint32 nrows)\n{\n\tstatic const char module[] = \"TIFFVTileSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFVTileSize64(tif,nrows);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}",
          "fn_code_pos": [
            [
              245,
              0
            ],
            [
              259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFVTileSize",
            "parameters": {
              "tif": "TIFF",
              "nrows": "uint32"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "uint64\nTIFFTileSize64(TIFF* tif)\n{\n\treturn (TIFFVTileSize64(tif, tif->tif_dir.td_tilelength));\n}",
          "fn_code_pos": [
            [
              264,
              0
            ],
            [
              268,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFTileSize64",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFTileSize(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFTileSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFTileSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}",
          "fn_code_pos": [
            [
              269,
              0
            ],
            [
              283,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFTileSize",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "void\nTIFFDefaultTileSize(TIFF* tif, uint32* tw, uint32* th)\n{\n\t(*tif->tif_deftilesize)(tif, tw, th);\n}",
          "fn_code_pos": [
            [
              291,
              0
            ],
            [
              295,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFDefaultTileSize",
            "parameters": {
              "tif": "TIFF",
              "tw": "uint32",
              "th": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\n_TIFFDefaultTileSize(TIFF* tif, uint32* tw, uint32* th)\n{\n\t(void) tif;\n\tif (*(int32*) tw < 1)\n\t\t*tw = 256;\n\tif (*(int32*) th < 1)\n\t\t*th = 256;\n\t/* roundup to a multiple of 16 per the spec */\n\tif (*tw & 0xf)\n\t\t*tw = TIFFroundup_32(*tw, 16);\n\tif (*th & 0xf)\n\t\t*th = TIFFroundup_32(*th, 16);\n}",
          "fn_code_pos": [
            [
              297,
              0
            ],
            [
              310,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFDefaultTileSize",
            "parameters": {
              "tif": "TIFF",
              "tw": "uint32",
              "th": "uint32"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_dirread.c": {
      "fn_def_list": [
        {
          "fn_code": "static uint64 TIFFReadUInt64(const uint8 *value)\n{\n\tUInt64Aligned_t result;\n\n\tresult.c[0]=value[0];\n\tresult.c[1]=value[1];\n\tresult.c[2]=value[2];\n\tresult.c[3]=value[3];\n\tresult.c[4]=value[4];\n\tresult.c[5]=value[5];\n\tresult.c[6]=value[6];\n\tresult.c[7]=value[7];\n\n\treturn result.l;\n}",
          "fn_code_pos": [
            [
              184,
              0
            ],
            [
              198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadUInt64",
            "parameters": {
              "value": "uint8"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryByte(TIFF* tif, TIFFDirEntry* direntry, uint8* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,value);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSbyte(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint8)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeByteShort(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint8)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSshort(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint8)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeByteLong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint8)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSlong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint8)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeByteLong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint8)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSlong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint8)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
          "fn_code_pos": [
            [
              200,
              0
            ],
            [
              287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryByte",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,&m);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSbyte(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,value);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSshort(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint16)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
          "fn_code_pos": [
            [
              289,
              0
            ],
            [
              373,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryShort",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,&m);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSbyte(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,&m);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSshort(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,value);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSlong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongLong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSlong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint32)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
          "fn_code_pos": [
            [
              375,
              0
            ],
            [
              456,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryLong",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8(TIFF* tif, TIFFDirEntry* direntry, uint64* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,&m);\n\t\t\t\t*value=(uint64)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Sbyte(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint64)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,&m);\n\t\t\t\t*value=(uint64)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Sshort(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint64)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,&m);\n\t\t\t\t*value=(uint64)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Slong(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint64)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,value);\n\t\t\treturn(err);\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Slong8(m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(uint64)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
          "fn_code_pos": [
            [
              458,
              0
            ],
            [
              534,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryLong8",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryFloat(TIFF* tif, TIFFDirEntry* direntry, float* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,&m);\n\t\t\t\t*value=(float)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\t*value=(float)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,&m);\n\t\t\t\t*value=(float)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\t*value=(float)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,&m);\n\t\t\t\t*value=(float)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\t*value=(float)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n#if defined(__WIN32__) && (_MSC_VER < 1500)\n\t\t\t\t/*\n\t\t\t\t * XXX: MSVC 6.0 does not support conversion\n\t\t\t\t * of 64-bit integers into floating point\n\t\t\t\t * values.\n\t\t\t\t */\n\t\t\t\t*value = _TIFFUInt64ToFloat(m);\n#else\n\t\t\t\t*value=(float)m;\n#endif\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(float)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_RATIONAL:\n\t\t\t{\n\t\t\t\tdouble m;\n\t\t\t\terr=TIFFReadDirEntryCheckedRational(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(float)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SRATIONAL:\n\t\t\t{\n\t\t\t\tdouble m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSrational(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(float)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_FLOAT:\n\t\t\tTIFFReadDirEntryCheckedFloat(tif,direntry,value);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble m;\n\t\t\t\terr=TIFFReadDirEntryCheckedDouble(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\tif ((m > FLT_MAX) || (m < FLT_MIN))\n\t\t\t\t\treturn(TIFFReadDirEntryErrRange);\n\t\t\t\t*value=(float)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
          "fn_code_pos": [
            [
              536,
              0
            ],
            [
              647,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryFloat",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "float"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryDouble(TIFF* tif, TIFFDirEntry* direntry, double* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedByte(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8 m;\n\t\t\t\tTIFFReadDirEntryCheckedSbyte(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedShort(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16 m;\n\t\t\t\tTIFFReadDirEntryCheckedSshort(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedSlong(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n#if defined(__WIN32__) && (_MSC_VER < 1500)\n\t\t\t\t/*\n\t\t\t\t * XXX: MSVC 6.0 does not support conversion\n\t\t\t\t * of 64-bit integers into floating point\n\t\t\t\t * values.\n\t\t\t\t */\n\t\t\t\t*value = _TIFFUInt64ToDouble(m);\n#else\n\t\t\t\t*value = (double)m;\n#endif\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64 m;\n\t\t\t\terr=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);\n\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\treturn(err);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_RATIONAL:\n\t\t\terr=TIFFReadDirEntryCheckedRational(tif,direntry,value);\n\t\t\treturn(err);\n\t\tcase TIFF_SRATIONAL:\n\t\t\terr=TIFFReadDirEntryCheckedSrational(tif,direntry,value);\n\t\t\treturn(err);\n\t\tcase TIFF_FLOAT:\n\t\t\t{\n\t\t\t\tfloat m;\n\t\t\t\tTIFFReadDirEntryCheckedFloat(tif,direntry,&m);\n\t\t\t\t*value=(double)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_DOUBLE:\n\t\t\terr=TIFFReadDirEntryCheckedDouble(tif,direntry,value);\n\t\t\treturn(err);\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
          "fn_code_pos": [
            [
              649,
              0
            ],
            [
              744,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryDouble",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8(TIFF* tif, TIFFDirEntry* direntry, uint64* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tif (direntry->tdir_count!=1)\n\t\treturn(TIFFReadDirEntryErrCount);\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_IFD:\n\t\t\t{\n\t\t\t\tuint32 m;\n\t\t\t\tTIFFReadDirEntryCheckedLong(tif,direntry,&m);\n\t\t\t\t*value=(uint64)m;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_IFD8:\n\t\t\terr=TIFFReadDirEntryCheckedLong8(tif,direntry,value);\n\t\t\treturn(err);\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n}",
          "fn_code_pos": [
            [
              746,
              0
            ],
            [
              768,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryIfd8",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryDataAndRealloc(\n                    TIFF* tif, uint64 offset, tmsize_t size, void** pdest)\n{\n#if SIZEOF_SIZE_T == 8\n        tmsize_t threshold = INITIAL_THRESHOLD;\n#endif\n        tmsize_t already_read = 0;\n\n        assert( !isMapped(tif) );\n\n        if (!SeekOK(tif,offset))\n                return(TIFFReadDirEntryErrIo);\n\n        /* On 64 bit processes, read first a maximum of 1 MB, then 10 MB, etc */\n        /* so as to avoid allocating too much memory in case the file is too */\n        /* short. We could ask for the file size, but this might be */\n        /* expensive with some I/O layers (think of reading a gzipped file) */\n        /* Restrict to 64 bit processes, so as to avoid reallocs() */\n        /* on 32 bit processes where virtual memory is scarce.  */\n        while( already_read < size )\n        {\n            void* new_dest;\n            tmsize_t bytes_read;\n            tmsize_t to_read = size - already_read;\n#if SIZEOF_SIZE_T == 8\n            if( to_read >= threshold && threshold < MAX_THRESHOLD )\n            {\n                to_read = threshold;\n                threshold *= THRESHOLD_MULTIPLIER;\n            }\n#endif\n\n            new_dest = (uint8*) _TIFFrealloc(\n                            *pdest, already_read + to_read);\n            if( new_dest == NULL )\n            {\n                TIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n                            \"Failed to allocate memory for %s \"\n                            \"(%ld elements of %ld bytes each)\",\n                            \"TIFFReadDirEntryArray\",\n                             (long) 1, (long) (already_read + to_read));\n                return TIFFReadDirEntryErrAlloc;\n            }\n            *pdest = new_dest;\n\n            bytes_read = TIFFReadFile(tif,\n                (char*)*pdest + already_read, to_read);\n            already_read += bytes_read;\n            if (bytes_read != to_read) {\n                return TIFFReadDirEntryErrIo;\n            }\n        }\n        return TIFFReadDirEntryErrOk;\n}",
          "fn_code_pos": [
            [
              775,
              0
            ],
            [
              828,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryDataAndRealloc",
            "parameters": {
              "tif": "TIFF",
              "offset": "uint64",
              "size": "tmsize_t",
              "pdest": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(\n    TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize,\n    void** value, uint64 maxcount)\n{\n\tint typesize;\n\tuint32 datasize;\n\tvoid* data;\n        uint64 target_count64;\n\ttypesize=TIFFDataWidth(direntry->tdir_type);\n\n        target_count64 = (direntry->tdir_count > maxcount) ?\n                maxcount : direntry->tdir_count;\n\n\tif ((target_count64==0)||(typesize==0))\n\t{\n\t\t*value=0;\n\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n        (void) desttypesize;\n\n        /* \n         * As a sanity check, make sure we have no more than a 2GB tag array \n         * in either the current data type or the dest data type.  This also\n         * avoids problems with overflow of tmsize_t on 32bit systems.\n         */\n\tif ((uint64)(2147483647/typesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\tif ((uint64)(2147483647/desttypesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\n\t*count=(uint32)target_count64;\n\tdatasize=(*count)*typesize;\n\tassert((tmsize_t)datasize>0);\n\n\tif( isMapped(tif) && datasize > (uint32)tif->tif_size )\n\t\treturn TIFFReadDirEntryErrIo;\n\n\tif( !isMapped(tif) &&\n\t\t(((tif->tif_flags&TIFF_BIGTIFF) && datasize > 8) ||\n\t\t(!(tif->tif_flags&TIFF_BIGTIFF) && datasize > 4)) )\n\t{\n\t\tdata = NULL;\n\t}\n\telse\n\t{\n\t\tdata=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\n\t\tif (data==0)\n\t\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tif (datasize<=4)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (datasize<=8)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint64 offset = direntry->tdir_offset.toff_long8;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              830,
              0
            ],
            [
              923,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryArrayWithLimit",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "count": "uint32",
              "desttypesize": "uint32",
              "value": "void",
              "maxcount": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value)\n{\n    return TIFFReadDirEntryArrayWithLimit(tif, direntry, count,\n                                          desttypesize, value, ~((uint64)0));\n}",
          "fn_code_pos": [
            [
              925,
              0
            ],
            [
              929,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "count": "uint32",
              "desttypesize": "uint32",
              "value": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint8* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,1,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\n\t\tcase TIFF_BYTE:\n\t\t\t*value=(uint8*)origdata;\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(int8*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSbyte(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(uint8*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t}\n\tdata=(uint8*)_TIFFmalloc(count);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteShort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSshort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteLong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSlong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteLong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tuint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeByteSlong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              931,
              0
            ],
            [
              1110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryByteArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntrySbyteArray(TIFF* tif, TIFFDirEntry* direntry, int8** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tint8* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_UNDEFINED:\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,1,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_UNDEFINED:\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(uint8*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeSbyteByte(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(int8*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SBYTE:\n\t\t\t*value=(int8*)origdata;\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n\tdata=(int8*)_TIFFmalloc(count);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeSbyteShort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(int8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeSbyteSshort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(int8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeSbyteLong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(int8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeSbyteSlong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(int8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeSbyteLong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(int8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tint8* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeSbyteSlong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(int8)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              1112,
              0
            ],
            [
              1289,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntrySbyteArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "int8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEntry* direntry, uint16** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint16* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,2,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_SHORT:\n\t\t\t*value=(uint16*)origdata;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfShort(*value,count);  \n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(int16*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)m);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSshort(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(uint16*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t}\n\tdata=(uint16*)_TIFFmalloc(count*2);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSbyte(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortLong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tuint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeShortSlong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              1291,
              0
            ],
            [
              1461,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryShortArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntrySshortArray(TIFF* tif, TIFFDirEntry* direntry, int16** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tint16* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,2,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(uint16*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(m);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeSshortShort(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(int16*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SSHORT:\n\t\t\t*value=(int16*)origdata;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfShort((uint16*)(*value),count);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n\tdata=(int16*)_TIFFmalloc(count*2);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(int16)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(int16)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeSshortLong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(int16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeSshortSlong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(int16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeSshortLong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(int16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tint16* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeSshortSlong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(int16)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              1463,
              0
            ],
            [
              1628,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntrySshortArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "int16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLongArray(TIFF* tif, TIFFDirEntry* direntry, uint32** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint32* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,4,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_LONG:\n\t\t\t*value=(uint32*)origdata;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfLong(*value,count);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(int32*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)m);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSlong(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(uint32*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t}\n\tdata=(uint32*)_TIFFmalloc(count*4);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tuint32* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(uint32)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tuint32* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSbyte(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint32)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tuint32* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\t*mb++=(uint32)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tuint32* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSshort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint32)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tuint32* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLongLong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint32)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tuint32* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLongSlong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint32)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              1630,
              0
            ],
            [
              1797,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryLongArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntrySlongArray(TIFF* tif, TIFFDirEntry* direntry, int32** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tint32* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,4,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(uint32*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)m);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeSlongLong(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(int32*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG:\n\t\t\t*value=(int32*)origdata;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfLong((uint32*)(*value),count);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n\tdata=(int32*)_TIFFmalloc(count*4);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tint32* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(int32)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tint32* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(int32)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tint32* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\t*mb++=(int32)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tint32* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\t*mb++=(int32)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tint32* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeSlongLong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(int32)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tint32* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeSlongSlong8(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(int32)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              1799,
              0
            ],
            [
              1958,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntrySlongArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8ArrayWithLimit(\n        TIFF* tif, TIFFDirEntry* direntry, uint64** value, uint64 maxcount)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint64* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArrayWithLimit(tif,direntry,&count,8,&origdata,maxcount);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_LONG8:\n\t\t\t*value=(uint64*)origdata;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfLong8(*value,count);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(int64*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)m);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Slong8(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(uint64*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t}\n\tdata=(uint64*)_TIFFmalloc(count*8);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Sbyte(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Sshort(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeLong8Slong(*ma);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\t_TIFFfree(data);\n\t\treturn(err);\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              1960,
              0
            ],
            [
              2125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryLong8ArrayWithLimit",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint64",
              "maxcount": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)\n{\n    return TIFFReadDirEntryLong8ArrayWithLimit(tif, direntry, value, ~((uint64)0));\n}",
          "fn_code_pos": [
            [
              2127,
              0
            ],
            [
              2130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryLong8Array",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntrySlong8Array(TIFF* tif, TIFFDirEntry* direntry, int64** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tint64* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,8,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* m;\n\t\t\t\tuint32 n;\n\t\t\t\tm=(uint64*)origdata;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(m);\n\t\t\t\t\terr=TIFFReadDirEntryCheckRangeSlong8Long8(*m);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\t_TIFFfree(origdata);\n\t\t\t\t\t\treturn(err);\n\t\t\t\t\t}\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\t*value=(int64*)origdata;\n\t\t\t\treturn(TIFFReadDirEntryErrOk);\n\t\t\t}\n\t\tcase TIFF_SLONG8:\n\t\t\t*value=(int64*)origdata;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfLong8((uint64*)(*value),count);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n\tdata=(int64*)_TIFFmalloc(count*8);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(int64)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(int64)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\t*mb++=(int64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\t*mb++=(int64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\t*mb++=(int64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\t*mb++=(int64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              2132,
              0
            ],
            [
              2280,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntrySlong8Array",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEntry* direntry, float** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tfloat* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\tcase TIFF_FLOAT:\n\t\tcase TIFF_DOUBLE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,4,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_FLOAT:\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfLong((uint32*)origdata,count);  \n\t\t\tTIFFCvtIEEEDoubleToNative(tif,count,(float*)origdata);\n\t\t\t*value=(float*)origdata;\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n\tdata=(float*)_TIFFmalloc(count*sizeof(float));\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(float)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(float)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\t*mb++=(float)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\t*mb++=(float)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\t*mb++=(float)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\t*mb++=(float)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n#if defined(__WIN32__) && (_MSC_VER < 1500)\n\t\t\t\t\t/*\n\t\t\t\t\t * XXX: MSVC 6.0 does not support\n\t\t\t\t\t * conversion of 64-bit integers into\n\t\t\t\t\t * floating point values.\n\t\t\t\t\t */\n\t\t\t\t\t*mb++ = _TIFFUInt64ToFloat(*ma++);\n#else\n\t\t\t\t\t*mb++ = (float)(*ma++);\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\t*mb++=(float)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint32 maa;\n\t\t\t\tuint32 mab;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\tmaa=*ma++;\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\tmab=*ma++;\n\t\t\t\t\tif (mab==0)\n\t\t\t\t\t\t*mb++=0.0;\n\t\t\t\t\telse\n\t\t\t\t\t\t*mb++=(float)maa/(float)mab;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SRATIONAL:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tint32 maa;\n\t\t\t\tuint32 mab;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\tmaa=*(int32*)ma;\n\t\t\t\t\tma++;\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\tmab=*ma++;\n\t\t\t\t\tif (mab==0)\n\t\t\t\t\t\t*mb++=0.0;\n\t\t\t\t\telse\n\t\t\t\t\t\t*mb++=(float)maa/(float)mab;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble* ma;\n\t\t\t\tfloat* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabArrayOfLong8((uint64*)origdata,count);\n\t\t\t\tTIFFCvtIEEEDoubleToNative(tif,count,(double*)origdata);\n\t\t\t\tma=(double*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n                                {\n                                    double val = *ma++;\n                                    if( val > FLT_MAX )\n                                        val = FLT_MAX;\n                                    else if( val < -FLT_MAX )\n                                        val = -FLT_MAX;\n                                    *mb++=(float)val;\n                                }\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              2282,
              0
            ],
            [
              2524,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryFloatArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "float"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryDoubleArray(TIFF* tif, TIFFDirEntry* direntry, double** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tdouble* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\tcase TIFF_FLOAT:\n\t\tcase TIFF_DOUBLE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,8,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_DOUBLE:\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfLong8((uint64*)origdata,count);\n\t\t\tTIFFCvtIEEEDoubleToNative(tif,count,(double*)origdata);\n\t\t\t*value=(double*)origdata;\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n\tdata=(double*)_TIFFmalloc(count*sizeof(double));\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\t\t{\n\t\t\t\tuint8* ma;\n\t\t\t\tdouble* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(double)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\t{\n\t\t\t\tint8* ma;\n\t\t\t\tdouble* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int8*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(double)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\t\t{\n\t\t\t\tuint16* ma;\n\t\t\t\tdouble* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort(ma);\n\t\t\t\t\t*mb++=(double)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\t{\n\t\t\t\tint16* ma;\n\t\t\t\tdouble* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int16*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabShort((uint16*)ma);\n\t\t\t\t\t*mb++=(double)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tdouble* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\t*mb++=(double)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\t{\n\t\t\t\tint32* ma;\n\t\t\t\tdouble* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\t\t\t*mb++=(double)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\t{\n\t\t\t\tuint64* ma;\n\t\t\t\tdouble* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8(ma);\n#if defined(__WIN32__) && (_MSC_VER < 1500)\n\t\t\t\t\t/*\n\t\t\t\t\t * XXX: MSVC 6.0 does not support\n\t\t\t\t\t * conversion of 64-bit integers into\n\t\t\t\t\t * floating point values.\n\t\t\t\t\t */\n\t\t\t\t\t*mb++ = _TIFFUInt64ToDouble(*ma++);\n#else\n\t\t\t\t\t*mb++ = (double)(*ma++);\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\t{\n\t\t\t\tint64* ma;\n\t\t\t\tdouble* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(int64*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong8((uint64*)ma);\n\t\t\t\t\t*mb++=(double)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint32 maa;\n\t\t\t\tuint32 mab;\n\t\t\t\tdouble* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\tmaa=*ma++;\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\tmab=*ma++;\n\t\t\t\t\tif (mab==0)\n\t\t\t\t\t\t*mb++=0.0;\n\t\t\t\t\telse\n\t\t\t\t\t\t*mb++=(double)maa/(double)mab;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SRATIONAL:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tint32 maa;\n\t\t\t\tuint32 mab;\n\t\t\t\tdouble* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\tmaa=*(int32*)ma;\n\t\t\t\t\tma++;\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\tmab=*ma++;\n\t\t\t\t\tif (mab==0)\n\t\t\t\t\t\t*mb++=0.0;\n\t\t\t\t\telse\n\t\t\t\t\t\t*mb++=(double)maa/(double)mab;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* ma;\n\t\t\t\tdouble* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabArrayOfLong((uint32*)origdata,count);  \n\t\t\t\tTIFFCvtIEEEFloatToNative(tif,count,(float*)origdata);\n\t\t\t\tma=(float*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t\t*mb++=(double)(*ma++);\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              2526,
              0
            ],
            [
              2762,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryDoubleArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint32 count;\n\tvoid* origdata;\n\tuint64* data;\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_IFD:\n\t\tcase TIFF_IFD8:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn(TIFFReadDirEntryErrType);\n\t}\n\terr=TIFFReadDirEntryArray(tif,direntry,&count,8,&origdata);\n\tif ((err!=TIFFReadDirEntryErrOk)||(origdata==0))\n\t{\n\t\t*value=0;\n\t\treturn(err);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_IFD8:\n\t\t\t*value=(uint64*)origdata;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabArrayOfLong8(*value,count);\n\t\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n\tdata=(uint64*)_TIFFmalloc(count*8);\n\tif (data==0)\n\t{\n\t\t_TIFFfree(origdata);\n\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tswitch (direntry->tdir_type)\n\t{\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_IFD:\n\t\t\t{\n\t\t\t\tuint32* ma;\n\t\t\t\tuint64* mb;\n\t\t\t\tuint32 n;\n\t\t\t\tma=(uint32*)origdata;\n\t\t\t\tmb=data;\n\t\t\t\tfor (n=0; n<count; n++)\n\t\t\t\t{\n\t\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\t\tTIFFSwabLong(ma);\n\t\t\t\t\t*mb++=(uint64)(*ma++);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\t_TIFFfree(origdata);\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              2764,
              0
            ],
            [
              2823,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryIfd8Array",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tuint16* m;\n\tuint16* na;\n\tuint16 nb;\n\tif (direntry->tdir_count<(uint64)tif->tif_dir.td_samplesperpixel)\n\t\treturn(TIFFReadDirEntryErrCount);\n\terr=TIFFReadDirEntryShortArray(tif,direntry,&m);\n\tif (err!=TIFFReadDirEntryErrOk || m == NULL)\n\t\treturn(err);\n\tna=m;\n\tnb=tif->tif_dir.td_samplesperpixel;\n\t*value=*na++;\n\tnb--;\n\twhile (nb>0)\n\t{\n\t\tif (*na++!=*value)\n\t\t{\n\t\t\terr=TIFFReadDirEntryErrPsdif;\n\t\t\tbreak;\n\t\t}\n\t\tnb--;\n\t}\n\t_TIFFfree(m);\n\treturn(err);\n}",
          "fn_code_pos": [
            [
              2825,
              0
            ],
            [
              2851,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryPersampleShort",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleDouble(TIFF* tif, TIFFDirEntry* direntry, double* value)\n{\n\tenum TIFFReadDirEntryErr err;\n\tdouble* m;\n\tdouble* na;\n\tuint16 nb;\n\tif (direntry->tdir_count<(uint64)tif->tif_dir.td_samplesperpixel)\n\t\treturn(TIFFReadDirEntryErrCount);\n\terr=TIFFReadDirEntryDoubleArray(tif,direntry,&m);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t\treturn(err);\n\tna=m;\n\tnb=tif->tif_dir.td_samplesperpixel;\n\t*value=*na++;\n\tnb--;\n\twhile (nb>0)\n\t{\n\t\tif (*na++!=*value)\n\t\t{\n\t\t\terr=TIFFReadDirEntryErrPsdif;\n\t\t\tbreak;\n\t\t}\n\t\tnb--;\n\t}\n\t_TIFFfree(m);\n\treturn(err);\n}",
          "fn_code_pos": [
            [
              2854,
              0
            ],
            [
              2880,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryPersampleDouble",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void TIFFReadDirEntryCheckedByte(TIFF* tif, TIFFDirEntry* direntry, uint8* value)\n{\n\t(void) tif;\n\t*value=*(uint8*)(&direntry->tdir_offset);\n}",
          "fn_code_pos": [
            [
              2883,
              0
            ],
            [
              2887,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedByte",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint8"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void TIFFReadDirEntryCheckedSbyte(TIFF* tif, TIFFDirEntry* direntry, int8* value)\n{\n\t(void) tif;\n\t*value=*(int8*)(&direntry->tdir_offset);\n}",
          "fn_code_pos": [
            [
              2889,
              0
            ],
            [
              2893,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedSbyte",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "int8"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void TIFFReadDirEntryCheckedShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)\n{\n\t*value = direntry->tdir_offset.toff_short;\n\t/* *value=*(uint16*)(&direntry->tdir_offset); */\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabShort(value);\n}",
          "fn_code_pos": [
            [
              2895,
              0
            ],
            [
              2901,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedShort",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void TIFFReadDirEntryCheckedSshort(TIFF* tif, TIFFDirEntry* direntry, int16* value)\n{\n\t*value=*(int16*)(&direntry->tdir_offset);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabShort((uint16*)value);\n}",
          "fn_code_pos": [
            [
              2903,
              0
            ],
            [
              2908,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedSshort",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "int16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void TIFFReadDirEntryCheckedLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value)\n{\n\t*value=*(uint32*)(&direntry->tdir_offset);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong(value);\n}",
          "fn_code_pos": [
            [
              2910,
              0
            ],
            [
              2915,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedLong",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void TIFFReadDirEntryCheckedSlong(TIFF* tif, TIFFDirEntry* direntry, int32* value)\n{\n\t*value=*(int32*)(&direntry->tdir_offset);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong((uint32*)value);\n}",
          "fn_code_pos": [
            [
              2917,
              0
            ],
            [
              2922,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedSlong",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "int32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedLong8(TIFF* tif, TIFFDirEntry* direntry, uint64* value)\n{\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tenum TIFFReadDirEntryErr err;\n\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong(&offset);\n\t\terr=TIFFReadDirEntryData(tif,offset,8,value);\n\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\treturn(err);\n\t}\n\telse\n\t\t*value = direntry->tdir_offset.toff_long8;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong8(value);\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              2924,
              0
            ],
            [
              2941,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedLong8",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedSlong8(TIFF* tif, TIFFDirEntry* direntry, int64* value)\n{\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tenum TIFFReadDirEntryErr err;\n\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong(&offset);\n\t\terr=TIFFReadDirEntryData(tif,offset,8,value);\n\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\treturn(err);\n\t}\n\telse\n\t\t*value=*(int64*)(&direntry->tdir_offset);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong8((uint64*)value);\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              2943,
              0
            ],
            [
              2960,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedSlong8",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedRational(TIFF* tif, TIFFDirEntry* direntry, double* value)\n{\n\tUInt64Aligned_t m;\n\n\tassert(sizeof(double)==8);\n\tassert(sizeof(uint64)==8);\n\tassert(sizeof(uint32)==4);\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tenum TIFFReadDirEntryErr err;\n\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong(&offset);\n\t\terr=TIFFReadDirEntryData(tif,offset,8,m.i);\n\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\treturn(err);\n\t}\n\telse\n\t\tm.l = direntry->tdir_offset.toff_long8;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong(m.i,2);\n        /* Not completely sure what we should do when m.i[1]==0, but some */\n        /* sanitizers do not like division by 0.0: */\n        /* http://bugzilla.maptools.org/show_bug.cgi?id=2644 */\n\tif (m.i[0]==0 || m.i[1]==0)\n\t\t*value=0.0;\n\telse\n\t\t*value=(double)m.i[0]/(double)m.i[1];\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              2962,
              0
            ],
            [
              2991,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedRational",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedSrational(TIFF* tif, TIFFDirEntry* direntry, double* value)\n{\n\tUInt64Aligned_t m;\n\tassert(sizeof(double)==8);\n\tassert(sizeof(uint64)==8);\n\tassert(sizeof(int32)==4);\n\tassert(sizeof(uint32)==4);\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tenum TIFFReadDirEntryErr err;\n\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong(&offset);\n\t\terr=TIFFReadDirEntryData(tif,offset,8,m.i);\n\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\treturn(err);\n\t}\n\telse\n\t\tm.l=direntry->tdir_offset.toff_long8;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong(m.i,2);\n        /* Not completely sure what we should do when m.i[1]==0, but some */\n        /* sanitizers do not like division by 0.0: */\n        /* http://bugzilla.maptools.org/show_bug.cgi?id=2644 */\n\tif ((int32)m.i[0]==0 || m.i[1]==0)\n\t\t*value=0.0;\n\telse\n\t\t*value=(double)((int32)m.i[0])/(double)m.i[1];\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              2993,
              0
            ],
            [
              3022,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedSrational",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void TIFFReadDirEntryCheckedFloat(TIFF* tif, TIFFDirEntry* direntry, float* value)\n{\n         union\n\t {\n\t   float  f;\n\t   uint32 i;\n\t } float_union;\n\tassert(sizeof(float)==4);\n\tassert(sizeof(uint32)==4);\n\tassert(sizeof(float_union)==4);\n\tfloat_union.i=*(uint32*)(&direntry->tdir_offset);\n\t*value=float_union.f;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong((uint32*)value);\n}",
          "fn_code_pos": [
            [
              3024,
              0
            ],
            [
              3038,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedFloat",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "float"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedDouble(TIFF* tif, TIFFDirEntry* direntry, double* value)\n{\n\tassert(sizeof(double)==8);\n\tassert(sizeof(uint64)==8);\n\tassert(sizeof(UInt64Aligned_t)==8);\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tenum TIFFReadDirEntryErr err;\n\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong(&offset);\n\t\terr=TIFFReadDirEntryData(tif,offset,8,value);\n\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\treturn(err);\n\t}\n\telse\n\t{\n\t       UInt64Aligned_t uint64_union;\n\t       uint64_union.l=direntry->tdir_offset.toff_long8;\n\t       *value=uint64_union.d;\n\t}\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong8((uint64*)value);\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3040,
              0
            ],
            [
              3064,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedDouble",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSbyte(int8 value)\n{\n\tif (value<0)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3066,
              0
            ],
            [
              3072,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeByteSbyte",
            "parameters": {
              "value": "int8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteShort(uint16 value)\n{\n\tif (value>0xFF)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3074,
              0
            ],
            [
              3080,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeByteShort",
            "parameters": {
              "value": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSshort(int16 value)\n{\n\tif ((value<0)||(value>0xFF))\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3082,
              0
            ],
            [
              3088,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeByteSshort",
            "parameters": {
              "value": "int16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong(uint32 value)\n{\n\tif (value>0xFF)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3090,
              0
            ],
            [
              3096,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeByteLong",
            "parameters": {
              "value": "uint32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSlong(int32 value)\n{\n\tif ((value<0)||(value>0xFF))\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3098,
              0
            ],
            [
              3104,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeByteSlong",
            "parameters": {
              "value": "int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong8(uint64 value)\n{\n\tif (value>0xFF)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3106,
              0
            ],
            [
              3112,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeByteLong8",
            "parameters": {
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSlong8(int64 value)\n{\n\tif ((value<0)||(value>0xFF))\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3114,
              0
            ],
            [
              3120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeByteSlong8",
            "parameters": {
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteByte(uint8 value)\n{\n\tif (value>0x7F)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3122,
              0
            ],
            [
              3128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSbyteByte",
            "parameters": {
              "value": "uint8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteShort(uint16 value)\n{\n\tif (value>0x7F)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3130,
              0
            ],
            [
              3136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSbyteShort",
            "parameters": {
              "value": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSshort(int16 value)\n{\n\tif ((value<-0x80)||(value>0x7F))\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3138,
              0
            ],
            [
              3144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSbyteSshort",
            "parameters": {
              "value": "int16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteLong(uint32 value)\n{\n\tif (value>0x7F)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3146,
              0
            ],
            [
              3152,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSbyteLong",
            "parameters": {
              "value": "uint32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSlong(int32 value)\n{\n\tif ((value<-0x80)||(value>0x7F))\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3154,
              0
            ],
            [
              3160,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSbyteSlong",
            "parameters": {
              "value": "int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteLong8(uint64 value)\n{\n\tif (value>0x7F)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3162,
              0
            ],
            [
              3168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSbyteLong8",
            "parameters": {
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSlong8(int64 value)\n{\n\tif ((value<-0x80)||(value>0x7F))\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3170,
              0
            ],
            [
              3176,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSbyteSlong8",
            "parameters": {
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSbyte(int8 value)\n{\n\tif (value<0)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3178,
              0
            ],
            [
              3184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeShortSbyte",
            "parameters": {
              "value": "int8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSshort(int16 value)\n{\n\tif (value<0)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3186,
              0
            ],
            [
              3192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeShortSshort",
            "parameters": {
              "value": "int16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortLong(uint32 value)\n{\n\tif (value>0xFFFF)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3194,
              0
            ],
            [
              3200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeShortLong",
            "parameters": {
              "value": "uint32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSlong(int32 value)\n{\n\tif ((value<0)||(value>0xFFFF))\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3202,
              0
            ],
            [
              3208,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeShortSlong",
            "parameters": {
              "value": "int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortLong8(uint64 value)\n{\n\tif (value>0xFFFF)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3210,
              0
            ],
            [
              3216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeShortLong8",
            "parameters": {
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSlong8(int64 value)\n{\n\tif ((value<0)||(value>0xFFFF))\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3218,
              0
            ],
            [
              3224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeShortSlong8",
            "parameters": {
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortShort(uint16 value)\n{\n\tif (value>0x7FFF)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3226,
              0
            ],
            [
              3232,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSshortShort",
            "parameters": {
              "value": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortLong(uint32 value)\n{\n\tif (value>0x7FFF)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3234,
              0
            ],
            [
              3240,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSshortLong",
            "parameters": {
              "value": "uint32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortSlong(int32 value)\n{\n\tif ((value<-0x8000)||(value>0x7FFF))\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3242,
              0
            ],
            [
              3248,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSshortSlong",
            "parameters": {
              "value": "int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortLong8(uint64 value)\n{\n\tif (value>0x7FFF)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3250,
              0
            ],
            [
              3256,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSshortLong8",
            "parameters": {
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortSlong8(int64 value)\n{\n\tif ((value<-0x8000)||(value>0x7FFF))\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3258,
              0
            ],
            [
              3264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSshortSlong8",
            "parameters": {
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSbyte(int8 value)\n{\n\tif (value<0)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3266,
              0
            ],
            [
              3272,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLongSbyte",
            "parameters": {
              "value": "int8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSshort(int16 value)\n{\n\tif (value<0)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3274,
              0
            ],
            [
              3280,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLongSshort",
            "parameters": {
              "value": "int16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSlong(int32 value)\n{\n\tif (value<0)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3282,
              0
            ],
            [
              3288,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLongSlong",
            "parameters": {
              "value": "int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryCheckRangeLongLong8(uint64 value)\n{\n\tif (value > TIFF_UINT32_MAX)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3295,
              0
            ],
            [
              3302,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLongLong8",
            "parameters": {
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryCheckRangeLongSlong8(int64 value)\n{\n\tif ((value < 0) || (value > (int64) TIFF_UINT32_MAX))\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3304,
              0
            ],
            [
              3311,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLongSlong8",
            "parameters": {
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryCheckRangeSlongLong(uint32 value)\n{\n\tif (value > 0x7FFFFFFFUL)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3315,
              0
            ],
            [
              3322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSlongLong",
            "parameters": {
              "value": "uint32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryCheckRangeSlongLong8(uint64 value)\n{\n\tif (value > 0x7FFFFFFF)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3325,
              0
            ],
            [
              3332,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSlongLong8",
            "parameters": {
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryCheckRangeSlongSlong8(int64 value)\n{\n        if ((value < 0-((int64) 0x7FFFFFFF+1)) || (value > 0x7FFFFFFF))\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3335,
              0
            ],
            [
              3342,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSlongSlong8",
            "parameters": {
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryCheckRangeLong8Sbyte(int8 value)\n{\n\tif (value < 0)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3344,
              0
            ],
            [
              3351,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLong8Sbyte",
            "parameters": {
              "value": "int8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryCheckRangeLong8Sshort(int16 value)\n{\n\tif (value < 0)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3353,
              0
            ],
            [
              3360,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLong8Sshort",
            "parameters": {
              "value": "int16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryCheckRangeLong8Slong(int32 value)\n{\n\tif (value < 0)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3362,
              0
            ],
            [
              3369,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLong8Slong",
            "parameters": {
              "value": "int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryCheckRangeLong8Slong8(int64 value)\n{\n\tif (value < 0)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3371,
              0
            ],
            [
              3378,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLong8Slong8",
            "parameters": {
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryCheckRangeSlong8Long8(uint64 value)\n{\n\tif (value > TIFF_INT64_MAX)\n\t\treturn(TIFFReadDirEntryErrRange);\n\telse\n\t\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3385,
              0
            ],
            [
              3392,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSlong8Long8",
            "parameters": {
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static enum TIFFReadDirEntryErr\nTIFFReadDirEntryData(TIFF* tif, uint64 offset, tmsize_t size, void* dest)\n{\n\tassert(size>0);\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif,offset))\n\t\t\treturn(TIFFReadDirEntryErrIo);\n\t\tif (!ReadOK(tif,dest,size))\n\t\t\treturn(TIFFReadDirEntryErrIo);\n\t} else {\n\t\tsize_t ma,mb;\n\t\tma=(size_t)offset;\n\t\tmb=ma+size;\n\t\tif (((uint64)ma!=offset)\n\t\t    || (mb < ma)\n\t\t    || (mb - ma != (size_t) size)\n\t\t    || (mb < (size_t)size)\n\t\t    || (mb > (size_t)tif->tif_size)\n\t\t    )\n\t\t\treturn(TIFFReadDirEntryErrIo);\n\t\t_TIFFmemcpy(dest,tif->tif_base+ma,size);\n\t}\n\treturn(TIFFReadDirEntryErrOk);\n}",
          "fn_code_pos": [
            [
              3396,
              0
            ],
            [
              3419,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryData",
            "parameters": {
              "tif": "TIFF",
              "offset": "uint64",
              "size": "tmsize_t",
              "dest": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void TIFFReadDirEntryOutputErr(TIFF* tif, enum TIFFReadDirEntryErr err, const char* module, const char* tagname, int recover)\n{\n\tif (!recover) {\n\t\tswitch (err) {\n\t\t\tcase TIFFReadDirEntryErrCount:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Incorrect count for \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrType:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Incompatible type for \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrIo:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"IO error during reading of \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrRange:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Incorrect value for \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrPsdif:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Cannot handle different values per sample for \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrSizesan:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Sanity check on size of \\\"%s\\\" value failed\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrAlloc:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Out of memory reading of \\\"%s\\\"\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);   /* we should never get here */\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (err) {\n\t\t\tcase TIFFReadDirEntryErrCount:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"Incorrect count for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t     tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrType:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"Incompatible type for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrIo:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"IO error during reading of \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrRange:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"Incorrect value for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrPsdif:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\"Cannot handle different values per sample for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrSizesan:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\"Sanity check on size of \\\"%s\\\" value failed; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tcase TIFFReadDirEntryErrAlloc:\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"Out of memory reading of \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t       tagname);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);   /* we should never get here */\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              3421,
              0
            ],
            [
              3506,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryOutputErr",
            "parameters": {
              "tif": "TIFF",
              "err": "enum TIFFReadDirEntryErr",
              "module": "char",
              "tagname": "char",
              "recover": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int _TIFFGetMaxColorChannels( uint16 photometric )\n{\n    switch (photometric) {\n\tcase PHOTOMETRIC_PALETTE:\n\tcase PHOTOMETRIC_MINISWHITE:\n\tcase PHOTOMETRIC_MINISBLACK:\n            return 1;\n\tcase PHOTOMETRIC_YCBCR:\n\tcase PHOTOMETRIC_RGB:\n\tcase PHOTOMETRIC_CIELAB:\n\tcase PHOTOMETRIC_LOGLUV:\n\tcase PHOTOMETRIC_ITULAB:\n\tcase PHOTOMETRIC_ICCLAB:\n            return 3;\n\tcase PHOTOMETRIC_SEPARATED:\n\tcase PHOTOMETRIC_MASK:\n            return 4;\n\tcase PHOTOMETRIC_LOGL:\n\tcase PHOTOMETRIC_CFA:\n\tdefault:\n            return 0;\n    }\n}",
          "fn_code_pos": [
            [
              3513,
              0
            ],
            [
              3535,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFGetMaxColorChannels",
            "parameters": {
              "photometric": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFReadDirectory(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFReadDirectory\";\n\tTIFFDirEntry* dir;\n\tuint16 dircount;\n\tTIFFDirEntry* dp;\n\tuint16 di;\n\tconst TIFFField* fip;\n\tuint32 fii=FAILED_FII;\n        toff_t nextdiroff;\n    int bitspersample_read = FALSE;\n        int color_channels;\n\n\ttif->tif_diroff=tif->tif_nextdiroff;\n\tif (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))\n\t\treturn 0;           /* last offset or bad offset (IFD looping) */\n\t(*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */\n\ttif->tif_curdir++;\n        nextdiroff = tif->tif_nextdiroff;\n\tdircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);\n\tif (!dircount)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"Failed to read directory at offset \" TIFF_UINT64_FORMAT,nextdiroff);\n\t\treturn 0;\n\t}\n\tTIFFReadDirectoryCheckOrder(tif,dir,dircount);\n\n        /*\n         * Mark duplicates of any tag to be ignored (bugzilla 1994)\n         * to avoid certain pathological problems.\n         */\n\t{\n\t\tTIFFDirEntry* ma;\n\t\tuint16 mb;\n\t\tfor (ma=dir, mb=0; mb<dircount; ma++, mb++)\n\t\t{\n\t\t\tTIFFDirEntry* na;\n\t\t\tuint16 nb;\n\t\t\tfor (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)\n\t\t\t{\n\t\t\t\tif (ma->tdir_tag==na->tdir_tag)\n\t\t\t\t\tna->tdir_tag=IGNORE;\n\t\t\t}\n\t\t}\n\t}\n        \n\ttif->tif_flags &= ~TIFF_BEENWRITING;    /* reset before new dir */\n\ttif->tif_flags &= ~TIFF_BUF4WRITE;      /* reset before new dir */\n\t/* free any old stuff and reinit */\n\tTIFFFreeDirectory(tif);\n\tTIFFDefaultDirectory(tif);\n\t/*\n\t * Electronic Arts writes gray-scale TIFF files\n\t * without a PlanarConfiguration directory entry.\n\t * Thus we setup a default value here, even though\n\t * the TIFF spec says there is no default value.\n\t */\n\tTIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n\t/*\n\t * Setup default value and then make a pass over\n\t * the fields to check type and tag information,\n\t * and to extract info required to size data\n\t * structures.  A second pass is made afterwards\n\t * to read in everything not taken in the first pass.\n\t * But we must process the Compression tag first\n\t * in order to merge in codec-private tag definitions (otherwise\n\t * we may get complaints about unknown tags).  However, the\n\t * Compression tag may be dependent on the SamplesPerPixel\n\t * tag value because older TIFF specs permitted Compression\n\t * to be written as a SamplesPerPixel-count tag entry.\n\t * Thus if we don't first figure out the correct SamplesPerPixel\n\t * tag value then we may end up ignoring the Compression tag\n\t * value because it has an incorrect count value (if the\n\t * true value of SamplesPerPixel is not 1).\n\t */\n\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);\n\tif (dp)\n\t{\n\t\tif (!TIFFFetchNormalTag(tif,dp,0))\n\t\t\tgoto bad;\n\t\tdp->tdir_tag=IGNORE;\n\t}\n\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);\n\tif (dp)\n\t{\n\t\t/*\n\t\t * The 5.0 spec says the Compression tag has one value, while\n\t\t * earlier specs say it has one value per sample.  Because of\n\t\t * this, we accept the tag if one value is supplied with either\n\t\t * count.\n\t\t */\n\t\tuint16 value;\n\t\tenum TIFFReadDirEntryErr err;\n\t\terr=TIFFReadDirEntryShort(tif,dp,&value);\n\t\tif (err==TIFFReadDirEntryErrCount)\n\t\t\terr=TIFFReadDirEntryPersampleShort(tif,dp,&value);\n\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t{\n\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,\"Compression\",0);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))\n\t\t\tgoto bad;\n\t\tdp->tdir_tag=IGNORE;\n\t}\n\telse\n\t{\n\t\tif (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))\n\t\t\tgoto bad;\n\t}\n\t/*\n\t * First real pass over the directory.\n\t */\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tif (dp->tdir_tag!=IGNORE)\n\t\t{\n\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\tif (fii == FAILED_FII)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Unknown field with tag %d (0x%x) encountered\",\n\t\t\t\t    dp->tdir_tag,dp->tdir_tag);\n                                /* the following knowingly leaks the \n                                   anonymous field structure */\n\t\t\t\tif (!_TIFFMergeFields(tif,\n\t\t\t\t\t_TIFFCreateAnonField(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t1)) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t    module,\n\t\t\t\t\t    \"Registering anonymous field with tag %d (0x%x) failed\",\n\t\t\t\t\t    dp->tdir_tag,\n\t\t\t\t\t    dp->tdir_tag);\n\t\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\t\t} else {\n\t\t\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\t\t\tassert(fii != FAILED_FII);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dp->tdir_tag!=IGNORE)\n\t\t{\n\t\t\tfip=tif->tif_fields[fii];\n\t\t\tif (fip->field_bit==FIELD_IGNORE)\n\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\telse\n\t\t\t{\n\t\t\t\tswitch (dp->tdir_tag)\n\t\t\t\t{\n\t\t\t\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\t\t\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\t\t\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\t\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\t\t\t\tTIFFSetFieldBit(tif,fip->field_bit);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\t\t\t\tcase TIFFTAG_IMAGELENGTH:\n\t\t\t\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\t\t\t\tcase TIFFTAG_TILELENGTH:\n\t\t\t\t\tcase TIFFTAG_TILEWIDTH:\n\t\t\t\t\tcase TIFFTAG_TILEDEPTH:\n\t\t\t\t\tcase TIFFTAG_PLANARCONFIG:\n\t\t\t\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t\t\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\t\t\t\tif (!TIFFFetchNormalTag(tif,dp,0))\n\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\t\t\t\tbreak;\n                                        default:\n                                            if( !_TIFFCheckFieldIsValidForCodec(tif, dp->tdir_tag) )\n                                                dp->tdir_tag=IGNORE;\n                                            break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * XXX: OJPEG hack.\n\t * If a) compression is OJPEG, b) planarconfig tag says it's separate,\n\t * c) strip offsets/bytecounts tag are both present and\n\t * d) both contain exactly one value, then we consistently find\n\t * that the buggy implementation of the buggy compression scheme\n\t * matches contig planarconfig best. So we 'fix-up' the tag here\n\t */\n\tif ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&\n\t    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))\n\t{\n        if (!_TIFFFillStriles(tif))\n            goto bad;\n\t\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);\n\t\tif ((dp!=0)&&(dp->tdir_count==1))\n\t\t{\n\t\t\tdp=TIFFReadDirectoryFindEntry(tif,dir,dircount,\n\t\t\t    TIFFTAG_STRIPBYTECOUNTS);\n\t\t\tif ((dp!=0)&&(dp->tdir_count==1))\n\t\t\t{\n\t\t\t\ttif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t    \"Planarconfig tag value assumed incorrect, \"\n\t\t\t\t    \"assuming data is contig instead of chunky\");\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Allocate directory structure and setup defaults.\n\t */\n\tif (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))\n\t{\n\t\tMissingRequired(tif,\"ImageLength\");\n\t\tgoto bad;\n\t}\n\t/*\n\t * Setup appropriate structures (by strip or by tile)\n\t */\n\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\n\t\ttif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  \n\t\ttif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;\n\t\ttif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;\n\t\ttif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;\n\t\ttif->tif_flags &= ~TIFF_ISTILED;\n\t} else {\n\t\ttif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t}\n\tif (!tif->tif_dir.td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Cannot handle zero number of %s\",\n\t\t    isTiled(tif) ? \"tiles\" : \"strips\");\n\t\tgoto bad;\n\t}\n\ttif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;\n\tif (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\ttif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;\n\tif (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {\n#ifdef OJPEG_SUPPORT\n\t\tif ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&\n\t\t    (isTiled(tif)==0) &&\n\t\t    (tif->tif_dir.td_nstrips==1)) {\n\t\t\t/*\n\t\t\t * XXX: OJPEG hack.\n\t\t\t * If a) compression is OJPEG, b) it's not a tiled TIFF,\n\t\t\t * and c) the number of strips is 1,\n\t\t\t * then we tolerate the absence of stripoffsets tag,\n\t\t\t * because, presumably, all required data is in the\n\t\t\t * JpegInterchangeFormat stream.\n\t\t\t */\n\t\t\tTIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\n\t\t} else\n#endif\n        {\n\t\t\tMissingRequired(tif,\n\t\t\t\tisTiled(tif) ? \"TileOffsets\" : \"StripOffsets\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\t/*\n\t * Second pass: extract other information.\n\t */\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tswitch (dp->tdir_tag)\n\t\t{\n\t\t\tcase IGNORE:\n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t\tcase TIFFTAG_DATATYPE:\n\t\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t\t/*\n\t\t\t\t * The MinSampleValue, MaxSampleValue, BitsPerSample\n\t\t\t\t * DataType and SampleFormat tags are supposed to be\n\t\t\t\t * written as one value/sample, but some vendors\n\t\t\t\t * incorrectly write one value only -- so we accept\n\t\t\t\t * that as well (yuck). Other vendors write correct\n\t\t\t\t * value for NumberOfSamples, but incorrect one for\n\t\t\t\t * BitsPerSample and friends, and we will read this\n\t\t\t\t * too.\n\t\t\t\t */\n\t\t\t\t{\n\t\t\t\t\tuint16 value;\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\t\t\terr=TIFFReadDirEntryShort(tif,dp,&value);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrCount)\n\t\t\t\t\t\terr=TIFFReadDirEntryPersampleShort(tif,dp,&value);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,value))\n\t\t\t\t\t\tgoto bad;\n                    if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )\n                        bitspersample_read = TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\t\t{\n\n\t\t\t\t\tdouble *data = NULL;\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\t\t\tuint32 saved_flags;\n\t\t\t\t\tint m;\n\t\t\t\t\tif (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)\n\t\t\t\t\t\terr = TIFFReadDirEntryErrCount;\n\t\t\t\t\telse\n\t\t\t\t\t\terr = TIFFReadDirEntryDoubleArray(tif, dp, &data);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tsaved_flags = tif->tif_flags;\n\t\t\t\t\ttif->tif_flags |= TIFF_PERSAMPLE;\n\t\t\t\t\tm = TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\ttif->tif_flags = saved_flags;\n\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\t\tcase TIFFTAG_TILEOFFSETS:\n#if defined(DEFER_STRILE_LOAD)\n                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),\n                                             dp, sizeof(TIFFDirEntry) );\n#else                          \n                                if( tif->tif_dir.td_stripoffset != NULL )\n                                {\n                                    TIFFErrorExt(tif->tif_clientdata, module,\n                                        \"tif->tif_dir.td_stripoffset is \"\n                                        \"already allocated. Likely duplicated \"\n                                        \"StripOffsets/TileOffsets tag\");\n                                    goto bad;\n                                }\n\t\t\t\tif (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  \n\t\t\t\t\tgoto bad;\n#endif                                \n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\t\tcase TIFFTAG_TILEBYTECOUNTS:\n#if defined(DEFER_STRILE_LOAD)\n                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),\n                                             dp, sizeof(TIFFDirEntry) );\n#else                          \n                                if( tif->tif_dir.td_stripbytecount != NULL )\n                                {\n                                    TIFFErrorExt(tif->tif_clientdata, module,\n                                        \"tif->tif_dir.td_stripbytecount is \"\n                                        \"already allocated. Likely duplicated \"\n                                        \"StripByteCounts/TileByteCounts tag\");\n                                    goto bad;\n                                }\n                                if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  \n\t\t\t\t\tgoto bad;\n#endif                                \n\t\t\t\tbreak;\n\t\t\tcase TIFFTAG_COLORMAP:\n\t\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t\t{\n\t\t\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\t\t\tuint32 countpersample;\n\t\t\t\t\tuint32 countrequired;\n\t\t\t\t\tuint32 incrementpersample;\n\t\t\t\t\tuint16* value=NULL;\n                    /* It would be dangerous to instantiate those tag values */\n                    /* since if td_bitspersample has not yet been read (due to */\n                    /* unordered tags), it could be read afterwards with a */\n                    /* values greater than the default one (1), which may cause */\n                    /* crashes in user code */\n                    if( !bitspersample_read )\n                    {\n                        fip = TIFFFieldWithTag(tif,dp->tdir_tag);\n                        TIFFWarningExt(tif->tif_clientdata,module,\n                                       \"Ignoring %s since BitsPerSample tag not found\",\n                                       fip ? fip->field_name : \"unknown tagname\");\n                        continue;\n                    }\n\t\t\t\t\t/* ColorMap or TransferFunction for high bit */\n\t\t\t\t\t/* depths do not make much sense and could be */\n\t\t\t\t\t/* used as a denial of service vector */\n\t\t\t\t\tif (tif->tif_dir.td_bitspersample > 24)\n\t\t\t\t\t{\n\t\t\t\t\t    fip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t    TIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t\"Ignoring %s because BitsPerSample=%d>24\",\n\t\t\t\t\t\tfip ? fip->field_name : \"unknown tagname\",\n\t\t\t\t\t\ttif->tif_dir.td_bitspersample);\n\t\t\t\t\t    continue;\n\t\t\t\t\t}\n\t\t\t\t\tcountpersample=(1U<<tif->tif_dir.td_bitspersample);\n\t\t\t\t\tif ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))\n\t\t\t\t\t{\n\t\t\t\t\t\tcountrequired=countpersample;\n\t\t\t\t\t\tincrementpersample=0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcountrequired=3*countpersample;\n\t\t\t\t\t\tincrementpersample=countpersample;\n\t\t\t\t\t}\n\t\t\t\t\tif (dp->tdir_count!=(uint64)countrequired)\n\t\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\t\telse\n\t\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&value);\n\t\t\t\t\tif (err!=TIFFReadDirEntryErrOk)\n                    {\n\t\t\t\t\t\tfip = TIFFFieldWithTag(tif,dp->tdir_tag);\n\t\t\t\t\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",1);\n                    }\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tTIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);\n\t\t\t\t\t\t_TIFFfree(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n/* BEGIN REV 4.0 COMPATIBILITY */\n\t\t\tcase TIFFTAG_OSUBFILETYPE:\n\t\t\t\t{\n\t\t\t\t\tuint16 valueo;\n\t\t\t\t\tuint32 value;\n\t\t\t\t\tif (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (valueo)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;\n\t\t\t\t\t\t\tcase OFILETYPE_PAGE: value=FILETYPE_PAGE; break;\n\t\t\t\t\t\t\tdefault: value=0; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value!=0)\n\t\t\t\t\t\t\tTIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n/* END REV 4.0 COMPATIBILITY */\n\t\t\tdefault:\n\t\t\t\t(void) TIFFFetchNormalTag(tif, dp, TRUE);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * OJPEG hack:\n\t * - If a) compression is OJPEG, and b) photometric tag is missing,\n\t * then we consistently find that photometric should be YCbCr\n\t * - If a) compression is OJPEG, and b) photometric tag says it's RGB,\n\t * then we consistently find that the buggy implementation of the\n\t * buggy compression scheme matches photometric YCbCr instead.\n\t * - If a) compression is OJPEG, and b) bitspersample tag is missing,\n\t * then we consistently find bitspersample should be 8.\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n\t * and c) photometric is RGB or YCbCr, then we consistently find\n\t * samplesperpixel should be 3\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n\t * and c) photometric is MINISWHITE or MINISBLACK, then we consistently\n\t * find samplesperpixel should be 3\n\t */\n\tif (tif->tif_dir.td_compression==COMPRESSION_OJPEG)\n\t{\n\t\tif (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Photometric tag is missing, assuming data is YCbCr\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))\n\t\t\t\tgoto bad;\n\t\t}\n\t\telse if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)\n\t\t{\n\t\t\ttif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Photometric tag value assumed incorrect, \"\n\t\t\t    \"assuming data is YCbCr instead of RGB\");\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t    \"BitsPerSample tag is missing, assuming 8 bits per sample\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))\n\t\t\t\tgoto bad;\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\t{\n\t\t\tif (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t    \"SamplesPerPixel tag is missing, \"\n\t\t\t\t    \"assuming correct SamplesPerPixel value is 3\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t    \"SamplesPerPixel tag is missing, \"\n\t\t\t\t    \"applying correct SamplesPerPixel value of 3\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\telse if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)\n\t\t\t\t || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * SamplesPerPixel tag is missing, but is not required\n\t\t\t\t * by spec.  Assume correct SamplesPerPixel value of 1.\n\t\t\t\t */\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Make sure all non-color channels are extrasamples.\n\t * If it's not the case, define them as such.\n\t */\n        color_channels = _TIFFGetMaxColorChannels(tif->tif_dir.td_photometric);\n        if (color_channels && tif->tif_dir.td_samplesperpixel - tif->tif_dir.td_extrasamples > color_channels) {\n                uint16 old_extrasamples;\n                uint16 *new_sampleinfo;\n\n                TIFFWarningExt(tif->tif_clientdata,module, \"Sum of Photometric type-related \"\n                    \"color channels and ExtraSamples doesn't match SamplesPerPixel. \"\n                    \"Defining non-color channels as ExtraSamples.\");\n\n                old_extrasamples = tif->tif_dir.td_extrasamples;\n                tif->tif_dir.td_extrasamples = (uint16) (tif->tif_dir.td_samplesperpixel - color_channels);\n\n                // sampleinfo should contain information relative to these new extra samples\n                new_sampleinfo = (uint16*) _TIFFcalloc(tif->tif_dir.td_extrasamples, sizeof(uint16));\n                if (!new_sampleinfo) {\n                    TIFFErrorExt(tif->tif_clientdata, module, \"Failed to allocate memory for \"\n                                \"temporary new sampleinfo array (%d 16 bit elements)\",\n                                tif->tif_dir.td_extrasamples);\n                    goto bad;\n                }\n\n                memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16));\n                _TIFFsetShortArray(&tif->tif_dir.td_sampleinfo, new_sampleinfo, tif->tif_dir.td_extrasamples);\n                _TIFFfree(new_sampleinfo);\n        }\n\n\t/*\n\t * Verify Palette image has a Colormap.\n\t */\n\tif (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&\n\t    !TIFFFieldSet(tif, FIELD_COLORMAP)) {\n\t\tif ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)\n\t\t\ttif->tif_dir.td_photometric = PHOTOMETRIC_RGB;\n\t\telse if (tif->tif_dir.td_bitspersample>=8)\n\t\t\ttif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;\n\t\telse {\n\t\t\tMissingRequired(tif, \"Colormap\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\t/*\n\t * OJPEG hack:\n\t * We do no further messing with strip/tile offsets/bytecounts in OJPEG\n\t * TIFFs\n\t */\n\tif (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)\n\t{\n\t\t/*\n\t\t * Attempt to deal with a missing StripByteCounts tag.\n\t\t */\n\t\tif (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {\n\t\t\t/*\n\t\t\t * Some manufacturers violate the spec by not giving\n\t\t\t * the size of the strips.  In this case, assume there\n\t\t\t * is one uncompressed strip of data.\n\t\t\t */\n\t\t\tif ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&\n\t\t\t    tif->tif_dir.td_nstrips > 1) ||\n\t\t\t    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&\n\t\t\t     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {\n\t\t\t    MissingRequired(tif, \"StripByteCounts\");\n\t\t\t    goto bad;\n\t\t\t}\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"TIFF directory is missing required \"\n\t\t\t\t\"\\\"StripByteCounts\\\" field, calculating from imagelength\");\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t/*\n\t\t * Assume we have wrong StripByteCount value (in case\n\t\t * of single strip) in following cases:\n\t\t *   - it is equal to zero along with StripOffset;\n\t\t *   - it is larger than file itself (in case of uncompressed\n\t\t *     image);\n\t\t *   - it is smaller than the size of the bytes per row\n\t\t *     multiplied on the number of rows.  The last case should\n\t\t *     not be checked in the case of writing new image,\n\t\t *     because we may do not know the exact strip size\n\t\t *     until the whole image will be written and directory\n\t\t *     dumped out.\n\t\t */\n\t\t#define\tBYTECOUNTLOOKSBAD \\\n\t\t    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \\\n\t\t      (tif->tif_dir.td_compression == COMPRESSION_NONE && \\\n\t\t       (tif->tif_dir.td_stripoffset[0] <= TIFFGetFileSize(tif) && \\\n\t\t        tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0])) || \\\n\t\t      (tif->tif_mode == O_RDONLY && \\\n\t\t       tif->tif_dir.td_compression == COMPRESSION_NONE && \\\n\t\t       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )\n\n\t\t} else if (tif->tif_dir.td_nstrips == 1\n                           && !(tif->tif_flags&TIFF_ISTILED)\n                           && _TIFFFillStriles(tif)\n\t\t\t   && tif->tif_dir.td_stripoffset[0] != 0\n\t\t\t   && BYTECOUNTLOOKSBAD) {\n\t\t\t/*\n\t\t\t * XXX: Plexus (and others) sometimes give a value of\n\t\t\t * zero for a tag when they don't know what the\n\t\t\t * correct value is!  Try and handle the simple case\n\t\t\t * of estimating the size of a one strip image.\n\t\t\t */\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Bogus \\\"StripByteCounts\\\" field, ignoring and calculating from imagelength\");\n\t\t\tif(EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\n#if !defined(DEFER_STRILE_LOAD)\n\t\t} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG\n\t\t\t   && tif->tif_dir.td_nstrips > 2\n\t\t\t   && tif->tif_dir.td_compression == COMPRESSION_NONE\n\t\t\t   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]\n\t\t\t   && tif->tif_dir.td_stripbytecount[0] != 0\n\t\t\t   && tif->tif_dir.td_stripbytecount[1] != 0 ) {\n\t\t\t/*\n\t\t\t * XXX: Some vendors fill StripByteCount array with\n\t\t\t * absolutely wrong values (it can be equal to\n\t\t\t * StripOffset array, for example). Catch this case\n\t\t\t * here.\n                         *\n                         * We avoid this check if deferring strile loading\n                         * as it would always force us to load the strip/tile\n                         * information.\n\t\t\t */\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Wrong \\\"StripByteCounts\\\" field, ignoring and calculating from imagelength\");\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n#endif /* !defined(DEFER_STRILE_LOAD) */                        \n\t\t}\n\t}\n\tif (dir)\n\t{\n\t\t_TIFFfree(dir);\n\t\tdir=NULL;\n\t}\n\tif (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))\n\t{\n\t\tif (tif->tif_dir.td_bitspersample>=16)\n\t\t\ttif->tif_dir.td_maxsamplevalue=0xFFFF;\n\t\telse\n\t\t\ttif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);\n\t}\n\t/*\n\t * XXX: We can optimize checking for the strip bounds using the sorted\n\t * bytecounts array. See also comments for TIFFAppendToStrip()\n\t * function in tif_write.c.\n\t */\n#if !defined(DEFER_STRILE_LOAD)        \n\tif (tif->tif_dir.td_nstrips > 1) {\n\t\tuint32 strip;\n\n\t\ttif->tif_dir.td_stripbytecountsorted = 1;\n\t\tfor (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {\n\t\t\tif (tif->tif_dir.td_stripoffset[strip - 1] >\n\t\t\t    tif->tif_dir.td_stripoffset[strip]) {\n\t\t\t\ttif->tif_dir.td_stripbytecountsorted = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif /* !defined(DEFER_STRILE_LOAD) */\n        \n\t/*\n\t * An opportunity for compression mode dependent tag fixup\n\t */\n\t(*tif->tif_fixuptags)(tif);\n\n\t/*\n\t * Some manufacturers make life difficult by writing\n\t * large amounts of uncompressed data as a single strip.\n\t * This is contrary to the recommendations of the spec.\n\t * The following makes an attempt at breaking such images\n\t * into strips closer to the recommended 8k bytes.  A\n\t * side effect, however, is that the RowsPerStrip tag\n\t * value may be changed.\n\t */\n\tif ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (tif->tif_dir.td_nstrips==1)&&\n\t    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  \n\t    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))\n    {\n        if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )\n            return 0;\n\t\tChopUpSingleUncompressedStrip(tif);\n    }\n\n        /* There are also uncompressed stripped files with strips larger than */\n        /* 2 GB, which make them unfriendly with a lot of code. If possible, */\n        /* try to expose smaller \"virtual\" strips. */\n        if( tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&\n            tif->tif_dir.td_compression == COMPRESSION_NONE &&\n            (tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP &&\n            TIFFStripSize64(tif) > 0x7FFFFFFFUL )\n        {\n            if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )\n                return 0;\n            TryChopUpUncompressedBigTiff(tif);\n        }\n\n        /*\n         * Clear the dirty directory flag. \n         */\n\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\ttif->tif_flags &= ~TIFF_DIRTYSTRIP;\n\n\t/*\n\t * Reinitialize i/o since we are starting on a new directory.\n\t */\n\ttif->tif_row = (uint32) -1;\n\ttif->tif_curstrip = (uint32) -1;\n\ttif->tif_col = (uint32) -1;\n\ttif->tif_curtile = (uint32) -1;\n\ttif->tif_tilesize = (tmsize_t) -1;\n\n\ttif->tif_scanlinesize = TIFFScanlineSize(tif);\n\tif (!tif->tif_scanlinesize) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Cannot handle zero scanline size\");\n\t\treturn (0);\n\t}\n\n\tif (isTiled(tif)) {\n\t\ttif->tif_tilesize = TIFFTileSize(tif);\n\t\tif (!tif->tif_tilesize) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Cannot handle zero tile size\");\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (!TIFFStripSize(tif)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Cannot handle zero strip size\");\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\nbad:\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn (0);\n}\n\nstatic void\nTIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)\n{\n\tstatic const char module[] = \"TIFFReadDirectoryCheckOrder\";\n\tuint16 m;\n\tuint16 n;\n\tTIFFDirEntry* o;\n\tm=0;\n\tfor (n=0, o=dir; n<dircount; n++, o++)\n\t{\n\t\tif (o->tdir_tag<m)\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t    \"Invalid TIFF directory; tags are not sorted in ascending order\");\n\t\t\tbreak;\n\t\t}\n\t\tm=o->tdir_tag+1;\n\t}\n}\n\nstatic TIFFDirEntry*\nTIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid)\n{\n\tTIFFDirEntry* m;\n\tuint16 n;\n\t(void) tif;\n\tfor (m=dir, n=0; n<dircount; m++, n++)\n\t{\n\t\tif (m->tdir_tag==tagid)\n\t\t\treturn(m);\n\t}\n\treturn(0);\n}\n\nstatic void\nTIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii)\n{\n\tint32 ma,mb,mc;\n\tma=-1;\n\tmc=(int32)tif->tif_nfields;\n\twhile (1)\n\t{\n\t\tif (ma+1==mc)\n\t\t{\n\t\t\t*fii = FAILED_FII;\n\t\t\treturn;\n\t\t}\n\t\tmb=(ma+mc)/2;\n\t\tif (tif->tif_fields[mb]->field_tag==(uint32)tagid)\n\t\t\tbreak;\n\t\tif (tif->tif_fields[mb]->field_tag<(uint32)tagid)\n\t\t\tma=mb;\n\t\telse\n\t\t\tmc=mb;\n\t}\n\twhile (1)\n\t{\n\t\tif (mb==0)\n\t\t\tbreak;\n\t\tif (tif->tif_fields[mb-1]->field_tag!=(uint32)tagid)\n\t\t\tbreak;\n\t\tmb--;\n\t}\n\t*fii=mb;\n}\n\n/*\n * Read custom directory from the arbitrary offset.\n * The code is very similar to TIFFReadDirectory().\n */\nint\nTIFFReadCustomDirectory(TIFF* tif, toff_t diroff,\n\t\t\tconst TIFFFieldArray* infoarray)\n{\n\tstatic const char module[] = \"TIFFReadCustomDirectory\";\n\tTIFFDirEntry* dir;\n\tuint16 dircount;\n\tTIFFDirEntry* dp;\n\tuint16 di;\n\tconst TIFFField* fip;\n\tuint32 fii;\n\t_TIFFSetupFields(tif, infoarray);\n\tdircount=TIFFFetchDirectory(tif,diroff,&dir,NULL);\n\tif (!dircount)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"Failed to read custom directory at offset \" TIFF_UINT64_FORMAT,diroff);\n\t\treturn 0;\n\t}\n\tTIFFFreeDirectory(tif);\n\t_TIFFmemset(&tif->tif_dir, 0, sizeof(TIFFDirectory));\n\tTIFFReadDirectoryCheckOrder(tif,dir,dircount);\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\tif (fii == FAILED_FII)\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Unknown field with tag %d (0x%x) encountered\",\n\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\tif (!_TIFFMergeFields(tif, _TIFFCreateAnonField(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t     1)) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Registering anonymous field with tag %d (0x%x) failed\",\n\t\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\t} else {\n\t\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\t\tassert( fii != FAILED_FII );\n\t\t\t}\n\t\t}\n\t\tif (dp->tdir_tag!=IGNORE)\n\t\t{\n\t\t\tfip=tif->tif_fields[fii];\n\t\t\tif (fip->field_bit==FIELD_IGNORE)\n\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* check data type */\n\t\t\t\twhile ((fip->field_type!=TIFF_ANY)&&(fip->field_type!=dp->tdir_type))\n\t\t\t\t{\n\t\t\t\t\tfii++;\n\t\t\t\t\tif ((fii==tif->tif_nfields)||\n\t\t\t\t\t    (tif->tif_fields[fii]->field_tag!=(uint32)dp->tdir_tag))\n\t\t\t\t\t{\n\t\t\t\t\t\tfii=0xFFFF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfip=tif->tif_fields[fii];\n\t\t\t\t}\n\t\t\t\tif (fii==0xFFFF)\n\t\t\t\t{\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Wrong data type %d for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    dp->tdir_type,fip->field_name);\n\t\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* check count if known in advance */\n\t\t\t\t\tif ((fip->field_readcount!=TIFF_VARIABLE)&&\n\t\t\t\t\t    (fip->field_readcount!=TIFF_VARIABLE2))\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32 expected;\n\t\t\t\t\t\tif (fip->field_readcount==TIFF_SPP)\n\t\t\t\t\t\t\texpected=(uint32)tif->tif_dir.td_samplesperpixel;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\texpected=(uint32)fip->field_readcount;\n\t\t\t\t\t\tif (!CheckDirCount(tif,dp,expected))\n\t\t\t\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (dp->tdir_tag)\n\t\t\t{\n\t\t\t\tcase IGNORE:\n\t\t\t\t\tbreak;\n\t\t\t\tcase EXIFTAG_SUBJECTDISTANCE:\n\t\t\t\t\t(void) TIFFFetchSubjectDistance(tif,dp);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t(void) TIFFFetchNormalTag(tif, dp, TRUE);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn 1;\n}\n\n/*\n * EXIF is important special case of custom IFD, so we have a special\n * function to read it.\n */\nint\nTIFFReadEXIFDirectory(TIFF* tif, toff_t diroff)\n{\n\tconst TIFFFieldArray* exifFieldArray;\n\texifFieldArray = _TIFFGetExifFields();\n\treturn TIFFReadCustomDirectory(tif, diroff, exifFieldArray);  \n}\n\nstatic int\nEstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)\n{\n\tstatic const char module[] = \"EstimateStripByteCounts\";\n\n\tTIFFDirEntry *dp;\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 strip;\n\n    /* Do not try to load stripbytecount as we will compute it */\n        if( !_TIFFFillStrilesInternal( tif, 0 ) )\n            return -1;\n\n\tif (td->td_stripbytecount)\n\t\t_TIFFfree(td->td_stripbytecount);\n\ttd->td_stripbytecount = (uint64*)\n\t    _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint64),\n\t\t\"for \\\"StripByteCounts\\\" array\");\n        if( td->td_stripbytecount == NULL )\n            return -1;\n\n\tif (td->td_compression != COMPRESSION_NONE) {\n\t\tuint64 space;\n\t\tuint64 filesize;\n\t\tuint16 n;\n\t\tfilesize = TIFFGetFileSize(tif);\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\tspace=sizeof(TIFFHeaderClassic)+2+dircount*12+4;\n\t\telse\n\t\t\tspace=sizeof(TIFFHeaderBig)+8+dircount*20+8;\n\t\t/* calculate amount of space used by indirect values */\n\t\tfor (dp = dir, n = dircount; n > 0; n--, dp++)\n\t\t{\n\t\t\tuint32 typewidth;\n\t\t\tuint64 datasize;\n\t\t\ttypewidth = TIFFDataWidth((TIFFDataType) dp->tdir_type);\n\t\t\tif (typewidth == 0) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Cannot determine size of unknown tag type %d\",\n\t\t\t\t    dp->tdir_type);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdatasize=(uint64)typewidth*dp->tdir_count;\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t{\n\t\t\t\tif (datasize<=4)\n\t\t\t\t\tdatasize=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (datasize<=8)\n\t\t\t\t\tdatasize=0;\n\t\t\t}\n\t\t\tspace+=datasize;\n\t\t}\n\t\tif( filesize < space )\n                    /* we should perhaps return in error ? */\n                    space = filesize;\n                else\n                    space = filesize - space;\n\t\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\t\tspace /= td->td_samplesperpixel;\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n\t\t\ttd->td_stripbytecount[strip] = space;\n\t\t/*\n\t\t * This gross hack handles the case were the offset to\n\t\t * the last strip is past the place where we think the strip\n\t\t * should begin.  Since a strip of data must be contiguous,\n\t\t * it's safe to assume that we've overestimated the amount\n\t\t * of data in the strip and trim this number back accordingly.\n\t\t */\n\t\tstrip--;\n\t\tif (td->td_stripoffset[strip]+td->td_stripbytecount[strip] > filesize)\n\t\t\ttd->td_stripbytecount[strip] = filesize - td->td_stripoffset[strip];\n\t} else if (isTiled(tif)) {\n\t\tuint64 bytespertile = TIFFTileSize64(tif);\n\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n\t\t    td->td_stripbytecount[strip] = bytespertile;\n\t} else {\n\t\tuint64 rowbytes = TIFFScanlineSize64(tif);\n\t\tuint32 rowsperstrip = td->td_imagelength/td->td_stripsperimage;\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n\t\t\ttd->td_stripbytecount[strip] = rowbytes * rowsperstrip;\n\t}\n\tTIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);\n\tif (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP))\n\t\ttd->td_rowsperstrip = td->td_imagelength;\n\treturn 1;\n}\n\nstatic void\nMissingRequired(TIFF* tif, const char* tagname)\n{\n\tstatic const char module[] = \"MissingRequired\";\n\n\tTIFFErrorExt(tif->tif_clientdata, module,\n\t    \"TIFF directory is missing required \\\"%s\\\" field\",\n\t    tagname);\n}\n\n/*\n * Check the directory offset against the list of already seen directory\n * offsets. This is a trick to prevent IFD looping. The one can create TIFF\n * file with looped directory pointers. We will maintain a list of already\n * seen directories and check every IFD offset against that list.\n */\nstatic int\nTIFFCheckDirOffset(TIFF* tif, uint64 diroff)\n{\n\tuint16 n;\n\n\tif (diroff == 0)\t\t\t/* no more directories */\n\t\treturn 0;\n\tif (tif->tif_dirnumber == 65535) {\n\t    TIFFErrorExt(tif->tif_clientdata, \"TIFFCheckDirOffset\",\n\t\t\t \"Cannot handle more than 65535 TIFF directories\");\n\t    return 0;\n\t}\n\n\tfor (n = 0; n < tif->tif_dirnumber && tif->tif_dirlist; n++) {\n\t\tif (tif->tif_dirlist[n] == diroff)\n\t\t\treturn 0;\n\t}\n\n\ttif->tif_dirnumber++;\n\n\tif (tif->tif_dirlist == NULL || tif->tif_dirnumber > tif->tif_dirlistsize) {\n\t\tuint64* new_dirlist;\n\n\t\t/*\n\t\t * XXX: Reduce memory allocation granularity of the dirlist\n\t\t * array.\n\t\t */\n\t\tnew_dirlist = (uint64*)_TIFFCheckRealloc(tif, tif->tif_dirlist,\n\t\t    tif->tif_dirnumber, 2 * sizeof(uint64), \"for IFD list\");\n\t\tif (!new_dirlist)\n\t\t\treturn 0;\n\t\tif( tif->tif_dirnumber >= 32768 )\n\t\t    tif->tif_dirlistsize = 65535;\n\t\telse\n\t\t    tif->tif_dirlistsize = 2 * tif->tif_dirnumber;\n\t\ttif->tif_dirlist = new_dirlist;\n\t}\n\n\ttif->tif_dirlist[tif->tif_dirnumber - 1] = diroff;\n\n\treturn 1;\n}\n\n/*\n * Check the count field of a directory entry against a known value.  The\n * caller is expected to skip/ignore the tag if there is a mismatch.\n */\nstatic int\nCheckDirCount(TIFF* tif, TIFFDirEntry* dir, uint32 count)\n{\n\tif ((uint64)count > dir->tdir_count) {\n\t\tconst TIFFField* fip = TIFFFieldWithTag(tif, dir->tdir_tag);\n\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\"incorrect count for field \\\"%s\\\" (\" TIFF_UINT64_FORMAT \", expecting %u); tag ignored\",\n\t\t    fip ? fip->field_name : \"unknown tagname\",\n\t\t    dir->tdir_count, count);\n\t\treturn (0);\n\t} else if ((uint64)count < dir->tdir_count) {\n\t\tconst TIFFField* fip = TIFFFieldWithTag(tif, dir->tdir_tag);\n\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\"incorrect count for field \\\"%s\\\" (\" TIFF_UINT64_FORMAT \", expecting %u); tag trimmed\",\n\t\t    fip ? fip->field_name : \"unknown tagname\",\n\t\t    dir->tdir_count, count);\n\t\tdir->tdir_count = count;\n\t\treturn (1);\n\t}\n\treturn (1);\n}\n\n/*\n * Read IFD structure from the specified offset. If the pointer to\n * nextdiroff variable has been specified, read it too. Function returns a\n * number of fields in the directory or 0 if failed.\n */\nstatic uint16\nTIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,\n                   uint64 *nextdiroff)\n{\n\tstatic const char module[] = \"TIFFFetchDirectory\";\n\n\tvoid* origdir;\n\tuint16 dircount16;\n\tuint32 dirsize;\n\tTIFFDirEntry* dir;\n\tuint8* ma;\n\tTIFFDirEntry* mb;\n\tuint16 n;\n\n\tassert(pdir);\n\n\ttif->tif_diroff = diroff;\n\tif (nextdiroff)\n\t\t*nextdiroff = 0;\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif, tif->tif_diroff)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%s: Seek error accessing TIFF directory\",\n\t\t\t\ttif->tif_name);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tif (!ReadOK(tif, &dircount16, sizeof (uint16))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"%s: Can not read TIFF directory count\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount16);\n\t\t\tif (dircount16>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdirsize = 12;\n\t\t} else {\n\t\t\tuint64 dircount64;\n\t\t\tif (!ReadOK(tif, &dircount64, sizeof (uint64))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"%s: Can not read TIFF directory count\",\n\t\t\t\t\ttif->tif_name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdircount16 = (uint16)dircount64;\n\t\t\tdirsize = 20;\n\t\t}\n\t\torigdir = _TIFFCheckMalloc(tif, dircount16,\n\t\t    dirsize, \"to read TIFF directory\");\n\t\tif (origdir == NULL)\n\t\t\treturn 0;\n\t\tif (!ReadOK(tif, origdir, (tmsize_t)(dircount16*dirsize))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%.100s: Can not read TIFF directory\",\n\t\t\t\ttif->tif_name);\n\t\t\t_TIFFfree(origdir);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Read offset to next directory for sequential scans if\n\t\t * needed.\n\t\t */\n\t\tif (nextdiroff)\n\t\t{\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t{\n\t\t\t\tuint32 nextdiroff32;\n\t\t\t\tif (!ReadOK(tif, &nextdiroff32, sizeof(uint32)))\n\t\t\t\t\tnextdiroff32 = 0;\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong(&nextdiroff32);\n\t\t\t\t*nextdiroff=nextdiroff32;\n\t\t\t} else {\n\t\t\t\tif (!ReadOK(tif, nextdiroff, sizeof(uint64)))\n\t\t\t\t\t*nextdiroff = 0;\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong8(nextdiroff);\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttmsize_t m;\n\t\ttmsize_t off = (tmsize_t) tif->tif_diroff;\n\t\tif ((uint64)off!=tif->tif_diroff)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Can not read TIFF directory count\");\n\t\t\treturn(0);\n\t\t}\n\n\t\t/*\n\t\t * Check for integer overflow when validating the dir_off,\n\t\t * otherwise a very high offset may cause an OOB read and\n\t\t * crash the client. Make two comparisons instead of\n\t\t *\n\t\t *  off + sizeof(uint16) > tif->tif_size\n\t\t *\n\t\t * to avoid overflow.\n\t\t */\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tm=off+sizeof(uint16);\n\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint16))||(m>tif->tif_size)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"Can not read TIFF directory count\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t_TIFFmemcpy(&dircount16, tif->tif_base + off,\n\t\t\t\t\t    sizeof(uint16));\n\t\t\t}\n\t\t\toff += sizeof (uint16);\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount16);\n\t\t\tif (dircount16>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdirsize = 12;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 dircount64;\n\t\t\tm=off+sizeof(uint64);\n\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint64))||(m>tif->tif_size)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"Can not read TIFF directory count\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t_TIFFmemcpy(&dircount64, tif->tif_base + off,\n\t\t\t\t\t    sizeof(uint64));\n\t\t\t}\n\t\t\toff += sizeof (uint64);\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdircount16 = (uint16)dircount64;\n\t\t\tdirsize = 20;\n\t\t}\n\t\tif (dircount16 == 0 )\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t             \"Sanity check on directory count failed, zero tag directories not supported\");\n\t\t\treturn 0;\n\t\t}\n\t\torigdir = _TIFFCheckMalloc(tif, dircount16,\n\t\t\t\t\t\tdirsize,\n\t\t\t\t\t\t\"to read TIFF directory\");\n\t\tif (origdir == NULL)\n\t\t\treturn 0;\n\t\tm=off+dircount16*dirsize;\n\t\tif ((m<off)||(m<(tmsize_t)(dircount16*dirsize))||(m>tif->tif_size)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"Can not read TIFF directory\");\n\t\t\t_TIFFfree(origdir);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t_TIFFmemcpy(origdir, tif->tif_base + off,\n\t\t\t\t    dircount16 * dirsize);\n\t\t}\n\t\tif (nextdiroff) {\n\t\t\toff += dircount16 * dirsize;\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t{\n\t\t\t\tuint32 nextdiroff32;\n\t\t\t\tm=off+sizeof(uint32);\n\t\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint32))||(m>tif->tif_size))\n\t\t\t\t\tnextdiroff32 = 0;\n\t\t\t\telse\n\t\t\t\t\t_TIFFmemcpy(&nextdiroff32, tif->tif_base + off,\n\t\t\t\t\t\t    sizeof (uint32));\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong(&nextdiroff32);\n\t\t\t\t*nextdiroff = nextdiroff32;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm=off+sizeof(uint64);\n\t\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint64))||(m>tif->tif_size))\n\t\t\t\t\t*nextdiroff = 0;\n\t\t\t\telse\n\t\t\t\t\t_TIFFmemcpy(nextdiroff, tif->tif_base + off,\n\t\t\t\t\t\t    sizeof (uint64));\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong8(nextdiroff);\n\t\t\t}\n\t\t}\n\t}\n\tdir = (TIFFDirEntry*)_TIFFCheckMalloc(tif, dircount16,\n\t\t\t\t\t\tsizeof(TIFFDirEntry),\n\t\t\t\t\t\t\"to read TIFF directory\");\n\tif (dir==0)\n\t{\n\t\t_TIFFfree(origdir);\n\t\treturn 0;\n\t}\n\tma=(uint8*)origdir;\n\tmb=dir;\n\tfor (n=0; n<dircount16; n++)\n\t{\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)ma);\n\t\tmb->tdir_tag=*(uint16*)ma;\n\t\tma+=sizeof(uint16);\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)ma);\n\t\tmb->tdir_type=*(uint16*)ma;\n\t\tma+=sizeof(uint16);\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\tmb->tdir_count=(uint64)(*(uint32*)ma);\n\t\t\tma+=sizeof(uint32);\n\t\t\t*(uint32*)(&mb->tdir_offset)=*(uint32*)ma;\n\t\t\tma+=sizeof(uint32);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8((uint64*)ma);\n                        mb->tdir_count=TIFFReadUInt64(ma);\n\t\t\tma+=sizeof(uint64);\n\t\t\tmb->tdir_offset.toff_long8=TIFFReadUInt64(ma);\n\t\t\tma+=sizeof(uint64);\n\t\t}\n\t\tmb++;\n\t}\n\t_TIFFfree(origdir);\n\t*pdir = dir;\n\treturn dircount16;\n}\n\n/*\n * Fetch a tag that is not handled by special case code.\n */\nstatic int\nTIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)\n{\n\tstatic const char module[] = \"TIFFFetchNormalTag\";\n\tenum TIFFReadDirEntryErr err;\n\tuint32 fii;\n\tconst TIFFField* fip = NULL;\n\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n        if( fii == FAILED_FII )\n        {\n            TIFFErrorExt(tif->tif_clientdata, \"TIFFFetchNormalTag\",\n                         \"No definition found for tag %d\",\n                         dp->tdir_tag);\n            return 0;\n        }\n\tfip=tif->tif_fields[fii];\n\tassert(fip != NULL); /* should not happen */\n\tassert(fip->set_field_type!=TIFF_SETGET_OTHER);  /* if so, we shouldn't arrive here but deal with this in specialized code */\n\tassert(fip->set_field_type!=TIFF_SETGET_INT);    /* if so, we shouldn't arrive here as this is only the case for pseudo-tags */\n\terr=TIFFReadDirEntryErrOk;\n\tswitch (fip->set_field_type)\n\t{\n\t\tcase TIFF_SETGET_UNDEFINED:\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tuint32 mb = 0;\n\t\t\t\t\tint n;\n\t\t\t\t\tif (data != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    uint8* ma = data;\n\t\t\t\t\t    while (mb<(uint32)dp->tdir_count)\n\t\t\t\t\t    {\n\t\t\t\t\t            if (*ma==0)\n\t\t\t\t\t                    break;\n\t\t\t\t\t            ma++;\n\t\t\t\t\t            mb++;\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t\tif (mb+1<(uint32)dp->tdir_count)\n\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" contains null byte in value; value incorrectly truncated during reading due to implementation limitations\",fip->field_name);\n\t\t\t\t\telse if (mb+1>(uint32)dp->tdir_count)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8* o;\n\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte\",fip->field_name);\n\t\t\t\t\t\tif ((uint32)dp->tdir_count+1!=dp->tdir_count+1)\n\t\t\t\t\t\t\to=NULL;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\to=_TIFFmalloc((uint32)dp->tdir_count+1);\n\t\t\t\t\t\tif (o==NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (data!=NULL)\n\t\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_TIFFmemcpy(o,data,(uint32)dp->tdir_count);\n\t\t\t\t\t\to[(uint32)dp->tdir_count]=0;\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tdata=o;\n\t\t\t\t\t}\n\t\t\t\t\tn=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!n)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT8:\n\t\t\t{\n\t\t\t\tuint8 data=0;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryByte(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT16:\n\t\t\t{\n\t\t\t\tuint16 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryShort(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT32:\n\t\t\t{\n\t\t\t\tuint32 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryLong(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT64:\n\t\t\t{\n\t\t\t\tuint64 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryLong8(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_FLOAT:\n\t\t\t{\n\t\t\t\tfloat data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryFloat(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryDouble(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_IFD8:\n\t\t\t{\n\t\t\t\tuint64 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryIfd8(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT16_PAIR:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==2);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=2) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t       \"incorrect count for field \\\"%s\\\", expected 2, got %d\",\n\t\t\t\t\t\t       fip->field_name,(int)dp->tdir_count);\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data[0],data[1]);\n\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t       \"incorrect count for field \\\"%s\\\", expected %d, got %d\",\n\t\t\t\t\t\t       fip->field_name,(int) fip->field_readcount, (int)dp->tdir_count);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tif( data != 0 && dp->tdir_count > 0 && data[dp->tdir_count-1] != '\\0' )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t    TIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte. Forcing it to be null\",fip->field_name);\n\t\t\t\t\t\t    data[dp->tdir_count-1] = '\\0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT64:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLong8Array(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryDoubleArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_IFD8:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryIfd8Array(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tif( data != 0 && dp->tdir_count > 0 && data[dp->tdir_count-1] != '\\0' )\n\t\t\t\t\t{\n\t\t\t\t\t    TIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte. Forcing it to be null\",fip->field_name);\n                                            data[dp->tdir_count-1] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT8:\n\t\t\t{\n\t\t\t\tint8* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySbyteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT16:\n\t\t\t{\n\t\t\t\tint16* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySshortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT32:\n\t\t\t{\n\t\t\t\tint32* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySlongArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT64:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryLong8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT64:\n\t\t\t{\n\t\t\t\tint64* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySlong8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryDoubleArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_IFD8:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryIfd8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);    /* we should never get here */\n\t\t\tbreak;\n\t}\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip->field_name,recover);\n\t\treturn(0);\n\t}\n\treturn(1);\n}\n\n/*\n * Fetch a set of offsets or lengths.\n * While this routine says \"strips\", in fact it's also used for tiles.\n */\nstatic int\nTIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)\n{\n\tstatic const char module[] = \"TIFFFetchStripThing\";\n\tenum TIFFReadDirEntryErr err;\n\tuint64* data;\n\terr=TIFFReadDirEntryLong8ArrayWithLimit(tif,dir,&data,nstrips);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\tconst TIFFField* fip = TIFFFieldWithTag(tif,dir->tdir_tag); \n\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\n\t\treturn(0);\n\t}\n\tif (dir->tdir_count<(uint64)nstrips)\n\t{\n\t\tuint64* resizeddata;\n\t\tconst TIFFField* fip = TIFFFieldWithTag(tif,dir->tdir_tag);\n\t\tconst char* pszMax = getenv(\"LIBTIFF_STRILE_ARRAY_MAX_RESIZE_COUNT\");\n\t\tuint32 max_nstrips = 1000000;\n\t\tif( pszMax )\n\t\t\tmax_nstrips = (uint32) atoi(pszMax);\n\t\tTIFFReadDirEntryOutputErr(tif,TIFFReadDirEntryErrCount,\n\t\t            module,\n\t\t            fip ? fip->field_name : \"unknown tagname\",\n\t\t            ( nstrips <= max_nstrips ) );\n\n\t\tif( nstrips > max_nstrips )\n\t\t{\n\t\t\t_TIFFfree(data);\n\t\t\treturn(0);\n\t\t}\n\n\t\tresizeddata=(uint64*)_TIFFCheckMalloc(tif,nstrips,sizeof(uint64),\"for strip array\");\n\t\tif (resizeddata==0) {\n\t\t\t_TIFFfree(data);\n\t\t\treturn(0);\n\t\t}\n                _TIFFmemcpy(resizeddata,data,(uint32)dir->tdir_count*sizeof(uint64));\n                _TIFFmemset(resizeddata+(uint32)dir->tdir_count,0,(nstrips-(uint32)dir->tdir_count)*sizeof(uint64));\n\t\t_TIFFfree(data);\n\t\tdata=resizeddata;\n\t}\n\t*lpp=data;\n\treturn(1);\n}\n\n/*\n * Fetch and set the SubjectDistance EXIF tag.\n */\nstatic int\nTIFFFetchSubjectDistance(TIFF* tif, TIFFDirEntry* dir)\n{\n\tstatic const char module[] = \"TIFFFetchSubjectDistance\";\n\tenum TIFFReadDirEntryErr err;\n\tUInt64Aligned_t m;\n    m.l=0;\n\tassert(sizeof(double)==8);\n\tassert(sizeof(uint64)==8);\n\tassert(sizeof(uint32)==4);\n\tif (dir->tdir_count!=1)\n\t\terr=TIFFReadDirEntryErrCount;\n\telse if (dir->tdir_type!=TIFF_RATIONAL)\n\t\terr=TIFFReadDirEntryErrType;\n\telse\n\t{\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tuint32 offset;\n\t\t\toffset=*(uint32*)(&dir->tdir_offset);\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\terr=TIFFReadDirEntryData(tif,offset,8,m.i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm.l=dir->tdir_offset.toff_long8;\n\t\t\terr=TIFFReadDirEntryErrOk;\n\t\t}\n\t}\n\tif (err==TIFFReadDirEntryErrOk)\n\t{\n\t\tdouble n;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabArrayOfLong(m.i,2);\n\t\tif (m.i[0]==0)\n\t\t\tn=0.0;\n\t\telse if (m.i[0]==0xFFFFFFFF)\n\t\t\t/*\n\t\t\t * XXX: Numerator 0xFFFFFFFF means that we have infinite\n\t\t\t * distance. Indicate that with a negative floating point\n\t\t\t * SubjectDistance value.\n\t\t\t */\n\t\t\tn=-1.0;\n\t\telse\n\t\t\tn=(double)m.i[0]/(double)m.i[1];\n\t\treturn(TIFFSetField(tif,dir->tdir_tag,n));\n\t}\n\telse\n\t{\n\t\tTIFFReadDirEntryOutputErr(tif,err,module,\"SubjectDistance\",TRUE);\n\t\treturn(0);\n\t}\n}\n\nstatic void allocChoppedUpStripArrays(TIFF* tif, uint32 nstrips,\n                                      uint64 stripbytes, uint32 rowsperstrip)\n{\n    TIFFDirectory *td = &tif->tif_dir;\n    uint64 bytecount;\n    uint64 offset;\n    uint32 i;\n    uint64 *newcounts;\n    uint64 *newoffsets;\n\n    newcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),\n                            \"for chopped \\\"StripByteCounts\\\" array\");\n    newoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),\n                            \"for chopped \\\"StripOffsets\\\" array\");\n    if (newcounts == NULL || newoffsets == NULL) {\n        /*\n        * Unable to allocate new strip information, give up and use\n        * the original one strip information.\n        */\n        if (newcounts != NULL)\n            _TIFFfree(newcounts);\n        if (newoffsets != NULL)\n            _TIFFfree(newoffsets);\n        return;\n    }\n\n    /*\n     * Fill the strip information arrays with new bytecounts and offsets\n     * that reflect the broken-up format.\n     */\n    offset = td->td_stripoffset[0];\n    bytecount = td->td_stripoffset[td->td_nstrips-1] +\n                td->td_stripbytecount[td->td_nstrips-1] - offset;\n    for (i = 0; i < nstrips; i++)\n    {\n        if (stripbytes > bytecount)\n            stripbytes = bytecount;\n        newcounts[i] = stripbytes;\n        newoffsets[i] = stripbytes ? offset : 0;\n        offset += stripbytes;\n        bytecount -= stripbytes;\n    }\n\n    /*\n     * Replace old single strip info with multi-strip info.\n     */\n    td->td_stripsperimage = td->td_nstrips = nstrips;\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n    _TIFFfree(td->td_stripbytecount);\n    _TIFFfree(td->td_stripoffset);\n    td->td_stripbytecount = newcounts;\n    td->td_stripoffset = newoffsets;\n    td->td_stripbytecountsorted = 1;\n}\n\n\n/*\n * Replace a single strip (tile) of uncompressed data by multiple strips\n * (tiles), each approximately STRIP_SIZE_DEFAULT bytes. This is useful for\n * dealing with large images or for dealing with machines with a limited\n * amount memory.\n */\nstatic void\nChopUpSingleUncompressedStrip(TIFF* tif)\n{\n\tregister TIFFDirectory *td = &tif->tif_dir;\n\tuint64 bytecount;\n\tuint64 offset;\n\tuint32 rowblock;\n\tuint64 rowblockbytes;\n\tuint64 stripbytes;\n\tuint32 nstrips;\n\tuint32 rowsperstrip;\n\n\tbytecount = td->td_stripbytecount[0];\n        /* On a newly created file, just re-opened to be filled, we */\n        /* don't want strip chop to trigger as it is going to cause issues */\n        /* later ( StripOffsets and StripByteCounts improperly filled) . */\n        if( bytecount == 0 && tif->tif_mode != O_RDONLY )\n            return;\n\toffset = td->td_stripoffset[0];\n\tassert(td->td_planarconfig == PLANARCONFIG_CONTIG);\n\tif ((td->td_photometric == PHOTOMETRIC_YCBCR)&&\n\t    (!isUpSampled(tif)))\n\t\trowblock = td->td_ycbcrsubsampling[1];\n\telse\n\t\trowblock = 1;\n\trowblockbytes = TIFFVTileSize64(tif, rowblock);\n\t/*\n\t * Make the rows hold at least one scanline, but fill specified amount\n\t * of data if possible.\n\t */\n\tif (rowblockbytes > STRIP_SIZE_DEFAULT) {\n\t\tstripbytes = rowblockbytes;\n\t\trowsperstrip = rowblock;\n\t} else if (rowblockbytes > 0 ) {\n\t\tuint32 rowblocksperstrip;\n\t\trowblocksperstrip = (uint32) (STRIP_SIZE_DEFAULT / rowblockbytes);\n\t\trowsperstrip = rowblocksperstrip * rowblock;\n\t\tstripbytes = rowblocksperstrip * rowblockbytes;\n\t}\n\telse\n\t    return;\n\n\t/*\n\t * never increase the number of rows per strip\n\t */\n\tif (rowsperstrip >= td->td_rowsperstrip)\n\t\treturn;\n        nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);\n        if( nstrips == 0 )\n            return;\n\n        /* If we are going to allocate a lot of memory, make sure that the */\n        /* file is as big as needed */\n        if( tif->tif_mode == O_RDONLY &&\n            nstrips > 1000000 &&\n            (offset >= TIFFGetFileSize(tif) ||\n             stripbytes > (TIFFGetFileSize(tif) - offset) / (nstrips - 1)) )\n        {\n            return;\n        }\n\n        allocChoppedUpStripArrays(tif, nstrips, stripbytes, rowsperstrip);\n}\n\n\n/*\n * Replace a file with contiguous strips > 2 GB of uncompressed data by\n * multiple smaller strips. This is useful for\n * dealing with large images or for dealing with machines with a limited\n * amount memory.\n */\nstatic void TryChopUpUncompressedBigTiff( TIFF* tif )\n{\n    TIFFDirectory *td = &tif->tif_dir;\n    uint32 rowblock;\n    uint64 rowblockbytes;\n    uint32 i;\n    uint64 stripsize;\n    uint32 rowblocksperstrip;\n    uint32 rowsperstrip;\n    uint64 stripbytes;\n    uint32 nstrips;\n\n    stripsize = TIFFStripSize64(tif);\n\n    assert( tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG );\n    assert( tif->tif_dir.td_compression == COMPRESSION_NONE );\n    assert( (tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP );\n    assert( stripsize > 0x7FFFFFFFUL );\n\n    /* On a newly created file, just re-opened to be filled, we */\n    /* don't want strip chop to trigger as it is going to cause issues */\n    /* later ( StripOffsets and StripByteCounts improperly filled) . */\n    if( td->td_stripbytecount[0] == 0 && tif->tif_mode != O_RDONLY )\n        return;\n\n    if ((td->td_photometric == PHOTOMETRIC_YCBCR)&&\n        (!isUpSampled(tif)))\n        rowblock = td->td_ycbcrsubsampling[1];\n    else\n        rowblock = 1;\n    rowblockbytes = TIFFVStripSize64(tif, rowblock);\n    if( rowblockbytes > 0x7FFFFFFFUL )\n    {\n        /* In case of file with gigantic width */\n        return;\n    }\n\n    /* Check that the strips are contiguous and of the expected size */\n    for( i = 0; i < td->td_nstrips; i++ )\n    {\n        if( i == td->td_nstrips - 1 )\n        {\n            if( td->td_stripbytecount[i] < TIFFVStripSize64(\n                    tif, td->td_imagelength - i * td->td_rowsperstrip ) )\n            {\n                return;\n            }\n        }\n        else\n        {\n            if( td->td_stripbytecount[i] != stripsize )\n            {\n                return;\n            }\n            if( i > 0 && td->td_stripoffset[i] !=\n                    td->td_stripoffset[i-1] + td->td_stripbytecount[i - 1] )\n            {\n                return;\n            }\n        }\n    }\n\n    /* Aim for 512 MB strips (that will still be manageable by 32 bit builds */\n    rowblocksperstrip = (uint32) (512 * 1024 * 1024 / rowblockbytes);\n    if( rowblocksperstrip == 0 )\n        rowblocksperstrip = 1;\n    rowsperstrip = rowblocksperstrip * rowblock;\n    stripbytes = rowblocksperstrip * rowblockbytes;\n    assert( stripbytes <= 0x7FFFFFFFUL );\n\n    nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);\n    if( nstrips == 0 )\n        return;\n\n    /* If we are going to allocate a lot of memory, make sure that the */\n    /* file is as big as needed */\n    if( tif->tif_mode == O_RDONLY &&\n        nstrips > 1000000 &&\n        (td->td_stripoffset[td->td_nstrips-1] > TIFFGetFileSize(tif) ||\n         td->td_stripoffset[td->td_nstrips-1] +\n         td->td_stripbytecount[td->td_nstrips-1] > TIFFGetFileSize(tif)) )\n    {\n        return;\n    }\n\n    allocChoppedUpStripArrays(tif, nstrips, stripbytes, rowsperstrip);\n}\n\n\n\nint _TIFFFillStriles( TIFF *tif )\n{\n    return _TIFFFillStrilesInternal( tif, 1 );\n}\n\nstatic int _TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount )\n{\n#if defined(DEFER_STRILE_LOAD)\n        register TIFFDirectory *td = &tif->tif_dir;\n        int return_value = 1;\n\n        if( td->td_stripoffset != NULL )\n                return 1;\n\n        if( td->td_stripoffset_entry.tdir_count == 0 )\n                return 0;\n\n        if (!TIFFFetchStripThing(tif,&(td->td_stripoffset_entry),\n                                 td->td_nstrips,&td->td_stripoffset))\n        {\n                return_value = 0;\n        }\n\n        if (loadStripByteCount &&\n            !TIFFFetchStripThing(tif,&(td->td_stripbytecount_entry),\n                                 td->td_nstrips,&td->td_stripbytecount))\n        {\n                return_value = 0;\n        }\n\n        _TIFFmemset( &(td->td_stripoffset_entry), 0, sizeof(TIFFDirEntry));\n        _TIFFmemset( &(td->td_stripbytecount_entry), 0, sizeof(TIFFDirEntry));\n\n\tif (tif->tif_dir.td_nstrips > 1 && return_value == 1 ) {\n\t\tuint32 strip;\n\n\t\ttif->tif_dir.td_stripbytecountsorted = 1;\n\t\tfor (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {\n\t\t\tif (tif->tif_dir.td_stripoffset[strip - 1] >\n\t\t\t    tif->tif_dir.td_stripoffset[strip]) {\n\t\t\t\ttif->tif_dir.td_stripbytecountsorted = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n        return return_value;\n#else /* !defined(DEFER_STRILE_LOAD) */\n        (void) tif;\n        (void) loadStripByteCount;\n        return 1;\n#endif \n}\n\n\n/* vim: set ts=8 sts=8 sw=8 noet: */\n/*\n * Local Variables:\n * mode: c\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */",
          "fn_code_pos": [
            [
              3541,
              0
            ],
            [
              6001,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nTIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)\n{\n\tstatic const char module[] = \"TIFFReadDirectoryCheckOrder\";\n\tuint16 m;\n\tuint16 n;\n\tTIFFDirEntry* o;\n\tm=0;\n\tfor (n=0, o=dir; n<dircount; n++, o++)\n\t{\n\t\tif (o->tdir_tag<m)\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t    \"Invalid TIFF directory; tags are not sorted in ascending order\");\n\t\t\tbreak;\n\t\t}\n\t\tm=o->tdir_tag+1;\n\t}\n}",
          "fn_code_pos": [
            [
              4305,
              0
            ],
            [
              4323,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirectoryCheckOrder",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "dircount": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static TIFFDirEntry*\nTIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid)\n{\n\tTIFFDirEntry* m;\n\tuint16 n;\n\t(void) tif;\n\tfor (m=dir, n=0; n<dircount; m++, n++)\n\t{\n\t\tif (m->tdir_tag==tagid)\n\t\t\treturn(m);\n\t}\n\treturn(0);\n}",
          "fn_code_pos": [
            [
              4325,
              0
            ],
            [
              4337,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirectoryFindEntry",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "dircount": "uint16",
              "tagid": "uint16"
            },
            "return_type": "TIFFDirEntry"
          }
        },
        {
          "fn_code": "static void\nTIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii)\n{\n\tint32 ma,mb,mc;\n\tma=-1;\n\tmc=(int32)tif->tif_nfields;\n\twhile (1)\n\t{\n\t\tif (ma+1==mc)\n\t\t{\n\t\t\t*fii = FAILED_FII;\n\t\t\treturn;\n\t\t}\n\t\tmb=(ma+mc)/2;\n\t\tif (tif->tif_fields[mb]->field_tag==(uint32)tagid)\n\t\t\tbreak;\n\t\tif (tif->tif_fields[mb]->field_tag<(uint32)tagid)\n\t\t\tma=mb;\n\t\telse\n\t\t\tmc=mb;\n\t}\n\twhile (1)\n\t{\n\t\tif (mb==0)\n\t\t\tbreak;\n\t\tif (tif->tif_fields[mb-1]->field_tag!=(uint32)tagid)\n\t\t\tbreak;\n\t\tmb--;\n\t}\n\t*fii=mb;\n}",
          "fn_code_pos": [
            [
              4339,
              0
            ],
            [
              4369,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirectoryFindFieldInfo",
            "parameters": {
              "tif": "TIFF",
              "tagid": "uint16",
              "fii": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\nTIFFReadCustomDirectory(TIFF* tif, toff_t diroff,\n\t\t\tconst TIFFFieldArray* infoarray)\n{\n\tstatic const char module[] = \"TIFFReadCustomDirectory\";\n\tTIFFDirEntry* dir;\n\tuint16 dircount;\n\tTIFFDirEntry* dp;\n\tuint16 di;\n\tconst TIFFField* fip;\n\tuint32 fii;\n\t_TIFFSetupFields(tif, infoarray);\n\tdircount=TIFFFetchDirectory(tif,diroff,&dir,NULL);\n\tif (!dircount)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"Failed to read custom directory at offset \" TIFF_UINT64_FORMAT,diroff);\n\t\treturn 0;\n\t}\n\tTIFFFreeDirectory(tif);\n\t_TIFFmemset(&tif->tif_dir, 0, sizeof(TIFFDirectory));\n\tTIFFReadDirectoryCheckOrder(tif,dir,dircount);\n\tfor (di=0, dp=dir; di<dircount; di++, dp++)\n\t{\n\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\tif (fii == FAILED_FII)\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Unknown field with tag %d (0x%x) encountered\",\n\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\tif (!_TIFFMergeFields(tif, _TIFFCreateAnonField(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t     1)) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Registering anonymous field with tag %d (0x%x) failed\",\n\t\t\t\t    dp->tdir_tag, dp->tdir_tag);\n\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\t} else {\n\t\t\t\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n\t\t\t\tassert( fii != FAILED_FII );\n\t\t\t}\n\t\t}\n\t\tif (dp->tdir_tag!=IGNORE)\n\t\t{\n\t\t\tfip=tif->tif_fields[fii];\n\t\t\tif (fip->field_bit==FIELD_IGNORE)\n\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* check data type */\n\t\t\t\twhile ((fip->field_type!=TIFF_ANY)&&(fip->field_type!=dp->tdir_type))\n\t\t\t\t{\n\t\t\t\t\tfii++;\n\t\t\t\t\tif ((fii==tif->tif_nfields)||\n\t\t\t\t\t    (tif->tif_fields[fii]->field_tag!=(uint32)dp->tdir_tag))\n\t\t\t\t\t{\n\t\t\t\t\t\tfii=0xFFFF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfip=tif->tif_fields[fii];\n\t\t\t\t}\n\t\t\t\tif (fii==0xFFFF)\n\t\t\t\t{\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Wrong data type %d for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    dp->tdir_type,fip->field_name);\n\t\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* check count if known in advance */\n\t\t\t\t\tif ((fip->field_readcount!=TIFF_VARIABLE)&&\n\t\t\t\t\t    (fip->field_readcount!=TIFF_VARIABLE2))\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32 expected;\n\t\t\t\t\t\tif (fip->field_readcount==TIFF_SPP)\n\t\t\t\t\t\t\texpected=(uint32)tif->tif_dir.td_samplesperpixel;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\texpected=(uint32)fip->field_readcount;\n\t\t\t\t\t\tif (!CheckDirCount(tif,dp,expected))\n\t\t\t\t\t\t\tdp->tdir_tag=IGNORE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (dp->tdir_tag)\n\t\t\t{\n\t\t\t\tcase IGNORE:\n\t\t\t\t\tbreak;\n\t\t\t\tcase EXIFTAG_SUBJECTDISTANCE:\n\t\t\t\t\t(void) TIFFFetchSubjectDistance(tif,dp);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t(void) TIFFFetchNormalTag(tif, dp, TRUE);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              4375,
              0
            ],
            [
              4476,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadCustomDirectory",
            "parameters": {
              "tif": "TIFF",
              "diroff": "toff_t",
              "infoarray": "TIFFFieldArray"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFReadEXIFDirectory(TIFF* tif, toff_t diroff)\n{\n\tconst TIFFFieldArray* exifFieldArray;\n\texifFieldArray = _TIFFGetExifFields();\n\treturn TIFFReadCustomDirectory(tif, diroff, exifFieldArray);  \n}",
          "fn_code_pos": [
            [
              4482,
              0
            ],
            [
              4488,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadEXIFDirectory",
            "parameters": {
              "tif": "TIFF",
              "diroff": "toff_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nEstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)\n{\n\tstatic const char module[] = \"EstimateStripByteCounts\";\n\n\tTIFFDirEntry *dp;\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 strip;\n\n    /* Do not try to load stripbytecount as we will compute it */\n        if( !_TIFFFillStrilesInternal( tif, 0 ) )\n            return -1;\n\n\tif (td->td_stripbytecount)\n\t\t_TIFFfree(td->td_stripbytecount);\n\ttd->td_stripbytecount = (uint64*)\n\t    _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint64),\n\t\t\"for \\\"StripByteCounts\\\" array\");\n        if( td->td_stripbytecount == NULL )\n            return -1;\n\n\tif (td->td_compression != COMPRESSION_NONE) {\n\t\tuint64 space;\n\t\tuint64 filesize;\n\t\tuint16 n;\n\t\tfilesize = TIFFGetFileSize(tif);\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\tspace=sizeof(TIFFHeaderClassic)+2+dircount*12+4;\n\t\telse\n\t\t\tspace=sizeof(TIFFHeaderBig)+8+dircount*20+8;\n\t\t/* calculate amount of space used by indirect values */\n\t\tfor (dp = dir, n = dircount; n > 0; n--, dp++)\n\t\t{\n\t\t\tuint32 typewidth;\n\t\t\tuint64 datasize;\n\t\t\ttypewidth = TIFFDataWidth((TIFFDataType) dp->tdir_type);\n\t\t\tif (typewidth == 0) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Cannot determine size of unknown tag type %d\",\n\t\t\t\t    dp->tdir_type);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdatasize=(uint64)typewidth*dp->tdir_count;\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t{\n\t\t\t\tif (datasize<=4)\n\t\t\t\t\tdatasize=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (datasize<=8)\n\t\t\t\t\tdatasize=0;\n\t\t\t}\n\t\t\tspace+=datasize;\n\t\t}\n\t\tif( filesize < space )\n                    /* we should perhaps return in error ? */\n                    space = filesize;\n                else\n                    space = filesize - space;\n\t\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\t\tspace /= td->td_samplesperpixel;\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n\t\t\ttd->td_stripbytecount[strip] = space;\n\t\t/*\n\t\t * This gross hack handles the case were the offset to\n\t\t * the last strip is past the place where we think the strip\n\t\t * should begin.  Since a strip of data must be contiguous,\n\t\t * it's safe to assume that we've overestimated the amount\n\t\t * of data in the strip and trim this number back accordingly.\n\t\t */\n\t\tstrip--;\n\t\tif (td->td_stripoffset[strip]+td->td_stripbytecount[strip] > filesize)\n\t\t\ttd->td_stripbytecount[strip] = filesize - td->td_stripoffset[strip];\n\t} else if (isTiled(tif)) {\n\t\tuint64 bytespertile = TIFFTileSize64(tif);\n\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n\t\t    td->td_stripbytecount[strip] = bytespertile;\n\t} else {\n\t\tuint64 rowbytes = TIFFScanlineSize64(tif);\n\t\tuint32 rowsperstrip = td->td_imagelength/td->td_stripsperimage;\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n\t\t\ttd->td_stripbytecount[strip] = rowbytes * rowsperstrip;\n\t}\n\tTIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);\n\tif (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP))\n\t\ttd->td_rowsperstrip = td->td_imagelength;\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              4490,
              0
            ],
            [
              4579,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EstimateStripByteCounts",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "dircount": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nMissingRequired(TIFF* tif, const char* tagname)\n{\n\tstatic const char module[] = \"MissingRequired\";\n\n\tTIFFErrorExt(tif->tif_clientdata, module,\n\t    \"TIFF directory is missing required \\\"%s\\\" field\",\n\t    tagname);\n}",
          "fn_code_pos": [
            [
              4581,
              0
            ],
            [
              4589,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MissingRequired",
            "parameters": {
              "tif": "TIFF",
              "tagname": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nTIFFCheckDirOffset(TIFF* tif, uint64 diroff)\n{\n\tuint16 n;\n\n\tif (diroff == 0)\t\t\t/* no more directories */\n\t\treturn 0;\n\tif (tif->tif_dirnumber == 65535) {\n\t    TIFFErrorExt(tif->tif_clientdata, \"TIFFCheckDirOffset\",\n\t\t\t \"Cannot handle more than 65535 TIFF directories\");\n\t    return 0;\n\t}\n\n\tfor (n = 0; n < tif->tif_dirnumber && tif->tif_dirlist; n++) {\n\t\tif (tif->tif_dirlist[n] == diroff)\n\t\t\treturn 0;\n\t}\n\n\ttif->tif_dirnumber++;\n\n\tif (tif->tif_dirlist == NULL || tif->tif_dirnumber > tif->tif_dirlistsize) {\n\t\tuint64* new_dirlist;\n\n\t\t/*\n\t\t * XXX: Reduce memory allocation granularity of the dirlist\n\t\t * array.\n\t\t */\n\t\tnew_dirlist = (uint64*)_TIFFCheckRealloc(tif, tif->tif_dirlist,\n\t\t    tif->tif_dirnumber, 2 * sizeof(uint64), \"for IFD list\");\n\t\tif (!new_dirlist)\n\t\t\treturn 0;\n\t\tif( tif->tif_dirnumber >= 32768 )\n\t\t    tif->tif_dirlistsize = 65535;\n\t\telse\n\t\t    tif->tif_dirlistsize = 2 * tif->tif_dirnumber;\n\t\ttif->tif_dirlist = new_dirlist;\n\t}\n\n\ttif->tif_dirlist[tif->tif_dirnumber - 1] = diroff;\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              4597,
              0
            ],
            [
              4638,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCheckDirOffset",
            "parameters": {
              "tif": "TIFF",
              "diroff": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nCheckDirCount(TIFF* tif, TIFFDirEntry* dir, uint32 count)\n{\n\tif ((uint64)count > dir->tdir_count) {\n\t\tconst TIFFField* fip = TIFFFieldWithTag(tif, dir->tdir_tag);\n\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\"incorrect count for field \\\"%s\\\" (\" TIFF_UINT64_FORMAT \", expecting %u); tag ignored\",\n\t\t    fip ? fip->field_name : \"unknown tagname\",\n\t\t    dir->tdir_count, count);\n\t\treturn (0);\n\t} else if ((uint64)count < dir->tdir_count) {\n\t\tconst TIFFField* fip = TIFFFieldWithTag(tif, dir->tdir_tag);\n\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\"incorrect count for field \\\"%s\\\" (\" TIFF_UINT64_FORMAT \", expecting %u); tag trimmed\",\n\t\t    fip ? fip->field_name : \"unknown tagname\",\n\t\t    dir->tdir_count, count);\n\t\tdir->tdir_count = count;\n\t\treturn (1);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              4644,
              0
            ],
            [
              4664,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckDirCount",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "count": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static uint16\nTIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,\n                   uint64 *nextdiroff)\n{\n\tstatic const char module[] = \"TIFFFetchDirectory\";\n\n\tvoid* origdir;\n\tuint16 dircount16;\n\tuint32 dirsize;\n\tTIFFDirEntry* dir;\n\tuint8* ma;\n\tTIFFDirEntry* mb;\n\tuint16 n;\n\n\tassert(pdir);\n\n\ttif->tif_diroff = diroff;\n\tif (nextdiroff)\n\t\t*nextdiroff = 0;\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif, tif->tif_diroff)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%s: Seek error accessing TIFF directory\",\n\t\t\t\ttif->tif_name);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tif (!ReadOK(tif, &dircount16, sizeof (uint16))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"%s: Can not read TIFF directory count\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount16);\n\t\t\tif (dircount16>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdirsize = 12;\n\t\t} else {\n\t\t\tuint64 dircount64;\n\t\t\tif (!ReadOK(tif, &dircount64, sizeof (uint64))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"%s: Can not read TIFF directory count\",\n\t\t\t\t\ttif->tif_name);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdircount16 = (uint16)dircount64;\n\t\t\tdirsize = 20;\n\t\t}\n\t\torigdir = _TIFFCheckMalloc(tif, dircount16,\n\t\t    dirsize, \"to read TIFF directory\");\n\t\tif (origdir == NULL)\n\t\t\treturn 0;\n\t\tif (!ReadOK(tif, origdir, (tmsize_t)(dircount16*dirsize))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%.100s: Can not read TIFF directory\",\n\t\t\t\ttif->tif_name);\n\t\t\t_TIFFfree(origdir);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * Read offset to next directory for sequential scans if\n\t\t * needed.\n\t\t */\n\t\tif (nextdiroff)\n\t\t{\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t{\n\t\t\t\tuint32 nextdiroff32;\n\t\t\t\tif (!ReadOK(tif, &nextdiroff32, sizeof(uint32)))\n\t\t\t\t\tnextdiroff32 = 0;\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong(&nextdiroff32);\n\t\t\t\t*nextdiroff=nextdiroff32;\n\t\t\t} else {\n\t\t\t\tif (!ReadOK(tif, nextdiroff, sizeof(uint64)))\n\t\t\t\t\t*nextdiroff = 0;\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong8(nextdiroff);\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttmsize_t m;\n\t\ttmsize_t off = (tmsize_t) tif->tif_diroff;\n\t\tif ((uint64)off!=tif->tif_diroff)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Can not read TIFF directory count\");\n\t\t\treturn(0);\n\t\t}\n\n\t\t/*\n\t\t * Check for integer overflow when validating the dir_off,\n\t\t * otherwise a very high offset may cause an OOB read and\n\t\t * crash the client. Make two comparisons instead of\n\t\t *\n\t\t *  off + sizeof(uint16) > tif->tif_size\n\t\t *\n\t\t * to avoid overflow.\n\t\t */\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tm=off+sizeof(uint16);\n\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint16))||(m>tif->tif_size)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"Can not read TIFF directory count\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t_TIFFmemcpy(&dircount16, tif->tif_base + off,\n\t\t\t\t\t    sizeof(uint16));\n\t\t\t}\n\t\t\toff += sizeof (uint16);\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount16);\n\t\t\tif (dircount16>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdirsize = 12;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 dircount64;\n\t\t\tm=off+sizeof(uint64);\n\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint64))||(m>tif->tif_size)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\"Can not read TIFF directory count\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t_TIFFmemcpy(&dircount64, tif->tif_base + off,\n\t\t\t\t\t    sizeof(uint64));\n\t\t\t}\n\t\t\toff += sizeof (uint64);\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>4096)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Sanity check on directory count failed, this is probably not a valid IFD offset\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdircount16 = (uint16)dircount64;\n\t\t\tdirsize = 20;\n\t\t}\n\t\tif (dircount16 == 0 )\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t             \"Sanity check on directory count failed, zero tag directories not supported\");\n\t\t\treturn 0;\n\t\t}\n\t\torigdir = _TIFFCheckMalloc(tif, dircount16,\n\t\t\t\t\t\tdirsize,\n\t\t\t\t\t\t\"to read TIFF directory\");\n\t\tif (origdir == NULL)\n\t\t\treturn 0;\n\t\tm=off+dircount16*dirsize;\n\t\tif ((m<off)||(m<(tmsize_t)(dircount16*dirsize))||(m>tif->tif_size)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"Can not read TIFF directory\");\n\t\t\t_TIFFfree(origdir);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t_TIFFmemcpy(origdir, tif->tif_base + off,\n\t\t\t\t    dircount16 * dirsize);\n\t\t}\n\t\tif (nextdiroff) {\n\t\t\toff += dircount16 * dirsize;\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t{\n\t\t\t\tuint32 nextdiroff32;\n\t\t\t\tm=off+sizeof(uint32);\n\t\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint32))||(m>tif->tif_size))\n\t\t\t\t\tnextdiroff32 = 0;\n\t\t\t\telse\n\t\t\t\t\t_TIFFmemcpy(&nextdiroff32, tif->tif_base + off,\n\t\t\t\t\t\t    sizeof (uint32));\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong(&nextdiroff32);\n\t\t\t\t*nextdiroff = nextdiroff32;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm=off+sizeof(uint64);\n\t\t\t\tif ((m<off)||(m<(tmsize_t)sizeof(uint64))||(m>tif->tif_size))\n\t\t\t\t\t*nextdiroff = 0;\n\t\t\t\telse\n\t\t\t\t\t_TIFFmemcpy(nextdiroff, tif->tif_base + off,\n\t\t\t\t\t\t    sizeof (uint64));\n\t\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong8(nextdiroff);\n\t\t\t}\n\t\t}\n\t}\n\tdir = (TIFFDirEntry*)_TIFFCheckMalloc(tif, dircount16,\n\t\t\t\t\t\tsizeof(TIFFDirEntry),\n\t\t\t\t\t\t\"to read TIFF directory\");\n\tif (dir==0)\n\t{\n\t\t_TIFFfree(origdir);\n\t\treturn 0;\n\t}\n\tma=(uint8*)origdir;\n\tmb=dir;\n\tfor (n=0; n<dircount16; n++)\n\t{\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)ma);\n\t\tmb->tdir_tag=*(uint16*)ma;\n\t\tma+=sizeof(uint16);\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)ma);\n\t\tmb->tdir_type=*(uint16*)ma;\n\t\tma+=sizeof(uint16);\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong((uint32*)ma);\n\t\t\tmb->tdir_count=(uint64)(*(uint32*)ma);\n\t\t\tma+=sizeof(uint32);\n\t\t\t*(uint32*)(&mb->tdir_offset)=*(uint32*)ma;\n\t\t\tma+=sizeof(uint32);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8((uint64*)ma);\n                        mb->tdir_count=TIFFReadUInt64(ma);\n\t\t\tma+=sizeof(uint64);\n\t\t\tmb->tdir_offset.toff_long8=TIFFReadUInt64(ma);\n\t\t\tma+=sizeof(uint64);\n\t\t}\n\t\tmb++;\n\t}\n\t_TIFFfree(origdir);\n\t*pdir = dir;\n\treturn dircount16;\n}",
          "fn_code_pos": [
            [
              4671,
              0
            ],
            [
              4921,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchDirectory",
            "parameters": {
              "tif": "TIFF",
              "diroff": "uint64",
              "pdir": "TIFFDirEntry",
              "nextdiroff": "uint64"
            },
            "return_type": "uint16"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)\n{\n\tstatic const char module[] = \"TIFFFetchNormalTag\";\n\tenum TIFFReadDirEntryErr err;\n\tuint32 fii;\n\tconst TIFFField* fip = NULL;\n\tTIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);\n        if( fii == FAILED_FII )\n        {\n            TIFFErrorExt(tif->tif_clientdata, \"TIFFFetchNormalTag\",\n                         \"No definition found for tag %d\",\n                         dp->tdir_tag);\n            return 0;\n        }\n\tfip=tif->tif_fields[fii];\n\tassert(fip != NULL); /* should not happen */\n\tassert(fip->set_field_type!=TIFF_SETGET_OTHER);  /* if so, we shouldn't arrive here but deal with this in specialized code */\n\tassert(fip->set_field_type!=TIFF_SETGET_INT);    /* if so, we shouldn't arrive here as this is only the case for pseudo-tags */\n\terr=TIFFReadDirEntryErrOk;\n\tswitch (fip->set_field_type)\n\t{\n\t\tcase TIFF_SETGET_UNDEFINED:\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tuint32 mb = 0;\n\t\t\t\t\tint n;\n\t\t\t\t\tif (data != NULL)\n\t\t\t\t\t{\n\t\t\t\t\t    uint8* ma = data;\n\t\t\t\t\t    while (mb<(uint32)dp->tdir_count)\n\t\t\t\t\t    {\n\t\t\t\t\t            if (*ma==0)\n\t\t\t\t\t                    break;\n\t\t\t\t\t            ma++;\n\t\t\t\t\t            mb++;\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\t\t\t\t\tif (mb+1<(uint32)dp->tdir_count)\n\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" contains null byte in value; value incorrectly truncated during reading due to implementation limitations\",fip->field_name);\n\t\t\t\t\telse if (mb+1>(uint32)dp->tdir_count)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8* o;\n\t\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte\",fip->field_name);\n\t\t\t\t\t\tif ((uint32)dp->tdir_count+1!=dp->tdir_count+1)\n\t\t\t\t\t\t\to=NULL;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\to=_TIFFmalloc((uint32)dp->tdir_count+1);\n\t\t\t\t\t\tif (o==NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (data!=NULL)\n\t\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_TIFFmemcpy(o,data,(uint32)dp->tdir_count);\n\t\t\t\t\t\to[(uint32)dp->tdir_count]=0;\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tdata=o;\n\t\t\t\t\t}\n\t\t\t\t\tn=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!n)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT8:\n\t\t\t{\n\t\t\t\tuint8 data=0;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryByte(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT16:\n\t\t\t{\n\t\t\t\tuint16 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryShort(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT32:\n\t\t\t{\n\t\t\t\tuint32 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryLong(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT64:\n\t\t\t{\n\t\t\t\tuint64 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryLong8(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_FLOAT:\n\t\t\t{\n\t\t\t\tfloat data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryFloat(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryDouble(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_IFD8:\n\t\t\t{\n\t\t\t\tuint64 data;\n\t\t\t\tassert(fip->field_readcount==1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\terr=TIFFReadDirEntryIfd8(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFSetField(tif,dp->tdir_tag,data))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_UINT16_PAIR:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==2);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=2) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t       \"incorrect count for field \\\"%s\\\", expected 2, got %d\",\n\t\t\t\t\t\t       fip->field_name,(int)dp->tdir_count);\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data[0],data[1]);\n\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount) {\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t       \"incorrect count for field \\\"%s\\\", expected %d, got %d\",\n\t\t\t\t\t\t       fip->field_name,(int) fip->field_readcount, (int)dp->tdir_count);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C0_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount>=1);\n\t\t\t\tassert(fip->field_passcount==0);\n\t\t\t\tif (dp->tdir_count!=(uint64)fip->field_readcount)\n                                    /* corrupt file */;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tif( data != 0 && dp->tdir_count > 0 && data[dp->tdir_count-1] != '\\0' )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t    TIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte. Forcing it to be null\",fip->field_name);\n\t\t\t\t\t\t    data[dp->tdir_count-1] = '\\0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_UINT64:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryLong8Array(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryDoubleArray(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C16_IFD8:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\tif (dp->tdir_count>0xFFFF)\n\t\t\t\t\terr=TIFFReadDirEntryErrCount;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terr=TIFFReadDirEntryIfd8Array(tif,dp,&data);\n\t\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t\t{\n\t\t\t\t\t\tint m;\n\t\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);\n\t\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\t\tif (!m)\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_ASCII:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tif( data != 0 && dp->tdir_count > 0 && data[dp->tdir_count-1] != '\\0' )\n\t\t\t\t\t{\n\t\t\t\t\t    TIFFWarningExt(tif->tif_clientdata,module,\"ASCII value for tag \\\"%s\\\" does not end in null byte. Forcing it to be null\",fip->field_name);\n                                            data[dp->tdir_count-1] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT8:\n\t\t\t{\n\t\t\t\tuint8* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryByteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT8:\n\t\t\t{\n\t\t\t\tint8* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySbyteArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT16:\n\t\t\t{\n\t\t\t\tuint16* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryShortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT16:\n\t\t\t{\n\t\t\t\tint16* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySshortArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT32:\n\t\t\t{\n\t\t\t\tuint32* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryLongArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT32:\n\t\t\t{\n\t\t\t\tint32* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySlongArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_UINT64:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryLong8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_SINT64:\n\t\t\t{\n\t\t\t\tint64* data = NULL;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntrySlong8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_FLOAT:\n\t\t\t{\n\t\t\t\tfloat* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryFloatArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_DOUBLE:\n\t\t\t{\n\t\t\t\tdouble* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryDoubleArray(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_SETGET_C32_IFD8:\n\t\t\t{\n\t\t\t\tuint64* data;\n\t\t\t\tassert(fip->field_readcount==TIFF_VARIABLE2);\n\t\t\t\tassert(fip->field_passcount==1);\n\t\t\t\terr=TIFFReadDirEntryIfd8Array(tif,dp,&data);\n\t\t\t\tif (err==TIFFReadDirEntryErrOk)\n\t\t\t\t{\n\t\t\t\t\tint m;\n\t\t\t\t\tm=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);\n\t\t\t\t\tif (data!=0)\n\t\t\t\t\t\t_TIFFfree(data);\n\t\t\t\t\tif (!m)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);    /* we should never get here */\n\t\t\tbreak;\n\t}\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip->field_name,recover);\n\t\treturn(0);\n\t}\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              4926,
              0
            ],
            [
              5605,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchNormalTag",
            "parameters": {
              "tif": "TIFF",
              "dp": "TIFFDirEntry",
              "recover": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)\n{\n\tstatic const char module[] = \"TIFFFetchStripThing\";\n\tenum TIFFReadDirEntryErr err;\n\tuint64* data;\n\terr=TIFFReadDirEntryLong8ArrayWithLimit(tif,dir,&data,nstrips);\n\tif (err!=TIFFReadDirEntryErrOk)\n\t{\n\t\tconst TIFFField* fip = TIFFFieldWithTag(tif,dir->tdir_tag); \n\t\tTIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : \"unknown tagname\",0);\n\t\treturn(0);\n\t}\n\tif (dir->tdir_count<(uint64)nstrips)\n\t{\n\t\tuint64* resizeddata;\n\t\tconst TIFFField* fip = TIFFFieldWithTag(tif,dir->tdir_tag);\n\t\tconst char* pszMax = getenv(\"LIBTIFF_STRILE_ARRAY_MAX_RESIZE_COUNT\");\n\t\tuint32 max_nstrips = 1000000;\n\t\tif( pszMax )\n\t\t\tmax_nstrips = (uint32) atoi(pszMax);\n\t\tTIFFReadDirEntryOutputErr(tif,TIFFReadDirEntryErrCount,\n\t\t            module,\n\t\t            fip ? fip->field_name : \"unknown tagname\",\n\t\t            ( nstrips <= max_nstrips ) );\n\n\t\tif( nstrips > max_nstrips )\n\t\t{\n\t\t\t_TIFFfree(data);\n\t\t\treturn(0);\n\t\t}\n\n\t\tresizeddata=(uint64*)_TIFFCheckMalloc(tif,nstrips,sizeof(uint64),\"for strip array\");\n\t\tif (resizeddata==0) {\n\t\t\t_TIFFfree(data);\n\t\t\treturn(0);\n\t\t}\n                _TIFFmemcpy(resizeddata,data,(uint32)dir->tdir_count*sizeof(uint64));\n                _TIFFmemset(resizeddata+(uint32)dir->tdir_count,0,(nstrips-(uint32)dir->tdir_count)*sizeof(uint64));\n\t\t_TIFFfree(data);\n\t\tdata=resizeddata;\n\t}\n\t*lpp=data;\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              5611,
              0
            ],
            [
              5655,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchStripThing",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "nstrips": "uint32",
              "lpp": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchSubjectDistance(TIFF* tif, TIFFDirEntry* dir)\n{\n\tstatic const char module[] = \"TIFFFetchSubjectDistance\";\n\tenum TIFFReadDirEntryErr err;\n\tUInt64Aligned_t m;\n    m.l=0;\n\tassert(sizeof(double)==8);\n\tassert(sizeof(uint64)==8);\n\tassert(sizeof(uint32)==4);\n\tif (dir->tdir_count!=1)\n\t\terr=TIFFReadDirEntryErrCount;\n\telse if (dir->tdir_type!=TIFF_RATIONAL)\n\t\terr=TIFFReadDirEntryErrType;\n\telse\n\t{\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tuint32 offset;\n\t\t\toffset=*(uint32*)(&dir->tdir_offset);\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\terr=TIFFReadDirEntryData(tif,offset,8,m.i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm.l=dir->tdir_offset.toff_long8;\n\t\t\terr=TIFFReadDirEntryErrOk;\n\t\t}\n\t}\n\tif (err==TIFFReadDirEntryErrOk)\n\t{\n\t\tdouble n;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabArrayOfLong(m.i,2);\n\t\tif (m.i[0]==0)\n\t\t\tn=0.0;\n\t\telse if (m.i[0]==0xFFFFFFFF)\n\t\t\t/*\n\t\t\t * XXX: Numerator 0xFFFFFFFF means that we have infinite\n\t\t\t * distance. Indicate that with a negative floating point\n\t\t\t * SubjectDistance value.\n\t\t\t */\n\t\t\tn=-1.0;\n\t\telse\n\t\t\tn=(double)m.i[0]/(double)m.i[1];\n\t\treturn(TIFFSetField(tif,dir->tdir_tag,n));\n\t}\n\telse\n\t{\n\t\tTIFFReadDirEntryOutputErr(tif,err,module,\"SubjectDistance\",TRUE);\n\t\treturn(0);\n\t}\n}",
          "fn_code_pos": [
            [
              5660,
              0
            ],
            [
              5713,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchSubjectDistance",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void allocChoppedUpStripArrays(TIFF* tif, uint32 nstrips,\n                                      uint64 stripbytes, uint32 rowsperstrip)\n{\n    TIFFDirectory *td = &tif->tif_dir;\n    uint64 bytecount;\n    uint64 offset;\n    uint32 i;\n    uint64 *newcounts;\n    uint64 *newoffsets;\n\n    newcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),\n                            \"for chopped \\\"StripByteCounts\\\" array\");\n    newoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),\n                            \"for chopped \\\"StripOffsets\\\" array\");\n    if (newcounts == NULL || newoffsets == NULL) {\n        /*\n        * Unable to allocate new strip information, give up and use\n        * the original one strip information.\n        */\n        if (newcounts != NULL)\n            _TIFFfree(newcounts);\n        if (newoffsets != NULL)\n            _TIFFfree(newoffsets);\n        return;\n    }\n\n    /*\n     * Fill the strip information arrays with new bytecounts and offsets\n     * that reflect the broken-up format.\n     */\n    offset = td->td_stripoffset[0];\n    bytecount = td->td_stripoffset[td->td_nstrips-1] +\n                td->td_stripbytecount[td->td_nstrips-1] - offset;\n    for (i = 0; i < nstrips; i++)\n    {\n        if (stripbytes > bytecount)\n            stripbytes = bytecount;\n        newcounts[i] = stripbytes;\n        newoffsets[i] = stripbytes ? offset : 0;\n        offset += stripbytes;\n        bytecount -= stripbytes;\n    }\n\n    /*\n     * Replace old single strip info with multi-strip info.\n     */\n    td->td_stripsperimage = td->td_nstrips = nstrips;\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n    _TIFFfree(td->td_stripbytecount);\n    _TIFFfree(td->td_stripoffset);\n    td->td_stripbytecount = newcounts;\n    td->td_stripoffset = newoffsets;\n    td->td_stripbytecountsorted = 1;\n}",
          "fn_code_pos": [
            [
              5715,
              0
            ],
            [
              5769,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "allocChoppedUpStripArrays",
            "parameters": {
              "tif": "TIFF",
              "nstrips": "uint32",
              "stripbytes": "uint64",
              "rowsperstrip": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nChopUpSingleUncompressedStrip(TIFF* tif)\n{\n\tregister TIFFDirectory *td = &tif->tif_dir;\n\tuint64 bytecount;\n\tuint64 offset;\n\tuint32 rowblock;\n\tuint64 rowblockbytes;\n\tuint64 stripbytes;\n\tuint32 nstrips;\n\tuint32 rowsperstrip;\n\n\tbytecount = td->td_stripbytecount[0];\n        /* On a newly created file, just re-opened to be filled, we */\n        /* don't want strip chop to trigger as it is going to cause issues */\n        /* later ( StripOffsets and StripByteCounts improperly filled) . */\n        if( bytecount == 0 && tif->tif_mode != O_RDONLY )\n            return;\n\toffset = td->td_stripoffset[0];\n\tassert(td->td_planarconfig == PLANARCONFIG_CONTIG);\n\tif ((td->td_photometric == PHOTOMETRIC_YCBCR)&&\n\t    (!isUpSampled(tif)))\n\t\trowblock = td->td_ycbcrsubsampling[1];\n\telse\n\t\trowblock = 1;\n\trowblockbytes = TIFFVTileSize64(tif, rowblock);\n\t/*\n\t * Make the rows hold at least one scanline, but fill specified amount\n\t * of data if possible.\n\t */\n\tif (rowblockbytes > STRIP_SIZE_DEFAULT) {\n\t\tstripbytes = rowblockbytes;\n\t\trowsperstrip = rowblock;\n\t} else if (rowblockbytes > 0 ) {\n\t\tuint32 rowblocksperstrip;\n\t\trowblocksperstrip = (uint32) (STRIP_SIZE_DEFAULT / rowblockbytes);\n\t\trowsperstrip = rowblocksperstrip * rowblock;\n\t\tstripbytes = rowblocksperstrip * rowblockbytes;\n\t}\n\telse\n\t    return;\n\n\t/*\n\t * never increase the number of rows per strip\n\t */\n\tif (rowsperstrip >= td->td_rowsperstrip)\n\t\treturn;\n        nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);\n        if( nstrips == 0 )\n            return;\n\n        /* If we are going to allocate a lot of memory, make sure that the */\n        /* file is as big as needed */\n        if( tif->tif_mode == O_RDONLY &&\n            nstrips > 1000000 &&\n            (offset >= TIFFGetFileSize(tif) ||\n             stripbytes > (TIFFGetFileSize(tif) - offset) / (nstrips - 1)) )\n        {\n            return;\n        }\n\n        allocChoppedUpStripArrays(tif, nstrips, stripbytes, rowsperstrip);\n}",
          "fn_code_pos": [
            [
              5778,
              0
            ],
            [
              5840,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ChopUpSingleUncompressedStrip",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void TryChopUpUncompressedBigTiff( TIFF* tif )\n{\n    TIFFDirectory *td = &tif->tif_dir;\n    uint32 rowblock;\n    uint64 rowblockbytes;\n    uint32 i;\n    uint64 stripsize;\n    uint32 rowblocksperstrip;\n    uint32 rowsperstrip;\n    uint64 stripbytes;\n    uint32 nstrips;\n\n    stripsize = TIFFStripSize64(tif);\n\n    assert( tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG );\n    assert( tif->tif_dir.td_compression == COMPRESSION_NONE );\n    assert( (tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP );\n    assert( stripsize > 0x7FFFFFFFUL );\n\n    /* On a newly created file, just re-opened to be filled, we */\n    /* don't want strip chop to trigger as it is going to cause issues */\n    /* later ( StripOffsets and StripByteCounts improperly filled) . */\n    if( td->td_stripbytecount[0] == 0 && tif->tif_mode != O_RDONLY )\n        return;\n\n    if ((td->td_photometric == PHOTOMETRIC_YCBCR)&&\n        (!isUpSampled(tif)))\n        rowblock = td->td_ycbcrsubsampling[1];\n    else\n        rowblock = 1;\n    rowblockbytes = TIFFVStripSize64(tif, rowblock);\n    if( rowblockbytes > 0x7FFFFFFFUL )\n    {\n        /* In case of file with gigantic width */\n        return;\n    }\n\n    /* Check that the strips are contiguous and of the expected size */\n    for( i = 0; i < td->td_nstrips; i++ )\n    {\n        if( i == td->td_nstrips - 1 )\n        {\n            if( td->td_stripbytecount[i] < TIFFVStripSize64(\n                    tif, td->td_imagelength - i * td->td_rowsperstrip ) )\n            {\n                return;\n            }\n        }\n        else\n        {\n            if( td->td_stripbytecount[i] != stripsize )\n            {\n                return;\n            }\n            if( i > 0 && td->td_stripoffset[i] !=\n                    td->td_stripoffset[i-1] + td->td_stripbytecount[i - 1] )\n            {\n                return;\n            }\n        }\n    }\n\n    /* Aim for 512 MB strips (that will still be manageable by 32 bit builds */\n    rowblocksperstrip = (uint32) (512 * 1024 * 1024 / rowblockbytes);\n    if( rowblocksperstrip == 0 )\n        rowblocksperstrip = 1;\n    rowsperstrip = rowblocksperstrip * rowblock;\n    stripbytes = rowblocksperstrip * rowblockbytes;\n    assert( stripbytes <= 0x7FFFFFFFUL );\n\n    nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);\n    if( nstrips == 0 )\n        return;\n\n    /* If we are going to allocate a lot of memory, make sure that the */\n    /* file is as big as needed */\n    if( tif->tif_mode == O_RDONLY &&\n        nstrips > 1000000 &&\n        (td->td_stripoffset[td->td_nstrips-1] > TIFFGetFileSize(tif) ||\n         td->td_stripoffset[td->td_nstrips-1] +\n         td->td_stripbytecount[td->td_nstrips-1] > TIFFGetFileSize(tif)) )\n    {\n        return;\n    }\n\n    allocChoppedUpStripArrays(tif, nstrips, stripbytes, rowsperstrip);\n}",
          "fn_code_pos": [
            [
              5849,
              0
            ],
            [
              5935,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TryChopUpUncompressedBigTiff",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int _TIFFFillStriles( TIFF *tif )\n{\n    return _TIFFFillStrilesInternal( tif, 1 );\n}",
          "fn_code_pos": [
            [
              5939,
              0
            ],
            [
              5942,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFFillStriles",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int _TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount )\n{\n#if defined(DEFER_STRILE_LOAD)\n        register TIFFDirectory *td = &tif->tif_dir;\n        int return_value = 1;\n\n        if( td->td_stripoffset != NULL )\n                return 1;\n\n        if( td->td_stripoffset_entry.tdir_count == 0 )\n                return 0;\n\n        if (!TIFFFetchStripThing(tif,&(td->td_stripoffset_entry),\n                                 td->td_nstrips,&td->td_stripoffset))\n        {\n                return_value = 0;\n        }\n\n        if (loadStripByteCount &&\n            !TIFFFetchStripThing(tif,&(td->td_stripbytecount_entry),\n                                 td->td_nstrips,&td->td_stripbytecount))\n        {\n                return_value = 0;\n        }\n\n        _TIFFmemset( &(td->td_stripoffset_entry), 0, sizeof(TIFFDirEntry));\n        _TIFFmemset( &(td->td_stripbytecount_entry), 0, sizeof(TIFFDirEntry));\n\n\tif (tif->tif_dir.td_nstrips > 1 && return_value == 1 ) {\n\t\tuint32 strip;\n\n\t\ttif->tif_dir.td_stripbytecountsorted = 1;\n\t\tfor (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {\n\t\t\tif (tif->tif_dir.td_stripoffset[strip - 1] >\n\t\t\t    tif->tif_dir.td_stripoffset[strip]) {\n\t\t\t\ttif->tif_dir.td_stripbytecountsorted = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n        return return_value;\n#else /* !defined(DEFER_STRILE_LOAD) */\n        (void) tif;\n        (void) loadStripByteCount;\n        return 1;\n#endif \n}",
          "fn_code_pos": [
            [
              5944,
              0
            ],
            [
              5991,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFFillStrilesInternal",
            "parameters": {
              "tif": "TIFF",
              "loadStripByteCount": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFCvtIEEEFloatToNative(TIFF*, uint32, float*)",
          "fn_dec_pos": [
            [
              50,
              12
            ],
            [
              50,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCvtIEEEFloatToNative",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFCvtIEEEDoubleToNative(TIFF*, uint32, double*)",
          "fn_dec_pos": [
            [
              51,
              12
            ],
            [
              51,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCvtIEEEDoubleToNative",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFReadDirEntryByte(TIFF* tif, TIFFDirEntry* direntry, uint8* value)",
          "fn_dec_pos": [
            [
              65,
              32
            ],
            [
              65,
              101
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryByte",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)",
          "fn_dec_pos": [
            [
              66,
              32
            ],
            [
              66,
              103
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryShort",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value)",
          "fn_dec_pos": [
            [
              67,
              32
            ],
            [
              67,
              102
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryLong",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryLong8(TIFF* tif, TIFFDirEntry* direntry, uint64* value)",
          "fn_dec_pos": [
            [
              68,
              32
            ],
            [
              68,
              103
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryLong8",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryFloat(TIFF* tif, TIFFDirEntry* direntry, float* value)",
          "fn_dec_pos": [
            [
              69,
              32
            ],
            [
              69,
              102
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryFloat",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "float"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryDouble(TIFF* tif, TIFFDirEntry* direntry, double* value)",
          "fn_dec_pos": [
            [
              70,
              32
            ],
            [
              70,
              104
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryDouble",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryIfd8(TIFF* tif, TIFFDirEntry* direntry, uint64* value)",
          "fn_dec_pos": [
            [
              71,
              32
            ],
            [
              71,
              102
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryIfd8",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value)",
          "fn_dec_pos": [
            [
              73,
              32
            ],
            [
              73,
              138
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "count": "uint32",
              "desttypesize": "uint32",
              "value": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8** value)",
          "fn_dec_pos": [
            [
              74,
              32
            ],
            [
              74,
              107
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryByteArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntrySbyteArray(TIFF* tif, TIFFDirEntry* direntry, int8** value)",
          "fn_dec_pos": [
            [
              75,
              32
            ],
            [
              75,
              107
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntrySbyteArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "int8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEntry* direntry, uint16** value)",
          "fn_dec_pos": [
            [
              76,
              32
            ],
            [
              76,
              109
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryShortArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntrySshortArray(TIFF* tif, TIFFDirEntry* direntry, int16** value)",
          "fn_dec_pos": [
            [
              77,
              32
            ],
            [
              77,
              109
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntrySshortArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "int16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryLongArray(TIFF* tif, TIFFDirEntry* direntry, uint32** value)",
          "fn_dec_pos": [
            [
              78,
              32
            ],
            [
              78,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryLongArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntrySlongArray(TIFF* tif, TIFFDirEntry* direntry, int32** value)",
          "fn_dec_pos": [
            [
              79,
              32
            ],
            [
              79,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntrySlongArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)",
          "fn_dec_pos": [
            [
              80,
              32
            ],
            [
              80,
              109
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryLong8Array",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntrySlong8Array(TIFF* tif, TIFFDirEntry* direntry, int64** value)",
          "fn_dec_pos": [
            [
              81,
              32
            ],
            [
              81,
              109
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntrySlong8Array",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEntry* direntry, float** value)",
          "fn_dec_pos": [
            [
              82,
              32
            ],
            [
              82,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryFloatArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "float"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryDoubleArray(TIFF* tif, TIFFDirEntry* direntry, double** value)",
          "fn_dec_pos": [
            [
              83,
              32
            ],
            [
              83,
              110
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryDoubleArray",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryIfd8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)",
          "fn_dec_pos": [
            [
              84,
              32
            ],
            [
              84,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryIfd8Array",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryPersampleShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)",
          "fn_dec_pos": [
            [
              86,
              32
            ],
            [
              86,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryPersampleShort",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryPersampleDouble(TIFF* tif, TIFFDirEntry* direntry, double* value)",
          "fn_dec_pos": [
            [
              88,
              32
            ],
            [
              88,
              113
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryPersampleDouble",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckedByte(TIFF* tif, TIFFDirEntry* direntry, uint8* value)",
          "fn_dec_pos": [
            [
              91,
              12
            ],
            [
              91,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedByte",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint8"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckedSbyte(TIFF* tif, TIFFDirEntry* direntry, int8* value)",
          "fn_dec_pos": [
            [
              92,
              12
            ],
            [
              92,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedSbyte",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "int8"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckedShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)",
          "fn_dec_pos": [
            [
              93,
              12
            ],
            [
              93,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedShort",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckedSshort(TIFF* tif, TIFFDirEntry* direntry, int16* value)",
          "fn_dec_pos": [
            [
              94,
              12
            ],
            [
              94,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedSshort",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "int16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckedLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value)",
          "fn_dec_pos": [
            [
              95,
              12
            ],
            [
              95,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedLong",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckedSlong(TIFF* tif, TIFFDirEntry* direntry, int32* value)",
          "fn_dec_pos": [
            [
              96,
              12
            ],
            [
              96,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedSlong",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "int32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckedLong8(TIFF* tif, TIFFDirEntry* direntry, uint64* value)",
          "fn_dec_pos": [
            [
              97,
              32
            ],
            [
              97,
              110
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedLong8",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckedSlong8(TIFF* tif, TIFFDirEntry* direntry, int64* value)",
          "fn_dec_pos": [
            [
              98,
              32
            ],
            [
              98,
              110
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedSlong8",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckedRational(TIFF* tif, TIFFDirEntry* direntry, double* value)",
          "fn_dec_pos": [
            [
              99,
              32
            ],
            [
              99,
              113
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedRational",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckedSrational(TIFF* tif, TIFFDirEntry* direntry, double* value)",
          "fn_dec_pos": [
            [
              100,
              32
            ],
            [
              100,
              114
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedSrational",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckedFloat(TIFF* tif, TIFFDirEntry* direntry, float* value)",
          "fn_dec_pos": [
            [
              101,
              12
            ],
            [
              101,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedFloat",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "float"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckedDouble(TIFF* tif, TIFFDirEntry* direntry, double* value)",
          "fn_dec_pos": [
            [
              102,
              32
            ],
            [
              102,
              111
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckedDouble",
            "parameters": {
              "tif": "TIFF",
              "direntry": "TIFFDirEntry",
              "value": "double"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeByteSbyte(int8 value)",
          "fn_dec_pos": [
            [
              104,
              32
            ],
            [
              104,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeByteSbyte",
            "parameters": {
              "value": "int8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeByteShort(uint16 value)",
          "fn_dec_pos": [
            [
              105,
              32
            ],
            [
              105,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeByteShort",
            "parameters": {
              "value": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeByteSshort(int16 value)",
          "fn_dec_pos": [
            [
              106,
              32
            ],
            [
              106,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeByteSshort",
            "parameters": {
              "value": "int16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeByteLong(uint32 value)",
          "fn_dec_pos": [
            [
              107,
              32
            ],
            [
              107,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeByteLong",
            "parameters": {
              "value": "uint32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeByteSlong(int32 value)",
          "fn_dec_pos": [
            [
              108,
              32
            ],
            [
              108,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeByteSlong",
            "parameters": {
              "value": "int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeByteLong8(uint64 value)",
          "fn_dec_pos": [
            [
              109,
              32
            ],
            [
              109,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeByteLong8",
            "parameters": {
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeByteSlong8(int64 value)",
          "fn_dec_pos": [
            [
              110,
              32
            ],
            [
              110,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeByteSlong8",
            "parameters": {
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeSbyteByte(uint8 value)",
          "fn_dec_pos": [
            [
              112,
              32
            ],
            [
              112,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSbyteByte",
            "parameters": {
              "value": "uint8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeSbyteShort(uint16 value)",
          "fn_dec_pos": [
            [
              113,
              32
            ],
            [
              113,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSbyteShort",
            "parameters": {
              "value": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeSbyteSshort(int16 value)",
          "fn_dec_pos": [
            [
              114,
              32
            ],
            [
              114,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSbyteSshort",
            "parameters": {
              "value": "int16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeSbyteLong(uint32 value)",
          "fn_dec_pos": [
            [
              115,
              32
            ],
            [
              115,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSbyteLong",
            "parameters": {
              "value": "uint32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeSbyteSlong(int32 value)",
          "fn_dec_pos": [
            [
              116,
              32
            ],
            [
              116,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSbyteSlong",
            "parameters": {
              "value": "int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeSbyteLong8(uint64 value)",
          "fn_dec_pos": [
            [
              117,
              32
            ],
            [
              117,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSbyteLong8",
            "parameters": {
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeSbyteSlong8(int64 value)",
          "fn_dec_pos": [
            [
              118,
              32
            ],
            [
              118,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSbyteSlong8",
            "parameters": {
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeShortSbyte(int8 value)",
          "fn_dec_pos": [
            [
              120,
              32
            ],
            [
              120,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeShortSbyte",
            "parameters": {
              "value": "int8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeShortSshort(int16 value)",
          "fn_dec_pos": [
            [
              121,
              32
            ],
            [
              121,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeShortSshort",
            "parameters": {
              "value": "int16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeShortLong(uint32 value)",
          "fn_dec_pos": [
            [
              122,
              32
            ],
            [
              122,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeShortLong",
            "parameters": {
              "value": "uint32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeShortSlong(int32 value)",
          "fn_dec_pos": [
            [
              123,
              32
            ],
            [
              123,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeShortSlong",
            "parameters": {
              "value": "int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeShortLong8(uint64 value)",
          "fn_dec_pos": [
            [
              124,
              32
            ],
            [
              124,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeShortLong8",
            "parameters": {
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeShortSlong8(int64 value)",
          "fn_dec_pos": [
            [
              125,
              32
            ],
            [
              125,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeShortSlong8",
            "parameters": {
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeSshortShort(uint16 value)",
          "fn_dec_pos": [
            [
              127,
              32
            ],
            [
              127,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSshortShort",
            "parameters": {
              "value": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeSshortLong(uint32 value)",
          "fn_dec_pos": [
            [
              128,
              32
            ],
            [
              128,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSshortLong",
            "parameters": {
              "value": "uint32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeSshortSlong(int32 value)",
          "fn_dec_pos": [
            [
              129,
              32
            ],
            [
              129,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSshortSlong",
            "parameters": {
              "value": "int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeSshortLong8(uint64 value)",
          "fn_dec_pos": [
            [
              130,
              32
            ],
            [
              130,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSshortLong8",
            "parameters": {
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeSshortSlong8(int64 value)",
          "fn_dec_pos": [
            [
              131,
              32
            ],
            [
              131,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSshortSlong8",
            "parameters": {
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeLongSbyte(int8 value)",
          "fn_dec_pos": [
            [
              133,
              32
            ],
            [
              133,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLongSbyte",
            "parameters": {
              "value": "int8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeLongSshort(int16 value)",
          "fn_dec_pos": [
            [
              134,
              32
            ],
            [
              134,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLongSshort",
            "parameters": {
              "value": "int16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeLongSlong(int32 value)",
          "fn_dec_pos": [
            [
              135,
              32
            ],
            [
              135,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLongSlong",
            "parameters": {
              "value": "int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeLongLong8(uint64 value)",
          "fn_dec_pos": [
            [
              136,
              32
            ],
            [
              136,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLongLong8",
            "parameters": {
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeLongSlong8(int64 value)",
          "fn_dec_pos": [
            [
              137,
              32
            ],
            [
              137,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLongSlong8",
            "parameters": {
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeSlongLong(uint32 value)",
          "fn_dec_pos": [
            [
              139,
              32
            ],
            [
              139,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSlongLong",
            "parameters": {
              "value": "uint32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeSlongLong8(uint64 value)",
          "fn_dec_pos": [
            [
              140,
              32
            ],
            [
              140,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSlongLong8",
            "parameters": {
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeSlongSlong8(int64 value)",
          "fn_dec_pos": [
            [
              141,
              32
            ],
            [
              141,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSlongSlong8",
            "parameters": {
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeLong8Sbyte(int8 value)",
          "fn_dec_pos": [
            [
              143,
              32
            ],
            [
              143,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLong8Sbyte",
            "parameters": {
              "value": "int8"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeLong8Sshort(int16 value)",
          "fn_dec_pos": [
            [
              144,
              32
            ],
            [
              144,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLong8Sshort",
            "parameters": {
              "value": "int16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeLong8Slong(int32 value)",
          "fn_dec_pos": [
            [
              145,
              32
            ],
            [
              145,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLong8Slong",
            "parameters": {
              "value": "int32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeLong8Slong8(int64 value)",
          "fn_dec_pos": [
            [
              146,
              32
            ],
            [
              146,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeLong8Slong8",
            "parameters": {
              "value": "int64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryCheckRangeSlong8Long8(uint64 value)",
          "fn_dec_pos": [
            [
              148,
              32
            ],
            [
              148,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryCheckRangeSlong8Long8",
            "parameters": {
              "value": "uint64"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryData(TIFF* tif, uint64 offset, tmsize_t size, void* dest)",
          "fn_dec_pos": [
            [
              150,
              32
            ],
            [
              150,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryData",
            "parameters": {
              "tif": "TIFF",
              "offset": "uint64",
              "size": "tmsize_t",
              "dest": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirEntryOutputErr(TIFF* tif, enum TIFFReadDirEntryErr err, const char* module, const char* tagname, int recover)",
          "fn_dec_pos": [
            [
              151,
              12
            ],
            [
              151,
              132
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirEntryOutputErr",
            "parameters": {
              "tif": "TIFF",
              "err": "enum TIFFReadDirEntryErr",
              "module": "char",
              "tagname": "char",
              "recover": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)",
          "fn_dec_pos": [
            [
              153,
              12
            ],
            [
              153,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirectoryCheckOrder",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "dircount": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid)",
          "fn_dec_pos": [
            [
              154,
              21
            ],
            [
              154,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirectoryFindEntry",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "dircount": "uint16",
              "tagid": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii)",
          "fn_dec_pos": [
            [
              155,
              12
            ],
            [
              155,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirectoryFindFieldInfo",
            "parameters": {
              "tif": "TIFF",
              "tagid": "uint16",
              "fii": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)",
          "fn_dec_pos": [
            [
              157,
              11
            ],
            [
              157,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EstimateStripByteCounts",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "dircount": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "MissingRequired(TIFF*, const char*)",
          "fn_dec_pos": [
            [
              158,
              12
            ],
            [
              158,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MissingRequired",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFCheckDirOffset(TIFF* tif, uint64 diroff)",
          "fn_dec_pos": [
            [
              159,
              11
            ],
            [
              159,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCheckDirOffset",
            "parameters": {
              "tif": "TIFF",
              "diroff": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "CheckDirCount(TIFF*, TIFFDirEntry*, uint32)",
          "fn_dec_pos": [
            [
              160,
              11
            ],
            [
              160,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckDirCount",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir, uint64* nextdiroff)",
          "fn_dec_pos": [
            [
              161,
              14
            ],
            [
              161,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchDirectory",
            "parameters": {
              "tif": "TIFF",
              "diroff": "uint64",
              "pdir": "TIFFDirEntry",
              "nextdiroff": "uint64"
            },
            "return_type": "uint16"
          }
        },
        {
          "fn_code": "TIFFFetchNormalTag(TIFF*, TIFFDirEntry*, int recover)",
          "fn_dec_pos": [
            [
              162,
              11
            ],
            [
              162,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchNormalTag",
            "parameters": {
              "recover": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)",
          "fn_dec_pos": [
            [
              163,
              11
            ],
            [
              163,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchStripThing",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "nstrips": "uint32",
              "lpp": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFetchSubjectDistance(TIFF*, TIFFDirEntry*)",
          "fn_dec_pos": [
            [
              164,
              11
            ],
            [
              164,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchSubjectDistance",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "ChopUpSingleUncompressedStrip(TIFF*)",
          "fn_dec_pos": [
            [
              165,
              12
            ],
            [
              165,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ChopUpSingleUncompressedStrip",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TryChopUpUncompressedBigTiff(TIFF*)",
          "fn_dec_pos": [
            [
              166,
              12
            ],
            [
              166,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TryChopUpUncompressedBigTiff",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFReadUInt64(const uint8 *value)",
          "fn_dec_pos": [
            [
              167,
              14
            ],
            [
              167,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadUInt64",
            "parameters": {
              "value": "uint8"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "_TIFFGetMaxColorChannels(uint16 photometric)",
          "fn_dec_pos": [
            [
              168,
              11
            ],
            [
              168,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFGetMaxColorChannels",
            "parameters": {
              "photometric": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount )",
          "fn_dec_pos": [
            [
              170,
              11
            ],
            [
              170,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFFillStrilesInternal",
            "parameters": {
              "tif": "TIFF",
              "loadStripByteCount": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid)",
          "fn_dec_pos": [
            [
              4326,
              0
            ],
            [
              4326,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirectoryFindEntry",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "dircount": "uint16",
              "tagid": "uint16"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include <float.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "enum TIFFReadDirEntryErr {\n\tTIFFReadDirEntryErrOk = 0,\n\tTIFFReadDirEntryErrCount = 1,\n\tTIFFReadDirEntryErrType = 2,\n\tTIFFReadDirEntryErrIo = 3,\n\tTIFFReadDirEntryErrRange = 4,\n\tTIFFReadDirEntryErrPsdif = 5,\n\tTIFFReadDirEntryErrSizesan = 6,\n\tTIFFReadDirEntryErrAlloc = 7,\n}",
          {
            "TIFFReadDirEntryErrOk": "",
            "TIFFReadDirEntryErrCount": "",
            "TIFFReadDirEntryErrType": "",
            "TIFFReadDirEntryErrIo": "",
            "TIFFReadDirEntryErrRange": "",
            "TIFFReadDirEntryErrPsdif": "",
            "TIFFReadDirEntryErrSizesan": "",
            "TIFFReadDirEntryErrAlloc": ""
          },
          "TIFFReadDirEntryErr",
          [
            54,
            0
          ],
          [
            63,
            1
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            65,
            7
          ],
          [
            65,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            66,
            7
          ],
          [
            66,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            67,
            7
          ],
          [
            67,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            68,
            7
          ],
          [
            68,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            69,
            7
          ],
          [
            69,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            70,
            7
          ],
          [
            70,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            71,
            7
          ],
          [
            71,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            73,
            7
          ],
          [
            73,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            74,
            7
          ],
          [
            74,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            75,
            7
          ],
          [
            75,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            76,
            7
          ],
          [
            76,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            77,
            7
          ],
          [
            77,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            78,
            7
          ],
          [
            78,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            79,
            7
          ],
          [
            79,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            80,
            7
          ],
          [
            80,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            81,
            7
          ],
          [
            81,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            82,
            7
          ],
          [
            82,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            83,
            7
          ],
          [
            83,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            84,
            7
          ],
          [
            84,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            86,
            7
          ],
          [
            86,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            88,
            7
          ],
          [
            88,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            97,
            7
          ],
          [
            97,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            98,
            7
          ],
          [
            98,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            99,
            7
          ],
          [
            99,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            100,
            7
          ],
          [
            100,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            102,
            7
          ],
          [
            102,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            104,
            7
          ],
          [
            104,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            105,
            7
          ],
          [
            105,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            106,
            7
          ],
          [
            106,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            107,
            7
          ],
          [
            107,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            108,
            7
          ],
          [
            108,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            109,
            7
          ],
          [
            109,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            110,
            7
          ],
          [
            110,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            112,
            7
          ],
          [
            112,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            113,
            7
          ],
          [
            113,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            114,
            7
          ],
          [
            114,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            115,
            7
          ],
          [
            115,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            116,
            7
          ],
          [
            116,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            117,
            7
          ],
          [
            117,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            118,
            7
          ],
          [
            118,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            120,
            7
          ],
          [
            120,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            121,
            7
          ],
          [
            121,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            122,
            7
          ],
          [
            122,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            123,
            7
          ],
          [
            123,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            124,
            7
          ],
          [
            124,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            125,
            7
          ],
          [
            125,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            127,
            7
          ],
          [
            127,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            128,
            7
          ],
          [
            128,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            129,
            7
          ],
          [
            129,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            130,
            7
          ],
          [
            130,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            131,
            7
          ],
          [
            131,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            133,
            7
          ],
          [
            133,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            134,
            7
          ],
          [
            134,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            135,
            7
          ],
          [
            135,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            136,
            7
          ],
          [
            136,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            137,
            7
          ],
          [
            137,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            139,
            7
          ],
          [
            139,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            140,
            7
          ],
          [
            140,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            141,
            7
          ],
          [
            141,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            143,
            7
          ],
          [
            143,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            144,
            7
          ],
          [
            144,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            145,
            7
          ],
          [
            145,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            146,
            7
          ],
          [
            146,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            148,
            7
          ],
          [
            148,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            150,
            7
          ],
          [
            150,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            151,
            49
          ],
          [
            151,
            73
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            200,
            7
          ],
          [
            200,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            202,
            1
          ],
          [
            202,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            289,
            7
          ],
          [
            289,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            291,
            1
          ],
          [
            291,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            375,
            7
          ],
          [
            375,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            377,
            1
          ],
          [
            377,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            458,
            7
          ],
          [
            458,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            460,
            1
          ],
          [
            460,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            536,
            7
          ],
          [
            536,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            538,
            1
          ],
          [
            538,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            649,
            7
          ],
          [
            649,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            651,
            1
          ],
          [
            651,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            746,
            7
          ],
          [
            746,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            748,
            1
          ],
          [
            748,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            775,
            7
          ],
          [
            775,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            830,
            7
          ],
          [
            830,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            885,
            3
          ],
          [
            885,
            27
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            906,
            3
          ],
          [
            906,
            27
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            925,
            7
          ],
          [
            925,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            931,
            7
          ],
          [
            931,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            933,
            1
          ],
          [
            933,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            1112,
            7
          ],
          [
            1112,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            1114,
            1
          ],
          [
            1114,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            1291,
            7
          ],
          [
            1291,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            1293,
            1
          ],
          [
            1293,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            1463,
            7
          ],
          [
            1463,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            1465,
            1
          ],
          [
            1465,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            1630,
            7
          ],
          [
            1630,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            1632,
            1
          ],
          [
            1632,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            1799,
            7
          ],
          [
            1799,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            1801,
            1
          ],
          [
            1801,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            1960,
            7
          ],
          [
            1960,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            1963,
            1
          ],
          [
            1963,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2127,
            7
          ],
          [
            2127,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2132,
            7
          ],
          [
            2132,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2134,
            1
          ],
          [
            2134,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2282,
            7
          ],
          [
            2282,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2284,
            1
          ],
          [
            2284,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2526,
            7
          ],
          [
            2526,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2529,
            1
          ],
          [
            2529,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2764,
            7
          ],
          [
            2764,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2766,
            1
          ],
          [
            2766,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2825,
            7
          ],
          [
            2825,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2827,
            1
          ],
          [
            2827,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2854,
            7
          ],
          [
            2854,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2856,
            1
          ],
          [
            2856,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2924,
            7
          ],
          [
            2924,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2928,
            2
          ],
          [
            2928,
            26
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2943,
            7
          ],
          [
            2943,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2947,
            2
          ],
          [
            2947,
            26
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2962,
            7
          ],
          [
            2962,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2971,
            2
          ],
          [
            2971,
            26
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            2993,
            7
          ],
          [
            2993,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3002,
            2
          ],
          [
            3002,
            26
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3040,
            7
          ],
          [
            3040,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3047,
            2
          ],
          [
            3047,
            26
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3066,
            7
          ],
          [
            3066,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3074,
            7
          ],
          [
            3074,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3082,
            7
          ],
          [
            3082,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3090,
            7
          ],
          [
            3090,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3098,
            7
          ],
          [
            3098,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3106,
            7
          ],
          [
            3106,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3114,
            7
          ],
          [
            3114,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3122,
            7
          ],
          [
            3122,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3130,
            7
          ],
          [
            3130,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3138,
            7
          ],
          [
            3138,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3146,
            7
          ],
          [
            3146,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3154,
            7
          ],
          [
            3154,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3162,
            7
          ],
          [
            3162,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3170,
            7
          ],
          [
            3170,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3178,
            7
          ],
          [
            3178,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3186,
            7
          ],
          [
            3186,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3194,
            7
          ],
          [
            3194,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3202,
            7
          ],
          [
            3202,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3210,
            7
          ],
          [
            3210,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3218,
            7
          ],
          [
            3218,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3226,
            7
          ],
          [
            3226,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3234,
            7
          ],
          [
            3234,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3242,
            7
          ],
          [
            3242,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3250,
            7
          ],
          [
            3250,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3258,
            7
          ],
          [
            3258,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3266,
            7
          ],
          [
            3266,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3274,
            7
          ],
          [
            3274,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3282,
            7
          ],
          [
            3282,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3295,
            7
          ],
          [
            3295,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3304,
            7
          ],
          [
            3304,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3315,
            7
          ],
          [
            3315,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3325,
            7
          ],
          [
            3325,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3335,
            7
          ],
          [
            3335,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3344,
            7
          ],
          [
            3344,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3353,
            7
          ],
          [
            3353,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3362,
            7
          ],
          [
            3362,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3371,
            7
          ],
          [
            3371,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3385,
            7
          ],
          [
            3385,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3396,
            7
          ],
          [
            3396,
            31
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3421,
            49
          ],
          [
            3421,
            73
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3635,
            2
          ],
          [
            3635,
            26
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3826,
            5
          ],
          [
            3826,
            29
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3847,
            5
          ],
          [
            3847,
            29
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            3908,
            5
          ],
          [
            3908,
            29
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            4930,
            1
          ],
          [
            4930,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            5615,
            1
          ],
          [
            5615,
            25
          ]
        ],
        [
          "enum TIFFReadDirEntryErr",
          {},
          "",
          [
            5664,
            1
          ],
          [
            5664,
            25
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_aux.c": {
      "fn_def_list": [
        {
          "fn_code": "uint32\n_TIFFMultiply32(TIFF* tif, uint32 first, uint32 second, const char* where)\n{\n\tuint32 bytes = first * second;\n\n\tif (second && bytes / second != first) {\n\t\tTIFFErrorExt(tif->tif_clientdata, where, \"Integer overflow in %s\", where);\n\t\tbytes = 0;\n\t}\n\n\treturn bytes;\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              45,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFMultiply32",
            "parameters": {
              "tif": "TIFF",
              "first": "uint32",
              "second": "uint32",
              "where": "char"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "uint64\n_TIFFMultiply64(TIFF* tif, uint64 first, uint64 second, const char* where)\n{\n\tuint64 bytes = first * second;\n\n\tif (second && bytes / second != first) {\n\t\tTIFFErrorExt(tif->tif_clientdata, where, \"Integer overflow in %s\", where);\n\t\tbytes = 0;\n\t}\n\n\treturn bytes;\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFMultiply64",
            "parameters": {
              "tif": "TIFF",
              "first": "uint64",
              "second": "uint64",
              "where": "char"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "void*\n_TIFFCheckRealloc(TIFF* tif, void* buffer,\n\t\t  tmsize_t nmemb, tmsize_t elem_size, const char* what)\n{\n\tvoid* cp = NULL;\n\ttmsize_t bytes = nmemb * elem_size;\n\n\t/*\n\t * XXX: Check for integer overflow.\n\t */\n\tif (nmemb && elem_size && bytes / elem_size == nmemb)\n\t\tcp = _TIFFrealloc(buffer, bytes);\n\n\tif (cp == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"Failed to allocate memory for %s \"\n\t\t\t     \"(%ld elements of %ld bytes each)\",\n\t\t\t     what,(long) nmemb, (long) elem_size);\n\t}\n\n\treturn cp;\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              81,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFCheckRealloc",
            "parameters": {
              "tif": "TIFF",
              "buffer": "void",
              "nmemb": "tmsize_t",
              "elem_size": "tmsize_t",
              "what": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void*\n_TIFFCheckMalloc(TIFF* tif, tmsize_t nmemb, tmsize_t elem_size, const char* what)\n{\n\treturn _TIFFCheckRealloc(tif, NULL, nmemb, elem_size, what);  \n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFCheckMalloc",
            "parameters": {
              "tif": "TIFF",
              "nmemb": "tmsize_t",
              "elem_size": "tmsize_t",
              "what": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nTIFFDefaultTransferFunction(TIFFDirectory* td)\n{\n\tuint16 **tf = td->td_transferfunction;\n\ttmsize_t i, n, nbytes;\n\n\ttf[0] = tf[1] = tf[2] = 0;\n\tif (td->td_bitspersample >= sizeof(tmsize_t) * 8 - 2)\n\t\treturn 0;\n\n\tn = ((tmsize_t)1)<<td->td_bitspersample;\n\tnbytes = n * sizeof (uint16);\n        tf[0] = (uint16 *)_TIFFmalloc(nbytes);\n\tif (tf[0] == NULL)\n\t\treturn 0;\n\ttf[0][0] = 0;\n\tfor (i = 1; i < n; i++) {\n\t\tdouble t = (double)i/((double) n-1.);\n\t\ttf[0][i] = (uint16)floor(65535.*pow(t, 2.2) + .5);\n\t}\n\n\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\n                tf[1] = (uint16 *)_TIFFmalloc(nbytes);\n\t\tif(tf[1] == NULL)\n\t\t\tgoto bad;\n\t\t_TIFFmemcpy(tf[1], tf[0], nbytes);\n                tf[2] = (uint16 *)_TIFFmalloc(nbytes);\n\t\tif (tf[2] == NULL)\n\t\t\tgoto bad;\n\t\t_TIFFmemcpy(tf[2], tf[0], nbytes);\n\t}\n\treturn 1;\n\nbad:\n\tif (tf[0])\n\t\t_TIFFfree(tf[0]);\n\tif (tf[1])\n\t\t_TIFFfree(tf[1]);\n\tif (tf[2])\n\t\t_TIFFfree(tf[2]);\n\ttf[0] = tf[1] = tf[2] = 0;\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              89,
              0
            ],
            [
              131,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFDefaultTransferFunction",
            "parameters": {
              "td": "TIFFDirectory"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFDefaultRefBlackWhite(TIFFDirectory* td)\n{\n\tint i;\n\n        td->td_refblackwhite = (float *)_TIFFmalloc(6*sizeof (float));\n\tif (td->td_refblackwhite == NULL)\n\t\treturn 0;\n        if (td->td_photometric == PHOTOMETRIC_YCBCR) {\n\t\t/*\n\t\t * YCbCr (Class Y) images must have the ReferenceBlackWhite\n\t\t * tag set. Fix the broken images, which lacks that tag.\n\t\t */\n\t\ttd->td_refblackwhite[0] = 0.0F;\n\t\ttd->td_refblackwhite[1] = td->td_refblackwhite[3] =\n\t\t\ttd->td_refblackwhite[5] = 255.0F;\n\t\ttd->td_refblackwhite[2] = td->td_refblackwhite[4] = 128.0F;\n\t} else {\n\t\t/*\n\t\t * Assume RGB (Class R)\n\t\t */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t    td->td_refblackwhite[2*i+0] = 0;\n\t\t    td->td_refblackwhite[2*i+1] =\n\t\t\t    (float)((1L<<td->td_bitspersample)-1L);\n\t\t}\n\t}\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              133,
              0
            ],
            [
              161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFDefaultRefBlackWhite",
            "parameters": {
              "td": "TIFFDirectory"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\tif (TIFFVGetField(tif, tag, ap))\n\t\treturn (1);\n\tswitch (tag) {\n\tcase TIFFTAG_SUBFILETYPE:\n\t\t*va_arg(ap, uint32 *) = td->td_subfiletype;\n\t\treturn (1);\n\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t*va_arg(ap, uint16 *) = td->td_bitspersample;\n\t\treturn (1);\n\tcase TIFFTAG_THRESHHOLDING:\n\t\t*va_arg(ap, uint16 *) = td->td_threshholding;\n\t\treturn (1);\n\tcase TIFFTAG_FILLORDER:\n\t\t*va_arg(ap, uint16 *) = td->td_fillorder;\n\t\treturn (1);\n\tcase TIFFTAG_ORIENTATION:\n\t\t*va_arg(ap, uint16 *) = td->td_orientation;\n\t\treturn (1);\n\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\t*va_arg(ap, uint16 *) = td->td_samplesperpixel;\n\t\treturn (1);\n\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t*va_arg(ap, uint32 *) = td->td_rowsperstrip;\n\t\treturn (1);\n\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t*va_arg(ap, uint16 *) = td->td_minsamplevalue;\n\t\treturn (1);\n\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t*va_arg(ap, uint16 *) = td->td_maxsamplevalue;\n\t\treturn (1);\n\tcase TIFFTAG_PLANARCONFIG:\n\t\t*va_arg(ap, uint16 *) = td->td_planarconfig;\n\t\treturn (1);\n\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\t*va_arg(ap, uint16 *) = td->td_resolutionunit;\n\t\treturn (1);\n\tcase TIFFTAG_PREDICTOR:\n    {\n        TIFFPredictorState* sp = (TIFFPredictorState*) tif->tif_data;\n        if( sp == NULL )\n        {\n            TIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n                         \"Cannot get \\\"Predictor\\\" tag as plugin is not configured\");\n            *va_arg(ap, uint16*) = 0;\n            return 0;\n        }\n        *va_arg(ap, uint16*) = (uint16) sp->predictor;\n        return 1;\n    }\n\tcase TIFFTAG_DOTRANGE:\n\t\t*va_arg(ap, uint16 *) = 0;\n\t\t*va_arg(ap, uint16 *) = (1<<td->td_bitspersample)-1;\n\t\treturn (1);\n\tcase TIFFTAG_INKSET:\n\t\t*va_arg(ap, uint16 *) = INKSET_CMYK;\n\t\treturn 1;\n\tcase TIFFTAG_NUMBEROFINKS:\n\t\t*va_arg(ap, uint16 *) = 4;\n\t\treturn (1);\n\tcase TIFFTAG_EXTRASAMPLES:\n\t\t*va_arg(ap, uint16 *) = td->td_extrasamples;\n\t\t*va_arg(ap, uint16 **) = td->td_sampleinfo;\n\t\treturn (1);\n\tcase TIFFTAG_MATTEING:\n\t\t*va_arg(ap, uint16 *) =\n\t\t    (td->td_extrasamples == 1 &&\n\t\t     td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\n\t\treturn (1);\n\tcase TIFFTAG_TILEDEPTH:\n\t\t*va_arg(ap, uint32 *) = td->td_tiledepth;\n\t\treturn (1);\n\tcase TIFFTAG_DATATYPE:\n\t\t*va_arg(ap, uint16 *) = td->td_sampleformat-1;\n\t\treturn (1);\n\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t*va_arg(ap, uint16 *) = td->td_sampleformat;\n                return(1);\n\tcase TIFFTAG_IMAGEDEPTH:\n\t\t*va_arg(ap, uint32 *) = td->td_imagedepth;\n\t\treturn (1);\n\tcase TIFFTAG_YCBCRCOEFFICIENTS:\n\t\t{\n\t\t\t/* defaults are from CCIR Recommendation 601-1 */\n\t\t\tstatic float ycbcrcoeffs[] = { 0.299f, 0.587f, 0.114f };\n\t\t\t*va_arg(ap, float **) = ycbcrcoeffs;\n\t\t\treturn 1;\n\t\t}\n\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t*va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[0];\n\t\t*va_arg(ap, uint16 *) = td->td_ycbcrsubsampling[1];\n\t\treturn (1);\n\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\t*va_arg(ap, uint16 *) = td->td_ycbcrpositioning;\n\t\treturn (1);\n\tcase TIFFTAG_WHITEPOINT:\n\t\t{\n\t\t\tstatic float whitepoint[2];\n\n\t\t\t/* TIFF 6.0 specification tells that it is no default\n\t\t\t   value for the WhitePoint, but AdobePhotoshop TIFF\n\t\t\t   Technical Note tells that it should be CIE D50. */\n\t\t\twhitepoint[0] =\tD50_X0 / (D50_X0 + D50_Y0 + D50_Z0);\n\t\t\twhitepoint[1] =\tD50_Y0 / (D50_X0 + D50_Y0 + D50_Z0);\n\t\t\t*va_arg(ap, float **) = whitepoint;\n\t\t\treturn 1;\n\t\t}\n\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\tif (!td->td_transferfunction[0] &&\n\t\t    !TIFFDefaultTransferFunction(td)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"No space for \\\"TransferFunction\\\" tag\");\n\t\t\treturn (0);\n\t\t}\n\t\t*va_arg(ap, uint16 **) = td->td_transferfunction[0];\n\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\n\t\t\t*va_arg(ap, uint16 **) = td->td_transferfunction[1];\n\t\t\t*va_arg(ap, uint16 **) = td->td_transferfunction[2];\n\t\t}\n\t\treturn (1);\n\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\tif (!td->td_refblackwhite && !TIFFDefaultRefBlackWhite(td))\n\t\t\treturn (0);\n\t\t*va_arg(ap, float **) = td->td_refblackwhite;\n\t\treturn (1);\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              171,
              0
            ],
            [
              301,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFVGetFieldDefaulted",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFGetFieldDefaulted(TIFF* tif, uint32 tag, ...)\n{\n\tint ok;\n\tva_list ap;\n\n\tva_start(ap, tag);\n\tok =  TIFFVGetFieldDefaulted(tif, tag, ap);\n\tva_end(ap);\n\treturn (ok);\n}",
          "fn_code_pos": [
            [
              307,
              0
            ],
            [
              317,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetFieldDefaulted",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "float\n_TIFFUInt64ToFloat(uint64 ui64)\n{\n\t_Int64 i;\n\n\ti.value = ui64;\n\tif (i.part.high >= 0) {\n\t\treturn (float)i.value;\n\t} else {\n\t\tlong double df;\n\t\tdf = (long double)i.value;\n\t\tdf += 18446744073709551616.0; /* adding 2**64 */\n\t\treturn (float)df;\n\t}\n}",
          "fn_code_pos": [
            [
              328,
              0
            ],
            [
              342,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFUInt64ToFloat",
            "parameters": {
              "ui64": "uint64"
            },
            "return_type": "float"
          }
        },
        {
          "fn_code": "double\n_TIFFUInt64ToDouble(uint64 ui64)\n{\n\t_Int64 i;\n\n\ti.value = ui64;\n\tif (i.part.high >= 0) {\n\t\treturn (double)i.value;\n\t} else {\n\t\tlong double df;\n\t\tdf = (long double)i.value;\n\t\tdf += 18446744073709551616.0; /* adding 2**64 */\n\t\treturn (double)df;\n\t}\n}",
          "fn_code_pos": [
            [
              344,
              0
            ],
            [
              358,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFUInt64ToDouble",
            "parameters": {
              "ui64": "uint64"
            },
            "return_type": "double"
          }
        },
        {
          "fn_code": "float _TIFFClampDoubleToFloat( double val )\n{\n    if( val > FLT_MAX )\n        return FLT_MAX;\n    if( val < -FLT_MAX )\n        return -FLT_MAX;\n    return (float)val;\n}",
          "fn_code_pos": [
            [
              360,
              0
            ],
            [
              367,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFClampDoubleToFloat",
            "parameters": {
              "val": "double"
            },
            "return_type": "float"
          }
        },
        {
          "fn_code": "int _TIFFSeekOK(TIFF* tif, toff_t off)\n{\n    /* Huge offsets, especially -1 / UINT64_MAX, can cause issues */\n    /* See http://bugzilla.maptools.org/show_bug.cgi?id=2726 */\n    return off <= (~(uint64)0)/2 && TIFFSeekFile(tif,off,SEEK_SET)==off;\n}",
          "fn_code_pos": [
            [
              369,
              0
            ],
            [
              374,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFSeekOK",
            "parameters": {
              "tif": "TIFF",
              "off": "toff_t"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "_TIFFCheckRealloc(TIFF* tif, void* buffer,\n\t\t  tmsize_t nmemb, tmsize_t elem_size, const char* what)",
          "fn_dec_pos": [
            [
              61,
              0
            ],
            [
              62,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFCheckRealloc",
            "parameters": {
              "tif": "TIFF",
              "buffer": "void",
              "nmemb": "tmsize_t",
              "elem_size": "tmsize_t",
              "what": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFCheckMalloc(TIFF* tif, tmsize_t nmemb, tmsize_t elem_size, const char* what)",
          "fn_dec_pos": [
            [
              84,
              0
            ],
            [
              84,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFCheckMalloc",
            "parameters": {
              "tif": "TIFF",
              "nmemb": "tmsize_t",
              "elem_size": "tmsize_t",
              "what": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, uint16*)",
          "fn_dec_pos": [
            [
              219,
              13
            ],
            [
              219,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, uint16*) = (uint16)",
          "fn_dec_pos": [
            [
              222,
              9
            ],
            [
              222,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, uint16*)",
          "fn_dec_pos": [
            [
              222,
              9
            ],
            [
              222,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, float **)",
          "fn_dec_pos": [
            [
              260,
              4
            ],
            [
              260,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, float **)",
          "fn_dec_pos": [
            [
              279,
              4
            ],
            [
              279,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, uint16 **)",
          "fn_dec_pos": [
            [
              290,
              4
            ],
            [
              290,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, uint16 **)",
          "fn_dec_pos": [
            [
              291,
              4
            ],
            [
              291,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct _Int64Parts {\n\tint32 low, high;\n}",
          {
            "low": "int32"
          },
          "_Int64Parts",
          [
            319,
            0
          ],
          [
            321,
            1
          ]
        ],
        [
          "struct _Int64Parts {\n\tint32 low, high;\n}",
          {
            "low": "int32"
          },
          "_Int64Parts",
          [
            319,
            0
          ],
          [
            321,
            1
          ]
        ],
        [
          "struct _Int64Parts",
          {},
          "",
          [
            324,
            1
          ],
          [
            324,
            19
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"tif_predict.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <float.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_zstd.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nZSTDFixupTags(TIFF* tif)\n{\n        (void) tif;\n        return 1;\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZSTDFixupTags",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nZSTDSetupDecode(TIFF* tif)\n{\n        ZSTDState* sp = DecoderState(tif);\n\n        assert(sp != NULL);\n\n        /* if we were last encoding, terminate this mode */\n        if (sp->state & LSTATE_INIT_ENCODE) {\n            ZSTD_freeCStream(sp->cstream);\n            sp->cstream = NULL;\n            sp->state = 0;\n        }\n\n        sp->state |= LSTATE_INIT_DECODE;\n        return 1;\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              85,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZSTDSetupDecode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nZSTDPreDecode(TIFF* tif, uint16 s)\n{\n        static const char module[] = \"ZSTDPreDecode\";\n        ZSTDState* sp = DecoderState(tif);\n        size_t zstd_ret;\n\n        (void) s;\n        assert(sp != NULL);\n\n        if( (sp->state & LSTATE_INIT_DECODE) == 0 )\n            tif->tif_setupdecode(tif);\n\n        if( sp->dstream )\n        {\n            ZSTD_freeDStream(sp->dstream);\n            sp->dstream = NULL;\n        }\n\n        sp->dstream = ZSTD_createDStream();\n        if( sp->dstream == NULL ) {\n            TIFFErrorExt(tif->tif_clientdata, module,\n                         \"Cannot allocate decompression stream\");\n            return 0;\n        }\n        zstd_ret = ZSTD_initDStream(sp->dstream);\n        if( ZSTD_isError(zstd_ret) ) {\n            TIFFErrorExt(tif->tif_clientdata, module,\n                         \"Error in ZSTD_initDStream(): %s\",\n                         ZSTD_getErrorName(zstd_ret));\n            return 0;\n        }\n\n        return 1;\n}",
          "fn_code_pos": [
            [
              90,
              0
            ],
            [
              124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZSTDPreDecode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ZSTDEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              59,
              11
            ],
            [
              59,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZSTDEncode",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ZSTDDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)",
          "fn_dec_pos": [
            [
              60,
              11
            ],
            [
              60,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZSTDDecode",
            "parameters": {
              "tif": "TIFF",
              "op": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ZSTDDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)",
          "fn_dec_pos": [
            [
              127,
              0
            ],
            [
              127,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZSTDDecode",
            "parameters": {
              "tif": "TIFF",
              "op": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n        TIFFPredictorState predict;\n        ZSTD_DStream*   dstream;\n        ZSTD_CStream*   cstream;\n        int             compression_level;      /* compression level */\n        ZSTD_outBuffer  out_buffer;\n        int             state;                  /* state flags */\n#define LSTATE_INIT_DECODE 0x01\n#define LSTATE_INIT_ENCODE 0x02\n\n        TIFFVGetMethod  vgetparent;            /* super-class method */\n        TIFFVSetMethod  vsetparent;            /* super-class method */\n} ZSTDState;",
          {
            "predict": "TIFFPredictorState",
            "*   dstream": "ZSTD_DStream",
            "*   cstream": "ZSTD_CStream",
            "compression_level": "int",
            "out_buffer": "ZSTD_outBuffer",
            "state": "int",
            "vgetparent": "TIFFVGetMethod",
            "vsetparent": "TIFFVSetMethod"
          },
          "ZSTDState",
          [
            41,
            0
          ],
          [
            53,
            12
          ]
        ],
        [
          "typedef struct {\n        TIFFPredictorState predict;\n        ZSTD_DStream*   dstream;\n        ZSTD_CStream*   cstream;\n        int             compression_level;      /* compression level */\n        ZSTD_outBuffer  out_buffer;\n        int             state;                  /* state flags */\n#define LSTATE_INIT_DECODE 0x01\n#define LSTATE_INIT_ENCODE 0x02\n\n        TIFFVGetMethod  vgetparent;            /* super-class method */\n        TIFFVSetMethod  vsetparent;            /* super-class method */\n} ZSTDState;",
          {
            "predict": "TIFFPredictorState",
            "*   dstream": "ZSTD_DStream",
            "*   cstream": "ZSTD_CStream",
            "compression_level": "int",
            "out_buffer": "ZSTD_outBuffer",
            "state": "int",
            "vgetparent": "TIFFVGetMethod",
            "vsetparent": "TIFFVSetMethod"
          },
          "ZSTDState",
          [
            41,
            0
          ],
          [
            53,
            12
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"tif_predict.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"zstd.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_dirwrite.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nTIFFWriteDirectory(TIFF* tif)\n{\n\treturn TIFFWriteDirectorySec(tif,TRUE,TRUE,NULL);\n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              181,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFCheckpointDirectory(TIFF* tif)\n{\n\tint rc;\n\t/* Setup the strips arrays, if they haven't already been. */\n\tif (tif->tif_dir.td_stripoffset == NULL)\n\t    (void) TIFFSetupStrips(tif);\n\trc = TIFFWriteDirectorySec(tif,TRUE,FALSE,NULL);\n\t(void) TIFFSetWriteOffset(tif, TIFFSeekFile(tif, 0, SEEK_END));\n\treturn rc;\n}",
          "fn_code_pos": [
            [
              189,
              0
            ],
            [
              199,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCheckpointDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFWriteCustomDirectory(TIFF* tif, uint64* pdiroff)\n{\n\treturn TIFFWriteDirectorySec(tif,FALSE,FALSE,pdiroff);\n}",
          "fn_code_pos": [
            [
              201,
              0
            ],
            [
              205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteCustomDirectory",
            "parameters": {
              "tif": "TIFF",
              "pdiroff": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFRewriteDirectory( TIFF *tif )\n{\n\tstatic const char module[] = \"TIFFRewriteDirectory\";\n\n\t/* We don't need to do anything special if it hasn't been written. */\n\tif( tif->tif_diroff == 0 )\n\t\treturn TIFFWriteDirectory( tif );\n\n\t/*\n\t * Find and zero the pointer to this directory, so that TIFFLinkDirectory\n\t * will cause it to be added after this directories current pre-link.\n\t */\n\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tif (tif->tif_header.classic.tiff_diroff == tif->tif_diroff)\n\t\t{\n\t\t\ttif->tif_header.classic.tiff_diroff = 0;\n\t\t\ttif->tif_diroff = 0;\n\n\t\t\tTIFFSeekFile(tif,4,SEEK_SET);\n\t\t\tif (!WriteOK(tif, &(tif->tif_header.classic.tiff_diroff),4))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t    \"Error updating TIFF header\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint32 nextdir;\n\t\t\tnextdir = tif->tif_header.classic.tiff_diroff;\n\t\t\twhile(1) {\n\t\t\t\tuint16 dircount;\n\t\t\t\tuint32 nextnextdir;\n\n\t\t\t\tif (!SeekOK(tif, nextdir) ||\n\t\t\t\t    !ReadOK(tif, &dircount, 2)) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory count\");\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\t\tTIFFSwabShort(&dircount);\n\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t    nextdir+2+dircount*12, SEEK_SET);\n\t\t\t\tif (!ReadOK(tif, &nextnextdir, 4)) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory link\");\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong(&nextnextdir);\n\t\t\t\tif (nextnextdir==tif->tif_diroff)\n\t\t\t\t{\n\t\t\t\t\tuint32 m;\n\t\t\t\t\tm=0;\n\t\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t\t    nextdir+2+dircount*12, SEEK_SET);\n\t\t\t\t\tif (!WriteOK(tif, &m, 4)) {\n\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\t     \"Error writing directory link\");\n\t\t\t\t\t\treturn (0);\n\t\t\t\t\t}\n\t\t\t\t\ttif->tif_diroff=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnextdir=nextnextdir;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (tif->tif_header.big.tiff_diroff == tif->tif_diroff)\n\t\t{\n\t\t\ttif->tif_header.big.tiff_diroff = 0;\n\t\t\ttif->tif_diroff = 0;\n\n\t\t\tTIFFSeekFile(tif,8,SEEK_SET);\n\t\t\tif (!WriteOK(tif, &(tif->tif_header.big.tiff_diroff),8))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t    \"Error updating TIFF header\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 nextdir;\n\t\t\tnextdir = tif->tif_header.big.tiff_diroff;\n\t\t\twhile(1) {\n\t\t\t\tuint64 dircount64;\n\t\t\t\tuint16 dircount;\n\t\t\t\tuint64 nextnextdir;\n\n\t\t\t\tif (!SeekOK(tif, nextdir) ||\n\t\t\t\t    !ReadOK(tif, &dircount64, 8)) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory count\");\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\t\tif (dircount64>0xFFFF)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Sanity check on tag count failed, likely corrupt TIFF\");\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tdircount=(uint16)dircount64;\n\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t    nextdir+8+dircount*20, SEEK_SET);\n\t\t\t\tif (!ReadOK(tif, &nextnextdir, 8)) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory link\");\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\t\tTIFFSwabLong8(&nextnextdir);\n\t\t\t\tif (nextnextdir==tif->tif_diroff)\n\t\t\t\t{\n\t\t\t\t\tuint64 m;\n\t\t\t\t\tm=0;\n\t\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t\t    nextdir+8+dircount*20, SEEK_SET);\n\t\t\t\t\tif (!WriteOK(tif, &m, 8)) {\n\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\t     \"Error writing directory link\");\n\t\t\t\t\t\treturn (0);\n\t\t\t\t\t}\n\t\t\t\t\ttif->tif_diroff=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnextdir=nextnextdir;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now use TIFFWriteDirectory() normally.\n\t */\n\n\treturn TIFFWriteDirectory( tif );\n}",
          "fn_code_pos": [
            [
              213,
              0
            ],
            [
              357,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRewriteDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)\n{\n\tstatic const char module[] = \"TIFFWriteDirectorySec\";\n\tuint32 ndir;\n\tTIFFDirEntry* dir;\n\tuint32 dirsize;\n\tvoid* dirmem;\n\tuint32 m;\n\tif (tif->tif_mode == O_RDONLY)\n\t\treturn (1);\n\n        _TIFFFillStriles( tif );\n        \n\t/*\n\t * Clear write state so that subsequent images with\n\t * different characteristics get the right buffers\n\t * setup for them.\n\t */\n\tif (imagedone)\n\t{\n\t\tif (tif->tif_flags & TIFF_POSTENCODE)\n\t\t{\n\t\t\ttif->tif_flags &= ~TIFF_POSTENCODE;\n\t\t\tif (!(*tif->tif_postencode)(tif))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t\t    \"Error post-encoding before directory write\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\t(*tif->tif_close)(tif);       /* shutdown encoder */\n\t\t/*\n\t\t * Flush any data that might have been written\n\t\t * by the compression close+cleanup routines.  But\n                 * be careful not to write stuff if we didn't add data\n                 * in the previous steps as the \"rawcc\" data may well be\n                 * a previously read tile/strip in mixed read/write mode.\n\t\t */\n\t\tif (tif->tif_rawcc > 0 \n\t\t    && (tif->tif_flags & TIFF_BEENWRITING) != 0 )\n\t\t{\n\t\t    if( !TIFFFlushData1(tif) )\n                    {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Error flushing data before directory write\");\n\t\t\treturn (0);\n                    }\n\t\t}\n\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata)\n\t\t{\n\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\ttif->tif_rawdata = NULL;\n\t\t\ttif->tif_rawcc = 0;\n\t\t\ttif->tif_rawdatasize = 0;\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = 0;\n\t\t}\n\t\ttif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP);\n\t}\n\tdir=NULL;\n\tdirmem=NULL;\n\tdirsize=0;\n\twhile (1)\n\t{\n\t\tndir=0;\n\t\tif (isimage)\n\t\t{\n\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGEWIDTH,tif->tif_dir.td_imagewidth))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGELENGTH,tif->tif_dir.td_imagelength))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILEWIDTH,tif->tif_dir.td_tilewidth))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILELENGTH,tif->tif_dir.td_tilelength))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XRESOLUTION,tif->tif_dir.td_xresolution))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YRESOLUTION,tif->tif_dir.td_yresolution))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_POSITION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XPOSITION,tif->tif_dir.td_xposition))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YPOSITION,tif->tif_dir.td_yposition))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SUBFILETYPE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_SUBFILETYPE,tif->tif_dir.td_subfiletype))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_BITSPERSAMPLE,tif->tif_dir.td_bitspersample))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_COMPRESSION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_COMPRESSION,tif->tif_dir.td_compression))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PHOTOMETRIC,tif->tif_dir.td_photometric))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_THRESHHOLDING,tif->tif_dir.td_threshholding))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_FILLORDER))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_FILLORDER,tif->tif_dir.td_fillorder))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_ORIENTATION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_ORIENTATION,tif->tif_dir.td_orientation))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_SAMPLESPERPIXEL,tif->tif_dir.td_samplesperpixel))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_ROWSPERSTRIP,tif->tif_dir.td_rowsperstrip))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MINSAMPLEVALUE,tif->tif_dir.td_minsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MAXSAMPLEVALUE,tif->tif_dir.td_maxsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_PLANARCONFIG))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PLANARCONFIG,tif->tif_dir.td_planarconfig))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_RESOLUTIONUNIT,tif->tif_dir.td_resolutionunit))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_PAGENUMBER))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_PAGENUMBER,2,&tif->tif_dir.td_pagenumber[0]))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPBYTECOUNTS))\n\t\t\t{\n\t\t\t\tif (!isTiled(tif))\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPOFFSETS))\n\t\t\t{\n\t\t\t\tif (!isTiled(tif))\n\t\t\t\t{\n                    /* td_stripoffset might be NULL in an odd OJPEG case. See\n                     *  tif_dirread.c around line 3634.\n                     * XXX: OJPEG hack.\n                     * If a) compression is OJPEG, b) it's not a tiled TIFF,\n                     * and c) the number of strips is 1,\n                     * then we tolerate the absence of stripoffsets tag,\n                     * because, presumably, all required data is in the\n                     * JpegInterchangeFormat stream.\n                     * We can get here when using tiffset on such a file.\n                     * See http://bugzilla.maptools.org/show_bug.cgi?id=2500\n                    */\n                    if (tif->tif_dir.td_stripoffset != NULL &&\n                        !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n                        goto bad;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_COLORMAP))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_EXTRASAMPLES))\n\t\t\t{\n\t\t\t\tif (tif->tif_dir.td_extrasamples)\n\t\t\t\t{\n\t\t\t\t\tuint16 na;\n\t\t\t\t\tuint16* nb;\n\t\t\t\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb);\n\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDEPTH))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_TILEDEPTH,tif->tif_dir.td_tiledepth))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_HALFTONEHINTS,2,&tif->tif_dir.td_halftonehints[0]))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_YCBCRSUBSAMPLING,2,&tif->tif_dir.td_ycbcrsubsampling[0]))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_YCBCRPOSITIONING,tif->tif_dir.td_ycbcrpositioning))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_REFBLACKWHITE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,TIFFTAG_REFERENCEBLACKWHITE,6,tif->tif_dir.td_refblackwhite))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagTransferfunction(tif,&ndir,dir))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_INKNAMES))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t{\n\t\t\t\tuint32 n;\n\t\t\t\tfor (n=0; n<tif->tif_nfields; n++) {\n\t\t\t\t\tconst TIFFField* o;\n\t\t\t\t\to = tif->tif_fields[n];\n\t\t\t\t\tif ((o->field_bit>=FIELD_CODEC)&&(TIFFFieldSet(tif,o->field_bit)))\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (o->get_field_type)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase TIFF_SETGET_ASCII:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32 pa;\n\t\t\t\t\t\t\t\t\tchar* pb;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_ASCII);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pb);\n\t\t\t\t\t\t\t\t\tpa=(uint32)(strlen(pb));\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SETGET_UINT16:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint16 p;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_SHORT);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SETGET_UINT32:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32 p;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_LONG);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SETGET_C32_UINT8:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32 pa;\n\t\t\t\t\t\t\t\t\tvoid* pb;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_UNDEFINED);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE2);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==1);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pa,&pb);\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t\t\t            \"Cannot write tag %d (%s)\",\n\t\t\t\t\t\t\t\t            TIFFFieldTag(o),\n                                                                            o->field_name ? o->field_name : \"unknown\");\n\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++)\n\t\t{\n                        uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag;\n                        uint32 count = tif->tif_dir.td_customValues[m].count;\n\t\t\tswitch (tif->tif_dir.td_customValues[m].info->field_type)\n\t\t\t{\n\t\t\t\tcase TIFF_ASCII:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_BYTE:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagByteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSbyteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSshortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSlongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG8:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSlong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdIfd8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(0);   /* we should never get here */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (dir!=NULL)\n\t\t\tbreak;\n\t\tdir=_TIFFmalloc(ndir*sizeof(TIFFDirEntry));\n\t\tif (dir==NULL)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (isimage)\n\t\t{\n\t\t\tif ((tif->tif_diroff==0)&&(!TIFFLinkDirectory(tif)))\n\t\t\t\tgoto bad;\n\t\t}\n\t\telse\n\t\t\ttif->tif_diroff=(TIFFSeekFile(tif,0,SEEK_END)+1)&(~((toff_t)1));\n\t\tif (pdiroff!=NULL)\n\t\t\t*pdiroff=tif->tif_diroff;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\tdirsize=2+ndir*12+4;\n\t\telse\n\t\t\tdirsize=8+ndir*20+8;\n\t\ttif->tif_dataoff=tif->tif_diroff+dirsize;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\ttif->tif_dataoff=(uint32)tif->tif_dataoff;\n\t\tif ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (tif->tif_dataoff&1)\n\t\t\ttif->tif_dataoff++;\n\t\tif (isimage)\n\t\t\ttif->tif_curdir++;\n\t}\n\tif (isimage)\n\t{\n\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0))\n\t\t{\n\t\t\tuint32 na;\n\t\t\tTIFFDirEntry* nb;\n\t\t\tfor (na=0, nb=dir; ; na++, nb++)\n\t\t\t{\n\t\t\t\tif( na == ndir )\n                                {\n                                    TIFFErrorExt(tif->tif_clientdata,module,\n                                                 \"Cannot find SubIFD tag\");\n                                    goto bad;\n                                }\n\t\t\t\tif (nb->tdir_tag==TIFFTAG_SUBIFD)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+2+na*12+8;\n\t\t\telse\n\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+8+na*20+12;\n\t\t}\n\t}\n\tdirmem=_TIFFmalloc(dirsize);\n\tif (dirmem==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\tgoto bad;\n\t}\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tuint8* n;\n\t\tuint32 nTmp;\n\t\tTIFFDirEntry* o;\n\t\tn=dirmem;\n\t\t*(uint16*)n=(uint16)ndir;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)n);\n\t\tn+=2;\n\t\to=dir;\n\t\tfor (m=0; m<ndir; m++)\n\t\t{\n\t\t\t*(uint16*)n=o->tdir_tag;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\t*(uint16*)n=o->tdir_type;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\tnTmp = (uint32)o->tdir_count;\n\t\t\t_TIFFmemcpy(n,&nTmp,4);\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong((uint32*)n);\n\t\t\tn+=4;\n\t\t\t/* This is correct. The data has been */\n\t\t\t/* swabbed previously in TIFFWriteDirectoryTagData */\n\t\t\t_TIFFmemcpy(n,&o->tdir_offset,4);\n\t\t\tn+=4;\n\t\t\to++;\n\t\t}\n\t\tnTmp = (uint32)tif->tif_nextdiroff;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong(&nTmp);\n\t\t_TIFFmemcpy(n,&nTmp,4);\n\t}\n\telse\n\t{\n\t\tuint8* n;\n\t\tTIFFDirEntry* o;\n\t\tn=dirmem;\n\t\t*(uint64*)n=ndir;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong8((uint64*)n);\n\t\tn+=8;\n\t\to=dir;\n\t\tfor (m=0; m<ndir; m++)\n\t\t{\n\t\t\t*(uint16*)n=o->tdir_tag;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\t*(uint16*)n=o->tdir_type;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\t_TIFFmemcpy(n,&o->tdir_count,8);\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8((uint64*)n);\n\t\t\tn+=8;\n\t\t\t_TIFFmemcpy(n,&o->tdir_offset,8);\n\t\t\tn+=8;\n\t\t\to++;\n\t\t}\n\t\t_TIFFmemcpy(n,&tif->tif_nextdiroff,8);\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong8((uint64*)n);\n\t}\n\t_TIFFfree(dir);\n\tdir=NULL;\n\tif (!SeekOK(tif,tif->tif_diroff))\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\n\t\tgoto bad;\n\t}\n\tif (!WriteOK(tif,dirmem,(tmsize_t)dirsize))\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\n\t\tgoto bad;\n\t}\n\t_TIFFfree(dirmem);\n\tif (imagedone)\n\t{\n\t\tTIFFFreeDirectory(tif);\n\t\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\t\ttif->tif_flags &= ~TIFF_DIRTYSTRIP;\n\t\t(*tif->tif_cleanup)(tif);\n\t\t/*\n\t\t* Reset directory-related state for subsequent\n\t\t* directories.\n\t\t*/\n\t\tTIFFCreateDirectory(tif);\n\t}\n\treturn(1);\nbad:\n\tif (dir!=NULL)\n\t\t_TIFFfree(dir);\n\tif (dirmem!=NULL)\n\t\t_TIFFfree(dirmem);\n\treturn(0);\n}\n\nstatic int8 TIFFClampDoubleToInt8( double val )\n{\n    if( val > 127 )\n        return 127;\n    if( val < -128 || val != val )\n        return -128;\n    return (int8)val;\n}\n\nstatic int16 TIFFClampDoubleToInt16( double val )\n{\n    if( val > 32767 )\n        return 32767;\n    if( val < -32768 || val != val )\n        return -32768;\n    return (int16)val;\n}\n\nstatic int32 TIFFClampDoubleToInt32( double val )\n{\n    if( val > 0x7FFFFFFF )\n        return 0x7FFFFFFF;\n    if( val < -0x7FFFFFFF-1 || val != val )\n        return -0x7FFFFFFF-1;\n    return (int32)val;\n}\n\nstatic uint8 TIFFClampDoubleToUInt8( double val )\n{\n    if( val < 0 )\n        return 0;\n    if( val > 255 || val != val )\n        return 255;\n    return (uint8)val;\n}\n\nstatic uint16 TIFFClampDoubleToUInt16( double val )\n{\n    if( val < 0 )\n        return 0;\n    if( val > 65535 || val != val )\n        return 65535;\n    return (uint16)val;\n}\n\nstatic uint32 TIFFClampDoubleToUInt32( double val )\n{\n    if( val < 0 )\n        return 0;\n    if( val > 0xFFFFFFFFU || val != val )\n        return 0xFFFFFFFFU;\n    return (uint32)val;\n}\n\nstatic int\nTIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, double* value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagSampleformatArray\";\n\tvoid* conv;\n\tuint32 i;\n\tint ok;\n\tconv = _TIFFmalloc(count*sizeof(double));\n\tif (conv == NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Out of memory\");\n\t\treturn (0);\n\t}\n\n\tswitch (tif->tif_dir.td_sampleformat)\n\t{\n\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\tif (tif->tif_dir.td_bitspersample<=32)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((float*)conv)[i] = _TIFFClampDoubleToFloat(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagFloatArray(tif,ndir,dir,tag,count,(float*)conv);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tok = TIFFWriteDirectoryTagDoubleArray(tif,ndir,dir,tag,count,value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_INT:\n\t\t\tif (tif->tif_dir.td_bitspersample<=8)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((int8*)conv)[i] = TIFFClampDoubleToInt8(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagSbyteArray(tif,ndir,dir,tag,count,(int8*)conv);\n\t\t\t}\n\t\t\telse if (tif->tif_dir.td_bitspersample<=16)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((int16*)conv)[i] = TIFFClampDoubleToInt16(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16*)conv);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((int32*)conv)[i] = TIFFClampDoubleToInt32(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagSlongArray(tif,ndir,dir,tag,count,(int32*)conv);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_UINT:\n\t\t\tif (tif->tif_dir.td_bitspersample<=8)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((uint8*)conv)[i] = TIFFClampDoubleToUInt8(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagByteArray(tif,ndir,dir,tag,count,(uint8*)conv);\n\t\t\t}\n\t\t\telse if (tif->tif_dir.td_bitspersample<=16)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((uint16*)conv)[i] = TIFFClampDoubleToUInt16(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagShortArray(tif,ndir,dir,tag,count,(uint16*)conv);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((uint32*)conv)[i] = TIFFClampDoubleToUInt32(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagLongArray(tif,ndir,dir,tag,count,(uint32*)conv);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tok = 0;\n\t}\n\n\t_TIFFfree(conv);\n\treturn (ok);\n}\n\n#if 0\nstatic int\nTIFFWriteDirectoryTagSampleformatPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n\tswitch (tif->tif_dir.td_sampleformat)\n\t{\n\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\tif (tif->tif_dir.td_bitspersample<=32)\n\t\t\t\treturn(TIFFWriteDirectoryTagFloatPerSample(tif,ndir,dir,tag,(float)value));\n\t\t\telse\n\t\t\t\treturn(TIFFWriteDirectoryTagDoublePerSample(tif,ndir,dir,tag,value));\n\t\tcase SAMPLEFORMAT_INT:\n\t\t\tif (tif->tif_dir.td_bitspersample<=8)\n\t\t\t\treturn(TIFFWriteDirectoryTagSbytePerSample(tif,ndir,dir,tag,(int8)value));\n\t\t\telse if (tif->tif_dir.td_bitspersample<=16)\n\t\t\t\treturn(TIFFWriteDirectoryTagSshortPerSample(tif,ndir,dir,tag,(int16)value));\n\t\t\telse\n\t\t\t\treturn(TIFFWriteDirectoryTagSlongPerSample(tif,ndir,dir,tag,(int32)value));\n\t\tcase SAMPLEFORMAT_UINT:\n\t\t\tif (tif->tif_dir.td_bitspersample<=8)\n\t\t\t\treturn(TIFFWriteDirectoryTagBytePerSample(tif,ndir,dir,tag,(uint8)value));\n\t\t\telse if (tif->tif_dir.td_bitspersample<=16)\n\t\t\t\treturn(TIFFWriteDirectoryTagShortPerSample(tif,ndir,dir,tag,(uint16)value));\n\t\t\telse\n\t\t\t\treturn(TIFFWriteDirectoryTagLongPerSample(tif,ndir,dir,tag,(uint32)value));\n\t\tdefault:\n\t\t\treturn(1);\n\t}\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagAscii(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, char* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedAscii(tif,ndir,dir,tag,count,value));\n}\n\nstatic int\nTIFFWriteDirectoryTagUndefinedArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedUndefinedArray(tif,ndir,dir,tag,count,value));\n}\n\n#ifdef notdef\nstatic int\nTIFFWriteDirectoryTagByte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint8 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedByte(tif,ndir,dir,tag,value));\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagByteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedByteArray(tif,ndir,dir,tag,count,value));\n}\n\n#if 0\nstatic int\nTIFFWriteDirectoryTagBytePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint8 value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagBytePerSample\";\n\tuint8* m;\n\tuint8* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(uint8));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedByteArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}\n#endif\n\n#ifdef notdef\nstatic int\nTIFFWriteDirectoryTagSbyte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int8 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSbyte(tif,ndir,dir,tag,value));\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagSbyteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int8* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSbyteArray(tif,ndir,dir,tag,count,value));\n}\n\n#if 0\nstatic int\nTIFFWriteDirectoryTagSbytePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int8 value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagSbytePerSample\";\n\tint8* m;\n\tint8* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(int8));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedSbyteArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagShort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedShort(tif,ndir,dir,tag,value));\n}\n\nstatic int\nTIFFWriteDirectoryTagShortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint16* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedShortArray(tif,ndir,dir,tag,count,value));\n}\n\nstatic int\nTIFFWriteDirectoryTagShortPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagShortPerSample\";\n\tuint16* m;\n\tuint16* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(uint16));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedShortArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}\n\n#ifdef notdef\nstatic int\nTIFFWriteDirectoryTagSshort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int16 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSshort(tif,ndir,dir,tag,value));\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagSshortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int16* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSshortArray(tif,ndir,dir,tag,count,value));\n}\n\n#if 0\nstatic int\nTIFFWriteDirectoryTagSshortPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int16 value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagSshortPerSample\";\n\tint16* m;\n\tint16* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(int16));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedSshortArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedLong(tif,ndir,dir,tag,value));\n}\n\nstatic int\nTIFFWriteDirectoryTagLongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedLongArray(tif,ndir,dir,tag,count,value));\n}\n\n#if 0\nstatic int\nTIFFWriteDirectoryTagLongPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagLongPerSample\";\n\tuint32* m;\n\tuint32* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(uint32));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedLongArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}\n#endif\n\n#ifdef notdef\nstatic int\nTIFFWriteDirectoryTagSlong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int32 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSlong(tif,ndir,dir,tag,value));\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagSlongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int32* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSlongArray(tif,ndir,dir,tag,count,value));\n}\n\n#if 0\nstatic int\nTIFFWriteDirectoryTagSlongPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int32 value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagSlongPerSample\";\n\tint32* m;\n\tint32* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(int32));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedSlongArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}\n#endif\n\n#ifdef notdef\nstatic int\nTIFFWriteDirectoryTagLong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint64 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedLong8(tif,ndir,dir,tag,value));\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedLong8Array(tif,ndir,dir,tag,count,value));\n}\n\n#ifdef notdef\nstatic int\nTIFFWriteDirectoryTagSlong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int64 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSlong8(tif,ndir,dir,tag,value));\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagSlong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int64* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSlong8Array(tif,ndir,dir,tag,count,value));\n}\n\nstatic int\nTIFFWriteDirectoryTagRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedRational(tif,ndir,dir,tag,value));\n}\n\nstatic int\nTIFFWriteDirectoryTagRationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedRationalArray(tif,ndir,dir,tag,count,value));\n}\n\nstatic int\nTIFFWriteDirectoryTagSrationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSrationalArray(tif,ndir,dir,tag,count,value));\n}\n\n#ifdef notdef\nstatic int TIFFWriteDirectoryTagFloat(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, float value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedFloat(tif,ndir,dir,tag,value));\n}\n#endif\n\nstatic int TIFFWriteDirectoryTagFloatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedFloatArray(tif,ndir,dir,tag,count,value));\n}\n\n#if 0\nstatic int TIFFWriteDirectoryTagFloatPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, float value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagFloatPerSample\";\n\tfloat* m;\n\tfloat* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(float));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedFloatArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}\n#endif\n\n#ifdef notdef\nstatic int TIFFWriteDirectoryTagDouble(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedDouble(tif,ndir,dir,tag,value));\n}\n#endif\n\nstatic int TIFFWriteDirectoryTagDoubleArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, double* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedDoubleArray(tif,ndir,dir,tag,count,value));\n}\n\n#if 0\nstatic int TIFFWriteDirectoryTagDoublePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagDoublePerSample\";\n\tdouble* m;\n\tdouble* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(double));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedDoubleArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagIfdArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedIfdArray(tif,ndir,dir,tag,count,value));\n}\n\n#ifdef notdef\nstatic int\nTIFFWriteDirectoryTagIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedIfd8Array(tif,ndir,dir,tag,count,value));\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagShortLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tif (value<=0xFFFF)\n\t\treturn(TIFFWriteDirectoryTagCheckedShort(tif,ndir,dir,tag,(uint16)value));\n\telse\n\t\treturn(TIFFWriteDirectoryTagCheckedLong(tif,ndir,dir,tag,value));\n}\n\n/************************************************************************/\n/*                TIFFWriteDirectoryTagLongLong8Array()                 */\n/*                                                                      */\n/*      Write out LONG8 array as LONG8 for BigTIFF or LONG for          */\n/*      Classic TIFF with some checking.                                */\n/************************************************************************/\n\nstatic int\nTIFFWriteDirectoryTagLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)\n{\n    static const char module[] = \"TIFFWriteDirectoryTagLongLong8Array\";\n    uint64* ma;\n    uint32 mb;\n    uint32* p;\n    uint32* q;\n    int o;\n\n    /* is this just a counting pass? */\n    if (dir==NULL)\n    {\n        (*ndir)++;\n        return(1);\n    }\n\n    /* We always write LONG8 for BigTIFF, no checking needed. */\n    if( tif->tif_flags&TIFF_BIGTIFF )\n        return TIFFWriteDirectoryTagCheckedLong8Array(tif,ndir,dir,\n                                                      tag,count,value);\n\n    /*\n    ** For classic tiff we want to verify everything is in range for LONG\n    ** and convert to long format.\n    */\n\n    p = _TIFFmalloc(count*sizeof(uint32));\n    if (p==NULL)\n    {\n        TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n        return(0);\n    }\n\n    for (q=p, ma=value, mb=0; mb<count; ma++, mb++, q++)\n    {\n        if (*ma>0xFFFFFFFF)\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\n                         \"Attempt to write value larger than 0xFFFFFFFF in Classic TIFF file.\");\n            _TIFFfree(p);\n            return(0);\n        }\n        *q= (uint32)(*ma);\n    }\n\n    o=TIFFWriteDirectoryTagCheckedLongArray(tif,ndir,dir,tag,count,p);\n    _TIFFfree(p);\n\n    return(o);\n}\n\n/************************************************************************/\n/*                 TIFFWriteDirectoryTagIfdIfd8Array()                  */\n/*                                                                      */\n/*      Write either IFD8 or IFD array depending on file type.          */\n/************************************************************************/\n\nstatic int\nTIFFWriteDirectoryTagIfdIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)\n{\n    static const char module[] = \"TIFFWriteDirectoryTagIfdIfd8Array\";\n    uint64* ma;\n    uint32 mb;\n    uint32* p;\n    uint32* q;\n    int o;\n\n    /* is this just a counting pass? */\n    if (dir==NULL)\n    {\n        (*ndir)++;\n        return(1);\n    }\n\n    /* We always write IFD8 for BigTIFF, no checking needed. */\n    if( tif->tif_flags&TIFF_BIGTIFF )\n        return TIFFWriteDirectoryTagCheckedIfd8Array(tif,ndir,dir,\n                                                     tag,count,value);\n\n    /*\n    ** For classic tiff we want to verify everything is in range for IFD\n    ** and convert to long format.\n    */\n\n    p = _TIFFmalloc(count*sizeof(uint32));\n    if (p==NULL)\n    {\n        TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n        return(0);\n    }\n\n    for (q=p, ma=value, mb=0; mb<count; ma++, mb++, q++)\n    {\n        if (*ma>0xFFFFFFFF)\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\n                         \"Attempt to write value larger than 0xFFFFFFFF in Classic TIFF file.\");\n            _TIFFfree(p);\n            return(0);\n        }\n        *q= (uint32)(*ma);\n    }\n\n    o=TIFFWriteDirectoryTagCheckedIfdArray(tif,ndir,dir,tag,count,p);\n    _TIFFfree(p);\n\n    return(o);\n}\n\n#ifdef notdef\nstatic int\nTIFFWriteDirectoryTagShortLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagShortLongLong8Array\";\n\tuint64* ma;\n\tuint32 mb;\n\tuint8 n;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tn=0;\n\tfor (ma=value, mb=0; mb<count; ma++, mb++)\n\t{\n\t\tif ((n==0)&&(*ma>0xFFFF))\n\t\t\tn=1;\n\t\tif ((n==1)&&(*ma>0xFFFFFFFF))\n\t\t{\n\t\t\tn=2;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (n==0)\n\t{\n\t\tuint16* p;\n\t\tuint16* q;\n\t\tp=_TIFFmalloc(count*sizeof(uint16));\n\t\tif (p==NULL)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\treturn(0);\n\t\t}\n\t\tfor (ma=value, mb=0, q=p; mb<count; ma++, mb++, q++)\n\t\t\t*q=(uint16)(*ma);\n\t\to=TIFFWriteDirectoryTagCheckedShortArray(tif,ndir,dir,tag,count,p);\n\t\t_TIFFfree(p);\n\t}\n\telse if (n==1)\n\t{\n\t\tuint32* p;\n\t\tuint32* q;\n\t\tp=_TIFFmalloc(count*sizeof(uint32));\n\t\tif (p==NULL)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\treturn(0);\n\t\t}\n\t\tfor (ma=value, mb=0, q=p; mb<count; ma++, mb++, q++)\n\t\t\t*q=(uint32)(*ma);\n\t\to=TIFFWriteDirectoryTagCheckedLongArray(tif,ndir,dir,tag,count,p);\n\t\t_TIFFfree(p);\n\t}\n\telse\n\t{\n\t\tassert(n==2);\n\t\to=TIFFWriteDirectoryTagCheckedLong8Array(tif,ndir,dir,tag,count,value);\n\t}\n\treturn(o);\n}\n#endif\nstatic int\nTIFFWriteDirectoryTagColormap(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagColormap\";\n\tuint32 m;\n\tuint16* n;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=(1<<tif->tif_dir.td_bitspersample);\n\tn=_TIFFmalloc(3*m*sizeof(uint16));\n\tif (n==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\t_TIFFmemcpy(&n[0],tif->tif_dir.td_colormap[0],m*sizeof(uint16));\n\t_TIFFmemcpy(&n[m],tif->tif_dir.td_colormap[1],m*sizeof(uint16));\n\t_TIFFmemcpy(&n[2*m],tif->tif_dir.td_colormap[2],m*sizeof(uint16));\n\to=TIFFWriteDirectoryTagCheckedShortArray(tif,ndir,dir,TIFFTAG_COLORMAP,3*m,n);\n\t_TIFFfree(n);\n\treturn(o);\n}\n\nstatic int\nTIFFWriteDirectoryTagTransferfunction(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagTransferfunction\";\n\tuint32 m;\n\tuint16 n;\n\tuint16* o;\n\tint p;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=(1<<tif->tif_dir.td_bitspersample);\n\tn=tif->tif_dir.td_samplesperpixel-tif->tif_dir.td_extrasamples;\n\t/*\n\t * Check if the table can be written as a single column,\n\t * or if it must be written as 3 columns.  Note that we\n\t * write a 3-column tag if there are 2 samples/pixel and\n\t * a single column of data won't suffice--hmm.\n\t */\n\tif (n>3)\n\t\tn=3;\n\tif (n==3)\n\t{\n\t\tif (tif->tif_dir.td_transferfunction[2] == NULL ||\n\t\t    !_TIFFmemcmp(tif->tif_dir.td_transferfunction[0],tif->tif_dir.td_transferfunction[2],m*sizeof(uint16)))\n\t\t\tn=2;\n\t}\n\tif (n==2)\n\t{\n\t\tif (tif->tif_dir.td_transferfunction[1] == NULL ||\n\t\t    !_TIFFmemcmp(tif->tif_dir.td_transferfunction[0],tif->tif_dir.td_transferfunction[1],m*sizeof(uint16)))\n\t\t\tn=1;\n\t}\n\tif (n==0)\n\t\tn=1;\n\to=_TIFFmalloc(n*m*sizeof(uint16));\n\tif (o==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\t_TIFFmemcpy(&o[0],tif->tif_dir.td_transferfunction[0],m*sizeof(uint16));\n\tif (n>1)\n\t\t_TIFFmemcpy(&o[m],tif->tif_dir.td_transferfunction[1],m*sizeof(uint16));\n\tif (n>2)\n\t\t_TIFFmemcpy(&o[2*m],tif->tif_dir.td_transferfunction[2],m*sizeof(uint16));\n\tp=TIFFWriteDirectoryTagCheckedShortArray(tif,ndir,dir,TIFFTAG_TRANSFERFUNCTION,n*m,o);\n\t_TIFFfree(o);\n\treturn(p);\n}\n\nstatic int\nTIFFWriteDirectoryTagSubifd(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagSubifd\";\n\tuint64 m;\n\tint n;\n\tif (tif->tif_dir.td_nsubifd==0)\n\t\treturn(1);\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=tif->tif_dataoff;\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tuint32* o;\n\t\tuint64* pa;\n\t\tuint32* pb;\n\t\tuint16 p;\n\t\to=_TIFFmalloc(tif->tif_dir.td_nsubifd*sizeof(uint32));\n\t\tif (o==NULL)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\treturn(0);\n\t\t}\n\t\tpa=tif->tif_dir.td_subifd;\n\t\tpb=o;\n\t\tfor (p=0; p < tif->tif_dir.td_nsubifd; p++)\n\t\t{\n                        assert(pa != 0);\n\n                        /* Could happen if an classicTIFF has a SubIFD of type LONG8 (which is illegal) */\n                        if( *pa > 0xFFFFFFFFUL)\n                        {\n                            TIFFErrorExt(tif->tif_clientdata,module,\"Illegal value for SubIFD tag\");\n                            _TIFFfree(o);\n                            return(0);\n                        }\n\t\t\t*pb++=(uint32)(*pa++);\n\t\t}\n\t\tn=TIFFWriteDirectoryTagCheckedIfdArray(tif,ndir,dir,TIFFTAG_SUBIFD,tif->tif_dir.td_nsubifd,o);\n\t\t_TIFFfree(o);\n\t}\n\telse\n\t\tn=TIFFWriteDirectoryTagCheckedIfd8Array(tif,ndir,dir,TIFFTAG_SUBIFD,tif->tif_dir.td_nsubifd,tif->tif_dir.td_subifd);\n\tif (!n)\n\t\treturn(0);\n\t/*\n\t * Total hack: if this directory includes a SubIFD\n\t * tag then force the next <n> directories to be\n\t * written as ``sub directories'' of this one.  This\n\t * is used to write things like thumbnails and\n\t * image masks that one wants to keep out of the\n\t * normal directory linkage access mechanism.\n\t */\n\ttif->tif_flags|=TIFF_INSUBIFD;\n\ttif->tif_nsubifd=tif->tif_dir.td_nsubifd;\n\tif (tif->tif_dir.td_nsubifd==1)\n\t\ttif->tif_subifdoff=0;\n\telse\n\t\ttif->tif_subifdoff=m;\n\treturn(1);\n}\n\nstatic int\nTIFFWriteDirectoryTagCheckedAscii(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, char* value)\n{\n\tassert(sizeof(char)==1);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_ASCII,count,count,value));\n}\n\nstatic int\nTIFFWriteDirectoryTagCheckedUndefinedArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value)\n{\n\tassert(sizeof(uint8)==1);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_UNDEFINED,count,count,value));\n}\n\n#ifdef notdef\nstatic int\nTIFFWriteDirectoryTagCheckedByte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint8 value)\n{\n\tassert(sizeof(uint8)==1);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_BYTE,1,1,&value));\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagCheckedByteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value)\n{\n\tassert(sizeof(uint8)==1);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_BYTE,count,count,value));\n}\n\n#ifdef notdef\nstatic int\nTIFFWriteDirectoryTagCheckedSbyte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int8 value)\n{\n\tassert(sizeof(int8)==1);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SBYTE,1,1,&value));\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagCheckedSbyteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int8* value)\n{\n\tassert(sizeof(int8)==1);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SBYTE,count,count,value));\n}\n\nstatic int\nTIFFWriteDirectoryTagCheckedShort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)\n{\n\tuint16 m;\n\tassert(sizeof(uint16)==2);\n\tm=value;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabShort(&m);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SHORT,1,2,&m));\n}\n\nstatic int\nTIFFWriteDirectoryTagCheckedShortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint16* value)\n{\n\tassert(count<0x80000000);\n\tassert(sizeof(uint16)==2);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfShort(value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SHORT,count,count*2,value));\n}\n\n#ifdef notdef\nstatic int\nTIFFWriteDirectoryTagCheckedSshort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int16 value)\n{\n\tint16 m;\n\tassert(sizeof(int16)==2);\n\tm=value;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabShort((uint16*)(&m));\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SSHORT,1,2,&m));\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagCheckedSshortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int16* value)\n{\n\tassert(count<0x80000000);\n\tassert(sizeof(int16)==2);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfShort((uint16*)value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SSHORT,count,count*2,value));\n}\n\nstatic int\nTIFFWriteDirectoryTagCheckedLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)\n{\n\tuint32 m;\n\tassert(sizeof(uint32)==4);\n\tm=value;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong(&m);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_LONG,1,4,&m));\n}\n\nstatic int\nTIFFWriteDirectoryTagCheckedLongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value)\n{\n\tassert(count<0x40000000);\n\tassert(sizeof(uint32)==4);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong(value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_LONG,count,count*4,value));\n}\n\n#ifdef notdef\nstatic int\nTIFFWriteDirectoryTagCheckedSlong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int32 value)\n{\n\tint32 m;\n\tassert(sizeof(int32)==4);\n\tm=value;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong((uint32*)(&m));\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SLONG,1,4,&m));\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagCheckedSlongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int32* value)\n{\n\tassert(count<0x40000000);\n\tassert(sizeof(int32)==4);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong((uint32*)value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SLONG,count,count*4,value));\n}\n\n#ifdef notdef\nstatic int\nTIFFWriteDirectoryTagCheckedLong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint64 value)\n{\n\tuint64 m;\n\tassert(sizeof(uint64)==8);\n\tif( !(tif->tif_flags&TIFF_BIGTIFF) ) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\"TIFFWriteDirectoryTagCheckedLong8\",\"LONG8 not allowed for ClassicTIFF\");\n\t\treturn(0);\n\t}\n\tm=value;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong8(&m);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_LONG8,1,8,&m));\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagCheckedLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)\n{\n\tassert(count<0x20000000);\n\tassert(sizeof(uint64)==8);\n\tif( !(tif->tif_flags&TIFF_BIGTIFF) ) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\"TIFFWriteDirectoryTagCheckedLong8Array\",\"LONG8 not allowed for ClassicTIFF\");\n\t\treturn(0);\n\t}\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong8(value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_LONG8,count,count*8,value));\n}\n\n#ifdef notdef\nstatic int\nTIFFWriteDirectoryTagCheckedSlong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int64 value)\n{\n\tint64 m;\n\tassert(sizeof(int64)==8);\n\tif( !(tif->tif_flags&TIFF_BIGTIFF) ) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\"TIFFWriteDirectoryTagCheckedSlong8\",\"SLONG8 not allowed for ClassicTIFF\");\n\t\treturn(0);\n\t}\n\tm=value;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong8((uint64*)(&m));\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SLONG8,1,8,&m));\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagCheckedSlong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int64* value)\n{\n\tassert(count<0x20000000);\n\tassert(sizeof(int64)==8);\n\tif( !(tif->tif_flags&TIFF_BIGTIFF) ) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\"TIFFWriteDirectoryTagCheckedSlong8Array\",\"SLONG8 not allowed for ClassicTIFF\");\n\t\treturn(0);\n\t}\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong8((uint64*)value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SLONG8,count,count*8,value));\n}\n\nstatic int\nTIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n        static const char module[] = \"TIFFWriteDirectoryTagCheckedRational\";\n\tuint32 m[2];\n\tassert(sizeof(uint32)==4);\n        if( value < 0 )\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\"Negative value is illegal\");\n            return 0;\n        }\n        else if( value != value )\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\"Not-a-number value is illegal\");\n            return 0;\n        }\n\telse if (value==0.0)\n\t{\n\t\tm[0]=0;\n\t\tm[1]=1;\n\t}\n\telse if (value <= 0xFFFFFFFFU && value==(double)(uint32)value)\n\t{\n\t\tm[0]=(uint32)value;\n\t\tm[1]=1;\n\t}\n\telse if (value<1.0)\n\t{\n\t\tm[0]=(uint32)(value*0xFFFFFFFF);\n\t\tm[1]=0xFFFFFFFF;\n\t}\n\telse\n\t{\n\t\tm[0]=0xFFFFFFFF;\n\t\tm[1]=(uint32)(0xFFFFFFFF/value);\n\t}\n\tif (tif->tif_flags&TIFF_SWAB)\n\t{\n\t\tTIFFSwabLong(&m[0]);\n\t\tTIFFSwabLong(&m[1]);\n\t}\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,1,8,&m[0]));\n}\n\nstatic int\nTIFFWriteDirectoryTagCheckedRationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagCheckedRationalArray\";\n\tuint32* m;\n\tfloat* na;\n\tuint32* nb;\n\tuint32 nc;\n\tint o;\n\tassert(sizeof(uint32)==4);\n\tm=_TIFFmalloc(count*2*sizeof(uint32));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=value, nb=m, nc=0; nc<count; na++, nb+=2, nc++)\n\t{\n\t\tif (*na<=0.0 || *na != *na)\n\t\t{\n\t\t\tnb[0]=0;\n\t\t\tnb[1]=1;\n\t\t}\n\t\telse if (*na >= 0 && *na <= (float)0xFFFFFFFFU &&\n                         *na==(float)(uint32)(*na))\n\t\t{\n\t\t\tnb[0]=(uint32)(*na);\n\t\t\tnb[1]=1;\n\t\t}\n\t\telse if (*na<1.0)\n\t\t{\n\t\t\tnb[0]=(uint32)((double)(*na)*0xFFFFFFFF);\n\t\t\tnb[1]=0xFFFFFFFF;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnb[0]=0xFFFFFFFF;\n\t\t\tnb[1]=(uint32)((double)0xFFFFFFFF/(*na));\n\t\t}\n\t}\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong(m,count*2);\n\to=TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,count,count*8,&m[0]);\n\t_TIFFfree(m);\n\treturn(o);\n}\n\nstatic int\nTIFFWriteDirectoryTagCheckedSrationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagCheckedSrationalArray\";\n\tint32* m;\n\tfloat* na;\n\tint32* nb;\n\tuint32 nc;\n\tint o;\n\tassert(sizeof(int32)==4);\n\tm=_TIFFmalloc(count*2*sizeof(int32));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=value, nb=m, nc=0; nc<count; na++, nb+=2, nc++)\n\t{\n\t\tif (*na<0.0)\n\t\t{\n\t\t\tif (*na==(int32)(*na))\n\t\t\t{\n\t\t\t\tnb[0]=(int32)(*na);\n\t\t\t\tnb[1]=1;\n\t\t\t}\n\t\t\telse if (*na>-1.0)\n\t\t\t{\n\t\t\t\tnb[0]=-(int32)((double)(-*na)*0x7FFFFFFF);\n\t\t\t\tnb[1]=0x7FFFFFFF;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnb[0]=-0x7FFFFFFF;\n\t\t\t\tnb[1]=(int32)((double)0x7FFFFFFF/(-*na));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (*na==(int32)(*na))\n\t\t\t{\n\t\t\t\tnb[0]=(int32)(*na);\n\t\t\t\tnb[1]=1;\n\t\t\t}\n\t\t\telse if (*na<1.0)\n\t\t\t{\n\t\t\t\tnb[0]=(int32)((double)(*na)*0x7FFFFFFF);\n\t\t\t\tnb[1]=0x7FFFFFFF;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnb[0]=0x7FFFFFFF;\n\t\t\t\tnb[1]=(int32)((double)0x7FFFFFFF/(*na));\n\t\t\t}\n\t\t}\n\t}\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong((uint32*)m,count*2);\n\to=TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SRATIONAL,count,count*8,&m[0]);\n\t_TIFFfree(m);\n\treturn(o);\n}\n\n#ifdef notdef\nstatic int\nTIFFWriteDirectoryTagCheckedFloat(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, float value)\n{\n\tfloat m;\n\tassert(sizeof(float)==4);\n\tm=value;\n\tTIFFCvtNativeToIEEEFloat(tif,1,&m);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabFloat(&m);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_FLOAT,1,4,&m));\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagCheckedFloatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)\n{\n\tassert(count<0x40000000);\n\tassert(sizeof(float)==4);\n\tTIFFCvtNativeToIEEEFloat(tif,count,&value);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfFloat(value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_FLOAT,count,count*4,value));\n}\n\n#ifdef notdef\nstatic int\nTIFFWriteDirectoryTagCheckedDouble(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n\tdouble m;\n\tassert(sizeof(double)==8);\n\tm=value;\n\tTIFFCvtNativeToIEEEDouble(tif,1,&m);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabDouble(&m);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_DOUBLE,1,8,&m));\n}\n#endif\n\nstatic int\nTIFFWriteDirectoryTagCheckedDoubleArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, double* value)\n{\n\tassert(count<0x20000000);\n\tassert(sizeof(double)==8);\n\tTIFFCvtNativeToIEEEDouble(tif,count,&value);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfDouble(value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_DOUBLE,count,count*8,value));\n}\n\nstatic int\nTIFFWriteDirectoryTagCheckedIfdArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value)\n{\n\tassert(count<0x40000000);\n\tassert(sizeof(uint32)==4);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong(value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_IFD,count,count*4,value));\n}\n\nstatic int\nTIFFWriteDirectoryTagCheckedIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)\n{\n\tassert(count<0x20000000);\n\tassert(sizeof(uint64)==8);\n\tassert(tif->tif_flags&TIFF_BIGTIFF);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong8(value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_IFD8,count,count*8,value));\n}\n\nstatic int\nTIFFWriteDirectoryTagData(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 datatype, uint32 count, uint32 datalength, void* data)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagData\";\n\tuint32 m;\n\tm=0;\n\twhile (m<(*ndir))\n\t{\n\t\tassert(dir[m].tdir_tag!=tag);\n\t\tif (dir[m].tdir_tag>tag)\n\t\t\tbreak;\n\t\tm++;\n\t}\n\tif (m<(*ndir))\n\t{\n\t\tuint32 n;\n\t\tfor (n=*ndir; n>m; n--)\n\t\t\tdir[n]=dir[n-1];\n\t}\n\tdir[m].tdir_tag=tag;\n\tdir[m].tdir_type=datatype;\n\tdir[m].tdir_count=count;\n\tdir[m].tdir_offset.toff_long8 = 0;\n\tif (datalength<=((tif->tif_flags&TIFF_BIGTIFF)?0x8U:0x4U))\n\t\t_TIFFmemcpy(&dir[m].tdir_offset,data,datalength);\n\telse\n\t{\n\t\tuint64 na,nb;\n\t\tna=tif->tif_dataoff;\n\t\tnb=na+datalength;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\tnb=(uint32)nb;\n\t\tif ((nb<na)||(nb<datalength))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\");\n\t\t\treturn(0);\n\t\t}\n\t\tif (!SeekOK(tif,na))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing tag data\");\n\t\t\treturn(0);\n\t\t}\n\t\tassert(datalength<0x80000000UL);\n\t\tif (!WriteOK(tif,data,(tmsize_t)datalength))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing tag data\");\n\t\t\treturn(0);\n\t\t}\n\t\ttif->tif_dataoff=nb;\n\t\tif (tif->tif_dataoff&1)\n\t\t\ttif->tif_dataoff++;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tuint32 o;\n\t\t\to=(uint32)na;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&o);\n\t\t\t_TIFFmemcpy(&dir[m].tdir_offset,&o,4);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdir[m].tdir_offset.toff_long8 = na;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dir[m].tdir_offset.toff_long8);\n\t\t}\n\t}\n\t(*ndir)++;\n\treturn(1);\n}\n\n/*\n * Link the current directory into the directory chain for the file.\n */\nstatic int\nTIFFLinkDirectory(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFLinkDirectory\";\n\n\ttif->tif_diroff = (TIFFSeekFile(tif,0,SEEK_END)+1) & (~((toff_t)1));\n\n\t/*\n\t * Handle SubIFDs\n\t */\n\tif (tif->tif_flags & TIFF_INSUBIFD)\n\t{\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tuint32 m;\n\t\t\tm = (uint32)tif->tif_diroff;\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&m);\n\t\t\t(void) TIFFSeekFile(tif, tif->tif_subifdoff, SEEK_SET);\n\t\t\tif (!WriteOK(tif, &m, 4)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"Error writing SubIFD directory link\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Advance to the next SubIFD or, if this is\n\t\t\t * the last one configured, revert back to the\n\t\t\t * normal directory linkage.\n\t\t\t */\n\t\t\tif (--tif->tif_nsubifd)\n\t\t\t\ttif->tif_subifdoff += 4;\n\t\t\telse\n\t\t\t\ttif->tif_flags &= ~TIFF_INSUBIFD;\n\t\t\treturn (1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 m;\n\t\t\tm = tif->tif_diroff;\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&m);\n\t\t\t(void) TIFFSeekFile(tif, tif->tif_subifdoff, SEEK_SET);\n\t\t\tif (!WriteOK(tif, &m, 8)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"Error writing SubIFD directory link\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Advance to the next SubIFD or, if this is\n\t\t\t * the last one configured, revert back to the\n\t\t\t * normal directory linkage.\n\t\t\t */\n\t\t\tif (--tif->tif_nsubifd)\n\t\t\t\ttif->tif_subifdoff += 8;\n\t\t\telse\n\t\t\t\ttif->tif_flags &= ~TIFF_INSUBIFD;\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tuint32 m;\n\t\tuint32 nextdir;\n\t\tm = (uint32)(tif->tif_diroff);\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong(&m);\n\t\tif (tif->tif_header.classic.tiff_diroff == 0) {\n\t\t\t/*\n\t\t\t * First directory, overwrite offset in header.\n\t\t\t */\n\t\t\ttif->tif_header.classic.tiff_diroff = (uint32) tif->tif_diroff;\n\t\t\t(void) TIFFSeekFile(tif,4, SEEK_SET);\n\t\t\tif (!WriteOK(tif, &m, 4)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t\t     \"Error writing TIFF header\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\treturn (1);\n\t\t}\n\t\t/*\n\t\t * Not the first directory, search to the last and append.\n\t\t */\n\t\tnextdir = tif->tif_header.classic.tiff_diroff;\n\t\twhile(1) {\n\t\t\tuint16 dircount;\n\t\t\tuint32 nextnextdir;\n\n\t\t\tif (!SeekOK(tif, nextdir) ||\n\t\t\t    !ReadOK(tif, &dircount, 2)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory count\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount);\n\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t    nextdir+2+dircount*12, SEEK_SET);\n\t\t\tif (!ReadOK(tif, &nextnextdir, 4)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory link\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&nextnextdir);\n\t\t\tif (nextnextdir==0)\n\t\t\t{\n\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t    nextdir+2+dircount*12, SEEK_SET);\n\t\t\t\tif (!WriteOK(tif, &m, 4)) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error writing directory link\");\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextdir=nextnextdir;\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint64 m;\n\t\tuint64 nextdir;\n\t\tm = tif->tif_diroff;\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong8(&m);\n\t\tif (tif->tif_header.big.tiff_diroff == 0) {\n\t\t\t/*\n\t\t\t * First directory, overwrite offset in header.\n\t\t\t */\n\t\t\ttif->tif_header.big.tiff_diroff = tif->tif_diroff;\n\t\t\t(void) TIFFSeekFile(tif,8, SEEK_SET);\n\t\t\tif (!WriteOK(tif, &m, 8)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t\t     \"Error writing TIFF header\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\treturn (1);\n\t\t}\n\t\t/*\n\t\t * Not the first directory, search to the last and append.\n\t\t */\n\t\tnextdir = tif->tif_header.big.tiff_diroff;\n\t\twhile(1) {\n\t\t\tuint64 dircount64;\n\t\t\tuint16 dircount;\n\t\t\tuint64 nextnextdir;\n\n\t\t\tif (!SeekOK(tif, nextdir) ||\n\t\t\t    !ReadOK(tif, &dircount64, 8)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory count\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>0xFFFF)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Sanity check on tag count failed, likely corrupt TIFF\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdircount=(uint16)dircount64;\n\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t    nextdir+8+dircount*20, SEEK_SET);\n\t\t\tif (!ReadOK(tif, &nextnextdir, 8)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory link\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&nextnextdir);\n\t\t\tif (nextnextdir==0)\n\t\t\t{\n\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t    nextdir+8+dircount*20, SEEK_SET);\n\t\t\t\tif (!WriteOK(tif, &m, 8)) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error writing directory link\");\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextdir=nextnextdir;\n\t\t}\n\t}\n\treturn (1);\n}\n\n/************************************************************************/\n/*                          TIFFRewriteField()                          */\n/*                                                                      */\n/*      Rewrite a field in the directory on disk without regard to      */\n/*      updating the TIFF directory structure in memory.  Currently     */\n/*      only supported for field that already exist in the on-disk      */\n/*      directory.  Mainly used for updating stripoffset /              */\n/*      stripbytecount values after the directory is already on         */\n/*      disk.                                                           */\n/*                                                                      */\n/*      Returns zero on failure, and one on success.                    */\n/************************************************************************/\n\nint\n_TIFFRewriteField(TIFF* tif, uint16 tag, TIFFDataType in_datatype, \n                  tmsize_t count, void* data)\n{\n    static const char module[] = \"TIFFResetField\";\n    /* const TIFFField* fip = NULL; */\n    uint16 dircount;\n    tmsize_t dirsize;\n    uint8 direntry_raw[20];\n    uint16 entry_tag = 0;\n    uint16 entry_type = 0;\n    uint64 entry_count = 0;\n    uint64 entry_offset = 0;\n    int    value_in_entry = 0;\n    uint64 read_offset;\n    uint8 *buf_to_write = NULL;\n    TIFFDataType datatype;\n\n/* -------------------------------------------------------------------- */\n/*      Find field definition.                                          */\n/* -------------------------------------------------------------------- */\n    /*fip =*/ TIFFFindField(tif, tag, TIFF_ANY);\n\n/* -------------------------------------------------------------------- */\n/*      Do some checking this is a straight forward case.               */\n/* -------------------------------------------------------------------- */\n    if( isMapped(tif) )\n    {\n        TIFFErrorExt( tif->tif_clientdata, module, \n                      \"Memory mapped files not currently supported for this operation.\" );\n        return 0;\n    }\n\n    if( tif->tif_diroff == 0 )\n    {\n        TIFFErrorExt( tif->tif_clientdata, module, \n                      \"Attempt to reset field on directory not already on disk.\" );\n        return 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read the directory entry count.                                 */\n/* -------------------------------------------------------------------- */\n    if (!SeekOK(tif, tif->tif_diroff)) {\n        TIFFErrorExt(tif->tif_clientdata, module,\n                     \"%s: Seek error accessing TIFF directory\",\n                     tif->tif_name);\n        return 0;\n    }\n\n    read_offset = tif->tif_diroff;\n\n    if (!(tif->tif_flags&TIFF_BIGTIFF))\n    {\n        if (!ReadOK(tif, &dircount, sizeof (uint16))) {\n            TIFFErrorExt(tif->tif_clientdata, module,\n                         \"%s: Can not read TIFF directory count\",\n                         tif->tif_name);\n            return 0;\n        }\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabShort(&dircount);\n        dirsize = 12;\n        read_offset += 2;\n    } else {\n        uint64 dircount64;\n        if (!ReadOK(tif, &dircount64, sizeof (uint64))) {\n            TIFFErrorExt(tif->tif_clientdata, module,\n                         \"%s: Can not read TIFF directory count\",\n                         tif->tif_name);\n            return 0;\n        }\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabLong8(&dircount64);\n        dircount = (uint16)dircount64;\n        dirsize = 20;\n        read_offset += 8;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read through directory to find target tag.                      */\n/* -------------------------------------------------------------------- */\n    while( dircount > 0 )\n    {\n        if (!ReadOK(tif, direntry_raw, dirsize)) {\n            TIFFErrorExt(tif->tif_clientdata, module,\n                         \"%s: Can not read TIFF directory entry.\",\n                         tif->tif_name);\n            return 0;\n        }\n\n        memcpy( &entry_tag, direntry_raw + 0, sizeof(uint16) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabShort( &entry_tag );\n\n        if( entry_tag == tag )\n            break;\n\n        read_offset += dirsize;\n    }\n\n    if( entry_tag != tag )\n    {\n        TIFFErrorExt(tif->tif_clientdata, module,\n                     \"%s: Could not find tag %d.\",\n                     tif->tif_name, tag );\n        return 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Extract the type, count and offset for this entry.              */\n/* -------------------------------------------------------------------- */\n    memcpy( &entry_type, direntry_raw + 2, sizeof(uint16) );\n    if (tif->tif_flags&TIFF_SWAB)\n        TIFFSwabShort( &entry_type );\n\n    if (!(tif->tif_flags&TIFF_BIGTIFF))\n    {\n        uint32 value;\n        \n        memcpy( &value, direntry_raw + 4, sizeof(uint32) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabLong( &value );\n        entry_count = value;\n\n        memcpy( &value, direntry_raw + 8, sizeof(uint32) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabLong( &value );\n        entry_offset = value;\n    }\n    else\n    {\n        memcpy( &entry_count, direntry_raw + 4, sizeof(uint64) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabLong8( &entry_count );\n\n        memcpy( &entry_offset, direntry_raw + 12, sizeof(uint64) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabLong8( &entry_offset );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      What data type do we want to write this as?                     */\n/* -------------------------------------------------------------------- */\n    if( TIFFDataWidth(in_datatype) == 8 && !(tif->tif_flags&TIFF_BIGTIFF) )\n    {\n        if( in_datatype == TIFF_LONG8 )\n            datatype = TIFF_LONG;\n        else if( in_datatype == TIFF_SLONG8 )\n            datatype = TIFF_SLONG;\n        else if( in_datatype == TIFF_IFD8 )\n            datatype = TIFF_IFD;\n        else\n            datatype = in_datatype;\n    }\n    else \n        datatype = in_datatype;\n\n/* -------------------------------------------------------------------- */\n/*      Prepare buffer of actual data to write.  This includes          */\n/*      swabbing as needed.                                             */\n/* -------------------------------------------------------------------- */\n    buf_to_write =\n\t    (uint8 *)_TIFFCheckMalloc(tif, count, TIFFDataWidth(datatype),\n\t\t\t\t      \"for field buffer.\");\n    if (!buf_to_write)\n        return 0;\n\n    if( datatype == in_datatype )\n        memcpy( buf_to_write, data, count * TIFFDataWidth(datatype) );\n    else if( datatype == TIFF_SLONG && in_datatype == TIFF_SLONG8 )\n    {\n\ttmsize_t i;\n\n        for( i = 0; i < count; i++ )\n        {\n            ((int32 *) buf_to_write)[i] = \n                (int32) ((int64 *) data)[i];\n            if( (int64) ((int32 *) buf_to_write)[i] != ((int64 *) data)[i] )\n            {\n                _TIFFfree( buf_to_write );\n                TIFFErrorExt( tif->tif_clientdata, module, \n                              \"Value exceeds 32bit range of output type.\" );\n                return 0;\n            }\n        }\n    }\n    else if( (datatype == TIFF_LONG && in_datatype == TIFF_LONG8)\n             || (datatype == TIFF_IFD && in_datatype == TIFF_IFD8) )\n    {\n\ttmsize_t i;\n\n        for( i = 0; i < count; i++ )\n        {\n            ((uint32 *) buf_to_write)[i] = \n                (uint32) ((uint64 *) data)[i];\n            if( (uint64) ((uint32 *) buf_to_write)[i] != ((uint64 *) data)[i] )\n            {\n                _TIFFfree( buf_to_write );\n                TIFFErrorExt( tif->tif_clientdata, module, \n                              \"Value exceeds 32bit range of output type.\" );\n                return 0;\n            }\n        }\n    }\n\n    if( TIFFDataWidth(datatype) > 1 && (tif->tif_flags&TIFF_SWAB) )\n    {\n        if( TIFFDataWidth(datatype) == 2 )\n            TIFFSwabArrayOfShort( (uint16 *) buf_to_write, count );\n        else if( TIFFDataWidth(datatype) == 4 )\n            TIFFSwabArrayOfLong( (uint32 *) buf_to_write, count );\n        else if( TIFFDataWidth(datatype) == 8 )\n            TIFFSwabArrayOfLong8( (uint64 *) buf_to_write, count );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Is this a value that fits into the directory entry?             */\n/* -------------------------------------------------------------------- */\n    if (!(tif->tif_flags&TIFF_BIGTIFF))\n    {\n        if( TIFFDataWidth(datatype) * count <= 4 )\n        {\n            entry_offset = read_offset + 8;\n            value_in_entry = 1;\n        }\n    }\n    else\n    {\n        if( TIFFDataWidth(datatype) * count <= 8 )\n        {\n            entry_offset = read_offset + 12;\n            value_in_entry = 1;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the tag type, and count match, then we just write it out     */\n/*      over the old values without altering the directory entry at     */\n/*      all.                                                            */\n/* -------------------------------------------------------------------- */\n    if( entry_count == (uint64)count && entry_type == (uint16) datatype )\n    {\n        if (!SeekOK(tif, entry_offset)) {\n            _TIFFfree( buf_to_write );\n            TIFFErrorExt(tif->tif_clientdata, module,\n                         \"%s: Seek error accessing TIFF directory\",\n                         tif->tif_name);\n            return 0;\n        }\n        if (!WriteOK(tif, buf_to_write, count*TIFFDataWidth(datatype))) {\n            _TIFFfree( buf_to_write );\n            TIFFErrorExt(tif->tif_clientdata, module,\n                         \"Error writing directory link\");\n            return (0);\n        }\n\n        _TIFFfree( buf_to_write );\n        return 1;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise, we write the new tag data at the end of the file.    */\n/* -------------------------------------------------------------------- */\n    if( !value_in_entry )\n    {\n        entry_offset = TIFFSeekFile(tif,0,SEEK_END);\n        \n        if (!WriteOK(tif, buf_to_write, count*TIFFDataWidth(datatype))) {\n            _TIFFfree( buf_to_write );\n            TIFFErrorExt(tif->tif_clientdata, module,\n                         \"Error writing directory link\");\n            return (0);\n        }\n    }\n    else\n    {\n        memcpy( &entry_offset, buf_to_write, count*TIFFDataWidth(datatype));\n    }\n\n    _TIFFfree( buf_to_write );\n    buf_to_write = 0;\n\n/* -------------------------------------------------------------------- */\n/*      Adjust the directory entry.                                     */\n/* -------------------------------------------------------------------- */\n    entry_type = datatype;\n    memcpy( direntry_raw + 2, &entry_type, sizeof(uint16) );\n    if (tif->tif_flags&TIFF_SWAB)\n        TIFFSwabShort( (uint16 *) (direntry_raw + 2) );\n\n    if (!(tif->tif_flags&TIFF_BIGTIFF))\n    {\n        uint32 value;\n\n        value = (uint32) entry_count;\n        memcpy( direntry_raw + 4, &value, sizeof(uint32) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabLong( (uint32 *) (direntry_raw + 4) );\n\n        value = (uint32) entry_offset;\n        memcpy( direntry_raw + 8, &value, sizeof(uint32) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabLong( (uint32 *) (direntry_raw + 8) );\n    }\n    else\n    {\n        memcpy( direntry_raw + 4, &entry_count, sizeof(uint64) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabLong8( (uint64 *) (direntry_raw + 4) );\n\n        memcpy( direntry_raw + 12, &entry_offset, sizeof(uint64) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabLong8( (uint64 *) (direntry_raw + 12) );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write the directory entry out to disk.                          */\n/* -------------------------------------------------------------------- */\n    if (!SeekOK(tif, read_offset )) {\n        TIFFErrorExt(tif->tif_clientdata, module,\n                     \"%s: Seek error accessing TIFF directory\",\n                     tif->tif_name);\n        return 0;\n    }\n\n    if (!WriteOK(tif, direntry_raw,dirsize))\n    {\n        TIFFErrorExt(tif->tif_clientdata, module,\n                     \"%s: Can not write TIFF directory entry.\",\n                     tif->tif_name);\n        return 0;\n    }\n    \n    return 1;\n}\n/* vim: set ts=8 sts=8 sw=8 noet: */\n/*\n * Local Variables:\n * mode: c\n * c-basic-offset: 8\n * fill-column: 78\n * End:\n */",
          "fn_code_pos": [
            [
              359,
              0
            ],
            [
              3016,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectorySec",
            "parameters": {
              "tif": "TIFF",
              "isimage": "int",
              "imagedone": "int",
              "pdiroff": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int32 TIFFClampDoubleToInt32( double val )\n{\n    if( val > 0x7FFFFFFF )\n        return 0x7FFFFFFF;\n    if( val < -0x7FFFFFFF-1 || val != val )\n        return -0x7FFFFFFF-1;\n    return (int32)val;\n}",
          "fn_code_pos": [
            [
              965,
              0
            ],
            [
              972,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFClampDoubleToInt32",
            "parameters": {
              "val": "double"
            },
            "return_type": "int32"
          }
        },
        {
          "fn_code": "static uint8 TIFFClampDoubleToUInt8( double val )\n{\n    if( val < 0 )\n        return 0;\n    if( val > 255 || val != val )\n        return 255;\n    return (uint8)val;\n}",
          "fn_code_pos": [
            [
              974,
              0
            ],
            [
              981,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFClampDoubleToUInt8",
            "parameters": {
              "val": "double"
            },
            "return_type": "uint8"
          }
        },
        {
          "fn_code": "static uint16 TIFFClampDoubleToUInt16( double val )\n{\n    if( val < 0 )\n        return 0;\n    if( val > 65535 || val != val )\n        return 65535;\n    return (uint16)val;\n}",
          "fn_code_pos": [
            [
              983,
              0
            ],
            [
              990,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFClampDoubleToUInt16",
            "parameters": {
              "val": "double"
            },
            "return_type": "uint16"
          }
        },
        {
          "fn_code": "static uint32 TIFFClampDoubleToUInt32( double val )\n{\n    if( val < 0 )\n        return 0;\n    if( val > 0xFFFFFFFFU || val != val )\n        return 0xFFFFFFFFU;\n    return (uint32)val;\n}",
          "fn_code_pos": [
            [
              992,
              0
            ],
            [
              999,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFClampDoubleToUInt32",
            "parameters": {
              "val": "double"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, double* value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagSampleformatArray\";\n\tvoid* conv;\n\tuint32 i;\n\tint ok;\n\tconv = _TIFFmalloc(count*sizeof(double));\n\tif (conv == NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Out of memory\");\n\t\treturn (0);\n\t}\n\n\tswitch (tif->tif_dir.td_sampleformat)\n\t{\n\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\tif (tif->tif_dir.td_bitspersample<=32)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((float*)conv)[i] = _TIFFClampDoubleToFloat(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagFloatArray(tif,ndir,dir,tag,count,(float*)conv);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tok = TIFFWriteDirectoryTagDoubleArray(tif,ndir,dir,tag,count,value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_INT:\n\t\t\tif (tif->tif_dir.td_bitspersample<=8)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((int8*)conv)[i] = TIFFClampDoubleToInt8(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagSbyteArray(tif,ndir,dir,tag,count,(int8*)conv);\n\t\t\t}\n\t\t\telse if (tif->tif_dir.td_bitspersample<=16)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((int16*)conv)[i] = TIFFClampDoubleToInt16(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16*)conv);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((int32*)conv)[i] = TIFFClampDoubleToInt32(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagSlongArray(tif,ndir,dir,tag,count,(int32*)conv);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_UINT:\n\t\t\tif (tif->tif_dir.td_bitspersample<=8)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((uint8*)conv)[i] = TIFFClampDoubleToUInt8(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagByteArray(tif,ndir,dir,tag,count,(uint8*)conv);\n\t\t\t}\n\t\t\telse if (tif->tif_dir.td_bitspersample<=16)\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((uint16*)conv)[i] = TIFFClampDoubleToUInt16(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagShortArray(tif,ndir,dir,tag,count,(uint16*)conv);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\t\t((uint32*)conv)[i] = TIFFClampDoubleToUInt32(value[i]);\n\t\t\t\tok = TIFFWriteDirectoryTagLongArray(tif,ndir,dir,tag,count,(uint32*)conv);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tok = 0;\n\t}\n\n\t_TIFFfree(conv);\n\treturn (ok);\n}",
          "fn_code_pos": [
            [
              1001,
              0
            ],
            [
              1075,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSampleformatArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagSampleformatPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n\tswitch (tif->tif_dir.td_sampleformat)\n\t{\n\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\tif (tif->tif_dir.td_bitspersample<=32)\n\t\t\t\treturn(TIFFWriteDirectoryTagFloatPerSample(tif,ndir,dir,tag,(float)value));\n\t\t\telse\n\t\t\t\treturn(TIFFWriteDirectoryTagDoublePerSample(tif,ndir,dir,tag,value));\n\t\tcase SAMPLEFORMAT_INT:\n\t\t\tif (tif->tif_dir.td_bitspersample<=8)\n\t\t\t\treturn(TIFFWriteDirectoryTagSbytePerSample(tif,ndir,dir,tag,(int8)value));\n\t\t\telse if (tif->tif_dir.td_bitspersample<=16)\n\t\t\t\treturn(TIFFWriteDirectoryTagSshortPerSample(tif,ndir,dir,tag,(int16)value));\n\t\t\telse\n\t\t\t\treturn(TIFFWriteDirectoryTagSlongPerSample(tif,ndir,dir,tag,(int32)value));\n\t\tcase SAMPLEFORMAT_UINT:\n\t\t\tif (tif->tif_dir.td_bitspersample<=8)\n\t\t\t\treturn(TIFFWriteDirectoryTagBytePerSample(tif,ndir,dir,tag,(uint8)value));\n\t\t\telse if (tif->tif_dir.td_bitspersample<=16)\n\t\t\t\treturn(TIFFWriteDirectoryTagShortPerSample(tif,ndir,dir,tag,(uint16)value));\n\t\t\telse\n\t\t\t\treturn(TIFFWriteDirectoryTagLongPerSample(tif,ndir,dir,tag,(uint32)value));\n\t\tdefault:\n\t\t\treturn(1);\n\t}\n}",
          "fn_code_pos": [
            [
              1078,
              0
            ],
            [
              1105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSampleformatPerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagAscii(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, char* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedAscii(tif,ndir,dir,tag,count,value));\n}",
          "fn_code_pos": [
            [
              1108,
              0
            ],
            [
              1117,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagAscii",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagUndefinedArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedUndefinedArray(tif,ndir,dir,tag,count,value));\n}",
          "fn_code_pos": [
            [
              1119,
              0
            ],
            [
              1128,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagUndefinedArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagByte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint8 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedByte(tif,ndir,dir,tag,value));\n}",
          "fn_code_pos": [
            [
              1131,
              0
            ],
            [
              1140,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagByte",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagByteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedByteArray(tif,ndir,dir,tag,count,value));\n}",
          "fn_code_pos": [
            [
              1143,
              0
            ],
            [
              1152,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagByteArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagBytePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint8 value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagBytePerSample\";\n\tuint8* m;\n\tuint8* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(uint8));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedByteArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}",
          "fn_code_pos": [
            [
              1155,
              0
            ],
            [
              1179,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagBytePerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagSbyte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int8 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSbyte(tif,ndir,dir,tag,value));\n}",
          "fn_code_pos": [
            [
              1183,
              0
            ],
            [
              1192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSbyte",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagSbyteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int8* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSbyteArray(tif,ndir,dir,tag,count,value));\n}",
          "fn_code_pos": [
            [
              1195,
              0
            ],
            [
              1204,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSbyteArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "int8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagSbytePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int8 value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagSbytePerSample\";\n\tint8* m;\n\tint8* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(int8));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedSbyteArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}",
          "fn_code_pos": [
            [
              1207,
              0
            ],
            [
              1231,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSbytePerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagShort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedShort(tif,ndir,dir,tag,value));\n}",
          "fn_code_pos": [
            [
              1234,
              0
            ],
            [
              1243,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagShort",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagShortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint16* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedShortArray(tif,ndir,dir,tag,count,value));\n}",
          "fn_code_pos": [
            [
              1245,
              0
            ],
            [
              1254,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagShortArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagShortPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagShortPerSample\";\n\tuint16* m;\n\tuint16* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(uint16));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedShortArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}",
          "fn_code_pos": [
            [
              1256,
              0
            ],
            [
              1280,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagShortPerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagSshort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int16 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSshort(tif,ndir,dir,tag,value));\n}",
          "fn_code_pos": [
            [
              1283,
              0
            ],
            [
              1292,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSshort",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagSshortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int16* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSshortArray(tif,ndir,dir,tag,count,value));\n}",
          "fn_code_pos": [
            [
              1295,
              0
            ],
            [
              1304,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSshortArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "int16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagSshortPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int16 value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagSshortPerSample\";\n\tint16* m;\n\tint16* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(int16));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedSshortArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}",
          "fn_code_pos": [
            [
              1307,
              0
            ],
            [
              1331,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSshortPerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedLong(tif,ndir,dir,tag,value));\n}",
          "fn_code_pos": [
            [
              1334,
              0
            ],
            [
              1343,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagLong",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagLongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedLongArray(tif,ndir,dir,tag,count,value));\n}",
          "fn_code_pos": [
            [
              1345,
              0
            ],
            [
              1354,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagLongArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagLongPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagLongPerSample\";\n\tuint32* m;\n\tuint32* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(uint32));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedLongArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}",
          "fn_code_pos": [
            [
              1357,
              0
            ],
            [
              1381,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagLongPerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagSlong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int32 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSlong(tif,ndir,dir,tag,value));\n}",
          "fn_code_pos": [
            [
              1385,
              0
            ],
            [
              1394,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSlong",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagSlongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int32* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSlongArray(tif,ndir,dir,tag,count,value));\n}",
          "fn_code_pos": [
            [
              1397,
              0
            ],
            [
              1406,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSlongArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "int32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagSlongPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int32 value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagSlongPerSample\";\n\tint32* m;\n\tint32* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(int32));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedSlongArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}",
          "fn_code_pos": [
            [
              1409,
              0
            ],
            [
              1433,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSlongPerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagLong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint64 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedLong8(tif,ndir,dir,tag,value));\n}",
          "fn_code_pos": [
            [
              1437,
              0
            ],
            [
              1446,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagLong8",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedLong8Array(tif,ndir,dir,tag,count,value));\n}",
          "fn_code_pos": [
            [
              1449,
              0
            ],
            [
              1458,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagLong8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagSlong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int64 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSlong8(tif,ndir,dir,tag,value));\n}",
          "fn_code_pos": [
            [
              1461,
              0
            ],
            [
              1470,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSlong8",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagSlong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int64* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSlong8Array(tif,ndir,dir,tag,count,value));\n}",
          "fn_code_pos": [
            [
              1473,
              0
            ],
            [
              1482,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSlong8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "int64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedRational(tif,ndir,dir,tag,value));\n}",
          "fn_code_pos": [
            [
              1484,
              0
            ],
            [
              1493,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagRational",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagRationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedRationalArray(tif,ndir,dir,tag,count,value));\n}",
          "fn_code_pos": [
            [
              1495,
              0
            ],
            [
              1504,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagRationalArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagSrationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedSrationalArray(tif,ndir,dir,tag,count,value));\n}",
          "fn_code_pos": [
            [
              1506,
              0
            ],
            [
              1515,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSrationalArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int TIFFWriteDirectoryTagFloat(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, float value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedFloat(tif,ndir,dir,tag,value));\n}",
          "fn_code_pos": [
            [
              1518,
              0
            ],
            [
              1526,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagFloat",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int TIFFWriteDirectoryTagFloatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedFloatArray(tif,ndir,dir,tag,count,value));\n}",
          "fn_code_pos": [
            [
              1529,
              0
            ],
            [
              1537,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagFloatArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int TIFFWriteDirectoryTagFloatPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, float value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagFloatPerSample\";\n\tfloat* m;\n\tfloat* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(float));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedFloatArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}",
          "fn_code_pos": [
            [
              1540,
              0
            ],
            [
              1563,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagFloatPerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int TIFFWriteDirectoryTagDouble(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedDouble(tif,ndir,dir,tag,value));\n}",
          "fn_code_pos": [
            [
              1567,
              0
            ],
            [
              1575,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagDouble",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int TIFFWriteDirectoryTagDoubleArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, double* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedDoubleArray(tif,ndir,dir,tag,count,value));\n}",
          "fn_code_pos": [
            [
              1578,
              0
            ],
            [
              1586,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagDoubleArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int TIFFWriteDirectoryTagDoublePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagDoublePerSample\";\n\tdouble* m;\n\tdouble* na;\n\tuint16 nb;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=_TIFFmalloc(tif->tif_dir.td_samplesperpixel*sizeof(double));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=m, nb=0; nb<tif->tif_dir.td_samplesperpixel; na++, nb++)\n\t\t*na=value;\n\to=TIFFWriteDirectoryTagCheckedDoubleArray(tif,ndir,dir,tag,tif->tif_dir.td_samplesperpixel,m);\n\t_TIFFfree(m);\n\treturn(o);\n}",
          "fn_code_pos": [
            [
              1589,
              0
            ],
            [
              1612,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagDoublePerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagIfdArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedIfdArray(tif,ndir,dir,tag,count,value));\n}",
          "fn_code_pos": [
            [
              1615,
              0
            ],
            [
              1624,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagIfdArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\treturn(TIFFWriteDirectoryTagCheckedIfd8Array(tif,ndir,dir,tag,count,value));\n}",
          "fn_code_pos": [
            [
              1627,
              0
            ],
            [
              1636,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagIfd8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagShortLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)\n{\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tif (value<=0xFFFF)\n\t\treturn(TIFFWriteDirectoryTagCheckedShort(tif,ndir,dir,tag,(uint16)value));\n\telse\n\t\treturn(TIFFWriteDirectoryTagCheckedLong(tif,ndir,dir,tag,value));\n}",
          "fn_code_pos": [
            [
              1639,
              0
            ],
            [
              1651,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagShortLong",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)\n{\n    static const char module[] = \"TIFFWriteDirectoryTagLongLong8Array\";\n    uint64* ma;\n    uint32 mb;\n    uint32* p;\n    uint32* q;\n    int o;\n\n    /* is this just a counting pass? */\n    if (dir==NULL)\n    {\n        (*ndir)++;\n        return(1);\n    }\n\n    /* We always write LONG8 for BigTIFF, no checking needed. */\n    if( tif->tif_flags&TIFF_BIGTIFF )\n        return TIFFWriteDirectoryTagCheckedLong8Array(tif,ndir,dir,\n                                                      tag,count,value);\n\n    /*\n    ** For classic tiff we want to verify everything is in range for LONG\n    ** and convert to long format.\n    */\n\n    p = _TIFFmalloc(count*sizeof(uint32));\n    if (p==NULL)\n    {\n        TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n        return(0);\n    }\n\n    for (q=p, ma=value, mb=0; mb<count; ma++, mb++, q++)\n    {\n        if (*ma>0xFFFFFFFF)\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\n                         \"Attempt to write value larger than 0xFFFFFFFF in Classic TIFF file.\");\n            _TIFFfree(p);\n            return(0);\n        }\n        *q= (uint32)(*ma);\n    }\n\n    o=TIFFWriteDirectoryTagCheckedLongArray(tif,ndir,dir,tag,count,p);\n    _TIFFfree(p);\n\n    return(o);\n}",
          "fn_code_pos": [
            [
              1660,
              0
            ],
            [
              1710,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagLongLong8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagIfdIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)\n{\n    static const char module[] = \"TIFFWriteDirectoryTagIfdIfd8Array\";\n    uint64* ma;\n    uint32 mb;\n    uint32* p;\n    uint32* q;\n    int o;\n\n    /* is this just a counting pass? */\n    if (dir==NULL)\n    {\n        (*ndir)++;\n        return(1);\n    }\n\n    /* We always write IFD8 for BigTIFF, no checking needed. */\n    if( tif->tif_flags&TIFF_BIGTIFF )\n        return TIFFWriteDirectoryTagCheckedIfd8Array(tif,ndir,dir,\n                                                     tag,count,value);\n\n    /*\n    ** For classic tiff we want to verify everything is in range for IFD\n    ** and convert to long format.\n    */\n\n    p = _TIFFmalloc(count*sizeof(uint32));\n    if (p==NULL)\n    {\n        TIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n        return(0);\n    }\n\n    for (q=p, ma=value, mb=0; mb<count; ma++, mb++, q++)\n    {\n        if (*ma>0xFFFFFFFF)\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\n                         \"Attempt to write value larger than 0xFFFFFFFF in Classic TIFF file.\");\n            _TIFFfree(p);\n            return(0);\n        }\n        *q= (uint32)(*ma);\n    }\n\n    o=TIFFWriteDirectoryTagCheckedIfdArray(tif,ndir,dir,tag,count,p);\n    _TIFFfree(p);\n\n    return(o);\n}",
          "fn_code_pos": [
            [
              1718,
              0
            ],
            [
              1768,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagIfdIfd8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagShortLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagShortLongLong8Array\";\n\tuint64* ma;\n\tuint32 mb;\n\tuint8 n;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tn=0;\n\tfor (ma=value, mb=0; mb<count; ma++, mb++)\n\t{\n\t\tif ((n==0)&&(*ma>0xFFFF))\n\t\t\tn=1;\n\t\tif ((n==1)&&(*ma>0xFFFFFFFF))\n\t\t{\n\t\t\tn=2;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (n==0)\n\t{\n\t\tuint16* p;\n\t\tuint16* q;\n\t\tp=_TIFFmalloc(count*sizeof(uint16));\n\t\tif (p==NULL)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\treturn(0);\n\t\t}\n\t\tfor (ma=value, mb=0, q=p; mb<count; ma++, mb++, q++)\n\t\t\t*q=(uint16)(*ma);\n\t\to=TIFFWriteDirectoryTagCheckedShortArray(tif,ndir,dir,tag,count,p);\n\t\t_TIFFfree(p);\n\t}\n\telse if (n==1)\n\t{\n\t\tuint32* p;\n\t\tuint32* q;\n\t\tp=_TIFFmalloc(count*sizeof(uint32));\n\t\tif (p==NULL)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\treturn(0);\n\t\t}\n\t\tfor (ma=value, mb=0, q=p; mb<count; ma++, mb++, q++)\n\t\t\t*q=(uint32)(*ma);\n\t\to=TIFFWriteDirectoryTagCheckedLongArray(tif,ndir,dir,tag,count,p);\n\t\t_TIFFfree(p);\n\t}\n\telse\n\t{\n\t\tassert(n==2);\n\t\to=TIFFWriteDirectoryTagCheckedLong8Array(tif,ndir,dir,tag,count,value);\n\t}\n\treturn(o);\n}",
          "fn_code_pos": [
            [
              1771,
              0
            ],
            [
              1831,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagShortLongLong8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagColormap(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagColormap\";\n\tuint32 m;\n\tuint16* n;\n\tint o;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=(1<<tif->tif_dir.td_bitspersample);\n\tn=_TIFFmalloc(3*m*sizeof(uint16));\n\tif (n==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\t_TIFFmemcpy(&n[0],tif->tif_dir.td_colormap[0],m*sizeof(uint16));\n\t_TIFFmemcpy(&n[m],tif->tif_dir.td_colormap[1],m*sizeof(uint16));\n\t_TIFFmemcpy(&n[2*m],tif->tif_dir.td_colormap[2],m*sizeof(uint16));\n\to=TIFFWriteDirectoryTagCheckedShortArray(tif,ndir,dir,TIFFTAG_COLORMAP,3*m,n);\n\t_TIFFfree(n);\n\treturn(o);\n}",
          "fn_code_pos": [
            [
              1833,
              0
            ],
            [
              1858,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagColormap",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagTransferfunction(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagTransferfunction\";\n\tuint32 m;\n\tuint16 n;\n\tuint16* o;\n\tint p;\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=(1<<tif->tif_dir.td_bitspersample);\n\tn=tif->tif_dir.td_samplesperpixel-tif->tif_dir.td_extrasamples;\n\t/*\n\t * Check if the table can be written as a single column,\n\t * or if it must be written as 3 columns.  Note that we\n\t * write a 3-column tag if there are 2 samples/pixel and\n\t * a single column of data won't suffice--hmm.\n\t */\n\tif (n>3)\n\t\tn=3;\n\tif (n==3)\n\t{\n\t\tif (tif->tif_dir.td_transferfunction[2] == NULL ||\n\t\t    !_TIFFmemcmp(tif->tif_dir.td_transferfunction[0],tif->tif_dir.td_transferfunction[2],m*sizeof(uint16)))\n\t\t\tn=2;\n\t}\n\tif (n==2)\n\t{\n\t\tif (tif->tif_dir.td_transferfunction[1] == NULL ||\n\t\t    !_TIFFmemcmp(tif->tif_dir.td_transferfunction[0],tif->tif_dir.td_transferfunction[1],m*sizeof(uint16)))\n\t\t\tn=1;\n\t}\n\tif (n==0)\n\t\tn=1;\n\to=_TIFFmalloc(n*m*sizeof(uint16));\n\tif (o==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\t_TIFFmemcpy(&o[0],tif->tif_dir.td_transferfunction[0],m*sizeof(uint16));\n\tif (n>1)\n\t\t_TIFFmemcpy(&o[m],tif->tif_dir.td_transferfunction[1],m*sizeof(uint16));\n\tif (n>2)\n\t\t_TIFFmemcpy(&o[2*m],tif->tif_dir.td_transferfunction[2],m*sizeof(uint16));\n\tp=TIFFWriteDirectoryTagCheckedShortArray(tif,ndir,dir,TIFFTAG_TRANSFERFUNCTION,n*m,o);\n\t_TIFFfree(o);\n\treturn(p);\n}",
          "fn_code_pos": [
            [
              1860,
              0
            ],
            [
              1911,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagTransferfunction",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagSubifd(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagSubifd\";\n\tuint64 m;\n\tint n;\n\tif (tif->tif_dir.td_nsubifd==0)\n\t\treturn(1);\n\tif (dir==NULL)\n\t{\n\t\t(*ndir)++;\n\t\treturn(1);\n\t}\n\tm=tif->tif_dataoff;\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tuint32* o;\n\t\tuint64* pa;\n\t\tuint32* pb;\n\t\tuint16 p;\n\t\to=_TIFFmalloc(tif->tif_dir.td_nsubifd*sizeof(uint32));\n\t\tif (o==NULL)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\treturn(0);\n\t\t}\n\t\tpa=tif->tif_dir.td_subifd;\n\t\tpb=o;\n\t\tfor (p=0; p < tif->tif_dir.td_nsubifd; p++)\n\t\t{\n                        assert(pa != 0);\n\n                        /* Could happen if an classicTIFF has a SubIFD of type LONG8 (which is illegal) */\n                        if( *pa > 0xFFFFFFFFUL)\n                        {\n                            TIFFErrorExt(tif->tif_clientdata,module,\"Illegal value for SubIFD tag\");\n                            _TIFFfree(o);\n                            return(0);\n                        }\n\t\t\t*pb++=(uint32)(*pa++);\n\t\t}\n\t\tn=TIFFWriteDirectoryTagCheckedIfdArray(tif,ndir,dir,TIFFTAG_SUBIFD,tif->tif_dir.td_nsubifd,o);\n\t\t_TIFFfree(o);\n\t}\n\telse\n\t\tn=TIFFWriteDirectoryTagCheckedIfd8Array(tif,ndir,dir,TIFFTAG_SUBIFD,tif->tif_dir.td_nsubifd,tif->tif_dir.td_subifd);\n\tif (!n)\n\t\treturn(0);\n\t/*\n\t * Total hack: if this directory includes a SubIFD\n\t * tag then force the next <n> directories to be\n\t * written as ``sub directories'' of this one.  This\n\t * is used to write things like thumbnails and\n\t * image masks that one wants to keep out of the\n\t * normal directory linkage access mechanism.\n\t */\n\ttif->tif_flags|=TIFF_INSUBIFD;\n\ttif->tif_nsubifd=tif->tif_dir.td_nsubifd;\n\tif (tif->tif_dir.td_nsubifd==1)\n\t\ttif->tif_subifdoff=0;\n\telse\n\t\ttif->tif_subifdoff=m;\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              1913,
              0
            ],
            [
              1976,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSubifd",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedAscii(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, char* value)\n{\n\tassert(sizeof(char)==1);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_ASCII,count,count,value));\n}",
          "fn_code_pos": [
            [
              1978,
              0
            ],
            [
              1983,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedAscii",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedUndefinedArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value)\n{\n\tassert(sizeof(uint8)==1);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_UNDEFINED,count,count,value));\n}",
          "fn_code_pos": [
            [
              1985,
              0
            ],
            [
              1990,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedUndefinedArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedByte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint8 value)\n{\n\tassert(sizeof(uint8)==1);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_BYTE,1,1,&value));\n}",
          "fn_code_pos": [
            [
              1993,
              0
            ],
            [
              1998,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedByte",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedByteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value)\n{\n\tassert(sizeof(uint8)==1);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_BYTE,count,count,value));\n}",
          "fn_code_pos": [
            [
              2001,
              0
            ],
            [
              2006,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedByteArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedSbyte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int8 value)\n{\n\tassert(sizeof(int8)==1);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SBYTE,1,1,&value));\n}",
          "fn_code_pos": [
            [
              2009,
              0
            ],
            [
              2014,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSbyte",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedSbyteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int8* value)\n{\n\tassert(sizeof(int8)==1);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SBYTE,count,count,value));\n}",
          "fn_code_pos": [
            [
              2017,
              0
            ],
            [
              2022,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSbyteArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "int8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedShort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)\n{\n\tuint16 m;\n\tassert(sizeof(uint16)==2);\n\tm=value;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabShort(&m);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SHORT,1,2,&m));\n}",
          "fn_code_pos": [
            [
              2024,
              0
            ],
            [
              2033,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedShort",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedShortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint16* value)\n{\n\tassert(count<0x80000000);\n\tassert(sizeof(uint16)==2);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfShort(value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SHORT,count,count*2,value));\n}",
          "fn_code_pos": [
            [
              2035,
              0
            ],
            [
              2043,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedShortArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedSshort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int16 value)\n{\n\tint16 m;\n\tassert(sizeof(int16)==2);\n\tm=value;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabShort((uint16*)(&m));\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SSHORT,1,2,&m));\n}",
          "fn_code_pos": [
            [
              2046,
              0
            ],
            [
              2055,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSshort",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedSshortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int16* value)\n{\n\tassert(count<0x80000000);\n\tassert(sizeof(int16)==2);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfShort((uint16*)value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SSHORT,count,count*2,value));\n}",
          "fn_code_pos": [
            [
              2058,
              0
            ],
            [
              2066,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSshortArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "int16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)\n{\n\tuint32 m;\n\tassert(sizeof(uint32)==4);\n\tm=value;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong(&m);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_LONG,1,4,&m));\n}",
          "fn_code_pos": [
            [
              2068,
              0
            ],
            [
              2077,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedLong",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedLongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value)\n{\n\tassert(count<0x40000000);\n\tassert(sizeof(uint32)==4);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong(value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_LONG,count,count*4,value));\n}",
          "fn_code_pos": [
            [
              2079,
              0
            ],
            [
              2087,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedLongArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedSlong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int32 value)\n{\n\tint32 m;\n\tassert(sizeof(int32)==4);\n\tm=value;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong((uint32*)(&m));\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SLONG,1,4,&m));\n}",
          "fn_code_pos": [
            [
              2090,
              0
            ],
            [
              2099,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSlong",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedSlongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int32* value)\n{\n\tassert(count<0x40000000);\n\tassert(sizeof(int32)==4);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong((uint32*)value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SLONG,count,count*4,value));\n}",
          "fn_code_pos": [
            [
              2102,
              0
            ],
            [
              2110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSlongArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "int32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedLong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint64 value)\n{\n\tuint64 m;\n\tassert(sizeof(uint64)==8);\n\tif( !(tif->tif_flags&TIFF_BIGTIFF) ) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\"TIFFWriteDirectoryTagCheckedLong8\",\"LONG8 not allowed for ClassicTIFF\");\n\t\treturn(0);\n\t}\n\tm=value;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong8(&m);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_LONG8,1,8,&m));\n}",
          "fn_code_pos": [
            [
              2113,
              0
            ],
            [
              2126,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedLong8",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)\n{\n\tassert(count<0x20000000);\n\tassert(sizeof(uint64)==8);\n\tif( !(tif->tif_flags&TIFF_BIGTIFF) ) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\"TIFFWriteDirectoryTagCheckedLong8Array\",\"LONG8 not allowed for ClassicTIFF\");\n\t\treturn(0);\n\t}\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong8(value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_LONG8,count,count*8,value));\n}",
          "fn_code_pos": [
            [
              2129,
              0
            ],
            [
              2141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedLong8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedSlong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int64 value)\n{\n\tint64 m;\n\tassert(sizeof(int64)==8);\n\tif( !(tif->tif_flags&TIFF_BIGTIFF) ) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\"TIFFWriteDirectoryTagCheckedSlong8\",\"SLONG8 not allowed for ClassicTIFF\");\n\t\treturn(0);\n\t}\n\tm=value;\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabLong8((uint64*)(&m));\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SLONG8,1,8,&m));\n}",
          "fn_code_pos": [
            [
              2144,
              0
            ],
            [
              2157,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSlong8",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedSlong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int64* value)\n{\n\tassert(count<0x20000000);\n\tassert(sizeof(int64)==8);\n\tif( !(tif->tif_flags&TIFF_BIGTIFF) ) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\"TIFFWriteDirectoryTagCheckedSlong8Array\",\"SLONG8 not allowed for ClassicTIFF\");\n\t\treturn(0);\n\t}\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong8((uint64*)value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SLONG8,count,count*8,value));\n}",
          "fn_code_pos": [
            [
              2160,
              0
            ],
            [
              2172,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSlong8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "int64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n        static const char module[] = \"TIFFWriteDirectoryTagCheckedRational\";\n\tuint32 m[2];\n\tassert(sizeof(uint32)==4);\n        if( value < 0 )\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\"Negative value is illegal\");\n            return 0;\n        }\n        else if( value != value )\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\"Not-a-number value is illegal\");\n            return 0;\n        }\n\telse if (value==0.0)\n\t{\n\t\tm[0]=0;\n\t\tm[1]=1;\n\t}\n\telse if (value <= 0xFFFFFFFFU && value==(double)(uint32)value)\n\t{\n\t\tm[0]=(uint32)value;\n\t\tm[1]=1;\n\t}\n\telse if (value<1.0)\n\t{\n\t\tm[0]=(uint32)(value*0xFFFFFFFF);\n\t\tm[1]=0xFFFFFFFF;\n\t}\n\telse\n\t{\n\t\tm[0]=0xFFFFFFFF;\n\t\tm[1]=(uint32)(0xFFFFFFFF/value);\n\t}\n\tif (tif->tif_flags&TIFF_SWAB)\n\t{\n\t\tTIFFSwabLong(&m[0]);\n\t\tTIFFSwabLong(&m[1]);\n\t}\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,1,8,&m[0]));\n}",
          "fn_code_pos": [
            [
              2174,
              0
            ],
            [
              2216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedRational",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedRationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagCheckedRationalArray\";\n\tuint32* m;\n\tfloat* na;\n\tuint32* nb;\n\tuint32 nc;\n\tint o;\n\tassert(sizeof(uint32)==4);\n\tm=_TIFFmalloc(count*2*sizeof(uint32));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=value, nb=m, nc=0; nc<count; na++, nb+=2, nc++)\n\t{\n\t\tif (*na<=0.0 || *na != *na)\n\t\t{\n\t\t\tnb[0]=0;\n\t\t\tnb[1]=1;\n\t\t}\n\t\telse if (*na >= 0 && *na <= (float)0xFFFFFFFFU &&\n                         *na==(float)(uint32)(*na))\n\t\t{\n\t\t\tnb[0]=(uint32)(*na);\n\t\t\tnb[1]=1;\n\t\t}\n\t\telse if (*na<1.0)\n\t\t{\n\t\t\tnb[0]=(uint32)((double)(*na)*0xFFFFFFFF);\n\t\t\tnb[1]=0xFFFFFFFF;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnb[0]=0xFFFFFFFF;\n\t\t\tnb[1]=(uint32)((double)0xFFFFFFFF/(*na));\n\t\t}\n\t}\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong(m,count*2);\n\to=TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,count,count*8,&m[0]);\n\t_TIFFfree(m);\n\treturn(o);\n}",
          "fn_code_pos": [
            [
              2218,
              0
            ],
            [
              2263,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedRationalArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedSrationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagCheckedSrationalArray\";\n\tint32* m;\n\tfloat* na;\n\tint32* nb;\n\tuint32 nc;\n\tint o;\n\tassert(sizeof(int32)==4);\n\tm=_TIFFmalloc(count*2*sizeof(int32));\n\tif (m==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tfor (na=value, nb=m, nc=0; nc<count; na++, nb+=2, nc++)\n\t{\n\t\tif (*na<0.0)\n\t\t{\n\t\t\tif (*na==(int32)(*na))\n\t\t\t{\n\t\t\t\tnb[0]=(int32)(*na);\n\t\t\t\tnb[1]=1;\n\t\t\t}\n\t\t\telse if (*na>-1.0)\n\t\t\t{\n\t\t\t\tnb[0]=-(int32)((double)(-*na)*0x7FFFFFFF);\n\t\t\t\tnb[1]=0x7FFFFFFF;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnb[0]=-0x7FFFFFFF;\n\t\t\t\tnb[1]=(int32)((double)0x7FFFFFFF/(-*na));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (*na==(int32)(*na))\n\t\t\t{\n\t\t\t\tnb[0]=(int32)(*na);\n\t\t\t\tnb[1]=1;\n\t\t\t}\n\t\t\telse if (*na<1.0)\n\t\t\t{\n\t\t\t\tnb[0]=(int32)((double)(*na)*0x7FFFFFFF);\n\t\t\t\tnb[1]=0x7FFFFFFF;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnb[0]=0x7FFFFFFF;\n\t\t\t\tnb[1]=(int32)((double)0x7FFFFFFF/(*na));\n\t\t\t}\n\t\t}\n\t}\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong((uint32*)m,count*2);\n\to=TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_SRATIONAL,count,count*8,&m[0]);\n\t_TIFFfree(m);\n\treturn(o);\n}",
          "fn_code_pos": [
            [
              2265,
              0
            ],
            [
              2325,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSrationalArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedFloat(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, float value)\n{\n\tfloat m;\n\tassert(sizeof(float)==4);\n\tm=value;\n\tTIFFCvtNativeToIEEEFloat(tif,1,&m);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabFloat(&m);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_FLOAT,1,4,&m));\n}",
          "fn_code_pos": [
            [
              2328,
              0
            ],
            [
              2338,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedFloat",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedFloatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)\n{\n\tassert(count<0x40000000);\n\tassert(sizeof(float)==4);\n\tTIFFCvtNativeToIEEEFloat(tif,count,&value);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfFloat(value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_FLOAT,count,count*4,value));\n}",
          "fn_code_pos": [
            [
              2341,
              0
            ],
            [
              2350,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedFloatArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedDouble(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n\tdouble m;\n\tassert(sizeof(double)==8);\n\tm=value;\n\tTIFFCvtNativeToIEEEDouble(tif,1,&m);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabDouble(&m);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_DOUBLE,1,8,&m));\n}",
          "fn_code_pos": [
            [
              2353,
              0
            ],
            [
              2363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedDouble",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedDoubleArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, double* value)\n{\n\tassert(count<0x20000000);\n\tassert(sizeof(double)==8);\n\tTIFFCvtNativeToIEEEDouble(tif,count,&value);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfDouble(value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_DOUBLE,count,count*8,value));\n}",
          "fn_code_pos": [
            [
              2366,
              0
            ],
            [
              2375,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedDoubleArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedIfdArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value)\n{\n\tassert(count<0x40000000);\n\tassert(sizeof(uint32)==4);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong(value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_IFD,count,count*4,value));\n}",
          "fn_code_pos": [
            [
              2377,
              0
            ],
            [
              2385,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedIfdArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagCheckedIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)\n{\n\tassert(count<0x20000000);\n\tassert(sizeof(uint64)==8);\n\tassert(tif->tif_flags&TIFF_BIGTIFF);\n\tif (tif->tif_flags&TIFF_SWAB)\n\t\tTIFFSwabArrayOfLong8(value,count);\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_IFD8,count,count*8,value));\n}",
          "fn_code_pos": [
            [
              2387,
              0
            ],
            [
              2396,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedIfd8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDirectoryTagData(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 datatype, uint32 count, uint32 datalength, void* data)\n{\n\tstatic const char module[] = \"TIFFWriteDirectoryTagData\";\n\tuint32 m;\n\tm=0;\n\twhile (m<(*ndir))\n\t{\n\t\tassert(dir[m].tdir_tag!=tag);\n\t\tif (dir[m].tdir_tag>tag)\n\t\t\tbreak;\n\t\tm++;\n\t}\n\tif (m<(*ndir))\n\t{\n\t\tuint32 n;\n\t\tfor (n=*ndir; n>m; n--)\n\t\t\tdir[n]=dir[n-1];\n\t}\n\tdir[m].tdir_tag=tag;\n\tdir[m].tdir_type=datatype;\n\tdir[m].tdir_count=count;\n\tdir[m].tdir_offset.toff_long8 = 0;\n\tif (datalength<=((tif->tif_flags&TIFF_BIGTIFF)?0x8U:0x4U))\n\t\t_TIFFmemcpy(&dir[m].tdir_offset,data,datalength);\n\telse\n\t{\n\t\tuint64 na,nb;\n\t\tna=tif->tif_dataoff;\n\t\tnb=na+datalength;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\tnb=(uint32)nb;\n\t\tif ((nb<na)||(nb<datalength))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\");\n\t\t\treturn(0);\n\t\t}\n\t\tif (!SeekOK(tif,na))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing tag data\");\n\t\t\treturn(0);\n\t\t}\n\t\tassert(datalength<0x80000000UL);\n\t\tif (!WriteOK(tif,data,(tmsize_t)datalength))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing tag data\");\n\t\t\treturn(0);\n\t\t}\n\t\ttif->tif_dataoff=nb;\n\t\tif (tif->tif_dataoff&1)\n\t\t\ttif->tif_dataoff++;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tuint32 o;\n\t\t\to=(uint32)na;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&o);\n\t\t\t_TIFFmemcpy(&dir[m].tdir_offset,&o,4);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdir[m].tdir_offset.toff_long8 = na;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dir[m].tdir_offset.toff_long8);\n\t\t}\n\t}\n\t(*ndir)++;\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              2398,
              0
            ],
            [
              2466,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagData",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "datatype": "uint16",
              "count": "uint32",
              "datalength": "uint32",
              "data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFLinkDirectory(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFLinkDirectory\";\n\n\ttif->tif_diroff = (TIFFSeekFile(tif,0,SEEK_END)+1) & (~((toff_t)1));\n\n\t/*\n\t * Handle SubIFDs\n\t */\n\tif (tif->tif_flags & TIFF_INSUBIFD)\n\t{\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tuint32 m;\n\t\t\tm = (uint32)tif->tif_diroff;\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&m);\n\t\t\t(void) TIFFSeekFile(tif, tif->tif_subifdoff, SEEK_SET);\n\t\t\tif (!WriteOK(tif, &m, 4)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"Error writing SubIFD directory link\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Advance to the next SubIFD or, if this is\n\t\t\t * the last one configured, revert back to the\n\t\t\t * normal directory linkage.\n\t\t\t */\n\t\t\tif (--tif->tif_nsubifd)\n\t\t\t\ttif->tif_subifdoff += 4;\n\t\t\telse\n\t\t\t\ttif->tif_flags &= ~TIFF_INSUBIFD;\n\t\t\treturn (1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 m;\n\t\t\tm = tif->tif_diroff;\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&m);\n\t\t\t(void) TIFFSeekFile(tif, tif->tif_subifdoff, SEEK_SET);\n\t\t\tif (!WriteOK(tif, &m, 8)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"Error writing SubIFD directory link\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Advance to the next SubIFD or, if this is\n\t\t\t * the last one configured, revert back to the\n\t\t\t * normal directory linkage.\n\t\t\t */\n\t\t\tif (--tif->tif_nsubifd)\n\t\t\t\ttif->tif_subifdoff += 8;\n\t\t\telse\n\t\t\t\ttif->tif_flags &= ~TIFF_INSUBIFD;\n\t\t\treturn (1);\n\t\t}\n\t}\n\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tuint32 m;\n\t\tuint32 nextdir;\n\t\tm = (uint32)(tif->tif_diroff);\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong(&m);\n\t\tif (tif->tif_header.classic.tiff_diroff == 0) {\n\t\t\t/*\n\t\t\t * First directory, overwrite offset in header.\n\t\t\t */\n\t\t\ttif->tif_header.classic.tiff_diroff = (uint32) tif->tif_diroff;\n\t\t\t(void) TIFFSeekFile(tif,4, SEEK_SET);\n\t\t\tif (!WriteOK(tif, &m, 4)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t\t     \"Error writing TIFF header\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\treturn (1);\n\t\t}\n\t\t/*\n\t\t * Not the first directory, search to the last and append.\n\t\t */\n\t\tnextdir = tif->tif_header.classic.tiff_diroff;\n\t\twhile(1) {\n\t\t\tuint16 dircount;\n\t\t\tuint32 nextnextdir;\n\n\t\t\tif (!SeekOK(tif, nextdir) ||\n\t\t\t    !ReadOK(tif, &dircount, 2)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory count\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount);\n\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t    nextdir+2+dircount*12, SEEK_SET);\n\t\t\tif (!ReadOK(tif, &nextnextdir, 4)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory link\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&nextnextdir);\n\t\t\tif (nextnextdir==0)\n\t\t\t{\n\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t    nextdir+2+dircount*12, SEEK_SET);\n\t\t\t\tif (!WriteOK(tif, &m, 4)) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error writing directory link\");\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextdir=nextnextdir;\n\t\t}\n\t}\n\telse\n\t{\n\t\tuint64 m;\n\t\tuint64 nextdir;\n\t\tm = tif->tif_diroff;\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong8(&m);\n\t\tif (tif->tif_header.big.tiff_diroff == 0) {\n\t\t\t/*\n\t\t\t * First directory, overwrite offset in header.\n\t\t\t */\n\t\t\ttif->tif_header.big.tiff_diroff = tif->tif_diroff;\n\t\t\t(void) TIFFSeekFile(tif,8, SEEK_SET);\n\t\t\tif (!WriteOK(tif, &m, 8)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t\t     \"Error writing TIFF header\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\treturn (1);\n\t\t}\n\t\t/*\n\t\t * Not the first directory, search to the last and append.\n\t\t */\n\t\tnextdir = tif->tif_header.big.tiff_diroff;\n\t\twhile(1) {\n\t\t\tuint64 dircount64;\n\t\t\tuint16 dircount;\n\t\t\tuint64 nextnextdir;\n\n\t\t\tif (!SeekOK(tif, nextdir) ||\n\t\t\t    !ReadOK(tif, &dircount64, 8)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory count\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>0xFFFF)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Sanity check on tag count failed, likely corrupt TIFF\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tdircount=(uint16)dircount64;\n\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t    nextdir+8+dircount*20, SEEK_SET);\n\t\t\tif (!ReadOK(tif, &nextnextdir, 8)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error fetching directory link\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&nextnextdir);\n\t\t\tif (nextnextdir==0)\n\t\t\t{\n\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t    nextdir+8+dircount*20, SEEK_SET);\n\t\t\t\tif (!WriteOK(tif, &m, 8)) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error writing directory link\");\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextdir=nextnextdir;\n\t\t}\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              2471,
              0
            ],
            [
              2658,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFLinkDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\n_TIFFRewriteField(TIFF* tif, uint16 tag, TIFFDataType in_datatype, \n                  tmsize_t count, void* data)\n{\n    static const char module[] = \"TIFFResetField\";\n    /* const TIFFField* fip = NULL; */\n    uint16 dircount;\n    tmsize_t dirsize;\n    uint8 direntry_raw[20];\n    uint16 entry_tag = 0;\n    uint16 entry_type = 0;\n    uint64 entry_count = 0;\n    uint64 entry_offset = 0;\n    int    value_in_entry = 0;\n    uint64 read_offset;\n    uint8 *buf_to_write = NULL;\n    TIFFDataType datatype;\n\n/* -------------------------------------------------------------------- */\n/*      Find field definition.                                          */\n/* -------------------------------------------------------------------- */\n    /*fip =*/ TIFFFindField(tif, tag, TIFF_ANY);\n\n/* -------------------------------------------------------------------- */\n/*      Do some checking this is a straight forward case.               */\n/* -------------------------------------------------------------------- */\n    if( isMapped(tif) )\n    {\n        TIFFErrorExt( tif->tif_clientdata, module, \n                      \"Memory mapped files not currently supported for this operation.\" );\n        return 0;\n    }\n\n    if( tif->tif_diroff == 0 )\n    {\n        TIFFErrorExt( tif->tif_clientdata, module, \n                      \"Attempt to reset field on directory not already on disk.\" );\n        return 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read the directory entry count.                                 */\n/* -------------------------------------------------------------------- */\n    if (!SeekOK(tif, tif->tif_diroff)) {\n        TIFFErrorExt(tif->tif_clientdata, module,\n                     \"%s: Seek error accessing TIFF directory\",\n                     tif->tif_name);\n        return 0;\n    }\n\n    read_offset = tif->tif_diroff;\n\n    if (!(tif->tif_flags&TIFF_BIGTIFF))\n    {\n        if (!ReadOK(tif, &dircount, sizeof (uint16))) {\n            TIFFErrorExt(tif->tif_clientdata, module,\n                         \"%s: Can not read TIFF directory count\",\n                         tif->tif_name);\n            return 0;\n        }\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabShort(&dircount);\n        dirsize = 12;\n        read_offset += 2;\n    } else {\n        uint64 dircount64;\n        if (!ReadOK(tif, &dircount64, sizeof (uint64))) {\n            TIFFErrorExt(tif->tif_clientdata, module,\n                         \"%s: Can not read TIFF directory count\",\n                         tif->tif_name);\n            return 0;\n        }\n        if (tif->tif_flags & TIFF_SWAB)\n            TIFFSwabLong8(&dircount64);\n        dircount = (uint16)dircount64;\n        dirsize = 20;\n        read_offset += 8;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Read through directory to find target tag.                      */\n/* -------------------------------------------------------------------- */\n    while( dircount > 0 )\n    {\n        if (!ReadOK(tif, direntry_raw, dirsize)) {\n            TIFFErrorExt(tif->tif_clientdata, module,\n                         \"%s: Can not read TIFF directory entry.\",\n                         tif->tif_name);\n            return 0;\n        }\n\n        memcpy( &entry_tag, direntry_raw + 0, sizeof(uint16) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabShort( &entry_tag );\n\n        if( entry_tag == tag )\n            break;\n\n        read_offset += dirsize;\n    }\n\n    if( entry_tag != tag )\n    {\n        TIFFErrorExt(tif->tif_clientdata, module,\n                     \"%s: Could not find tag %d.\",\n                     tif->tif_name, tag );\n        return 0;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Extract the type, count and offset for this entry.              */\n/* -------------------------------------------------------------------- */\n    memcpy( &entry_type, direntry_raw + 2, sizeof(uint16) );\n    if (tif->tif_flags&TIFF_SWAB)\n        TIFFSwabShort( &entry_type );\n\n    if (!(tif->tif_flags&TIFF_BIGTIFF))\n    {\n        uint32 value;\n        \n        memcpy( &value, direntry_raw + 4, sizeof(uint32) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabLong( &value );\n        entry_count = value;\n\n        memcpy( &value, direntry_raw + 8, sizeof(uint32) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabLong( &value );\n        entry_offset = value;\n    }\n    else\n    {\n        memcpy( &entry_count, direntry_raw + 4, sizeof(uint64) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabLong8( &entry_count );\n\n        memcpy( &entry_offset, direntry_raw + 12, sizeof(uint64) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabLong8( &entry_offset );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      What data type do we want to write this as?                     */\n/* -------------------------------------------------------------------- */\n    if( TIFFDataWidth(in_datatype) == 8 && !(tif->tif_flags&TIFF_BIGTIFF) )\n    {\n        if( in_datatype == TIFF_LONG8 )\n            datatype = TIFF_LONG;\n        else if( in_datatype == TIFF_SLONG8 )\n            datatype = TIFF_SLONG;\n        else if( in_datatype == TIFF_IFD8 )\n            datatype = TIFF_IFD;\n        else\n            datatype = in_datatype;\n    }\n    else \n        datatype = in_datatype;\n\n/* -------------------------------------------------------------------- */\n/*      Prepare buffer of actual data to write.  This includes          */\n/*      swabbing as needed.                                             */\n/* -------------------------------------------------------------------- */\n    buf_to_write =\n\t    (uint8 *)_TIFFCheckMalloc(tif, count, TIFFDataWidth(datatype),\n\t\t\t\t      \"for field buffer.\");\n    if (!buf_to_write)\n        return 0;\n\n    if( datatype == in_datatype )\n        memcpy( buf_to_write, data, count * TIFFDataWidth(datatype) );\n    else if( datatype == TIFF_SLONG && in_datatype == TIFF_SLONG8 )\n    {\n\ttmsize_t i;\n\n        for( i = 0; i < count; i++ )\n        {\n            ((int32 *) buf_to_write)[i] = \n                (int32) ((int64 *) data)[i];\n            if( (int64) ((int32 *) buf_to_write)[i] != ((int64 *) data)[i] )\n            {\n                _TIFFfree( buf_to_write );\n                TIFFErrorExt( tif->tif_clientdata, module, \n                              \"Value exceeds 32bit range of output type.\" );\n                return 0;\n            }\n        }\n    }\n    else if( (datatype == TIFF_LONG && in_datatype == TIFF_LONG8)\n             || (datatype == TIFF_IFD && in_datatype == TIFF_IFD8) )\n    {\n\ttmsize_t i;\n\n        for( i = 0; i < count; i++ )\n        {\n            ((uint32 *) buf_to_write)[i] = \n                (uint32) ((uint64 *) data)[i];\n            if( (uint64) ((uint32 *) buf_to_write)[i] != ((uint64 *) data)[i] )\n            {\n                _TIFFfree( buf_to_write );\n                TIFFErrorExt( tif->tif_clientdata, module, \n                              \"Value exceeds 32bit range of output type.\" );\n                return 0;\n            }\n        }\n    }\n\n    if( TIFFDataWidth(datatype) > 1 && (tif->tif_flags&TIFF_SWAB) )\n    {\n        if( TIFFDataWidth(datatype) == 2 )\n            TIFFSwabArrayOfShort( (uint16 *) buf_to_write, count );\n        else if( TIFFDataWidth(datatype) == 4 )\n            TIFFSwabArrayOfLong( (uint32 *) buf_to_write, count );\n        else if( TIFFDataWidth(datatype) == 8 )\n            TIFFSwabArrayOfLong8( (uint64 *) buf_to_write, count );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Is this a value that fits into the directory entry?             */\n/* -------------------------------------------------------------------- */\n    if (!(tif->tif_flags&TIFF_BIGTIFF))\n    {\n        if( TIFFDataWidth(datatype) * count <= 4 )\n        {\n            entry_offset = read_offset + 8;\n            value_in_entry = 1;\n        }\n    }\n    else\n    {\n        if( TIFFDataWidth(datatype) * count <= 8 )\n        {\n            entry_offset = read_offset + 12;\n            value_in_entry = 1;\n        }\n    }\n\n/* -------------------------------------------------------------------- */\n/*      If the tag type, and count match, then we just write it out     */\n/*      over the old values without altering the directory entry at     */\n/*      all.                                                            */\n/* -------------------------------------------------------------------- */\n    if( entry_count == (uint64)count && entry_type == (uint16) datatype )\n    {\n        if (!SeekOK(tif, entry_offset)) {\n            _TIFFfree( buf_to_write );\n            TIFFErrorExt(tif->tif_clientdata, module,\n                         \"%s: Seek error accessing TIFF directory\",\n                         tif->tif_name);\n            return 0;\n        }\n        if (!WriteOK(tif, buf_to_write, count*TIFFDataWidth(datatype))) {\n            _TIFFfree( buf_to_write );\n            TIFFErrorExt(tif->tif_clientdata, module,\n                         \"Error writing directory link\");\n            return (0);\n        }\n\n        _TIFFfree( buf_to_write );\n        return 1;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Otherwise, we write the new tag data at the end of the file.    */\n/* -------------------------------------------------------------------- */\n    if( !value_in_entry )\n    {\n        entry_offset = TIFFSeekFile(tif,0,SEEK_END);\n        \n        if (!WriteOK(tif, buf_to_write, count*TIFFDataWidth(datatype))) {\n            _TIFFfree( buf_to_write );\n            TIFFErrorExt(tif->tif_clientdata, module,\n                         \"Error writing directory link\");\n            return (0);\n        }\n    }\n    else\n    {\n        memcpy( &entry_offset, buf_to_write, count*TIFFDataWidth(datatype));\n    }\n\n    _TIFFfree( buf_to_write );\n    buf_to_write = 0;\n\n/* -------------------------------------------------------------------- */\n/*      Adjust the directory entry.                                     */\n/* -------------------------------------------------------------------- */\n    entry_type = datatype;\n    memcpy( direntry_raw + 2, &entry_type, sizeof(uint16) );\n    if (tif->tif_flags&TIFF_SWAB)\n        TIFFSwabShort( (uint16 *) (direntry_raw + 2) );\n\n    if (!(tif->tif_flags&TIFF_BIGTIFF))\n    {\n        uint32 value;\n\n        value = (uint32) entry_count;\n        memcpy( direntry_raw + 4, &value, sizeof(uint32) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabLong( (uint32 *) (direntry_raw + 4) );\n\n        value = (uint32) entry_offset;\n        memcpy( direntry_raw + 8, &value, sizeof(uint32) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabLong( (uint32 *) (direntry_raw + 8) );\n    }\n    else\n    {\n        memcpy( direntry_raw + 4, &entry_count, sizeof(uint64) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabLong8( (uint64 *) (direntry_raw + 4) );\n\n        memcpy( direntry_raw + 12, &entry_offset, sizeof(uint64) );\n        if (tif->tif_flags&TIFF_SWAB)\n            TIFFSwabLong8( (uint64 *) (direntry_raw + 12) );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write the directory entry out to disk.                          */\n/* -------------------------------------------------------------------- */\n    if (!SeekOK(tif, read_offset )) {\n        TIFFErrorExt(tif->tif_clientdata, module,\n                     \"%s: Seek error accessing TIFF directory\",\n                     tif->tif_name);\n        return 0;\n    }\n\n    if (!WriteOK(tif, direntry_raw,dirsize))\n    {\n        TIFFErrorExt(tif->tif_clientdata, module,\n                     \"%s: Can not write TIFF directory entry.\",\n                     tif->tif_name);\n        return 0;\n    }\n    \n    return 1;\n}",
          "fn_code_pos": [
            [
              2673,
              0
            ],
            [
              3008,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFRewriteField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint16",
              "in_datatype": "TIFFDataType",
              "count": "tmsize_t",
              "data": "void"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFCvtNativeToIEEEFloat(TIFF* tif, uint32 n, float* fp)",
          "fn_dec_pos": [
            [
              35,
              12
            ],
            [
              35,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCvtNativeToIEEEFloat",
            "parameters": {
              "tif": "TIFF",
              "n": "uint32",
              "fp": "float"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFCvtNativeToIEEEDouble(TIFF* tif, uint32 n, double* dp)",
          "fn_dec_pos": [
            [
              36,
              12
            ],
            [
              36,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCvtNativeToIEEEDouble",
            "parameters": {
              "tif": "TIFF",
              "n": "uint32",
              "dp": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)",
          "fn_dec_pos": [
            [
              39,
              11
            ],
            [
              39,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectorySec",
            "parameters": {
              "tif": "TIFF",
              "isimage": "int",
              "imagedone": "int",
              "pdiroff": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagSampleformatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, double* value)",
          "fn_dec_pos": [
            [
              41,
              11
            ],
            [
              41,
              134
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSampleformatArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagSampleformatPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)",
          "fn_dec_pos": [
            [
              43,
              11
            ],
            [
              43,
              123
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSampleformatPerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagAscii(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, char* value)",
          "fn_dec_pos": [
            [
              46,
              11
            ],
            [
              46,
              120
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagAscii",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagUndefinedArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value)",
          "fn_dec_pos": [
            [
              47,
              11
            ],
            [
              47,
              130
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagUndefinedArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagByte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint8 value)",
          "fn_dec_pos": [
            [
              49,
              11
            ],
            [
              49,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagByte",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagByteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value)",
          "fn_dec_pos": [
            [
              51,
              11
            ],
            [
              51,
              125
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagByteArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagBytePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint8 value)",
          "fn_dec_pos": [
            [
              53,
              11
            ],
            [
              53,
              114
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagBytePerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagSbyte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int8 value)",
          "fn_dec_pos": [
            [
              56,
              11
            ],
            [
              56,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSbyte",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagSbyteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int8* value)",
          "fn_dec_pos": [
            [
              58,
              11
            ],
            [
              58,
              125
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSbyteArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "int8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagSbytePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int8 value)",
          "fn_dec_pos": [
            [
              60,
              11
            ],
            [
              60,
              114
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSbytePerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagShort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)",
          "fn_dec_pos": [
            [
              62,
              11
            ],
            [
              62,
              107
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagShort",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagShortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint16* value)",
          "fn_dec_pos": [
            [
              63,
              11
            ],
            [
              63,
              127
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagShortArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagShortPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)",
          "fn_dec_pos": [
            [
              64,
              11
            ],
            [
              64,
              116
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagShortPerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagSshort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int16 value)",
          "fn_dec_pos": [
            [
              66,
              11
            ],
            [
              66,
              107
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSshort",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagSshortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int16* value)",
          "fn_dec_pos": [
            [
              68,
              11
            ],
            [
              68,
              127
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSshortArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "int16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagSshortPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int16 value)",
          "fn_dec_pos": [
            [
              70,
              11
            ],
            [
              70,
              116
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSshortPerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)",
          "fn_dec_pos": [
            [
              72,
              11
            ],
            [
              72,
              106
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagLong",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagLongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value)",
          "fn_dec_pos": [
            [
              73,
              11
            ],
            [
              73,
              126
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagLongArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagLongPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)",
          "fn_dec_pos": [
            [
              75,
              11
            ],
            [
              75,
              115
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagLongPerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagSlong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int32 value)",
          "fn_dec_pos": [
            [
              78,
              11
            ],
            [
              78,
              106
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSlong",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagSlongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int32* value)",
          "fn_dec_pos": [
            [
              80,
              11
            ],
            [
              80,
              126
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSlongArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "int32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagSlongPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int32 value)",
          "fn_dec_pos": [
            [
              82,
              11
            ],
            [
              82,
              115
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSlongPerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagLong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint64 value)",
          "fn_dec_pos": [
            [
              85,
              11
            ],
            [
              85,
              107
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagLong8",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)",
          "fn_dec_pos": [
            [
              87,
              11
            ],
            [
              87,
              127
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagLong8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagSlong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int64 value)",
          "fn_dec_pos": [
            [
              89,
              11
            ],
            [
              89,
              107
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSlong8",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagSlong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int64* value)",
          "fn_dec_pos": [
            [
              91,
              11
            ],
            [
              91,
              127
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSlong8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "int64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)",
          "fn_dec_pos": [
            [
              92,
              11
            ],
            [
              92,
              110
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagRational",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagRationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)",
          "fn_dec_pos": [
            [
              93,
              11
            ],
            [
              93,
              129
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagRationalArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagSrationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)",
          "fn_dec_pos": [
            [
              94,
              11
            ],
            [
              94,
              130
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSrationalArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagFloat(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, float value)",
          "fn_dec_pos": [
            [
              96,
              11
            ],
            [
              96,
              106
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagFloat",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagFloatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)",
          "fn_dec_pos": [
            [
              98,
              11
            ],
            [
              98,
              126
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagFloatArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagFloatPerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, float value)",
          "fn_dec_pos": [
            [
              100,
              11
            ],
            [
              100,
              115
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagFloatPerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagDouble(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)",
          "fn_dec_pos": [
            [
              103,
              11
            ],
            [
              103,
              108
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagDouble",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagDoubleArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, double* value)",
          "fn_dec_pos": [
            [
              105,
              11
            ],
            [
              105,
              128
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagDoubleArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagDoublePerSample(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)",
          "fn_dec_pos": [
            [
              107,
              11
            ],
            [
              107,
              117
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagDoublePerSample",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagIfdArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value)",
          "fn_dec_pos": [
            [
              109,
              11
            ],
            [
              109,
              125
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagIfdArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)",
          "fn_dec_pos": [
            [
              111,
              11
            ],
            [
              111,
              126
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagIfd8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagShortLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)",
          "fn_dec_pos": [
            [
              113,
              11
            ],
            [
              113,
              111
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagShortLong",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)",
          "fn_dec_pos": [
            [
              114,
              11
            ],
            [
              114,
              131
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagLongLong8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagIfdIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)",
          "fn_dec_pos": [
            [
              115,
              11
            ],
            [
              115,
              129
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagIfdIfd8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagShortLongLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)",
          "fn_dec_pos": [
            [
              117,
              11
            ],
            [
              117,
              136
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagShortLongLong8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagColormap(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)",
          "fn_dec_pos": [
            [
              119,
              11
            ],
            [
              119,
              84
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagColormap",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagTransferfunction(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)",
          "fn_dec_pos": [
            [
              120,
              11
            ],
            [
              120,
              92
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagTransferfunction",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagSubifd(TIFF* tif, uint32* ndir, TIFFDirEntry* dir)",
          "fn_dec_pos": [
            [
              121,
              11
            ],
            [
              121,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagSubifd",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedAscii(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, char* value)",
          "fn_dec_pos": [
            [
              123,
              11
            ],
            [
              123,
              127
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedAscii",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedUndefinedArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value)",
          "fn_dec_pos": [
            [
              124,
              11
            ],
            [
              124,
              137
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedUndefinedArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedByte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint8 value)",
          "fn_dec_pos": [
            [
              126,
              11
            ],
            [
              126,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedByte",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedByteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint8* value)",
          "fn_dec_pos": [
            [
              128,
              11
            ],
            [
              128,
              132
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedByteArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedSbyte(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int8 value)",
          "fn_dec_pos": [
            [
              130,
              11
            ],
            [
              130,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSbyte",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedSbyteArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int8* value)",
          "fn_dec_pos": [
            [
              132,
              11
            ],
            [
              132,
              132
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSbyteArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "int8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedShort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 value)",
          "fn_dec_pos": [
            [
              133,
              11
            ],
            [
              133,
              114
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedShort",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedShortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint16* value)",
          "fn_dec_pos": [
            [
              134,
              11
            ],
            [
              134,
              134
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedShortArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedSshort(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int16 value)",
          "fn_dec_pos": [
            [
              136,
              11
            ],
            [
              136,
              114
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSshort",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedSshortArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int16* value)",
          "fn_dec_pos": [
            [
              138,
              11
            ],
            [
              138,
              134
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSshortArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "int16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedLong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 value)",
          "fn_dec_pos": [
            [
              139,
              11
            ],
            [
              139,
              113
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedLong",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedLongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value)",
          "fn_dec_pos": [
            [
              140,
              11
            ],
            [
              140,
              133
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedLongArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedSlong(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int32 value)",
          "fn_dec_pos": [
            [
              142,
              11
            ],
            [
              142,
              113
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSlong",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedSlongArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int32* value)",
          "fn_dec_pos": [
            [
              144,
              11
            ],
            [
              144,
              133
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSlongArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "int32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedLong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint64 value)",
          "fn_dec_pos": [
            [
              146,
              11
            ],
            [
              146,
              114
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedLong8",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedLong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)",
          "fn_dec_pos": [
            [
              148,
              11
            ],
            [
              148,
              134
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedLong8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedSlong8(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, int64 value)",
          "fn_dec_pos": [
            [
              150,
              11
            ],
            [
              150,
              114
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSlong8",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "int64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedSlong8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, int64* value)",
          "fn_dec_pos": [
            [
              152,
              11
            ],
            [
              152,
              134
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSlong8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "int64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)",
          "fn_dec_pos": [
            [
              153,
              11
            ],
            [
              153,
              117
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedRational",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedRationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)",
          "fn_dec_pos": [
            [
              154,
              11
            ],
            [
              154,
              136
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedRationalArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedSrationalArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)",
          "fn_dec_pos": [
            [
              155,
              11
            ],
            [
              155,
              137
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedSrationalArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedFloat(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, float value)",
          "fn_dec_pos": [
            [
              157,
              11
            ],
            [
              157,
              113
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedFloat",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedFloatArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, float* value)",
          "fn_dec_pos": [
            [
              159,
              11
            ],
            [
              159,
              133
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedFloatArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedDouble(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)",
          "fn_dec_pos": [
            [
              161,
              11
            ],
            [
              161,
              115
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedDouble",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedDoubleArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, double* value)",
          "fn_dec_pos": [
            [
              163,
              11
            ],
            [
              163,
              135
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedDoubleArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedIfdArray(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint32* value)",
          "fn_dec_pos": [
            [
              164,
              11
            ],
            [
              164,
              132
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedIfdArray",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagCheckedIfd8Array(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint32 count, uint64* value)",
          "fn_dec_pos": [
            [
              165,
              11
            ],
            [
              165,
              133
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagCheckedIfd8Array",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "count": "uint32",
              "value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectoryTagData(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, uint16 datatype, uint32 count, uint32 datalength, void* data)",
          "fn_dec_pos": [
            [
              167,
              11
            ],
            [
              167,
              154
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectoryTagData",
            "parameters": {
              "tif": "TIFF",
              "ndir": "uint32",
              "dir": "TIFFDirEntry",
              "tag": "uint16",
              "datatype": "uint16",
              "count": "uint32",
              "datalength": "uint32",
              "data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFLinkDirectory(TIFF*)",
          "fn_dec_pos": [
            [
              169,
              11
            ],
            [
              169,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFLinkDirectory",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_strip.c": {
      "fn_def_list": [
        {
          "fn_code": "uint32\nTIFFComputeStrip(TIFF* tif, uint32 row, uint16 sample)\n{\n\tstatic const char module[] = \"TIFFComputeStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 strip;\n\n\tstrip = row / td->td_rowsperstrip;\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE) {\n\t\tif (sample >= td->td_samplesperpixel) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"%lu: Sample out of range, max %lu\",\n\t\t\t    (unsigned long) sample, (unsigned long) td->td_samplesperpixel);\n\t\t\treturn (0);\n\t\t}\n\t\tstrip += (uint32)sample*td->td_stripsperimage;\n\t}\n\treturn (strip);\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              52,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFComputeStrip",
            "parameters": {
              "tif": "TIFF",
              "row": "uint32",
              "sample": "uint16"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "uint32\nTIFFNumberOfStrips(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 nstrips;\n\n\tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n\t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfStrips\");\n\treturn (nstrips);\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              69,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFNumberOfStrips",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "uint64\nTIFFVStripSize64(TIFF* tif, uint32 nrows)\n{\n\tstatic const char module[] = \"TIFFVStripSize64\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tif (nrows==(uint32)(-1))\n\t\tnrows=td->td_imagelength;\n\tif ((td->td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (td->td_photometric == PHOTOMETRIC_YCBCR)&&\n\t    (!isUpSampled(tif)))\n\t{\n\t\t/*\n\t\t * Packed YCbCr data contain one Cb+Cr for every\n\t\t * HorizontalSampling*VerticalSampling Y values.\n\t\t * Must also roundup width and height when calculating\n\t\t * since images that are not a multiple of the\n\t\t * horizontal/vertical subsampling area include\n\t\t * YCbCr data for the extended image.\n\t\t */\n\t\tuint16 ycbcrsubsampling[2];\n\t\tuint16 samplingblock_samples;\n\t\tuint32 samplingblocks_hor;\n\t\tuint32 samplingblocks_ver;\n\t\tuint64 samplingrow_samples;\n\t\tuint64 samplingrow_size;\n\t\tif(td->td_samplesperpixel!=3)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t    \"Invalid td_samplesperpixel value\");\n\t\t\treturn 0;\n\t\t}\n\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_YCBCRSUBSAMPLING,ycbcrsubsampling+0,\n\t\t    ycbcrsubsampling+1);\n\t\tif ((ycbcrsubsampling[0] != 1 && ycbcrsubsampling[0] != 2 && ycbcrsubsampling[0] != 4)\n\t\t    ||(ycbcrsubsampling[1] != 1 && ycbcrsubsampling[1] != 2 && ycbcrsubsampling[1] != 4))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t\t     \"Invalid YCbCr subsampling (%dx%d)\", \n\t\t\t\t     ycbcrsubsampling[0], \n\t\t\t\t     ycbcrsubsampling[1] );\n\t\t\treturn 0;\n\t\t}\n\t\tsamplingblock_samples=ycbcrsubsampling[0]*ycbcrsubsampling[1]+2;\n\t\tsamplingblocks_hor=TIFFhowmany_32(td->td_imagewidth,ycbcrsubsampling[0]);\n\t\tsamplingblocks_ver=TIFFhowmany_32(nrows,ycbcrsubsampling[1]);\n\t\tsamplingrow_samples=_TIFFMultiply64(tif,samplingblocks_hor,samplingblock_samples,module);\n\t\tsamplingrow_size=TIFFhowmany8_64(_TIFFMultiply64(tif,samplingrow_samples,td->td_bitspersample,module));\n\t\treturn(_TIFFMultiply64(tif,samplingrow_size,samplingblocks_ver,module));\n\t}\n\telse\n\t\treturn(_TIFFMultiply64(tif,nrows,TIFFScanlineSize64(tif),module));\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFVStripSize64",
            "parameters": {
              "tif": "TIFF",
              "nrows": "uint32"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFVStripSize(TIFF* tif, uint32 nrows)\n{\n\tstatic const char module[] = \"TIFFVStripSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFVStripSize64(tif,nrows);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}",
          "fn_code_pos": [
            [
              126,
              0
            ],
            [
              140,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFVStripSize",
            "parameters": {
              "tif": "TIFF",
              "nrows": "uint32"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "uint64\nTIFFRawStripSize64(TIFF* tif, uint32 strip)\n{\n\tstatic const char module[] = \"TIFFRawStripSize64\";\n\tTIFFDirectory* td = &tif->tif_dir;\n\tuint64 bytecount = td->td_stripbytecount[strip];\n\n\tif (bytecount == 0)\n\t{\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%I64u: Invalid strip byte count, strip %lu\",\n\t\t\t     (unsigned __int64) bytecount,\n\t\t\t     (unsigned long) strip);\n#else\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%llu: Invalid strip byte count, strip %lu\",\n\t\t\t     (unsigned long long) bytecount,\n\t\t\t     (unsigned long) strip);\n#endif\n\t\tbytecount = (uint64) -1;\n\t}\n\n\treturn bytecount;\n}",
          "fn_code_pos": [
            [
              145,
              0
            ],
            [
              169,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRawStripSize64",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFRawStripSize(TIFF* tif, uint32 strip)\n{\n\tstatic const char module[] = \"TIFFRawStripSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFRawStripSize64(tif,strip);\n\tif (m==(uint64)(-1))\n\t\tn=(tmsize_t)(-1);\n\telse\n\t{\n\t\tn=(tmsize_t)m;\n\t\tif ((uint64)n!=m)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\t\tn=0;\n\t\t}\n\t}\n\treturn(n);\n}",
          "fn_code_pos": [
            [
              170,
              0
            ],
            [
              189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRawStripSize",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "uint64\nTIFFStripSize64(TIFF* tif)\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\tuint32 rps = td->td_rowsperstrip;\n\tif (rps > td->td_imagelength)\n\t\trps = td->td_imagelength;\n\treturn (TIFFVStripSize64(tif, rps));\n}",
          "fn_code_pos": [
            [
              199,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFStripSize64",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFStripSize(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFStripSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFStripSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}",
          "fn_code_pos": [
            [
              208,
              0
            ],
            [
              222,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFStripSize",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "uint32\nTIFFDefaultStripSize(TIFF* tif, uint32 request)\n{\n\treturn (*tif->tif_defstripsize)(tif, request);\n}",
          "fn_code_pos": [
            [
              230,
              0
            ],
            [
              234,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFDefaultStripSize",
            "parameters": {
              "tif": "TIFF",
              "request": "uint32"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "uint32\n_TIFFDefaultStripSize(TIFF* tif, uint32 s)\n{\n\tif ((int32) s < 1) {\n\t\t/*\n\t\t * If RowsPerStrip is unspecified, try to break the\n\t\t * image up into strips that are approximately\n\t\t * STRIP_SIZE_DEFAULT bytes long.\n\t\t */\n\t\tuint64 scanlinesize;\n\t\tuint64 rows;\n\t\tscanlinesize=TIFFScanlineSize64(tif);\n\t\tif (scanlinesize==0)\n\t\t\tscanlinesize=1;\n\t\trows=(uint64)STRIP_SIZE_DEFAULT/scanlinesize;\n\t\tif (rows==0)\n\t\t\trows=1;\n\t\telse if (rows>0xFFFFFFFF)\n\t\t\trows=0xFFFFFFFF;\n\t\ts=(uint32)rows;\n\t}\n\treturn (s);\n}",
          "fn_code_pos": [
            [
              236,
              0
            ],
            [
              258,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFDefaultStripSize",
            "parameters": {
              "tif": "TIFF",
              "s": "uint32"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "uint64\nTIFFScanlineSize64(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFScanlineSize64\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64 scanline_size;\n\tif (td->td_planarconfig==PLANARCONFIG_CONTIG)\n\t{\n\t\tif ((td->td_photometric==PHOTOMETRIC_YCBCR)&&\n\t\t    (td->td_samplesperpixel==3)&&\n\t\t    (!isUpSampled(tif)))\n\t\t{\n\t\t\tuint16 ycbcrsubsampling[2];\n\t\t\tuint16 samplingblock_samples;\n\t\t\tuint32 samplingblocks_hor;\n\t\t\tuint64 samplingrow_samples;\n\t\t\tuint64 samplingrow_size;\n\t\t\tif(td->td_samplesperpixel!=3)\n\t\t\t{\n                            TIFFErrorExt(tif->tif_clientdata,module,\n                                         \"Invalid td_samplesperpixel value\");\n                            return 0;\n\t\t\t}\n\t\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_YCBCRSUBSAMPLING,\n                                              ycbcrsubsampling+0,\n                                              ycbcrsubsampling+1);\n\t\t\tif (((ycbcrsubsampling[0]!=1)&&(ycbcrsubsampling[0]!=2)&&(ycbcrsubsampling[0]!=4)) ||\n\t\t\t    ((ycbcrsubsampling[1]!=1)&&(ycbcrsubsampling[1]!=2)&&(ycbcrsubsampling[1]!=4)))\n\t\t\t{\n                            TIFFErrorExt(tif->tif_clientdata,module,\n                                         \"Invalid YCbCr subsampling\");\n                            return 0;\n\t\t\t}\n\t\t\tsamplingblock_samples = ycbcrsubsampling[0]*ycbcrsubsampling[1]+2;\n\t\t\tsamplingblocks_hor = TIFFhowmany_32(td->td_imagewidth,ycbcrsubsampling[0]);\n\t\t\tsamplingrow_samples = _TIFFMultiply64(tif,samplingblocks_hor,samplingblock_samples,module);\n\t\t\tsamplingrow_size = TIFFhowmany_64(_TIFFMultiply64(tif,samplingrow_samples,td->td_bitspersample,module),8);\n\t\t\tscanline_size = (samplingrow_size/ycbcrsubsampling[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 scanline_samples;\n\t\t\tscanline_samples=_TIFFMultiply64(tif,td->td_imagewidth,td->td_samplesperpixel,module);\n\t\t\tscanline_size=TIFFhowmany_64(_TIFFMultiply64(tif,scanline_samples,td->td_bitspersample,module),8);\n\t\t}\n\t}\n\telse\n        {\n\t\tscanline_size=TIFFhowmany_64(_TIFFMultiply64(tif,td->td_imagewidth,td->td_bitspersample,module),8);\n        }\n        if (scanline_size == 0)\n        {\n                TIFFErrorExt(tif->tif_clientdata,module,\"Computed scanline size is zero\");\n                return 0;\n        }\n\treturn(scanline_size);\n}",
          "fn_code_pos": [
            [
              270,
              0
            ],
            [
              326,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFScanlineSize64",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFScanlineSize(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFScanlineSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFScanlineSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m) {\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer arithmetic overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}",
          "fn_code_pos": [
            [
              327,
              0
            ],
            [
              340,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFScanlineSize",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "uint64\nTIFFRasterScanlineSize64(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFRasterScanlineSize64\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64 scanline;\n\n\tscanline = _TIFFMultiply64(tif, td->td_bitspersample, td->td_imagewidth, module);\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tscanline = _TIFFMultiply64(tif, scanline, td->td_samplesperpixel, module);\n\t\treturn (TIFFhowmany8_64(scanline));\n\t} else\n\t\treturn (_TIFFMultiply64(tif, TIFFhowmany8_64(scanline),\n\t\t    td->td_samplesperpixel, module));\n}",
          "fn_code_pos": [
            [
              348,
              0
            ],
            [
              362,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRasterScanlineSize64",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFRasterScanlineSize(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFRasterScanlineSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFRasterScanlineSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer arithmetic overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}",
          "fn_code_pos": [
            [
              363,
              0
            ],
            [
              377,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRasterScanlineSize",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "tmsize_t"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_pixarlog.c": {
      "fn_def_list": [
        {
          "fn_code": "static void\nhorizontalAccumulateF(uint16 *wp, int n, int stride, float *op,\n\tfloat *ToLinearF)\n{\n    register unsigned int  cr, cg, cb, ca, mask;\n    register float  t0, t1, t2, t3;\n\n    if (n >= stride) {\n\tmask = CODE_MASK;\n\tif (stride == 3) {\n\t    t0 = ToLinearF[cr = (wp[0] & mask)];\n\t    t1 = ToLinearF[cg = (wp[1] & mask)];\n\t    t2 = ToLinearF[cb = (wp[2] & mask)];\n\t    op[0] = t0;\n\t    op[1] = t1;\n\t    op[2] = t2;\n\t    n -= 3;\n\t    while (n > 0) {\n\t\twp += 3;\n\t\top += 3;\n\t\tn -= 3;\n\t\tt0 = ToLinearF[(cr += wp[0]) & mask];\n\t\tt1 = ToLinearF[(cg += wp[1]) & mask];\n\t\tt2 = ToLinearF[(cb += wp[2]) & mask];\n\t\top[0] = t0;\n\t\top[1] = t1;\n\t\top[2] = t2;\n\t    }\n\t} else if (stride == 4) {\n\t    t0 = ToLinearF[cr = (wp[0] & mask)];\n\t    t1 = ToLinearF[cg = (wp[1] & mask)];\n\t    t2 = ToLinearF[cb = (wp[2] & mask)];\n\t    t3 = ToLinearF[ca = (wp[3] & mask)];\n\t    op[0] = t0;\n\t    op[1] = t1;\n\t    op[2] = t2;\n\t    op[3] = t3;\n\t    n -= 4;\n\t    while (n > 0) {\n\t\twp += 4;\n\t\top += 4;\n\t\tn -= 4;\n\t\tt0 = ToLinearF[(cr += wp[0]) & mask];\n\t\tt1 = ToLinearF[(cg += wp[1]) & mask];\n\t\tt2 = ToLinearF[(cb += wp[2]) & mask];\n\t\tt3 = ToLinearF[(ca += wp[3]) & mask];\n\t\top[0] = t0;\n\t\top[1] = t1;\n\t\top[2] = t2;\n\t\top[3] = t3;\n\t    }\n\t} else {\n\t    REPEAT(stride, *op = ToLinearF[*wp&mask]; wp++; op++)\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride,\n\t\t    wp[stride] += *wp; *op = ToLinearF[*wp&mask]; wp++; op++)\n\t\tn -= stride;\n\t    }\n\t}\n    }\n}",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              171,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horizontalAccumulateF",
            "parameters": {
              "wp": "uint16",
              "n": "int",
              "stride": "int",
              "op": "float",
              "ToLinearF": "float"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nhorizontalAccumulate12(uint16 *wp, int n, int stride, int16 *op,\n\tfloat *ToLinearF)\n{\n    register unsigned int  cr, cg, cb, ca, mask;\n    register float  t0, t1, t2, t3;\n\n#define SCALE12 2048.0F\n#define CLAMP12(t) (((t) < 3071) ? (uint16) (t) : 3071)\n\n    if (n >= stride) {\n\tmask = CODE_MASK;\n\tif (stride == 3) {\n\t    t0 = ToLinearF[cr = (wp[0] & mask)] * SCALE12;\n\t    t1 = ToLinearF[cg = (wp[1] & mask)] * SCALE12;\n\t    t2 = ToLinearF[cb = (wp[2] & mask)] * SCALE12;\n\t    op[0] = CLAMP12(t0);\n\t    op[1] = CLAMP12(t1);\n\t    op[2] = CLAMP12(t2);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\twp += 3;\n\t\top += 3;\n\t\tn -= 3;\n\t\tt0 = ToLinearF[(cr += wp[0]) & mask] * SCALE12;\n\t\tt1 = ToLinearF[(cg += wp[1]) & mask] * SCALE12;\n\t\tt2 = ToLinearF[(cb += wp[2]) & mask] * SCALE12;\n\t\top[0] = CLAMP12(t0);\n\t\top[1] = CLAMP12(t1);\n\t\top[2] = CLAMP12(t2);\n\t    }\n\t} else if (stride == 4) {\n\t    t0 = ToLinearF[cr = (wp[0] & mask)] * SCALE12;\n\t    t1 = ToLinearF[cg = (wp[1] & mask)] * SCALE12;\n\t    t2 = ToLinearF[cb = (wp[2] & mask)] * SCALE12;\n\t    t3 = ToLinearF[ca = (wp[3] & mask)] * SCALE12;\n\t    op[0] = CLAMP12(t0);\n\t    op[1] = CLAMP12(t1);\n\t    op[2] = CLAMP12(t2);\n\t    op[3] = CLAMP12(t3);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\twp += 4;\n\t\top += 4;\n\t\tn -= 4;\n\t\tt0 = ToLinearF[(cr += wp[0]) & mask] * SCALE12;\n\t\tt1 = ToLinearF[(cg += wp[1]) & mask] * SCALE12;\n\t\tt2 = ToLinearF[(cb += wp[2]) & mask] * SCALE12;\n\t\tt3 = ToLinearF[(ca += wp[3]) & mask] * SCALE12;\n\t\top[0] = CLAMP12(t0);\n\t\top[1] = CLAMP12(t1);\n\t\top[2] = CLAMP12(t2);\n\t\top[3] = CLAMP12(t3);\n\t    }\n\t} else {\n\t    REPEAT(stride, t0 = ToLinearF[*wp&mask] * SCALE12;\n                           *op = CLAMP12(t0); wp++; op++)\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride,\n\t\t    wp[stride] += *wp; t0 = ToLinearF[wp[stride]&mask]*SCALE12;\n\t\t    *op = CLAMP12(t0);  wp++; op++)\n\t\tn -= stride;\n\t    }\n\t}\n    }\n}",
          "fn_code_pos": [
            [
              173,
              0
            ],
            [
              239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horizontalAccumulate12",
            "parameters": {
              "wp": "uint16",
              "n": "int",
              "stride": "int",
              "op": "int16",
              "ToLinearF": "float"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nhorizontalAccumulate16(uint16 *wp, int n, int stride, uint16 *op,\n\tuint16 *ToLinear16)\n{\n    register unsigned int  cr, cg, cb, ca, mask;\n\n    if (n >= stride) {\n\tmask = CODE_MASK;\n\tif (stride == 3) {\n\t    op[0] = ToLinear16[cr = (wp[0] & mask)];\n\t    op[1] = ToLinear16[cg = (wp[1] & mask)];\n\t    op[2] = ToLinear16[cb = (wp[2] & mask)];\n\t    n -= 3;\n\t    while (n > 0) {\n\t\twp += 3;\n\t\top += 3;\n\t\tn -= 3;\n\t\top[0] = ToLinear16[(cr += wp[0]) & mask];\n\t\top[1] = ToLinear16[(cg += wp[1]) & mask];\n\t\top[2] = ToLinear16[(cb += wp[2]) & mask];\n\t    }\n\t} else if (stride == 4) {\n\t    op[0] = ToLinear16[cr = (wp[0] & mask)];\n\t    op[1] = ToLinear16[cg = (wp[1] & mask)];\n\t    op[2] = ToLinear16[cb = (wp[2] & mask)];\n\t    op[3] = ToLinear16[ca = (wp[3] & mask)];\n\t    n -= 4;\n\t    while (n > 0) {\n\t\twp += 4;\n\t\top += 4;\n\t\tn -= 4;\n\t\top[0] = ToLinear16[(cr += wp[0]) & mask];\n\t\top[1] = ToLinear16[(cg += wp[1]) & mask];\n\t\top[2] = ToLinear16[(cb += wp[2]) & mask];\n\t\top[3] = ToLinear16[(ca += wp[3]) & mask];\n\t    }\n\t} else {\n\t    REPEAT(stride, *op = ToLinear16[*wp&mask]; wp++; op++)\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride,\n\t\t    wp[stride] += *wp; *op = ToLinear16[*wp&mask]; wp++; op++)\n\t\tn -= stride;\n\t    }\n\t}\n    }\n}",
          "fn_code_pos": [
            [
              241,
              0
            ],
            [
              287,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horizontalAccumulate16",
            "parameters": {
              "wp": "uint16",
              "n": "int",
              "stride": "int",
              "op": "uint16",
              "ToLinear16": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nhorizontalAccumulate11(uint16 *wp, int n, int stride, uint16 *op)\n{\n    register unsigned int cr, cg, cb, ca, mask;\n\n    if (n >= stride) {\n\tmask = CODE_MASK;\n\tif (stride == 3) {\n\t    op[0] = wp[0];  op[1] = wp[1];  op[2] = wp[2];\n            cr = wp[0];  cg = wp[1];  cb = wp[2];\n\t    n -= 3;\n\t    while (n > 0) {\n\t\twp += 3;\n\t\top += 3;\n\t\tn -= 3;\n\t\top[0] = (uint16)((cr += wp[0]) & mask);\n\t\top[1] = (uint16)((cg += wp[1]) & mask);\n\t\top[2] = (uint16)((cb += wp[2]) & mask);\n\t    }\n\t} else if (stride == 4) {\n\t    op[0] = wp[0];  op[1] = wp[1];\n\t    op[2] = wp[2];  op[3] = wp[3];\n            cr = wp[0]; cg = wp[1]; cb = wp[2]; ca = wp[3];\n\t    n -= 4;\n\t    while (n > 0) {\n\t\twp += 4;\n\t\top += 4;\n\t\tn -= 4;\n\t\top[0] = (uint16)((cr += wp[0]) & mask);\n\t\top[1] = (uint16)((cg += wp[1]) & mask);\n\t\top[2] = (uint16)((cb += wp[2]) & mask);\n\t\top[3] = (uint16)((ca += wp[3]) & mask);\n\t    } \n\t} else {\n\t    REPEAT(stride, *op = *wp&mask; wp++; op++)\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride,\n\t\t    wp[stride] += *wp; *op = *wp&mask; wp++; op++)\n\t\tn -= stride;\n\t    }\n\t}\n    }\n}",
          "fn_code_pos": [
            [
              293,
              0
            ],
            [
              336,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horizontalAccumulate11",
            "parameters": {
              "wp": "uint16",
              "n": "int",
              "stride": "int",
              "op": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nhorizontalAccumulate8(uint16 *wp, int n, int stride, unsigned char *op,\n\tunsigned char *ToLinear8)\n{\n    register unsigned int  cr, cg, cb, ca, mask;\n\n    if (n >= stride) {\n\tmask = CODE_MASK;\n\tif (stride == 3) {\n\t    op[0] = ToLinear8[cr = (wp[0] & mask)];\n\t    op[1] = ToLinear8[cg = (wp[1] & mask)];\n\t    op[2] = ToLinear8[cb = (wp[2] & mask)];\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\top += 3;\n\t\top[0] = ToLinear8[(cr += wp[0]) & mask];\n\t\top[1] = ToLinear8[(cg += wp[1]) & mask];\n\t\top[2] = ToLinear8[(cb += wp[2]) & mask];\n\t    }\n\t} else if (stride == 4) {\n\t    op[0] = ToLinear8[cr = (wp[0] & mask)];\n\t    op[1] = ToLinear8[cg = (wp[1] & mask)];\n\t    op[2] = ToLinear8[cb = (wp[2] & mask)];\n\t    op[3] = ToLinear8[ca = (wp[3] & mask)];\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\top += 4;\n\t\top[0] = ToLinear8[(cr += wp[0]) & mask];\n\t\top[1] = ToLinear8[(cg += wp[1]) & mask];\n\t\top[2] = ToLinear8[(cb += wp[2]) & mask];\n\t\top[3] = ToLinear8[(ca += wp[3]) & mask];\n\t    }\n\t} else {\n\t    REPEAT(stride, *op = ToLinear8[*wp&mask]; wp++; op++)\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride,\n\t\t    wp[stride] += *wp; *op = ToLinear8[*wp&mask]; wp++; op++)\n\t\tn -= stride;\n\t    }\n\t}\n    }\n}",
          "fn_code_pos": [
            [
              338,
              0
            ],
            [
              384,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horizontalAccumulate8",
            "parameters": {
              "wp": "uint16",
              "n": "int",
              "stride": "int",
              "op": "unsigned char",
              "ToLinear8": "unsigned char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nhorizontalAccumulate8abgr(uint16 *wp, int n, int stride, unsigned char *op,\n\tunsigned char *ToLinear8)\n{\n    register unsigned int  cr, cg, cb, ca, mask;\n    register unsigned char  t0, t1, t2, t3;\n\n    if (n >= stride) {\n\tmask = CODE_MASK;\n\tif (stride == 3) {\n\t    op[0] = 0;\n\t    t1 = ToLinear8[cb = (wp[2] & mask)];\n\t    t2 = ToLinear8[cg = (wp[1] & mask)];\n\t    t3 = ToLinear8[cr = (wp[0] & mask)];\n\t    op[1] = t1;\n\t    op[2] = t2;\n\t    op[3] = t3;\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\top += 4;\n\t\top[0] = 0;\n\t\tt1 = ToLinear8[(cb += wp[2]) & mask];\n\t\tt2 = ToLinear8[(cg += wp[1]) & mask];\n\t\tt3 = ToLinear8[(cr += wp[0]) & mask];\n\t\top[1] = t1;\n\t\top[2] = t2;\n\t\top[3] = t3;\n\t    }\n\t} else if (stride == 4) {\n\t    t0 = ToLinear8[ca = (wp[3] & mask)];\n\t    t1 = ToLinear8[cb = (wp[2] & mask)];\n\t    t2 = ToLinear8[cg = (wp[1] & mask)];\n\t    t3 = ToLinear8[cr = (wp[0] & mask)];\n\t    op[0] = t0;\n\t    op[1] = t1;\n\t    op[2] = t2;\n\t    op[3] = t3;\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\top += 4;\n\t\tt0 = ToLinear8[(ca += wp[3]) & mask];\n\t\tt1 = ToLinear8[(cb += wp[2]) & mask];\n\t\tt2 = ToLinear8[(cg += wp[1]) & mask];\n\t\tt3 = ToLinear8[(cr += wp[0]) & mask];\n\t\top[0] = t0;\n\t\top[1] = t1;\n\t\top[2] = t2;\n\t\top[3] = t3;\n\t    }\n\t} else {\n\t    REPEAT(stride, *op = ToLinear8[*wp&mask]; wp++; op++)\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride,\n\t\t    wp[stride] += *wp; *op = ToLinear8[*wp&mask]; wp++; op++)\n\t\tn -= stride;\n\t    }\n\t}\n    }\n}",
          "fn_code_pos": [
            [
              387,
              0
            ],
            [
              450,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horizontalAccumulate8abgr",
            "parameters": {
              "wp": "uint16",
              "n": "int",
              "stride": "int",
              "op": "unsigned char",
              "ToLinear8": "unsigned char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nPixarLogMakeTables(PixarLogState *sp)\n{\n\n/*\n *    We make several tables here to convert between various external\n *    representations (float, 16-bit, and 8-bit) and the internal\n *    11-bit companded representation.  The 11-bit representation has two\n *    distinct regions.  A linear bottom end up through .018316 in steps\n *    of about .000073, and a region of constant ratio up to about 25.\n *    These floating point numbers are stored in the main table ToLinearF. \n *    All other tables are derived from this one.  The tables (and the\n *    ratios) are continuous at the internal seam.\n */\n\n    int  nlin, lt2size;\n    int  i, j;\n    double  b, c, linstep, v;\n    float *ToLinearF;\n    uint16 *ToLinear16;\n    unsigned char *ToLinear8;\n    uint16  *FromLT2;\n    uint16  *From14; /* Really for 16-bit data, but we shift down 2 */\n    uint16  *From8;\n\n    c = log(RATIO);\t\n    nlin = (int)(1./c);\t/* nlin must be an integer */\n    c = 1./nlin;\n    b = exp(-c*ONE);\t/* multiplicative scale factor [b*exp(c*ONE) = 1] */\n    linstep = b*c*exp(1.);\n\n    LogK1 = (float)(1./c);\t/* if (v >= 2)  token = k1*log(v*k2) */\n    LogK2 = (float)(1./b);\n    lt2size = (int)(2./linstep) + 1;\n    FromLT2 = (uint16 *)_TIFFmalloc(lt2size*sizeof(uint16));\n    From14 = (uint16 *)_TIFFmalloc(16384*sizeof(uint16));\n    From8 = (uint16 *)_TIFFmalloc(256*sizeof(uint16));\n    ToLinearF = (float *)_TIFFmalloc(TSIZEP1 * sizeof(float));\n    ToLinear16 = (uint16 *)_TIFFmalloc(TSIZEP1 * sizeof(uint16));\n    ToLinear8 = (unsigned char *)_TIFFmalloc(TSIZEP1 * sizeof(unsigned char));\n    if (FromLT2 == NULL || From14  == NULL || From8   == NULL ||\n\t ToLinearF == NULL || ToLinear16 == NULL || ToLinear8 == NULL) {\n\tif (FromLT2) _TIFFfree(FromLT2);\n\tif (From14) _TIFFfree(From14);\n\tif (From8) _TIFFfree(From8);\n\tif (ToLinearF) _TIFFfree(ToLinearF);\n\tif (ToLinear16) _TIFFfree(ToLinear16);\n\tif (ToLinear8) _TIFFfree(ToLinear8);\n\tsp->FromLT2 = NULL;\n\tsp->From14 = NULL;\n\tsp->From8 = NULL;\n\tsp->ToLinearF = NULL;\n\tsp->ToLinear16 = NULL;\n\tsp->ToLinear8 = NULL;\n\treturn 0;\n    }\n\n    j = 0;\n\n    for (i = 0; i < nlin; i++)  {\n\tv = i * linstep;\n\tToLinearF[j++] = (float)v;\n    }\n\n    for (i = nlin; i < TSIZE; i++)\n\tToLinearF[j++] = (float)(b*exp(c*i));\n\n    ToLinearF[2048] = ToLinearF[2047];\n\n    for (i = 0; i < TSIZEP1; i++)  {\n\tv = ToLinearF[i]*65535.0 + 0.5;\n\tToLinear16[i] = (v > 65535.0) ? 65535 : (uint16)v;\n\tv = ToLinearF[i]*255.0  + 0.5;\n\tToLinear8[i]  = (v > 255.0) ? 255 : (unsigned char)v;\n    }\n\n    j = 0;\n    for (i = 0; i < lt2size; i++)  {\n\tif ((i*linstep)*(i*linstep) > ToLinearF[j]*ToLinearF[j+1])\n\t    j++;\n\tFromLT2[i] = (uint16)j;\n    }\n\n    /*\n     * Since we lose info anyway on 16-bit data, we set up a 14-bit\n     * table and shift 16-bit values down two bits on input.\n     * saves a little table space.\n     */\n    j = 0;\n    for (i = 0; i < 16384; i++)  {\n\twhile ((i/16383.)*(i/16383.) > ToLinearF[j]*ToLinearF[j+1])\n\t    j++;\n\tFrom14[i] = (uint16)j;\n    }\n\n    j = 0;\n    for (i = 0; i < 256; i++)  {\n\twhile ((i/255.)*(i/255.) > ToLinearF[j]*ToLinearF[j+1])\n\t    j++;\n\tFrom8[i] = (uint16)j;\n    }\n\n    Fltsize = (float)(lt2size/2);\n\n    sp->ToLinearF = ToLinearF;\n    sp->ToLinear16 = ToLinear16;\n    sp->ToLinear8 = ToLinear8;\n    sp->FromLT2 = FromLT2;\n    sp->From14 = From14;\n    sp->From8 = From8;\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              479,
              0
            ],
            [
              591,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixarLogMakeTables",
            "parameters": {
              "sp": "PixarLogState"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPixarLogGuessDataFmt(TIFFDirectory *td)\n{\n\tint guess = PIXARLOGDATAFMT_UNKNOWN;\n\tint format = td->td_sampleformat;\n\n\t/* If the user didn't tell us his datafmt,\n\t * take our best guess from the bitspersample.\n\t */\n\tswitch (td->td_bitspersample) {\n\t case 32:\n\t\tif (format == SAMPLEFORMAT_IEEEFP)\n\t\t\tguess = PIXARLOGDATAFMT_FLOAT;\n\t\tbreak;\n\t case 16:\n\t\tif (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_UINT)\n\t\t\tguess = PIXARLOGDATAFMT_16BIT;\n\t\tbreak;\n\t case 12:\n\t\tif (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_INT)\n\t\t\tguess = PIXARLOGDATAFMT_12BITPICIO;\n\t\tbreak;\n\t case 11:\n\t\tif (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_UINT)\n\t\t\tguess = PIXARLOGDATAFMT_11BITLOG;\n\t\tbreak;\n\t case 8:\n\t\tif (format == SAMPLEFORMAT_VOID || format == SAMPLEFORMAT_UINT)\n\t\t\tguess = PIXARLOGDATAFMT_8BIT;\n\t\tbreak;\n\t}\n\n\treturn guess;\n}",
          "fn_code_pos": [
            [
              601,
              0
            ],
            [
              634,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixarLogGuessDataFmt",
            "parameters": {
              "td": "TIFFDirectory"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static tmsize_t\nmultiply_ms(tmsize_t m1, tmsize_t m2)\n{\n        if( m1 == 0 || m2 > TIFF_TMSIZE_T_MAX / m1 )\n            return 0;\n        return m1 * m2;\n}",
          "fn_code_pos": [
            [
              639,
              0
            ],
            [
              645,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "multiply_ms",
            "parameters": {
              "m1": "tmsize_t",
              "m2": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static tmsize_t\nadd_ms(tmsize_t m1, tmsize_t m2)\n{\n\t/* if either input is zero, assume overflow already occurred */\n\tif (m1 == 0 || m2 == 0)\n\t\treturn 0;\n\telse if (m1 > TIFF_TMSIZE_T_MAX - m2)\n\t\treturn 0;\n\n\treturn m1 + m2;\n}",
          "fn_code_pos": [
            [
              647,
              0
            ],
            [
              657,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "add_ms",
            "parameters": {
              "m1": "tmsize_t",
              "m2": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static int\nPixarLogFixupTags(TIFF* tif)\n{\n\t(void) tif;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              659,
              0
            ],
            [
              664,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixarLogFixupTags",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPixarLogSetupDecode(TIFF* tif)\n{\n\tstatic const char module[] = \"PixarLogSetupDecode\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tPixarLogState* sp = DecoderState(tif);\n\ttmsize_t tbuf_size;\n        uint32 strip_height;\n\n\tassert(sp != NULL);\n\n\t/* This function can possibly be called several times by */\n\t/* PredictorSetupDecode() if this function succeeds but */\n\t/* PredictorSetup() fails */\n\tif( (sp->state & PLSTATE_INIT) != 0 )\n\t\treturn 1;\n\n        strip_height = td->td_rowsperstrip;\n        if( strip_height > td->td_imagelength )\n            strip_height = td->td_imagelength;\n\n\t/* Make sure no byte swapping happens on the data\n\t * after decompression. */\n\ttif->tif_postdecode = _TIFFNoPostDecode;  \n\n\t/* for some reason, we can't do this in TIFFInitPixarLog */\n\n\tsp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?\n\t    td->td_samplesperpixel : 1);\n\ttbuf_size = multiply_ms(multiply_ms(multiply_ms(sp->stride, td->td_imagewidth),\n\t\t\t\t      strip_height), sizeof(uint16));\n\t/* add one more stride in case input ends mid-stride */\n\ttbuf_size = add_ms(tbuf_size, sizeof(uint16) * sp->stride);\n\tif (tbuf_size == 0)\n\t\treturn (0);   /* TODO: this is an error return without error report through TIFFErrorExt */\n\tsp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size);\n\tif (sp->tbuf == NULL)\n\t\treturn (0);\n\tsp->tbuf_size = tbuf_size;\n\tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN)\n\t\tsp->user_datafmt = PixarLogGuessDataFmt(td);\n\tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) {\n                _TIFFfree(sp->tbuf);\n                sp->tbuf = NULL;\n                sp->tbuf_size = 0;\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"PixarLog compression can't handle bits depth/data format combination (depth: %d)\", \n\t\t\ttd->td_bitspersample);\n\t\treturn (0);\n\t}\n\n\tif (inflateInit(&sp->stream) != Z_OK) {\n                _TIFFfree(sp->tbuf);\n                sp->tbuf = NULL;\n                sp->tbuf_size = 0;\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s\", sp->stream.msg ? sp->stream.msg : \"(null)\");\n\t\treturn (0);\n\t} else {\n\t\tsp->state |= PLSTATE_INIT;\n\t\treturn (1);\n\t}\n}",
          "fn_code_pos": [
            [
              666,
              0
            ],
            [
              727,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixarLogSetupDecode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPixarLogPreDecode(TIFF* tif, uint16 s)\n{\n\tstatic const char module[] = \"PixarLogPreDecode\";\n\tPixarLogState* sp = DecoderState(tif);\n\n\t(void) s;\n\tassert(sp != NULL);\n\tsp->stream.next_in = tif->tif_rawdata;\n\tassert(sizeof(sp->stream.avail_in)==4);  /* if this assert gets raised,\n\t    we need to simplify this code to reflect a ZLib that is likely updated\n\t    to deal with 8byte memory sizes, though this code will respond\n\t    appropriately even before we simplify it */\n\tsp->stream.avail_in = (uInt) tif->tif_rawcc;\n\tif ((tmsize_t)sp->stream.avail_in != tif->tif_rawcc)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\");\n\t\treturn (0);\n\t}\n\treturn (inflateReset(&sp->stream) == Z_OK);\n}",
          "fn_code_pos": [
            [
              732,
              0
            ],
            [
              752,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixarLogPreDecode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"PixarLogDecode\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tPixarLogState* sp = DecoderState(tif);\n\ttmsize_t i;\n\ttmsize_t nsamples;\n\tint llen;\n\tuint16 *up;\n\n\tswitch (sp->user_datafmt) {\n\tcase PIXARLOGDATAFMT_FLOAT:\n\t\tnsamples = occ / sizeof(float);\t/* XXX float == 32 bits */\n\t\tbreak;\n\tcase PIXARLOGDATAFMT_16BIT:\n\tcase PIXARLOGDATAFMT_12BITPICIO:\n\tcase PIXARLOGDATAFMT_11BITLOG:\n\t\tnsamples = occ / sizeof(uint16); /* XXX uint16 == 16 bits */\n\t\tbreak;\n\tcase PIXARLOGDATAFMT_8BIT:\n\tcase PIXARLOGDATAFMT_8BITABGR:\n\t\tnsamples = occ;\n\t\tbreak;\n\tdefault:\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"%d bit input not supported in PixarLog\",\n\t\t\ttd->td_bitspersample);\n\t\treturn 0;\n\t}\n\n\tllen = sp->stride * td->td_imagewidth;\n\n\t(void) s;\n\tassert(sp != NULL);\n\n        sp->stream.next_in = tif->tif_rawcp;\n\tsp->stream.avail_in = (uInt) tif->tif_rawcc;\n\n\tsp->stream.next_out = (unsigned char *) sp->tbuf;\n\tassert(sizeof(sp->stream.avail_out)==4);  /* if this assert gets raised,\n\t    we need to simplify this code to reflect a ZLib that is likely updated\n\t    to deal with 8byte memory sizes, though this code will respond\n\t    appropriately even before we simplify it */\n\tsp->stream.avail_out = (uInt) (nsamples * sizeof(uint16));\n\tif (sp->stream.avail_out != nsamples * sizeof(uint16))\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\");\n\t\treturn (0);\n\t}\n\t/* Check that we will not fill more than what was allocated */\n\tif ((tmsize_t)sp->stream.avail_out > sp->tbuf_size)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"sp->stream.avail_out > sp->tbuf_size\");\n\t\treturn (0);\n\t}\n\tdo {\n\t\tint state = inflate(&sp->stream, Z_PARTIAL_FLUSH);\n\t\tif (state == Z_STREAM_END) {\n\t\t\tbreak;\t\t\t/* XXX */\n\t\t}\n\t\tif (state == Z_DATA_ERROR) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Decoding error at scanline %lu, %s\",\n\t\t\t    (unsigned long) tif->tif_row, sp->stream.msg ? sp->stream.msg : \"(null)\");\n\t\t\t/* if (inflateSync(&sp->stream) != Z_OK) */\n\t\t\treturn (0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (state != Z_OK) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"ZLib error: %s\",\n\t\t\t    sp->stream.msg ? sp->stream.msg : \"(null)\");\n\t\t\treturn (0);\n\t\t}\n\t} while (sp->stream.avail_out > 0);\n\n\t/* hopefully, we got all the bytes we needed */\n\tif (sp->stream.avail_out != 0) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Not enough data at scanline %lu (short \" TIFF_UINT64_FORMAT \" bytes)\",\n\t\t    (unsigned long) tif->tif_row, (TIFF_UINT64_T) sp->stream.avail_out);\n\t\treturn (0);\n\t}\n\n        tif->tif_rawcp = sp->stream.next_in;\n        tif->tif_rawcc = sp->stream.avail_in;\n\n\tup = sp->tbuf;\n\t/* Swap bytes in the data if from a different endian machine. */\n\tif (tif->tif_flags & TIFF_SWAB)\n\t\tTIFFSwabArrayOfShort(up, nsamples);\n\n\t/*\n\t * if llen is not an exact multiple of nsamples, the decode operation\n\t * may overflow the output buffer, so truncate it enough to prevent\n\t * that but still salvage as much data as possible.\n\t */\n\tif (nsamples % llen) { \n\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"stride %lu is not a multiple of sample count, \"\n\t\t\t\"%lu, data truncated.\", (unsigned long) llen, (unsigned long) nsamples);\n\t\tnsamples -= nsamples % llen;\n\t}\n\n\tfor (i = 0; i < nsamples; i += llen, up += llen) {\n\t\tswitch (sp->user_datafmt)  {\n\t\tcase PIXARLOGDATAFMT_FLOAT:\n\t\t\thorizontalAccumulateF(up, llen, sp->stride,\n\t\t\t\t\t(float *)op, sp->ToLinearF);\n\t\t\top += llen * sizeof(float);\n\t\t\tbreak;\n\t\tcase PIXARLOGDATAFMT_16BIT:\n\t\t\thorizontalAccumulate16(up, llen, sp->stride,\n\t\t\t\t\t(uint16 *)op, sp->ToLinear16);\n\t\t\top += llen * sizeof(uint16);\n\t\t\tbreak;\n\t\tcase PIXARLOGDATAFMT_12BITPICIO:\n\t\t\thorizontalAccumulate12(up, llen, sp->stride,\n\t\t\t\t\t(int16 *)op, sp->ToLinearF);\n\t\t\top += llen * sizeof(int16);\n\t\t\tbreak;\n\t\tcase PIXARLOGDATAFMT_11BITLOG:\n\t\t\thorizontalAccumulate11(up, llen, sp->stride,\n\t\t\t\t\t(uint16 *)op);\n\t\t\top += llen * sizeof(uint16);\n\t\t\tbreak;\n\t\tcase PIXARLOGDATAFMT_8BIT:\n\t\t\thorizontalAccumulate8(up, llen, sp->stride,\n\t\t\t\t\t(unsigned char *)op, sp->ToLinear8);\n\t\t\top += llen * sizeof(unsigned char);\n\t\t\tbreak;\n\t\tcase PIXARLOGDATAFMT_8BITABGR:\n\t\t\thorizontalAccumulate8abgr(up, llen, sp->stride,\n\t\t\t\t\t(unsigned char *)op, sp->ToLinear8);\n\t\t\top += llen * sizeof(unsigned char);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"Unsupported bits/sample: %d\",\n\t\t\t\t  td->td_bitspersample);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              754,
              0
            ],
            [
              899,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixarLogDecode",
            "parameters": {
              "tif": "TIFF",
              "op": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPixarLogSetupEncode(TIFF* tif)\n{\n\tstatic const char module[] = \"PixarLogSetupEncode\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tPixarLogState* sp = EncoderState(tif);\n\ttmsize_t tbuf_size;\n\n\tassert(sp != NULL);\n\n\t/* for some reason, we can't do this in TIFFInitPixarLog */\n\n\tsp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?\n\t    td->td_samplesperpixel : 1);\n\ttbuf_size = multiply_ms(multiply_ms(multiply_ms(sp->stride, td->td_imagewidth),\n\t\t\t\t      td->td_rowsperstrip), sizeof(uint16));\n\tif (tbuf_size == 0)\n\t\treturn (0);  /* TODO: this is an error return without error report through TIFFErrorExt */\n\tsp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size);\n\tif (sp->tbuf == NULL)\n\t\treturn (0);\n\tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN)\n\t\tsp->user_datafmt = PixarLogGuessDataFmt(td);\n\tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"PixarLog compression can't handle %d bit linear encodings\", td->td_bitspersample);\n\t\treturn (0);\n\t}\n\n\tif (deflateInit(&sp->stream, sp->quality) != Z_OK) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s\", sp->stream.msg ? sp->stream.msg : \"(null)\");\n\t\treturn (0);\n\t} else {\n\t\tsp->state |= PLSTATE_INIT;\n\t\treturn (1);\n\t}\n}",
          "fn_code_pos": [
            [
              901,
              0
            ],
            [
              936,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixarLogSetupEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPixarLogPreEncode(TIFF* tif, uint16 s)\n{\n\tstatic const char module[] = \"PixarLogPreEncode\";\n\tPixarLogState *sp = EncoderState(tif);\n\n\t(void) s;\n\tassert(sp != NULL);\n\tsp->stream.next_out = tif->tif_rawdata;\n\tassert(sizeof(sp->stream.avail_out)==4);  /* if this assert gets raised,\n\t    we need to simplify this code to reflect a ZLib that is likely updated\n\t    to deal with 8byte memory sizes, though this code will respond\n\t    appropriately even before we simplify it */\n\tsp->stream.avail_out = (uInt)tif->tif_rawdatasize;\n\tif ((tmsize_t)sp->stream.avail_out != tif->tif_rawdatasize)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\");\n\t\treturn (0);\n\t}\n\treturn (deflateReset(&sp->stream) == Z_OK);\n}",
          "fn_code_pos": [
            [
              941,
              0
            ],
            [
              961,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixarLogPreEncode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nhorizontalDifferenceF(float *ip, int n, int stride, uint16 *wp, uint16 *FromLT2)\n{\n    int32 r1, g1, b1, a1, r2, g2, b2, a2, mask;\n    float fltsize = Fltsize;\n\n#define  CLAMP(v) ( (v<(float)0.)   ? 0\t\t\t\t\\\n\t\t  : (v<(float)2.)   ? FromLT2[(int)(v*fltsize)]\t\\\n\t\t  : (v>(float)24.2) ? 2047\t\t\t\\\n\t\t  : LogK1*log(v*LogK2) + 0.5 )\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = (uint16) CLAMP(ip[0]);\n\t    g2 = wp[1] = (uint16) CLAMP(ip[1]);\n\t    b2 = wp[2] = (uint16) CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = (uint16) CLAMP(ip[0]);\n\t    g2 = wp[1] = (uint16) CLAMP(ip[1]);\n\t    b2 = wp[2] = (uint16) CLAMP(ip[2]);\n\t    a2 = wp[3] = (uint16) CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = (int32) CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n        REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]); wp++; ip++)\n        n -= stride;\n        while (n > 0) {\n            REPEAT(stride,\n                wp[0] = (uint16)(((int32)CLAMP(ip[0])-(int32)CLAMP(ip[-stride])) & mask);\n                wp++; ip++)\n            n -= stride;\n        }\n\t}\n    }\n}",
          "fn_code_pos": [
            [
              963,
              0
            ],
            [
              1015,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horizontalDifferenceF",
            "parameters": {
              "ip": "float",
              "n": "int",
              "stride": "int",
              "wp": "uint16",
              "FromLT2": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nhorizontalDifference16(unsigned short *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From14)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n\n/* assumption is unsigned pixel values */\n#undef   CLAMP\n#define  CLAMP(v) From14[(v) >> 2]\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n        REPEAT(stride, wp[0] = CLAMP(ip[0]); wp++; ip++)\n\t    n -= stride;\n\t    while (n > 0) {\n            REPEAT(stride,\n                wp[0] = (uint16)((CLAMP(ip[0])-CLAMP(ip[-stride])) & mask);\n                wp++; ip++)\n            n -= stride;\n        }\n\t}\n    }\n}",
          "fn_code_pos": [
            [
              1017,
              0
            ],
            [
              1065,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horizontalDifference16",
            "parameters": {
              "ip": "unsigned short",
              "n": "int",
              "stride": "int",
              "wp": "unsigned short",
              "From14": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nhorizontalDifference8(unsigned char *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From8)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n\n#undef\t CLAMP\n#define  CLAMP(v) (From8[(v)])\n\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\tr1 = CLAMP(ip[3]); wp[3] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[4]); wp[4] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[5]); wp[5] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\twp += 3;\n\t\tip += 3;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\tr1 = CLAMP(ip[4]); wp[4] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[5]); wp[5] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[6]); wp[6] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[7]); wp[7] = (uint16)((a1-a2) & mask); a2 = a1;\n\t\twp += 4;\n\t\tip += 4;\n\t    }\n\t} else {\n        REPEAT(stride, wp[0] = CLAMP(ip[0]); wp++; ip++)\n        n -= stride;\n        while (n > 0) {\n            REPEAT(stride,\n                wp[0] = (uint16)((CLAMP(ip[0])-CLAMP(ip[-stride])) & mask);\n                wp++; ip++)\n            n -= stride;\n        }\n    }\n    }\n}",
          "fn_code_pos": [
            [
              1068,
              0
            ],
            [
              1115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horizontalDifference8",
            "parameters": {
              "ip": "unsigned char",
              "n": "int",
              "stride": "int",
              "wp": "unsigned short",
              "From8": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nPixarLogEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\tstatic const char module[] = \"PixarLogEncode\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tPixarLogState *sp = EncoderState(tif);\n\ttmsize_t i;\n\ttmsize_t n;\n\tint llen;\n\tunsigned short * up;\n\n\t(void) s;\n\n\tswitch (sp->user_datafmt) {\n\tcase PIXARLOGDATAFMT_FLOAT:\n\t\tn = cc / sizeof(float);\t\t/* XXX float == 32 bits */\n\t\tbreak;\n\tcase PIXARLOGDATAFMT_16BIT:\n\tcase PIXARLOGDATAFMT_12BITPICIO:\n\tcase PIXARLOGDATAFMT_11BITLOG:\n\t\tn = cc / sizeof(uint16);\t/* XXX uint16 == 16 bits */\n\t\tbreak;\n\tcase PIXARLOGDATAFMT_8BIT:\n\tcase PIXARLOGDATAFMT_8BITABGR:\n\t\tn = cc;\n\t\tbreak;\n\tdefault:\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"%d bit input not supported in PixarLog\",\n\t\t\ttd->td_bitspersample);\n\t\treturn 0;\n\t}\n\n\tllen = sp->stride * td->td_imagewidth;\n    /* Check against the number of elements (of size uint16) of sp->tbuf */\n    if( n > (tmsize_t)(td->td_rowsperstrip * llen) )\n    {\n        TIFFErrorExt(tif->tif_clientdata, module,\n                     \"Too many input bytes provided\");\n        return 0;\n    }\n\n\tfor (i = 0, up = sp->tbuf; i < n; i += llen, up += llen) {\n\t\tswitch (sp->user_datafmt)  {\n\t\tcase PIXARLOGDATAFMT_FLOAT:\n\t\t\thorizontalDifferenceF((float *)bp, llen, \n\t\t\t\tsp->stride, up, sp->FromLT2);\n\t\t\tbp += llen * sizeof(float);\n\t\t\tbreak;\n\t\tcase PIXARLOGDATAFMT_16BIT:\n\t\t\thorizontalDifference16((uint16 *)bp, llen, \n\t\t\t\tsp->stride, up, sp->From14);\n\t\t\tbp += llen * sizeof(uint16);\n\t\t\tbreak;\n\t\tcase PIXARLOGDATAFMT_8BIT:\n\t\t\thorizontalDifference8((unsigned char *)bp, llen, \n\t\t\t\tsp->stride, up, sp->From8);\n\t\t\tbp += llen * sizeof(unsigned char);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%d bit input not supported in PixarLog\",\n\t\t\t\ttd->td_bitspersample);\n\t\t\treturn 0;\n\t\t}\n\t}\n \n\tsp->stream.next_in = (unsigned char *) sp->tbuf;\n\tassert(sizeof(sp->stream.avail_in)==4);  /* if this assert gets raised,\n\t    we need to simplify this code to reflect a ZLib that is likely updated\n\t    to deal with 8byte memory sizes, though this code will respond\n\t    appropriately even before we simplify it */\n\tsp->stream.avail_in = (uInt) (n * sizeof(uint16));\n\tif ((sp->stream.avail_in / sizeof(uint16)) != (uInt) n)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"ZLib cannot deal with buffers this size\");\n\t\treturn (0);\n\t}\n\n\tdo {\n\t\tif (deflate(&sp->stream, Z_NO_FLUSH) != Z_OK) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Encoder error: %s\",\n\t\t\t    sp->stream.msg ? sp->stream.msg : \"(null)\");\n\t\t\treturn (0);\n\t\t}\n\t\tif (sp->stream.avail_out == 0) {\n\t\t\ttif->tif_rawcc = tif->tif_rawdatasize;\n\t\t\tTIFFFlushData1(tif);\n\t\t\tsp->stream.next_out = tif->tif_rawdata;\n\t\t\tsp->stream.avail_out = (uInt) tif->tif_rawdatasize;  /* this is a safe typecast, as check is made already in PixarLogPreEncode */\n\t\t}\n\t} while (sp->stream.avail_in > 0);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1120,
              0
            ],
            [
              1214,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixarLogEncode",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPixarLogPostEncode(TIFF* tif)\n{\n\tstatic const char module[] = \"PixarLogPostEncode\";\n\tPixarLogState *sp = EncoderState(tif);\n\tint state;\n\n\tsp->stream.avail_in = 0;\n\n\tdo {\n\t\tstate = deflate(&sp->stream, Z_FINISH);\n\t\tswitch (state) {\n\t\tcase Z_STREAM_END:\n\t\tcase Z_OK:\n\t\t    if ((tmsize_t)sp->stream.avail_out != tif->tif_rawdatasize) {\n\t\t\t    tif->tif_rawcc =\n\t\t\t\ttif->tif_rawdatasize - sp->stream.avail_out;\n\t\t\t    TIFFFlushData1(tif);\n\t\t\t    sp->stream.next_out = tif->tif_rawdata;\n\t\t\t    sp->stream.avail_out = (uInt) tif->tif_rawdatasize;  /* this is a safe typecast, as check is made already in PixarLogPreEncode */\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"ZLib error: %s\",\n\t\t\tsp->stream.msg ? sp->stream.msg : \"(null)\");\n\t\t    return (0);\n\t\t}\n\t} while (state != Z_STREAM_END);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1221,
              0
            ],
            [
              1250,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixarLogPostEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nPixarLogClose(TIFF* tif)\n{\n        PixarLogState* sp = (PixarLogState*) tif->tif_data;\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\tassert(sp != 0);\n\t/* In a really sneaky (and really incorrect, and untruthful, and\n\t * troublesome, and error-prone) maneuver that completely goes against\n\t * the spirit of TIFF, and breaks TIFF, on close, we covertly\n\t * modify both bitspersample and sampleformat in the directory to\n\t * indicate 8-bit linear.  This way, the decode \"just works\" even for\n\t * readers that don't know about PixarLog, or how to set\n\t * the PIXARLOGDATFMT pseudo-tag.\n\t */\n\n        if (sp->state&PLSTATE_INIT) {\n            /* We test the state to avoid an issue such as in\n             * http://bugzilla.maptools.org/show_bug.cgi?id=2604\n             * What appends in that case is that the bitspersample is 1 and\n             * a TransferFunction is set. The size of the TransferFunction\n             * depends on 1<<bitspersample. So if we increase it, an access\n             * out of the buffer will happen at directory flushing.\n             * Another option would be to clear those targs. \n             */\n            td->td_bitspersample = 8;\n            td->td_sampleformat = SAMPLEFORMAT_UINT;\n        }\n}",
          "fn_code_pos": [
            [
              1252,
              0
            ],
            [
              1280,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixarLogClose",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nPixarLogCleanup(TIFF* tif)\n{\n\tPixarLogState* sp = (PixarLogState*) tif->tif_data;\n\n\tassert(sp != 0);\n\n\t(void)TIFFPredictorCleanup(tif);\n\n\ttif->tif_tagmethods.vgetfield = sp->vgetparent;\n\ttif->tif_tagmethods.vsetfield = sp->vsetparent;\n\n\tif (sp->FromLT2) _TIFFfree(sp->FromLT2);\n\tif (sp->From14) _TIFFfree(sp->From14);\n\tif (sp->From8) _TIFFfree(sp->From8);\n\tif (sp->ToLinearF) _TIFFfree(sp->ToLinearF);\n\tif (sp->ToLinear16) _TIFFfree(sp->ToLinear16);\n\tif (sp->ToLinear8) _TIFFfree(sp->ToLinear8);\n\tif (sp->state&PLSTATE_INIT) {\n\t\tif (tif->tif_mode == O_RDONLY)\n\t\t\tinflateEnd(&sp->stream);\n\t\telse\n\t\t\tdeflateEnd(&sp->stream);\n\t}\n\tif (sp->tbuf)\n\t\t_TIFFfree(sp->tbuf);\n\t_TIFFfree(sp);\n\ttif->tif_data = NULL;\n\n\t_TIFFSetDefaultCompressionState(tif);\n}",
          "fn_code_pos": [
            [
              1282,
              0
            ],
            [
              1312,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixarLogCleanup",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nPixarLogVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n    static const char module[] = \"PixarLogVSetField\";\n    PixarLogState *sp = (PixarLogState *)tif->tif_data;\n    int result;\n\n    switch (tag) {\n     case TIFFTAG_PIXARLOGQUALITY:\n\t\tsp->quality = (int) va_arg(ap, int);\n\t\tif (tif->tif_mode != O_RDONLY && (sp->state&PLSTATE_INIT)) {\n\t\t\tif (deflateParams(&sp->stream,\n\t\t\t    sp->quality, Z_DEFAULT_STRATEGY) != Z_OK) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"ZLib error: %s\",\n\t\t\t\t\tsp->stream.msg ? sp->stream.msg : \"(null)\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\treturn (1);\n     case TIFFTAG_PIXARLOGDATAFMT:\n\tsp->user_datafmt = (int) va_arg(ap, int);\n\t/* Tweak the TIFF header so that the rest of libtiff knows what\n\t * size of data will be passed between app and library, and\n\t * assume that the app knows what it is doing and is not\n\t * confused by these header manipulations...\n\t */\n\tswitch (sp->user_datafmt) {\n\t case PIXARLOGDATAFMT_8BIT:\n\t case PIXARLOGDATAFMT_8BITABGR:\n\t    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n\t    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\t    break;\n\t case PIXARLOGDATAFMT_11BITLOG:\n\t    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);\n\t    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\t    break;\n\t case PIXARLOGDATAFMT_12BITPICIO:\n\t    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);\n\t    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\n\t    break;\n\t case PIXARLOGDATAFMT_16BIT:\n\t    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 16);\n\t    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\t    break;\n\t case PIXARLOGDATAFMT_FLOAT:\n\t    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 32);\n\t    TIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n\t    break;\n\t}\n\t/*\n\t * Must recalculate sizes should bits/sample change.\n\t */\n\ttif->tif_tilesize = isTiled(tif) ? TIFFTileSize(tif) : (tmsize_t)(-1);\n\ttif->tif_scanlinesize = TIFFScanlineSize(tif);\n\tresult = 1;\t\t/* NB: pseudo tag */\n\tbreak;\n     default:\n\tresult = (*sp->vsetparent)(tif, tag, ap);\n    }\n    return (result);\n}",
          "fn_code_pos": [
            [
              1314,
              0
            ],
            [
              1374,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixarLogVSetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPixarLogVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n    PixarLogState *sp = (PixarLogState *)tif->tif_data;\n\n    switch (tag) {\n     case TIFFTAG_PIXARLOGQUALITY:\n\t*va_arg(ap, int*) = sp->quality;\n\tbreak;\n     case TIFFTAG_PIXARLOGDATAFMT:\n\t*va_arg(ap, int*) = sp->user_datafmt;\n\tbreak;\n     default:\n\treturn (*sp->vgetparent)(tif, tag, ap);\n    }\n    return (1);\n}",
          "fn_code_pos": [
            [
              1376,
              0
            ],
            [
              1392,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixarLogVGetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFInitPixarLog(TIFF* tif, int scheme)\n{\n\tstatic const char module[] = \"TIFFInitPixarLog\";\n\n\tPixarLogState* sp;\n\n\tassert(scheme == COMPRESSION_PIXARLOG);\n\n\t/*\n\t * Merge codec-specific tag information.\n\t */\n\tif (!_TIFFMergeFields(tif, pixarlogFields,\n\t\t\t      TIFFArrayCount(pixarlogFields))) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Merging PixarLog codec-specific tags failed\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate state block so tag methods have storage to record values.\n\t */\n\ttif->tif_data = (uint8*) _TIFFmalloc(sizeof (PixarLogState));\n\tif (tif->tif_data == NULL)\n\t\tgoto bad;\n\tsp = (PixarLogState*) tif->tif_data;\n\t_TIFFmemset(sp, 0, sizeof (*sp));\n\tsp->stream.data_type = Z_BINARY;\n\tsp->user_datafmt = PIXARLOGDATAFMT_UNKNOWN;\n\n\t/*\n\t * Install codec methods.\n\t */\n\ttif->tif_fixuptags = PixarLogFixupTags; \n\ttif->tif_setupdecode = PixarLogSetupDecode;\n\ttif->tif_predecode = PixarLogPreDecode;\n\ttif->tif_decoderow = PixarLogDecode;\n\ttif->tif_decodestrip = PixarLogDecode;  \n\ttif->tif_decodetile = PixarLogDecode;\n\ttif->tif_setupencode = PixarLogSetupEncode;\n\ttif->tif_preencode = PixarLogPreEncode;\n\ttif->tif_postencode = PixarLogPostEncode;\n\ttif->tif_encoderow = PixarLogEncode;  \n\ttif->tif_encodestrip = PixarLogEncode;\n\ttif->tif_encodetile = PixarLogEncode;  \n\ttif->tif_close = PixarLogClose;\n\ttif->tif_cleanup = PixarLogCleanup;\n\n\t/* Override SetField so we can handle our private pseudo-tag */\n\tsp->vgetparent = tif->tif_tagmethods.vgetfield;\n\ttif->tif_tagmethods.vgetfield = PixarLogVGetField;   /* hook for codec tags */\n\tsp->vsetparent = tif->tif_tagmethods.vsetfield;\n\ttif->tif_tagmethods.vsetfield = PixarLogVSetField;   /* hook for codec tags */\n\n\t/* Default values for codec-specific fields */\n\tsp->quality = Z_DEFAULT_COMPRESSION; /* default comp. level */\n\tsp->state = 0;\n\n\t/* we don't wish to use the predictor, \n\t * the default is none, which predictor value 1\n\t */\n\t(void) TIFFPredictorInit(tif);\n\n\t/*\n\t * build the companding tables \n\t */\n\tPixarLogMakeTables(sp);\n\n\treturn (1);\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"No space for PixarLog state block\");\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1399,
              0
            ],
            [
              1472,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitPixarLog",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "PixarLogEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              596,
              11
            ],
            [
              596,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixarLogEncode",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)",
          "fn_dec_pos": [
            [
              597,
              11
            ],
            [
              597,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PixarLogDecode",
            "parameters": {
              "tif": "TIFF",
              "op": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef\tstruct {\n\tTIFFPredictorState\tpredict;\n\tz_stream\t\tstream;\n\ttmsize_t\t\ttbuf_size; /* only set/used on reading for now */\n\tuint16\t\t\t*tbuf; \n\tuint16\t\t\tstride;\n\tint\t\t\tstate;\n\tint\t\t\tuser_datafmt;\n\tint\t\t\tquality;\n#define PLSTATE_INIT 1\n\n\tTIFFVSetMethod\t\tvgetparent;\t/* super-class method */\n\tTIFFVSetMethod\t\tvsetparent;\t/* super-class method */\n\n\tfloat *ToLinearF;\n\tuint16 *ToLinear16;\n\tunsigned char *ToLinear8;\n\tuint16  *FromLT2;\n\tuint16  *From14; /* Really for 16-bit data, but we shift down 2 */\n\tuint16  *From8;\n\t\n} PixarLogState;",
          {
            "predict": "TIFFPredictorState",
            "stream": "z_stream",
            "tbuf_size": "tmsize_t",
            "*tbuf": "uint16",
            "stride": "uint16",
            "state": "int",
            "user_datafmt": "int",
            "quality": "int",
            "vgetparent": "TIFFVSetMethod",
            "vsetparent": "TIFFVSetMethod",
            "*ToLinearF": "float",
            "*ToLinear16": "uint16",
            "*ToLinear8": "unsigned char",
            "*FromLT2": "uint16",
            "*From14": "uint16",
            "*From8": "uint16"
          },
          "PixarLogState",
          [
            456,
            0
          ],
          [
            477,
            16
          ]
        ],
        [
          "typedef\tstruct {\n\tTIFFPredictorState\tpredict;\n\tz_stream\t\tstream;\n\ttmsize_t\t\ttbuf_size; /* only set/used on reading for now */\n\tuint16\t\t\t*tbuf; \n\tuint16\t\t\tstride;\n\tint\t\t\tstate;\n\tint\t\t\tuser_datafmt;\n\tint\t\t\tquality;\n#define PLSTATE_INIT 1\n\n\tTIFFVSetMethod\t\tvgetparent;\t/* super-class method */\n\tTIFFVSetMethod\t\tvsetparent;\t/* super-class method */\n\n\tfloat *ToLinearF;\n\tuint16 *ToLinear16;\n\tunsigned char *ToLinear8;\n\tuint16  *FromLT2;\n\tuint16  *From14; /* Really for 16-bit data, but we shift down 2 */\n\tuint16  *From8;\n\t\n} PixarLogState;",
          {
            "predict": "TIFFPredictorState",
            "stream": "z_stream",
            "tbuf_size": "tmsize_t",
            "*tbuf": "uint16",
            "stride": "uint16",
            "state": "int",
            "user_datafmt": "int",
            "quality": "int",
            "vgetparent": "TIFFVSetMethod",
            "vsetparent": "TIFFVSetMethod",
            "*ToLinearF": "float",
            "*ToLinear16": "uint16",
            "*ToLinear8": "unsigned char",
            "*FromLT2": "uint16",
            "*From14": "uint16",
            "*From8": "uint16"
          },
          "PixarLogState",
          [
            456,
            0
          ],
          [
            477,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"tif_predict.h\"\n",
          [
            89,
            0
          ],
          [
            90,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            90,
            0
          ],
          [
            91,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            92,
            0
          ],
          [
            93,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            93,
            0
          ],
          [
            94,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            94,
            0
          ],
          [
            95,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_thunder.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nThunderSetupDecode(TIFF* tif)\n{\n\tstatic const char module[] = \"ThunderSetupDecode\";\n\n        if( tif->tif_dir.td_bitspersample != 4 )\n        {\n                TIFFErrorExt(tif->tif_clientdata, module,\n                             \"Wrong bitspersample value (%d), Thunder decoder only supports 4bits per sample.\",\n                             (int) tif->tif_dir.td_bitspersample );\n                return 0;\n        }\n        \n\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ThunderSetupDecode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nThunderDecode(TIFF* tif, uint8* op, tmsize_t maxpixels)\n{\n\tstatic const char module[] = \"ThunderDecode\";\n\tregister unsigned char *bp;\n\tregister tmsize_t cc;\n\tunsigned int lastpixel;\n\ttmsize_t npixels;\n\n\tbp = (unsigned char *)tif->tif_rawcp;\n\tcc = tif->tif_rawcc;\n\tlastpixel = 0;\n\tnpixels = 0;\n\twhile (cc > 0 && npixels < maxpixels) {\n\t\tint n, delta;\n\n\t\tn = *bp++;\n\t\tcc--;\n\t\tswitch (n & THUNDER_CODE) {\n\t\tcase THUNDER_RUN:\t\t/* pixel run */\n\t\t\t/*\n\t\t\t * Replicate the last pixel n times,\n\t\t\t * where n is the lower-order 6 bits.\n\t\t\t */\n\t\t\tif (npixels & 1) {\n\t\t\t\top[0] |= lastpixel;\n\t\t\t\tlastpixel = *op++; npixels++; n--;\n\t\t\t} else\n\t\t\t\tlastpixel |= lastpixel << 4;\n\t\t\tnpixels += n;\n\t\t\tif (npixels < maxpixels) {\n\t\t\t\tfor (; n > 0; n -= 2)\n\t\t\t\t\t*op++ = (uint8) lastpixel;\n\t\t\t}\n\t\t\tif (n == -1)\n\t\t\t\t*--op &= 0xf0;\n\t\t\tlastpixel &= 0xf;\n\t\t\tbreak;\n\t\tcase THUNDER_2BITDELTAS:\t/* 2-bit deltas */\n\t\t\tif ((delta = ((n >> 4) & 3)) != DELTA2_SKIP)\n\t\t\t\tSETPIXEL(op, lastpixel + twobitdeltas[delta]);\n\t\t\tif ((delta = ((n >> 2) & 3)) != DELTA2_SKIP)\n\t\t\t\tSETPIXEL(op, lastpixel + twobitdeltas[delta]);\n\t\t\tif ((delta = (n & 3)) != DELTA2_SKIP)\n\t\t\t\tSETPIXEL(op, lastpixel + twobitdeltas[delta]);\n\t\t\tbreak;\n\t\tcase THUNDER_3BITDELTAS:\t/* 3-bit deltas */\n\t\t\tif ((delta = ((n >> 3) & 7)) != DELTA3_SKIP)\n\t\t\t\tSETPIXEL(op, lastpixel + threebitdeltas[delta]);\n\t\t\tif ((delta = (n & 7)) != DELTA3_SKIP)\n\t\t\t\tSETPIXEL(op, lastpixel + threebitdeltas[delta]);\n\t\t\tbreak;\n\t\tcase THUNDER_RAW:\t\t/* raw data */\n\t\t\tSETPIXEL(op, n);\n\t\t\tbreak;\n\t\t}\n\t}\n\ttif->tif_rawcp = (uint8*) bp;\n\ttif->tif_rawcc = cc;\n\tif (npixels != maxpixels) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%s data at scanline %lu (%I64u != %I64u)\",\n\t\t\t     npixels < maxpixels ? \"Not enough\" : \"Too much\",\n\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t     (unsigned __int64) npixels,\n\t\t\t     (unsigned __int64) maxpixels);\n#else\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%s data at scanline %lu (%llu != %llu)\",\n\t\t\t     npixels < maxpixels ? \"Not enough\" : \"Too much\",\n\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t     (unsigned long long) npixels,\n\t\t\t     (unsigned long long) maxpixels);\n#endif\n\t\treturn (0);\n\t}\n\n        return (1);\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              163,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ThunderDecode",
            "parameters": {
              "tif": "TIFF",
              "op": "uint8",
              "maxpixels": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nThunderDecodeRow(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"ThunderDecodeRow\";\n\tuint8* row = buf;\n\t\n\t(void) s;\n\tif (occ % tif->tif_scanlinesize)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\n\t\treturn (0);\n\t}\n\twhile (occ > 0) {\n\t\tif (!ThunderDecode(tif, row, tif->tif_dir.td_imagewidth))\n\t\t\treturn (0);\n\t\tocc -= tif->tif_scanlinesize;\n\t\trow += tif->tif_scanlinesize;\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              165,
              0
            ],
            [
              184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ThunderDecodeRow",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFInitThunderScan(TIFF* tif, int scheme)\n{\n\t(void) scheme;\n\n        tif->tif_setupdecode = ThunderSetupDecode;\n\ttif->tif_decoderow = ThunderDecodeRow;\n\ttif->tif_decodestrip = ThunderDecodeRow; \n\treturn (1);\n}",
          "fn_code_pos": [
            [
              186,
              0
            ],
            [
              195,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitThunderScan",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_getimage.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nTIFFRGBAImageOK(TIFF* tif, char emsg[1024])\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\tuint16 photometric;\n\tint colorchannels;\n\n\tif (!tif->tif_decodestatus) {\n\t\tsprintf(emsg, \"Sorry, requested compression method is not configured\");\n\t\treturn (0);\n\t}\n\tswitch (td->td_bitspersample) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",\n\t\t\t    td->td_bitspersample);\n\t\t\treturn (0);\n\t}\n        if (td->td_sampleformat == SAMPLEFORMAT_IEEEFP) {\n                sprintf(emsg, \"Sorry, can not handle images with IEEE floating-point samples\");\n                return (0);\n        }\n\tcolorchannels = td->td_samplesperpixel - td->td_extrasamples;\n\tif (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric)) {\n\t\tswitch (colorchannels) {\n\t\t\tcase 1:\n\t\t\t\tphotometric = PHOTOMETRIC_MINISBLACK;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tphotometric = PHOTOMETRIC_RGB;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf(emsg, \"Missing needed %s tag\", photoTag);\n\t\t\t\treturn (0);\n\t\t}\n\t}\n\tswitch (photometric) {\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\tcase PHOTOMETRIC_PALETTE:\n\t\t\tif (td->td_planarconfig == PLANARCONFIG_CONTIG\n\t\t\t    && td->td_samplesperpixel != 1\n\t\t\t    && td->td_bitspersample < 8 ) {\n\t\t\t\tsprintf(emsg,\n\t\t\t\t    \"Sorry, can not handle contiguous data with %s=%d, \"\n\t\t\t\t    \"and %s=%d and Bits/Sample=%d\",\n\t\t\t\t    photoTag, photometric,\n\t\t\t\t    \"Samples/pixel\", td->td_samplesperpixel,\n\t\t\t\t    td->td_bitspersample);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\t/*\n\t\t\t * We should likely validate that any extra samples are either\n\t\t\t * to be ignored, or are alpha, and if alpha we should try to use\n\t\t\t * them.  But for now we won't bother with this.\n\t\t\t*/\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_YCBCR:\n\t\t\t/*\n\t\t\t * TODO: if at all meaningful and useful, make more complete\n\t\t\t * support check here, or better still, refactor to let supporting\n\t\t\t * code decide whether there is support and what meaningful\n\t\t\t * error to return\n\t\t\t */\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_RGB:\n\t\t\tif (colorchannels < 3) {\n\t\t\t\tsprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",\n\t\t\t\t    \"Color channels\", colorchannels);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_SEPARATED:\n\t\t\t{\n\t\t\t\tuint16 inkset;\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);\n\t\t\t\tif (inkset != INKSET_CMYK) {\n\t\t\t\t\tsprintf(emsg,\n\t\t\t\t\t    \"Sorry, can not handle separated image with %s=%d\",\n\t\t\t\t\t    \"InkSet\", inkset);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (td->td_samplesperpixel < 4) {\n\t\t\t\t\tsprintf(emsg,\n\t\t\t\t\t    \"Sorry, can not handle separated image with %s=%d\",\n\t\t\t\t\t    \"Samples/pixel\", td->td_samplesperpixel);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase PHOTOMETRIC_LOGL:\n\t\t\tif (td->td_compression != COMPRESSION_SGILOG) {\n\t\t\t\tsprintf(emsg, \"Sorry, LogL data must have %s=%d\",\n\t\t\t\t    \"Compression\", COMPRESSION_SGILOG);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\tif (td->td_compression != COMPRESSION_SGILOG &&\n\t\t\t    td->td_compression != COMPRESSION_SGILOG24) {\n\t\t\t\tsprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",\n\t\t\t\t    \"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {\n\t\t\t\tsprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",\n\t\t\t\t    \"Planarconfiguration\", td->td_planarconfig);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif ( td->td_samplesperpixel != 3 || colorchannels != 3 ) {\n                                sprintf(emsg,\n                                        \"Sorry, can not handle image with %s=%d, %s=%d\",\n                                        \"Samples/pixel\", td->td_samplesperpixel,\n                                        \"colorchannels\", colorchannels);\n                                return 0;\n                        }\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_CIELAB:\n                        if ( td->td_samplesperpixel != 3 || colorchannels != 3 || td->td_bitspersample != 8 ) {\n                                sprintf(emsg,\n                                        \"Sorry, can not handle image with %s=%d, %s=%d and %s=%d\",\n                                        \"Samples/pixel\", td->td_samplesperpixel,\n                                        \"colorchannels\", colorchannels,\n                                        \"Bits/sample\", td->td_bitspersample);\n                                return 0;\n                        }\n\t\t\tbreak;\n                default:\n\t\t\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",\n\t\t\t    photoTag, photometric);\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              210,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRGBAImageOK",
            "parameters": {
              "tif": "TIFF",
              "emsg": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\nTIFFRGBAImageEnd(TIFFRGBAImage* img)\n{\n\tif (img->Map) {\n\t\t_TIFFfree(img->Map);\n\t\timg->Map = NULL;\n\t}\n\tif (img->BWmap) {\n\t\t_TIFFfree(img->BWmap);\n\t\timg->BWmap = NULL;\n\t}\n\tif (img->PALmap) {\n\t\t_TIFFfree(img->PALmap);\n\t\timg->PALmap = NULL;\n\t}\n\tif (img->ycbcr) {\n\t\t_TIFFfree(img->ycbcr);\n\t\timg->ycbcr = NULL;\n\t}\n\tif (img->cielab) {\n\t\t_TIFFfree(img->cielab);\n\t\timg->cielab = NULL;\n\t}\n\tif (img->UaToAa) {\n\t\t_TIFFfree(img->UaToAa);\n\t\timg->UaToAa = NULL;\n\t}\n\tif (img->Bitdepth16To8) {\n\t\t_TIFFfree(img->Bitdepth16To8);\n\t\timg->Bitdepth16To8 = NULL;\n\t}\n\n\tif( img->redcmap ) {\n\t\t_TIFFfree( img->redcmap );\n\t\t_TIFFfree( img->greencmap );\n\t\t_TIFFfree( img->bluecmap );\n                img->redcmap = img->greencmap = img->bluecmap = NULL;\n\t}\n}",
          "fn_code_pos": [
            [
              212,
              0
            ],
            [
              250,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRGBAImageEnd",
            "parameters": {
              "img": "TIFFRGBAImage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nisCCITTCompression(TIFF* tif)\n{\n    uint16 compress;\n    TIFFGetField(tif, TIFFTAG_COMPRESSION, &compress);\n    return (compress == COMPRESSION_CCITTFAX3 ||\n\t    compress == COMPRESSION_CCITTFAX4 ||\n\t    compress == COMPRESSION_CCITTRLE ||\n\t    compress == COMPRESSION_CCITTRLEW);\n}",
          "fn_code_pos": [
            [
              252,
              0
            ],
            [
              261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "isCCITTCompression",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int stop, char emsg[1024])\n{\n\tuint16* sampleinfo;\n\tuint16 extrasamples;\n\tuint16 planarconfig;\n\tuint16 compress;\n\tint colorchannels;\n\tuint16 *red_orig, *green_orig, *blue_orig;\n\tint n_color;\n\t\n\tif( !TIFFRGBAImageOK(tif, emsg) )\n\t\treturn 0;\n\n\t/* Initialize to normal values */\n\timg->row_offset = 0;\n\timg->col_offset = 0;\n\timg->redcmap = NULL;\n\timg->greencmap = NULL;\n\timg->bluecmap = NULL;\n\timg->Map = NULL;\n\timg->BWmap = NULL;\n\timg->PALmap = NULL;\n\timg->ycbcr = NULL;\n\timg->cielab = NULL;\n\timg->UaToAa = NULL;\n\timg->Bitdepth16To8 = NULL;\n\timg->req_orientation = ORIENTATION_BOTLEFT;     /* It is the default */\n\n\timg->tif = tif;\n\timg->stoponerr = stop;\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &img->bitspersample);\n\tswitch (img->bitspersample) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",\n\t\t\t    img->bitspersample);\n\t\t\tgoto fail_return;\n\t}\n\timg->alpha = 0;\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\n\t    &extrasamples, &sampleinfo);\n\tif (extrasamples >= 1)\n\t{\n\t\tswitch (sampleinfo[0]) {\n\t\t\tcase EXTRASAMPLE_UNSPECIFIED:          /* Workaround for some images without */\n\t\t\t\tif (img->samplesperpixel > 3)  /* correct info about alpha channel */\n\t\t\t\t\timg->alpha = EXTRASAMPLE_ASSOCALPHA;\n\t\t\t\tbreak;\n\t\t\tcase EXTRASAMPLE_ASSOCALPHA:           /* data is pre-multiplied */\n\t\t\tcase EXTRASAMPLE_UNASSALPHA:           /* data is not pre-multiplied */\n\t\t\t\timg->alpha = sampleinfo[0];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef DEFAULT_EXTRASAMPLE_AS_ALPHA\n\tif( !TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &img->photometric))\n\t\timg->photometric = PHOTOMETRIC_MINISWHITE;\n\n\tif( extrasamples == 0\n\t    && img->samplesperpixel == 4\n\t    && img->photometric == PHOTOMETRIC_RGB )\n\t{\n\t\timg->alpha = EXTRASAMPLE_ASSOCALPHA;\n\t\textrasamples = 1;\n\t}\n#endif\n\n\tcolorchannels = img->samplesperpixel - extrasamples;\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &compress);\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarconfig);\n\tif (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &img->photometric)) {\n\t\tswitch (colorchannels) {\n\t\t\tcase 1:\n\t\t\t\tif (isCCITTCompression(tif))\n\t\t\t\t\timg->photometric = PHOTOMETRIC_MINISWHITE;\n\t\t\t\telse\n\t\t\t\t\timg->photometric = PHOTOMETRIC_MINISBLACK;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\timg->photometric = PHOTOMETRIC_RGB;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf(emsg, \"Missing needed %s tag\", photoTag);\n                                goto fail_return;\n\t\t}\n\t}\n\tswitch (img->photometric) {\n\t\tcase PHOTOMETRIC_PALETTE:\n\t\t\tif (!TIFFGetField(tif, TIFFTAG_COLORMAP,\n\t\t\t    &red_orig, &green_orig, &blue_orig)) {\n\t\t\t\tsprintf(emsg, \"Missing required \\\"Colormap\\\" tag\");\n                                goto fail_return;\n\t\t\t}\n\n\t\t\t/* copy the colormaps so we can modify them */\n\t\t\tn_color = (1U << img->bitspersample);\n\t\t\timg->redcmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);\n\t\t\timg->greencmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);\n\t\t\timg->bluecmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);\n\t\t\tif( !img->redcmap || !img->greencmap || !img->bluecmap ) {\n\t\t\t\tsprintf(emsg, \"Out of memory for colormap copy\");\n                                goto fail_return;\n\t\t\t}\n\n\t\t\t_TIFFmemcpy( img->redcmap, red_orig, n_color * 2 );\n\t\t\t_TIFFmemcpy( img->greencmap, green_orig, n_color * 2 );\n\t\t\t_TIFFmemcpy( img->bluecmap, blue_orig, n_color * 2 );\n\n\t\t\t/* fall through... */\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\t\tif (planarconfig == PLANARCONFIG_CONTIG\n\t\t\t    && img->samplesperpixel != 1\n\t\t\t    && img->bitspersample < 8 ) {\n\t\t\t\tsprintf(emsg,\n\t\t\t\t    \"Sorry, can not handle contiguous data with %s=%d, \"\n\t\t\t\t    \"and %s=%d and Bits/Sample=%d\",\n\t\t\t\t    photoTag, img->photometric,\n\t\t\t\t    \"Samples/pixel\", img->samplesperpixel,\n\t\t\t\t    img->bitspersample);\n                                goto fail_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_YCBCR:\n\t\t\t/* It would probably be nice to have a reality check here. */\n\t\t\tif (planarconfig == PLANARCONFIG_CONTIG)\n\t\t\t\t/* can rely on libjpeg to convert to RGB */\n\t\t\t\t/* XXX should restore current state on exit */\n\t\t\t\tswitch (compress) {\n\t\t\t\t\tcase COMPRESSION_JPEG:\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * TODO: when complete tests verify complete desubsampling\n\t\t\t\t\t\t * and YCbCr handling, remove use of TIFFTAG_JPEGCOLORMODE in\n\t\t\t\t\t\t * favor of tif_getimage.c native handling\n\t\t\t\t\t\t */\n\t\t\t\t\t\tTIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t\t\t\timg->photometric = PHOTOMETRIC_RGB;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* do nothing */;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t/*\n\t\t\t * TODO: if at all meaningful and useful, make more complete\n\t\t\t * support check here, or better still, refactor to let supporting\n\t\t\t * code decide whether there is support and what meaningful\n\t\t\t * error to return\n\t\t\t */\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_RGB:\n\t\t\tif (colorchannels < 3) {\n\t\t\t\tsprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",\n\t\t\t\t    \"Color channels\", colorchannels);\n                                goto fail_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_SEPARATED:\n\t\t\t{\n\t\t\t\tuint16 inkset;\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);\n\t\t\t\tif (inkset != INKSET_CMYK) {\n\t\t\t\t\tsprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",\n\t\t\t\t\t    \"InkSet\", inkset);\n                                        goto fail_return;\n\t\t\t\t}\n\t\t\t\tif (img->samplesperpixel < 4) {\n\t\t\t\t\tsprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",\n\t\t\t\t\t    \"Samples/pixel\", img->samplesperpixel);\n                                        goto fail_return;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_LOGL:\n\t\t\tif (compress != COMPRESSION_SGILOG) {\n\t\t\t\tsprintf(emsg, \"Sorry, LogL data must have %s=%d\",\n\t\t\t\t    \"Compression\", COMPRESSION_SGILOG);\n                                goto fail_return;\n\t\t\t}\n\t\t\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\t\t\timg->photometric = PHOTOMETRIC_MINISBLACK;\t/* little white lie */\n\t\t\timg->bitspersample = 8;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\tif (compress != COMPRESSION_SGILOG && compress != COMPRESSION_SGILOG24) {\n\t\t\t\tsprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",\n\t\t\t\t    \"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);\n                                goto fail_return;\n\t\t\t}\n\t\t\tif (planarconfig != PLANARCONFIG_CONTIG) {\n\t\t\t\tsprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",\n\t\t\t\t    \"Planarconfiguration\", planarconfig);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\t\t\timg->photometric = PHOTOMETRIC_RGB;\t\t/* little white lie */\n\t\t\timg->bitspersample = 8;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_CIELAB:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",\n\t\t\t    photoTag, img->photometric);\n                        goto fail_return;\n\t}\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &img->width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &img->height);\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ORIENTATION, &img->orientation);\n\timg->isContig =\n\t    !(planarconfig == PLANARCONFIG_SEPARATE && img->samplesperpixel > 1);\n\tif (img->isContig) {\n\t\tif (!PickContigCase(img)) {\n\t\t\tsprintf(emsg, \"Sorry, can not handle image\");\n\t\t\tgoto fail_return;\n\t\t}\n\t} else {\n\t\tif (!PickSeparateCase(img)) {\n\t\t\tsprintf(emsg, \"Sorry, can not handle image\");\n\t\t\tgoto fail_return;\n\t\t}\n\t}\n\treturn 1;\n\n  fail_return:\n        TIFFRGBAImageEnd( img );\n        return 0;\n}",
          "fn_code_pos": [
            [
              263,
              0
            ],
            [
              496,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRGBAImageBegin",
            "parameters": {
              "img": "TIFFRGBAImage",
              "tif": "TIFF",
              "stop": "int",
              "emsg": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFRGBAImageGet(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    if (img->get == NULL) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"No \\\"get\\\" routine setup\");\n\t\treturn (0);\n\t}\n\tif (img->put.any == NULL) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif),\n\t\t\"No \\\"put\\\" routine setupl; probably can not handle image format\");\n\t\treturn (0);\n    }\n    return (*img->get)(img, raster, w, h);\n}",
          "fn_code_pos": [
            [
              498,
              0
            ],
            [
              511,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRGBAImageGet",
            "parameters": {
              "img": "TIFFRGBAImage",
              "raster": "uint32",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFReadRGBAImageOriented(TIFF* tif,\n\t\t\t  uint32 rwidth, uint32 rheight, uint32* raster,\n\t\t\t  int orientation, int stop)\n{\n    char emsg[1024] = \"\";\n    TIFFRGBAImage img;\n    int ok;\n\n\tif (TIFFRGBAImageOK(tif, emsg) && TIFFRGBAImageBegin(&img, tif, stop, emsg)) {\n\t\timg.req_orientation = (uint16)orientation;\n\t\t/* XXX verify rwidth and rheight against width and height */\n\t\tok = TIFFRGBAImageGet(&img, raster+(rheight-img.height)*rwidth,\n\t\t\trwidth, img.height);\n\t\tTIFFRGBAImageEnd(&img);\n\t} else {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", emsg);\n\t\tok = 0;\n    }\n    return (ok);\n}",
          "fn_code_pos": [
            [
              517,
              0
            ],
            [
              537,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRGBAImageOriented",
            "parameters": {
              "tif": "TIFF",
              "rwidth": "uint32",
              "rheight": "uint32",
              "raster": "uint32",
              "orientation": "int",
              "stop": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFReadRGBAImage(TIFF* tif,\n\t\t  uint32 rwidth, uint32 rheight, uint32* raster, int stop)\n{\n\treturn TIFFReadRGBAImageOriented(tif, rwidth, rheight, raster,\n\t\t\t\t\t ORIENTATION_BOTLEFT, stop);\n}",
          "fn_code_pos": [
            [
              543,
              0
            ],
            [
              549,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRGBAImage",
            "parameters": {
              "tif": "TIFF",
              "rwidth": "uint32",
              "rheight": "uint32",
              "raster": "uint32",
              "stop": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int \nsetorientation(TIFFRGBAImage* img)\n{\n\tswitch (img->orientation) {\n\t\tcase ORIENTATION_TOPLEFT:\n\t\tcase ORIENTATION_LEFTTOP:\n\t\t\tif (img->req_orientation == ORIENTATION_TOPRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTTOP)\n\t\t\t\treturn FLIP_HORIZONTALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTBOT)\n\t\t\t\treturn FLIP_HORIZONTALLY | FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTBOT)\n\t\t\t\treturn FLIP_VERTICALLY;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\tcase ORIENTATION_TOPRIGHT:\n\t\tcase ORIENTATION_RIGHTTOP:\n\t\t\tif (img->req_orientation == ORIENTATION_TOPLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTTOP)\n\t\t\t\treturn FLIP_HORIZONTALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTBOT)\n\t\t\t\treturn FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTBOT)\n\t\t\t\treturn FLIP_HORIZONTALLY | FLIP_VERTICALLY;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\tcase ORIENTATION_BOTRIGHT:\n\t\tcase ORIENTATION_RIGHTBOT:\n\t\t\tif (img->req_orientation == ORIENTATION_TOPLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTTOP)\n\t\t\t\treturn FLIP_HORIZONTALLY | FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_TOPRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTTOP)\n\t\t\t\treturn FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTBOT)\n\t\t\t\treturn FLIP_HORIZONTALLY;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\tcase ORIENTATION_BOTLEFT:\n\t\tcase ORIENTATION_LEFTBOT:\n\t\t\tif (img->req_orientation == ORIENTATION_TOPLEFT ||\n\t\t\t    img->req_orientation == ORIENTATION_LEFTTOP)\n\t\t\t\treturn FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_TOPRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTTOP)\n\t\t\t\treturn FLIP_HORIZONTALLY | FLIP_VERTICALLY;\n\t\t\telse if (img->req_orientation == ORIENTATION_BOTRIGHT ||\n\t\t\t    img->req_orientation == ORIENTATION_RIGHTBOT)\n\t\t\t\treturn FLIP_HORIZONTALLY;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\tdefault:\t/* NOTREACHED */\n\t\t\treturn 0;\n\t}\n}",
          "fn_code_pos": [
            [
              551,
              0
            ],
            [
              610,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setorientation",
            "parameters": {
              "img": "TIFFRGBAImage"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ngtTileContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint32 col, row, y, rowstoread;\n    tmsize_t pos;\n    uint32 tw, th;\n    unsigned char* buf = NULL;\n    int32 fromskew, toskew;\n    uint32 nrow;\n    int ret = 1, flip;\n    uint32 this_tw, tocol;\n    int32 this_toskew, leftmost_toskew;\n    int32 leftmost_fromskew;\n    uint32 leftmost_tw;\n    tmsize_t bufsize;\n\n    bufsize = TIFFTileSize(tif);\n    if (bufsize == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", \"No space for tile buffer\");\n        return (0);\n    }\n\n    TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\n    flip = setorientation(img);\n    if (flip & FLIP_VERTICALLY) {\n\t    y = h - 1;\n\t    toskew = -(int32)(tw + w);\n    }\n    else {\n\t    y = 0;\n\t    toskew = -(int32)(tw - w);\n    }\n     \n    /*\n     *\tLeftmost tile is clipped on left side if col_offset > 0.\n     */\n    leftmost_fromskew = img->col_offset % tw;\n    leftmost_tw = tw - leftmost_fromskew;\n    leftmost_toskew = toskew + leftmost_fromskew;\n    for (row = 0; ret != 0 && row < h; row += nrow)\n    {\n        rowstoread = th - (row + img->row_offset) % th;\n    \tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\tfromskew = leftmost_fromskew;\n\tthis_tw = leftmost_tw;\n\tthis_toskew = leftmost_toskew;\n\ttocol = 0;\n\tcol = img->col_offset;\n\twhile (tocol < w)\n        {\n\t    if (_TIFFReadTileAndAllocBuffer(tif, (void**) &buf, bufsize, col,\n\t\t\t     row+img->row_offset, 0, 0)==(tmsize_t)(-1) &&\n                (buf == NULL || img->stoponerr))\n            {\n                ret = 0;\n                break;\n            }\n            pos = ((row+img->row_offset) % th) * TIFFTileRowSize(tif) + \\\n\t\t   ((tmsize_t) fromskew * img->samplesperpixel);\n\t    if (tocol + this_tw > w) \n\t    {\n\t\t/*\n\t\t * Rightmost tile is clipped on right side.\n\t\t */\n\t\tfromskew = tw - (w - tocol);\n\t\tthis_tw = tw - fromskew;\n\t\tthis_toskew = toskew + fromskew;\n\t    }\n\t    (*put)(img, raster+y*w+tocol, tocol, y, this_tw, nrow, fromskew, this_toskew, buf + pos);\n\t    tocol += this_tw;\n\t    col += this_tw;\n\t    /*\n\t     * After the leftmost tile, tiles are no longer clipped on left side.\n\t     */\n\t    fromskew = 0;\n\t    this_tw = tw;\n\t    this_toskew = toskew;\n\t}\n\n        y += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n\n    if (flip & FLIP_HORIZONTALLY) {\n\t    uint32 line;\n\n\t    for (line = 0; line < h; line++) {\n\t\t    uint32 *left = raster + (line * w);\n\t\t    uint32 *right = left + w - 1;\n\t\t    \n\t\t    while ( left < right ) {\n\t\t\t    uint32 temp = *left;\n\t\t\t    *left = *right;\n\t\t\t    *right = temp;\n\t\t\t    left++;\n\t\t\t\tright--;\n\t\t    }\n\t    }\n    }\n\n    return (ret);\n}",
          "fn_code_pos": [
            [
              618,
              0
            ],
            [
              723,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gtTileContig",
            "parameters": {
              "img": "TIFFRGBAImage",
              "raster": "uint32",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ngtTileSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n\tTIFF* tif = img->tif;\n\ttileSeparateRoutine put = img->put.separate;\n\tuint32 col, row, y, rowstoread;\n\ttmsize_t pos;\n\tuint32 tw, th;\n\tunsigned char* buf = NULL;\n\tunsigned char* p0 = NULL;\n\tunsigned char* p1 = NULL;\n\tunsigned char* p2 = NULL;\n\tunsigned char* pa = NULL;\n\ttmsize_t tilesize;\n\ttmsize_t bufsize;\n\tint32 fromskew, toskew;\n\tint alpha = img->alpha;\n\tuint32 nrow;\n\tint ret = 1, flip;\n        uint16 colorchannels;\n\tuint32 this_tw, tocol;\n\tint32 this_toskew, leftmost_toskew;\n\tint32 leftmost_fromskew;\n\tuint32 leftmost_tw;\n\n\ttilesize = TIFFTileSize(tif);  \n\tbufsize = TIFFSafeMultiply(tmsize_t,alpha?4:3,tilesize);\n\tif (bufsize == 0) {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Integer overflow in %s\", \"gtTileSeparate\");\n\t\treturn (0);\n\t}\n\n\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\n\tflip = setorientation(img);\n\tif (flip & FLIP_VERTICALLY) {\n\t\ty = h - 1;\n\t\ttoskew = -(int32)(tw + w);\n\t}\n\telse {\n\t\ty = 0;\n\t\ttoskew = -(int32)(tw - w);\n\t}\n\n        switch( img->photometric )\n        {\n          case PHOTOMETRIC_MINISWHITE:\n          case PHOTOMETRIC_MINISBLACK:\n          case PHOTOMETRIC_PALETTE:\n            colorchannels = 1;\n            break;\n\n          default:\n            colorchannels = 3;\n            break;\n        }\n\n\t/*\n\t *\tLeftmost tile is clipped on left side if col_offset > 0.\n\t */\n\tleftmost_fromskew = img->col_offset % tw;\n\tleftmost_tw = tw - leftmost_fromskew;\n\tleftmost_toskew = toskew + leftmost_fromskew;\n\tfor (row = 0; ret != 0 && row < h; row += nrow)\n\t{\n\t\trowstoread = th - (row + img->row_offset) % th;\n\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\t\tfromskew = leftmost_fromskew;\n\t\tthis_tw = leftmost_tw;\n\t\tthis_toskew = leftmost_toskew;\n\t\ttocol = 0;\n\t\tcol = img->col_offset;\n\t\twhile (tocol < w)\n\t\t{\n                        if( buf == NULL )\n                        {\n                            if (_TIFFReadTileAndAllocBuffer(\n                                    tif, (void**) &buf, bufsize, col,\n                                    row+img->row_offset,0,0)==(tmsize_t)(-1)\n                                && (buf == NULL || img->stoponerr))\n                            {\n                                    ret = 0;\n                                    break;\n                            }\n                            p0 = buf;\n                            if( colorchannels == 1 )\n                            {\n                                p2 = p1 = p0;\n                                pa = (alpha?(p0+3*tilesize):NULL);\n                            }\n                            else\n                            {\n                                p1 = p0 + tilesize;\n                                p2 = p1 + tilesize;\n                                pa = (alpha?(p2+tilesize):NULL);\n                            }\n                        }\n\t\t\telse if (TIFFReadTile(tif, p0, col,  \n\t\t\t    row+img->row_offset,0,0)==(tmsize_t)(-1) && img->stoponerr)\n\t\t\t{\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (colorchannels > 1 \n                            && TIFFReadTile(tif, p1, col,  \n                                            row+img->row_offset,0,1) == (tmsize_t)(-1) \n                            && img->stoponerr)\n\t\t\t{\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (colorchannels > 1 \n                            && TIFFReadTile(tif, p2, col,  \n                                            row+img->row_offset,0,2) == (tmsize_t)(-1) \n                            && img->stoponerr)\n\t\t\t{\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (alpha\n                            && TIFFReadTile(tif,pa,col,  \n                                            row+img->row_offset,0,colorchannels) == (tmsize_t)(-1) \n                            && img->stoponerr)\n                        {\n                            ret = 0;\n                            break;\n\t\t\t}\n\n\t\t\tpos = ((row+img->row_offset) % th) * TIFFTileRowSize(tif) + \\\n\t\t\t   ((tmsize_t) fromskew * img->samplesperpixel);\n\t\t\tif (tocol + this_tw > w) \n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Rightmost tile is clipped on right side.\n\t\t\t\t */\n\t\t\t\tfromskew = tw - (w - tocol);\n\t\t\t\tthis_tw = tw - fromskew;\n\t\t\t\tthis_toskew = toskew + fromskew;\n\t\t\t}\n\t\t\t(*put)(img, raster+y*w+tocol, tocol, y, this_tw, nrow, fromskew, this_toskew, \\\n\t\t\t\tp0 + pos, p1 + pos, p2 + pos, (alpha?(pa+pos):NULL));\n\t\t\ttocol += this_tw;\n\t\t\tcol += this_tw;\n\t\t\t/*\n\t\t\t* After the leftmost tile, tiles are no longer clipped on left side.\n\t\t\t*/\n\t\t\tfromskew = 0;\n\t\t\tthis_tw = tw;\n\t\t\tthis_toskew = toskew;\n\t\t}\n\n\t\ty += ((flip & FLIP_VERTICALLY) ?-(int32) nrow : (int32) nrow);\n\t}\n\n\tif (flip & FLIP_HORIZONTALLY) {\n\t\tuint32 line;\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tuint32 *left = raster + (line * w);\n\t\t\tuint32 *right = left + w - 1;\n\n\t\t\twhile ( left < right ) {\n\t\t\t\tuint32 temp = *left;\n\t\t\t\t*left = *right;\n\t\t\t\t*right = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\n\t_TIFFfree(buf);\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              731,
              0
            ],
            [
              905,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gtTileSeparate",
            "parameters": {
              "img": "TIFFRGBAImage",
              "raster": "uint32",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ngtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n\tTIFF* tif = img->tif;\n\ttileContigRoutine put = img->put.contig;\n\tuint32 row, y, nrow, nrowsub, rowstoread;\n\ttmsize_t pos;\n\tunsigned char* buf = NULL;\n\tuint32 rowsperstrip;\n\tuint16 subsamplinghor,subsamplingver;\n\tuint32 imagewidth = img->width;\n\ttmsize_t scanline;\n\tint32 fromskew, toskew;\n\tint ret = 1, flip;\n        tmsize_t maxstripsize;\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);\n\tif( subsamplingver == 0 ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Invalid vertical YCbCr subsampling\");\n\t\treturn (0);\n\t}\n\t\n\tmaxstripsize = TIFFStripSize(tif);\n\n\tflip = setorientation(img);\n\tif (flip & FLIP_VERTICALLY) {\n\t\ty = h - 1;\n\t\ttoskew = -(int32)(w + w);\n\t} else {\n\t\ty = 0;\n\t\ttoskew = -(int32)(w - w);\n\t}\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\n\tscanline = TIFFScanlineSize(tif);\n\tfromskew = (w < imagewidth ? imagewidth - w : 0);\n\tfor (row = 0; row < h; row += nrow)\n\t{\n\t\trowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\t\tnrowsub = nrow;\n\t\tif ((nrowsub%subsamplingver)!=0)\n\t\t\tnrowsub+=subsamplingver-nrowsub%subsamplingver;\n\t\tif (_TIFFReadEncodedStripAndAllocBuffer(tif,\n\t\t    TIFFComputeStrip(tif,row+img->row_offset, 0),\n\t\t    (void**)(&buf),\n                    maxstripsize,\n\t\t    ((row + img->row_offset)%rowsperstrip + nrowsub) * scanline)==(tmsize_t)(-1)\n\t\t    && (buf == NULL || img->stoponerr))\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tpos = ((row + img->row_offset) % rowsperstrip) * scanline + \\\n\t\t\t((tmsize_t) img->col_offset * img->samplesperpixel);\n\t\t(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, buf + pos);\n\t\ty += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n\t}\n\n\tif (flip & FLIP_HORIZONTALLY) {\n\t\tuint32 line;\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tuint32 *left = raster + (line * w);\n\t\t\tuint32 *right = left + w - 1;\n\n\t\t\twhile ( left < right ) {\n\t\t\t\tuint32 temp = *left;\n\t\t\t\t*left = *right;\n\t\t\t\t*right = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\n\t_TIFFfree(buf);\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              913,
              0
            ],
            [
              993,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gtStripContig",
            "parameters": {
              "img": "TIFFRGBAImage",
              "raster": "uint32",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ngtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n\tTIFF* tif = img->tif;\n\ttileSeparateRoutine put = img->put.separate;\n\tunsigned char *buf = NULL;\n\tunsigned char *p0 = NULL, *p1 = NULL, *p2 = NULL, *pa = NULL;\n\tuint32 row, y, nrow, rowstoread;\n\ttmsize_t pos;\n\ttmsize_t scanline;\n\tuint32 rowsperstrip, offset_row;\n\tuint32 imagewidth = img->width;\n\ttmsize_t stripsize;\n\ttmsize_t bufsize;\n\tint32 fromskew, toskew;\n\tint alpha = img->alpha;\n\tint ret = 1, flip;\n        uint16 colorchannels;\n\n\tstripsize = TIFFStripSize(tif);  \n\tbufsize = TIFFSafeMultiply(tmsize_t,alpha?4:3,stripsize);\n\tif (bufsize == 0) {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Integer overflow in %s\", \"gtStripSeparate\");\n\t\treturn (0);\n\t}\n\n\tflip = setorientation(img);\n\tif (flip & FLIP_VERTICALLY) {\n\t\ty = h - 1;\n\t\ttoskew = -(int32)(w + w);\n\t}\n\telse {\n\t\ty = 0;\n\t\ttoskew = -(int32)(w - w);\n\t}\n\n        switch( img->photometric )\n        {\n          case PHOTOMETRIC_MINISWHITE:\n          case PHOTOMETRIC_MINISBLACK:\n          case PHOTOMETRIC_PALETTE:\n            colorchannels = 1;\n            break;\n\n          default:\n            colorchannels = 3;\n            break;\n        }\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\tscanline = TIFFScanlineSize(tif);  \n\tfromskew = (w < imagewidth ? imagewidth - w : 0);\n\tfor (row = 0; row < h; row += nrow)\n\t{\n\t\trowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n\t\tnrow = (row + rowstoread > h ? h - row : rowstoread);\n\t\toffset_row = row + img->row_offset;\n                if( buf == NULL )\n                {\n                    if (_TIFFReadEncodedStripAndAllocBuffer(\n                            tif, TIFFComputeStrip(tif, offset_row, 0),\n                            (void**) &buf, bufsize,\n                            ((row + img->row_offset)%rowsperstrip + nrow) * scanline)==(tmsize_t)(-1)\n                        && (buf == NULL || img->stoponerr))\n                    {\n                            ret = 0;\n                            break;\n                    }\n                    p0 = buf;\n                    if( colorchannels == 1 )\n                    {\n                        p2 = p1 = p0;\n                        pa = (alpha?(p0+3*stripsize):NULL);\n                    }\n                    else\n                    {\n                        p1 = p0 + stripsize;\n                        p2 = p1 + stripsize;\n                        pa = (alpha?(p2+stripsize):NULL);\n                    }\n                }\n\t\telse if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 0),\n\t\t    p0, ((row + img->row_offset)%rowsperstrip + nrow) * scanline)==(tmsize_t)(-1)\n\t\t    && img->stoponerr)\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (colorchannels > 1 \n                    && TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 1),\n                                            p1, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) == (tmsize_t)(-1)\n\t\t    && img->stoponerr)\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (colorchannels > 1 \n                    && TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 2),\n                                            p2, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) == (tmsize_t)(-1)\n\t\t    && img->stoponerr)\n\t\t{\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (alpha)\n\t\t{\n\t\t\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, colorchannels),\n\t\t\t    pa, ((row + img->row_offset)%rowsperstrip + nrow) * scanline)==(tmsize_t)(-1)\n\t\t\t    && img->stoponerr)\n\t\t\t{\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpos = ((row + img->row_offset) % rowsperstrip) * scanline + \\\n\t\t\t((tmsize_t) img->col_offset * img->samplesperpixel);\n\t\t(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, p0 + pos, p1 + pos,\n\t\t    p2 + pos, (alpha?(pa+pos):NULL));\n\t\ty += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);\n\t}\n\n\tif (flip & FLIP_HORIZONTALLY) {\n\t\tuint32 line;\n\n\t\tfor (line = 0; line < h; line++) {\n\t\t\tuint32 *left = raster + (line * w);\n\t\t\tuint32 *right = left + w - 1;\n\n\t\t\twhile ( left < right ) {\n\t\t\t\tuint32 temp = *left;\n\t\t\t\t*left = *right;\n\t\t\t\t*right = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\n\t_TIFFfree(buf);\n\treturn (ret);\n}",
          "fn_code_pos": [
            [
              1001,
              0
            ],
            [
              1142,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gtStripSeparate",
            "parameters": {
              "img": "TIFFRGBAImage",
              "raster": "uint32",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(put8bitcmaptile)\n{\n    uint32** PALmap = img->PALmap;\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    for( ; h > 0; --h) {\n\tfor (x = w; x > 0; --x)\n        {\n\t    *cp++ = PALmap[*pp][0];\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}",
          "fn_code_pos": [
            [
              1232,
              0
            ],
            [
              1247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(put4bitcmaptile)\n{\n    uint32** PALmap = img->PALmap;\n\n    (void) x; (void) y;\n    fromskew /= 2;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL2(w, bw = PALmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}",
          "fn_code_pos": [
            [
              1252,
              0
            ],
            [
              1264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(put2bitcmaptile)\n{\n    uint32** PALmap = img->PALmap;\n\n    (void) x; (void) y;\n    fromskew /= 4;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL4(w, bw = PALmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}",
          "fn_code_pos": [
            [
              1269,
              0
            ],
            [
              1281,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(put1bitcmaptile)\n{\n    uint32** PALmap = img->PALmap;\n\n    (void) x; (void) y;\n    fromskew /= 8;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL8(w, bw = PALmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}",
          "fn_code_pos": [
            [
              1286,
              0
            ],
            [
              1298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putgreytile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n\n    (void) y;\n    for( ; h > 0; --h) {\n\tfor (x = w; x > 0; --x)\n        {\n\t    *cp++ = BWmap[*pp][0];\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}",
          "fn_code_pos": [
            [
              1303,
              0
            ],
            [
              1318,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putagreytile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n\n    (void) y;\n    for( ; h > 0; --h) {\n\tfor (x = w; x > 0; --x)\n        {\n            *cp++ = BWmap[*pp][0] & ((uint32)*(pp+1) << 24 | ~A1);\n            pp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}",
          "fn_code_pos": [
            [
              1323,
              0
            ],
            [
              1338,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(put16bitbwtile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint32** BWmap = img->BWmap;\n\n    (void) y;\n    for( ; h > 0; --h) {\n        uint16 *wp = (uint16 *) pp;\n\n\tfor (x = w; x > 0; --x)\n        {\n            /* use high order byte of 16bit value */\n\n\t    *cp++ = BWmap[*wp >> 8][0];\n            pp += 2 * samplesperpixel;\n            wp += samplesperpixel;\n        }\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}",
          "fn_code_pos": [
            [
              1343,
              0
            ],
            [
              1363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(put1bitbwtile)\n{\n    uint32** BWmap = img->BWmap;\n\n    (void) x; (void) y;\n    fromskew /= 8;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL8(w, bw = BWmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}",
          "fn_code_pos": [
            [
              1368,
              0
            ],
            [
              1380,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(put2bitbwtile)\n{\n    uint32** BWmap = img->BWmap;\n\n    (void) x; (void) y;\n    fromskew /= 4;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL4(w, bw = BWmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}",
          "fn_code_pos": [
            [
              1385,
              0
            ],
            [
              1397,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(put4bitbwtile)\n{\n    uint32** BWmap = img->BWmap;\n\n    (void) x; (void) y;\n    fromskew /= 2;\n    for( ; h > 0; --h) {\n\tuint32* bw;\n\tUNROLL2(w, bw = BWmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}",
          "fn_code_pos": [
            [
              1402,
              0
            ],
            [
              1414,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putRGBcontig8bittile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) x; (void) y;\n    fromskew *= samplesperpixel;\n    for( ; h > 0; --h) {\n\tUNROLL8(w, NOP,\n\t    *cp++ = PACK(pp[0], pp[1], pp[2]);\n\t    pp += samplesperpixel);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}",
          "fn_code_pos": [
            [
              1419,
              0
            ],
            [
              1432,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putRGBAAcontig8bittile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) x; (void) y;\n    fromskew *= samplesperpixel;\n    for( ; h > 0; --h) {\n\tUNROLL8(w, NOP,\n\t    *cp++ = PACK4(pp[0], pp[1], pp[2], pp[3]);\n\t    pp += samplesperpixel);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}",
          "fn_code_pos": [
            [
              1438,
              0
            ],
            [
              1451,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putRGBUAcontig8bittile)\n{\n\tint samplesperpixel = img->samplesperpixel;\n\t(void) y;\n\tfromskew *= samplesperpixel;\n\tfor( ; h > 0; --h) {\n\t\tuint32 r, g, b, a;\n\t\tuint8* m;\n\t\tfor (x = w; x > 0; --x) {\n\t\t\ta = pp[3];\n\t\t\tm = img->UaToAa+((size_t) a<<8);\n\t\t\tr = m[pp[0]];\n\t\t\tg = m[pp[1]];\n\t\t\tb = m[pp[2]];\n\t\t\t*cp++ = PACK4(r,g,b,a);\n\t\t\tpp += samplesperpixel;\n\t\t}\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t}\n}",
          "fn_code_pos": [
            [
              1457,
              0
            ],
            [
              1477,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putRGBcontig16bittile)\n{\n\tint samplesperpixel = img->samplesperpixel;\n\tuint16 *wp = (uint16 *)pp;\n\t(void) y;\n\tfromskew *= samplesperpixel;\n\tfor( ; h > 0; --h) {\n\t\tfor (x = w; x > 0; --x) {\n\t\t\t*cp++ = PACK(img->Bitdepth16To8[wp[0]],\n\t\t\t    img->Bitdepth16To8[wp[1]],\n\t\t\t    img->Bitdepth16To8[wp[2]]);\n\t\t\twp += samplesperpixel;\n\t\t}\n\t\tcp += toskew;\n\t\twp += fromskew;\n\t}\n}",
          "fn_code_pos": [
            [
              1482,
              0
            ],
            [
              1498,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putRGBAAcontig16bittile)\n{\n\tint samplesperpixel = img->samplesperpixel;\n\tuint16 *wp = (uint16 *)pp;\n\t(void) y;\n\tfromskew *= samplesperpixel;\n\tfor( ; h > 0; --h) {\n\t\tfor (x = w; x > 0; --x) {\n\t\t\t*cp++ = PACK4(img->Bitdepth16To8[wp[0]],\n\t\t\t    img->Bitdepth16To8[wp[1]],\n\t\t\t    img->Bitdepth16To8[wp[2]],\n\t\t\t    img->Bitdepth16To8[wp[3]]);\n\t\t\twp += samplesperpixel;\n\t\t}\n\t\tcp += toskew;\n\t\twp += fromskew;\n\t}\n}",
          "fn_code_pos": [
            [
              1504,
              0
            ],
            [
              1521,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putRGBUAcontig16bittile)\n{\n\tint samplesperpixel = img->samplesperpixel;\n\tuint16 *wp = (uint16 *)pp;\n\t(void) y;\n\tfromskew *= samplesperpixel;\n\tfor( ; h > 0; --h) {\n\t\tuint32 r,g,b,a;\n\t\tuint8* m;\n\t\tfor (x = w; x > 0; --x) {\n\t\t\ta = img->Bitdepth16To8[wp[3]];\n\t\t\tm = img->UaToAa+((size_t) a<<8);\n\t\t\tr = m[img->Bitdepth16To8[wp[0]]];\n\t\t\tg = m[img->Bitdepth16To8[wp[1]]];\n\t\t\tb = m[img->Bitdepth16To8[wp[2]]];\n\t\t\t*cp++ = PACK4(r,g,b,a);\n\t\t\twp += samplesperpixel;\n\t\t}\n\t\tcp += toskew;\n\t\twp += fromskew;\n\t}\n}",
          "fn_code_pos": [
            [
              1527,
              0
            ],
            [
              1548,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putRGBcontig8bitCMYKtile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    uint16 r, g, b, k;\n\n    (void) x; (void) y;\n    fromskew *= samplesperpixel;\n    for( ; h > 0; --h) {\n\tUNROLL8(w, NOP,\n\t    k = 255 - pp[3];\n\t    r = (k*(255-pp[0]))/255;\n\t    g = (k*(255-pp[1]))/255;\n\t    b = (k*(255-pp[2]))/255;\n\t    *cp++ = PACK(r, g, b);\n\t    pp += samplesperpixel);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}",
          "fn_code_pos": [
            [
              1555,
              0
            ],
            [
              1573,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putRGBcontig8bitCMYKMaptile)\n{\n    int samplesperpixel = img->samplesperpixel;\n    TIFFRGBValue* Map = img->Map;\n    uint16 r, g, b, k;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    for( ; h > 0; --h) {\n\tfor (x = w; x > 0; --x) {\n\t    k = 255 - pp[3];\n\t    r = (k*(255-pp[0]))/255;\n\t    g = (k*(255-pp[1]))/255;\n\t    b = (k*(255-pp[2]))/255;\n\t    *cp++ = PACK(Map[r], Map[g], Map[b]);\n\t    pp += samplesperpixel;\n\t}\n\tpp += fromskew;\n\tcp += toskew;\n    }\n}",
          "fn_code_pos": [
            [
              1580,
              0
            ],
            [
              1600,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLARESepPutFunc(putRGBseparate8bittile)\n{\n    (void) img; (void) x; (void) y; (void) a;\n    for( ; h > 0; --h) {\n\tUNROLL8(w, NOP, *cp++ = PACK(*r++, *g++, *b++));\n\tSKEW(r, g, b, fromskew);\n\tcp += toskew;\n    }\n}",
          "fn_code_pos": [
            [
              1615,
              0
            ],
            [
              1623,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLARESepPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLARESepPutFunc(putRGBAAseparate8bittile)\n{\n\t(void) img; (void) x; (void) y; \n\tfor( ; h > 0; --h) {\n\t\tUNROLL8(w, NOP, *cp++ = PACK4(*r++, *g++, *b++, *a++));\n\t\tSKEW4(r, g, b, a, fromskew);\n\t\tcp += toskew;\n\t}\n}",
          "fn_code_pos": [
            [
              1628,
              0
            ],
            [
              1636,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLARESepPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLARESepPutFunc(putCMYKseparate8bittile)\n{\n\t(void) img; (void) y;\n\tfor( ; h > 0; --h) {\n\t\tuint32 rv, gv, bv, kv;\n\t\tfor (x = w; x > 0; --x) {\n\t\t\tkv = 255 - *a++;\n\t\t\trv = (kv*(255-*r++))/255;\n\t\t\tgv = (kv*(255-*g++))/255;\n\t\t\tbv = (kv*(255-*b++))/255;\n\t\t\t*cp++ = PACK4(rv,gv,bv,255);\n\t\t}\n\t\tSKEW4(r, g, b, a, fromskew);\n\t\tcp += toskew;\n\t}\n}",
          "fn_code_pos": [
            [
              1641,
              0
            ],
            [
              1656,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLARESepPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLARESepPutFunc(putRGBUAseparate8bittile)\n{\n\t(void) img; (void) y;\n\tfor( ; h > 0; --h) {\n\t\tuint32 rv, gv, bv, av;\n\t\tuint8* m;\n\t\tfor (x = w; x > 0; --x) {\n\t\t\tav = *a++;\n\t\t\tm = img->UaToAa+((size_t) av<<8);\n\t\t\trv = m[*r++];\n\t\t\tgv = m[*g++];\n\t\t\tbv = m[*b++];\n\t\t\t*cp++ = PACK4(rv,gv,bv,av);\n\t\t}\n\t\tSKEW4(r, g, b, a, fromskew);\n\t\tcp += toskew;\n\t}\n}",
          "fn_code_pos": [
            [
              1661,
              0
            ],
            [
              1678,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLARESepPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLARESepPutFunc(putRGBseparate16bittile)\n{\n\tuint16 *wr = (uint16*) r;\n\tuint16 *wg = (uint16*) g;\n\tuint16 *wb = (uint16*) b;\n\t(void) img; (void) y; (void) a;\n\tfor( ; h > 0; --h) {\n\t\tfor (x = 0; x < w; x++)\n\t\t\t*cp++ = PACK(img->Bitdepth16To8[*wr++],\n\t\t\t    img->Bitdepth16To8[*wg++],\n\t\t\t    img->Bitdepth16To8[*wb++]);\n\t\tSKEW(wr, wg, wb, fromskew);\n\t\tcp += toskew;\n\t}\n}",
          "fn_code_pos": [
            [
              1683,
              0
            ],
            [
              1697,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLARESepPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLARESepPutFunc(putRGBAAseparate16bittile)\n{\n\tuint16 *wr = (uint16*) r;\n\tuint16 *wg = (uint16*) g;\n\tuint16 *wb = (uint16*) b;\n\tuint16 *wa = (uint16*) a;\n\t(void) img; (void) y;\n\tfor( ; h > 0; --h) {\n\t\tfor (x = 0; x < w; x++)\n\t\t\t*cp++ = PACK4(img->Bitdepth16To8[*wr++],\n\t\t\t    img->Bitdepth16To8[*wg++],\n\t\t\t    img->Bitdepth16To8[*wb++],\n\t\t\t    img->Bitdepth16To8[*wa++]);\n\t\tSKEW4(wr, wg, wb, wa, fromskew);\n\t\tcp += toskew;\n\t}\n}",
          "fn_code_pos": [
            [
              1702,
              0
            ],
            [
              1718,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLARESepPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLARESepPutFunc(putRGBUAseparate16bittile)\n{\n\tuint16 *wr = (uint16*) r;\n\tuint16 *wg = (uint16*) g;\n\tuint16 *wb = (uint16*) b;\n\tuint16 *wa = (uint16*) a;\n\t(void) img; (void) y;\n\tfor( ; h > 0; --h) {\n\t\tuint32 r2,g2,b2,a2;\n\t\tuint8* m;\n\t\tfor (x = w; x > 0; --x) {\n\t\t\ta2 = img->Bitdepth16To8[*wa++];\n\t\t\tm = img->UaToAa+((size_t) a2<<8);\n\t\t\tr2 = m[img->Bitdepth16To8[*wr++]];\n\t\t\tg2 = m[img->Bitdepth16To8[*wg++]];\n\t\t\tb2 = m[img->Bitdepth16To8[*wb++]];\n\t\t\t*cp++ = PACK4(r2,g2,b2,a2);\n\t\t}\n\t\tSKEW4(wr, wg, wb, wa, fromskew);\n\t\tcp += toskew;\n\t}\n}",
          "fn_code_pos": [
            [
              1723,
              0
            ],
            [
              1744,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLARESepPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putcontig8bitCIELab)\n{\n\tfloat X, Y, Z;\n\tuint32 r, g, b;\n\t(void) y;\n\tfromskew *= 3;\n\tfor( ; h > 0; --h) {\n\t\tfor (x = w; x > 0; --x) {\n\t\t\tTIFFCIELabToXYZ(img->cielab,\n\t\t\t\t\t(unsigned char)pp[0],\n\t\t\t\t\t(signed char)pp[1],\n\t\t\t\t\t(signed char)pp[2],\n\t\t\t\t\t&X, &Y, &Z);\n\t\t\tTIFFXYZToRGB(img->cielab, X, Y, Z, &r, &g, &b);\n\t\t\t*cp++ = PACK(r, g, b);\n\t\t\tpp += 3;\n\t\t}\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t}\n}",
          "fn_code_pos": [
            [
              1749,
              0
            ],
            [
              1769,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static void putcontig8bitYCbCrGenericTile( \n    TIFFRGBAImage* img, \n    uint32* cp, \n    uint32 x, uint32 y, \n    uint32 w, uint32 h, \n    int32 fromskew, int32 toskew, \n    unsigned char* pp,\n    int h_group, \n    int v_group )\n\n{\n    uint32* cp1 = cp+w+toskew;\n    uint32* cp2 = cp1+w+toskew;\n    uint32* cp3 = cp2+w+toskew;\n    int32 incr = 3*w+4*toskew;\n    int32   Cb, Cr;\n    int     group_size = v_group * h_group + 2;\n\n    (void) y;\n    fromskew = (fromskew * group_size) / h_group;\n\n    for( yy = 0; yy < h; yy++ )\n    {\n        unsigned char *pp_line;\n        int     y_line_group = yy / v_group;\n        int     y_remainder = yy - y_line_group * v_group;\n\n        pp_line = pp + v_line_group * \n\n        \n        for( xx = 0; xx < w; xx++ )\n        {\n            Cb = pp\n        }\n    }\n    for (; h >= 4; h -= 4) {\n\tx = w>>2;\n\tdo {\n\t    Cb = pp[16];\n\t    Cr = pp[17];\n\n\t    YCbCrtoRGB(cp [0], pp[ 0]);\n\t    YCbCrtoRGB(cp [1], pp[ 1]);\n\t    YCbCrtoRGB(cp [2], pp[ 2]);\n\t    YCbCrtoRGB(cp [3], pp[ 3]);\n\t    YCbCrtoRGB(cp1[0], pp[ 4]);\n\t    YCbCrtoRGB(cp1[1], pp[ 5]);\n\t    YCbCrtoRGB(cp1[2], pp[ 6]);\n\t    YCbCrtoRGB(cp1[3], pp[ 7]);\n\t    YCbCrtoRGB(cp2[0], pp[ 8]);\n\t    YCbCrtoRGB(cp2[1], pp[ 9]);\n\t    YCbCrtoRGB(cp2[2], pp[10]);\n\t    YCbCrtoRGB(cp2[3], pp[11]);\n\t    YCbCrtoRGB(cp3[0], pp[12]);\n\t    YCbCrtoRGB(cp3[1], pp[13]);\n\t    YCbCrtoRGB(cp3[2], pp[14]);\n\t    YCbCrtoRGB(cp3[3], pp[15]);\n\n\t    cp += 4, cp1 += 4, cp2 += 4, cp3 += 4;\n\t    pp += 18;\n\t} while (--x);\n\tcp += incr, cp1 += incr, cp2 += incr, cp3 += incr;\n\tpp += fromskew;\n    }\n}",
          "fn_code_pos": [
            [
              1790,
              0
            ],
            [
              1854,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "putcontig8bitYCbCrGenericTile",
            "parameters": {
              "img": "TIFFRGBAImage",
              "cp": "uint32",
              "x": "uint32",
              "y": "uint32",
              "w": "uint32",
              "h": "uint32",
              "fromskew": "int32",
              "toskew": "int32",
              "pp": "unsigned char",
              "h_group": "int",
              "v_group": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putcontig8bitYCbCr44tile)\n{\n    uint32* cp1 = cp+w+toskew;\n    uint32* cp2 = cp1+w+toskew;\n    uint32* cp3 = cp2+w+toskew;\n    int32 incr = 3*w+4*toskew;\n\n    (void) y;\n    /* adjust fromskew */\n    fromskew = (fromskew / 4) * (4*2+2);\n    if ((h & 3) == 0 && (w & 3) == 0) {\t\t\t\t        \n        for (; h >= 4; h -= 4) {\n            x = w>>2;\n            do {\n                int32 Cb = pp[16];\n                int32 Cr = pp[17];\n\n                YCbCrtoRGB(cp [0], pp[ 0]);\n                YCbCrtoRGB(cp [1], pp[ 1]);\n                YCbCrtoRGB(cp [2], pp[ 2]);\n                YCbCrtoRGB(cp [3], pp[ 3]);\n                YCbCrtoRGB(cp1[0], pp[ 4]);\n                YCbCrtoRGB(cp1[1], pp[ 5]);\n                YCbCrtoRGB(cp1[2], pp[ 6]);\n                YCbCrtoRGB(cp1[3], pp[ 7]);\n                YCbCrtoRGB(cp2[0], pp[ 8]);\n                YCbCrtoRGB(cp2[1], pp[ 9]);\n                YCbCrtoRGB(cp2[2], pp[10]);\n                YCbCrtoRGB(cp2[3], pp[11]);\n                YCbCrtoRGB(cp3[0], pp[12]);\n                YCbCrtoRGB(cp3[1], pp[13]);\n                YCbCrtoRGB(cp3[2], pp[14]);\n                YCbCrtoRGB(cp3[3], pp[15]);\n\n                cp += 4;\n                cp1 += 4;\n                cp2 += 4;\n                cp3 += 4;\n                pp += 18;\n            } while (--x);\n            cp += incr;\n            cp1 += incr;\n            cp2 += incr;\n            cp3 += incr;\n            pp += fromskew;\n        }\n    } else {\n        while (h > 0) {\n            for (x = w; x > 0;) {\n                int32 Cb = pp[16];\n                int32 Cr = pp[17];\n                switch (x) {\n                default:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp3[3], pp[15]); /* FALLTHROUGH */\n                    case 3:  YCbCrtoRGB(cp2[3], pp[11]); /* FALLTHROUGH */\n                    case 2:  YCbCrtoRGB(cp1[3], pp[ 7]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [3], pp[ 3]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 3:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp3[2], pp[14]); /* FALLTHROUGH */\n                    case 3:  YCbCrtoRGB(cp2[2], pp[10]); /* FALLTHROUGH */\n                    case 2:  YCbCrtoRGB(cp1[2], pp[ 6]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [2], pp[ 2]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 2:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp3[1], pp[13]); /* FALLTHROUGH */\n                    case 3:  YCbCrtoRGB(cp2[1], pp[ 9]); /* FALLTHROUGH */\n                    case 2:  YCbCrtoRGB(cp1[1], pp[ 5]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [1], pp[ 1]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 1:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp3[0], pp[12]); /* FALLTHROUGH */\n                    case 3:  YCbCrtoRGB(cp2[0], pp[ 8]); /* FALLTHROUGH */\n                    case 2:  YCbCrtoRGB(cp1[0], pp[ 4]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [0], pp[ 0]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                }\n                if (x < 4) {\n                    cp += x; cp1 += x; cp2 += x; cp3 += x;\n                    x = 0;\n                }\n                else {\n                    cp += 4; cp1 += 4; cp2 += 4; cp3 += 4;\n                    x -= 4;\n                }\n                pp += 18;\n            }\n            if (h <= 4)\n                break;\n            h -= 4;\n            cp += incr;\n            cp1 += incr;\n            cp2 += incr;\n            cp3 += incr;\n            pp += fromskew;\n        }\n    }\n}",
          "fn_code_pos": [
            [
              1860,
              0
            ],
            [
              1961,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putcontig8bitYCbCr42tile)\n{\n    uint32* cp1 = cp+w+toskew;\n    int32 incr = 2*toskew+w;\n\n    (void) y;\n    fromskew = (fromskew / 4) * (4*2+2);\n    if ((w & 3) == 0 && (h & 1) == 0) {\n        for (; h >= 2; h -= 2) {\n            x = w>>2;\n            do {\n                int32 Cb = pp[8];\n                int32 Cr = pp[9];\n                \n                YCbCrtoRGB(cp [0], pp[0]);\n                YCbCrtoRGB(cp [1], pp[1]);\n                YCbCrtoRGB(cp [2], pp[2]);\n                YCbCrtoRGB(cp [3], pp[3]);\n                YCbCrtoRGB(cp1[0], pp[4]);\n                YCbCrtoRGB(cp1[1], pp[5]);\n                YCbCrtoRGB(cp1[2], pp[6]);\n                YCbCrtoRGB(cp1[3], pp[7]);\n                \n                cp += 4;\n                cp1 += 4;\n                pp += 10;\n            } while (--x);\n            cp += incr;\n            cp1 += incr;\n            pp += fromskew;\n        }\n    } else {\n        while (h > 0) {\n            for (x = w; x > 0;) {\n                int32 Cb = pp[8];\n                int32 Cr = pp[9];\n                switch (x) {\n                default:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp1[3], pp[ 7]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [3], pp[ 3]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 3:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp1[2], pp[ 6]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [2], pp[ 2]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 2:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp1[1], pp[ 5]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [1], pp[ 1]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                case 1:\n                    switch (h) {\n                    default: YCbCrtoRGB(cp1[0], pp[ 4]); /* FALLTHROUGH */\n                    case 1:  YCbCrtoRGB(cp [0], pp[ 0]); /* FALLTHROUGH */\n                    }                                    /* FALLTHROUGH */\n                }\n                if (x < 4) {\n                    cp += x; cp1 += x;\n                    x = 0;\n                }\n                else {\n                    cp += 4; cp1 += 4;\n                    x -= 4;\n                }\n                pp += 10;\n            }\n            if (h <= 2)\n                break;\n            h -= 2;\n            cp += incr;\n            cp1 += incr;\n            pp += fromskew;\n        }\n    }\n}",
          "fn_code_pos": [
            [
              1966,
              0
            ],
            [
              2042,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putcontig8bitYCbCr41tile)\n{\n    (void) y;\n    fromskew = (fromskew / 4) * (4*1+2);\n    do {\n\tx = w>>2;\n\twhile(x>0) {\n\t    int32 Cb = pp[4];\n\t    int32 Cr = pp[5];\n\n\t    YCbCrtoRGB(cp [0], pp[0]);\n\t    YCbCrtoRGB(cp [1], pp[1]);\n\t    YCbCrtoRGB(cp [2], pp[2]);\n\t    YCbCrtoRGB(cp [3], pp[3]);\n\n\t    cp += 4;\n\t    pp += 6;\n\t\tx--;\n\t}\n\n        if( (w&3) != 0 )\n        {\n\t    int32 Cb = pp[4];\n\t    int32 Cr = pp[5];\n\n            switch( (w&3) ) {\n              case 3: YCbCrtoRGB(cp [2], pp[2]); /*-fallthrough*/\n              case 2: YCbCrtoRGB(cp [1], pp[1]); /*-fallthrough*/\n              case 1: YCbCrtoRGB(cp [0], pp[0]); /*-fallthrough*/\n              case 0: break;\n            }\n\n            cp += (w&3);\n            pp += 6;\n        }\n\n\tcp += toskew;\n\tpp += fromskew;\n    } while (--h);\n\n}",
          "fn_code_pos": [
            [
              2047,
              0
            ],
            [
              2087,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putcontig8bitYCbCr22tile)\n{\n\tuint32* cp2;\n\tint32 incr = 2*toskew+w;\n\t(void) y;\n\tfromskew = (fromskew / 2) * (2*2+2);\n\tcp2 = cp+w+toskew;\n\twhile (h>=2) {\n\t\tx = w;\n\t\twhile (x>=2) {\n\t\t\tuint32 Cb = pp[4];\n\t\t\tuint32 Cr = pp[5];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp[1], pp[1]);\n\t\t\tYCbCrtoRGB(cp2[0], pp[2]);\n\t\t\tYCbCrtoRGB(cp2[1], pp[3]);\n\t\t\tcp += 2;\n\t\t\tcp2 += 2;\n\t\t\tpp += 6;\n\t\t\tx -= 2;\n\t\t}\n\t\tif (x==1) {\n\t\t\tuint32 Cb = pp[4];\n\t\t\tuint32 Cr = pp[5];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp2[0], pp[2]);\n\t\t\tcp ++ ;\n\t\t\tcp2 ++ ;\n\t\t\tpp += 6;\n\t\t}\n\t\tcp += incr;\n\t\tcp2 += incr;\n\t\tpp += fromskew;\n\t\th-=2;\n\t}\n\tif (h==1) {\n\t\tx = w;\n\t\twhile (x>=2) {\n\t\t\tuint32 Cb = pp[4];\n\t\t\tuint32 Cr = pp[5];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp[1], pp[1]);\n\t\t\tcp += 2;\n\t\t\tcp2 += 2;\n\t\t\tpp += 6;\n\t\t\tx -= 2;\n\t\t}\n\t\tif (x==1) {\n\t\t\tuint32 Cb = pp[4];\n\t\t\tuint32 Cr = pp[5];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              2092,
              0
            ],
            [
              2145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putcontig8bitYCbCr21tile)\n{\n\t(void) y;\n\tfromskew = (fromskew / 2) * (2*1+2);\n\tdo {\n\t\tx = w>>1;\n\t\twhile(x>0) {\n\t\t\tint32 Cb = pp[2];\n\t\t\tint32 Cr = pp[3];\n\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp[1], pp[1]);\n\n\t\t\tcp += 2;\n\t\t\tpp += 4;\n\t\t\tx --;\n\t\t}\n\n\t\tif( (w&1) != 0 )\n\t\t{\n\t\t\tint32 Cb = pp[2];\n\t\t\tint32 Cr = pp[3];\n\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\n\t\t\tcp += 1;\n\t\t\tpp += 4;\n\t\t}\n\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t} while (--h);\n}",
          "fn_code_pos": [
            [
              2150,
              0
            ],
            [
              2182,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putcontig8bitYCbCr12tile)\n{\n\tuint32* cp2;\n\tint32 incr = 2*toskew+w;\n\t(void) y;\n\tfromskew = (fromskew / 1) * (1 * 2 + 2);\n\tcp2 = cp+w+toskew;\n\twhile (h>=2) {\n\t\tx = w;\n\t\tdo {\n\t\t\tuint32 Cb = pp[2];\n\t\t\tuint32 Cr = pp[3];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp2[0], pp[1]);\n\t\t\tcp ++;\n\t\t\tcp2 ++;\n\t\t\tpp += 4;\n\t\t} while (--x);\n\t\tcp += incr;\n\t\tcp2 += incr;\n\t\tpp += fromskew;\n\t\th-=2;\n\t}\n\tif (h==1) {\n\t\tx = w;\n\t\tdo {\n\t\t\tuint32 Cb = pp[2];\n\t\t\tuint32 Cr = pp[3];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tcp ++;\n\t\t\tpp += 4;\n\t\t} while (--x);\n\t}\n}",
          "fn_code_pos": [
            [
              2187,
              0
            ],
            [
              2220,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putcontig8bitYCbCr11tile)\n{\n\t(void) y;\n\tfromskew = (fromskew / 1) * (1 * 1 + 2);\n\tdo {\n\t\tx = w; /* was x = w>>1; patched 2000/09/25 warmerda@home.com */\n\t\tdo {\n\t\t\tint32 Cb = pp[1];\n\t\t\tint32 Cr = pp[2];\n\n\t\t\tYCbCrtoRGB(*cp++, pp[0]);\n\n\t\t\tpp += 3;\n\t\t} while (--x);\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t} while (--h);\n}",
          "fn_code_pos": [
            [
              2225,
              0
            ],
            [
              2242,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLARESepPutFunc(putseparate8bitYCbCr11tile)\n{\n\t(void) y;\n\t(void) a;\n\t/* TODO: naming of input vars is still off, change obfuscating declaration inside define, or resolve obfuscation */\n\tfor( ; h > 0; --h) {\n\t\tx = w;\n\t\tdo {\n\t\t\tuint32 dr, dg, db;\n\t\t\tTIFFYCbCrtoRGB(img->ycbcr,*r++,*g++,*b++,&dr,&dg,&db);\n\t\t\t*cp++ = PACK(dr,dg,db);\n\t\t} while (--x);\n\t\tSKEW(r, g, b, fromskew);\n\t\tcp += toskew;\n\t}\n}",
          "fn_code_pos": [
            [
              2247,
              0
            ],
            [
              2262,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLARESepPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static int isInRefBlackWhiteRange(float f)\n{\n    return f > (float)(-0x7FFFFFFF + 128) && f < (float)0x7FFFFFFF;\n}",
          "fn_code_pos": [
            [
              2265,
              0
            ],
            [
              2268,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "isInRefBlackWhiteRange",
            "parameters": {
              "f": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ninitYCbCrConversion(TIFFRGBAImage* img)\n{\n\tstatic const char module[] = \"initYCbCrConversion\";\n\n\tfloat *luma, *refBlackWhite;\n\n\tif (img->ycbcr == NULL) {\n\t\timg->ycbcr = (TIFFYCbCrToRGB*) _TIFFmalloc(\n\t\t    TIFFroundup_32(sizeof (TIFFYCbCrToRGB), sizeof (long))  \n\t\t    + 4*256*sizeof (TIFFRGBValue)\n\t\t    + 2*256*sizeof (int)\n\t\t    + 3*256*sizeof (int32)\n\t\t    );\n\t\tif (img->ycbcr == NULL) {\n\t\t\tTIFFErrorExt(img->tif->tif_clientdata, module,\n\t\t\t    \"No space for YCbCr->RGB conversion state\");\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\tTIFFGetFieldDefaulted(img->tif, TIFFTAG_YCBCRCOEFFICIENTS, &luma);\n\tTIFFGetFieldDefaulted(img->tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t    &refBlackWhite);\n\n        /* Do some validation to avoid later issues. Detect NaN for now */\n        /* and also if lumaGreen is zero since we divide by it later */\n        if( luma[0] != luma[0] ||\n            luma[1] != luma[1] ||\n            luma[1] == 0.0 ||\n            luma[2] != luma[2] )\n        {\n            TIFFErrorExt(img->tif->tif_clientdata, module,\n                \"Invalid values for YCbCrCoefficients tag\");\n            return (0);\n        }\n\n        if( !isInRefBlackWhiteRange(refBlackWhite[0]) ||\n            !isInRefBlackWhiteRange(refBlackWhite[1]) ||\n            !isInRefBlackWhiteRange(refBlackWhite[2]) ||\n            !isInRefBlackWhiteRange(refBlackWhite[3]) ||\n            !isInRefBlackWhiteRange(refBlackWhite[4]) ||\n            !isInRefBlackWhiteRange(refBlackWhite[5]) )\n        {\n            TIFFErrorExt(img->tif->tif_clientdata, module,\n                \"Invalid values for ReferenceBlackWhite tag\");\n            return (0);\n        }\n\n\tif (TIFFYCbCrToRGBInit(img->ycbcr, luma, refBlackWhite) < 0)\n\t\treturn(0);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              2270,
              0
            ],
            [
              2322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initYCbCrConversion",
            "parameters": {
              "img": "TIFFRGBAImage"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static tileContigRoutine\ninitCIELabConversion(TIFFRGBAImage* img)\n{\n\tstatic const char module[] = \"initCIELabConversion\";\n\n\tfloat   *whitePoint;\n\tfloat   refWhite[3];\n\n\tTIFFGetFieldDefaulted(img->tif, TIFFTAG_WHITEPOINT, &whitePoint);\n\tif (whitePoint[1] == 0.0f ) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, module,\n\t\t    \"Invalid value for WhitePoint tag.\");\n\t\treturn NULL;\n        }\n\n\tif (!img->cielab) {\n\t\timg->cielab = (TIFFCIELabToRGB *)\n\t\t\t_TIFFmalloc(sizeof(TIFFCIELabToRGB));\n\t\tif (!img->cielab) {\n\t\t\tTIFFErrorExt(img->tif->tif_clientdata, module,\n\t\t\t    \"No space for CIE L*a*b*->RGB conversion state.\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\trefWhite[1] = 100.0F;\n\trefWhite[0] = whitePoint[0] / whitePoint[1] * refWhite[1];\n\trefWhite[2] = (1.0F - whitePoint[0] - whitePoint[1])\n\t\t      / whitePoint[1] * refWhite[1];\n\tif (TIFFCIELabToRGBInit(img->cielab, &display_sRGB, refWhite) < 0) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, module,\n\t\t    \"Failed to initialize CIE L*a*b*->RGB conversion state.\");\n\t\t_TIFFfree(img->cielab);\n\t\treturn NULL;\n\t}\n\n\treturn putcontig8bitCIELab;\n}",
          "fn_code_pos": [
            [
              2324,
              0
            ],
            [
              2361,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initCIELabConversion",
            "parameters": {
              "img": "TIFFRGBAImage"
            },
            "return_type": "tileContigRoutine"
          }
        },
        {
          "fn_code": "static int\nmakebwmap(TIFFRGBAImage* img)\n{\n    TIFFRGBValue* Map = img->Map;\n    int bitspersample = img->bitspersample;\n    int nsamples = 8 / bitspersample;\n    int i;\n    uint32* p;\n\n    if( nsamples == 0 )\n        nsamples = 1;\n\n    img->BWmap = (uint32**) _TIFFmalloc(\n\t256*sizeof (uint32 *)+(256*nsamples*sizeof(uint32)));\n    if (img->BWmap == NULL) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"No space for B&W mapping table\");\n\t\treturn (0);\n    }\n    p = (uint32*)(img->BWmap + 256);\n    for (i = 0; i < 256; i++) {\n\tTIFFRGBValue c;\n\timg->BWmap[i] = p;\n\tswitch (bitspersample) {\n#define\tGREY(x)\tc = Map[x]; *p++ = PACK(c,c,c);\n\tcase 1:\n\t    GREY(i>>7);\n\t    GREY((i>>6)&1);\n\t    GREY((i>>5)&1);\n\t    GREY((i>>4)&1);\n\t    GREY((i>>3)&1);\n\t    GREY((i>>2)&1);\n\t    GREY((i>>1)&1);\n\t    GREY(i&1);\n\t    break;\n\tcase 2:\n\t    GREY(i>>6);\n\t    GREY((i>>4)&3);\n\t    GREY((i>>2)&3);\n\t    GREY(i&3);\n\t    break;\n\tcase 4:\n\t    GREY(i>>4);\n\t    GREY(i&0xf);\n\t    break;\n\tcase 8:\n        case 16:\n\t    GREY(i);\n\t    break;\n\t}\n#undef\tGREY\n    }\n    return (1);\n}",
          "fn_code_pos": [
            [
              2370,
              0
            ],
            [
              2422,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "makebwmap",
            "parameters": {
              "img": "TIFFRGBAImage"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nsetupMap(TIFFRGBAImage* img)\n{\n    int32 x, range;\n\n    range = (int32)((1L<<img->bitspersample)-1);\n    \n    /* treat 16 bit the same as eight bit */\n    if( img->bitspersample == 16 )\n        range = (int32) 255;\n\n    img->Map = (TIFFRGBValue*) _TIFFmalloc((range+1) * sizeof (TIFFRGBValue));\n    if (img->Map == NULL) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif),\n\t\t\t\"No space for photometric conversion table\");\n\t\treturn (0);\n    }\n    if (img->photometric == PHOTOMETRIC_MINISWHITE) {\n\tfor (x = 0; x <= range; x++)\n\t    img->Map[x] = (TIFFRGBValue) (((range - x) * 255) / range);\n    } else {\n\tfor (x = 0; x <= range; x++)\n\t    img->Map[x] = (TIFFRGBValue) ((x * 255) / range);\n    }\n    if (img->bitspersample <= 16 &&\n\t(img->photometric == PHOTOMETRIC_MINISBLACK ||\n\t img->photometric == PHOTOMETRIC_MINISWHITE)) {\n\t/*\n\t * Use photometric mapping table to construct\n\t * unpacking tables for samples <= 8 bits.\n\t */\n\tif (!makebwmap(img))\n\t    return (0);\n\t/* no longer need Map, free it */\n\t_TIFFfree(img->Map);\n\timg->Map = NULL;\n    }\n    return (1);\n}",
          "fn_code_pos": [
            [
              2429,
              0
            ],
            [
              2467,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setupMap",
            "parameters": {
              "img": "TIFFRGBAImage"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncheckcmap(TIFFRGBAImage* img)\n{\n    uint16* r = img->redcmap;\n    uint16* g = img->greencmap;\n    uint16* b = img->bluecmap;\n    long n = 1L<<img->bitspersample;\n\n    while (n-- > 0)\n\tif (*r++ >= 256 || *g++ >= 256 || *b++ >= 256)\n\t    return (16);\n    return (8);\n}",
          "fn_code_pos": [
            [
              2469,
              0
            ],
            [
              2481,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "checkcmap",
            "parameters": {
              "img": "TIFFRGBAImage"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ncvtcmap(TIFFRGBAImage* img)\n{\n    uint16* r = img->redcmap;\n    uint16* g = img->greencmap;\n    uint16* b = img->bluecmap;\n    long i;\n\n    for (i = (1L<<img->bitspersample)-1; i >= 0; i--) {\n#define\tCVT(x)\t\t((uint16)((x)>>8))\n\tr[i] = CVT(r[i]);\n\tg[i] = CVT(g[i]);\n\tb[i] = CVT(b[i]);\n#undef\tCVT\n    }\n}",
          "fn_code_pos": [
            [
              2483,
              0
            ],
            [
              2498,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cvtcmap",
            "parameters": {
              "img": "TIFFRGBAImage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nmakecmap(TIFFRGBAImage* img)\n{\n    int bitspersample = img->bitspersample;\n    int nsamples = 8 / bitspersample;\n    uint16* r = img->redcmap;\n    uint16* g = img->greencmap;\n    uint16* b = img->bluecmap;\n    uint32 *p;\n    int i;\n\n    img->PALmap = (uint32**) _TIFFmalloc(\n\t256*sizeof (uint32 *)+(256*nsamples*sizeof(uint32)));\n    if (img->PALmap == NULL) {\n\t\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"No space for Palette mapping table\");\n\t\treturn (0);\n\t}\n    p = (uint32*)(img->PALmap + 256);\n    for (i = 0; i < 256; i++) {\n\tTIFFRGBValue c;\n\timg->PALmap[i] = p;\n#define\tCMAP(x)\tc = (TIFFRGBValue) x; *p++ = PACK(r[c]&0xff, g[c]&0xff, b[c]&0xff);\n\tswitch (bitspersample) {\n\tcase 1:\n\t    CMAP(i>>7);\n\t    CMAP((i>>6)&1);\n\t    CMAP((i>>5)&1);\n\t    CMAP((i>>4)&1);\n\t    CMAP((i>>3)&1);\n\t    CMAP((i>>2)&1);\n\t    CMAP((i>>1)&1);\n\t    CMAP(i&1);\n\t    break;\n\tcase 2:\n\t    CMAP(i>>6);\n\t    CMAP((i>>4)&3);\n\t    CMAP((i>>2)&3);\n\t    CMAP(i&3);\n\t    break;\n\tcase 4:\n\t    CMAP(i>>4);\n\t    CMAP(i&0xf);\n\t    break;\n\tcase 8:\n\t    CMAP(i);\n\t    break;\n\t}\n#undef CMAP\n    }\n    return (1);\n}",
          "fn_code_pos": [
            [
              2507,
              0
            ],
            [
              2557,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "makecmap",
            "parameters": {
              "img": "TIFFRGBAImage"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nbuildMap(TIFFRGBAImage* img)\n{\n    switch (img->photometric) {\n    case PHOTOMETRIC_RGB:\n    case PHOTOMETRIC_YCBCR:\n    case PHOTOMETRIC_SEPARATED:\n\tif (img->bitspersample == 8)\n\t    break;\n\t/* fall through... */\n    case PHOTOMETRIC_MINISBLACK:\n    case PHOTOMETRIC_MINISWHITE:\n\tif (!setupMap(img))\n\t    return (0);\n\tbreak;\n    case PHOTOMETRIC_PALETTE:\n\t/*\n\t * Convert 16-bit colormap to 8-bit (unless it looks\n\t * like an old-style 8-bit colormap).\n\t */\n\tif (checkcmap(img) == 16)\n\t    cvtcmap(img);\n\telse\n\t    TIFFWarningExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"Assuming 8-bit colormap\");\n\t/*\n\t * Use mapping table and colormap to construct\n\t * unpacking tables for samples < 8 bits.\n\t */\n\tif (img->bitspersample <= 8 && !makecmap(img))\n\t    return (0);\n\tbreak;\n    }\n    return (1);\n}",
          "fn_code_pos": [
            [
              2563,
              0
            ],
            [
              2596,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "buildMap",
            "parameters": {
              "img": "TIFFRGBAImage"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPickContigCase(TIFFRGBAImage* img)\n{\n\timg->get = TIFFIsTiled(img->tif) ? gtTileContig : gtStripContig;\n\timg->put.contig = NULL;\n\tswitch (img->photometric) {\n\t\tcase PHOTOMETRIC_RGB:\n\t\t\tswitch (img->bitspersample) {\n\t\t\t\tcase 8:\n\t\t\t\t\tif (img->alpha == EXTRASAMPLE_ASSOCALPHA &&\n\t\t\t\t\t\timg->samplesperpixel >= 4)\n\t\t\t\t\t\timg->put.contig = putRGBAAcontig8bittile;\n\t\t\t\t\telse if (img->alpha == EXTRASAMPLE_UNASSALPHA &&\n\t\t\t\t\t\t\t img->samplesperpixel >= 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (BuildMapUaToAa(img))\n\t\t\t\t\t\t\timg->put.contig = putRGBUAcontig8bittile;\n\t\t\t\t\t}\n\t\t\t\t\telse if( img->samplesperpixel >= 3 )\n\t\t\t\t\t\timg->put.contig = putRGBcontig8bittile;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\tif (img->alpha == EXTRASAMPLE_ASSOCALPHA &&\n\t\t\t\t\t\timg->samplesperpixel >=4 )\n\t\t\t\t\t{\n\t\t\t\t\t\tif (BuildMapBitdepth16To8(img))\n\t\t\t\t\t\t\timg->put.contig = putRGBAAcontig16bittile;\n\t\t\t\t\t}\n\t\t\t\t\telse if (img->alpha == EXTRASAMPLE_UNASSALPHA &&\n\t\t\t\t\t\t\t img->samplesperpixel >=4 )\n\t\t\t\t\t{\n\t\t\t\t\t\tif (BuildMapBitdepth16To8(img) &&\n\t\t\t\t\t\t    BuildMapUaToAa(img))\n\t\t\t\t\t\t\timg->put.contig = putRGBUAcontig16bittile;\n\t\t\t\t\t}\n\t\t\t\t\telse if( img->samplesperpixel >=3 )\n\t\t\t\t\t{\n\t\t\t\t\t\tif (BuildMapBitdepth16To8(img))\n\t\t\t\t\t\t\timg->put.contig = putRGBcontig16bittile;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_SEPARATED:\n\t\t\tif (img->samplesperpixel >=4 && buildMap(img)) {\n\t\t\t\tif (img->bitspersample == 8) {\n\t\t\t\t\tif (!img->Map)\n\t\t\t\t\t\timg->put.contig = putRGBcontig8bitCMYKtile;\n\t\t\t\t\telse\n\t\t\t\t\t\timg->put.contig = putRGBcontig8bitCMYKMaptile;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_PALETTE:\n\t\t\tif (buildMap(img)) {\n\t\t\t\tswitch (img->bitspersample) {\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\timg->put.contig = put8bitcmaptile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\timg->put.contig = put4bitcmaptile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\timg->put.contig = put2bitcmaptile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\timg->put.contig = put1bitcmaptile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\t\tif (buildMap(img)) {\n\t\t\t\tswitch (img->bitspersample) {\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\timg->put.contig = put16bitbwtile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\tif (img->alpha && img->samplesperpixel == 2)\n\t\t\t\t\t\t\timg->put.contig = putagreytile;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\timg->put.contig = putgreytile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\timg->put.contig = put4bitbwtile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\timg->put.contig = put2bitbwtile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\timg->put.contig = put1bitbwtile;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_YCBCR:\n\t\t\tif ((img->bitspersample==8) && (img->samplesperpixel==3))\n\t\t\t{\n\t\t\t\tif (initYCbCrConversion(img)!=0)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * The 6.0 spec says that subsampling must be\n\t\t\t\t\t * one of 1, 2, or 4, and that vertical subsampling\n\t\t\t\t\t * must always be <= horizontal subsampling; so\n\t\t\t\t\t * there are only a few possibilities and we just\n\t\t\t\t\t * enumerate the cases.\n\t\t\t\t\t * Joris: added support for the [1,2] case, nonetheless, to accommodate\n\t\t\t\t\t * some OJPEG files\n\t\t\t\t\t */\n\t\t\t\t\tuint16 SubsamplingHor;\n\t\t\t\t\tuint16 SubsamplingVer;\n\t\t\t\t\tTIFFGetFieldDefaulted(img->tif, TIFFTAG_YCBCRSUBSAMPLING, &SubsamplingHor, &SubsamplingVer);\n\t\t\t\t\tswitch ((SubsamplingHor<<4)|SubsamplingVer) {\n\t\t\t\t\t\tcase 0x44:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr44tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x42:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr42tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x41:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr41tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x22:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr22tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x21:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr21tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x12:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr12tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x11:\n\t\t\t\t\t\t\timg->put.contig = putcontig8bitYCbCr11tile;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_CIELAB:\n\t\t\tif (img->samplesperpixel == 3 && buildMap(img)) {\n\t\t\t\tif (img->bitspersample == 8)\n\t\t\t\t\timg->put.contig = initCIELabConversion(img);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn ((img->get!=NULL) && (img->put.contig!=NULL));\n}",
          "fn_code_pos": [
            [
              2601,
              0
            ],
            [
              2748,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PickContigCase",
            "parameters": {
              "img": "TIFFRGBAImage"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPickSeparateCase(TIFFRGBAImage* img)\n{\n\timg->get = TIFFIsTiled(img->tif) ? gtTileSeparate : gtStripSeparate;\n\timg->put.separate = NULL;\n\tswitch (img->photometric) {\n\tcase PHOTOMETRIC_MINISWHITE:\n\tcase PHOTOMETRIC_MINISBLACK:\n\t\t/* greyscale images processed pretty much as RGB by gtTileSeparate */\n\tcase PHOTOMETRIC_RGB:\n\t\tswitch (img->bitspersample) {\n\t\tcase 8:\n\t\t\tif (img->alpha == EXTRASAMPLE_ASSOCALPHA)\n\t\t\t\timg->put.separate = putRGBAAseparate8bittile;\n\t\t\telse if (img->alpha == EXTRASAMPLE_UNASSALPHA)\n\t\t\t{\n\t\t\t\tif (BuildMapUaToAa(img))\n\t\t\t\t\timg->put.separate = putRGBUAseparate8bittile;\n\t\t\t}\n\t\t\telse\n\t\t\t\timg->put.separate = putRGBseparate8bittile;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tif (img->alpha == EXTRASAMPLE_ASSOCALPHA)\n\t\t\t{\n\t\t\t\tif (BuildMapBitdepth16To8(img))\n\t\t\t\t\timg->put.separate = putRGBAAseparate16bittile;\n\t\t\t}\n\t\t\telse if (img->alpha == EXTRASAMPLE_UNASSALPHA)\n\t\t\t{\n\t\t\t\tif (BuildMapBitdepth16To8(img) &&\n\t\t\t\t    BuildMapUaToAa(img))\n\t\t\t\t\timg->put.separate = putRGBUAseparate16bittile;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (BuildMapBitdepth16To8(img))\n\t\t\t\t\timg->put.separate = putRGBseparate16bittile;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_SEPARATED:\n\t\tif (img->bitspersample == 8 && img->samplesperpixel == 4)\n\t\t{\n\t\t\timg->alpha = 1; // Not alpha, but seems like the only way to get 4th band\n\t\t\timg->put.separate = putCMYKseparate8bittile;\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_YCBCR:\n\t\tif ((img->bitspersample==8) && (img->samplesperpixel==3))\n\t\t{\n\t\t\tif (initYCbCrConversion(img)!=0)\n\t\t\t{\n\t\t\t\tuint16 hs, vs;\n\t\t\t\tTIFFGetFieldDefaulted(img->tif, TIFFTAG_YCBCRSUBSAMPLING, &hs, &vs);\n\t\t\t\tswitch ((hs<<4)|vs) {\n\t\t\t\tcase 0x11:\n\t\t\t\t\timg->put.separate = putseparate8bitYCbCr11tile;\n\t\t\t\t\tbreak;\n\t\t\t\t\t/* TODO: add other cases here */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn ((img->get!=NULL) && (img->put.separate!=NULL));\n}",
          "fn_code_pos": [
            [
              2756,
              0
            ],
            [
              2823,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PickSeparateCase",
            "parameters": {
              "img": "TIFFRGBAImage"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nBuildMapUaToAa(TIFFRGBAImage* img)\n{\n\tstatic const char module[]=\"BuildMapUaToAa\";\n\tuint8* m;\n\tuint16 na,nv;\n\tassert(img->UaToAa==NULL);\n\timg->UaToAa=_TIFFmalloc(65536);\n\tif (img->UaToAa==NULL)\n\t{\n\t\tTIFFErrorExt(img->tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tm=img->UaToAa;\n\tfor (na=0; na<256; na++)\n\t{\n\t\tfor (nv=0; nv<256; nv++)\n\t\t\t*m++=(uint8)((nv*na+127)/255);\n\t}\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              2825,
              0
            ],
            [
              2845,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BuildMapUaToAa",
            "parameters": {
              "img": "TIFFRGBAImage"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nBuildMapBitdepth16To8(TIFFRGBAImage* img)\n{\n\tstatic const char module[]=\"BuildMapBitdepth16To8\";\n\tuint8* m;\n\tuint32 n;\n\tassert(img->Bitdepth16To8==NULL);\n\timg->Bitdepth16To8=_TIFFmalloc(65536);\n\tif (img->Bitdepth16To8==NULL)\n\t{\n\t\tTIFFErrorExt(img->tif->tif_clientdata,module,\"Out of memory\");\n\t\treturn(0);\n\t}\n\tm=img->Bitdepth16To8;\n\tfor (n=0; n<65536; n++)\n\t\t*m++=(uint8)((n+128)/257);\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              2847,
              0
            ],
            [
              2864,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BuildMapBitdepth16To8",
            "parameters": {
              "img": "TIFFRGBAImage"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFReadRGBAStrip(TIFF* tif, uint32 row, uint32 * raster )\n\n{\n    return TIFFReadRGBAStripExt(tif, row, raster, 0 );\n}",
          "fn_code_pos": [
            [
              2875,
              0
            ],
            [
              2880,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRGBAStrip",
            "parameters": {
              "tif": "TIFF",
              "row": "uint32",
              "raster": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFReadRGBAStripExt(TIFF* tif, uint32 row, uint32 * raster, int stop_on_error)\n\n{\n    char \temsg[1024] = \"\";\n    TIFFRGBAImage img;\n    int \tok;\n    uint32\trowsperstrip, rows_to_read;\n\n    if( TIFFIsTiled( tif ) )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n                  \"Can't use TIFFReadRGBAStrip() with tiled file.\");\n\treturn (0);\n    }\n    \n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    if( (row % rowsperstrip) != 0 )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n\t\t\t\t\"Row passed to TIFFReadRGBAStrip() must be first in a strip.\");\n\t\treturn (0);\n    }\n\n    if (TIFFRGBAImageOK(tif, emsg) && TIFFRGBAImageBegin(&img, tif, stop_on_error, emsg)) {\n\n        img.row_offset = row;\n        img.col_offset = 0;\n\n        if( row + rowsperstrip > img.height )\n            rows_to_read = img.height - row;\n        else\n            rows_to_read = rowsperstrip;\n        \n\tok = TIFFRGBAImageGet(&img, raster, img.width, rows_to_read );\n        \n\tTIFFRGBAImageEnd(&img);\n    } else {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", emsg);\n\t\tok = 0;\n    }\n    \n    return (ok);\n}",
          "fn_code_pos": [
            [
              2882,
              0
            ],
            [
              2925,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRGBAStripExt",
            "parameters": {
              "tif": "TIFF",
              "row": "uint32",
              "raster": "uint32",
              "stop_on_error": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFReadRGBATile(TIFF* tif, uint32 col, uint32 row, uint32 * raster)\n\n{\n    return TIFFReadRGBATileExt(tif, col, row, raster, 0 );\n}",
          "fn_code_pos": [
            [
              2933,
              0
            ],
            [
              2938,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRGBATile",
            "parameters": {
              "tif": "TIFF",
              "col": "uint32",
              "row": "uint32",
              "raster": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFReadRGBATileExt(TIFF* tif, uint32 col, uint32 row, uint32 * raster, int stop_on_error )\n{\n    char \temsg[1024] = \"\";\n    TIFFRGBAImage img;\n    int \tok;\n    uint32\ttile_xsize, tile_ysize;\n    uint32\tread_xsize, read_ysize;\n    uint32\ti_row;\n\n    /*\n     * Verify that our request is legal - on a tile file, and on a\n     * tile boundary.\n     */\n    \n    if( !TIFFIsTiled( tif ) )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n\t\t\t\t  \"Can't use TIFFReadRGBATile() with stripped file.\");\n\t\treturn (0);\n    }\n    \n    TIFFGetFieldDefaulted(tif, TIFFTAG_TILEWIDTH, &tile_xsize);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_TILELENGTH, &tile_ysize);\n    if( (col % tile_xsize) != 0 || (row % tile_ysize) != 0 )\n    {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n                  \"Row/col passed to TIFFReadRGBATile() must be top\"\n                  \"left corner of a tile.\");\n\treturn (0);\n    }\n\n    /*\n     * Setup the RGBA reader.\n     */\n    \n    if (!TIFFRGBAImageOK(tif, emsg) \n\t|| !TIFFRGBAImageBegin(&img, tif, stop_on_error, emsg)) {\n\t    TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"%s\", emsg);\n\t    return( 0 );\n    }\n\n    /*\n     * The TIFFRGBAImageGet() function doesn't allow us to get off the\n     * edge of the image, even to fill an otherwise valid tile.  So we\n     * figure out how much we can read, and fix up the tile buffer to\n     * a full tile configuration afterwards.\n     */\n\n    if( row + tile_ysize > img.height )\n        read_ysize = img.height - row;\n    else\n        read_ysize = tile_ysize;\n    \n    if( col + tile_xsize > img.width )\n        read_xsize = img.width - col;\n    else\n        read_xsize = tile_xsize;\n\n    /*\n     * Read the chunk of imagery.\n     */\n    \n    img.row_offset = row;\n    img.col_offset = col;\n\n    ok = TIFFRGBAImageGet(&img, raster, read_xsize, read_ysize );\n        \n    TIFFRGBAImageEnd(&img);\n\n    /*\n     * If our read was incomplete we will need to fix up the tile by\n     * shifting the data around as if a full tile of data is being returned.\n     *\n     * This is all the more complicated because the image is organized in\n     * bottom to top format. \n     */\n\n    if( read_xsize == tile_xsize && read_ysize == tile_ysize )\n        return( ok );\n\n    for( i_row = 0; i_row < read_ysize; i_row++ ) {\n        memmove( raster + (tile_ysize - i_row - 1) * tile_xsize,\n                 raster + (read_ysize - i_row - 1) * read_xsize,\n                 read_xsize * sizeof(uint32) );\n        _TIFFmemset( raster + (tile_ysize - i_row - 1) * tile_xsize+read_xsize,\n                     0, sizeof(uint32) * (tile_xsize - read_xsize) );\n    }\n\n    for( i_row = read_ysize; i_row < tile_ysize; i_row++ ) {\n        _TIFFmemset( raster + (tile_ysize - i_row - 1) * tile_xsize,\n                     0, sizeof(uint32) * tile_xsize );\n    }\n\n    return (ok);\n}",
          "fn_code_pos": [
            [
              2941,
              0
            ],
            [
              3036,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRGBATileExt",
            "parameters": {
              "tif": "TIFF",
              "col": "uint32",
              "row": "uint32",
              "raster": "uint32",
              "stop_on_error": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "gtTileContig(TIFFRGBAImage*, uint32*, uint32, uint32)",
          "fn_dec_pos": [
            [
              32,
              11
            ],
            [
              32,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gtTileContig",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "gtTileSeparate(TIFFRGBAImage*, uint32*, uint32, uint32)",
          "fn_dec_pos": [
            [
              33,
              11
            ],
            [
              33,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gtTileSeparate",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "gtStripContig(TIFFRGBAImage*, uint32*, uint32, uint32)",
          "fn_dec_pos": [
            [
              34,
              11
            ],
            [
              34,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gtStripContig",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "gtStripSeparate(TIFFRGBAImage*, uint32*, uint32, uint32)",
          "fn_dec_pos": [
            [
              35,
              11
            ],
            [
              35,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gtStripSeparate",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "PickContigCase(TIFFRGBAImage*)",
          "fn_dec_pos": [
            [
              36,
              11
            ],
            [
              36,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PickContigCase",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "PickSeparateCase(TIFFRGBAImage*)",
          "fn_dec_pos": [
            [
              37,
              11
            ],
            [
              37,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PickSeparateCase",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "BuildMapUaToAa(TIFFRGBAImage* img)",
          "fn_dec_pos": [
            [
              39,
              11
            ],
            [
              39,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BuildMapUaToAa",
            "parameters": {
              "img": "TIFFRGBAImage"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "BuildMapBitdepth16To8(TIFFRGBAImage* img)",
          "fn_dec_pos": [
            [
              40,
              11
            ],
            [
              40,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BuildMapBitdepth16To8",
            "parameters": {
              "img": "TIFFRGBAImage"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_error.c": {
      "fn_def_list": [
        {
          "fn_code": "TIFFErrorHandler\nTIFFSetErrorHandler(TIFFErrorHandler handler)\n{\n\tTIFFErrorHandler prev = _TIFFerrorHandler;\n\t_TIFFerrorHandler = handler;\n\treturn (prev);\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              37,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetErrorHandler",
            "parameters": {
              "handler": "TIFFErrorHandler"
            },
            "return_type": "TIFFErrorHandler"
          }
        },
        {
          "fn_code": "TIFFErrorHandlerExt\nTIFFSetErrorHandlerExt(TIFFErrorHandlerExt handler)\n{\n\tTIFFErrorHandlerExt prev = _TIFFerrorHandlerExt;\n\t_TIFFerrorHandlerExt = handler;\n\treturn (prev);\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              45,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetErrorHandlerExt",
            "parameters": {
              "handler": "TIFFErrorHandlerExt"
            },
            "return_type": "TIFFErrorHandlerExt"
          }
        },
        {
          "fn_code": "void\nTIFFError(const char* module, const char* fmt, ...)\n{\n\tva_list ap;\n\tif (_TIFFerrorHandler) {\n\t\tva_start(ap, fmt);\t\n\t\t(*_TIFFerrorHandler)(module, fmt, ap);\n\t\tva_end(ap);\n\t}\n\tif (_TIFFerrorHandlerExt) {\n\t\tva_start(ap, fmt);\n\t\t(*_TIFFerrorHandlerExt)(0, module, fmt, ap);\n\t\tva_end(ap);\n\t}\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              61,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFError",
            "parameters": {
              "module": "char",
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFErrorExt(thandle_t fd, const char* module, const char* fmt, ...)\n{\n\tva_list ap;\n\tif (_TIFFerrorHandler) {\n\t\tva_start(ap, fmt);\n\t\t(*_TIFFerrorHandler)(module, fmt, ap);\n\t\tva_end(ap);\n\t}\n\tif (_TIFFerrorHandlerExt) {\n\t\tva_start(ap, fmt);\n\t\t(*_TIFFerrorHandlerExt)(fd, module, fmt, ap);\n\t\tva_end(ap);\n\t}\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFErrorExt",
            "parameters": {
              "fd": "thandle_t",
              "module": "char",
              "fmt": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_dumpmode.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nDumpFixupTags(TIFF* tif)\n{\n\t(void) tif;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              36,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DumpFixupTags",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nDumpModeEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)\n{\n\t(void) s;\n\twhile (cc > 0) {\n\t\ttmsize_t n;\n\n\t\tn = cc;\n\t\tif (tif->tif_rawcc + n > tif->tif_rawdatasize)\n\t\t\tn = tif->tif_rawdatasize - tif->tif_rawcc;\n\n\t\tassert( n > 0 );\n\n\t\t/*\n\t\t * Avoid copy if client has setup raw\n\t\t * data buffer to avoid extra copy.\n\t\t */\n\t\tif (tif->tif_rawcp != pp)\n\t\t\t_TIFFmemcpy(tif->tif_rawcp, pp, n);\n\t\ttif->tif_rawcp += n;\n\t\ttif->tif_rawcc += n;\n\t\tpp += n;\n\t\tcc -= n;\n\t\tif (tif->tif_rawcc >= tif->tif_rawdatasize &&\n\t\t    !TIFFFlushData1(tif))\n\t\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              69,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DumpModeEncode",
            "parameters": {
              "tif": "TIFF",
              "pp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nDumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n{\n\tstatic const char module[] = \"DumpModeDecode\";\n\t(void) s;\n\tif (tif->tif_rawcc < cc) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\"Not enough data for scanline %lu, expected a request for at most %I64d bytes, got a request for %I64d bytes\",\n\t\t             (unsigned long) tif->tif_row,\n\t\t             (signed __int64) tif->tif_rawcc,\n\t\t             (signed __int64) cc);\n#else\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\"Not enough data for scanline %lu, expected a request for at most %lld bytes, got a request for %lld bytes\",\n\t\t             (unsigned long) tif->tif_row,\n\t\t             (signed long long) tif->tif_rawcc,\n\t\t             (signed long long) cc);\n#endif\n\t\treturn (0);\n\t}\n\t/*\n\t * Avoid copy if client has setup raw\n\t * data buffer to avoid extra copy.\n\t */\n\tif (tif->tif_rawcp != buf)\n\t\t_TIFFmemcpy(buf, tif->tif_rawcp, cc);\n\ttif->tif_rawcp += cc;\n\ttif->tif_rawcc -= cc;  \n\treturn (1);\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              104,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DumpModeDecode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nDumpModeSeek(TIFF* tif, uint32 nrows)\n{\n\ttif->tif_rawcp += nrows * tif->tif_scanlinesize;\n\ttif->tif_rawcc -= nrows * tif->tif_scanlinesize;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              109,
              0
            ],
            [
              115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DumpModeSeek",
            "parameters": {
              "tif": "TIFF",
              "nrows": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFInitDumpMode(TIFF* tif, int scheme)\n{\n\t(void) scheme;\n\ttif->tif_fixuptags = DumpFixupTags;  \n\ttif->tif_decoderow = DumpModeDecode;\n\ttif->tif_decodestrip = DumpModeDecode;\n\ttif->tif_decodetile = DumpModeDecode;\n\ttif->tif_encoderow = DumpModeEncode;\n\ttif->tif_encodestrip = DumpModeEncode;\n\ttif->tif_encodetile = DumpModeEncode; \n\ttif->tif_seek = DumpModeSeek;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              120,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitDumpMode",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_jbig.c": {
      "fn_def_list": [
        {
          "fn_code": "static int JBIGSetupDecode(TIFF* tif)\n{\n\tif (TIFFNumberOfStrips(tif) != 1)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, \"JBIG\", \"Multistrip images not supported in decoder\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              37,
              0
            ],
            [
              46,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JBIGSetupDecode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int JBIGDecode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s)\n{\n\tstruct jbg_dec_state decoder;\n\tint decodeStatus = 0;\n\tunsigned char* pImage = NULL;\n\tunsigned long decodedSize;\n\t(void) s;\n\n\tif (isFillOrder(tif, tif->tif_dir.td_fillorder))\n\t{\n\t\tTIFFReverseBits(tif->tif_rawcp, tif->tif_rawcc);\n\t}\n\n\tjbg_dec_init(&decoder);\n\n#if defined(HAVE_JBG_NEWLEN)\n\tjbg_newlen(tif->tif_rawcp, (size_t)tif->tif_rawcc);\n\t/*\n\t * I do not check the return status of jbg_newlen because even if this\n\t * function fails it does not necessarily mean that decoding the image\n\t * will fail.  It is generally only needed for received fax images\n\t * that do not contain the actual length of the image in the BIE\n\t * header.  I do not log when an error occurs because that will cause\n\t * problems when converting JBIG encoded TIFF's to\n\t * PostScript.  As long as the actual image length is contained in the\n\t * BIE header jbg_dec_in should succeed.\n\t */\n#endif /* HAVE_JBG_NEWLEN */\n\n\tdecodeStatus = jbg_dec_in(&decoder, (unsigned char*)tif->tif_rawcp,\n\t\t\t\t  (size_t)tif->tif_rawcc, NULL);\n\tif (JBG_EOK != decodeStatus)\n\t{\n\t\t/*\n\t\t * XXX: JBG_EN constant was defined in pre-2.0 releases of the\n\t\t * JBIG-KIT. Since the 2.0 the error reporting functions were\n\t\t * changed. We will handle both cases here.\n\t\t */\n\t\tTIFFErrorExt(tif->tif_clientdata,\n\t\t\t     \"JBIG\", \"Error (%d) decoding: %s\",\n\t\t\t     decodeStatus,\n#if defined(JBG_EN)\n\t\t\t     jbg_strerror(decodeStatus, JBG_EN)\n#else\n\t\t\t     jbg_strerror(decodeStatus)\n#endif\n\t\t\t     );\n\t\tjbg_dec_free(&decoder);\n\t\treturn 0;\n\t}\n\n\tdecodedSize = jbg_dec_getsize(&decoder);\n\tif( (tmsize_t)decodedSize < size )\n\t{\n\t    TIFFWarningExt(tif->tif_clientdata, \"JBIG\",\n\t                   \"Only decoded %lu bytes, whereas %lu requested\",\n\t                   decodedSize, (unsigned long)size);\n\t}\n\telse if( (tmsize_t)decodedSize > size )\n\t{\n\t    TIFFErrorExt(tif->tif_clientdata, \"JBIG\",\n\t                 \"Decoded %lu bytes, whereas %lu were requested\",\n\t                 decodedSize, (unsigned long)size);\n\t    jbg_dec_free(&decoder);\n\t    return 0;\n\t}\n\tpImage = jbg_dec_getimage(&decoder, 0);\n\t_TIFFmemcpy(buffer, pImage, decodedSize);\n\tjbg_dec_free(&decoder);\n\n        tif->tif_rawcp += tif->tif_rawcc;\n        tif->tif_rawcc = 0;\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JBIGDecode",
            "parameters": {
              "tif": "TIFF",
              "buffer": "uint8",
              "size": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int JBIGSetupEncode(TIFF* tif)\n{\n\tif (TIFFNumberOfStrips(tif) != 1)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, \"JBIG\", \"Multistrip images not supported in encoder\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              124,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JBIGSetupEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int JBIGCopyEncodedData(TIFF* tif, unsigned char* pp, size_t cc, uint16 s)\n{\n\t(void) s;\n\twhile (cc > 0)\n\t{\n\t\ttmsize_t n = (tmsize_t)cc;\n\n\t\tif (tif->tif_rawcc + n > tif->tif_rawdatasize)\n\t\t{\n\t\t\tn = tif->tif_rawdatasize - tif->tif_rawcc;\n\t\t}\n\n\t\tassert(n > 0);\n\t\t_TIFFmemcpy(tif->tif_rawcp, pp, n);\n\t\ttif->tif_rawcp += n;\n\t\ttif->tif_rawcc += n;\n\t\tpp += n;\n\t\tcc -= (size_t)n;\n\t\tif (tif->tif_rawcc >= tif->tif_rawdatasize &&\n\t\t    !TIFFFlushData1(tif))\n\t\t{\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              135,
              0
            ],
            [
              161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JBIGCopyEncodedData",
            "parameters": {
              "tif": "TIFF",
              "pp": "unsigned char",
              "cc": "size_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void JBIGOutputBie(unsigned char* buffer, size_t len, void* userData)\n{\n\tTIFF* tif = (TIFF*)userData;\n\n\tif (isFillOrder(tif, tif->tif_dir.td_fillorder))\n\t{\n\t\tTIFFReverseBits(buffer, (tmsize_t)len);\n\t}\n\n\tJBIGCopyEncodedData(tif, buffer, len, 0);\n}",
          "fn_code_pos": [
            [
              163,
              0
            ],
            [
              173,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JBIGOutputBie",
            "parameters": {
              "buffer": "unsigned char",
              "len": "size_t",
              "userData": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int JBIGEncode(TIFF* tif, uint8* buffer, tmsize_t size, uint16 s)\n{\n\tTIFFDirectory* dir = &tif->tif_dir;\n\tstruct jbg_enc_state encoder;\n\n\t(void) size, (void) s;\n\n\tjbg_enc_init(&encoder,\n\t\t     dir->td_imagewidth,\n\t\t     dir->td_imagelength,\n\t\t     1,\n\t\t     &buffer,\n\t\t     JBIGOutputBie,\n\t\t     tif);\n\t/*\n\t * jbg_enc_out does the \"real\" encoding.  As data is encoded,\n\t * JBIGOutputBie is called, which writes the data to the directory.\n\t */\n\tjbg_enc_out(&encoder);\n\tjbg_enc_free(&encoder);\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              175,
              0
            ],
            [
              197,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JBIGEncode",
            "parameters": {
              "tif": "TIFF",
              "buffer": "uint8",
              "size": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int TIFFInitJBIG(TIFF* tif, int scheme)\n{\n\tassert(scheme == COMPRESSION_JBIG);\n\n\t/*\n\t * These flags are set so the JBIG Codec can control when to reverse\n\t * bits and when not to and to allow the jbig decoder and bit reverser\n\t * to write to memory when necessary.\n\t */\n\ttif->tif_flags |= TIFF_NOBITREV;\n\ttif->tif_flags &= ~TIFF_MAPPED;\n\n\t/* Setup the function pointers for encode, decode, and cleanup. */\n\ttif->tif_setupdecode = JBIGSetupDecode;\n\ttif->tif_decodestrip = JBIGDecode;\n\n\ttif->tif_setupencode = JBIGSetupEncode;\n\ttif->tif_encodestrip = JBIGEncode;\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              199,
              0
            ],
            [
              219,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitJBIG",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct jbg_dec_state",
          {},
          "",
          [
            50,
            1
          ],
          [
            50,
            21
          ]
        ],
        [
          "struct jbg_enc_state",
          {},
          "",
          [
            178,
            1
          ],
          [
            178,
            21
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include \"jbig.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_color.c": {
      "fn_def_list": [
        {
          "fn_code": "void\nTIFFCIELabToXYZ(TIFFCIELabToRGB *cielab, uint32 l, int32 a, int32 b,\n\t\tfloat *X, float *Y, float *Z)\n{\n\tfloat L = (float)l * 100.0F / 255.0F;\n\tfloat cby, tmp;\n\n\tif( L < 8.856F ) {\n\t\t*Y = (L * cielab->Y0) / 903.292F;\n\t\tcby = 7.787F * (*Y / cielab->Y0) + 16.0F / 116.0F;\n\t} else {\n\t\tcby = (L + 16.0F) / 116.0F;\n\t\t*Y = cielab->Y0 * cby * cby * cby;\n\t}\n\n\ttmp = (float)a / 500.0F + cby;\n\tif( tmp < 0.2069F )\n\t\t*X = cielab->X0 * (tmp - 0.13793F) / 7.787F;\n\telse    \n\t\t*X = cielab->X0 * tmp * tmp * tmp;\n\n\ttmp = cby - (float)b / 200.0F;\n\tif( tmp < 0.2069F )\n\t\t*Z = cielab->Z0 * (tmp - 0.13793F) / 7.787F;\n\telse    \n\t\t*Z = cielab->Z0 * tmp * tmp * tmp;\n}",
          "fn_code_pos": [
            [
              42,
              0
            ],
            [
              68,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCIELabToXYZ",
            "parameters": {
              "cielab": "TIFFCIELabToRGB",
              "l": "uint32",
              "a": "int32",
              "b": "int32",
              "X": "float",
              "Y": "float",
              "Z": "float"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFXYZToRGB(TIFFCIELabToRGB *cielab, float X, float Y, float Z,\n\t     uint32 *r, uint32 *g, uint32 *b)\n{\n\tint i;\n\tfloat Yr, Yg, Yb;\n\tfloat *matrix = &cielab->display.d_mat[0][0];\n\n\t/* Multiply through the matrix to get luminosity values. */\n\tYr =  matrix[0] * X + matrix[1] * Y + matrix[2] * Z;\n\tYg =  matrix[3] * X + matrix[4] * Y + matrix[5] * Z;\n\tYb =  matrix[6] * X + matrix[7] * Y + matrix[8] * Z;\n\n\t/* Clip input */\n\tYr = TIFFmax(Yr, cielab->display.d_Y0R);\n\tYg = TIFFmax(Yg, cielab->display.d_Y0G);\n\tYb = TIFFmax(Yb, cielab->display.d_Y0B);\n\n\t/* Avoid overflow in case of wrong input values */\n\tYr = TIFFmin(Yr, cielab->display.d_YCR);\n\tYg = TIFFmin(Yg, cielab->display.d_YCG);\n\tYb = TIFFmin(Yb, cielab->display.d_YCB);\n\n\t/* Turn luminosity to colour value. */\n\ti = (int)((Yr - cielab->display.d_Y0R) / cielab->rstep);\n\ti = TIFFmin(cielab->range, i);\n\t*r = RINT(cielab->Yr2r[i]);\n\n\ti = (int)((Yg - cielab->display.d_Y0G) / cielab->gstep);\n\ti = TIFFmin(cielab->range, i);\n\t*g = RINT(cielab->Yg2g[i]);\n\n\ti = (int)((Yb - cielab->display.d_Y0B) / cielab->bstep);\n\ti = TIFFmin(cielab->range, i);\n\t*b = RINT(cielab->Yb2b[i]);\n\n\t/* Clip output. */\n\t*r = TIFFmin(*r, cielab->display.d_Vrwr);\n\t*g = TIFFmin(*g, cielab->display.d_Vrwg);\n\t*b = TIFFmin(*b, cielab->display.d_Vrwb);\n}",
          "fn_code_pos": [
            [
              74,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFXYZToRGB",
            "parameters": {
              "cielab": "TIFFCIELabToRGB",
              "X": "float",
              "Y": "float",
              "Z": "float",
              "r": "uint32",
              "g": "uint32",
              "b": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\nTIFFCIELabToRGBInit(TIFFCIELabToRGB* cielab,\n\t\t    const TIFFDisplay *display, float *refWhite)\n{\n\tint i;\n\tdouble dfGamma;\n\n\tcielab->range = CIELABTORGB_TABLE_RANGE;\n\n\t_TIFFmemcpy(&cielab->display, display, sizeof(TIFFDisplay));\n\n\t/* Red */\n\tdfGamma = 1.0 / cielab->display.d_gammaR ;\n\tcielab->rstep =\n\t\t(cielab->display.d_YCR - cielab->display.d_Y0R)\t/ cielab->range;\n\tfor(i = 0; i <= cielab->range; i++) {\n\t\tcielab->Yr2r[i] = cielab->display.d_Vrwr\n\t\t    * ((float)pow((double)i / cielab->range, dfGamma));\n\t}\n\n\t/* Green */\n\tdfGamma = 1.0 / cielab->display.d_gammaG ;\n\tcielab->gstep =\n\t    (cielab->display.d_YCR - cielab->display.d_Y0R) / cielab->range;\n\tfor(i = 0; i <= cielab->range; i++) {\n\t\tcielab->Yg2g[i] = cielab->display.d_Vrwg\n\t\t    * ((float)pow((double)i / cielab->range, dfGamma));\n\t}\n\n\t/* Blue */\n\tdfGamma = 1.0 / cielab->display.d_gammaB ;\n\tcielab->bstep =\n\t    (cielab->display.d_YCR - cielab->display.d_Y0R) / cielab->range;\n\tfor(i = 0; i <= cielab->range; i++) {\n\t\tcielab->Yb2b[i] = cielab->display.d_Vrwb\n\t\t    * ((float)pow((double)i / cielab->range, dfGamma));\n\t}\n\n\t/* Init reference white point */\n\tcielab->X0 = refWhite[0];\n\tcielab->Y0 = refWhite[1];\n\tcielab->Z0 = refWhite[2];\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              165,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCIELabToRGBInit",
            "parameters": {
              "cielab": "TIFFCIELabToRGB",
              "display": "TIFFDisplay",
              "refWhite": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\nTIFFYCbCrtoRGB(TIFFYCbCrToRGB *ycbcr, uint32 Y, int32 Cb, int32 Cr,\n\t       uint32 *r, uint32 *g, uint32 *b)\n{\n\tint32 i;\n\n\t/* XXX: Only 8-bit YCbCr input supported for now */\n\tY = HICLAMP(Y, 255);\n\tCb = CLAMP(Cb, 0, 255);\n\tCr = CLAMP(Cr, 0, 255);\n\n\ti = ycbcr->Y_tab[Y] + ycbcr->Cr_r_tab[Cr];\n\t*r = CLAMP(i, 0, 255);\n\ti = ycbcr->Y_tab[Y]\n\t    + (int)((ycbcr->Cb_g_tab[Cb] + ycbcr->Cr_g_tab[Cr]) >> SHIFT);\n\t*g = CLAMP(i, 0, 255);\n\ti = ycbcr->Y_tab[Y] + ycbcr->Cb_b_tab[Cb];\n\t*b = CLAMP(i, 0, 255);\n}",
          "fn_code_pos": [
            [
              179,
              0
            ],
            [
              197,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFYCbCrtoRGB",
            "parameters": {
              "ycbcr": "TIFFYCbCrToRGB",
              "Y": "uint32",
              "Cb": "int32",
              "Cr": "int32",
              "r": "uint32",
              "g": "uint32",
              "b": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static float CLAMPw(float v, float vmin, float vmax)\n{\n    if( v < vmin )\n    {\n        /* printf(\"%f clamped to %f\\n\", v, vmin); */\n        return vmin;\n    }\n    if( v > vmax )\n    {\n        /* printf(\"%f clamped to %f\\n\", v, vmax); */\n        return vmax;\n    }\n    return v;\n}",
          "fn_code_pos": [
            [
              201,
              0
            ],
            [
              214,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CLAMPw",
            "parameters": {
              "v": "float",
              "vmin": "float",
              "vmax": "float"
            },
            "return_type": "float"
          }
        },
        {
          "fn_code": "int\nTIFFYCbCrToRGBInit(TIFFYCbCrToRGB* ycbcr, float *luma, float *refBlackWhite)\n{\n    TIFFRGBValue* clamptab;\n    int i;\n    \n#define LumaRed\t    luma[0]\n#define LumaGreen   luma[1]\n#define LumaBlue    luma[2]\n\n    clamptab = (TIFFRGBValue*)(\n\t(uint8*) ycbcr+TIFFroundup_32(sizeof (TIFFYCbCrToRGB), sizeof (long)));  \n    _TIFFmemset(clamptab, 0, 256);\t\t/* v < 0 => 0 */\n    ycbcr->clamptab = (clamptab += 256);\n    for (i = 0; i < 256; i++)\n\tclamptab[i] = (TIFFRGBValue) i;\n    _TIFFmemset(clamptab+256, 255, 2*256);\t/* v > 255 => 255 */\n    ycbcr->Cr_r_tab = (int*) (clamptab + 3*256);\n    ycbcr->Cb_b_tab = ycbcr->Cr_r_tab + 256;\n    ycbcr->Cr_g_tab = (int32*) (ycbcr->Cb_b_tab + 256);\n    ycbcr->Cb_g_tab = ycbcr->Cr_g_tab + 256;\n    ycbcr->Y_tab = ycbcr->Cb_g_tab + 256;\n\n    { float f1 = 2-2*LumaRed;\t\tint32 D1 = FIX(CLAMP(f1,0.0F,2.0F));\n      float f2 = LumaRed*f1/LumaGreen;\tint32 D2 = -FIX(CLAMP(f2,0.0F,2.0F));\n      float f3 = 2-2*LumaBlue;\t\tint32 D3 = FIX(CLAMP(f3,0.0F,2.0F));\n      float f4 = LumaBlue*f3/LumaGreen;\tint32 D4 = -FIX(CLAMP(f4,0.0F,2.0F));\n      int x;\n\n#undef LumaBlue\n#undef LumaGreen\n#undef LumaRed\n      \n      /*\n       * i is the actual input pixel value in the range 0..255\n       * Cb and Cr values are in the range -128..127 (actually\n       * they are in a range defined by the ReferenceBlackWhite\n       * tag) so there is some range shifting to do here when\n       * constructing tables indexed by the raw pixel data.\n       */\n      for (i = 0, x = -128; i < 256; i++, x++) {\n\t    int32 Cr = (int32)CLAMPw(Code2V(x, refBlackWhite[4] - 128.0F,\n\t\t\t    refBlackWhite[5] - 128.0F, 127),\n                            -128.0F * 32, 128.0F * 32);\n\t    int32 Cb = (int32)CLAMPw(Code2V(x, refBlackWhite[2] - 128.0F,\n\t\t\t    refBlackWhite[3] - 128.0F, 127),\n                            -128.0F * 32, 128.0F * 32);\n\n\t    ycbcr->Cr_r_tab[i] = (int32)((D1*Cr + ONE_HALF)>>SHIFT);\n\t    ycbcr->Cb_b_tab[i] = (int32)((D3*Cb + ONE_HALF)>>SHIFT);\n\t    ycbcr->Cr_g_tab[i] = D2*Cr;\n\t    ycbcr->Cb_g_tab[i] = D4*Cb + ONE_HALF;\n\t    ycbcr->Y_tab[i] =\n\t\t    (int32)CLAMPw(Code2V(x + 128, refBlackWhite[0], refBlackWhite[1], 255),\n                                  -128.0F * 32, 128.0F * 32);\n      }\n    }\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              232,
              0
            ],
            [
              291,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFYCbCrToRGBInit",
            "parameters": {
              "ycbcr": "TIFFYCbCrToRGB",
              "luma": "float",
              "refBlackWhite": "float"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_close.c": {
      "fn_def_list": [
        {
          "fn_code": "void\nTIFFCleanup(TIFF* tif)\n{\n\t/*\n         * Flush buffered data and directory (if dirty).\n         */\n\tif (tif->tif_mode != O_RDONLY)\n\t\tTIFFFlush(tif);\n\t(*tif->tif_cleanup)(tif);\n\tTIFFFreeDirectory(tif);\n\n\tif (tif->tif_dirlist)\n\t\t_TIFFfree(tif->tif_dirlist);\n\n\t/*\n         * Clean up client info links.\n         */\n\twhile( tif->tif_clientinfo )\n\t{\n\t\tTIFFClientInfoLink *psLink = tif->tif_clientinfo;\n\n\t\ttif->tif_clientinfo = psLink->next;\n\t\t_TIFFfree( psLink->name );\n\t\t_TIFFfree( psLink );\n\t}\n\n\tif (tif->tif_rawdata && (tif->tif_flags&TIFF_MYBUFFER))\n\t\t_TIFFfree(tif->tif_rawdata);\n\tif (isMapped(tif))\n\t\tTIFFUnmapFileContents(tif, tif->tif_base, (toff_t)tif->tif_size);\n\n\t/*\n         * Clean up custom fields.\n         */\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\tuint32 i;\n\n\t\tfor (i = 0; i < tif->tif_nfields; i++) {\n\t\t\tTIFFField *fld = tif->tif_fields[i];\n\t\t\tif (fld->field_bit == FIELD_CUSTOM &&\n\t\t\t    strncmp(\"Tag \", fld->field_name, 4) == 0) {\n\t\t\t\t_TIFFfree(fld->field_name);\n\t\t\t\t_TIFFfree(fld);\n\t\t\t}\n\t\t}\n\n\t\t_TIFFfree(tif->tif_fields);\n\t}\n\n        if (tif->tif_nfieldscompat > 0) {\n                uint32 i;\n\n                for (i = 0; i < tif->tif_nfieldscompat; i++) {\n                        if (tif->tif_fieldscompat[i].allocated_size)\n                                _TIFFfree(tif->tif_fieldscompat[i].fields);\n                }\n                _TIFFfree(tif->tif_fieldscompat);\n        }\n\n\t_TIFFfree(tif);\n}",
          "fn_code_pos": [
            [
              43,
              0
            ],
            [
              103,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCleanup",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFClose(TIFF* tif)\n{\n\tTIFFCloseProc closeproc = tif->tif_closeproc;\n\tthandle_t fd = tif->tif_clientdata;\n\n\tTIFFCleanup(tif);\n\t(void) (*closeproc)(fd);\n}",
          "fn_code_pos": [
            [
              119,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFClose",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_luv.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nLogL16Decode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"LogL16Decode\";\n\tLogLuvState* sp = DecoderState(tif);\n\tint shft;\n\ttmsize_t i;\n\ttmsize_t npixels;\n\tunsigned char* bp;\n\tint16* tp;\n\tint16 b;\n\ttmsize_t cc;\n\tint rc;\n\n\tassert(s == 0);\n\tassert(sp != NULL);\n\n\tnpixels = occ / sp->pixel_size;\n\n\tif (sp->user_datafmt == SGILOGDATAFMT_16BIT)\n\t\ttp = (int16*) op;\n\telse {\n\t\tif(sp->tbuflen < npixels) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\t \"Translation buffer too short\");\n\t\t\treturn (0);\n\t\t}\n\t\ttp = (int16*) sp->tbuf;\n\t}\n\t_TIFFmemset((void*) tp, 0, npixels*sizeof (tp[0]));\n\n\tbp = (unsigned char*) tif->tif_rawcp;\n\tcc = tif->tif_rawcc;\n\t/* get each byte string */\n\tfor (shft = 8; shft >= 0; shft -=8) {\n\t\tfor (i = 0; i < npixels && cc > 0; ) {\n\t\t\tif (*bp >= 128) {\t\t/* run */\n\t\t\t\tif( cc < 2 )\n\t\t\t\t\tbreak;\n\t\t\t\trc = *bp++ + (2-128);\n\t\t\t\tb = (int16)(*bp++ << shft);\n\t\t\t\tcc -= 2;\n\t\t\t\twhile (rc-- && i < npixels)\n\t\t\t\t\ttp[i++] |= b;\n\t\t\t} else {\t\t\t/* non-run */\n\t\t\t\trc = *bp++;\t\t/* nul is noop */\n\t\t\t\twhile (--cc && rc-- && i < npixels)\n\t\t\t\t\ttp[i++] |= (int16)*bp++ << shft;\n\t\t\t}\n\t\t}\n\t\tif (i != npixels) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Not enough data at row %lu (short %I64d pixels)\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned __int64) (npixels - i));\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Not enough data at row %lu (short %llu pixels)\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long long) (npixels - i));\n#endif\n\t\t\ttif->tif_rawcp = (uint8*) bp;\n\t\t\ttif->tif_rawcc = cc;\n\t\t\treturn (0);\n\t\t}\n\t}\n\t(*sp->tfunc)(sp, op, npixels);\n\ttif->tif_rawcp = (uint8*) bp;\n\ttif->tif_rawcc = cc;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              252,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogL16Decode",
            "parameters": {
              "tif": "TIFF",
              "op": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLogLuvDecode24(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"LogLuvDecode24\";\n\tLogLuvState* sp = DecoderState(tif);\n\ttmsize_t cc;\n\ttmsize_t i;\n\ttmsize_t npixels;\n\tunsigned char* bp;\n\tuint32* tp;\n\n\tassert(s == 0);\n\tassert(sp != NULL);\n\n\tnpixels = occ / sp->pixel_size;\n\n\tif (sp->user_datafmt == SGILOGDATAFMT_RAW)\n\t\ttp = (uint32 *)op;\n\telse {\n\t\tif(sp->tbuflen < npixels) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\t \"Translation buffer too short\");\n\t\t\treturn (0);\n\t\t}\n\t\ttp = (uint32 *) sp->tbuf;\n\t}\n\t/* copy to array of uint32 */\n\tbp = (unsigned char*) tif->tif_rawcp;\n\tcc = tif->tif_rawcc;\n\tfor (i = 0; i < npixels && cc >= 3; i++) {\n\t\ttp[i] = bp[0] << 16 | bp[1] << 8 | bp[2];\n\t\tbp += 3;\n\t\tcc -= 3;\n\t}\n\ttif->tif_rawcp = (uint8*) bp;\n\ttif->tif_rawcc = cc;\n\tif (i != npixels) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Not enough data at row %lu (short %I64d pixels)\",\n\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t     (unsigned __int64) (npixels - i));\n#else\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Not enough data at row %lu (short %llu pixels)\",\n\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t     (unsigned long long) (npixels - i));\n#endif\n\t\treturn (0);\n\t}\n\t(*sp->tfunc)(sp, op, npixels);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              257,
              0
            ],
            [
              309,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvDecode24",
            "parameters": {
              "tif": "TIFF",
              "op": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLogLuvDecode32(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"LogLuvDecode32\";\n\tLogLuvState* sp;\n\tint shft;\n\ttmsize_t i;\n\ttmsize_t npixels;\n\tunsigned char* bp;\n\tuint32* tp;\n\tuint32 b;\n\ttmsize_t cc;\n\tint rc;\n\n\tassert(s == 0);\n\tsp = DecoderState(tif);\n\tassert(sp != NULL);\n\n\tnpixels = occ / sp->pixel_size;\n\n\tif (sp->user_datafmt == SGILOGDATAFMT_RAW)\n\t\ttp = (uint32*) op;\n\telse {\n\t\tif(sp->tbuflen < npixels) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\t \"Translation buffer too short\");\n\t\t\treturn (0);\n\t\t}\n\t\ttp = (uint32*) sp->tbuf;\n\t}\n\t_TIFFmemset((void*) tp, 0, npixels*sizeof (tp[0]));\n\n\tbp = (unsigned char*) tif->tif_rawcp;\n\tcc = tif->tif_rawcc;\n\t/* get each byte string */\n\tfor (shft = 24; shft >= 0; shft -=8) {\n\t\tfor (i = 0; i < npixels && cc > 0; ) {\n\t\t\tif (*bp >= 128) {\t\t/* run */\n\t\t\t\tif( cc < 2 )\n\t\t\t\t\tbreak;\n\t\t\t\trc = *bp++ + (2-128);\n\t\t\t\tb = (uint32)*bp++ << shft;\n\t\t\t\tcc -= 2;\n\t\t\t\twhile (rc-- && i < npixels)\n\t\t\t\t\ttp[i++] |= b;\n\t\t\t} else {\t\t\t/* non-run */\n\t\t\t\trc = *bp++;\t\t/* nul is noop */\n\t\t\t\twhile (--cc && rc-- && i < npixels)\n\t\t\t\t\ttp[i++] |= (uint32)*bp++ << shft;\n\t\t\t}\n\t\t}\n\t\tif (i != npixels) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Not enough data at row %lu (short %I64d pixels)\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned __int64) (npixels - i));\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Not enough data at row %lu (short %llu pixels)\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long long) (npixels - i));\n#endif\n\t\t\ttif->tif_rawcp = (uint8*) bp;\n\t\t\ttif->tif_rawcc = cc;\n\t\t\treturn (0);\n\t\t}\n\t}\n\t(*sp->tfunc)(sp, op, npixels);\n\ttif->tif_rawcp = (uint8*) bp;\n\ttif->tif_rawcc = cc;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              314,
              0
            ],
            [
              386,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvDecode32",
            "parameters": {
              "tif": "TIFF",
              "op": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLogLuvDecodeStrip(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\ttmsize_t rowlen = TIFFScanlineSize(tif);\n\n        if (rowlen == 0)\n                return 0;\n\n\tassert(cc%rowlen == 0);\n\twhile (cc && (*tif->tif_decoderow)(tif, bp, rowlen, s)) {\n\t\tbp += rowlen;\n\t\tcc -= rowlen;\n\t}\n\treturn (cc == 0);\n}",
          "fn_code_pos": [
            [
              393,
              0
            ],
            [
              407,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvDecodeStrip",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLogLuvDecodeTile(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\ttmsize_t rowlen = TIFFTileRowSize(tif);\n\n        if (rowlen == 0)\n                return 0;\n\n\tassert(cc%rowlen == 0);\n\twhile (cc && (*tif->tif_decoderow)(tif, bp, rowlen, s)) {\n\t\tbp += rowlen;\n\t\tcc -= rowlen;\n\t}\n\treturn (cc == 0);\n}",
          "fn_code_pos": [
            [
              414,
              0
            ],
            [
              428,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvDecodeTile",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLogL16Encode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\tstatic const char module[] = \"LogL16Encode\";\n\tLogLuvState* sp = EncoderState(tif);\n\tint shft;\n\ttmsize_t i;\n\ttmsize_t j;\n\ttmsize_t npixels;\n\tuint8* op;\n\tint16* tp;\n\tint16 b;\n\ttmsize_t occ;\n\tint rc=0, mask;\n\ttmsize_t beg;\n\n\tassert(s == 0);\n\tassert(sp != NULL);\n\tnpixels = cc / sp->pixel_size;\n\n\tif (sp->user_datafmt == SGILOGDATAFMT_16BIT)\n\t\ttp = (int16*) bp;\n\telse {\n\t\ttp = (int16*) sp->tbuf;\n\t\tif(sp->tbuflen < npixels) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\t \"Translation buffer too short\");\n\t\t\treturn (0);\n\t\t}\n\t\t(*sp->tfunc)(sp, bp, npixels);\n\t}\n\t/* compress each byte string */\n\top = tif->tif_rawcp;\n\tocc = tif->tif_rawdatasize - tif->tif_rawcc;\n\tfor (shft = 8; shft >= 0; shft -=8) {\n\t\tfor (i = 0; i < npixels; i += rc) {\n\t\t\tif (occ < 4) {\n\t\t\t\ttif->tif_rawcp = op;\n\t\t\t\ttif->tif_rawcc = tif->tif_rawdatasize - occ;\n\t\t\t\tif (!TIFFFlushData1(tif))\n\t\t\t\t\treturn (0);\n\t\t\t\top = tif->tif_rawcp;\n\t\t\t\tocc = tif->tif_rawdatasize - tif->tif_rawcc;\n\t\t\t}\n\t\t\tmask = 0xff << shft;\t\t/* find next run */\n\t\t\tfor (beg = i; beg < npixels; beg += rc) {\n\t\t\t\tb = (int16) (tp[beg] & mask);\n\t\t\t\trc = 1;\n\t\t\t\twhile (rc < 127+2 && beg+rc < npixels &&\n\t\t\t\t    (tp[beg+rc] & mask) == b)\n\t\t\t\t\trc++;\n\t\t\t\tif (rc >= MINRUN)\n\t\t\t\t\tbreak;\t\t/* long enough */\n\t\t\t}\n\t\t\tif (beg-i > 1 && beg-i < MINRUN) {\n\t\t\t\tb = (int16) (tp[i] & mask);/*check short run */\n\t\t\t\tj = i+1;\n\t\t\t\twhile ((tp[j++] & mask) == b)\n\t\t\t\t\tif (j == beg) {\n\t\t\t\t\t\t*op++ = (uint8)(128-2+j-i);\n\t\t\t\t\t\t*op++ = (uint8)(b >> shft);\n\t\t\t\t\t\tocc -= 2;\n\t\t\t\t\t\ti = beg;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\twhile (i < beg) {\t\t/* write out non-run */\n\t\t\t\tif ((j = beg-i) > 127) j = 127;\n\t\t\t\tif (occ < j+3) {\n\t\t\t\t\ttif->tif_rawcp = op;\n\t\t\t\t\ttif->tif_rawcc = tif->tif_rawdatasize - occ;\n\t\t\t\t\tif (!TIFFFlushData1(tif))\n\t\t\t\t\t\treturn (0);\n\t\t\t\t\top = tif->tif_rawcp;\n\t\t\t\t\tocc = tif->tif_rawdatasize - tif->tif_rawcc;\n\t\t\t\t}\n\t\t\t\t*op++ = (uint8) j; occ--;\n\t\t\t\twhile (j--) {\n\t\t\t\t\t*op++ = (uint8) (tp[i++] >> shft & 0xff);\n\t\t\t\t\tocc--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rc >= MINRUN) {\t\t/* write out run */\n\t\t\t\t*op++ = (uint8) (128-2+rc);\n\t\t\t\t*op++ = (uint8) (tp[beg] >> shft & 0xff);\n\t\t\t\tocc -= 2;\n\t\t\t} else\n\t\t\t\trc = 0;\n\t\t}\n\t}\n\ttif->tif_rawcp = op;\n\ttif->tif_rawcc = tif->tif_rawdatasize - occ;\n\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              433,
              0
            ],
            [
              527,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogL16Encode",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLogLuvEncode24(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\tstatic const char module[] = \"LogLuvEncode24\";\n\tLogLuvState* sp = EncoderState(tif);\n\ttmsize_t i;\n\ttmsize_t npixels;\n\ttmsize_t occ;\n\tuint8* op;\n\tuint32* tp;\n\n\tassert(s == 0);\n\tassert(sp != NULL);\n\tnpixels = cc / sp->pixel_size;\n\n\tif (sp->user_datafmt == SGILOGDATAFMT_RAW)\n\t\ttp = (uint32*) bp;\n\telse {\n\t\ttp = (uint32*) sp->tbuf;\n\t\tif(sp->tbuflen < npixels) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\t \"Translation buffer too short\");\n\t\t\treturn (0);\n\t\t}\n\t\t(*sp->tfunc)(sp, bp, npixels);\n\t}\n\t/* write out encoded pixels */\n\top = tif->tif_rawcp;\n\tocc = tif->tif_rawdatasize - tif->tif_rawcc;\n\tfor (i = npixels; i--; ) {\n\t\tif (occ < 3) {\n\t\t\ttif->tif_rawcp = op;\n\t\t\ttif->tif_rawcc = tif->tif_rawdatasize - occ;\n\t\t\tif (!TIFFFlushData1(tif))\n\t\t\t\treturn (0);\n\t\t\top = tif->tif_rawcp;\n\t\t\tocc = tif->tif_rawdatasize - tif->tif_rawcc;\n\t\t}\n\t\t*op++ = (uint8)(*tp >> 16);\n\t\t*op++ = (uint8)(*tp >> 8 & 0xff);\n\t\t*op++ = (uint8)(*tp++ & 0xff);\n\t\tocc -= 3;\n\t}\n\ttif->tif_rawcp = op;\n\ttif->tif_rawcc = tif->tif_rawdatasize - occ;\n\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              532,
              0
            ],
            [
              579,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvEncode24",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLogLuvEncode32(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\tstatic const char module[] = \"LogLuvEncode32\";\n\tLogLuvState* sp = EncoderState(tif);\n\tint shft;\n\ttmsize_t i;\n\ttmsize_t j;\n\ttmsize_t npixels;\n\tuint8* op;\n\tuint32* tp;\n\tuint32 b;\n\ttmsize_t occ;\n\tint rc=0, mask;\n\ttmsize_t beg;\n\n\tassert(s == 0);\n\tassert(sp != NULL);\n\n\tnpixels = cc / sp->pixel_size;\n\n\tif (sp->user_datafmt == SGILOGDATAFMT_RAW)\n\t\ttp = (uint32*) bp;\n\telse {\n\t\ttp = (uint32*) sp->tbuf;\n\t\tif(sp->tbuflen < npixels) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t\t \"Translation buffer too short\");\n\t\t\treturn (0);\n\t\t}\n\t\t(*sp->tfunc)(sp, bp, npixels);\n\t}\n\t/* compress each byte string */\n\top = tif->tif_rawcp;\n\tocc = tif->tif_rawdatasize - tif->tif_rawcc;\n\tfor (shft = 24; shft >= 0; shft -=8) {\n\t\tfor (i = 0; i < npixels; i += rc) {\n\t\t\tif (occ < 4) {\n\t\t\t\ttif->tif_rawcp = op;\n\t\t\t\ttif->tif_rawcc = tif->tif_rawdatasize - occ;\n\t\t\t\tif (!TIFFFlushData1(tif))\n\t\t\t\t\treturn (0);\n\t\t\t\top = tif->tif_rawcp;\n\t\t\t\tocc = tif->tif_rawdatasize - tif->tif_rawcc;\n\t\t\t}\n\t\t\tmask = 0xff << shft;\t\t/* find next run */\n\t\t\tfor (beg = i; beg < npixels; beg += rc) {\n\t\t\t\tb = tp[beg] & mask;\n\t\t\t\trc = 1;\n\t\t\t\twhile (rc < 127+2 && beg+rc < npixels &&\n\t\t\t\t\t\t(tp[beg+rc] & mask) == b)\n\t\t\t\t\trc++;\n\t\t\t\tif (rc >= MINRUN)\n\t\t\t\t\tbreak;\t\t/* long enough */\n\t\t\t}\n\t\t\tif (beg-i > 1 && beg-i < MINRUN) {\n\t\t\t\tb = tp[i] & mask;\t/* check short run */\n\t\t\t\tj = i+1;\n\t\t\t\twhile ((tp[j++] & mask) == b)\n\t\t\t\t\tif (j == beg) {\n\t\t\t\t\t\t*op++ = (uint8)(128-2+j-i);\n\t\t\t\t\t\t*op++ = (uint8)(b >> shft);\n\t\t\t\t\t\tocc -= 2;\n\t\t\t\t\t\ti = beg;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\twhile (i < beg) {\t\t/* write out non-run */\n\t\t\t\tif ((j = beg-i) > 127) j = 127;\n\t\t\t\tif (occ < j+3) {\n\t\t\t\t\ttif->tif_rawcp = op;\n\t\t\t\t\ttif->tif_rawcc = tif->tif_rawdatasize - occ;\n\t\t\t\t\tif (!TIFFFlushData1(tif))\n\t\t\t\t\t\treturn (0);\n\t\t\t\t\top = tif->tif_rawcp;\n\t\t\t\t\tocc = tif->tif_rawdatasize - tif->tif_rawcc;\n\t\t\t\t}\n\t\t\t\t*op++ = (uint8) j; occ--;\n\t\t\t\twhile (j--) {\n\t\t\t\t\t*op++ = (uint8)(tp[i++] >> shft & 0xff);\n\t\t\t\t\tocc--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rc >= MINRUN) {\t\t/* write out run */\n\t\t\t\t*op++ = (uint8) (128-2+rc);\n\t\t\t\t*op++ = (uint8)(tp[beg] >> shft & 0xff);\n\t\t\t\tocc -= 2;\n\t\t\t} else\n\t\t\t\trc = 0;\n\t\t}\n\t}\n\ttif->tif_rawcp = op;\n\ttif->tif_rawcc = tif->tif_rawdatasize - occ;\n\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              584,
              0
            ],
            [
              679,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvEncode32",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLogLuvEncodeStrip(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\ttmsize_t rowlen = TIFFScanlineSize(tif);\n\n        if (rowlen == 0)\n                return 0;\n\n\tassert(cc%rowlen == 0);\n\twhile (cc && (*tif->tif_encoderow)(tif, bp, rowlen, s) == 1) {\n\t\tbp += rowlen;\n\t\tcc -= rowlen;\n\t}\n\treturn (cc == 0);\n}",
          "fn_code_pos": [
            [
              685,
              0
            ],
            [
              699,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvEncodeStrip",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLogLuvEncodeTile(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\ttmsize_t rowlen = TIFFTileRowSize(tif);\n\n        if (rowlen == 0)\n                return 0;\n\n\tassert(cc%rowlen == 0);\n\twhile (cc && (*tif->tif_encoderow)(tif, bp, rowlen, s) == 1) {\n\t\tbp += rowlen;\n\t\tcc -= rowlen;\n\t}\n\treturn (cc == 0);\n}",
          "fn_code_pos": [
            [
              705,
              0
            ],
            [
              719,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvEncodeTile",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "double\nLogL16toY(int p16)\t\t/* compute luminance from 16-bit LogL */\n{\n\tint\tLe = p16 & 0x7fff;\n\tdouble\tY;\n\n\tif (!Le)\n\t\treturn (0.);\n\tY = exp(M_LN2/256.*(Le+.5) - M_LN2*64.);\n\treturn (!(p16 & 0x8000) ? Y : -Y);\n}",
          "fn_code_pos": [
            [
              751,
              0
            ],
            [
              761,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogL16toY",
            "parameters": {
              "p16": "int"
            },
            "return_type": "double"
          }
        },
        {
          "fn_code": "int\nLogL16fromY(double Y, int em)\t/* get 16-bit LogL from Y */\n{\n\tif (Y >= 1.8371976e19)\n\t\treturn (0x7fff);\n\tif (Y <= -1.8371976e19)\n\t\treturn (0xffff);\n\tif (Y > 5.4136769e-20)\n\t\treturn itrunc(256.*(log2(Y) + 64.), em);\n\tif (Y < -5.4136769e-20)\n\t\treturn (~0x7fff | itrunc(256.*(log2(-Y) + 64.), em));\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              766,
              0
            ],
            [
              778,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogL16fromY",
            "parameters": {
              "Y": "double",
              "em": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nL16toY(LogLuvState* sp, uint8* op, tmsize_t n)\n{\n\tint16* l16 = (int16*) sp->tbuf;\n\tfloat* yp = (float*) op;\n\n\twhile (n-- > 0)\n\t\t*yp++ = (float)LogL16toY(*l16++);\n}",
          "fn_code_pos": [
            [
              780,
              0
            ],
            [
              788,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "L16toY",
            "parameters": {
              "sp": "LogLuvState",
              "op": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nL16toGry(LogLuvState* sp, uint8* op, tmsize_t n)\n{\n\tint16* l16 = (int16*) sp->tbuf;\n\tuint8* gp = (uint8*) op;\n\n\twhile (n-- > 0) {\n\t\tdouble Y = LogL16toY(*l16++);\n\t\t*gp++ = (uint8) ((Y <= 0.) ? 0 : (Y >= 1.) ? 255 : (int)(256.*sqrt(Y)));\n\t}\n}",
          "fn_code_pos": [
            [
              790,
              0
            ],
            [
              800,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "L16toGry",
            "parameters": {
              "sp": "LogLuvState",
              "op": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nL16fromY(LogLuvState* sp, uint8* op, tmsize_t n)\n{\n\tint16* l16 = (int16*) sp->tbuf;\n\tfloat* yp = (float*) op;\n\n\twhile (n-- > 0)\n\t\t*l16++ = (int16) (LogL16fromY(*yp++, sp->encode_meth));\n}",
          "fn_code_pos": [
            [
              802,
              0
            ],
            [
              810,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "L16fromY",
            "parameters": {
              "sp": "LogLuvState",
              "op": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nXYZtoRGB24(float xyz[3], uint8 rgb[3])\n{\n\tdouble\tr, g, b;\n\t\t\t\t\t/* assume CCIR-709 primaries */\n\tr =  2.690*xyz[0] + -1.276*xyz[1] + -0.414*xyz[2];\n\tg = -1.022*xyz[0] +  1.978*xyz[1] +  0.044*xyz[2];\n\tb =  0.061*xyz[0] + -0.224*xyz[1] +  1.163*xyz[2];\n\t\t\t\t\t/* assume 2.0 gamma for speed */\n\t/* could use integer sqrt approx., but this is probably faster */\n\trgb[0] = (uint8)((r<=0.) ? 0 : (r >= 1.) ? 255 : (int)(256.*sqrt(r)));\n\trgb[1] = (uint8)((g<=0.) ? 0 : (g >= 1.) ? 255 : (int)(256.*sqrt(g)));\n\trgb[2] = (uint8)((b<=0.) ? 0 : (b >= 1.) ? 255 : (int)(256.*sqrt(b)));\n}",
          "fn_code_pos": [
            [
              815,
              0
            ],
            [
              828,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XYZtoRGB24",
            "parameters": {
              "xyz": "float",
              "rgb": "uint8"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "double\nLogL10toY(int p10)\t\t/* compute luminance from 10-bit LogL */\n{\n\tif (p10 == 0)\n\t\treturn (0.);\n\treturn (exp(M_LN2/64.*(p10+.5) - M_LN2*12.));\n}",
          "fn_code_pos": [
            [
              833,
              0
            ],
            [
              839,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogL10toY",
            "parameters": {
              "p10": "int"
            },
            "return_type": "double"
          }
        },
        {
          "fn_code": "int\nLogL10fromY(double Y, int em)\t/* get 10-bit LogL from Y */\n{\n\tif (Y >= 15.742)\n\t\treturn (0x3ff);\n\telse if (Y <= .00024283)\n\t\treturn (0);\n\telse\n\t\treturn itrunc(64.*(log2(Y) + 12.), em);\n}",
          "fn_code_pos": [
            [
              844,
              0
            ],
            [
              853,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogL10fromY",
            "parameters": {
              "Y": "double",
              "em": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\noog_encode(double u, double v)\t\t/* encode out-of-gamut chroma */\n{\n\tstatic int\toog_table[NANGLES];\n\tstatic int\tinitialized = 0;\n\tregister int\ti;\n\n\tif (!initialized) {\t\t/* set up perimeter table */\n\t\tdouble\teps[NANGLES], ua, va, ang, epsa;\n\t\tint\tui, vi, ustep;\n\t\tfor (i = NANGLES; i--; )\n\t\t\teps[i] = 2.;\n\t\tfor (vi = UV_NVS; vi--; ) {\n\t\t\tva = UV_VSTART + (vi+.5)*UV_SQSIZ;\n\t\t\tustep = uv_row[vi].nus-1;\n\t\t\tif (vi == UV_NVS-1 || vi == 0 || ustep <= 0)\n\t\t\t\tustep = 1;\n\t\t\tfor (ui = uv_row[vi].nus-1; ui >= 0; ui -= ustep) {\n\t\t\t\tua = uv_row[vi].ustart + (ui+.5)*UV_SQSIZ;\n\t\t\t\tang = uv2ang(ua, va);\n\t\t\t\ti = (int) ang;\n\t\t\t\tepsa = fabs(ang - (i+.5));\n\t\t\t\tif (epsa < eps[i]) {\n\t\t\t\t\toog_table[i] = uv_row[vi].ncum + ui;\n\t\t\t\t\teps[i] = epsa;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = NANGLES; i--; )\t/* fill any holes */\n\t\t\tif (eps[i] > 1.5) {\n\t\t\t\tint\ti1, i2;\n\t\t\t\tfor (i1 = 1; i1 < NANGLES/2; i1++)\n\t\t\t\t\tif (eps[(i+i1)%NANGLES] < 1.5)\n\t\t\t\t\t\tbreak;\n\t\t\t\tfor (i2 = 1; i2 < NANGLES/2; i2++)\n\t\t\t\t\tif (eps[(i+NANGLES-i2)%NANGLES] < 1.5)\n\t\t\t\t\t\tbreak;\n\t\t\t\tif (i1 < i2)\n\t\t\t\t\toog_table[i] =\n\t\t\t\t\t\toog_table[(i+i1)%NANGLES];\n\t\t\t\telse\n\t\t\t\t\toog_table[i] =\n\t\t\t\t\t\toog_table[(i+NANGLES-i2)%NANGLES];\n\t\t\t}\n\t\tinitialized = 1;\n\t}\n\ti = (int) uv2ang(u, v);\t\t/* look up hue angle */\n\treturn (oog_table[i]);\n}",
          "fn_code_pos": [
            [
              859,
              0
            ],
            [
              907,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "oog_encode",
            "parameters": {
              "u": "double",
              "v": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nuv_encode(double u, double v, int em)\t/* encode (u',v') coordinates */\n{\n\tregister int\tvi, ui;\n\n\tif (v < UV_VSTART)\n\t\treturn oog_encode(u, v);\n\tvi = itrunc((v - UV_VSTART)*(1./UV_SQSIZ), em);\n\tif (vi >= UV_NVS)\n\t\treturn oog_encode(u, v);\n\tif (u < uv_row[vi].ustart)\n\t\treturn oog_encode(u, v);\n\tui = itrunc((u - uv_row[vi].ustart)*(1./UV_SQSIZ), em);\n\tif (ui >= uv_row[vi].nus)\n\t\treturn oog_encode(u, v);\n\n\treturn (uv_row[vi].ncum + ui);\n}",
          "fn_code_pos": [
            [
              915,
              0
            ],
            [
              932,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "uv_encode",
            "parameters": {
              "u": "double",
              "v": "double",
              "em": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nuv_decode(double *up, double *vp, int c)\t/* decode (u',v') index */\n{\n\tint\tupper, lower;\n\tregister int\tui, vi;\n\n\tif (c < 0 || c >= UV_NDIVS)\n\t\treturn (-1);\n\tlower = 0;\t\t\t\t/* binary search */\n\tupper = UV_NVS;\n\twhile (upper - lower > 1) {\n\t\tvi = (lower + upper) >> 1;\n\t\tui = c - uv_row[vi].ncum;\n\t\tif (ui > 0)\n\t\t\tlower = vi;\n\t\telse if (ui < 0)\n\t\t\tupper = vi;\n\t\telse {\n\t\t\tlower = vi;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvi = lower;\n\tui = c - uv_row[vi].ncum;\n\t*up = uv_row[vi].ustart + (ui+.5)*UV_SQSIZ;\n\t*vp = UV_VSTART + (vi+.5)*UV_SQSIZ;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              937,
              0
            ],
            [
              964,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "uv_decode",
            "parameters": {
              "up": "double",
              "vp": "double",
              "c": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\nLogLuv24toXYZ(uint32 p, float XYZ[3])\n{\n\tint\tCe;\n\tdouble\tL, u, v, s, x, y;\n\t\t\t\t\t/* decode luminance */\n\tL = LogL10toY(p>>14 & 0x3ff);\n\tif (L <= 0.) {\n\t\tXYZ[0] = XYZ[1] = XYZ[2] = 0.;\n\t\treturn;\n\t}\n\t\t\t\t\t/* decode color */\n\tCe = p & 0x3fff;\n\tif (uv_decode(&u, &v, Ce) < 0) {\n\t\tu = U_NEU; v = V_NEU;\n\t}\n\ts = 1./(6.*u - 16.*v + 12.);\n\tx = 9.*u * s;\n\ty = 4.*v * s;\n\t\t\t\t\t/* convert to XYZ */\n\tXYZ[0] = (float)(x/y * L);\n\tXYZ[1] = (float)L;\n\tXYZ[2] = (float)((1.-x-y)/y * L);\n}",
          "fn_code_pos": [
            [
              969,
              0
            ],
            [
              992,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuv24toXYZ",
            "parameters": {
              "p": "uint32",
              "XYZ": "float"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "uint32\nLogLuv24fromXYZ(float XYZ[3], int em)\n{\n\tint\tLe, Ce;\n\tdouble\tu, v, s;\n\t\t\t\t\t/* encode luminance */\n\tLe = LogL10fromY(XYZ[1], em);\n\t\t\t\t\t/* encode color */\n\ts = XYZ[0] + 15.*XYZ[1] + 3.*XYZ[2];\n\tif (!Le || s <= 0.) {\n\t\tu = U_NEU;\n\t\tv = V_NEU;\n\t} else {\n\t\tu = 4.*XYZ[0] / s;\n\t\tv = 9.*XYZ[1] / s;\n\t}\n\tCe = uv_encode(u, v, em);\n\tif (Ce < 0)\t\t\t/* never happens */\n\t\tCe = uv_encode(U_NEU, V_NEU, SGILOGENCODE_NODITHER);\n\t\t\t\t\t/* combine encodings */\n\treturn (Le << 14 | Ce);\n}",
          "fn_code_pos": [
            [
              997,
              0
            ],
            [
              1018,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuv24fromXYZ",
            "parameters": {
              "XYZ": "float",
              "em": "int"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "static void\nLuv24toXYZ(LogLuvState* sp, uint8* op, tmsize_t n)\n{\n\tuint32* luv = (uint32*) sp->tbuf;  \n\tfloat* xyz = (float*) op;\n\n\twhile (n-- > 0) {\n\t\tLogLuv24toXYZ(*luv, xyz);\n\t\txyz += 3;\n\t\tluv++;\n\t}\n}",
          "fn_code_pos": [
            [
              1020,
              0
            ],
            [
              1031,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Luv24toXYZ",
            "parameters": {
              "sp": "LogLuvState",
              "op": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nLuv24toLuv48(LogLuvState* sp, uint8* op, tmsize_t n)\n{\n\tuint32* luv = (uint32*) sp->tbuf;  \n\tint16* luv3 = (int16*) op;\n\n\twhile (n-- > 0) {\n\t\tdouble u, v;\n\n\t\t*luv3++ = (int16)((*luv >> 12 & 0xffd) + 13314);\n\t\tif (uv_decode(&u, &v, *luv&0x3fff) < 0) {\n\t\t\tu = U_NEU;\n\t\t\tv = V_NEU;\n\t\t}\n\t\t*luv3++ = (int16)(u * (1L<<15));\n\t\t*luv3++ = (int16)(v * (1L<<15));\n\t\tluv++;\n\t}\n}",
          "fn_code_pos": [
            [
              1033,
              0
            ],
            [
              1051,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Luv24toLuv48",
            "parameters": {
              "sp": "LogLuvState",
              "op": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nLuv24toRGB(LogLuvState* sp, uint8* op, tmsize_t n)\n{\n\tuint32* luv = (uint32*) sp->tbuf;  \n\tuint8* rgb = (uint8*) op;\n\n\twhile (n-- > 0) {\n\t\tfloat xyz[3];\n\n\t\tLogLuv24toXYZ(*luv++, xyz);\n\t\tXYZtoRGB24(xyz, rgb);\n\t\trgb += 3;\n\t}\n}",
          "fn_code_pos": [
            [
              1053,
              0
            ],
            [
              1066,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Luv24toRGB",
            "parameters": {
              "sp": "LogLuvState",
              "op": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nLuv24fromXYZ(LogLuvState* sp, uint8* op, tmsize_t n)\n{\n\tuint32* luv = (uint32*) sp->tbuf;  \n\tfloat* xyz = (float*) op;\n\n\twhile (n-- > 0) {\n\t\t*luv++ = LogLuv24fromXYZ(xyz, sp->encode_meth);\n\t\txyz += 3;\n\t}\n}",
          "fn_code_pos": [
            [
              1068,
              0
            ],
            [
              1078,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Luv24fromXYZ",
            "parameters": {
              "sp": "LogLuvState",
              "op": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nLuv24fromLuv48(LogLuvState* sp, uint8* op, tmsize_t n)\n{\n\tuint32* luv = (uint32*) sp->tbuf;  \n\tint16* luv3 = (int16*) op;\n\n\twhile (n-- > 0) {\n\t\tint Le, Ce;\n\n\t\tif (luv3[0] <= 0)\n\t\t\tLe = 0;\n\t\telse if (luv3[0] >= (1<<12)+3314)\n\t\t\tLe = (1<<10) - 1;\n\t\telse if (sp->encode_meth == SGILOGENCODE_NODITHER)\n\t\t\tLe = (luv3[0]-3314) >> 2;\n\t\telse\n\t\t\tLe = itrunc(.25*(luv3[0]-3314.), sp->encode_meth);\n\n\t\tCe = uv_encode((luv3[1]+.5)/(1<<15), (luv3[2]+.5)/(1<<15),\n\t\t\t\t\tsp->encode_meth);\n\t\tif (Ce < 0)\t/* never happens */\n\t\t\tCe = uv_encode(U_NEU, V_NEU, SGILOGENCODE_NODITHER);\n\t\t*luv++ = (uint32)Le << 14 | Ce;\n\t\tluv3 += 3;\n\t}\n}",
          "fn_code_pos": [
            [
              1080,
              0
            ],
            [
              1105,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Luv24fromLuv48",
            "parameters": {
              "sp": "LogLuvState",
              "op": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nLogLuv32toXYZ(uint32 p, float XYZ[3])\n{\n\tdouble\tL, u, v, s, x, y;\n\t\t\t\t\t/* decode luminance */\n\tL = LogL16toY((int)p >> 16);\n\tif (L <= 0.) {\n\t\tXYZ[0] = XYZ[1] = XYZ[2] = 0.;\n\t\treturn;\n\t}\n\t\t\t\t\t/* decode color */\n\tu = 1./UVSCALE * ((p>>8 & 0xff) + .5);\n\tv = 1./UVSCALE * ((p & 0xff) + .5);\n\ts = 1./(6.*u - 16.*v + 12.);\n\tx = 9.*u * s;\n\ty = 4.*v * s;\n\t\t\t\t\t/* convert to XYZ */\n\tXYZ[0] = (float)(x/y * L);\n\tXYZ[1] = (float)L;\n\tXYZ[2] = (float)((1.-x-y)/y * L);\n}",
          "fn_code_pos": [
            [
              1110,
              0
            ],
            [
              1130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuv32toXYZ",
            "parameters": {
              "p": "uint32",
              "XYZ": "float"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "uint32\nLogLuv32fromXYZ(float XYZ[3], int em)\n{\n\tunsigned int\tLe, ue, ve;\n\tdouble\tu, v, s;\n\t\t\t\t\t/* encode luminance */\n\tLe = (unsigned int)LogL16fromY(XYZ[1], em);\n\t\t\t\t\t/* encode color */\n\ts = XYZ[0] + 15.*XYZ[1] + 3.*XYZ[2];\n\tif (!Le || s <= 0.) {\n\t\tu = U_NEU;\n\t\tv = V_NEU;\n\t} else {\n\t\tu = 4.*XYZ[0] / s;\n\t\tv = 9.*XYZ[1] / s;\n\t}\n\tif (u <= 0.) ue = 0;\n\telse ue = itrunc(UVSCALE*u, em);\n\tif (ue > 255) ue = 255;\n\tif (v <= 0.) ve = 0;\n\telse ve = itrunc(UVSCALE*v, em);\n\tif (ve > 255) ve = 255;\n\t\t\t\t\t/* combine encodings */\n\treturn (Le << 16 | ue << 8 | ve);\n}",
          "fn_code_pos": [
            [
              1135,
              0
            ],
            [
              1159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuv32fromXYZ",
            "parameters": {
              "XYZ": "float",
              "em": "int"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "static void\nLuv32toXYZ(LogLuvState* sp, uint8* op, tmsize_t n)\n{\n\tuint32* luv = (uint32*) sp->tbuf;  \n\tfloat* xyz = (float*) op;\n\n\twhile (n-- > 0) {\n\t\tLogLuv32toXYZ(*luv++, xyz);\n\t\txyz += 3;\n\t}\n}",
          "fn_code_pos": [
            [
              1161,
              0
            ],
            [
              1171,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Luv32toXYZ",
            "parameters": {
              "sp": "LogLuvState",
              "op": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nLuv32toLuv48(LogLuvState* sp, uint8* op, tmsize_t n)\n{\n\tuint32* luv = (uint32*) sp->tbuf;  \n\tint16* luv3 = (int16*) op;\n\n\twhile (n-- > 0) {\n\t\tdouble u, v;\n\n\t\t*luv3++ = (int16)(*luv >> 16);\n\t\tu = 1./UVSCALE * ((*luv>>8 & 0xff) + .5);\n\t\tv = 1./UVSCALE * ((*luv & 0xff) + .5);\n\t\t*luv3++ = (int16)(u * (1L<<15));\n\t\t*luv3++ = (int16)(v * (1L<<15));\n\t\tluv++;\n\t}\n}",
          "fn_code_pos": [
            [
              1173,
              0
            ],
            [
              1189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Luv32toLuv48",
            "parameters": {
              "sp": "LogLuvState",
              "op": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nLuv32toRGB(LogLuvState* sp, uint8* op, tmsize_t n)\n{\n\tuint32* luv = (uint32*) sp->tbuf;  \n\tuint8* rgb = (uint8*) op;\n\n\twhile (n-- > 0) {\n\t\tfloat xyz[3];\n\n\t\tLogLuv32toXYZ(*luv++, xyz);\n\t\tXYZtoRGB24(xyz, rgb);\n\t\trgb += 3;\n\t}\n}",
          "fn_code_pos": [
            [
              1191,
              0
            ],
            [
              1204,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Luv32toRGB",
            "parameters": {
              "sp": "LogLuvState",
              "op": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nLuv32fromXYZ(LogLuvState* sp, uint8* op, tmsize_t n)\n{\n\tuint32* luv = (uint32*) sp->tbuf;  \n\tfloat* xyz = (float*) op;\n\n\twhile (n-- > 0) {\n\t\t*luv++ = LogLuv32fromXYZ(xyz, sp->encode_meth);\n\t\txyz += 3;\n\t}\n}",
          "fn_code_pos": [
            [
              1206,
              0
            ],
            [
              1216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Luv32fromXYZ",
            "parameters": {
              "sp": "LogLuvState",
              "op": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nLuv32fromLuv48(LogLuvState* sp, uint8* op, tmsize_t n)\n{\n\tuint32* luv = (uint32*) sp->tbuf;\n\tint16* luv3 = (int16*) op;\n\n\tif (sp->encode_meth == SGILOGENCODE_NODITHER) {\n\t\twhile (n-- > 0) {\n\t\t\t*luv++ = (uint32)luv3[0] << 16 |\n\t\t\t\t(luv3[1]*(uint32)(UVSCALE+.5) >> 7 & 0xff00) |\n\t\t\t\t(luv3[2]*(uint32)(UVSCALE+.5) >> 15 & 0xff);\n\t\t\tluv3 += 3;\n\t\t}\n\t\treturn;\n\t}\n\twhile (n-- > 0) {\n\t\t*luv++ = (uint32)luv3[0] << 16 |\n\t(itrunc(luv3[1]*(UVSCALE/(1<<15)), sp->encode_meth) << 8 & 0xff00) |\n\t\t(itrunc(luv3[2]*(UVSCALE/(1<<15)), sp->encode_meth) & 0xff);\n\t\tluv3 += 3;\n\t}\n}",
          "fn_code_pos": [
            [
              1218,
              0
            ],
            [
              1239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Luv32fromLuv48",
            "parameters": {
              "sp": "LogLuvState",
              "op": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\n_logLuvNop(LogLuvState* sp, uint8* op, tmsize_t n)\n{\n\t(void) sp; (void) op; (void) n;\n}",
          "fn_code_pos": [
            [
              1241,
              0
            ],
            [
              1245,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_logLuvNop",
            "parameters": {
              "sp": "LogLuvState",
              "op": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nLogL16GuessDataFmt(TIFFDirectory *td)\n{\n#define\tPACK(s,b,f)\t(((b)<<6)|((s)<<3)|(f))\n\tswitch (PACK(td->td_samplesperpixel, td->td_bitspersample, td->td_sampleformat)) {\n\tcase PACK(1, 32, SAMPLEFORMAT_IEEEFP):\n\t\treturn (SGILOGDATAFMT_FLOAT);\n\tcase PACK(1, 16, SAMPLEFORMAT_VOID):\n\tcase PACK(1, 16, SAMPLEFORMAT_INT):\n\tcase PACK(1, 16, SAMPLEFORMAT_UINT):\n\t\treturn (SGILOGDATAFMT_16BIT);\n\tcase PACK(1,  8, SAMPLEFORMAT_VOID):\n\tcase PACK(1,  8, SAMPLEFORMAT_UINT):\n\t\treturn (SGILOGDATAFMT_8BIT);\n\t}\n#undef PACK\n\treturn (SGILOGDATAFMT_UNKNOWN);\n}",
          "fn_code_pos": [
            [
              1247,
              0
            ],
            [
              1264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogL16GuessDataFmt",
            "parameters": {
              "td": "TIFFDirectory"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static tmsize_t\nmultiply_ms(tmsize_t m1, tmsize_t m2)\n{\n        if( m1 == 0 || m2 > TIFF_TMSIZE_T_MAX / m1 )\n            return 0;\n        return m1 * m2;\n}",
          "fn_code_pos": [
            [
              1270,
              0
            ],
            [
              1276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "multiply_ms",
            "parameters": {
              "m1": "tmsize_t",
              "m2": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static int\nLogL16InitState(TIFF* tif)\n{\n\tstatic const char module[] = \"LogL16InitState\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tLogLuvState* sp = DecoderState(tif);\n\n\tassert(sp != NULL);\n\tassert(td->td_photometric == PHOTOMETRIC_LOGL);\n\n\tif( td->td_samplesperpixel != 1 )\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t             \"Sorry, can not handle LogL image with %s=%d\",\n\t\t\t     \"Samples/pixel\", td->td_samplesperpixel);\n\t\treturn 0;\n\t}\n\n\t/* for some reason, we can't do this in TIFFInitLogL16 */\n\tif (sp->user_datafmt == SGILOGDATAFMT_UNKNOWN)\n\t\tsp->user_datafmt = LogL16GuessDataFmt(td);\n\tswitch (sp->user_datafmt) {\n\tcase SGILOGDATAFMT_FLOAT:\n\t\tsp->pixel_size = sizeof (float);\n\t\tbreak;\n\tcase SGILOGDATAFMT_16BIT:\n\t\tsp->pixel_size = sizeof (int16);\n\t\tbreak;\n\tcase SGILOGDATAFMT_8BIT:\n\t\tsp->pixel_size = sizeof (uint8);\n\t\tbreak;\n\tdefault:\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"No support for converting user data format to LogL\");\n\t\treturn (0);\n\t}\n        if( isTiled(tif) )\n            sp->tbuflen = multiply_ms(td->td_tilewidth, td->td_tilelength);\n        else if( td->td_rowsperstrip < td->td_imagelength )\n            sp->tbuflen = multiply_ms(td->td_imagewidth, td->td_rowsperstrip);\n        else\n            sp->tbuflen = multiply_ms(td->td_imagewidth, td->td_imagelength);\n\tif (multiply_ms(sp->tbuflen, sizeof (int16)) == 0 ||\n\t    (sp->tbuf = (uint8*) _TIFFmalloc(sp->tbuflen * sizeof (int16))) == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"No space for SGILog translation buffer\");\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1278,
              0
            ],
            [
              1326,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogL16InitState",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLogLuvGuessDataFmt(TIFFDirectory *td)\n{\n\tint guess;\n\n\t/*\n\t * If the user didn't tell us their datafmt,\n\t * take our best guess from the bitspersample.\n\t */\n#define\tPACK(a,b)\t(((a)<<3)|(b))\n\tswitch (PACK(td->td_bitspersample, td->td_sampleformat)) {\n\tcase PACK(32, SAMPLEFORMAT_IEEEFP):\n\t\tguess = SGILOGDATAFMT_FLOAT;\n\t\tbreak;\n\tcase PACK(32, SAMPLEFORMAT_VOID):\n\tcase PACK(32, SAMPLEFORMAT_UINT):\n\tcase PACK(32, SAMPLEFORMAT_INT):\n\t\tguess = SGILOGDATAFMT_RAW;\n\t\tbreak;\n\tcase PACK(16, SAMPLEFORMAT_VOID):\n\tcase PACK(16, SAMPLEFORMAT_INT):\n\tcase PACK(16, SAMPLEFORMAT_UINT):\n\t\tguess = SGILOGDATAFMT_16BIT;\n\t\tbreak;\n\tcase PACK( 8, SAMPLEFORMAT_VOID):\n\tcase PACK( 8, SAMPLEFORMAT_UINT):\n\t\tguess = SGILOGDATAFMT_8BIT;\n\t\tbreak;\n\tdefault:\n\t\tguess = SGILOGDATAFMT_UNKNOWN;\n\t\tbreak;\n#undef PACK\n\t}\n\t/*\n\t * Double-check samples per pixel.\n\t */\n\tswitch (td->td_samplesperpixel) {\n\tcase 1:\n\t\tif (guess != SGILOGDATAFMT_RAW)\n\t\t\tguess = SGILOGDATAFMT_UNKNOWN;\n\t\tbreak;\n\tcase 3:\n\t\tif (guess == SGILOGDATAFMT_RAW)\n\t\t\tguess = SGILOGDATAFMT_UNKNOWN;\n\t\tbreak;\n\tdefault:\n\t\tguess = SGILOGDATAFMT_UNKNOWN;\n\t\tbreak;\n\t}\n\treturn (guess);\n}",
          "fn_code_pos": [
            [
              1328,
              0
            ],
            [
              1378,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvGuessDataFmt",
            "parameters": {
              "td": "TIFFDirectory"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLogLuvInitState(TIFF* tif)\n{\n\tstatic const char module[] = \"LogLuvInitState\";\n\tTIFFDirectory* td = &tif->tif_dir;\n\tLogLuvState* sp = DecoderState(tif);\n\n\tassert(sp != NULL);\n\tassert(td->td_photometric == PHOTOMETRIC_LOGLUV);\n\n\t/* for some reason, we can't do this in TIFFInitLogLuv */\n\tif (td->td_planarconfig != PLANARCONFIG_CONTIG) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"SGILog compression cannot handle non-contiguous data\");\n\t\treturn (0);\n\t}\n\tif (sp->user_datafmt == SGILOGDATAFMT_UNKNOWN)\n\t\tsp->user_datafmt = LogLuvGuessDataFmt(td);\n\tswitch (sp->user_datafmt) {\n\tcase SGILOGDATAFMT_FLOAT:\n\t\tsp->pixel_size = 3*sizeof (float);\n\t\tbreak;\n\tcase SGILOGDATAFMT_16BIT:\n\t\tsp->pixel_size = 3*sizeof (int16);\n\t\tbreak;\n\tcase SGILOGDATAFMT_RAW:\n\t\tsp->pixel_size = sizeof (uint32);\n\t\tbreak;\n\tcase SGILOGDATAFMT_8BIT:\n\t\tsp->pixel_size = 3*sizeof (uint8);\n\t\tbreak;\n\tdefault:\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"No support for converting user data format to LogLuv\");\n\t\treturn (0);\n\t}\n        if( isTiled(tif) )\n            sp->tbuflen = multiply_ms(td->td_tilewidth, td->td_tilelength);\n        else if( td->td_rowsperstrip < td->td_imagelength )\n            sp->tbuflen = multiply_ms(td->td_imagewidth, td->td_rowsperstrip);\n        else\n            sp->tbuflen = multiply_ms(td->td_imagewidth, td->td_imagelength);\n\tif (multiply_ms(sp->tbuflen, sizeof (uint32)) == 0 ||\n\t    (sp->tbuf = (uint8*) _TIFFmalloc(sp->tbuflen * sizeof (uint32))) == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"No space for SGILog translation buffer\");\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1380,
              0
            ],
            [
              1428,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvInitState",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLogLuvFixupTags(TIFF* tif)\n{\n\t(void) tif;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1430,
              0
            ],
            [
              1435,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvFixupTags",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLogLuvSetupDecode(TIFF* tif)\n{\n\tstatic const char module[] = \"LogLuvSetupDecode\";\n\tLogLuvState* sp = DecoderState(tif);\n\tTIFFDirectory* td = &tif->tif_dir;\n\n\ttif->tif_postdecode = _TIFFNoPostDecode;\n\tswitch (td->td_photometric) {\n\tcase PHOTOMETRIC_LOGLUV:\n\t\tif (!LogLuvInitState(tif))\n\t\t\tbreak;\n\t\tif (td->td_compression == COMPRESSION_SGILOG24) {\n\t\t\ttif->tif_decoderow = LogLuvDecode24;\n\t\t\tswitch (sp->user_datafmt) {\n\t\t\tcase SGILOGDATAFMT_FLOAT:\n\t\t\t\tsp->tfunc = Luv24toXYZ;  \n\t\t\t\tbreak;\n\t\t\tcase SGILOGDATAFMT_16BIT:\n\t\t\t\tsp->tfunc = Luv24toLuv48;  \n\t\t\t\tbreak;\n\t\t\tcase SGILOGDATAFMT_8BIT:\n\t\t\t\tsp->tfunc = Luv24toRGB;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\ttif->tif_decoderow = LogLuvDecode32;\n\t\t\tswitch (sp->user_datafmt) {\n\t\t\tcase SGILOGDATAFMT_FLOAT:\n\t\t\t\tsp->tfunc = Luv32toXYZ;\n\t\t\t\tbreak;\n\t\t\tcase SGILOGDATAFMT_16BIT:\n\t\t\t\tsp->tfunc = Luv32toLuv48;\n\t\t\t\tbreak;\n\t\t\tcase SGILOGDATAFMT_8BIT:\n\t\t\t\tsp->tfunc = Luv32toRGB;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn (1);\n\tcase PHOTOMETRIC_LOGL:\n\t\tif (!LogL16InitState(tif))\n\t\t\tbreak;\n\t\ttif->tif_decoderow = LogL16Decode;\n\t\tswitch (sp->user_datafmt) {\n\t\tcase SGILOGDATAFMT_FLOAT:\n\t\t\tsp->tfunc = L16toY;\n\t\t\tbreak;\n\t\tcase SGILOGDATAFMT_8BIT:\n\t\t\tsp->tfunc = L16toGry;\n\t\t\tbreak;\n\t\t}\n\t\treturn (1);\n\tdefault:\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Inappropriate photometric interpretation %d for SGILog compression; %s\",\n\t\t    td->td_photometric, \"must be either LogLUV or LogL\");\n\t\tbreak;\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1437,
              0
            ],
            [
              1497,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvSetupDecode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLogLuvSetupEncode(TIFF* tif)\n{\n\tstatic const char module[] = \"LogLuvSetupEncode\";\n\tLogLuvState* sp = EncoderState(tif);\n\tTIFFDirectory* td = &tif->tif_dir;\n\n\tswitch (td->td_photometric) {\n\tcase PHOTOMETRIC_LOGLUV:\n\t\tif (!LogLuvInitState(tif))\n\t\t\tbreak;\n\t\tif (td->td_compression == COMPRESSION_SGILOG24) {\n\t\t\ttif->tif_encoderow = LogLuvEncode24;\n\t\t\tswitch (sp->user_datafmt) {\n\t\t\tcase SGILOGDATAFMT_FLOAT:\n\t\t\t\tsp->tfunc = Luv24fromXYZ;\n\t\t\t\tbreak;\n\t\t\tcase SGILOGDATAFMT_16BIT:\n\t\t\t\tsp->tfunc = Luv24fromLuv48;  \n\t\t\t\tbreak;\n\t\t\tcase SGILOGDATAFMT_RAW:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto notsupported;\n\t\t\t}\n\t\t} else {\n\t\t\ttif->tif_encoderow = LogLuvEncode32;  \n\t\t\tswitch (sp->user_datafmt) {\n\t\t\tcase SGILOGDATAFMT_FLOAT:\n\t\t\t\tsp->tfunc = Luv32fromXYZ;  \n\t\t\t\tbreak;\n\t\t\tcase SGILOGDATAFMT_16BIT:\n\t\t\t\tsp->tfunc = Luv32fromLuv48;  \n\t\t\t\tbreak;\n\t\t\tcase SGILOGDATAFMT_RAW:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto notsupported;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_LOGL:\n\t\tif (!LogL16InitState(tif))\n\t\t\tbreak;\n\t\ttif->tif_encoderow = LogL16Encode;  \n\t\tswitch (sp->user_datafmt) {\n\t\tcase SGILOGDATAFMT_FLOAT:\n\t\t\tsp->tfunc = L16fromY;\n\t\t\tbreak;\n\t\tcase SGILOGDATAFMT_16BIT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto notsupported;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Inappropriate photometric interpretation %d for SGILog compression; %s\",\n\t\t    td->td_photometric, \"must be either LogLUV or LogL\");\n\t\tbreak;\n\t}\n\tsp->encoder_state = 1;\n\treturn (1);\nnotsupported:\n\tTIFFErrorExt(tif->tif_clientdata, module,\n\t    \"SGILog compression supported only for %s, or raw data\",\n\t    td->td_photometric == PHOTOMETRIC_LOGL ? \"Y, L\" : \"XYZ, Luv\");\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1499,
              0
            ],
            [
              1567,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvSetupEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nLogLuvClose(TIFF* tif)\n{\n        LogLuvState* sp = (LogLuvState*) tif->tif_data;\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\tassert(sp != 0);\n\t/*\n\t * For consistency, we always want to write out the same\n\t * bitspersample and sampleformat for our TIFF file,\n\t * regardless of the data format being used by the application.\n\t * Since this routine is called after tags have been set but\n\t * before they have been recorded in the file, we reset them here.\n         * Note: this is really a nasty approach. See PixarLogClose\n\t */\n        if( sp->encoder_state )\n        {\n            /* See PixarLogClose. Might avoid issues with tags whose size depends\n             * on those below, but not completely sure this is enough. */\n            td->td_samplesperpixel =\n                (td->td_photometric == PHOTOMETRIC_LOGL) ? 1 : 3;\n            td->td_bitspersample = 16;\n            td->td_sampleformat = SAMPLEFORMAT_INT;\n        }\n}",
          "fn_code_pos": [
            [
              1569,
              0
            ],
            [
              1593,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvClose",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nLogLuvCleanup(TIFF* tif)\n{\n\tLogLuvState* sp = (LogLuvState *)tif->tif_data;\n\n\tassert(sp != 0);\n\n\ttif->tif_tagmethods.vgetfield = sp->vgetparent;\n\ttif->tif_tagmethods.vsetfield = sp->vsetparent;\n\n\tif (sp->tbuf)\n\t\t_TIFFfree(sp->tbuf);\n\t_TIFFfree(sp);\n\ttif->tif_data = NULL;\n\n\t_TIFFSetDefaultCompressionState(tif);\n}",
          "fn_code_pos": [
            [
              1595,
              0
            ],
            [
              1611,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvCleanup",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nLogLuvVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tstatic const char module[] = \"LogLuvVSetField\";\n\tLogLuvState* sp = DecoderState(tif);\n\tint bps, fmt;\n\n\tswitch (tag) {\n\tcase TIFFTAG_SGILOGDATAFMT:\n\t\tsp->user_datafmt = (int) va_arg(ap, int);\n\t\t/*\n\t\t * Tweak the TIFF header so that the rest of libtiff knows what\n\t\t * size of data will be passed between app and library, and\n\t\t * assume that the app knows what it is doing and is not\n\t\t * confused by these header manipulations...\n\t\t */\n\t\tswitch (sp->user_datafmt) {\n\t\tcase SGILOGDATAFMT_FLOAT:\n\t\t\tbps = 32;\n\t\t\tfmt = SAMPLEFORMAT_IEEEFP;\n\t\t\tbreak;\n\t\tcase SGILOGDATAFMT_16BIT:\n\t\t\tbps = 16;\n\t\t\tfmt = SAMPLEFORMAT_INT;\n\t\t\tbreak;\n\t\tcase SGILOGDATAFMT_RAW:\n\t\t\tbps = 32;\n\t\t\tfmt = SAMPLEFORMAT_UINT;\n\t\t\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n\t\t\tbreak;\n\t\tcase SGILOGDATAFMT_8BIT:\n\t\t\tbps = 8;\n\t\t\tfmt = SAMPLEFORMAT_UINT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t    \"Unknown data format %d for LogLuv compression\",\n\t\t\t    sp->user_datafmt);\n\t\t\treturn (0);\n\t\t}\n\t\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps);\n\t\tTIFFSetField(tif, TIFFTAG_SAMPLEFORMAT, fmt);\n\t\t/*\n\t\t * Must recalculate sizes should bits/sample change.\n\t\t */\n\t\ttif->tif_tilesize = isTiled(tif) ? TIFFTileSize(tif) : (tmsize_t) -1;\n\t\ttif->tif_scanlinesize = TIFFScanlineSize(tif);\n\t\treturn (1);\n\tcase TIFFTAG_SGILOGENCODE:\n\t\tsp->encode_meth = (int) va_arg(ap, int);\n\t\tif (sp->encode_meth != SGILOGENCODE_NODITHER &&\n\t\t    sp->encode_meth != SGILOGENCODE_RANDITHER) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Unknown encoding %d for LogLuv compression\",\n\t\t\t    sp->encode_meth);\n\t\t\treturn (0);\n\t\t}\n\t\treturn (1);\n\tdefault:\n\t\treturn (*sp->vsetparent)(tif, tag, ap);\n\t}\n}",
          "fn_code_pos": [
            [
              1613,
              0
            ],
            [
              1674,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvVSetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLogLuvVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tLogLuvState *sp = (LogLuvState *)tif->tif_data;\n\n\tswitch (tag) {\n\tcase TIFFTAG_SGILOGDATAFMT:\n\t\t*va_arg(ap, int*) = sp->user_datafmt;\n\t\treturn (1);\n\tdefault:\n\t\treturn (*sp->vgetparent)(tif, tag, ap);\n\t}\n}",
          "fn_code_pos": [
            [
              1676,
              0
            ],
            [
              1688,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuvVGetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFInitSGILog(TIFF* tif, int scheme)\n{\n\tstatic const char module[] = \"TIFFInitSGILog\";\n\tLogLuvState* sp;\n\n\tassert(scheme == COMPRESSION_SGILOG24 || scheme == COMPRESSION_SGILOG);\n\n\t/*\n\t * Merge codec-specific tag information.\n\t */\n\tif (!_TIFFMergeFields(tif, LogLuvFields,\n\t\t\t      TIFFArrayCount(LogLuvFields))) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Merging SGILog codec-specific tags failed\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate state block so tag methods have storage to record values.\n\t */\n\ttif->tif_data = (uint8*) _TIFFmalloc(sizeof (LogLuvState));\n\tif (tif->tif_data == NULL)\n\t\tgoto bad;\n\tsp = (LogLuvState*) tif->tif_data;\n\t_TIFFmemset((void*)sp, 0, sizeof (*sp));\n\tsp->user_datafmt = SGILOGDATAFMT_UNKNOWN;\n\tsp->encode_meth = (scheme == COMPRESSION_SGILOG24) ?\n\t    SGILOGENCODE_RANDITHER : SGILOGENCODE_NODITHER;\n\tsp->tfunc = _logLuvNop;\n\n\t/*\n\t * Install codec methods.\n\t * NB: tif_decoderow & tif_encoderow are filled\n\t *     in at setup time.\n\t */\n\ttif->tif_fixuptags = LogLuvFixupTags;  \n\ttif->tif_setupdecode = LogLuvSetupDecode;\n\ttif->tif_decodestrip = LogLuvDecodeStrip;\n\ttif->tif_decodetile = LogLuvDecodeTile;\n\ttif->tif_setupencode = LogLuvSetupEncode;\n\ttif->tif_encodestrip = LogLuvEncodeStrip;  \n\ttif->tif_encodetile = LogLuvEncodeTile;\n\ttif->tif_close = LogLuvClose;\n\ttif->tif_cleanup = LogLuvCleanup;\n\n\t/*\n\t * Override parent get/set field methods.\n\t */\n\tsp->vgetparent = tif->tif_tagmethods.vgetfield;\n\ttif->tif_tagmethods.vgetfield = LogLuvVGetField;   /* hook for codec tags */\n\tsp->vsetparent = tif->tif_tagmethods.vsetfield;\n\ttif->tif_tagmethods.vsetfield = LogLuvVSetField;   /* hook for codec tags */\n\n\treturn (1);\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"%s: No space for LogLuv state block\", tif->tif_name);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1695,
              0
            ],
            [
              1754,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitSGILog",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*tfunc)(LogLuvState*, uint8*, tmsize_t)",
          "fn_dec_pos": [
            [
              165,
              6
            ],
            [
              165,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct logLuvState {\n        int                     encoder_state;  /* 1 if encoder correctly initialized */\n\tint                     user_datafmt;   /* user data format */\n\tint                     encode_meth;    /* encoding method */\n\tint                     pixel_size;     /* bytes per pixel */\n\n\tuint8*                  tbuf;           /* translation buffer */\n\ttmsize_t                tbuflen;        /* buffer length */\n\tvoid (*tfunc)(LogLuvState*, uint8*, tmsize_t);\n\n\tTIFFVSetMethod          vgetparent;     /* super-class method */\n\tTIFFVSetMethod          vsetparent;     /* super-class method */\n}",
          {
            "encoder_state": "int",
            "user_datafmt": "int",
            "encode_meth": "int",
            "pixel_size": "int",
            "*                  tbuf": "uint8",
            "tbuflen": "tmsize_t",
            "(*tfunc)(LogLuvState*, uint8*, tmsize_t)": "void",
            "vgetparent": "TIFFVSetMethod",
            "vsetparent": "TIFFVSetMethod"
          },
          "logLuvState",
          [
            157,
            0
          ],
          [
            169,
            1
          ]
        ],
        [
          "typedef struct logLuvState LogLuvState;",
          {},
          "LogLuvState",
          [
            155,
            0
          ],
          [
            155,
            39
          ]
        ],
        [
          "struct logLuvState {\n        int                     encoder_state;  /* 1 if encoder correctly initialized */\n\tint                     user_datafmt;   /* user data format */\n\tint                     encode_meth;    /* encoding method */\n\tint                     pixel_size;     /* bytes per pixel */\n\n\tuint8*                  tbuf;           /* translation buffer */\n\ttmsize_t                tbuflen;        /* buffer length */\n\tvoid (*tfunc)(LogLuvState*, uint8*, tmsize_t);\n\n\tTIFFVSetMethod          vgetparent;     /* super-class method */\n\tTIFFVSetMethod          vsetparent;     /* super-class method */\n}",
          {
            "encoder_state": "int",
            "user_datafmt": "int",
            "encode_meth": "int",
            "pixel_size": "int",
            "*                  tbuf": "uint8",
            "tbuflen": "tmsize_t",
            "(*tfunc)(LogLuvState*, uint8*, tmsize_t)": "void",
            "vgetparent": "TIFFVSetMethod",
            "vsetparent": "TIFFVSetMethod"
          },
          "logLuvState",
          [
            157,
            0
          ],
          [
            169,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            147,
            0
          ],
          [
            148,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            148,
            0
          ],
          [
            149,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            149,
            0
          ],
          [
            150,
            0
          ]
        ],
        [
          "#include \"uvcode.h\"\n",
          [
            725,
            0
          ],
          [
            726,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_codec.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\n_notConfigured(TIFF* tif)\n{\n\tconst TIFFCodec* c = TIFFFindCODEC(tif->tif_dir.td_compression);\n        char compression_code[20];\n        \n        sprintf(compression_code, \"%d\",tif->tif_dir.td_compression );\n\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n                     \"%s compression support is not configured\", \n                     c ? c->name : compression_code );\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              121,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_notConfigured",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nNotConfigured(TIFF* tif, int scheme)\n{\n\t(void) scheme;\n\n\ttif->tif_fixuptags = _notConfigured;\n\ttif->tif_decodestatus = FALSE;\n\ttif->tif_setupdecode = _notConfigured;\n\ttif->tif_encodestatus = FALSE;\n\ttif->tif_setupencode = _notConfigured;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              123,
              0
            ],
            [
              134,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NotConfigured",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFIsCODECConfigured(uint16 scheme)\n{\n\tconst TIFFCodec* codec = TIFFFindCODEC(scheme);\n\n\tif(codec == NULL) {\n\t\treturn 0;\n\t}\n\tif(codec->init == NULL) {\n\t\treturn 0;\n\t}\n\tif(codec->init != NotConfigured){\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              147,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFIsCODECConfigured",
            "parameters": {
              "scheme": "uint16"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "NotConfigured(TIFF*, int)",
          "fn_dec_pos": [
            [
              31,
              11
            ],
            [
              31,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NotConfigured",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_read.c": {
      "fn_def_list": [
        {
          "fn_code": "static int TIFFReadAndRealloc( TIFF* tif, tmsize_t size,\n                               tmsize_t rawdata_offset,\n                               int is_strip, uint32 strip_or_tile,\n                               const char* module )\n{\n#if SIZEOF_SIZE_T == 8\n        tmsize_t threshold = INITIAL_THRESHOLD;\n#endif\n        tmsize_t already_read = 0;\n\n        /* On 64 bit processes, read first a maximum of 1 MB, then 10 MB, etc */\n        /* so as to avoid allocating too much memory in case the file is too */\n        /* short. We could ask for the file size, but this might be */\n        /* expensive with some I/O layers (think of reading a gzipped file) */\n        /* Restrict to 64 bit processes, so as to avoid reallocs() */\n        /* on 32 bit processes where virtual memory is scarce.  */\n        while( already_read < size )\n        {\n            tmsize_t bytes_read;\n            tmsize_t to_read = size - already_read;\n#if SIZEOF_SIZE_T == 8\n            if( to_read >= threshold && threshold < MAX_THRESHOLD &&\n                already_read + to_read + rawdata_offset > tif->tif_rawdatasize )\n            {\n                to_read = threshold;\n                threshold *= THRESHOLD_MULTIPLIER;\n            }\n#endif\n            if (already_read + to_read + rawdata_offset > tif->tif_rawdatasize) {\n                uint8* new_rawdata;\n                assert((tif->tif_flags & TIFF_MYBUFFER) != 0);\n                tif->tif_rawdatasize = (tmsize_t)TIFFroundup_64(\n                        (uint64)already_read + to_read + rawdata_offset, 1024);\n                if (tif->tif_rawdatasize==0) {\n                    TIFFErrorExt(tif->tif_clientdata, module,\n                                \"Invalid buffer size\");\n                    return 0;\n                }\n                new_rawdata = (uint8*) _TIFFrealloc(\n                                tif->tif_rawdata, tif->tif_rawdatasize);\n                if( new_rawdata == 0 )\n                {\n                    TIFFErrorExt(tif->tif_clientdata, module,\n                        \"No space for data buffer at scanline %lu\",\n                        (unsigned long) tif->tif_row);\n                    _TIFFfree(tif->tif_rawdata);\n                    tif->tif_rawdata = 0;\n                    tif->tif_rawdatasize = 0;\n                    return 0;\n                }\n                tif->tif_rawdata = new_rawdata;\n            }\n\n            bytes_read = TIFFReadFile(tif,\n                tif->tif_rawdata + rawdata_offset + already_read, to_read);\n            already_read += bytes_read;\n            if (bytes_read != to_read) {\n                memset( tif->tif_rawdata + rawdata_offset + already_read, 0,\n                        tif->tif_rawdatasize - rawdata_offset - already_read );\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n                if( is_strip )\n                {\n                    TIFFErrorExt(tif->tif_clientdata, module,\n                        \"Read error at scanline %lu; got %I64u bytes, \"\n                        \"expected %I64u\",\n                                        (unsigned long) tif->tif_row,\n                                        (unsigned __int64) already_read,\n                                        (unsigned __int64) size);\n                }\n                else\n                {\n                    TIFFErrorExt(tif->tif_clientdata, module,\n                        \"Read error at row %lu, col %lu, tile %lu; \"\n                        \"got %I64u bytes, expected %I64u\",\n                                        (unsigned long) tif->tif_row,\n                                        (unsigned long) tif->tif_col,\n                                        (unsigned long) strip_or_tile,\n                                        (unsigned __int64) already_read,\n                                        (unsigned __int64) size);\n                }\n#else\n                if( is_strip )\n                {\n                    TIFFErrorExt(tif->tif_clientdata, module,\n                        \"Read error at scanline %lu; got %llu bytes, \"\n                        \"expected %llu\",\n                                        (unsigned long) tif->tif_row,\n                                        (unsigned long long) already_read,\n                                        (unsigned long long) size);\n                }\n                else\n                {\n                    TIFFErrorExt(tif->tif_clientdata, module,\n                        \"Read error at row %lu, col %lu, tile %lu; \"\n                        \"got %llu bytes, expected %llu\",\n                                        (unsigned long) tif->tif_row,\n                                        (unsigned long) tif->tif_col,\n                                        (unsigned long) strip_or_tile,\n                                        (unsigned long long) already_read,\n                                        (unsigned long long) size);\n                }\n#endif\n                return 0;\n            }\n        }\n        return 1;\n}",
          "fn_code_pos": [
            [
              53,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadAndRealloc",
            "parameters": {
              "tif": "TIFF",
              "size": "tmsize_t",
              "rawdata_offset": "tmsize_t",
              "is_strip": "int",
              "strip_or_tile": "uint32",
              "module": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFFillStripPartial( TIFF *tif, int strip, tmsize_t read_ahead, int restart )\n{\n\tstatic const char module[] = \"TIFFFillStripPartial\";\n\tregister TIFFDirectory *td = &tif->tif_dir;\n        tmsize_t unused_data;\n        uint64 read_offset;\n        tmsize_t to_read;\n        tmsize_t read_ahead_mod;\n        /* tmsize_t bytecountm; */\n        \n        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)\n            return 0;\n        \n        /*\n         * Expand raw data buffer, if needed, to hold data\n         * strip coming from file (perhaps should set upper\n         * bound on the size of a buffer we'll use?).\n         */\n\n        /* bytecountm=(tmsize_t) td->td_stripbytecount[strip]; */\n\n        /* Not completely sure where the * 2 comes from, but probably for */\n        /* an exponentional growth strategy of tif_rawdatasize */\n        if( read_ahead < TIFF_TMSIZE_T_MAX / 2 )\n                read_ahead_mod = read_ahead * 2;\n        else\n                read_ahead_mod = read_ahead;\n        if (read_ahead_mod > tif->tif_rawdatasize) {\n                assert( restart );\n                \n                tif->tif_curstrip = NOSTRIP;\n                if ((tif->tif_flags & TIFF_MYBUFFER) == 0) {\n                        TIFFErrorExt(tif->tif_clientdata, module,\n                                     \"Data buffer too small to hold part of strip %lu\",\n                                     (unsigned long) strip);\n                        return (0);\n                }\n        }\n\n        if( restart )\n        {\n                tif->tif_rawdataloaded = 0;\n                tif->tif_rawdataoff = 0;\n        }\n\n        /*\n        ** If we are reading more data, move any unused data to the\n        ** start of the buffer.\n        */\n        if( tif->tif_rawdataloaded > 0 )\n                unused_data = tif->tif_rawdataloaded - (tif->tif_rawcp - tif->tif_rawdata);\n        else\n                unused_data = 0;\n        \n        if( unused_data > 0 )\n        {\n\t\tassert((tif->tif_flags&TIFF_BUFFERMMAP)==0);\n                memmove( tif->tif_rawdata, tif->tif_rawcp, unused_data );\n        }\n\n        /*\n        ** Seek to the point in the file where more data should be read.\n        */\n        read_offset = td->td_stripoffset[strip]\n                + tif->tif_rawdataoff + tif->tif_rawdataloaded;\n\n        if (!SeekOK(tif, read_offset)) {\n                TIFFErrorExt(tif->tif_clientdata, module,\n                             \"Seek error at scanline %lu, strip %lu\",\n                             (unsigned long) tif->tif_row, (unsigned long) strip);\n                return 0;\n        }\n\n        /*\n        ** How much do we want to read?\n        */\n        if( read_ahead_mod > tif->tif_rawdatasize )\n                to_read = read_ahead_mod - unused_data;\n        else\n                to_read = tif->tif_rawdatasize - unused_data;\n        if( (uint64) to_read > td->td_stripbytecount[strip] \n            - tif->tif_rawdataoff - tif->tif_rawdataloaded )\n        {\n                to_read = (tmsize_t) td->td_stripbytecount[strip]\n                        - tif->tif_rawdataoff - tif->tif_rawdataloaded;\n        }\n\n\tassert((tif->tif_flags&TIFF_BUFFERMMAP)==0);\n        if( !TIFFReadAndRealloc( tif, to_read, unused_data,\n                                 1, /* is_strip */\n                                 0, /* strip_or_tile */\n                                 module) )\n        {\n                return 0;\n        }\n\n        tif->tif_rawdataoff = tif->tif_rawdataoff + tif->tif_rawdataloaded - unused_data ;\n        tif->tif_rawdataloaded = unused_data + to_read;\n\n        tif->tif_rawcc = tif->tif_rawdataloaded;\n        tif->tif_rawcp = tif->tif_rawdata;\n                        \n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0) {\n\t\tassert((tif->tif_flags&TIFF_BUFFERMMAP)==0);\n                TIFFReverseBits(tif->tif_rawdata + unused_data, to_read );\n\t}\n\n        /*\n        ** When starting a strip from the beginning we need to\n        ** restart the decoder.\n        */\n        if( restart )\n        {\n\n#ifdef JPEG_SUPPORT\n            /* A bit messy since breaks the codec abstraction. Ultimately */\n            /* there should be a function pointer for that, but it seems */\n            /* only JPEG is affected. */\n            /* For JPEG, if there are multiple scans (can generally be known */\n            /* with the  read_ahead used), we need to read the whole strip */\n            if( tif->tif_dir.td_compression==COMPRESSION_JPEG &&\n                (uint64)tif->tif_rawcc < td->td_stripbytecount[strip] )\n            {\n                if( TIFFJPEGIsFullStripRequired(tif) )\n                {\n                    return TIFFFillStrip(tif, strip);\n                }\n            }\n#endif\n\n            return TIFFStartStrip(tif, strip);\n        }\n        else\n        {\n                return 1;\n        }\n}",
          "fn_code_pos": [
            [
              162,
              0
            ],
            [
              300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFillStripPartial",
            "parameters": {
              "tif": "TIFF",
              "strip": "int",
              "read_ahead": "tmsize_t",
              "restart": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFSeek(TIFF* tif, uint32 row, uint16 sample )\n{\n\tregister TIFFDirectory *td = &tif->tif_dir;\n\tuint32 strip;\n        int    whole_strip;\n\ttmsize_t read_ahead = 0;\n\n        /*\n        ** Establish what strip we are working from.\n        */\n\tif (row >= td->td_imagelength) {\t/* out of range */\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t    \"%lu: Row out of range, max %lu\",\n\t\t    (unsigned long) row,\n\t\t    (unsigned long) td->td_imagelength);\n\t\treturn (0);\n\t}\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE) {\n\t\tif (sample >= td->td_samplesperpixel) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t    \"%lu: Sample out of range, max %lu\",\n\t\t\t    (unsigned long) sample, (unsigned long) td->td_samplesperpixel);\n\t\t\treturn (0);\n\t\t}\n\t\tstrip = (uint32)sample*td->td_stripsperimage + row/td->td_rowsperstrip;\n\t} else\n\t\tstrip = row / td->td_rowsperstrip;\n\n        /*\n         * Do we want to treat this strip as one whole chunk or\n         * read it a few lines at a time?\n         */\n#if defined(CHUNKY_STRIP_READ_SUPPORT)\n        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)\n            return 0;\n        whole_strip = tif->tif_dir.td_stripbytecount[strip] < 10\n                || isMapped(tif);\n        if( td->td_compression == COMPRESSION_LERC ||\n            td->td_compression == COMPRESSION_JBIG )\n        {\n            /* Ideally plugins should have a way to declare they don't support\n             * chunk strip */\n            whole_strip = 1;\n        }\n#else\n        whole_strip = 1;\n#endif\n        \n        if( !whole_strip )\n        {\n                /* 16 is for YCbCr mode where we may need to read 16 */\n                /* lines at a time to get a decompressed line, and 5000 */\n                /* is some constant value, for example for JPEG tables */\n                if( tif->tif_scanlinesize < TIFF_TMSIZE_T_MAX / 16 &&\n                    tif->tif_scanlinesize * 16 < TIFF_TMSIZE_T_MAX - 5000 )\n                {\n                        read_ahead = tif->tif_scanlinesize * 16 + 5000;\n                }\n                else\n                {\n                        read_ahead = tif->tif_scanlinesize;\n                }\n        }\n\n        /*\n         * If we haven't loaded this strip, do so now, possibly\n         * only reading the first part.\n         */\n\tif (strip != tif->tif_curstrip) {\t/* different strip, refill */\n                \n                if( whole_strip )\n                {\n                        if (!TIFFFillStrip(tif, strip))\n                                return (0);\n                }\n                else\n                {\n                        if( !TIFFFillStripPartial(tif,strip,read_ahead,1) )\n                                return 0;\n                }\n\t}\n\n        /*\n        ** If we already have some data loaded, do we need to read some more?\n        */\n        else if( !whole_strip )\n        {\n                if( ((tif->tif_rawdata + tif->tif_rawdataloaded) - tif->tif_rawcp) < read_ahead \n                    && (uint64) tif->tif_rawdataoff+tif->tif_rawdataloaded < td->td_stripbytecount[strip] )\n                {\n                        if( !TIFFFillStripPartial(tif,strip,read_ahead,0) )\n                                return 0;\n                }\n        }\n\n        if (row < tif->tif_row) {\n\t\t/*\n\t\t * Moving backwards within the same strip: backup\n\t\t * to the start and then decode forward (below).\n\t\t *\n\t\t * NB: If you're planning on lots of random access within a\n\t\t * strip, it's better to just read and decode the entire\n\t\t * strip, and then access the decoded data in a random fashion.\n\t\t */\n\n                if( tif->tif_rawdataoff != 0 )\n                {\n                        if( !TIFFFillStripPartial(tif,strip,read_ahead,1) )\n                                return 0;\n                }\n                else\n                {\n                        if (!TIFFStartStrip(tif, strip))\n                                return (0);\n                }\n\t}\n        \n\tif (row != tif->tif_row) {\n\t\t/*\n\t\t * Seek forward to the desired row.\n\t\t */\n\n                /* TODO: Will this really work with partial buffers? */\n                \n\t\tif (!(*tif->tif_seek)(tif, row - tif->tif_row))\n\t\t\treturn (0);\n\t\ttif->tif_row = row;\n\t}\n\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              310,
              0
            ],
            [
              441,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSeek",
            "parameters": {
              "tif": "TIFF",
              "row": "uint32",
              "sample": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFReadScanline(TIFF* tif, void* buf, uint32 row, uint16 sample)\n{\n\tint e;\n\n\tif (!TIFFCheckRead(tif, 0))\n\t\treturn (-1);\n\tif( (e = TIFFSeek(tif, row, sample)) != 0) {\n\t\t/*\n\t\t * Decompress desired row into user buffer.\n\t\t */\n\t\te = (*tif->tif_decoderow)\n\t\t    (tif, (uint8*) buf, tif->tif_scanlinesize, sample);  \n\n\t\t/* we are now poised at the beginning of the next row */\n\t\ttif->tif_row = row + 1;\n\n\t\tif (e)\n\t\t\t(*tif->tif_postdecode)(tif, (uint8*) buf,\n\t\t\t    tif->tif_scanlinesize);  \n\t}\n\treturn (e > 0 ? 1 : -1);\n}",
          "fn_code_pos": [
            [
              443,
              0
            ],
            [
              465,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadScanline",
            "parameters": {
              "tif": "TIFF",
              "buf": "void",
              "row": "uint32",
              "sample": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static tmsize_t TIFFReadEncodedStripGetStripSize(TIFF* tif, uint32 strip, uint16* pplane)\n{\n\tstatic const char module[] = \"TIFFReadEncodedStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 rowsperstrip;\n\tuint32 stripsperplane;\n\tuint32 stripinplane;\n\tuint32 rows;\n\ttmsize_t stripsize;\n\tif (!TIFFCheckRead(tif,0))\n\t\treturn((tmsize_t)(-1));\n\tif (strip>=td->td_nstrips)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"%lu: Strip out of range, max %lu\",(unsigned long)strip,\n\t\t    (unsigned long)td->td_nstrips);\n\t\treturn((tmsize_t)(-1));\n\t}\n\n\trowsperstrip=td->td_rowsperstrip;\n\tif (rowsperstrip>td->td_imagelength)\n\t\trowsperstrip=td->td_imagelength;\n\tstripsperplane= TIFFhowmany_32_maxuint_compat(td->td_imagelength, rowsperstrip);\n\tstripinplane=(strip%stripsperplane);\n\tif( pplane ) *pplane=(uint16)(strip/stripsperplane);\n\trows=td->td_imagelength-stripinplane*rowsperstrip;\n\tif (rows>rowsperstrip)\n\t\trows=rowsperstrip;\n\tstripsize=TIFFVStripSize(tif,rows);\n\tif (stripsize==0)\n\t\treturn((tmsize_t)(-1));\n\treturn stripsize;\n}",
          "fn_code_pos": [
            [
              472,
              0
            ],
            [
              504,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadEncodedStripGetStripSize",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32",
              "pplane": "uint16"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadEncodedStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\ttmsize_t stripsize;\n\tuint16 plane;\n\n\tstripsize=TIFFReadEncodedStripGetStripSize(tif, strip, &plane);\n\tif (stripsize==((tmsize_t)(-1)))\n\t\treturn((tmsize_t)(-1));\n\n    /* shortcut to avoid an extra memcpy() */\n    if( td->td_compression == COMPRESSION_NONE &&\n        size!=(tmsize_t)(-1) && size >= stripsize &&\n        !isMapped(tif) &&\n        ((tif->tif_flags&TIFF_NOREADRAW)==0) )\n    {\n        if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize)\n            return ((tmsize_t)(-1));\n\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits(buf,stripsize);\n\n        (*tif->tif_postdecode)(tif,buf,stripsize);\n        return (stripsize);\n    }\n\n\tif ((size!=(tmsize_t)(-1))&&(size<stripsize))\n\t\tstripsize=size;\n\tif (!TIFFFillStrip(tif,strip))\n\t\treturn((tmsize_t)(-1));\n\tif ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0)\n\t\treturn((tmsize_t)(-1));\n\t(*tif->tif_postdecode)(tif,buf,stripsize);\n\treturn(stripsize);\n}",
          "fn_code_pos": [
            [
              510,
              0
            ],
            [
              547,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadEncodedStrip",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32",
              "buf": "void",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "tmsize_t\n_TIFFReadEncodedStripAndAllocBuffer(TIFF* tif, uint32 strip,\n                                    void **buf, tmsize_t bufsizetoalloc,\n                                    tmsize_t size_to_read)\n{\n    tmsize_t this_stripsize;\n    uint16 plane;\n\n    if( *buf != NULL )\n    {\n        return TIFFReadEncodedStrip(tif, strip, *buf, size_to_read);\n    }\n\n    this_stripsize=TIFFReadEncodedStripGetStripSize(tif, strip, &plane);\n    if (this_stripsize==((tmsize_t)(-1)))\n            return((tmsize_t)(-1));\n\n    if ((size_to_read!=(tmsize_t)(-1))&&(size_to_read<this_stripsize))\n            this_stripsize=size_to_read;\n    if (!TIFFFillStrip(tif,strip))\n            return((tmsize_t)(-1));\n\n    *buf = _TIFFmalloc(bufsizetoalloc);\n    if (*buf == NULL) {\n            TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n            return((tmsize_t)(-1));\n    }\n    _TIFFmemset(*buf, 0, bufsizetoalloc);\n\n    if ((*tif->tif_decodestrip)(tif,*buf,this_stripsize,plane)<=0)\n            return((tmsize_t)(-1));\n    (*tif->tif_postdecode)(tif,*buf,this_stripsize);\n    return(this_stripsize);\n\n\n}",
          "fn_code_pos": [
            [
              555,
              0
            ],
            [
              590,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFReadEncodedStripAndAllocBuffer",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32",
              "buf": "void",
              "bufsizetoalloc": "tmsize_t",
              "size_to_read": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static tmsize_t\nTIFFReadRawStrip1(TIFF* tif, uint32 strip, void* buf, tmsize_t size,\n    const char* module)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n    if (!_TIFFFillStriles( tif ))\n        return ((tmsize_t)(-1));\n        \n\tassert((tif->tif_flags&TIFF_NOREADRAW)==0);\n\tif (!isMapped(tif)) {\n\t\ttmsize_t cc;\n\n\t\tif (!SeekOK(tif, td->td_stripoffset[strip])) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Seek error at scanline %lu, strip %lu\",\n\t\t\t    (unsigned long) tif->tif_row, (unsigned long) strip);\n\t\t\treturn ((tmsize_t)(-1));\n\t\t}\n\t\tcc = TIFFReadFile(tif, buf, size);\n\t\tif (cc != size) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\"Read error at scanline %lu; got %I64u bytes, expected %I64u\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned __int64) cc,\n\t\t\t\t     (unsigned __int64) size);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\"Read error at scanline %lu; got %llu bytes, expected %llu\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long long) cc,\n\t\t\t\t     (unsigned long long) size);\n#endif\n\t\t\treturn ((tmsize_t)(-1));\n\t\t}\n\t} else {\n\t\ttmsize_t ma = 0;\n\t\ttmsize_t n;\n\t\tif ((td->td_stripoffset[strip] > (uint64)TIFF_TMSIZE_T_MAX)||\n                    ((ma=(tmsize_t)td->td_stripoffset[strip])>tif->tif_size))\n                {\n                    n=0;\n                }\n                else if( ma > TIFF_TMSIZE_T_MAX - size )\n                {\n                    n=0;\n                }\n                else\n                {\n                    tmsize_t mb=ma+size;\n                    if (mb>tif->tif_size)\n                            n=tif->tif_size-ma;\n                    else\n                            n=size;\n                }\n\t\tif (n!=size) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\"Read error at scanline %lu, strip %lu; got %I64u bytes, expected %I64u\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long) strip,\n\t\t\t\t     (unsigned __int64) n,\n\t\t\t\t     (unsigned __int64) size);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\"Read error at scanline %lu, strip %lu; got %llu bytes, expected %llu\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long) strip,\n\t\t\t\t     (unsigned long long) n,\n\t\t\t\t     (unsigned long long) size);\n#endif\n\t\t\treturn ((tmsize_t)(-1));\n\t\t}\n\t\t_TIFFmemcpy(buf, tif->tif_base + ma,\n\t\t\t    size);\n\t}\n\treturn (size);\n}",
          "fn_code_pos": [
            [
              592,
              0
            ],
            [
              670,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRawStrip1",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32",
              "buf": "void",
              "size": "tmsize_t",
              "module": "char"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static tmsize_t\nTIFFReadRawStripOrTile2(TIFF* tif, uint32 strip_or_tile, int is_strip,\n                        tmsize_t size, const char* module)\n{\n        TIFFDirectory *td = &tif->tif_dir;\n\n        assert( !isMapped(tif) );\n        assert((tif->tif_flags&TIFF_NOREADRAW)==0);\n\n        if (!SeekOK(tif, td->td_stripoffset[strip_or_tile])) {\n            if( is_strip )\n            {\n                TIFFErrorExt(tif->tif_clientdata, module,\n                    \"Seek error at scanline %lu, strip %lu\",\n                    (unsigned long) tif->tif_row,\n                    (unsigned long) strip_or_tile);\n            }\n            else\n            {\n                TIFFErrorExt(tif->tif_clientdata, module,\n                    \"Seek error at row %lu, col %lu, tile %lu\",\n                    (unsigned long) tif->tif_row,\n                    (unsigned long) tif->tif_col,\n                    (unsigned long) strip_or_tile);\n            }\n            return ((tmsize_t)(-1));\n        }\n\n        if( !TIFFReadAndRealloc( tif, size, 0, is_strip,\n                                 strip_or_tile, module ) )\n        {\n            return ((tmsize_t)(-1));\n        }\n\n        return (size);\n}",
          "fn_code_pos": [
            [
              672,
              0
            ],
            [
              707,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRawStripOrTile2",
            "parameters": {
              "tif": "TIFF",
              "strip_or_tile": "uint32",
              "is_strip": "int",
              "size": "tmsize_t",
              "module": "char"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFReadRawStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadRawStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64 bytecount;\n\ttmsize_t bytecountm;\n\n\tif (!TIFFCheckRead(tif, 0))\n\t\treturn ((tmsize_t)(-1));\n\tif (strip >= td->td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"%lu: Strip out of range, max %lu\",\n\t\t     (unsigned long) strip,\n\t\t     (unsigned long) td->td_nstrips);\n\t\treturn ((tmsize_t)(-1));\n\t}\n\tif (tif->tif_flags&TIFF_NOREADRAW)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Compression scheme does not support access to raw uncompressed data\");\n\t\treturn ((tmsize_t)(-1));\n\t}\n\tbytecount = td->td_stripbytecount[strip];\n\tif ((int64)bytecount <= 0) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%I64u: Invalid strip byte count, strip %lu\",\n\t\t\t     (unsigned __int64) bytecount,\n\t\t\t     (unsigned long) strip);\n#else\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%llu: Invalid strip byte count, strip %lu\",\n\t\t\t     (unsigned long long) bytecount,\n\t\t\t     (unsigned long) strip);\n#endif\n\t\treturn ((tmsize_t)(-1));\n\t}\n\tbytecountm = (tmsize_t)bytecount;\n\tif ((uint64)bytecountm!=bytecount) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Integer overflow\");\n\t\treturn ((tmsize_t)(-1));\n\t}\n\tif (size != (tmsize_t)(-1) && size < bytecountm)\n\t\tbytecountm = size;\n\treturn (TIFFReadRawStrip1(tif, strip, buf, bytecountm, module));\n}",
          "fn_code_pos": [
            [
              712,
              0
            ],
            [
              758,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRawStrip",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32",
              "buf": "void",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "int\nTIFFFillStrip(TIFF* tif, uint32 strip)\n{\n\tstatic const char module[] = \"TIFFFillStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\n        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)\n            return 0;\n\n\tif ((tif->tif_flags&TIFF_NOREADRAW)==0)\n\t{\n\t\tuint64 bytecount = td->td_stripbytecount[strip];\n\t\tif ((int64)bytecount <= 0) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Invalid strip byte count %I64u, strip %lu\",\n\t\t\t\t     (unsigned __int64) bytecount,\n\t\t\t\t     (unsigned long) strip);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Invalid strip byte count %llu, strip %lu\",\n\t\t\t\t     (unsigned long long) bytecount,\n\t\t\t\t     (unsigned long) strip);\n#endif\n\t\t\treturn (0);\n\t\t}\n\n\t\t/* To avoid excessive memory allocations: */\n\t\t/* Byte count should normally not be larger than a number of */\n\t\t/* times the uncompressed size plus some margin */\n                if( bytecount > 1024 * 1024 )\n                {\n\t\t\t/* 10 and 4096 are just values that could be adjusted. */\n\t\t\t/* Hopefully they are safe enough for all codecs */\n\t\t\ttmsize_t stripsize = TIFFStripSize(tif);\n\t\t\tif( stripsize != 0 &&\n\t\t\t    (bytecount - 4096) / 10 > (uint64)stripsize  )\n\t\t\t{\n\t\t\t\tuint64 newbytecount = (uint64)stripsize * 10 + 4096;\n\t\t\t\tif( (int64)newbytecount >= 0 )\n\t\t\t\t{\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t  \"Too large strip byte count %I64u, strip %lu. Limiting to %I64u\",\n\t\t\t\t\t     (unsigned __int64) bytecount,\n\t\t\t\t\t     (unsigned long) strip,\n\t\t\t\t\t     (unsigned __int64) newbytecount);\n#else\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t  \"Too large strip byte count %llu, strip %lu. Limiting to %llu\",\n\t\t\t\t\t     (unsigned long long) bytecount,\n\t\t\t\t\t     (unsigned long) strip,\n\t\t\t\t\t     (unsigned long long) newbytecount);\n#endif\n\t\t\t\t\tbytecount = newbytecount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isMapped(tif)) {\n\t\t\t/*\n\t\t\t * We must check for overflow, potentially causing\n\t\t\t * an OOB read. Instead of simple\n\t\t\t *\n\t\t\t *  td->td_stripoffset[strip]+bytecount > tif->tif_size\n\t\t\t *\n\t\t\t * comparison (which can overflow) we do the following\n\t\t\t * two comparisons:\n\t\t\t */\n\t\t\tif (bytecount > (uint64)tif->tif_size ||\n\t\t\t    td->td_stripoffset[strip] > (uint64)tif->tif_size - bytecount) {\n\t\t\t\t/*\n\t\t\t\t * This error message might seem strange, but\n\t\t\t\t * it's what would happen if a read were done\n\t\t\t\t * instead.\n\t\t\t\t */\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\n\t\t\t\t\t\"Read error on strip %lu; \"\n\t\t\t\t\t\"got %I64u bytes, expected %I64u\",\n\t\t\t\t\t(unsigned long) strip,\n\t\t\t\t\t(unsigned __int64) tif->tif_size - td->td_stripoffset[strip],\n\t\t\t\t\t(unsigned __int64) bytecount);\n#else\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\n\t\t\t\t\t\"Read error on strip %lu; \"\n\t\t\t\t\t\"got %llu bytes, expected %llu\",\n\t\t\t\t\t(unsigned long) strip,\n\t\t\t\t\t(unsigned long long) tif->tif_size - td->td_stripoffset[strip],\n\t\t\t\t\t(unsigned long long) bytecount);\n#endif\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\n\t\tif (isMapped(tif) &&\n\t\t    (isFillOrder(tif, td->td_fillorder)\n\t\t    || (tif->tif_flags & TIFF_NOBITREV))) {\n\t\t\t/*\n\t\t\t * The image is mapped into memory and we either don't\n\t\t\t * need to flip bits or the compression routine is\n\t\t\t * going to handle this operation itself.  In this\n\t\t\t * case, avoid copying the raw data and instead just\n\t\t\t * reference the data from the memory mapped file\n\t\t\t * image.  This assumes that the decompression\n\t\t\t * routines do not modify the contents of the raw data\n\t\t\t * buffer (if they try to, the application will get a\n\t\t\t * fault since the file is mapped read-only).\n\t\t\t */\n\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {\n\t\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\t\ttif->tif_rawdata = NULL;\n\t\t\t\ttif->tif_rawdatasize = 0;\n\t\t\t}\n\t\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\n\t\t\ttif->tif_rawdatasize = (tmsize_t)bytecount;\n\t\t\ttif->tif_rawdata = tif->tif_base + (tmsize_t)td->td_stripoffset[strip];\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = (tmsize_t) bytecount;\n\n\t\t\t/* \n\t\t\t * When we have tif_rawdata reference directly into the memory mapped file\n\t\t\t * we need to be pretty careful about how we use the rawdata.  It is not\n\t\t\t * a general purpose working buffer as it normally otherwise is.  So we\n\t\t\t * keep track of this fact to avoid using it improperly.\n\t\t\t */\n\t\t\ttif->tif_flags |= TIFF_BUFFERMMAP;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Expand raw data buffer, if needed, to hold data\n\t\t\t * strip coming from file (perhaps should set upper\n\t\t\t * bound on the size of a buffer we'll use?).\n\t\t\t */\n\t\t\ttmsize_t bytecountm;\n\t\t\tbytecountm=(tmsize_t)bytecount;\n\t\t\tif ((uint64)bytecountm!=bytecount)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (bytecountm > tif->tif_rawdatasize) {\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) == 0) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Data buffer too small to hold strip %lu\",\n\t\t\t\t\t    (unsigned long) strip);\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tif->tif_flags&TIFF_BUFFERMMAP) {\n\t\t\t\ttif->tif_curstrip = NOSTRIP;\n\t\t\t\ttif->tif_rawdata = NULL;\n\t\t\t\ttif->tif_rawdatasize = 0;\n\t\t\t\ttif->tif_flags &= ~TIFF_BUFFERMMAP;\n\t\t\t}\n\n\t\t\tif( isMapped(tif) )\n\t\t\t{\n\t\t\t\tif (bytecountm > tif->tif_rawdatasize &&\n\t\t\t\t    !TIFFReadBufferSetup(tif, 0, bytecountm))\n\t\t\t\t{\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (TIFFReadRawStrip1(tif, strip, tif->tif_rawdata,\n\t\t\t\t    bytecountm, module) != bytecountm)\n\t\t\t\t{\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (TIFFReadRawStripOrTile2(tif, strip, 1,\n\t\t\t\t    bytecountm, module) != bytecountm)\n\t\t\t\t{\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\n\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = bytecountm;\n                        \n\t\t\tif (!isFillOrder(tif, td->td_fillorder) &&\n\t\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\t\tTIFFReverseBits(tif->tif_rawdata, bytecountm);\n                }\n\t}\n\treturn (TIFFStartStrip(tif, strip));\n}",
          "fn_code_pos": [
            [
              764,
              0
            ],
            [
              955,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFillStrip",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFReadTile(TIFF* tif, void* buf, uint32 x, uint32 y, uint32 z, uint16 s)\n{\n\tif (!TIFFCheckRead(tif, 1) || !TIFFCheckTile(tif, x, y, z, s))\n\t\treturn ((tmsize_t)(-1));\n\treturn (TIFFReadEncodedTile(tif,\n\t    TIFFComputeTile(tif, x, y, z, s), buf, (tmsize_t)(-1)));\n}",
          "fn_code_pos": [
            [
              966,
              0
            ],
            [
              973,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadTile",
            "parameters": {
              "tif": "TIFF",
              "buf": "void",
              "x": "uint32",
              "y": "uint32",
              "z": "uint32",
              "s": "uint16"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFReadEncodedTile(TIFF* tif, uint32 tile, void* buf, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadEncodedTile\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\ttmsize_t tilesize = tif->tif_tilesize;\n\n\tif (!TIFFCheckRead(tif, 1))\n\t\treturn ((tmsize_t)(-1));\n\tif (tile >= td->td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"%lu: Tile out of range, max %lu\",\n\t\t    (unsigned long) tile, (unsigned long) td->td_nstrips);\n\t\treturn ((tmsize_t)(-1));\n\t}\n\n    /* shortcut to avoid an extra memcpy() */\n    if( td->td_compression == COMPRESSION_NONE &&\n        size!=(tmsize_t)(-1) && size >= tilesize &&\n        !isMapped(tif) &&\n        ((tif->tif_flags&TIFF_NOREADRAW)==0) )\n    {\n        if (TIFFReadRawTile1(tif, tile, buf, tilesize, module) != tilesize)\n            return ((tmsize_t)(-1));\n\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits(buf,tilesize);\n\n        (*tif->tif_postdecode)(tif,buf,tilesize);\n        return (tilesize);\n    }\n\n\tif (size == (tmsize_t)(-1))\n\t\tsize = tilesize;\n\telse if (size > tilesize)\n\t\tsize = tilesize;\n\tif (TIFFFillTile(tif, tile) && (*tif->tif_decodetile)(tif,\n\t    (uint8*) buf, size, (uint16)(tile/td->td_stripsperimage))) {\n\t\t(*tif->tif_postdecode)(tif, (uint8*) buf, size);\n\t\treturn (size);\n\t} else\n\t\treturn ((tmsize_t)(-1));\n}",
          "fn_code_pos": [
            [
              979,
              0
            ],
            [
              1022,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadEncodedTile",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32",
              "buf": "void",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "tmsize_t\n_TIFFReadTileAndAllocBuffer(TIFF* tif,\n                            void **buf, tmsize_t bufsizetoalloc,\n                            uint32 x, uint32 y, uint32 z, uint16 s)\n{\n    if (!TIFFCheckRead(tif, 1) || !TIFFCheckTile(tif, x, y, z, s))\n            return ((tmsize_t)(-1));\n    return (_TIFFReadEncodedTileAndAllocBuffer(tif,\n                                               TIFFComputeTile(tif, x, y, z, s),\n                                               buf, bufsizetoalloc,\n                                               (tmsize_t)(-1)));\n}",
          "fn_code_pos": [
            [
              1030,
              0
            ],
            [
              1041,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFReadTileAndAllocBuffer",
            "parameters": {
              "tif": "TIFF",
              "buf": "void",
              "bufsizetoalloc": "tmsize_t",
              "x": "uint32",
              "y": "uint32",
              "z": "uint32",
              "s": "uint16"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "tmsize_t\n_TIFFReadEncodedTileAndAllocBuffer(TIFF* tif, uint32 tile,\n                                    void **buf, tmsize_t bufsizetoalloc,\n                                    tmsize_t size_to_read)\n{\n    static const char module[] = \"_TIFFReadEncodedTileAndAllocBuffer\";\n    TIFFDirectory *td = &tif->tif_dir;\n    tmsize_t tilesize = tif->tif_tilesize;\n\n    if( *buf != NULL )\n    {\n        return TIFFReadEncodedTile(tif, tile, *buf, size_to_read);\n    }\n\n    if (!TIFFCheckRead(tif, 1))\n            return ((tmsize_t)(-1));\n    if (tile >= td->td_nstrips) {\n            TIFFErrorExt(tif->tif_clientdata, module,\n                \"%lu: Tile out of range, max %lu\",\n                (unsigned long) tile, (unsigned long) td->td_nstrips);\n            return ((tmsize_t)(-1));\n    }\n\n    if (!TIFFFillTile(tif,tile))\n            return((tmsize_t)(-1));\n\n    *buf = _TIFFmalloc(bufsizetoalloc);\n    if (*buf == NULL) {\n            TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),\n                         \"No space for tile buffer\");\n            return((tmsize_t)(-1));\n    }\n    _TIFFmemset(*buf, 0, bufsizetoalloc);\n\n    if (size_to_read == (tmsize_t)(-1))\n        size_to_read = tilesize;\n    else if (size_to_read > tilesize)\n        size_to_read = tilesize;\n    if( (*tif->tif_decodetile)(tif,\n        (uint8*) *buf, size_to_read, (uint16)(tile/td->td_stripsperimage))) {\n        (*tif->tif_postdecode)(tif, (uint8*) *buf, size_to_read);\n        return (size_to_read);\n    } else\n        return ((tmsize_t)(-1));\n}",
          "fn_code_pos": [
            [
              1049,
              0
            ],
            [
              1093,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFReadEncodedTileAndAllocBuffer",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32",
              "buf": "void",
              "bufsizetoalloc": "tmsize_t",
              "size_to_read": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static tmsize_t\nTIFFReadRawTile1(TIFF* tif, uint32 tile, void* buf, tmsize_t size, const char* module)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n    if (!_TIFFFillStriles( tif ))\n        return ((tmsize_t)(-1));\n\n\tassert((tif->tif_flags&TIFF_NOREADRAW)==0);\n\tif (!isMapped(tif)) {\n\t\ttmsize_t cc;\n\n\t\tif (!SeekOK(tif, td->td_stripoffset[tile])) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Seek error at row %lu, col %lu, tile %lu\",\n\t\t\t    (unsigned long) tif->tif_row,\n\t\t\t    (unsigned long) tif->tif_col,\n\t\t\t    (unsigned long) tile);\n\t\t\treturn ((tmsize_t)(-1));\n\t\t}\n\t\tcc = TIFFReadFile(tif, buf, size);\n\t\tif (cc != size) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\"Read error at row %lu, col %lu; got %I64u bytes, expected %I64u\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long) tif->tif_col,\n\t\t\t\t     (unsigned __int64) cc,\n\t\t\t\t     (unsigned __int64) size);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\"Read error at row %lu, col %lu; got %llu bytes, expected %llu\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long) tif->tif_col,\n\t\t\t\t     (unsigned long long) cc,\n\t\t\t\t     (unsigned long long) size);\n#endif\n\t\t\treturn ((tmsize_t)(-1));\n\t\t}\n\t} else {\n\t\ttmsize_t ma,mb;\n\t\ttmsize_t n;\n\t\tma=(tmsize_t)td->td_stripoffset[tile];\n\t\tmb=ma+size;\n\t\tif ((td->td_stripoffset[tile] > (uint64)TIFF_TMSIZE_T_MAX)||(ma>tif->tif_size))\n\t\t\tn=0;\n\t\telse if ((mb<ma)||(mb<size)||(mb>tif->tif_size))\n\t\t\tn=tif->tif_size-ma;\n\t\telse\n\t\t\tn=size;\n\t\tif (n!=size) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\"Read error at row %lu, col %lu, tile %lu; got %I64u bytes, expected %I64u\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long) tif->tif_col,\n\t\t\t\t     (unsigned long) tile,\n\t\t\t\t     (unsigned __int64) n,\n\t\t\t\t     (unsigned __int64) size);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\"Read error at row %lu, col %lu, tile %lu; got %llu bytes, expected %llu\",\n\t\t\t\t     (unsigned long) tif->tif_row,\n\t\t\t\t     (unsigned long) tif->tif_col,\n\t\t\t\t     (unsigned long) tile,\n\t\t\t\t     (unsigned long long) n,\n\t\t\t\t     (unsigned long long) size);\n#endif\n\t\t\treturn ((tmsize_t)(-1));\n\t\t}\n\t\t_TIFFmemcpy(buf, tif->tif_base + ma, size);\n\t}\n\treturn (size);\n}",
          "fn_code_pos": [
            [
              1095,
              0
            ],
            [
              1168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRawTile1",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32",
              "buf": "void",
              "size": "tmsize_t",
              "module": "char"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFReadRawTile(TIFF* tif, uint32 tile, void* buf, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadRawTile\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64 bytecount64;\n\ttmsize_t bytecountm;\n\n\tif (!TIFFCheckRead(tif, 1))\n\t\treturn ((tmsize_t)(-1));\n\tif (tile >= td->td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"%lu: Tile out of range, max %lu\",\n\t\t    (unsigned long) tile, (unsigned long) td->td_nstrips);\n\t\treturn ((tmsize_t)(-1));\n\t}\n\tif (tif->tif_flags&TIFF_NOREADRAW)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\"Compression scheme does not support access to raw uncompressed data\");\n\t\treturn ((tmsize_t)(-1));\n\t}\n\tbytecount64 = td->td_stripbytecount[tile];\n\tif (size != (tmsize_t)(-1) && (uint64)size < bytecount64)\n\t\tbytecount64 = (uint64)size;\n\tbytecountm = (tmsize_t)bytecount64;\n\tif ((uint64)bytecountm!=bytecount64)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\treturn ((tmsize_t)(-1));\n\t}\n\treturn (TIFFReadRawTile1(tif, tile, buf, bytecountm, module));\n}",
          "fn_code_pos": [
            [
              1173,
              0
            ],
            [
              1205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRawTile",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32",
              "buf": "void",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "int\nTIFFFillTile(TIFF* tif, uint32 tile)\n{\n\tstatic const char module[] = \"TIFFFillTile\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\n        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)\n            return 0;\n\n\tif ((tif->tif_flags&TIFF_NOREADRAW)==0)\n\t{\n\t\tuint64 bytecount = td->td_stripbytecount[tile];\n\t\tif ((int64)bytecount <= 0) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%I64u: Invalid tile byte count, tile %lu\",\n\t\t\t\t     (unsigned __int64) bytecount,\n\t\t\t\t     (unsigned long) tile);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%llu: Invalid tile byte count, tile %lu\",\n\t\t\t\t     (unsigned long long) bytecount,\n\t\t\t\t     (unsigned long) tile);\n#endif\n\t\t\treturn (0);\n\t\t}\n\n\t\t/* To avoid excessive memory allocations: */\n\t\t/* Byte count should normally not be larger than a number of */\n\t\t/* times the uncompressed size plus some margin */\n                if( bytecount > 1024 * 1024 )\n                {\n\t\t\t/* 10 and 4096 are just values that could be adjusted. */\n\t\t\t/* Hopefully they are safe enough for all codecs */\n\t\t\ttmsize_t stripsize = TIFFTileSize(tif);\n\t\t\tif( stripsize != 0 &&\n\t\t\t    (bytecount - 4096) / 10 > (uint64)stripsize  )\n\t\t\t{\n\t\t\t\tuint64 newbytecount = (uint64)stripsize * 10 + 4096;\n\t\t\t\tif( (int64)newbytecount >= 0 )\n\t\t\t\t{\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t  \"Too large tile byte count %I64u, tile %lu. Limiting to %I64u\",\n\t\t\t\t\t     (unsigned __int64) bytecount,\n\t\t\t\t\t     (unsigned long) tile,\n\t\t\t\t\t     (unsigned __int64) newbytecount);\n#else\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t  \"Too large tile byte count %llu, tile %lu. Limiting to %llu\",\n\t\t\t\t\t     (unsigned long long) bytecount,\n\t\t\t\t\t     (unsigned long) tile,\n\t\t\t\t\t     (unsigned long long) newbytecount);\n#endif\n\t\t\t\t\tbytecount = newbytecount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isMapped(tif)) {\n\t\t\t/*\n\t\t\t * We must check for overflow, potentially causing\n\t\t\t * an OOB read. Instead of simple\n\t\t\t *\n\t\t\t *  td->td_stripoffset[tile]+bytecount > tif->tif_size\n\t\t\t *\n\t\t\t * comparison (which can overflow) we do the following\n\t\t\t * two comparisons:\n\t\t\t */\n\t\t\tif (bytecount > (uint64)tif->tif_size ||\n\t\t\t    td->td_stripoffset[tile] > (uint64)tif->tif_size - bytecount) {\n\t\t\t\ttif->tif_curtile = NOTILE;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\n\t\tif (isMapped(tif) &&\n\t\t    (isFillOrder(tif, td->td_fillorder)\n\t\t     || (tif->tif_flags & TIFF_NOBITREV))) {\n\t\t\t/*\n\t\t\t * The image is mapped into memory and we either don't\n\t\t\t * need to flip bits or the compression routine is\n\t\t\t * going to handle this operation itself.  In this\n\t\t\t * case, avoid copying the raw data and instead just\n\t\t\t * reference the data from the memory mapped file\n\t\t\t * image.  This assumes that the decompression\n\t\t\t * routines do not modify the contents of the raw data\n\t\t\t * buffer (if they try to, the application will get a\n\t\t\t * fault since the file is mapped read-only).\n\t\t\t */\n\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {\n\t\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\t\ttif->tif_rawdata = NULL;\n\t\t\t\ttif->tif_rawdatasize = 0;\n\t\t\t}\n\t\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\n\n\t\t\ttif->tif_rawdatasize = (tmsize_t)bytecount;\n\t\t\ttif->tif_rawdata =\n\t\t\t\ttif->tif_base + (tmsize_t)td->td_stripoffset[tile];\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = (tmsize_t) bytecount;\n\t\t\ttif->tif_flags |= TIFF_BUFFERMMAP;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Expand raw data buffer, if needed, to hold data\n\t\t\t * tile coming from file (perhaps should set upper\n\t\t\t * bound on the size of a buffer we'll use?).\n\t\t\t */\n\t\t\ttmsize_t bytecountm;\n\t\t\tbytecountm=(tmsize_t)bytecount;\n\t\t\tif ((uint64)bytecountm!=bytecount)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (bytecountm > tif->tif_rawdatasize) {\n\t\t\t\ttif->tif_curtile = NOTILE;\n\t\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) == 0) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Data buffer too small to hold tile %lu\",\n\t\t\t\t\t    (unsigned long) tile);\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tif->tif_flags&TIFF_BUFFERMMAP) {\n\t\t\t\ttif->tif_curtile = NOTILE;\n\t\t\t\ttif->tif_rawdata = NULL;\n\t\t\t\ttif->tif_rawdatasize = 0;\n\t\t\t\ttif->tif_flags &= ~TIFF_BUFFERMMAP;\n\t\t\t}\n\n\t\t\tif( isMapped(tif) )\n\t\t\t{\n\t\t\t\tif (bytecountm > tif->tif_rawdatasize &&\n\t\t\t\t    !TIFFReadBufferSetup(tif, 0, bytecountm))\n\t\t\t\t{\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (TIFFReadRawTile1(tif, tile, tif->tif_rawdata,\n\t\t\t\t    bytecountm, module) != bytecountm)\n\t\t\t\t{\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (TIFFReadRawStripOrTile2(tif, tile, 0,\n\t\t\t\t    bytecountm, module) != bytecountm)\n\t\t\t\t{\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\n\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = bytecountm;\n                        \n\t\t\tif (!isFillOrder(tif, td->td_fillorder) &&\n\t\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\t\tTIFFReverseBits(tif->tif_rawdata,\n                                                tif->tif_rawdataloaded);\n\t\t}\n\t}\n\treturn (TIFFStartTile(tif, tile));\n}",
          "fn_code_pos": [
            [
              1211,
              0
            ],
            [
              1376,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFillTile",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFReadBufferSetup(TIFF* tif, void* bp, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadBufferSetup\";\n\n\tassert((tif->tif_flags&TIFF_NOREADRAW)==0);\n\ttif->tif_flags &= ~TIFF_BUFFERMMAP;\n\n\tif (tif->tif_rawdata) {\n\t\tif (tif->tif_flags & TIFF_MYBUFFER)\n\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\ttif->tif_rawdata = NULL;\n\t\ttif->tif_rawdatasize = 0;\n\t}\n\tif (bp) {\n\t\ttif->tif_rawdatasize = size;\n\t\ttif->tif_rawdata = (uint8*) bp;\n\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\n\t} else {\n\t\ttif->tif_rawdatasize = (tmsize_t)TIFFroundup_64((uint64)size, 1024);\n\t\tif (tif->tif_rawdatasize==0) {\n\t\t    TIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t \"Invalid buffer size\");\n\t\t    return (0);\n\t\t}\n\t\t/* Initialize to zero to avoid uninitialized buffers in case of */\n                /* short reads (http://bugzilla.maptools.org/show_bug.cgi?id=2651) */\n\t\ttif->tif_rawdata = (uint8*) _TIFFcalloc(1, tif->tif_rawdatasize);\n\t\ttif->tif_flags |= TIFF_MYBUFFER;\n\t}\n\tif (tif->tif_rawdata == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"No space for data buffer at scanline %lu\",\n\t\t    (unsigned long) tif->tif_row);\n\t\ttif->tif_rawdatasize = 0;\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1387,
              0
            ],
            [
              1425,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadBufferSetup",
            "parameters": {
              "tif": "TIFF",
              "bp": "void",
              "size": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFStartStrip(TIFF* tif, uint32 strip)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)\n            return 0;\n\n\tif ((tif->tif_flags & TIFF_CODERSETUP) == 0) {\n\t\tif (!(*tif->tif_setupdecode)(tif))\n\t\t\treturn (0);\n\t\ttif->tif_flags |= TIFF_CODERSETUP;\n\t}\n\ttif->tif_curstrip = strip;\n\ttif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;\n        tif->tif_flags &= ~TIFF_BUF4WRITE;\n\n\tif (tif->tif_flags&TIFF_NOREADRAW)\n\t{\n\t\ttif->tif_rawcp = NULL;\n\t\ttif->tif_rawcc = 0;  \n\t}\n\telse\n\t{\n\t\ttif->tif_rawcp = tif->tif_rawdata;\n\t\tif( tif->tif_rawdataloaded > 0 )\n\t\t\ttif->tif_rawcc = tif->tif_rawdataloaded;\n\t\telse\n\t\t\ttif->tif_rawcc = (tmsize_t)td->td_stripbytecount[strip];\n\t}\n\treturn ((*tif->tif_predecode)(tif,\n\t\t\t(uint16)(strip / td->td_stripsperimage)));\n}",
          "fn_code_pos": [
            [
              1431,
              0
            ],
            [
              1463,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFStartStrip",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFStartTile(TIFF* tif, uint32 tile)\n{\n        static const char module[] = \"TIFFStartTile\";\n\tTIFFDirectory *td = &tif->tif_dir;\n        uint32 howmany32;\n\n        if (!_TIFFFillStriles( tif ) || !tif->tif_dir.td_stripbytecount)\n                return 0;\n\n\tif ((tif->tif_flags & TIFF_CODERSETUP) == 0) {\n\t\tif (!(*tif->tif_setupdecode)(tif))\n\t\t\treturn (0);\n\t\ttif->tif_flags |= TIFF_CODERSETUP;\n\t}\n\ttif->tif_curtile = tile;\n        howmany32=TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth);\n        if (howmany32 == 0) {\n                 TIFFErrorExt(tif->tif_clientdata,module,\"Zero tiles\");\n                return 0;\n        }\n\ttif->tif_row = (tile % howmany32) * td->td_tilelength;\n        howmany32=TIFFhowmany_32(td->td_imagelength, td->td_tilelength);\n        if (howmany32 == 0) {\n                TIFFErrorExt(tif->tif_clientdata,module,\"Zero tiles\");\n                return 0;\n        }\n\ttif->tif_col = (tile % howmany32) * td->td_tilewidth;\n        tif->tif_flags &= ~TIFF_BUF4WRITE;\n\tif (tif->tif_flags&TIFF_NOREADRAW)\n\t{\n\t\ttif->tif_rawcp = NULL;\n\t\ttif->tif_rawcc = 0;\n\t}\n\telse\n\t{\n\t\ttif->tif_rawcp = tif->tif_rawdata;\n\t\tif( tif->tif_rawdataloaded > 0 )\n\t\t\ttif->tif_rawcc = tif->tif_rawdataloaded;\n\t\telse\n\t\t\ttif->tif_rawcc = (tmsize_t)td->td_stripbytecount[tile];\n\t}\n\treturn ((*tif->tif_predecode)(tif,\n\t\t\t(uint16)(tile/td->td_stripsperimage)));\n}",
          "fn_code_pos": [
            [
              1469,
              0
            ],
            [
              1513,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFStartTile",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFCheckRead(TIFF* tif, int tiles)\n{\n\tif (tif->tif_mode == O_WRONLY) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"File not open for reading\");\n\t\treturn (0);\n\t}\n\tif (tiles ^ isTiled(tif)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, tiles ?\n\t\t    \"Can not read tiles from a stripped image\" :\n\t\t    \"Can not read scanlines from a tiled image\");\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1515,
              0
            ],
            [
              1529,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCheckRead",
            "parameters": {
              "tif": "TIFF",
              "tiles": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\n_TIFFNoPostDecode(TIFF* tif, uint8* buf, tmsize_t cc)\n{\n    (void) tif; (void) buf; (void) cc;\n}",
          "fn_code_pos": [
            [
              1531,
              0
            ],
            [
              1535,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoPostDecode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\n_TIFFSwab16BitData(TIFF* tif, uint8* buf, tmsize_t cc)\n{\n    (void) tif;\n    assert((cc & 1) == 0);\n    TIFFSwabArrayOfShort((uint16*) buf, cc/2);\n}",
          "fn_code_pos": [
            [
              1537,
              0
            ],
            [
              1543,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFSwab16BitData",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\n_TIFFSwab24BitData(TIFF* tif, uint8* buf, tmsize_t cc)\n{\n    (void) tif;\n    assert((cc % 3) == 0);\n    TIFFSwabArrayOfTriples((uint8*) buf, cc/3);\n}",
          "fn_code_pos": [
            [
              1545,
              0
            ],
            [
              1551,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFSwab24BitData",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\n_TIFFSwab32BitData(TIFF* tif, uint8* buf, tmsize_t cc)\n{\n    (void) tif;\n    assert((cc & 3) == 0);\n    TIFFSwabArrayOfLong((uint32*) buf, cc/4);\n}",
          "fn_code_pos": [
            [
              1553,
              0
            ],
            [
              1559,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFSwab32BitData",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\n_TIFFSwab64BitData(TIFF* tif, uint8* buf, tmsize_t cc)\n{\n    (void) tif;\n    assert((cc & 7) == 0);\n    TIFFSwabArrayOfDouble((double*) buf, cc/8);\n}",
          "fn_code_pos": [
            [
              1561,
              0
            ],
            [
              1567,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFSwab64BitData",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFFillStrip(TIFF* tif, uint32 strip)",
          "fn_dec_pos": [
            [
              34,
              4
            ],
            [
              34,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFillStrip",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFillTile(TIFF* tif, uint32 tile)",
          "fn_dec_pos": [
            [
              35,
              4
            ],
            [
              35,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFillTile",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFStartStrip(TIFF* tif, uint32 strip)",
          "fn_dec_pos": [
            [
              36,
              11
            ],
            [
              36,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFStartStrip",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFStartTile(TIFF* tif, uint32 tile)",
          "fn_dec_pos": [
            [
              37,
              11
            ],
            [
              37,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFStartTile",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFCheckRead(TIFF*, int)",
          "fn_dec_pos": [
            [
              38,
              11
            ],
            [
              38,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCheckRead",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFReadRawStrip1(TIFF* tif, uint32 strip, void* buf, tmsize_t size,const char* module)",
          "fn_dec_pos": [
            [
              40,
              0
            ],
            [
              40,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRawStrip1",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32",
              "buf": "void",
              "size": "tmsize_t",
              "module": "char"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFReadRawTile1(TIFF* tif, uint32 tile, void* buf, tmsize_t size, const char* module)",
          "fn_dec_pos": [
            [
              42,
              0
            ],
            [
              42,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRawTile1",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32",
              "buf": "void",
              "size": "tmsize_t",
              "module": "char"
            },
            "return_type": "tmsize_t"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_jpeg.c": {
      "fn_def_list": [
        {
          "fn_code": "static void\nTIFFjpeg_error_exit(j_common_ptr cinfo)\n{\n\tJPEGState *sp = (JPEGState *) cinfo;\t/* NB: cinfo assumed first */\n\tchar buffer[JMSG_LENGTH_MAX];\n\n\t(*cinfo->err->format_message) (cinfo, buffer);\n\tTIFFErrorExt(sp->tif->tif_clientdata, \"JPEGLib\", \"%s\", buffer);\t\t/* display the error message */\n\tjpeg_abort(cinfo);\t\t\t/* clean up libjpeg state */\n\tLONGJMP(sp->exit_jmpbuf, 1);\t\t/* return to libtiff caller */\n}",
          "fn_code_pos": [
            [
              215,
              0
            ],
            [
              225,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_error_exit",
            "parameters": {
              "cinfo": "j_common_ptr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nTIFFjpeg_output_message(j_common_ptr cinfo)\n{\n\tchar buffer[JMSG_LENGTH_MAX];\n\n\t(*cinfo->err->format_message) (cinfo, buffer);\n\tTIFFWarningExt(((JPEGState *) cinfo)->tif->tif_clientdata, \"JPEGLib\", \"%s\", buffer);\n}",
          "fn_code_pos": [
            [
              232,
              0
            ],
            [
              239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_output_message",
            "parameters": {
              "cinfo": "j_common_ptr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nTIFFjpeg_progress_monitor(j_common_ptr cinfo)\n{\n    JPEGState *sp = (JPEGState *) cinfo;\t/* NB: cinfo assumed first */\n    if (cinfo->is_decompressor)\n    {\n        const int scan_no =\n            ((j_decompress_ptr)cinfo)->input_scan_number;\n        if (scan_no >= sp->max_allowed_scan_number)\n        {\n            TIFFErrorExt(((JPEGState *) cinfo)->tif->tif_clientdata, \n                     \"TIFFjpeg_progress_monitor\",\n                     \"Scan number %d exceeds maximum scans (%d). This limit \"\n                     \"can be raised through the LIBTIFF_JPEG_MAX_ALLOWED_SCAN_NUMBER \"\n                     \"environment variable.\",\n                     scan_no, sp->max_allowed_scan_number);\n\n            jpeg_abort(cinfo);\t\t\t/* clean up libjpeg state */\n            LONGJMP(sp->exit_jmpbuf, 1);\t\t/* return to libtiff caller */\n        }\n    }\n}",
          "fn_code_pos": [
            [
              244,
              0
            ],
            [
              265,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_progress_monitor",
            "parameters": {
              "cinfo": "j_common_ptr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_create_compress(JPEGState* sp)\n{\n\t/* initialize JPEG error handling */\n\tsp->cinfo.c.err = jpeg_std_error(&sp->err);\n\tsp->err.error_exit = TIFFjpeg_error_exit;\n\tsp->err.output_message = TIFFjpeg_output_message;\n\n\t/* set client_data to avoid UMR warning from tools like Purify */\n\tsp->cinfo.c.client_data = NULL;\n\n\treturn CALLVJPEG(sp, jpeg_create_compress(&sp->cinfo.c));\n}",
          "fn_code_pos": [
            [
              277,
              0
            ],
            [
              289,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_create_compress",
            "parameters": {
              "sp": "JPEGState"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_create_decompress(JPEGState* sp)\n{\n\t/* initialize JPEG error handling */\n\tsp->cinfo.d.err = jpeg_std_error(&sp->err);\n\tsp->err.error_exit = TIFFjpeg_error_exit;\n\tsp->err.output_message = TIFFjpeg_output_message;\n\n\t/* set client_data to avoid UMR warning from tools like Purify */\n\tsp->cinfo.d.client_data = NULL;\n\n\treturn CALLVJPEG(sp, jpeg_create_decompress(&sp->cinfo.d));\n}",
          "fn_code_pos": [
            [
              291,
              0
            ],
            [
              303,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_create_decompress",
            "parameters": {
              "sp": "JPEGState"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_set_defaults(JPEGState* sp)\n{\n\treturn CALLVJPEG(sp, jpeg_set_defaults(&sp->cinfo.c));\n}",
          "fn_code_pos": [
            [
              305,
              0
            ],
            [
              309,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_set_defaults",
            "parameters": {
              "sp": "JPEGState"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_set_colorspace(JPEGState* sp, J_COLOR_SPACE colorspace)\n{\n\treturn CALLVJPEG(sp, jpeg_set_colorspace(&sp->cinfo.c, colorspace));\n}",
          "fn_code_pos": [
            [
              311,
              0
            ],
            [
              315,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_set_colorspace",
            "parameters": {
              "sp": "JPEGState",
              "colorspace": "J_COLOR_SPACE"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_set_quality(JPEGState* sp, int quality, boolean force_baseline)\n{\n\treturn CALLVJPEG(sp,\n\t    jpeg_set_quality(&sp->cinfo.c, quality, force_baseline));\n}",
          "fn_code_pos": [
            [
              317,
              0
            ],
            [
              322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_set_quality",
            "parameters": {
              "sp": "JPEGState",
              "quality": "int",
              "force_baseline": "boolean"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_suppress_tables(JPEGState* sp, boolean suppress)\n{\n\treturn CALLVJPEG(sp, jpeg_suppress_tables(&sp->cinfo.c, suppress));\n}",
          "fn_code_pos": [
            [
              324,
              0
            ],
            [
              328,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_suppress_tables",
            "parameters": {
              "sp": "JPEGState",
              "suppress": "boolean"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_start_compress(JPEGState* sp, boolean write_all_tables)\n{\n\treturn CALLVJPEG(sp,\n\t    jpeg_start_compress(&sp->cinfo.c, write_all_tables));\n}",
          "fn_code_pos": [
            [
              330,
              0
            ],
            [
              335,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_start_compress",
            "parameters": {
              "sp": "JPEGState",
              "write_all_tables": "boolean"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_write_scanlines(JPEGState* sp, JSAMPARRAY scanlines, int num_lines)\n{\n\treturn CALLJPEG(sp, -1, (int) jpeg_write_scanlines(&sp->cinfo.c,\n\t    scanlines, (JDIMENSION) num_lines));\n}",
          "fn_code_pos": [
            [
              337,
              0
            ],
            [
              342,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_write_scanlines",
            "parameters": {
              "sp": "JPEGState",
              "scanlines": "JSAMPARRAY",
              "num_lines": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_write_raw_data(JPEGState* sp, JSAMPIMAGE data, int num_lines)\n{\n\treturn CALLJPEG(sp, -1, (int) jpeg_write_raw_data(&sp->cinfo.c,\n\t    data, (JDIMENSION) num_lines));\n}",
          "fn_code_pos": [
            [
              344,
              0
            ],
            [
              349,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_write_raw_data",
            "parameters": {
              "sp": "JPEGState",
              "data": "JSAMPIMAGE",
              "num_lines": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_finish_compress(JPEGState* sp)\n{\n\treturn CALLVJPEG(sp, jpeg_finish_compress(&sp->cinfo.c));\n}",
          "fn_code_pos": [
            [
              351,
              0
            ],
            [
              355,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_finish_compress",
            "parameters": {
              "sp": "JPEGState"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_write_tables(JPEGState* sp)\n{\n\treturn CALLVJPEG(sp, jpeg_write_tables(&sp->cinfo.c));\n}",
          "fn_code_pos": [
            [
              357,
              0
            ],
            [
              361,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_write_tables",
            "parameters": {
              "sp": "JPEGState"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_read_header(JPEGState* sp, boolean require_image)\n{\n\treturn CALLJPEG(sp, -1, jpeg_read_header(&sp->cinfo.d, require_image));\n}",
          "fn_code_pos": [
            [
              363,
              0
            ],
            [
              367,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_read_header",
            "parameters": {
              "sp": "JPEGState",
              "require_image": "boolean"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_has_multiple_scans(JPEGState* sp)\n{\n\treturn CALLJPEG(sp, 0, jpeg_has_multiple_scans(&sp->cinfo.d));\n}",
          "fn_code_pos": [
            [
              369,
              0
            ],
            [
              373,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_has_multiple_scans",
            "parameters": {
              "sp": "JPEGState"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_start_decompress(JPEGState* sp)\n{\n        const char* sz_max_allowed_scan_number;\n        /* progress monitor */\n        sp->cinfo.d.progress = &sp->progress;\n        sp->progress.progress_monitor = TIFFjpeg_progress_monitor;\n        sp->max_allowed_scan_number = 100;\n        sz_max_allowed_scan_number = getenv(\"LIBTIFF_JPEG_MAX_ALLOWED_SCAN_NUMBER\");\n        if( sz_max_allowed_scan_number )\n            sp->max_allowed_scan_number = atoi(sz_max_allowed_scan_number);\n\n\treturn CALLVJPEG(sp, jpeg_start_decompress(&sp->cinfo.d));\n}",
          "fn_code_pos": [
            [
              375,
              0
            ],
            [
              388,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_start_decompress",
            "parameters": {
              "sp": "JPEGState"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_read_scanlines(JPEGState* sp, JSAMPARRAY scanlines, int max_lines)\n{\n\treturn CALLJPEG(sp, -1, (int) jpeg_read_scanlines(&sp->cinfo.d,\n\t    scanlines, (JDIMENSION) max_lines));\n}",
          "fn_code_pos": [
            [
              390,
              0
            ],
            [
              395,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_read_scanlines",
            "parameters": {
              "sp": "JPEGState",
              "scanlines": "JSAMPARRAY",
              "max_lines": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_read_raw_data(JPEGState* sp, JSAMPIMAGE data, int max_lines)\n{\n\treturn CALLJPEG(sp, -1, (int) jpeg_read_raw_data(&sp->cinfo.d,\n\t    data, (JDIMENSION) max_lines));\n}",
          "fn_code_pos": [
            [
              397,
              0
            ],
            [
              402,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_read_raw_data",
            "parameters": {
              "sp": "JPEGState",
              "data": "JSAMPIMAGE",
              "max_lines": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_finish_decompress(JPEGState* sp)\n{\n\treturn CALLJPEG(sp, -1, (int) jpeg_finish_decompress(&sp->cinfo.d));\n}",
          "fn_code_pos": [
            [
              404,
              0
            ],
            [
              408,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_finish_decompress",
            "parameters": {
              "sp": "JPEGState"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_abort(JPEGState* sp)\n{\n\treturn CALLVJPEG(sp, jpeg_abort(&sp->cinfo.comm));\n}",
          "fn_code_pos": [
            [
              410,
              0
            ],
            [
              414,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_abort",
            "parameters": {
              "sp": "JPEGState"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_destroy(JPEGState* sp)\n{\n\treturn CALLVJPEG(sp, jpeg_destroy(&sp->cinfo.comm));\n}",
          "fn_code_pos": [
            [
              416,
              0
            ],
            [
              420,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_destroy",
            "parameters": {
              "sp": "JPEGState"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static JSAMPARRAY\nTIFFjpeg_alloc_sarray(JPEGState* sp, int pool_id,\n\t\t      JDIMENSION samplesperrow, JDIMENSION numrows)\n{\n\treturn CALLJPEG(sp, (JSAMPARRAY) NULL,\n\t    (*sp->cinfo.comm.mem->alloc_sarray)\n\t\t(&sp->cinfo.comm, pool_id, samplesperrow, numrows));\n}",
          "fn_code_pos": [
            [
              422,
              0
            ],
            [
              429,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_alloc_sarray",
            "parameters": {
              "sp": "JPEGState",
              "pool_id": "int",
              "samplesperrow": "JDIMENSION",
              "numrows": "JDIMENSION"
            },
            "return_type": "JSAMPARRAY"
          }
        },
        {
          "fn_code": "static void\nstd_init_destination(j_compress_ptr cinfo)\n{\n\tJPEGState* sp = (JPEGState*) cinfo;\n\tTIFF* tif = sp->tif;\n\n\tsp->dest.next_output_byte = (JOCTET*) tif->tif_rawdata;\n\tsp->dest.free_in_buffer = (size_t) tif->tif_rawdatasize;\n}",
          "fn_code_pos": [
            [
              437,
              0
            ],
            [
              445,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "std_init_destination",
            "parameters": {
              "cinfo": "j_compress_ptr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static boolean\nstd_empty_output_buffer(j_compress_ptr cinfo)\n{\n\tJPEGState* sp = (JPEGState*) cinfo;\n\tTIFF* tif = sp->tif;\n\n\t/* the entire buffer has been filled */\n\ttif->tif_rawcc = tif->tif_rawdatasize;\n\n#ifdef IPPJ_HUFF\n       /*\n        * The Intel IPP performance library does not necessarily fill up\n        * the whole output buffer on each pass, so only dump out the parts\n        * that have been filled.\n        *   http://trac.osgeo.org/gdal/wiki/JpegIPP\n        */\n       if ( sp->dest.free_in_buffer >= 0 ) {\n               tif->tif_rawcc = tif->tif_rawdatasize - sp->dest.free_in_buffer;\n       }\n#endif\n\n\tTIFFFlushData1(tif);\n\tsp->dest.next_output_byte = (JOCTET*) tif->tif_rawdata;\n\tsp->dest.free_in_buffer = (size_t) tif->tif_rawdatasize;\n\n\treturn (TRUE);\n}",
          "fn_code_pos": [
            [
              447,
              0
            ],
            [
              473,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "std_empty_output_buffer",
            "parameters": {
              "cinfo": "j_compress_ptr"
            },
            "return_type": "boolean"
          }
        },
        {
          "fn_code": "static void\nstd_term_destination(j_compress_ptr cinfo)\n{\n\tJPEGState* sp = (JPEGState*) cinfo;\n\tTIFF* tif = sp->tif;\n\n\ttif->tif_rawcp = (uint8*) sp->dest.next_output_byte;\n\ttif->tif_rawcc =\n\t    tif->tif_rawdatasize - (tmsize_t) sp->dest.free_in_buffer;\n\t/* NB: libtiff does the final buffer flush */\n}",
          "fn_code_pos": [
            [
              475,
              0
            ],
            [
              485,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "std_term_destination",
            "parameters": {
              "cinfo": "j_compress_ptr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nTIFFjpeg_data_dest(JPEGState* sp, TIFF* tif)\n{\n\t(void) tif;\n\tsp->cinfo.c.dest = &sp->dest;\n\tsp->dest.init_destination = std_init_destination;\n\tsp->dest.empty_output_buffer = std_empty_output_buffer;\n\tsp->dest.term_destination = std_term_destination;\n}",
          "fn_code_pos": [
            [
              487,
              0
            ],
            [
              495,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_data_dest",
            "parameters": {
              "sp": "JPEGState",
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ntables_init_destination(j_compress_ptr cinfo)\n{\n\tJPEGState* sp = (JPEGState*) cinfo;\n\n\t/* while building, jpegtables_length is allocated buffer size */\n\tsp->dest.next_output_byte = (JOCTET*) sp->jpegtables;\n\tsp->dest.free_in_buffer = (size_t) sp->jpegtables_length;\n}",
          "fn_code_pos": [
            [
              501,
              0
            ],
            [
              509,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tables_init_destination",
            "parameters": {
              "cinfo": "j_compress_ptr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static boolean\ntables_empty_output_buffer(j_compress_ptr cinfo)\n{\n\tJPEGState* sp = (JPEGState*) cinfo;\n\tvoid* newbuf;\n\n\t/* the entire buffer has been filled; enlarge it by 1000 bytes */\n\tnewbuf = _TIFFrealloc((void*) sp->jpegtables,\n\t\t\t      (tmsize_t) (sp->jpegtables_length + 1000));\n\tif (newbuf == NULL)\n\t\tERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 100);\n\tsp->dest.next_output_byte = (JOCTET*) newbuf + sp->jpegtables_length;\n\tsp->dest.free_in_buffer = (size_t) 1000;\n\tsp->jpegtables = newbuf;\n\tsp->jpegtables_length += 1000;\n\treturn (TRUE);\n}",
          "fn_code_pos": [
            [
              511,
              0
            ],
            [
              527,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tables_empty_output_buffer",
            "parameters": {
              "cinfo": "j_compress_ptr"
            },
            "return_type": "boolean"
          }
        },
        {
          "fn_code": "static void\ntables_term_destination(j_compress_ptr cinfo)\n{\n\tJPEGState* sp = (JPEGState*) cinfo;\n\n\t/* set tables length to number of bytes actually emitted */\n\tsp->jpegtables_length -= (uint32) sp->dest.free_in_buffer;\n}",
          "fn_code_pos": [
            [
              529,
              0
            ],
            [
              536,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tables_term_destination",
            "parameters": {
              "cinfo": "j_compress_ptr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nTIFFjpeg_tables_dest(JPEGState* sp, TIFF* tif)\n{\n\t(void) tif;\n\t/*\n\t * Allocate a working buffer for building tables.\n\t * Initial size is 1000 bytes, which is usually adequate.\n\t */\n\tif (sp->jpegtables)\n\t\t_TIFFfree(sp->jpegtables);\n\tsp->jpegtables_length = 1000;\n\tsp->jpegtables = (void*) _TIFFmalloc((tmsize_t) sp->jpegtables_length);\n\tif (sp->jpegtables == NULL) {\n\t\tsp->jpegtables_length = 0;\n\t\tTIFFErrorExt(sp->tif->tif_clientdata, \"TIFFjpeg_tables_dest\", \"No space for JPEGTables\");\n\t\treturn (0);\n\t}\n\tsp->cinfo.c.dest = &sp->dest;\n\tsp->dest.init_destination = tables_init_destination;\n\tsp->dest.empty_output_buffer = tables_empty_output_buffer;\n\tsp->dest.term_destination = tables_term_destination;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              538,
              0
            ],
            [
              560,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_tables_dest",
            "parameters": {
              "sp": "JPEGState",
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nstd_init_source(j_decompress_ptr cinfo)\n{\n\tJPEGState* sp = (JPEGState*) cinfo;\n\tTIFF* tif = sp->tif;\n\n\tsp->src.next_input_byte = (const JOCTET*) tif->tif_rawdata;\n\tsp->src.bytes_in_buffer = (size_t) tif->tif_rawcc;\n}",
          "fn_code_pos": [
            [
              567,
              0
            ],
            [
              575,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "std_init_source",
            "parameters": {
              "cinfo": "j_decompress_ptr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static boolean\nstd_fill_input_buffer(j_decompress_ptr cinfo)\n{\n\tJPEGState* sp = (JPEGState* ) cinfo;\n\tstatic const JOCTET dummy_EOI[2] = { 0xFF, JPEG_EOI };\n\n#ifdef IPPJ_HUFF\n        /*\n         * The Intel IPP performance library does not necessarily read the whole\n         * input buffer in one pass, so it is possible to get here with data\n         * yet to read. \n         * \n         * We just return without doing anything, until the entire buffer has\n         * been read.  \n         * http://trac.osgeo.org/gdal/wiki/JpegIPP\n         */\n        if( sp->src.bytes_in_buffer > 0 ) {\n            return (TRUE);\n        }\n#endif\n\n\t/*\n         * Normally the whole strip/tile is read and so we don't need to do\n         * a fill.  In the case of CHUNKY_STRIP_READ_SUPPORT we might not have\n         * all the data, but the rawdata is refreshed between scanlines and\n         * we push this into the io machinery in JPEGDecode(). \t \n         * http://trac.osgeo.org/gdal/ticket/3894\n\t */\n        \n\tWARNMS(cinfo, JWRN_JPEG_EOF);\n\t/* insert a fake EOI marker */\n\tsp->src.next_input_byte = dummy_EOI;\n\tsp->src.bytes_in_buffer = 2;\n\treturn (TRUE);\n}",
          "fn_code_pos": [
            [
              577,
              0
            ],
            [
              611,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "std_fill_input_buffer",
            "parameters": {
              "cinfo": "j_decompress_ptr"
            },
            "return_type": "boolean"
          }
        },
        {
          "fn_code": "static void\nstd_skip_input_data(j_decompress_ptr cinfo, long num_bytes)\n{\n\tJPEGState* sp = (JPEGState*) cinfo;\n\n\tif (num_bytes > 0) {\n\t\tif ((size_t)num_bytes > sp->src.bytes_in_buffer) {\n\t\t\t/* oops, buffer overrun */\n\t\t\t(void) std_fill_input_buffer(cinfo);\n\t\t} else {\n\t\t\tsp->src.next_input_byte += (size_t) num_bytes;\n\t\t\tsp->src.bytes_in_buffer -= (size_t) num_bytes;\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              613,
              0
            ],
            [
              627,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "std_skip_input_data",
            "parameters": {
              "cinfo": "j_decompress_ptr",
              "num_bytes": "long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nstd_term_source(j_decompress_ptr cinfo)\n{\n\t/* No work necessary here */\n\t(void) cinfo;\n}",
          "fn_code_pos": [
            [
              629,
              0
            ],
            [
              634,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "std_term_source",
            "parameters": {
              "cinfo": "j_decompress_ptr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nTIFFjpeg_data_src(JPEGState* sp)\n{\n\tsp->cinfo.d.src = &sp->src;\n\tsp->src.init_source = std_init_source;\n\tsp->src.fill_input_buffer = std_fill_input_buffer;\n\tsp->src.skip_input_data = std_skip_input_data;\n\tsp->src.resync_to_restart = jpeg_resync_to_restart;\n\tsp->src.term_source = std_term_source;\n\tsp->src.bytes_in_buffer = 0;\t\t/* for safety */\n\tsp->src.next_input_byte = NULL;\n}",
          "fn_code_pos": [
            [
              636,
              0
            ],
            [
              647,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_data_src",
            "parameters": {
              "sp": "JPEGState"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ntables_init_source(j_decompress_ptr cinfo)\n{\n\tJPEGState* sp = (JPEGState*) cinfo;\n\n\tsp->src.next_input_byte = (const JOCTET*) sp->jpegtables;\n\tsp->src.bytes_in_buffer = (size_t) sp->jpegtables_length;\n}",
          "fn_code_pos": [
            [
              654,
              0
            ],
            [
              661,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tables_init_source",
            "parameters": {
              "cinfo": "j_decompress_ptr"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nTIFFjpeg_tables_src(JPEGState* sp)\n{\n\tTIFFjpeg_data_src(sp);\n\tsp->src.init_source = tables_init_source;\n}",
          "fn_code_pos": [
            [
              663,
              0
            ],
            [
              668,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFjpeg_tables_src",
            "parameters": {
              "sp": "JPEGState"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nalloc_downsampled_buffers(TIFF* tif, jpeg_component_info* comp_info,\n\t\t\t  int num_components)\n{\n\tJPEGState* sp = JState(tif);\n\tint ci;\n\tjpeg_component_info* compptr;\n\tJSAMPARRAY buf;\n\tint samples_per_clump = 0;\n\n\tfor (ci = 0, compptr = comp_info; ci < num_components;\n\t     ci++, compptr++) {\n\t\tsamples_per_clump += compptr->h_samp_factor *\n\t\t\tcompptr->v_samp_factor;\n\t\tbuf = TIFFjpeg_alloc_sarray(sp, JPOOL_IMAGE,\n\t\t\t\tcompptr->width_in_blocks * DCTSIZE,\n\t\t\t\t(JDIMENSION) (compptr->v_samp_factor*DCTSIZE));\n\t\tif (buf == NULL)\n\t\t\treturn (0);\n\t\tsp->ds_buffer[ci] = buf;\n\t}\n\tsp->samplesperclump = samples_per_clump;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              677,
              0
            ],
            [
              700,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "alloc_downsampled_buffers",
            "parameters": {
              "tif": "TIFF",
              "comp_info": "jpeg_component_info",
              "num_components": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nJPEGFixupTags(TIFF* tif)\n{\n#ifdef CHECK_JPEG_YCBCR_SUBSAMPLING\n        JPEGState* sp = JState(tif);\n\tif ((tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)&&\n\t    (tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&\n\t    (tif->tif_dir.td_samplesperpixel==3) &&\n            !sp->ycbcrsampling_fetched)\n\t\tJPEGFixupTagsSubsampling(tif);\n#endif\n        \n\treturn(1);\n}",
          "fn_code_pos": [
            [
              740,
              0
            ],
            [
              753,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGFixupTags",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nJPEGFixupTagsSubsampling(TIFF* tif)\n{\n\t/*\n\t * Some JPEG-in-TIFF produces do not emit the YCBCRSUBSAMPLING values in\n\t * the TIFF tags, but still use non-default (2,2) values within the jpeg\n\t * data stream itself.  In order for TIFF applications to work properly\n\t * - for instance to get the strip buffer size right - it is imperative\n\t * that the subsampling be available before we start reading the image\n\t * data normally.  This function will attempt to analyze the first strip in\n\t * order to get the sampling values from the jpeg data stream.\n\t *\n\t * Note that JPEGPreDeocode() will produce a fairly loud warning when the\n\t * discovered sampling does not match the default sampling (2,2) or whatever\n\t * was actually in the tiff tags.\n\t *\n\t * See the bug in bugzilla for details:\n\t *\n\t * http://bugzilla.remotesensing.org/show_bug.cgi?id=168\n\t *\n\t * Frank Warmerdam, July 2002\n\t * Joris Van Damme, May 2007\n\t */\n\tstatic const char module[] = \"JPEGFixupTagsSubsampling\";\n\tstruct JPEGFixupTagsSubsamplingData m;\n\n        _TIFFFillStriles( tif );\n        \n        if( tif->tif_dir.td_stripbytecount == NULL\n            || tif->tif_dir.td_stripoffset == NULL\n            || tif->tif_dir.td_stripbytecount[0] == 0 )\n        {\n            /* Do not even try to check if the first strip/tile does not\n               yet exist, as occurs when GDAL has created a new NULL file\n               for instance. */\n            return;\n        }\n\n\tm.tif=tif;\n\tm.buffersize=2048;\n\tm.buffer=_TIFFmalloc(m.buffersize);\n\tif (m.buffer==NULL)\n\t{\n\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t    \"Unable to allocate memory for auto-correcting of subsampling values; auto-correcting skipped\");\n\t\treturn;\n\t}\n\tm.buffercurrentbyte=NULL;\n\tm.bufferbytesleft=0;\n\tm.fileoffset=tif->tif_dir.td_stripoffset[0];\n\tm.filepositioned=0;\n\tm.filebytesleft=tif->tif_dir.td_stripbytecount[0];\n\tif (!JPEGFixupTagsSubsamplingSec(&m))\n\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t    \"Unable to auto-correct subsampling values, likely corrupt JPEG compressed data in first strip/tile; auto-correcting skipped\");\n\t_TIFFfree(m.buffer);\n}",
          "fn_code_pos": [
            [
              757,
              0
            ],
            [
              813,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGFixupTagsSubsampling",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nJPEGFixupTagsSubsamplingSec(struct JPEGFixupTagsSubsamplingData* data)\n{\n\tstatic const char module[] = \"JPEGFixupTagsSubsamplingSec\";\n\tuint8 m;\n\twhile (1)\n\t{\n\t\twhile (1)\n\t\t{\n\t\t\tif (!JPEGFixupTagsSubsamplingReadByte(data,&m))\n\t\t\t\treturn(0);\n\t\t\tif (m==255)\n\t\t\t\tbreak;\n\t\t}\n\t\twhile (1)\n\t\t{\n\t\t\tif (!JPEGFixupTagsSubsamplingReadByte(data,&m))\n\t\t\t\treturn(0);\n\t\t\tif (m!=255)\n\t\t\t\tbreak;\n\t\t}\n\t\tswitch (m)\n\t\t{\n\t\t\tcase JPEG_MARKER_SOI:\n\t\t\t\t/* this type of marker has no data and should be skipped */\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_COM:\n\t\t\tcase JPEG_MARKER_APP0:\n\t\t\tcase JPEG_MARKER_APP0+1:\n\t\t\tcase JPEG_MARKER_APP0+2:\n\t\t\tcase JPEG_MARKER_APP0+3:\n\t\t\tcase JPEG_MARKER_APP0+4:\n\t\t\tcase JPEG_MARKER_APP0+5:\n\t\t\tcase JPEG_MARKER_APP0+6:\n\t\t\tcase JPEG_MARKER_APP0+7:\n\t\t\tcase JPEG_MARKER_APP0+8:\n\t\t\tcase JPEG_MARKER_APP0+9:\n\t\t\tcase JPEG_MARKER_APP0+10:\n\t\t\tcase JPEG_MARKER_APP0+11:\n\t\t\tcase JPEG_MARKER_APP0+12:\n\t\t\tcase JPEG_MARKER_APP0+13:\n\t\t\tcase JPEG_MARKER_APP0+14:\n\t\t\tcase JPEG_MARKER_APP0+15:\n\t\t\tcase JPEG_MARKER_DQT:\n\t\t\tcase JPEG_MARKER_SOS:\n\t\t\tcase JPEG_MARKER_DHT:\n\t\t\tcase JPEG_MARKER_DRI:\n\t\t\t\t/* this type of marker has data, but it has no use to us and should be skipped */\n\t\t\t\t{\n\t\t\t\t\tuint16 n;\n\t\t\t\t\tif (!JPEGFixupTagsSubsamplingReadWord(data,&n))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\tif (n<2)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\tn-=2;\n\t\t\t\t\tif (n>0)\n\t\t\t\t\t\tJPEGFixupTagsSubsamplingSkip(data,n);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_SOF0: /* Baseline sequential Huffman */\n\t\t\tcase JPEG_MARKER_SOF1: /* Extended sequential Huffman */\n\t\t\tcase JPEG_MARKER_SOF2: /* Progressive Huffman: normally not allowed by TechNote, but that doesn't hurt supporting it */\n\t\t\tcase JPEG_MARKER_SOF9: /* Extended sequential arithmetic */\n\t\t\tcase JPEG_MARKER_SOF10: /* Progressive arithmetic: normally not allowed by TechNote, but that doesn't hurt supporting it */\n\t\t\t\t/* this marker contains the subsampling factors we're scanning for */\n\t\t\t\t{\n\t\t\t\t\tuint16 n;\n\t\t\t\t\tuint16 o;\n\t\t\t\t\tuint8 p;\n\t\t\t\t\tuint8 ph,pv;\n\t\t\t\t\tif (!JPEGFixupTagsSubsamplingReadWord(data,&n))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\tif (n!=8+data->tif->tif_dir.td_samplesperpixel*3)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\tJPEGFixupTagsSubsamplingSkip(data,7);\n\t\t\t\t\tif (!JPEGFixupTagsSubsamplingReadByte(data,&p))\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\tph=(p>>4);\n\t\t\t\t\tpv=(p&15);\n\t\t\t\t\tJPEGFixupTagsSubsamplingSkip(data,1);\n\t\t\t\t\tfor (o=1; o<data->tif->tif_dir.td_samplesperpixel; o++)\n\t\t\t\t\t{\n\t\t\t\t\t\tJPEGFixupTagsSubsamplingSkip(data,1);\n\t\t\t\t\t\tif (!JPEGFixupTagsSubsamplingReadByte(data,&p))\n\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t\tif (p!=0x11)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTIFFWarningExt(data->tif->tif_clientdata,module,\n\t\t\t\t\t\t\t    \"Subsampling values inside JPEG compressed data have no TIFF equivalent, auto-correction of TIFF subsampling values failed\");\n\t\t\t\t\t\t\treturn(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJPEGFixupTagsSubsamplingSkip(data,1);\n\t\t\t\t\t}\n\t\t\t\t\tif (((ph!=1)&&(ph!=2)&&(ph!=4))||((pv!=1)&&(pv!=2)&&(pv!=4)))\n\t\t\t\t\t{\n\t\t\t\t\t\tTIFFWarningExt(data->tif->tif_clientdata,module,\n\t\t\t\t\t\t    \"Subsampling values inside JPEG compressed data have no TIFF equivalent, auto-correction of TIFF subsampling values failed\");\n\t\t\t\t\t\treturn(1);\n\t\t\t\t\t}\n\t\t\t\t\tif ((ph!=data->tif->tif_dir.td_ycbcrsubsampling[0])||(pv!=data->tif->tif_dir.td_ycbcrsubsampling[1]))\n\t\t\t\t\t{\n\t\t\t\t\t\tTIFFWarningExt(data->tif->tif_clientdata,module,\n\t\t\t\t\t\t    \"Auto-corrected former TIFF subsampling values [%d,%d] to match subsampling values inside JPEG compressed data [%d,%d]\",\n\t\t\t\t\t\t    (int)data->tif->tif_dir.td_ycbcrsubsampling[0],\n\t\t\t\t\t\t    (int)data->tif->tif_dir.td_ycbcrsubsampling[1],\n\t\t\t\t\t\t    (int)ph,(int)pv);\n\t\t\t\t\t\tdata->tif->tif_dir.td_ycbcrsubsampling[0]=ph;\n\t\t\t\t\t\tdata->tif->tif_dir.td_ycbcrsubsampling[1]=pv;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn(1);\n\t\t\tdefault:\n\t\t\t\treturn(0);\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              815,
              0
            ],
            [
              930,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGFixupTagsSubsamplingSec",
            "parameters": {
              "data": "struct JPEGFixupTagsSubsamplingData"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nJPEGFixupTagsSubsamplingReadByte(struct JPEGFixupTagsSubsamplingData* data, uint8* result)\n{\n\tif (data->bufferbytesleft==0)\n\t{\n\t\tuint32 m;\n\t\tif (data->filebytesleft==0)\n\t\t\treturn(0);\n\t\tif (!data->filepositioned)\n\t\t{\n\t\t\tTIFFSeekFile(data->tif,data->fileoffset,SEEK_SET);\n\t\t\tdata->filepositioned=1;\n\t\t}\n\t\tm=data->buffersize;\n\t\tif ((uint64)m>data->filebytesleft)\n\t\t\tm=(uint32)data->filebytesleft;\n\t\tassert(m<0x80000000UL);\n\t\tif (TIFFReadFile(data->tif,data->buffer,(tmsize_t)m)!=(tmsize_t)m)\n\t\t\treturn(0);\n\t\tdata->buffercurrentbyte=data->buffer;\n\t\tdata->bufferbytesleft=m;\n\t\tdata->fileoffset+=m;\n\t\tdata->filebytesleft-=m;\n\t}\n\t*result=*data->buffercurrentbyte;\n\tdata->buffercurrentbyte++;\n\tdata->bufferbytesleft--;\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              932,
              0
            ],
            [
              960,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGFixupTagsSubsamplingReadByte",
            "parameters": {
              "data": "struct JPEGFixupTagsSubsamplingData",
              "result": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nJPEGFixupTagsSubsamplingReadWord(struct JPEGFixupTagsSubsamplingData* data, uint16* result)\n{\n\tuint8 ma;\n\tuint8 mb;\n\tif (!JPEGFixupTagsSubsamplingReadByte(data,&ma))\n\t\treturn(0);\n\tif (!JPEGFixupTagsSubsamplingReadByte(data,&mb))\n\t\treturn(0);\n\t*result=(ma<<8)|mb;\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              962,
              0
            ],
            [
              973,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGFixupTagsSubsamplingReadWord",
            "parameters": {
              "data": "struct JPEGFixupTagsSubsamplingData",
              "result": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nJPEGFixupTagsSubsamplingSkip(struct JPEGFixupTagsSubsamplingData* data, uint16 skiplength)\n{\n\tif ((uint32)skiplength<=data->bufferbytesleft)\n\t{\n\t\tdata->buffercurrentbyte+=skiplength;\n\t\tdata->bufferbytesleft-=skiplength;\n\t}\n\telse\n\t{\n\t\tuint16 m;\n\t\tm=(uint16)(skiplength-data->bufferbytesleft);\n\t\tif (m<=data->filebytesleft)\n\t\t{\n\t\t\tdata->bufferbytesleft=0;\n\t\t\tdata->fileoffset+=m;\n\t\t\tdata->filebytesleft-=m;\n\t\t\tdata->filepositioned=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdata->bufferbytesleft=0;\n\t\t\tdata->filebytesleft=0;\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              975,
              0
            ],
            [
              1000,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGFixupTagsSubsamplingSkip",
            "parameters": {
              "data": "struct JPEGFixupTagsSubsamplingData",
              "skiplength": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nJPEGSetupDecode(TIFF* tif)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\n#if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG)\n        if( tif->tif_dir.td_bitspersample == 12 )\n            return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 0 );\n#endif\n\n\tJPEGInitializeLibJPEG( tif, TRUE );\n\n\tassert(sp != NULL);\n\tassert(sp->cinfo.comm.is_decompressor);\n\n\t/* Read JPEGTables if it is present */\n\tif (TIFFFieldSet(tif,FIELD_JPEGTABLES)) {\n\t\tTIFFjpeg_tables_src(sp);\n\t\tif(TIFFjpeg_read_header(sp,FALSE) != JPEG_HEADER_TABLES_ONLY) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, \"JPEGSetupDecode\", \"Bogus JPEGTables field\");\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* Grab parameters that are same for all strips/tiles */\n\tsp->photometric = td->td_photometric;\n\tswitch (sp->photometric) {\n\tcase PHOTOMETRIC_YCBCR:\n\t\tsp->h_sampling = td->td_ycbcrsubsampling[0];\n\t\tsp->v_sampling = td->td_ycbcrsubsampling[1];\n\t\tbreak;\n\tdefault:\n\t\t/* TIFF 6.0 forbids subsampling of all other color spaces */\n\t\tsp->h_sampling = 1;\n\t\tsp->v_sampling = 1;\n\t\tbreak;\n\t}\n\n\t/* Set up for reading normal data */\n\tTIFFjpeg_data_src(sp);\n\ttif->tif_postdecode = _TIFFNoPostDecode; /* override byte swapping */\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1005,
              0
            ],
            [
              1048,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGSetupDecode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int TIFFJPEGIsFullStripRequired(TIFF* tif)\n{\n    int ret;\n    JPEGState state;\n\n#if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFJPEGIsFullStripRequired)\n    if( tif->tif_dir.td_bitspersample == 12 )\n        return TIFFJPEGIsFullStripRequired_12( tif );\n#endif\n\n    memset(&state, 0, sizeof(JPEGState));\n    state.tif = tif;\n\n    TIFFjpeg_create_decompress(&state);\n\n    TIFFjpeg_data_src(&state);\n\n    if (TIFFjpeg_read_header(&state, TRUE) != JPEG_HEADER_OK)\n    {\n        TIFFjpeg_destroy(&state);\n        return (0);\n    }\n    ret = TIFFjpeg_has_multiple_scans(&state);\n\n    TIFFjpeg_destroy(&state);\n\n    return ret;\n}",
          "fn_code_pos": [
            [
              1057,
              0
            ],
            [
              1084,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFJPEGIsFullStripRequired",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nJPEGPreDecode(TIFF* tif, uint16 s)\n{\n\tJPEGState *sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\tstatic const char module[] = \"JPEGPreDecode\";\n\tuint32 segment_width, segment_height;\n\tint downsampled_output;\n\tint ci;\n\n\tassert(sp != NULL);\n  \n\tif (sp->cinfo.comm.is_decompressor == 0)\n\t{\n\t\ttif->tif_setupdecode( tif );\n\t}\n  \n\tassert(sp->cinfo.comm.is_decompressor);\n\t/*\n\t * Reset decoder state from any previous strip/tile,\n\t * in case application didn't read the whole strip.\n\t */\n\tif (!TIFFjpeg_abort(sp))\n\t\treturn (0);\n\t/*\n\t * Read the header for this strip/tile.\n\t */\n        \n\tif (TIFFjpeg_read_header(sp, TRUE) != JPEG_HEADER_OK)\n\t\treturn (0);\n\n        tif->tif_rawcp = (uint8*) sp->src.next_input_byte;\n        tif->tif_rawcc = sp->src.bytes_in_buffer;\n\n\t/*\n\t * Check image parameters and set decompression parameters.\n\t */\n\tif (isTiled(tif)) {\n                segment_width = td->td_tilewidth;\n                segment_height = td->td_tilelength;\n\t\tsp->bytesperline = TIFFTileRowSize(tif);\n\t} else {\n\t\tsegment_width = td->td_imagewidth;\n\t\tsegment_height = td->td_imagelength - tif->tif_row;\n\t\tif (segment_height > td->td_rowsperstrip)\n\t\t\tsegment_height = td->td_rowsperstrip;\n\t\tsp->bytesperline = TIFFScanlineSize(tif);\n\t}\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE && s > 0) {\n\t\t/*\n\t\t * For PC 2, scale down the expected strip/tile size\n\t\t * to match a downsampled component\n\t\t */\n\t\tsegment_width = TIFFhowmany_32(segment_width, sp->h_sampling);\n\t\tsegment_height = TIFFhowmany_32(segment_height, sp->v_sampling);\n\t}\n\tif (sp->cinfo.d.image_width < segment_width ||\n\t    sp->cinfo.d.image_height < segment_height) {\n\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t       \"Improper JPEG strip/tile size, \"\n\t\t\t       \"expected %dx%d, got %dx%d\",\n\t\t\t       segment_width, segment_height,\n\t\t\t       sp->cinfo.d.image_width,\n\t\t\t       sp->cinfo.d.image_height);\n\t}\n\tif( sp->cinfo.d.image_width == segment_width &&\n\t    sp->cinfo.d.image_height > segment_height &&\n\t    tif->tif_row + segment_height == td->td_imagelength &&\n\t    !isTiled(tif) ) {\n\t\t/* Some files have a last strip, that should be truncated, */\n\t\t/* but their JPEG codestream has still the maximum strip */\n\t\t/* height. Warn about this as this is non compliant, but */\n\t\t/* we can safely recover from that. */\n\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t     \"JPEG strip size exceeds expected dimensions,\"\n\t\t\t     \" expected %dx%d, got %dx%d\",\n\t\t\t     segment_width, segment_height,\n\t\t\t     sp->cinfo.d.image_width, sp->cinfo.d.image_height);\n\t}\n\telse if (sp->cinfo.d.image_width > segment_width ||\n\t\t sp->cinfo.d.image_height > segment_height) {\n\t\t/*\n\t\t * This case could be dangerous, if the strip or tile size has\n\t\t * been reported as less than the amount of data jpeg will\n\t\t * return, some potential security issues arise. Catch this\n\t\t * case and error out.\n\t\t */\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"JPEG strip/tile size exceeds expected dimensions,\"\n\t\t\t     \" expected %dx%d, got %dx%d\",\n\t\t\t     segment_width, segment_height,\n\t\t\t     sp->cinfo.d.image_width, sp->cinfo.d.image_height);\n\t\treturn (0);\n\t}\n\tif (sp->cinfo.d.num_components !=\n\t    (td->td_planarconfig == PLANARCONFIG_CONTIG ?\n\t     td->td_samplesperpixel : 1)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Improper JPEG component count\");\n\t\treturn (0);\n\t}",
          "fn_code_pos": [
            [
              1089,
              13
            ],
            [
              1188,
              2
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGPreDecode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n{\n\tJPEGState *sp = JState(tif);\n\ttmsize_t nrows;\n\t(void) s;\n\n        /*\n        ** Update available information, buffer may have been refilled\n        ** between decode requests\n        */\n\tsp->src.next_input_byte = (const JOCTET*) tif->tif_rawcp;\n\tsp->src.bytes_in_buffer = (size_t) tif->tif_rawcc;\n\n        if( sp->bytesperline == 0 )\n                return 0;\n        \n\tnrows = cc / sp->bytesperline;\n\tif (cc % sp->bytesperline)\n\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n                               \"fractional scanline not read\");\n\n\tif( nrows > (tmsize_t) sp->cinfo.d.image_height )\n\t\tnrows = sp->cinfo.d.image_height;\n\n\t/* data is expected to be read in multiples of a scanline */\n\tif (nrows)\n        {\n                do\n                {\n                        /*\n                         * In the libjpeg6b-9a 8bit case.  We read directly into\n                         * the TIFF buffer.\n                         */\n                        JSAMPROW bufptr = (JSAMPROW)buf;\n\n                        if (TIFFjpeg_read_scanlines(sp, &bufptr, 1) != 1)\n                                return (0);\n\n                        ++tif->tif_row;\n                        buf += sp->bytesperline;\n                        cc -= sp->bytesperline;\n                } while (--nrows > 0);\n        }\n\n        /* Update information on consumed data */\n        tif->tif_rawcp = (uint8*) sp->src.next_input_byte;\n        tif->tif_rawcc = sp->src.bytes_in_buffer;\n                \n\t/* Close down the decompressor if we've finished the strip or tile. */\n\treturn sp->cinfo.d.output_scanline < sp->cinfo.d.output_height\n                || TIFFjpeg_finish_decompress(sp);\n}",
          "fn_code_pos": [
            [
              1321,
              0
            ],
            [
              1373,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGDecode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n{\n\tJPEGState *sp = JState(tif);\n\ttmsize_t nrows;\n\t(void) s;\n\n        /*\n        ** Update available information, buffer may have been refilled\n        ** between decode requests\n        */\n\tsp->src.next_input_byte = (const JOCTET*) tif->tif_rawcp;\n\tsp->src.bytes_in_buffer = (size_t) tif->tif_rawcc;\n\n        if( sp->bytesperline == 0 )\n                return 0;\n        \n\tnrows = cc / sp->bytesperline;\n\tif (cc % sp->bytesperline)\n\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n                               \"fractional scanline not read\");\n\n\tif( nrows > (tmsize_t) sp->cinfo.d.image_height )\n\t\tnrows = sp->cinfo.d.image_height;\n\n\t/* data is expected to be read in multiples of a scanline */\n\tif (nrows)\n        {\n                JSAMPROW line_work_buf = NULL;\n\n                /*\n                 * For 6B, only use temporary buffer for 12 bit imagery.\n                 * For Mk1 always use it.\n                 */\n                if( sp->cinfo.d.data_precision == 12 )\n                {\n                        line_work_buf = (JSAMPROW)\n                                _TIFFmalloc(sizeof(short) * sp->cinfo.d.output_width\n                                            * sp->cinfo.d.num_components );\n                }\n\n               do\n               {\n                       if( line_work_buf != NULL )\n                       {\n                               /*\n                                * In the MK1 case, we always read into a 16bit\n                                * buffer, and then pack down to 12bit or 8bit.\n                                * In 6B case we only read into 16 bit buffer\n                                * for 12bit data, which we need to repack.\n                                */\n                               if (TIFFjpeg_read_scanlines(sp, &line_work_buf, 1) != 1)\n                                       return (0);\n\n                               if( sp->cinfo.d.data_precision == 12 )\n                               {\n                                       int value_pairs = (sp->cinfo.d.output_width\n                                                          * sp->cinfo.d.num_components) / 2;\n                                       int iPair;\n\n                                       for( iPair = 0; iPair < value_pairs; iPair++ )\n                                       {\n                                               unsigned char *out_ptr =\n                                                       ((unsigned char *) buf) + iPair * 3;\n                                               JSAMPLE *in_ptr = line_work_buf + iPair * 2;\n\n                                               out_ptr[0] = (unsigned char)((in_ptr[0] & 0xff0) >> 4);\n                                               out_ptr[1] = (unsigned char)(((in_ptr[0] & 0xf) << 4)\n                                                       | ((in_ptr[1] & 0xf00) >> 8));\n                                               out_ptr[2] = (unsigned char)(((in_ptr[1] & 0xff) >> 0));\n                                       }\n                               }\n                               else if( sp->cinfo.d.data_precision == 8 )\n                               {\n                                       int value_count = (sp->cinfo.d.output_width\n                                                          * sp->cinfo.d.num_components);\n                                       int iValue;\n\n                                       for( iValue = 0; iValue < value_count; iValue++ )\n                                       {\n                                               ((unsigned char *) buf)[iValue] =\n                                                       line_work_buf[iValue] & 0xff;\n                                       }\n                               }\n                       }\n\n                       ++tif->tif_row;\n                       buf += sp->bytesperline;\n                       cc -= sp->bytesperline;\n               } while (--nrows > 0);\n\n               if( line_work_buf != NULL )\n                       _TIFFfree( line_work_buf );\n        }\n\n        /* Update information on consumed data */\n        tif->tif_rawcp = (uint8*) sp->src.next_input_byte;\n        tif->tif_rawcc = sp->src.bytes_in_buffer;\n                \n\t/* Close down the decompressor if we've finished the strip or tile. */\n\treturn sp->cinfo.d.output_scanline < sp->cinfo.d.output_height\n                || TIFFjpeg_finish_decompress(sp);\n}",
          "fn_code_pos": [
            [
              1377,
              13
            ],
            [
              1479,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGDecode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nDecodeRowError(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n\n{\n    (void) buf;\n    (void) cc;\n    (void) s;\n\n    TIFFErrorExt(tif->tif_clientdata, \"TIFFReadScanline\",\n                 \"scanline oriented access is not supported for downsampled JPEG compressed images, consider enabling TIFF_JPEGCOLORMODE as JPEGCOLORMODE_RGB.\" );\n    return 0;\n}",
          "fn_code_pos": [
            [
              1482,
              13
            ],
            [
              1493,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecodeRowError",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n{\n\tJPEGState *sp = JState(tif);\n\ttmsize_t nrows;\n        TIFFDirectory *td = &tif->tif_dir;\n\t(void) s;\n\n        nrows = sp->cinfo.d.image_height;\n        /* For last strip, limit number of rows to its truncated height */\n        /* even if the codestream height is larger (which is not compliant, */\n        /* but that we tolerate) */\n        if( (uint32)nrows > td->td_imagelength - tif->tif_row && !isTiled(tif) )\n            nrows = td->td_imagelength - tif->tif_row;\n\n\t/* data is expected to be read in multiples of a scanline */\n\tif ( nrows != 0 ) {\n\n\t\t/* Cb,Cr both have sampling factors 1, so this is correct */\n\t\tJDIMENSION clumps_per_line = sp->cinfo.d.comp_info[1].downsampled_width;            \n\t\tint samples_per_clump = sp->samplesperclump;\n\n#if defined(JPEG_LIB_MK1_OR_12BIT)\n\t\tunsigned short* tmpbuf = _TIFFmalloc(sizeof(unsigned short) *\n\t\t\t\t\t\t     sp->cinfo.d.output_width *\n\t\t\t\t\t\t     sp->cinfo.d.num_components);\n\t\tif(tmpbuf==NULL) {\n                        TIFFErrorExt(tif->tif_clientdata, \"JPEGDecodeRaw\",\n\t\t\t\t     \"Out of memory\");\n\t\t\treturn 0;\n                }\n#endif\n\n\t\tdo {\n\t\t\tjpeg_component_info *compptr;\n\t\t\tint ci, clumpoffset;\n\n                        if( cc < sp->bytesperline ) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, \"JPEGDecodeRaw\",\n\t\t\t\t\t     \"application buffer not large enough for all data.\");\n\t\t\t\treturn 0;\n                        }\n\n\t\t\t/* Reload downsampled-data buffer if needed */\n\t\t\tif (sp->scancount >= DCTSIZE) {\n\t\t\t\tint n = sp->cinfo.d.max_v_samp_factor * DCTSIZE;\n\t\t\t\tif (TIFFjpeg_read_raw_data(sp, sp->ds_buffer, n) != n)\n\t\t\t\t\treturn (0);\n\t\t\t\tsp->scancount = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Fastest way to unseparate data is to make one pass\n\t\t\t * over the scanline for each row of each component.\n\t\t\t */\n\t\t\tclumpoffset = 0;    /* first sample in clump */\n\t\t\tfor (ci = 0, compptr = sp->cinfo.d.comp_info;\n\t\t\t     ci < sp->cinfo.d.num_components;\n\t\t\t     ci++, compptr++) {\n\t\t\t\tint hsamp = compptr->h_samp_factor;\n\t\t\t\tint vsamp = compptr->v_samp_factor;\n\t\t\t\tint ypos;\n\n\t\t\t\tfor (ypos = 0; ypos < vsamp; ypos++) {\n\t\t\t\t\tJSAMPLE *inptr = sp->ds_buffer[ci][sp->scancount*vsamp + ypos];\n\t\t\t\t\tJDIMENSION nclump;\n#if defined(JPEG_LIB_MK1_OR_12BIT)\n\t\t\t\t\tJSAMPLE *outptr = (JSAMPLE*)tmpbuf + clumpoffset;\n#else\n\t\t\t\t\tJSAMPLE *outptr = (JSAMPLE*)buf + clumpoffset;\n\t\t\t\t\tif (cc < (tmsize_t) (clumpoffset + samples_per_clump*(clumps_per_line-1) + hsamp)) {\n\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, \"JPEGDecodeRaw\",\n\t\t\t\t\t\t\t     \"application buffer not large enough for all data, possible subsampling issue\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n#endif\n\n\t\t\t\t\tif (hsamp == 1) {\n\t\t\t\t\t\t/* fast path for at least Cb and Cr */\n\t\t\t\t\t\tfor (nclump = clumps_per_line; nclump-- > 0; ) {\n\t\t\t\t\t\t\toutptr[0] = *inptr++;\n\t\t\t\t\t\t\toutptr += samples_per_clump;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint xpos;\n\n\t\t\t\t\t\t/* general case */\n\t\t\t\t\t\tfor (nclump = clumps_per_line; nclump-- > 0; ) {\n\t\t\t\t\t\t\tfor (xpos = 0; xpos < hsamp; xpos++)\n\t\t\t\t\t\t\t\toutptr[xpos] = *inptr++;\n\t\t\t\t\t\t\toutptr += samples_per_clump;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tclumpoffset += hsamp;\n\t\t\t\t}\n\t\t\t}\n\n#if defined(JPEG_LIB_MK1_OR_12BIT)\n\t\t\t{\n\t\t\t\tif (sp->cinfo.d.data_precision == 8)\n\t\t\t\t{\n\t\t\t\t\tint i=0;\n\t\t\t\t\tint len = sp->cinfo.d.output_width * sp->cinfo.d.num_components;\n\t\t\t\t\tfor (i=0; i<len; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t((unsigned char*)buf)[i] = tmpbuf[i] & 0xff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{         /* 12-bit */\n\t\t\t\t\tint value_pairs = (sp->cinfo.d.output_width\n\t\t\t\t\t\t\t   * sp->cinfo.d.num_components) / 2;\n\t\t\t\t\tint iPair;\n\t\t\t\t\tfor( iPair = 0; iPair < value_pairs; iPair++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned char *out_ptr = ((unsigned char *) buf) + iPair * 3;\n\t\t\t\t\t\tJSAMPLE *in_ptr = (JSAMPLE *) (tmpbuf + iPair * 2);\n\t\t\t\t\t\tout_ptr[0] = (unsigned char)((in_ptr[0] & 0xff0) >> 4);\n\t\t\t\t\t\tout_ptr[1] = (unsigned char)(((in_ptr[0] & 0xf) << 4)\n\t\t\t\t\t\t\t| ((in_ptr[1] & 0xf00) >> 8));\n\t\t\t\t\t\tout_ptr[2] = (unsigned char)(((in_ptr[1] & 0xff) >> 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\n\t\t\tsp->scancount ++;\n\t\t\ttif->tif_row += sp->v_sampling;\n\n\t\t\tbuf += sp->bytesperline;\n\t\t\tcc -= sp->bytesperline;\n\n\t\t\tnrows -= sp->v_sampling;\n\t\t} while (nrows > 0);\n\n#if defined(JPEG_LIB_MK1_OR_12BIT)\n\t\t_TIFFfree(tmpbuf);\n#endif\n\n\t}\n\n\t/* Close down the decompressor if done. */\n\treturn sp->cinfo.d.output_scanline < sp->cinfo.d.output_height\n\t\t|| TIFFjpeg_finish_decompress(sp);\n}",
          "fn_code_pos": [
            [
              1499,
              13
            ],
            [
              1642,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGDecodeRaw",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nunsuppress_quant_table (JPEGState* sp, int tblno)\n{\n\tJQUANT_TBL* qtbl;\n\n\tif ((qtbl = sp->cinfo.c.quant_tbl_ptrs[tblno]) != NULL)\n\t\tqtbl->sent_table = FALSE;\n}",
          "fn_code_pos": [
            [
              1649,
              0
            ],
            [
              1656,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unsuppress_quant_table",
            "parameters": {
              "sp": "JPEGState",
              "tblno": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nsuppress_quant_table (JPEGState* sp, int tblno)\n{\n\tJQUANT_TBL* qtbl;\n\n\tif ((qtbl = sp->cinfo.c.quant_tbl_ptrs[tblno]) != NULL)\n\t\tqtbl->sent_table = TRUE;\n}",
          "fn_code_pos": [
            [
              1658,
              0
            ],
            [
              1665,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "suppress_quant_table",
            "parameters": {
              "sp": "JPEGState",
              "tblno": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nunsuppress_huff_table (JPEGState* sp, int tblno)\n{\n\tJHUFF_TBL* htbl;\n\n\tif ((htbl = sp->cinfo.c.dc_huff_tbl_ptrs[tblno]) != NULL)\n\t\thtbl->sent_table = FALSE;\n\tif ((htbl = sp->cinfo.c.ac_huff_tbl_ptrs[tblno]) != NULL)\n\t\thtbl->sent_table = FALSE;\n}",
          "fn_code_pos": [
            [
              1667,
              0
            ],
            [
              1676,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unsuppress_huff_table",
            "parameters": {
              "sp": "JPEGState",
              "tblno": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nsuppress_huff_table (JPEGState* sp, int tblno)\n{\n\tJHUFF_TBL* htbl;\n\n\tif ((htbl = sp->cinfo.c.dc_huff_tbl_ptrs[tblno]) != NULL)\n\t\thtbl->sent_table = TRUE;\n\tif ((htbl = sp->cinfo.c.ac_huff_tbl_ptrs[tblno]) != NULL)\n\t\thtbl->sent_table = TRUE;\n}",
          "fn_code_pos": [
            [
              1678,
              0
            ],
            [
              1687,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "suppress_huff_table",
            "parameters": {
              "sp": "JPEGState",
              "tblno": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nprepare_JPEGTables(TIFF* tif)\n{\n\tJPEGState* sp = JState(tif);\n\n\t/* Initialize quant tables for current quality setting */\n\tif (!TIFFjpeg_set_quality(sp, sp->jpegquality, FALSE))\n\t\treturn (0);\n\t/* Mark only the tables we want for output */\n\t/* NB: chrominance tables are currently used only with YCbCr */\n\tif (!TIFFjpeg_suppress_tables(sp, TRUE))\n\t\treturn (0);\n\tif (sp->jpegtablesmode & JPEGTABLESMODE_QUANT) {\n\t\tunsuppress_quant_table(sp, 0);\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR)\n\t\t\tunsuppress_quant_table(sp, 1);\n\t}\n\tif (sp->jpegtablesmode & JPEGTABLESMODE_HUFF) {\n\t\tunsuppress_huff_table(sp, 0);\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR)\n\t\t\tunsuppress_huff_table(sp, 1);\n\t}\n\t/* Direct libjpeg output into jpegtables */\n\tif (!TIFFjpeg_tables_dest(sp, tif))\n\t\treturn (0);\n\t/* Emit tables-only datastream */\n\tif (!TIFFjpeg_write_tables(sp))\n\t\treturn (0);\n\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1689,
              0
            ],
            [
              1719,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "prepare_JPEGTables",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nJPEGSetupEncode(TIFF* tif)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\tstatic const char module[] = \"JPEGSetupEncode\";\n\n#if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG)\n        if( tif->tif_dir.td_bitspersample == 12 )\n            return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 1 );\n#endif\n\n        JPEGInitializeLibJPEG( tif, FALSE );\n\n\tassert(sp != NULL);\n\tassert(!sp->cinfo.comm.is_decompressor);\n\n\tsp->photometric = td->td_photometric;\n\n\t/*\n\t * Initialize all JPEG parameters to default values.\n\t * Note that jpeg_set_defaults needs legal values for\n\t * in_color_space and input_components.\n\t */\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tsp->cinfo.c.input_components = td->td_samplesperpixel;\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR) {\n\t\t\tif (sp->jpegcolormode == JPEGCOLORMODE_RGB) {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\t} else {\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_YCbCr;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_GRAYSCALE;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_RGB;\n\t\t\telse if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4)\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_CMYK;\n\t\t\telse\n\t\t\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t\t}\n\t} else {\n\t\tsp->cinfo.c.input_components = 1;\n\t\tsp->cinfo.c.in_color_space = JCS_UNKNOWN;\n\t}\n\tif (!TIFFjpeg_set_defaults(sp))\n\t\treturn (0);\n\t/* Set per-file parameters */\n\tswitch (sp->photometric) {\n\tcase PHOTOMETRIC_YCBCR:\n\t\tsp->h_sampling = td->td_ycbcrsubsampling[0];\n\t\tsp->v_sampling = td->td_ycbcrsubsampling[1];\n                if( sp->h_sampling == 0 || sp->v_sampling == 0 )\n                {\n                    TIFFErrorExt(tif->tif_clientdata, module,\n                            \"Invalig horizontal/vertical sampling value\");\n                    return (0);\n                }\n                if( td->td_bitspersample > 16 )\n                {\n                    TIFFErrorExt(tif->tif_clientdata, module,\n                                 \"BitsPerSample %d not allowed for JPEG\",\n                                 td->td_bitspersample);\n                    return (0);\n                }\n\n\t\t/*\n\t\t * A ReferenceBlackWhite field *must* be present since the\n\t\t * default value is inappropriate for YCbCr.  Fill in the\n\t\t * proper value if application didn't set it.\n\t\t */\n\t\t{\n\t\t\tfloat *ref;\n\t\t\tif (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t\t\t\t\t  &ref)) {\n\t\t\t\tfloat refbw[6];\n\t\t\t\tlong top = 1L << td->td_bitspersample;\n\t\t\t\trefbw[0] = 0;\n\t\t\t\trefbw[1] = (float)(top-1L);\n\t\t\t\trefbw[2] = (float)(top>>1);\n\t\t\t\trefbw[3] = refbw[1];\n\t\t\t\trefbw[4] = refbw[2];\n\t\t\t\trefbw[5] = refbw[1];\n\t\t\t\tTIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE,\n\t\t\t\t\t     refbw);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_PALETTE:\t\t/* disallowed by Tech Note */\n\tcase PHOTOMETRIC_MASK:\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t  \"PhotometricInterpretation %d not allowed for JPEG\",\n\t\t\t  (int) sp->photometric);\n\t\treturn (0);\n\tdefault:\n\t\t/* TIFF 6.0 forbids subsampling of all other color spaces */\n\t\tsp->h_sampling = 1;\n\t\tsp->v_sampling = 1;\n\t\tbreak;\n\t}\n\n\t/* Verify miscellaneous parameters */\n\n\t/*\n\t * This would need work if libtiff ever supports different\n\t * depths for different components, or if libjpeg ever supports\n\t * run-time selection of depth.  Neither is imminent.\n\t */\n#ifdef JPEG_LIB_MK1\n        /* BITS_IN_JSAMPLE now permits 8 and 12 --- dgilbert */\n\tif (td->td_bitspersample != 8 && td->td_bitspersample != 12) \n#else\n\tif (td->td_bitspersample != BITS_IN_JSAMPLE )\n#endif\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"BitsPerSample %d not allowed for JPEG\",\n\t\t\t  (int) td->td_bitspersample);\n\t\treturn (0);\n\t}\n\tsp->cinfo.c.data_precision = td->td_bitspersample;\n#ifdef JPEG_LIB_MK1\n        sp->cinfo.c.bits_in_jsample = td->td_bitspersample;\n#endif\n\tif (isTiled(tif)) {\n\t\tif ((td->td_tilelength % (sp->v_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"JPEG tile height must be multiple of %d\",\n\t\t\t\t  sp->v_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t\tif ((td->td_tilewidth % (sp->h_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"JPEG tile width must be multiple of %d\",\n\t\t\t\t  sp->h_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (td->td_rowsperstrip < td->td_imagelength &&\n\t\t    (td->td_rowsperstrip % (sp->v_sampling * DCTSIZE)) != 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t  \"RowsPerStrip must be multiple of %d for JPEG\",\n\t\t\t\t  sp->v_sampling * DCTSIZE);\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* Create a JPEGTables field if appropriate */\n\tif (sp->jpegtablesmode & (JPEGTABLESMODE_QUANT|JPEGTABLESMODE_HUFF)) {\n                if( sp->jpegtables == NULL\n                    || memcmp(sp->jpegtables,\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0 )\n                {\n                        if (!prepare_JPEGTables(tif))\n                                return (0);\n                        /* Mark the field present */\n                        /* Can't use TIFFSetField since BEENWRITING is already set! */\n                        tif->tif_flags |= TIFF_DIRTYDIRECT;\n                        TIFFSetFieldBit(tif, FIELD_JPEGTABLES);\n                }\n\t} else {\n\t\t/* We do not support application-supplied JPEGTables, */\n\t\t/* so mark the field not present */\n\t\tTIFFClrFieldBit(tif, FIELD_JPEGTABLES);\n\t}\n\n\t/* Direct libjpeg output to libtiff's output buffer */\n\tTIFFjpeg_data_dest(sp, tif);\n\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1721,
              0
            ],
            [
              1890,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGSetupEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nJPEGPreEncode(TIFF* tif, uint16 s)\n{\n\tJPEGState *sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\tstatic const char module[] = \"JPEGPreEncode\";\n\tuint32 segment_width, segment_height;\n\tint downsampled_input;\n\n\tassert(sp != NULL);\n  \n\tif (sp->cinfo.comm.is_decompressor == 1)\n\t{\n\t\ttif->tif_setupencode( tif );\n\t}\n  \n\tassert(!sp->cinfo.comm.is_decompressor);\n\t/*\n\t * Set encoding parameters for this strip/tile.\n\t */\n\tif (isTiled(tif)) {\n\t\tsegment_width = td->td_tilewidth;\n\t\tsegment_height = td->td_tilelength;\n\t\tsp->bytesperline = TIFFTileRowSize(tif);\n\t} else {\n\t\tsegment_width = td->td_imagewidth;\n\t\tsegment_height = td->td_imagelength - tif->tif_row;\n\t\tif (segment_height > td->td_rowsperstrip)\n\t\t\tsegment_height = td->td_rowsperstrip;\n\t\tsp->bytesperline = TIFFScanlineSize(tif);\n\t}\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE && s > 0) {\n\t\t/* for PC 2, scale down the strip/tile size\n\t\t * to match a downsampled component\n\t\t */\n\t\tsegment_width = TIFFhowmany_32(segment_width, sp->h_sampling); \n\t\tsegment_height = TIFFhowmany_32(segment_height, sp->v_sampling);\n\t}\n\tif (segment_width > 65535 || segment_height > 65535) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Strip/tile too large for JPEG\");\n\t\treturn (0);\n\t}\n\tsp->cinfo.c.image_width = segment_width;\n\tsp->cinfo.c.image_height = segment_height;\n\tdownsampled_input = FALSE;\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tsp->cinfo.c.input_components = td->td_samplesperpixel;\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR) {\n\t\t\tif (sp->jpegcolormode != JPEGCOLORMODE_RGB) {\n\t\t\t\tif (sp->h_sampling != 1 || sp->v_sampling != 1)\n\t\t\t\t\tdownsampled_input = TRUE;\n\t\t\t}\n\t\t\tif (!TIFFjpeg_set_colorspace(sp, JCS_YCbCr))\n\t\t\t\treturn (0);\n\t\t\t/*\n\t\t\t * Set Y sampling factors;\n\t\t\t * we assume jpeg_set_colorspace() set the rest to 1\n\t\t\t */\n\t\t\tsp->cinfo.c.comp_info[0].h_samp_factor = sp->h_sampling;\n\t\t\tsp->cinfo.c.comp_info[0].v_samp_factor = sp->v_sampling;\n\t\t} else {\n\t\t\tif (!TIFFjpeg_set_colorspace(sp, sp->cinfo.c.in_color_space))\n\t\t\t\treturn (0);\n\t\t\t/* jpeg_set_colorspace set all sampling factors to 1 */\n\t\t}\n\t} else {\n\t\tif (!TIFFjpeg_set_colorspace(sp, JCS_UNKNOWN))\n\t\t\treturn (0);\n\t\tsp->cinfo.c.comp_info[0].component_id = s;\n\t\t/* jpeg_set_colorspace() set sampling factors to 1 */\n\t\tif (sp->photometric == PHOTOMETRIC_YCBCR && s > 0) {\n\t\t\tsp->cinfo.c.comp_info[0].quant_tbl_no = 1;\n\t\t\tsp->cinfo.c.comp_info[0].dc_tbl_no = 1;\n\t\t\tsp->cinfo.c.comp_info[0].ac_tbl_no = 1;\n\t\t}\n\t}\n\t/* ensure libjpeg won't write any extraneous markers */\n\tsp->cinfo.c.write_JFIF_header = FALSE;\n\tsp->cinfo.c.write_Adobe_marker = FALSE;\n\t/* set up table handling correctly */\n\t/* calling TIFFjpeg_set_quality() causes quantization tables to be flagged */\n\t/* as being to be emitted, which we don't want in the JPEGTABLESMODE_QUANT */\n\t/* mode, so we must manually suppress them. However TIFFjpeg_set_quality() */\n\t/* should really be called when dealing with files with directories with */\n\t/* mixed qualities. see http://trac.osgeo.org/gdal/ticket/3539 */\n\tif (!TIFFjpeg_set_quality(sp, sp->jpegquality, FALSE))\n\t\treturn (0);\n\tif (sp->jpegtablesmode & JPEGTABLESMODE_QUANT) {\n\t\tsuppress_quant_table(sp, 0);\n\t\tsuppress_quant_table(sp, 1);\n\t}\n\telse {\n\t\tunsuppress_quant_table(sp, 0);\n\t\tunsuppress_quant_table(sp, 1);\n\t}\n\tif (sp->jpegtablesmode & JPEGTABLESMODE_HUFF)\n\t{\n\t\t/* Explicit suppression is only needed if we did not go through the */\n\t\t/* prepare_JPEGTables() code path, which may be the case if updating */\n\t\t/* an existing file */\n\t\tsuppress_huff_table(sp, 0);\n\t\tsuppress_huff_table(sp, 1);\n\t\tsp->cinfo.c.optimize_coding = FALSE;\n\t}\n\telse\n\t\tsp->cinfo.c.optimize_coding = TRUE;\n\tif (downsampled_input) {\n\t\t/* Need to use raw-data interface to libjpeg */\n\t\tsp->cinfo.c.raw_data_in = TRUE;\n\t\ttif->tif_encoderow = JPEGEncodeRaw;\n\t\ttif->tif_encodestrip = JPEGEncodeRaw;\n\t\ttif->tif_encodetile = JPEGEncodeRaw;\n\t} else {\n\t\t/* Use normal interface to libjpeg */\n\t\tsp->cinfo.c.raw_data_in = FALSE;\n\t\ttif->tif_encoderow = JPEGEncode;\n\t\ttif->tif_encodestrip = JPEGEncode;\n\t\ttif->tif_encodetile = JPEGEncode;\n\t}\n\t/* Start JPEG compressor */\n\tif (!TIFFjpeg_start_compress(sp, FALSE))\n\t\treturn (0);\n\t/* Allocate downsampled-data buffers if needed */\n\tif (downsampled_input) {\n\t\tif (!alloc_downsampled_buffers(tif, sp->cinfo.c.comp_info,\n\t\t\t\t\t       sp->cinfo.c.num_components))\n\t\t\treturn (0);\n\t}\n\tsp->scancount = 0;\n\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1895,
              0
            ],
            [
              2026,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGPreEncode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nJPEGEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n{\n\tJPEGState *sp = JState(tif);\n\ttmsize_t nrows;\n\tJSAMPROW bufptr[1];\n        short *line16 = NULL;\n        int    line16_count = 0;\n\n\t(void) s;\n\tassert(sp != NULL);\n\t/* data is expected to be supplied in multiples of a scanline */\n\tnrows = cc / sp->bytesperline;\n\tif (cc % sp->bytesperline)\n            TIFFWarningExt(tif->tif_clientdata, tif->tif_name, \n                           \"fractional scanline discarded\");\n\n        /* The last strip will be limited to image size */\n        if( !isTiled(tif) && tif->tif_row+nrows > tif->tif_dir.td_imagelength )\n            nrows = tif->tif_dir.td_imagelength - tif->tif_row;\n\n        if( sp->cinfo.c.data_precision == 12 )\n        {\n            line16_count = (int)((sp->bytesperline * 2) / 3);\n            line16 = (short *) _TIFFmalloc(sizeof(short) * line16_count);\n            if (!line16)\n            {\n                TIFFErrorExt(tif->tif_clientdata,\n\t\t\t     \"JPEGEncode\",\n                             \"Failed to allocate memory\");\n\n                return 0;\n            }\n        }\n            \n\twhile (nrows-- > 0) {\n\n            if( sp->cinfo.c.data_precision == 12 )\n            {\n\n                int value_pairs = line16_count / 2;\n                int iPair;\n\n\t\tbufptr[0] = (JSAMPROW) line16;\n\n                for( iPair = 0; iPair < value_pairs; iPair++ )\n                {\n                    unsigned char *in_ptr =\n                        ((unsigned char *) buf) + iPair * 3;\n                    JSAMPLE *out_ptr = (JSAMPLE *) (line16 + iPair * 2);\n\n                    out_ptr[0] = (in_ptr[0] << 4) | ((in_ptr[1] & 0xf0) >> 4);\n                    out_ptr[1] = ((in_ptr[1] & 0x0f) << 8) | in_ptr[2];\n                }\n            }\n            else\n            {\n\t\tbufptr[0] = (JSAMPROW) buf;\n            }\n            if (TIFFjpeg_write_scanlines(sp, bufptr, 1) != 1)\n                return (0);\n            if (nrows > 0)\n                tif->tif_row++;\n            buf += sp->bytesperline;\n\t}\n\n        if( sp->cinfo.c.data_precision == 12 )\n        {\n            _TIFFfree( line16 );\n        }\n            \n\treturn (1);\n}",
          "fn_code_pos": [
            [
              2032,
              0
            ],
            [
              2104,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGEncode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nJPEGEncodeRaw(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n{\n\tJPEGState *sp = JState(tif);\n\tJSAMPLE* inptr;\n\tJSAMPLE* outptr;\n\ttmsize_t nrows;\n\tJDIMENSION clumps_per_line, nclump;\n\tint clumpoffset, ci, xpos, ypos;\n\tjpeg_component_info* compptr;\n\tint samples_per_clump = sp->samplesperclump;\n\ttmsize_t bytesperclumpline;\n\n\t(void) s;\n\tassert(sp != NULL);\n\t/* data is expected to be supplied in multiples of a clumpline */\n\t/* a clumpline is equivalent to v_sampling desubsampled scanlines */\n\t/* TODO: the following calculation of bytesperclumpline, should substitute calculation of sp->bytesperline, except that it is per v_sampling lines */\n\tbytesperclumpline = (((sp->cinfo.c.image_width+sp->h_sampling-1)/sp->h_sampling)\n\t\t\t     *(sp->h_sampling*sp->v_sampling+2)*sp->cinfo.c.data_precision+7)\n\t\t\t    /8;\n\n\tnrows = ( cc / bytesperclumpline ) * sp->v_sampling;\n\tif (cc % bytesperclumpline)\n\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name, \"fractional scanline discarded\");\n\n\t/* Cb,Cr both have sampling factors 1, so this is correct */\n\tclumps_per_line = sp->cinfo.c.comp_info[1].downsampled_width;\n\n\twhile (nrows > 0) {\n\t\t/*\n\t\t * Fastest way to separate the data is to make one pass\n\t\t * over the scanline for each row of each component.\n\t\t */\n\t\tclumpoffset = 0;\t\t/* first sample in clump */\n\t\tfor (ci = 0, compptr = sp->cinfo.c.comp_info;\n\t\t     ci < sp->cinfo.c.num_components;\n\t\t     ci++, compptr++) {\n\t\t    int hsamp = compptr->h_samp_factor;\n\t\t    int vsamp = compptr->v_samp_factor;\n\t\t    int padding = (int) (compptr->width_in_blocks * DCTSIZE -\n\t\t\t\t\t clumps_per_line * hsamp);\n\t\t    for (ypos = 0; ypos < vsamp; ypos++) {\n\t\t\tinptr = ((JSAMPLE*) buf) + clumpoffset;\n\t\t\toutptr = sp->ds_buffer[ci][sp->scancount*vsamp + ypos];\n\t\t\tif (hsamp == 1) {\n\t\t\t    /* fast path for at least Cb and Cr */\n\t\t\t    for (nclump = clumps_per_line; nclump-- > 0; ) {\n\t\t\t\t*outptr++ = inptr[0];\n\t\t\t\tinptr += samples_per_clump;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    /* general case */\n\t\t\t    for (nclump = clumps_per_line; nclump-- > 0; ) {\n\t\t\t\tfor (xpos = 0; xpos < hsamp; xpos++)\n\t\t\t\t    *outptr++ = inptr[xpos];\n\t\t\t\tinptr += samples_per_clump;\n\t\t\t    }\n\t\t\t}\n\t\t\t/* pad each scanline as needed */\n\t\t\tfor (xpos = 0; xpos < padding; xpos++) {\n\t\t\t    *outptr = outptr[-1];\n\t\t\t    outptr++;\n\t\t\t}\n\t\t\tclumpoffset += hsamp;\n\t\t    }\n\t\t}\n\t\tsp->scancount++;\n\t\tif (sp->scancount >= DCTSIZE) {\n\t\t\tint n = sp->cinfo.c.max_v_samp_factor * DCTSIZE;\n\t\t\tif (TIFFjpeg_write_raw_data(sp, sp->ds_buffer, n) != n)\n\t\t\t\treturn (0);\n\t\t\tsp->scancount = 0;\n\t\t}\n\t\ttif->tif_row += sp->v_sampling;\n\t\tbuf += bytesperclumpline;\n\t\tnrows -= sp->v_sampling;\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              2110,
              0
            ],
            [
              2189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGEncodeRaw",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nJPEGPostEncode(TIFF* tif)\n{\n\tJPEGState *sp = JState(tif);\n\n\tif (sp->scancount > 0) {\n\t\t/*\n\t\t * Need to emit a partial bufferload of downsampled data.\n\t\t * Pad the data vertically.\n\t\t */\n\t\tint ci, ypos, n;\n\t\tjpeg_component_info* compptr;\n\n\t\tfor (ci = 0, compptr = sp->cinfo.c.comp_info;\n\t\t     ci < sp->cinfo.c.num_components;\n\t\t     ci++, compptr++) {\n\t\t\tint vsamp = compptr->v_samp_factor;\n\t\t\ttmsize_t row_width = compptr->width_in_blocks * DCTSIZE\n\t\t\t\t* sizeof(JSAMPLE);\n\t\t\tfor (ypos = sp->scancount * vsamp;\n\t\t\t     ypos < DCTSIZE * vsamp; ypos++) {\n\t\t\t\t_TIFFmemcpy((void*)sp->ds_buffer[ci][ypos],\n\t\t\t\t\t    (void*)sp->ds_buffer[ci][ypos-1],\n\t\t\t\t\t    row_width);\n\n\t\t\t}\n\t\t}\n\t\tn = sp->cinfo.c.max_v_samp_factor * DCTSIZE;\n\t\tif (TIFFjpeg_write_raw_data(sp, sp->ds_buffer, n) != n)\n\t\t\treturn (0);\n\t}\n\n\treturn (TIFFjpeg_finish_compress(JState(tif)));\n}",
          "fn_code_pos": [
            [
              2194,
              0
            ],
            [
              2227,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGPostEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nJPEGCleanup(TIFF* tif)\n{\n\tJPEGState *sp = JState(tif);\n\t\n\tassert(sp != 0);\n\n\ttif->tif_tagmethods.vgetfield = sp->vgetparent;\n\ttif->tif_tagmethods.vsetfield = sp->vsetparent;\n\ttif->tif_tagmethods.printdir = sp->printdir;\n        if( sp->cinfo_initialized )\n                TIFFjpeg_destroy(sp);\t/* release libjpeg resources */\n        if (sp->jpegtables)\t\t/* tag value */\n                _TIFFfree(sp->jpegtables);\n\t_TIFFfree(tif->tif_data);\t/* release local state */\n\ttif->tif_data = NULL;\n\n\t_TIFFSetDefaultCompressionState(tif);\n}",
          "fn_code_pos": [
            [
              2229,
              0
            ],
            [
              2247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGCleanup",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void \nJPEGResetUpsampled( TIFF* tif )\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory* td = &tif->tif_dir;\n\n\t/*\n\t * Mark whether returned data is up-sampled or not so TIFFStripSize\n\t * and TIFFTileSize return values that reflect the true amount of\n\t * data.\n\t */\n\ttif->tif_flags &= ~TIFF_UPSAMPLED;\n\tif (td->td_planarconfig == PLANARCONFIG_CONTIG) {\n\t\tif (td->td_photometric == PHOTOMETRIC_YCBCR &&\n\t\t    sp->jpegcolormode == JPEGCOLORMODE_RGB) {\n\t\t\ttif->tif_flags |= TIFF_UPSAMPLED;\n\t\t} else {\n#ifdef notdef\n\t\t\tif (td->td_ycbcrsubsampling[0] != 1 ||\n\t\t\t    td->td_ycbcrsubsampling[1] != 1)\n\t\t\t\t; /* XXX what about up-sampling? */\n#endif\n\t\t}\n\t}\n\n\t/*\n\t * Must recalculate cached tile size in case sampling state changed.\n\t * Should we really be doing this now if image size isn't set? \n\t */\n        if( tif->tif_tilesize > 0 )\n            tif->tif_tilesize = isTiled(tif) ? TIFFTileSize(tif) : (tmsize_t)(-1);   \n        if( tif->tif_scanlinesize > 0 )\n            tif->tif_scanlinesize = TIFFScanlineSize(tif); \n}",
          "fn_code_pos": [
            [
              2249,
              0
            ],
            [
              2282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGResetUpsampled",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nJPEGVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tJPEGState* sp = JState(tif);\n\tconst TIFFField* fip;\n\tuint32 v32;\n\n\tassert(sp != NULL);\n\n\tswitch (tag) {\n\tcase TIFFTAG_JPEGTABLES:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 == 0) {\n\t\t\t/* XXX */\n\t\t\treturn (0);\n\t\t}\n\t\t_TIFFsetByteArray(&sp->jpegtables, va_arg(ap, void*), v32);\n\t\tsp->jpegtables_length = v32;\n\t\tTIFFSetFieldBit(tif, FIELD_JPEGTABLES);\n\t\tbreak;\n\tcase TIFFTAG_JPEGQUALITY:\n\t\tsp->jpegquality = (int) va_arg(ap, int);\n\t\treturn (1);\t\t\t/* pseudo tag */\n\tcase TIFFTAG_JPEGCOLORMODE:\n\t\tsp->jpegcolormode = (int) va_arg(ap, int);\n\t\tJPEGResetUpsampled( tif );\n\t\treturn (1);\t\t\t/* pseudo tag */\n\tcase TIFFTAG_PHOTOMETRIC:\n\t{\n\t\tint ret_value = (*sp->vsetparent)(tif, tag, ap);\n\t\tJPEGResetUpsampled( tif );\n\t\treturn ret_value;\n\t}\n\tcase TIFFTAG_JPEGTABLESMODE:\n\t\tsp->jpegtablesmode = (int) va_arg(ap, int);\n\t\treturn (1);\t\t\t/* pseudo tag */\n\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t/* mark the fact that we have a real ycbcrsubsampling! */\n\t\tsp->ycbcrsampling_fetched = 1;\n\t\t/* should we be recomputing upsampling info here? */\n\t\treturn (*sp->vsetparent)(tif, tag, ap);\n\tdefault:\n\t\treturn (*sp->vsetparent)(tif, tag, ap);\n\t}\n\n\tif ((fip = TIFFFieldWithTag(tif, tag)) != NULL) {\n\t\tTIFFSetFieldBit(tif, fip->field_bit);\n\t} else {\n\t\treturn (0);\n\t}\n\n\ttif->tif_flags |= TIFF_DIRTYDIRECT;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              2284,
              0
            ],
            [
              2337,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGVSetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nJPEGVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tJPEGState* sp = JState(tif);\n\n\tassert(sp != NULL);\n\n\tswitch (tag) {\n\t\tcase TIFFTAG_JPEGTABLES:\n\t\t\t*va_arg(ap, uint32*) = sp->jpegtables_length;\n\t\t\t*va_arg(ap, void**) = sp->jpegtables;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGQUALITY:\n\t\t\t*va_arg(ap, int*) = sp->jpegquality;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGCOLORMODE:\n\t\t\t*va_arg(ap, int*) = sp->jpegcolormode;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGTABLESMODE:\n\t\t\t*va_arg(ap, int*) = sp->jpegtablesmode;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (*sp->vgetparent)(tif, tag, ap);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              2339,
              0
            ],
            [
              2364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGVGetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nJPEGPrintDir(TIFF* tif, FILE* fd, long flags)\n{\n\tJPEGState* sp = JState(tif);\n\n\tassert(sp != NULL);\n\t(void) flags;\n\n        if( sp != NULL ) {\n\t\tif (TIFFFieldSet(tif,FIELD_JPEGTABLES))\n\t\t\tfprintf(fd, \"  JPEG Tables: (%lu bytes)\\n\",\n\t\t\t\t(unsigned long) sp->jpegtables_length);\n\t\tif (sp->printdir)\n\t\t\t(*sp->printdir)(tif, fd, flags);\n\t}\n}",
          "fn_code_pos": [
            [
              2366,
              0
            ],
            [
              2381,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGPrintDir",
            "parameters": {
              "tif": "TIFF",
              "fd": "FILE",
              "flags": "long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static uint32\nJPEGDefaultStripSize(TIFF* tif, uint32 s)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\ts = (*sp->defsparent)(tif, s);\n\tif (s < td->td_imagelength)\n\t\ts = TIFFroundup_32(s, td->td_ycbcrsubsampling[1] * DCTSIZE);\n\treturn (s);\n}",
          "fn_code_pos": [
            [
              2383,
              0
            ],
            [
              2393,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGDefaultStripSize",
            "parameters": {
              "tif": "TIFF",
              "s": "uint32"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "static void\nJPEGDefaultTileSize(TIFF* tif, uint32* tw, uint32* th)\n{\n\tJPEGState* sp = JState(tif);\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\t(*sp->deftparent)(tif, tw, th);\n\t*tw = TIFFroundup_32(*tw, td->td_ycbcrsubsampling[0] * DCTSIZE);\n\t*th = TIFFroundup_32(*th, td->td_ycbcrsubsampling[1] * DCTSIZE);\n}",
          "fn_code_pos": [
            [
              2395,
              0
            ],
            [
              2404,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGDefaultTileSize",
            "parameters": {
              "tif": "TIFF",
              "tw": "uint32",
              "th": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int JPEGInitializeLibJPEG( TIFF * tif, int decompress )\n{\n    JPEGState* sp = JState(tif);\n\n    if(sp->cinfo_initialized)\n    {\n        if( !decompress && sp->cinfo.comm.is_decompressor )\n            TIFFjpeg_destroy( sp );\n        else if( decompress && !sp->cinfo.comm.is_decompressor )\n            TIFFjpeg_destroy( sp );\n        else\n            return 1;\n\n        sp->cinfo_initialized = 0;\n    }\n\n    /*\n     * Initialize libjpeg.\n     */\n    if ( decompress ) {\n        if (!TIFFjpeg_create_decompress(sp))\n            return (0);\n    } else {\n        if (!TIFFjpeg_create_compress(sp))\n            return (0);\n#ifndef TIFF_JPEG_MAX_MEMORY_TO_USE\n#define TIFF_JPEG_MAX_MEMORY_TO_USE (10 * 1024 * 1024)\n#endif\n        /* libjpeg turbo 1.5.2 honours max_memory_to_use, but has no backing */\n        /* store implementation, so better not set max_memory_to_use ourselves. */\n        /* See https://github.com/libjpeg-turbo/libjpeg-turbo/issues/162 */\n        if( sp->cinfo.c.mem->max_memory_to_use > 0 )\n        {\n            /* This is to address bug related in ticket GDAL #1795. */\n            if (getenv(\"JPEGMEM\") == NULL)\n            {\n                /* Increase the max memory usable. This helps when creating files */\n                /* with \"big\" tile, without using libjpeg temporary files. */\n                /* For example a 512x512 tile with 3 bands */\n                /* requires 1.5 MB which is above libjpeg 1MB default */\n                if( sp->cinfo.c.mem->max_memory_to_use < TIFF_JPEG_MAX_MEMORY_TO_USE )\n                    sp->cinfo.c.mem->max_memory_to_use = TIFF_JPEG_MAX_MEMORY_TO_USE;\n            }\n        }\n    }\n\n    sp->cinfo_initialized = TRUE;\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              2428,
              0
            ],
            [
              2477,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGInitializeLibJPEG",
            "parameters": {
              "tif": "TIFF",
              "decompress": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFInitJPEG(TIFF* tif, int scheme)\n{\n\tJPEGState* sp;\n\n\tassert(scheme == COMPRESSION_JPEG);\n\n\t/*\n\t * Merge codec-specific tag information.\n\t */\n\tif (!_TIFFMergeFields(tif, jpegFields, TIFFArrayCount(jpegFields))) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\n\t\t\t     \"TIFFInitJPEG\",\n\t\t\t     \"Merging JPEG codec-specific tags failed\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate state block so tag methods have storage to record values.\n\t */\n\ttif->tif_data = (uint8*) _TIFFmalloc(sizeof (JPEGState));\n\n\tif (tif->tif_data == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata,\n\t\t\t     \"TIFFInitJPEG\", \"No space for JPEG state block\");\n\t\treturn 0;\n\t}\n        _TIFFmemset(tif->tif_data, 0, sizeof(JPEGState));\n\n\tsp = JState(tif);\n\tsp->tif = tif;\t\t\t\t/* back link */\n\n\t/*\n\t * Override parent get/set field methods.\n\t */\n\tsp->vgetparent = tif->tif_tagmethods.vgetfield;\n\ttif->tif_tagmethods.vgetfield = JPEGVGetField; /* hook for codec tags */\n\tsp->vsetparent = tif->tif_tagmethods.vsetfield;\n\ttif->tif_tagmethods.vsetfield = JPEGVSetField; /* hook for codec tags */\n\tsp->printdir = tif->tif_tagmethods.printdir;\n\ttif->tif_tagmethods.printdir = JPEGPrintDir;   /* hook for codec tags */\n\n\t/* Default values for codec-specific fields */\n\tsp->jpegtables = NULL;\n\tsp->jpegtables_length = 0;\n\tsp->jpegquality = 75;\t\t\t/* Default IJG quality */\n\tsp->jpegcolormode = JPEGCOLORMODE_RAW;\n\tsp->jpegtablesmode = JPEGTABLESMODE_QUANT | JPEGTABLESMODE_HUFF;\n        sp->ycbcrsampling_fetched = 0;\n\n\t/*\n\t * Install codec methods.\n\t */\n\ttif->tif_fixuptags = JPEGFixupTags;\n\ttif->tif_setupdecode = JPEGSetupDecode;\n\ttif->tif_predecode = JPEGPreDecode;\n\ttif->tif_decoderow = JPEGDecode;\n\ttif->tif_decodestrip = JPEGDecode;\n\ttif->tif_decodetile = JPEGDecode;\n\ttif->tif_setupencode = JPEGSetupEncode;\n\ttif->tif_preencode = JPEGPreEncode;\n\ttif->tif_postencode = JPEGPostEncode;\n\ttif->tif_encoderow = JPEGEncode;\n\ttif->tif_encodestrip = JPEGEncode;\n\ttif->tif_encodetile = JPEGEncode;  \n\ttif->tif_cleanup = JPEGCleanup;\n\tsp->defsparent = tif->tif_defstripsize;\n\ttif->tif_defstripsize = JPEGDefaultStripSize;\n\tsp->deftparent = tif->tif_deftilesize;\n\ttif->tif_deftilesize = JPEGDefaultTileSize;\n\ttif->tif_flags |= TIFF_NOBITREV;\t/* no bit reversal, please */\n\n        sp->cinfo_initialized = FALSE;\n\n\t/*\n        ** Create a JPEGTables field if no directory has yet been created. \n        ** We do this just to ensure that sufficient space is reserved for\n        ** the JPEGTables field.  It will be properly created the right\n        ** size later. \n        */\n        if( tif->tif_diroff == 0 )\n        {\n#define SIZE_OF_JPEGTABLES 2000\n/*\nThe following line assumes incorrectly that all JPEG-in-TIFF files will have\na JPEGTABLES tag generated and causes null-filled JPEGTABLES tags to be written\nwhen the JPEG data is placed with TIFFWriteRawStrip.  The field bit should be \nset, anyway, later when actual JPEGTABLES header is generated, so removing it \nhere hopefully is harmless.\n            TIFFSetFieldBit(tif, FIELD_JPEGTABLES);\n*/\n            sp->jpegtables_length = SIZE_OF_JPEGTABLES;\n            sp->jpegtables = (void *) _TIFFmalloc(sp->jpegtables_length);\n            if (sp->jpegtables)\n            {\n                _TIFFmemset(sp->jpegtables, 0, SIZE_OF_JPEGTABLES);\n            }\n            else\n            {\n                TIFFErrorExt(tif->tif_clientdata,\n\t\t\t     \"TIFFInitJPEG\",\n                             \"Failed to allocate memory for JPEG tables\");\n                return 0;\n            }\n#undef SIZE_OF_JPEGTABLES\n        }\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              2479,
              0
            ],
            [
              2587,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitJPEG",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFFillStrip(TIFF* tif, uint32 strip)",
          "fn_dec_pos": [
            [
              46,
              4
            ],
            [
              46,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFillStrip",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFillTile(TIFF* tif, uint32 tile)",
          "fn_dec_pos": [
            [
              47,
              4
            ],
            [
              47,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFillTile",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFReInitJPEG_12( TIFF *tif, int scheme, int is_encode )",
          "fn_dec_pos": [
            [
              48,
              4
            ],
            [
              48,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReInitJPEG_12",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int",
              "is_encode": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFJPEGIsFullStripRequired_12(TIFF* tif)",
          "fn_dec_pos": [
            [
              49,
              4
            ],
            [
              49,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFJPEGIsFullStripRequired_12",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "JPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              185,
              11
            ],
            [
              185,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGDecode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "JPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              186,
              11
            ],
            [
              186,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGDecodeRaw",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "JPEGEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              187,
              11
            ],
            [
              187,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGEncode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "JPEGEncodeRaw(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              188,
              11
            ],
            [
              188,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGEncodeRaw",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "JPEGInitializeLibJPEG(TIFF * tif, int decode )",
          "fn_dec_pos": [
            [
              189,
              11
            ],
            [
              189,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGInitializeLibJPEG",
            "parameters": {
              "tif": "TIFF",
              "decode": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "DecodeRowError(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              190,
              11
            ],
            [
              190,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DecodeRowError",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "JPEGFixupTagsSubsampling(TIFF* tif)",
          "fn_dec_pos": [
            [
              732,
              12
            ],
            [
              732,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGFixupTagsSubsampling",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "JPEGFixupTagsSubsamplingSec(struct JPEGFixupTagsSubsamplingData* data)",
          "fn_dec_pos": [
            [
              733,
              11
            ],
            [
              733,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGFixupTagsSubsamplingSec",
            "parameters": {
              "data": "struct JPEGFixupTagsSubsamplingData"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "JPEGFixupTagsSubsamplingReadByte(struct JPEGFixupTagsSubsamplingData* data, uint8* result)",
          "fn_dec_pos": [
            [
              734,
              11
            ],
            [
              734,
              101
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGFixupTagsSubsamplingReadByte",
            "parameters": {
              "data": "struct JPEGFixupTagsSubsamplingData",
              "result": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "JPEGFixupTagsSubsamplingReadWord(struct JPEGFixupTagsSubsamplingData* data, uint16* result)",
          "fn_dec_pos": [
            [
              735,
              11
            ],
            [
              735,
              102
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGFixupTagsSubsamplingReadWord",
            "parameters": {
              "data": "struct JPEGFixupTagsSubsamplingData",
              "result": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "JPEGFixupTagsSubsamplingSkip(struct JPEGFixupTagsSubsamplingData* data, uint16 skiplength)",
          "fn_dec_pos": [
            [
              736,
              12
            ],
            [
              736,
              102
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "JPEGFixupTagsSubsamplingSkip",
            "parameters": {
              "data": "struct JPEGFixupTagsSubsamplingData",
              "skiplength": "uint16"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\tunion {\n\t\tstruct jpeg_compress_struct c;\n\t\tstruct jpeg_decompress_struct d;\n\t\tstruct jpeg_common_struct comm;\n\t} cinfo;\t\t\t/* NB: must be first */\n\tint             cinfo_initialized;\n\n\tjpeg_error_mgr\terr;\t\t/* libjpeg error manager */\n\tJMP_BUF\t\texit_jmpbuf;\t/* for catching libjpeg failures */\n\t\n\tstruct jpeg_progress_mgr progress;\n\t/*\n\t * The following two members could be a union, but\n\t * they're small enough that it's not worth the effort.\n\t */\n\tjpeg_destination_mgr dest;\t/* data dest for compression */\n\tjpeg_source_mgr\tsrc;\t\t/* data source for decompression */\n\t\t\t\t\t/* private state */\n\tTIFF*\t\ttif;\t\t/* back link needed by some code */\n\tuint16\t\tphotometric;\t/* copy of PhotometricInterpretation */\n\tuint16\t\th_sampling;\t/* luminance sampling factors */\n\tuint16\t\tv_sampling;\n\ttmsize_t   \tbytesperline;\t/* decompressed bytes per scanline */\n\t/* pointers to intermediate buffers when processing downsampled data */\n\tJSAMPARRAY\tds_buffer[MAX_COMPONENTS];\n\tint\t\tscancount;\t/* number of \"scanlines\" accumulated */\n\tint\t\tsamplesperclump;\n\n\tTIFFVGetMethod\tvgetparent;\t/* super-class method */\n\tTIFFVSetMethod\tvsetparent;\t/* super-class method */\n\tTIFFPrintMethod printdir;\t/* super-class method */\n\tTIFFStripMethod\tdefsparent;\t/* super-class method */\n\tTIFFTileMethod\tdeftparent;\t/* super-class method */\n\t\t\t\t\t/* pseudo-tag fields */\n\tvoid*\t\tjpegtables;\t/* JPEGTables tag value, or NULL */\n\tuint32\t\tjpegtables_length; /* number of bytes in same */\n\tint\t\tjpegquality;\t/* Compression quality level */\n\tint\t\tjpegcolormode;\t/* Auto RGB<=>YCbCr convert? */\n\tint\t\tjpegtablesmode;\t/* What to put in JPEGTables */\n\n        int             ycbcrsampling_fetched;\n        int             max_allowed_scan_number;\n} JPEGState;",
          {
            "cinfo": "union {\n\t\tstruct jpeg_compress_struct c;\n\t\tstruct jpeg_decompress_struct d;\n\t\tstruct jpeg_common_struct comm;\n\t}",
            "c": "struct jpeg_compress_struct",
            "d": "struct jpeg_decompress_struct",
            "comm": "struct jpeg_common_struct",
            "cinfo_initialized": "int",
            "err": "jpeg_error_mgr",
            "exit_jmpbuf": "JMP_BUF",
            "progress": "struct jpeg_progress_mgr",
            "dest": "jpeg_destination_mgr",
            "src": "jpeg_source_mgr",
            "*\t\ttif": "TIFF",
            "photometric": "uint16",
            "h_sampling": "uint16",
            "v_sampling": "uint16",
            "bytesperline": "tmsize_t",
            "ds_buffer[MAX_COMPONENTS]": "JSAMPARRAY",
            "scancount": "int",
            "samplesperclump": "int",
            "vgetparent": "TIFFVGetMethod",
            "vsetparent": "TIFFVSetMethod",
            "printdir": "TIFFPrintMethod",
            "defsparent": "TIFFStripMethod",
            "deftparent": "TIFFTileMethod",
            "*\t\tjpegtables": "void",
            "jpegtables_length": "uint32",
            "jpegquality": "int",
            "jpegcolormode": "int",
            "jpegtablesmode": "int",
            "ycbcrsampling_fetched": "int",
            "max_allowed_scan_number": "int"
          },
          "JPEGState",
          [
            138,
            0
          ],
          [
            181,
            12
          ]
        ],
        [
          "struct JPEGFixupTagsSubsamplingData\n{\n\tTIFF* tif;\n\tvoid* buffer;\n\tuint32 buffersize;\n\tuint8* buffercurrentbyte;\n\tuint32 bufferbytesleft;\n\tuint64 fileoffset;\n\tuint64 filebytesleft;\n\tuint8 filepositioned;\n}",
          {
            "* tif": "TIFF",
            "* buffer": "void",
            "buffersize": "uint32",
            "* buffercurrentbyte": "uint8",
            "bufferbytesleft": "uint32",
            "fileoffset": "uint64",
            "filebytesleft": "uint64",
            "filepositioned": "uint8"
          },
          "JPEGFixupTagsSubsamplingData",
          [
            721,
            0
          ],
          [
            731,
            1
          ]
        ],
        [
          "typedef struct jpeg_destination_mgr jpeg_destination_mgr;",
          {},
          "jpeg_destination_mgr",
          [
            121,
            0
          ],
          [
            121,
            57
          ]
        ],
        [
          "typedef struct jpeg_source_mgr jpeg_source_mgr;",
          {},
          "jpeg_source_mgr",
          [
            122,
            0
          ],
          [
            122,
            47
          ]
        ],
        [
          "typedef struct jpeg_error_mgr jpeg_error_mgr;",
          {},
          "jpeg_error_mgr",
          [
            123,
            0
          ],
          [
            123,
            45
          ]
        ],
        [
          "typedef struct {\n\tunion {\n\t\tstruct jpeg_compress_struct c;\n\t\tstruct jpeg_decompress_struct d;\n\t\tstruct jpeg_common_struct comm;\n\t} cinfo;\t\t\t/* NB: must be first */\n\tint             cinfo_initialized;\n\n\tjpeg_error_mgr\terr;\t\t/* libjpeg error manager */\n\tJMP_BUF\t\texit_jmpbuf;\t/* for catching libjpeg failures */\n\t\n\tstruct jpeg_progress_mgr progress;\n\t/*\n\t * The following two members could be a union, but\n\t * they're small enough that it's not worth the effort.\n\t */\n\tjpeg_destination_mgr dest;\t/* data dest for compression */\n\tjpeg_source_mgr\tsrc;\t\t/* data source for decompression */\n\t\t\t\t\t/* private state */\n\tTIFF*\t\ttif;\t\t/* back link needed by some code */\n\tuint16\t\tphotometric;\t/* copy of PhotometricInterpretation */\n\tuint16\t\th_sampling;\t/* luminance sampling factors */\n\tuint16\t\tv_sampling;\n\ttmsize_t   \tbytesperline;\t/* decompressed bytes per scanline */\n\t/* pointers to intermediate buffers when processing downsampled data */\n\tJSAMPARRAY\tds_buffer[MAX_COMPONENTS];\n\tint\t\tscancount;\t/* number of \"scanlines\" accumulated */\n\tint\t\tsamplesperclump;\n\n\tTIFFVGetMethod\tvgetparent;\t/* super-class method */\n\tTIFFVSetMethod\tvsetparent;\t/* super-class method */\n\tTIFFPrintMethod printdir;\t/* super-class method */\n\tTIFFStripMethod\tdefsparent;\t/* super-class method */\n\tTIFFTileMethod\tdeftparent;\t/* super-class method */\n\t\t\t\t\t/* pseudo-tag fields */\n\tvoid*\t\tjpegtables;\t/* JPEGTables tag value, or NULL */\n\tuint32\t\tjpegtables_length; /* number of bytes in same */\n\tint\t\tjpegquality;\t/* Compression quality level */\n\tint\t\tjpegcolormode;\t/* Auto RGB<=>YCbCr convert? */\n\tint\t\tjpegtablesmode;\t/* What to put in JPEGTables */\n\n        int             ycbcrsampling_fetched;\n        int             max_allowed_scan_number;\n} JPEGState;",
          {
            "cinfo": "union {\n\t\tstruct jpeg_compress_struct c;\n\t\tstruct jpeg_decompress_struct d;\n\t\tstruct jpeg_common_struct comm;\n\t}",
            "c": "struct jpeg_compress_struct",
            "d": "struct jpeg_decompress_struct",
            "comm": "struct jpeg_common_struct",
            "cinfo_initialized": "int",
            "err": "jpeg_error_mgr",
            "exit_jmpbuf": "JMP_BUF",
            "progress": "struct jpeg_progress_mgr",
            "dest": "jpeg_destination_mgr",
            "src": "jpeg_source_mgr",
            "*\t\ttif": "TIFF",
            "photometric": "uint16",
            "h_sampling": "uint16",
            "v_sampling": "uint16",
            "bytesperline": "tmsize_t",
            "ds_buffer[MAX_COMPONENTS]": "JSAMPARRAY",
            "scancount": "int",
            "samplesperclump": "int",
            "vgetparent": "TIFFVGetMethod",
            "vsetparent": "TIFFVSetMethod",
            "printdir": "TIFFPrintMethod",
            "defsparent": "TIFFStripMethod",
            "deftparent": "TIFFTileMethod",
            "*\t\tjpegtables": "void",
            "jpegtables_length": "uint32",
            "jpegquality": "int",
            "jpegcolormode": "int",
            "jpegtablesmode": "int",
            "ycbcrsampling_fetched": "int",
            "max_allowed_scan_number": "int"
          },
          "JPEGState",
          [
            138,
            0
          ],
          [
            181,
            12
          ]
        ],
        [
          "struct jpeg_compress_struct",
          {},
          "",
          [
            140,
            2
          ],
          [
            140,
            29
          ]
        ],
        [
          "struct jpeg_decompress_struct",
          {},
          "",
          [
            141,
            2
          ],
          [
            141,
            31
          ]
        ],
        [
          "struct jpeg_common_struct",
          {},
          "",
          [
            142,
            2
          ],
          [
            142,
            27
          ]
        ],
        [
          "struct jpeg_progress_mgr",
          {},
          "",
          [
            149,
            1
          ],
          [
            149,
            25
          ]
        ],
        [
          "struct JPEGFixupTagsSubsamplingData\n{\n\tTIFF* tif;\n\tvoid* buffer;\n\tuint32 buffersize;\n\tuint8* buffercurrentbyte;\n\tuint32 bufferbytesleft;\n\tuint64 fileoffset;\n\tuint64 filebytesleft;\n\tuint8 filepositioned;\n}",
          {
            "* tif": "TIFF",
            "* buffer": "void",
            "buffersize": "uint32",
            "* buffercurrentbyte": "uint8",
            "bufferbytesleft": "uint32",
            "fileoffset": "uint64",
            "filebytesleft": "uint64",
            "filepositioned": "uint8"
          },
          "JPEGFixupTagsSubsamplingData",
          [
            721,
            0
          ],
          [
            731,
            1
          ]
        ],
        [
          "struct JPEGFixupTagsSubsamplingData",
          {},
          "",
          [
            733,
            39
          ],
          [
            733,
            74
          ]
        ],
        [
          "struct JPEGFixupTagsSubsamplingData",
          {},
          "",
          [
            734,
            44
          ],
          [
            734,
            79
          ]
        ],
        [
          "struct JPEGFixupTagsSubsamplingData",
          {},
          "",
          [
            735,
            44
          ],
          [
            735,
            79
          ]
        ],
        [
          "struct JPEGFixupTagsSubsamplingData",
          {},
          "",
          [
            736,
            41
          ],
          [
            736,
            76
          ]
        ],
        [
          "struct JPEGFixupTagsSubsamplingData",
          {},
          "",
          [
            781,
            1
          ],
          [
            781,
            36
          ]
        ],
        [
          "struct JPEGFixupTagsSubsamplingData",
          {},
          "",
          [
            816,
            28
          ],
          [
            816,
            63
          ]
        ],
        [
          "struct JPEGFixupTagsSubsamplingData",
          {},
          "",
          [
            933,
            33
          ],
          [
            933,
            68
          ]
        ],
        [
          "struct JPEGFixupTagsSubsamplingData",
          {},
          "",
          [
            963,
            33
          ],
          [
            963,
            68
          ]
        ],
        [
          "struct JPEGFixupTagsSubsamplingData",
          {},
          "",
          [
            976,
            29
          ],
          [
            976,
            64
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <setjmp.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"jpeglib.h\"\n",
          [
            88,
            0
          ],
          [
            89,
            0
          ]
        ],
        [
          "#include \"jerror.h\"\n",
          [
            89,
            0
          ],
          [
            90,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_vms.c": {
      "fn_def_list": [
        {
          "fn_code": "void TIFFModeCCITTFax3(void){}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              48,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFModeCCITTFax3",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static tsize_t\n_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size)\n{\n\treturn (read((int) fd, buf, size));\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffReadProc",
            "parameters": {
              "fd": "thandle_t",
              "buf": "tdata_t",
              "size": "tsize_t"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "static tsize_t\n_tiffWriteProc(thandle_t fd, tdata_t buf, tsize_t size)\n{\n\treturn (write((int) fd, buf, size));\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              61,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffWriteProc",
            "parameters": {
              "fd": "thandle_t",
              "buf": "tdata_t",
              "size": "tsize_t"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "static toff_t\n_tiffSeekProc(thandle_t fd, toff_t off, int whence)\n{\n\treturn ((toff_t) _TIFF_lseek_f((int) fd, (_TIFF_off_t) off, whence));\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffSeekProc",
            "parameters": {
              "fd": "thandle_t",
              "off": "toff_t",
              "whence": "int"
            },
            "return_type": "toff_t"
          }
        },
        {
          "fn_code": "static int\n_tiffCloseProc(thandle_t fd)\n{\n\treturn (close((int) fd));\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              73,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffCloseProc",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static toff_t\n_tiffSizeProc(thandle_t fd)\n{\n\t_TIFF_stat_s sb;\n\treturn (toff_t) (_TIFF_fstat_f((int) fd, &sb) < 0 ? 0 : sb.st_size);\n}",
          "fn_code_pos": [
            [
              77,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffSizeProc",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "toff_t"
          }
        },
        {
          "fn_code": "static int\n_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)\n{\n\tchar name[256];\n\tstruct FAB fab;\n\tunsigned short channel;\n\tchar *inadr[2], *retadr[2];\n\tunsigned long status;\n\tlong size;\n\t\n\tif (no_mapped >= MAX_MAPPED)\n\t\treturn(0);\n\t/*\n\t * We cannot use a file descriptor, we\n\t * must open the file once more.\n\t */\n\tif (getname((int)fd, name, 1) == NULL)\n\t\treturn(0);\n\t/* prepare the FAB for a user file open */\n\tfab = cc$rms_fab;\n\tfab.fab$l_fop |= FAB$V_UFO;\n\tfab.fab$b_fac = FAB$M_GET;\n\tfab.fab$b_shr = FAB$M_SHRGET;\n\tfab.fab$l_fna = name;\n\tfab.fab$b_fns = strlen(name);\n\tstatus = sys$open(&fab);\t/* open file & get channel number */\n\tif ((status&1) == 0)\n\t\treturn(0);\n\tchannel = (unsigned short)fab.fab$l_stv;\n\tinadr[0] = inadr[1] = (char *)0; /* just an address in P0 space */\n\t/*\n\t * Map the blocks of the file up to\n\t * the EOF block into virtual memory.\n\t */\n\tsize = _tiffSizeProc(fd);\n\tstatus = sys$crmpsc(inadr, retadr, 0, SEC$M_EXPREG, 0,0,0, channel,\n\t\tTIFFhowmany(size,512), 0,0,0);  ddd\n\tif ((status&1) == 0){\n\t\tsys$dassgn(channel);\n\t\treturn(0);\n\t}\n\t*pbase = (tdata_t) retadr[0];\t/* starting virtual address */\n\t/*\n\t * Use the size of the file up to the\n\t * EOF mark for UNIX compatibility.\n\t */\n\t*psize = (toff_t) size;\n\t/* Record the section in the table */\n\tmap_table[no_mapped].base = retadr[0];\n\tmap_table[no_mapped].top = retadr[1];\n\tmap_table[no_mapped].channel = channel;\n\tno_mapped++;\n\n        return(1);\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffMapProc",
            "parameters": {
              "fd": "thandle_t",
              "pbase": "tdata_t",
              "psize": "toff_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\n_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size)\n{\n\tchar *inadr[2];\n\tint i, j;\n\t\n\t/* Find the section in the table */\n\tfor (i = 0;i < no_mapped; i++) {\n\t\tif (map_table[i].base == (char *) base) {\n\t\t\t/* Unmap the section */\n\t\t\tinadr[0] = (char *) base;\n\t\t\tinadr[1] = map_table[i].top;\n\t\t\tsys$deltva(inadr, 0, 0);\n\t\t\tsys$dassgn(map_table[i].channel);\n\t\t\t/* Remove this section from the list */\n\t\t\tfor (j = i+1; j < no_mapped; j++)\n\t\t\t\tmap_table[j-1] = map_table[j];\n\t\t\tno_mapped--;\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "fn_code_pos": [
            [
              175,
              0
            ],
            [
              196,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffUnmapProc",
            "parameters": {
              "fd": "thandle_t",
              "base": "tdata_t",
              "size": "toff_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\n_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)\n{\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              198,
              0
            ],
            [
              202,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffMapProc",
            "parameters": {
              "fd": "thandle_t",
              "pbase": "tdata_t",
              "psize": "toff_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\n_tiffUnmapProc(thandle_t fd, tdata_t base, toff_t size)\n{\n}",
          "fn_code_pos": [
            [
              204,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffUnmapProc",
            "parameters": {
              "fd": "thandle_t",
              "base": "tdata_t",
              "size": "toff_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFF*\nTIFFFdOpen(int fd, const char* name, const char* mode)\n{\n\tTIFF* tif;\n\n\ttif = TIFFClientOpen(name, mode,  ddd\n\t    (thandle_t) fd,\n\t    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,\n\t    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);\n\tif (tif)\n\t\ttif->tif_fd = fd;\n\treturn (tif);\n}",
          "fn_code_pos": [
            [
              213,
              0
            ],
            [
              225,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFdOpen",
            "parameters": {
              "fd": "int",
              "name": "char",
              "mode": "char"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "TIFF*\nTIFFOpen(const char* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpen\";\n\tint m, fd;\n\n\tm = _TIFFgetMode(mode, module);\n\tif (m == -1)\n\t\treturn ((TIFF*)0);\n        if (m&O_TRUNC){\n                /*\n\t\t * There is a bug in open in VAXC. If you use\n\t\t * open w/ m=O_RDWR|O_CREAT|O_TRUNC the\n\t\t * wrong thing happens.  On the other hand\n\t\t * creat does the right thing.\n                 */\n                fd = creat((char *) /* bug in stdio.h */ name, 0666,\n\t\t    \"alq = 128\", \"deq = 64\", \"mbc = 32\",\n\t\t    \"fop = tef\");\n\t} else if (m&O_RDWR) {\n\t\tfd = open(name, m, 0666,\n\t\t    \"deq = 64\", \"mbc = 32\", \"fop = tef\", \"ctx = stm\");\n\t} else\n\t\tfd = open(name, m, 0666, \"mbc = 32\", \"ctx = stm\");\n\tif (fd < 0) {\n\t\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\n\t\treturn ((TIFF*)0);\n\t}\n\treturn (TIFFFdOpen(fd, name, mode));\n}",
          "fn_code_pos": [
            [
              230,
              0
            ],
            [
              259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFOpen",
            "parameters": {
              "name": "char",
              "mode": "char"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "tdata_t\n_TIFFmalloc(tsize_t s)\n{\n        if (s == 0)\n                return ((void *) NULL);\n\n\treturn (malloc((size_t) s));\n}",
          "fn_code_pos": [
            [
              261,
              0
            ],
            [
              268,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmalloc",
            "parameters": {
              "s": "tsize_t"
            },
            "return_type": "tdata_t"
          }
        },
        {
          "fn_code": "void* _TIFFcalloc(tmsize_t nmemb, tmsize_t siz)\n{\n    if( nmemb == 0 || siz == 0 )\n        return ((void *) NULL);\n\n    return calloc((size_t) nmemb, (size_t)siz);\n}",
          "fn_code_pos": [
            [
              270,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFcalloc",
            "parameters": {
              "nmemb": "tmsize_t",
              "siz": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\n_TIFFfree(tdata_t p)\n{\n\tfree(p);\n}",
          "fn_code_pos": [
            [
              278,
              0
            ],
            [
              282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFfree",
            "parameters": {
              "p": "tdata_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "tdata_t\n_TIFFrealloc(tdata_t p, tsize_t s)\n{\n\treturn (realloc(p, (size_t) s));\n}",
          "fn_code_pos": [
            [
              284,
              0
            ],
            [
              288,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFrealloc",
            "parameters": {
              "p": "tdata_t",
              "s": "tsize_t"
            },
            "return_type": "tdata_t"
          }
        },
        {
          "fn_code": "void\n_TIFFmemset(tdata_t p, int v, tsize_t c)\n{\n\tmemset(p, v, (size_t) c);\n}",
          "fn_code_pos": [
            [
              290,
              0
            ],
            [
              294,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmemset",
            "parameters": {
              "p": "tdata_t",
              "v": "int",
              "c": "tsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\n_TIFFmemcpy(tdata_t d, const tdata_t s, tsize_t c)\n{\n\tmemcpy(d, s, (size_t) c);\n}",
          "fn_code_pos": [
            [
              296,
              0
            ],
            [
              300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmemcpy",
            "parameters": {
              "d": "tdata_t",
              "s": "tdata_t",
              "c": "tsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\n_TIFFmemcmp(const tdata_t p1, const tdata_t p2, tsize_t c)\n{\n\treturn (memcmp(p1, p2, (size_t) c));\n}",
          "fn_code_pos": [
            [
              302,
              0
            ],
            [
              306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmemcmp",
            "parameters": {
              "p1": "tdata_t",
              "p2": "tdata_t",
              "c": "tsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nvmsWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n\tif (module != NULL)\n\t\tfprintf(stderr, \"%s: \", module);\n\tfprintf(stderr, \"Warning, \");\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \".\\n\");\n}",
          "fn_code_pos": [
            [
              319,
              0
            ],
            [
              327,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "vmsWarningHandler",
            "parameters": {
              "module": "char",
              "fmt": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nvmsErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n\tif (module != NULL)\n\t\tfprintf(stderr, \"%s: \", module);\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \".\\n\");\n}",
          "fn_code_pos": [
            [
              335,
              0
            ],
            [
              342,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "vmsErrorHandler",
            "parameters": {
              "module": "char",
              "fmt": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "INLINE static void\nieeetod(double *dp)\n{\n\tdouble_t source;\n\tlong sign,exp,mant;\n\tdouble dmant;\n\n\tsource.ieee = ((double_t*)dp)->ieee;\n\tsign = source.ieee.sign;\n\texp = source.ieee.exp;\n\tmant = source.ieee.mant;\n\n\tif (exp == 2047) {\n\t\tif (mant)\t\t\t/* Not a Number (NAN) */\n\t\t\t*dp = HUGE_VAL;\n\t\telse\t\t\t\t/* +/- infinity */\n\t\t\t*dp = (sign ? -HUGE_VAL : HUGE_VAL);\n\t\treturn;\n\t}\n\tif (!exp) {\n\t\tif (!(mant || source.ieee.mant2)) {\t/* zero */\n\t\t\t*dp=0;\n\t\t\treturn;\n\t\t} else {\t\t\t/* Unnormalized number */\n\t\t\t/* NB: not -1023, the 1 bit is not implied */\n\t\t\texp= -1022;\n\t\t}\n\t} else {\n\t\tmant |= 1<<20;\n\t\texp -= 1023;\n\t}\n\tdmant = (((double) mant) +\n\t\t((double) source.ieee.mant2) / (((double) (1<<16)) *\n\t\t((double) (1<<16)))) / (double) (1<<20);\n\tdmant = ldexp(dmant, exp);\n\tif (sign)\n\t\tdmant= -dmant;\n\t*dp = dmant;\n}",
          "fn_code_pos": [
            [
              432,
              0
            ],
            [
              470,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ieeetod",
            "parameters": {
              "dp": "double"
            },
            "return_type": "INLINE"
          }
        },
        {
          "fn_code": "INLINE static void\ndtoieee(double *dp)\n{\n\tdouble_t num;\n\tdouble x;\n\tint exp;\n\n\tnum.d = *dp;\n\tif (!num.d) {\t\t\t/* Zero is just binary all zeros */\n\t\tnum.l[0] = num.l[1] = 0;\n\t\treturn;\n\t}\n\n\tif (num.d < 0) {\t\t/* Sign is encoded separately */\n\t\tnum.d = -num.d;\n\t\tnum.ieee.sign = 1;\n\t} else {\n\t\tnum.ieee.sign = 0;\n\t}\n\n\t/* Now separate the absolute value into mantissa and exponent */\n\tx = frexp(num.d, &exp);\n\n\t/*\n\t * Handle cases where the value is outside the\n\t * range for IEEE floating point numbers. \n\t * (Overflow cannot happen on a VAX, but underflow\n\t * can happen for G float.)\n\t */\n\tif (exp < -1022) {\t\t/* Unnormalized number */\n\t\tx = ldexp(x, -1023-exp);\n\t\texp = 0;\n\t} else if (exp > 1023) {\t/* +/- infinity */\n\t\tx = 0;\n\t\texp = 2047;\n\t} else {\t\t\t/* Get rid of most significant bit */\n\t\tx *= 2;\n\t\tx -= 1;\n\t\texp += 1022; /* fix NDR: 1.0 -> x=0.5, exp=1 -> ieee.exp = 1023 */\n\t}\n\tnum.ieee.exp = exp;\n\n\tx *= (double) (1<<20);\n\tnum.ieee.mant = (long) x;\n\tx -= (double) num.ieee.mant;\n\tnum.ieee.mant2 = (long) (x*((double) (1<<16)*(double) (1<<16)));\n\n\tif (!(num.ieee.mant || num.ieee.exp || num.ieee.mant2)) {\n\t\t/* Avoid negative zero */\n\t\tnum.ieee.sign = 0;\n\t}\n\t((double_t*)dp)->ieee = num.ieee;\n}",
          "fn_code_pos": [
            [
              472,
              0
            ],
            [
              524,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dtoieee",
            "parameters": {
              "dp": "double"
            },
            "return_type": "INLINE"
          }
        },
        {
          "fn_code": "void\nTIFFCvtIEEEFloatToNative(TIFF* tif, u_int n, float* f)\n{\n\tfloat_t* fp = (float_t*) f;\n\n\twhile (n-- > 0) {\n\t\tIEEEFLOAT2NATIVE(fp);\n\t\tfp++;\n\t}\n}",
          "fn_code_pos": [
            [
              559,
              0
            ],
            [
              568,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCvtIEEEFloatToNative",
            "parameters": {
              "tif": "TIFF",
              "n": "u_int",
              "f": "float"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFCvtNativeToIEEEFloat(TIFF* tif, u_int n, float* f)\n{\n\tfloat_t* fp = (float_t*) f;\n\n\twhile (n-- > 0) {\n\t\tNATIVE2IEEEFLOAT(fp);\n\t\tfp++;\n\t}\n}",
          "fn_code_pos": [
            [
              570,
              0
            ],
            [
              579,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCvtNativeToIEEEFloat",
            "parameters": {
              "tif": "TIFF",
              "n": "u_int",
              "f": "float"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFCvtIEEEDoubleToNative(TIFF* tif, u_int n, double* f)\n{\n\tdouble_t* fp = (double_t*) f;\n\n\twhile (n-- > 0) {\n\t\tIEEEDOUBLE2NATIVE(fp);\n\t\tfp++;\n\t}\n}",
          "fn_code_pos": [
            [
              580,
              0
            ],
            [
              589,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCvtIEEEDoubleToNative",
            "parameters": {
              "tif": "TIFF",
              "n": "u_int",
              "f": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFCvtNativeToIEEEDouble(TIFF* tif, u_int n, double* f)\n{\n\tdouble_t* fp = (double_t*) f;\n\n\twhile (n-- > 0) {\n\t\tNATIVE2IEEEDOUBLE(fp);\n\t\tfp++;\n\t}\n}",
          "fn_code_pos": [
            [
              591,
              0
            ],
            [
              600,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCvtNativeToIEEEDouble",
            "parameters": {
              "tif": "TIFF",
              "n": "u_int",
              "f": "double"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFFdOpen(int fd, const char* name, const char* mode)",
          "fn_dec_pos": [
            [
              214,
              0
            ],
            [
              214,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFdOpen",
            "parameters": {
              "fd": "int",
              "name": "char",
              "mode": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFOpen(const char* name, const char* mode)",
          "fn_dec_pos": [
            [
              231,
              0
            ],
            [
              231,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFOpen",
            "parameters": {
              "name": "char",
              "mode": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFcalloc(tmsize_t nmemb, tmsize_t siz)",
          "fn_dec_pos": [
            [
              270,
              6
            ],
            [
              270,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFcalloc",
            "parameters": {
              "nmemb": "tmsize_t",
              "siz": "tmsize_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct {\n\tchar *base;\n\tchar *top;\n\tunsigned short channel;\n}",
          {
            "*base": "char",
            "*top": "char",
            "channel": "unsigned short"
          },
          "",
          [
            95,
            7
          ],
          [
            99,
            1
          ]
        ],
        [
          "typedef\tstruct ieeedouble {\n\tunsigned long\tmant2;          /* fix NDR: full 8-byte swap */\n\tunsigned long\tmant\t: 20,\n\t\texp\t: 11,\n\t\tsign\t: 1;\n} ieeedouble;",
          {
            "mant2": "unsigned long",
            "mant": "unsigned long"
          },
          "ieeedouble",
          [
            354,
            0
          ],
          [
            359,
            13
          ]
        ],
        [
          "typedef\tstruct ieeefloat {\n\tunsigned long   mant\t: 23,\n\t\texp\t: 8,\n\t\tsign\t: 1;\n} ieeefloat;",
          {
            "mant": "unsigned long"
          },
          "ieeefloat",
          [
            360,
            0
          ],
          [
            364,
            12
          ]
        ],
        [
          "typedef\tstruct {\n\tunsigned long\tmant1\t: 7,\n\t\texp\t: 8,\n\t\tsign\t: 1,\n\t\tmant2\t: 16,\n\t\tmant3   : 16,\n\t\tmant4   : 16;\n} nativedouble;",
          {
            "mant1": "unsigned long"
          },
          "nativedouble",
          [
            371,
            0
          ],
          [
            378,
            15
          ]
        ],
        [
          "typedef\tstruct {\n\tunsigned long\tmant1\t: 7,\n\t\texp\t: 8,\n\t\tsign\t: 1,\n\t\tmant2\t: 16;\n} nativefloat;",
          {
            "mant1": "unsigned long"
          },
          "nativefloat",
          [
            379,
            0
          ],
          [
            384,
            14
          ]
        ],
        [
          "struct {\n\tchar *base;\n\tchar *top;\n\tunsigned short channel;\n}",
          {
            "*base": "char",
            "*top": "char",
            "channel": "unsigned short"
          },
          "",
          [
            95,
            7
          ],
          [
            99,
            1
          ]
        ],
        [
          "struct FAB",
          {},
          "",
          [
            118,
            1
          ],
          [
            118,
            11
          ]
        ],
        [
          "typedef\tstruct ieeedouble {\n\tunsigned long\tmant2;          /* fix NDR: full 8-byte swap */\n\tunsigned long\tmant\t: 20,\n\t\texp\t: 11,\n\t\tsign\t: 1;\n} ieeedouble;",
          {
            "mant2": "unsigned long",
            "mant": "unsigned long"
          },
          "ieeedouble",
          [
            354,
            0
          ],
          [
            359,
            13
          ]
        ],
        [
          "typedef\tstruct ieeefloat {\n\tunsigned long   mant\t: 23,\n\t\texp\t: 8,\n\t\tsign\t: 1;\n} ieeefloat;",
          {
            "mant": "unsigned long"
          },
          "ieeefloat",
          [
            360,
            0
          ],
          [
            364,
            12
          ]
        ],
        [
          "typedef\tstruct {\n\tunsigned long\tmant1\t: 7,\n\t\texp\t: 8,\n\t\tsign\t: 1,\n\t\tmant2\t: 16,\n\t\tmant3   : 16,\n\t\tmant4   : 16;\n} nativedouble;",
          {
            "mant1": "unsigned long"
          },
          "nativedouble",
          [
            371,
            0
          ],
          [
            378,
            15
          ]
        ],
        [
          "typedef\tstruct {\n\tunsigned long\tmant1\t: 7,\n\t\texp\t: 8,\n\t\tsign\t: 1,\n\t\tmant2\t: 16;\n} nativefloat;",
          {
            "mant1": "unsigned long"
          },
          "nativefloat",
          [
            379,
            0
          ],
          [
            384,
            14
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <unixio.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <sys/stat.h>\n",
          [
            75,
            0
          ],
          [
            76,
            0
          ]
        ],
        [
          "#include <starlet.h>\n",
          [
            85,
            0
          ],
          [
            86,
            0
          ]
        ],
        [
          "#include <fab.h>\n",
          [
            86,
            0
          ],
          [
            87,
            0
          ]
        ],
        [
          "#include <secdef.h>\n",
          [
            87,
            0
          ],
          [
            88,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_packbits.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nPackBitsPreEncode(TIFF* tif, uint16 s)\n{\n\t(void) s;\n\n        tif->tif_data = (uint8*)_TIFFmalloc(sizeof(tmsize_t));\n\tif (tif->tif_data == NULL)\n\t\treturn (0);\n\t/*\n\t * Calculate the scanline/tile-width size in bytes.\n\t */\n\tif (isTiled(tif))\n\t\t*(tmsize_t*)tif->tif_data = TIFFTileRowSize(tif);\n\telse\n\t\t*(tmsize_t*)tif->tif_data = TIFFScanlineSize(tif);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              33,
              0
            ],
            [
              49,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackBitsPreEncode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPackBitsPostEncode(TIFF* tif)\n{\n        if (tif->tif_data)\n            _TIFFfree(tif->tif_data);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              57,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackBitsPostEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPackBitsEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n{\n\tunsigned char* bp = (unsigned char*) buf;\n\tuint8* op;\n\tuint8* ep;\n\tuint8* lastliteral;\n\tlong n, slop;\n\tint b;\n\tenum { BASE, LITERAL, RUN, LITERAL_RUN } state;\n\n\t(void) s;\n\top = tif->tif_rawcp;\n\tep = tif->tif_rawdata + tif->tif_rawdatasize;\n\tstate = BASE;\n\tlastliteral = 0;\n\twhile (cc > 0) {\n\t\t/*\n\t\t * Find the longest string of identical bytes.\n\t\t */\n\t\tb = *bp++;\n\t\tcc--;\n\t\tn = 1;\n\t\tfor (; cc > 0 && b == *bp; cc--, bp++)\n\t\t\tn++;\n\tagain:\n\t\tif (op + 2 >= ep) {\t\t/* insure space for new data */\n\t\t\t/*\n\t\t\t * Be careful about writing the last\n\t\t\t * literal.  Must write up to that point\n\t\t\t * and then copy the remainder to the\n\t\t\t * front of the buffer.\n\t\t\t */\n\t\t\tif (state == LITERAL || state == LITERAL_RUN) {\n\t\t\t\tslop = (long)(op - lastliteral);\n\t\t\t\ttif->tif_rawcc += (tmsize_t)(lastliteral - tif->tif_rawcp);\n\t\t\t\tif (!TIFFFlushData1(tif))\n\t\t\t\t\treturn (0);\n\t\t\t\top = tif->tif_rawcp;\n\t\t\t\twhile (slop-- > 0)\n\t\t\t\t\t*op++ = *lastliteral++;\n\t\t\t\tlastliteral = tif->tif_rawcp;\n\t\t\t} else {\n\t\t\t\ttif->tif_rawcc += (tmsize_t)(op - tif->tif_rawcp);\n\t\t\t\tif (!TIFFFlushData1(tif))\n\t\t\t\t\treturn (0);\n\t\t\t\top = tif->tif_rawcp;\n\t\t\t}\n\t\t}\n\t\tswitch (state) {\n\t\tcase BASE:\t\t/* initial state, set run/literal */\n\t\t\tif (n > 1) {\n\t\t\t\tstate = RUN;\n\t\t\t\tif (n > 128) {\n\t\t\t\t\t*op++ = (uint8) -127;\n\t\t\t\t\t*op++ = (uint8) b;\n\t\t\t\t\tn -= 128;\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\t*op++ = (uint8)(-(n-1));\n\t\t\t\t*op++ = (uint8) b;\n\t\t\t} else {\n\t\t\t\tlastliteral = op;\n\t\t\t\t*op++ = 0;\n\t\t\t\t*op++ = (uint8) b;\n\t\t\t\tstate = LITERAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LITERAL:\t\t/* last object was literal string */\n\t\t\tif (n > 1) {\n\t\t\t\tstate = LITERAL_RUN;\n\t\t\t\tif (n > 128) {\n\t\t\t\t\t*op++ = (uint8) -127;\n\t\t\t\t\t*op++ = (uint8) b;\n\t\t\t\t\tn -= 128;\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\t*op++ = (uint8)(-(n-1));\t/* encode run */\n\t\t\t\t*op++ = (uint8) b;\n\t\t\t} else {\t\t\t/* extend literal */\n\t\t\t\tif (++(*lastliteral) == 127)\n\t\t\t\t\tstate = BASE;\n\t\t\t\t*op++ = (uint8) b;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RUN:\t\t/* last object was run */\n\t\t\tif (n > 1) {\n\t\t\t\tif (n > 128) {\n\t\t\t\t\t*op++ = (uint8) -127;\n\t\t\t\t\t*op++ = (uint8) b;\n\t\t\t\t\tn -= 128;\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\t\t\t\t*op++ = (uint8)(-(n-1));\n\t\t\t\t*op++ = (uint8) b;\n\t\t\t} else {\n\t\t\t\tlastliteral = op;\n\t\t\t\t*op++ = 0;\n\t\t\t\t*op++ = (uint8) b;\n\t\t\t\tstate = LITERAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LITERAL_RUN:\t/* literal followed by a run */\n\t\t\t/*\n\t\t\t * Check to see if previous run should\n\t\t\t * be converted to a literal, in which\n\t\t\t * case we convert literal-run-literal\n\t\t\t * to a single literal.\n\t\t\t */\n\t\t\tif (n == 1 && op[-2] == (uint8) -1 &&\n\t\t\t    *lastliteral < 126) {\n\t\t\t\tstate = (((*lastliteral) += 2) == 127 ?\n\t\t\t\t    BASE : LITERAL);\n\t\t\t\top[-2] = op[-1];\t/* replicate */\n\t\t\t} else\n\t\t\t\tstate = RUN;\n\t\t\tgoto again;\n\t\t}\n\t}\n\ttif->tif_rawcc += (tmsize_t)(op - tif->tif_rawcp);\n\ttif->tif_rawcp = op;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackBitsEncode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPackBitsEncodeChunk(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\ttmsize_t rowsize = *(tmsize_t*)tif->tif_data;\n\n\twhile (cc > 0) {\n\t\ttmsize_t chunk = rowsize;\n\t\t\n\t\tif( cc < chunk )\n\t\t    chunk = cc;\n\n\t\tif (PackBitsEncode(tif, bp, chunk, s) < 0)\n\t\t    return (-1);\n\t\tbp += chunk;\n\t\tcc -= chunk;\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              193,
              0
            ],
            [
              210,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackBitsEncodeChunk",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPackBitsDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"PackBitsDecode\";\n\tchar *bp;\n\ttmsize_t cc;\n\tlong n;\n\tint b;\n\n\t(void) s;\n\tbp = (char*) tif->tif_rawcp;\n\tcc = tif->tif_rawcc;\n\twhile (cc > 0 && occ > 0) {\n\t\tn = (long) *bp++;\n\t\tcc--;\n\t\t/*\n\t\t * Watch out for compilers that\n\t\t * don't sign extend chars...\n\t\t */\n\t\tif (n >= 128)\n\t\t\tn -= 256;\n\t\tif (n < 0) {\t\t/* replicate next byte -n+1 times */\n\t\t\tif (n == -128)\t/* nop */\n\t\t\t\tcontinue;\n\t\t\tn = -n + 1;\n\t\t\tif( occ < (tmsize_t)n )\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Discarding %lu bytes to avoid buffer overrun\",\n\t\t\t\t    (unsigned long) ((tmsize_t)n - occ));\n\t\t\t\tn = (long)occ;\n\t\t\t}\n\t\t\tif( cc == 0 )\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t       \"Terminating PackBitsDecode due to lack of data.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tocc -= n;\n\t\t\tb = *bp++;\n\t\t\tcc--;\n\t\t\twhile (n-- > 0)\n\t\t\t\t*op++ = (uint8) b;\n\t\t} else {\t\t/* copy next n+1 bytes literally */\n\t\t\tif (occ < (tmsize_t)(n + 1))\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Discarding %lu bytes to avoid buffer overrun\",\n\t\t\t\t    (unsigned long) ((tmsize_t)n - occ + 1));\n\t\t\t\tn = (long)occ - 1;\n\t\t\t}\n\t\t\tif (cc < (tmsize_t) (n+1)) \n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t       \"Terminating PackBitsDecode due to lack of data.\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t_TIFFmemcpy(op, bp, ++n);\n\t\t\top += n; occ -= n;\n\t\t\tbp += n; cc -= n;\n\t\t}\n\t}\n\ttif->tif_rawcp = (uint8*) bp;\n\ttif->tif_rawcc = cc;\n\tif (occ > 0) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Not enough data for scanline %lu\",\n\t\t    (unsigned long) tif->tif_row);\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              212,
              0
            ],
            [
              283,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PackBitsDecode",
            "parameters": {
              "tif": "TIFF",
              "op": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFInitPackBits(TIFF* tif, int scheme)\n{\n\t(void) scheme;\n\ttif->tif_decoderow = PackBitsDecode;\n\ttif->tif_decodestrip = PackBitsDecode;\n\ttif->tif_decodetile = PackBitsDecode;\n\ttif->tif_preencode = PackBitsPreEncode;\n\ttif->tif_postencode = PackBitsPostEncode;\n\ttif->tif_encoderow = PackBitsEncode;\n\ttif->tif_encodestrip = PackBitsEncodeChunk;\n\ttif->tif_encodetile = PackBitsEncodeChunk;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              285,
              0
            ],
            [
              298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitPackBits",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "enum { BASE, LITERAL, RUN, LITERAL_RUN }",
          {
            "BASE": "",
            "LITERAL": "",
            "RUN": "",
            "LITERAL_RUN": ""
          },
          "",
          [
            71,
            1
          ],
          [
            71,
            41
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_stream.cxx": {
      "fn_def_list": [
        {
          "fn_code": "static tmsize_t\n_tiffosReadProc(thandle_t, void*, tmsize_t)\n{\n        return 0;\n}",
          "fn_code_pos": [
            [
              106,
              0
            ],
            [
              110,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffosReadProc",
            "parameters": {},
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static tmsize_t\n_tiffisReadProc(thandle_t fd, void* buf, tmsize_t size)\n{\n        tiffis_data\t*data = reinterpret_cast<tiffis_data *>(fd);\n\n        // Verify that type does not overflow.\n        streamsize request_size = size;\n        if (static_cast<tmsize_t>(request_size) != size)\n          return static_cast<tmsize_t>(-1);\n\n        data->stream->read((char *) buf, request_size);\n\n        return static_cast<tmsize_t>(data->stream->gcount());\n}",
          "fn_code_pos": [
            [
              112,
              0
            ],
            [
              125,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffisReadProc",
            "parameters": {
              "fd": "thandle_t",
              "buf": "void",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static tmsize_t\n_tiffosWriteProc(thandle_t fd, void* buf, tmsize_t size)\n{\n\ttiffos_data\t*data = reinterpret_cast<tiffos_data *>(fd);\n\tostream\t\t*os = data->stream;\n\tios::pos_type\tpos = os->tellp();\n\n        // Verify that type does not overflow.\n        streamsize request_size = size;\n        if (static_cast<tmsize_t>(request_size) != size)\n          return static_cast<tmsize_t>(-1);\n\n\tos->write(reinterpret_cast<const char *>(buf), request_size);\n\n\treturn static_cast<tmsize_t>(os->tellp() - pos);\n}",
          "fn_code_pos": [
            [
              127,
              0
            ],
            [
              142,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffosWriteProc",
            "parameters": {
              "fd": "thandle_t",
              "buf": "void",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static tmsize_t\n_tiffisWriteProc(thandle_t, void*, tmsize_t)\n{\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              144,
              0
            ],
            [
              148,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffisWriteProc",
            "parameters": {},
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static uint64\n_tiffosSeekProc(thandle_t fd, uint64 off, int whence)\n{\n\ttiffos_data\t*data = reinterpret_cast<tiffos_data *>(fd);\n\tostream\t\t*os = data->stream;\n\n\t// if the stream has already failed, don't do anything\n\tif( os->fail() )\n\t\treturn static_cast<uint64>(-1);\n\n\tswitch(whence) {\n\tcase SEEK_SET:\n\t\t{\n\t\t\t// Compute 64-bit offset\n\t\t\tuint64 new_offset = static_cast<uint64>(data->start_pos) + off;\n\n\t\t\t// Verify that value does not overflow\n\t\t\tios::off_type offset = static_cast<ios::off_type>(new_offset);\n\t\t\tif (static_cast<uint64>(offset) != new_offset)\n\t\t\t\treturn static_cast<uint64>(-1);\n\t\t\t\n\t\t\tos->seekp(offset, ios::beg);\n\t\tbreak;\n\t\t}\n\tcase SEEK_CUR:\n\t\t{\n\t\t\t// Verify that value does not overflow\n\t\t\tios::off_type offset = static_cast<ios::off_type>(off);\n\t\t\tif (static_cast<uint64>(offset) != off)\n\t\t\t\treturn static_cast<uint64>(-1);\n\n\t\t\tos->seekp(offset, ios::cur);\n\t\t\tbreak;\n\t\t}\n\tcase SEEK_END:\n\t\t{\n\t\t\t// Verify that value does not overflow\n\t\t\tios::off_type offset = static_cast<ios::off_type>(off);\n\t\t\tif (static_cast<uint64>(offset) != off)\n\t\t\t\treturn static_cast<uint64>(-1);\n\n\t\t\tos->seekp(offset, ios::end);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Attempt to workaround problems with seeking past the end of the\n\t// stream.  ofstream doesn't have a problem with this but\n\t// ostrstream/ostringstream does. In that situation, add intermediate\n\t// '\\0' characters.\n\tif( os->fail() ) {\n#ifdef __VMS\n\t\tint\t\told_state;\n#else\n\t\tios::iostate\told_state;\n#endif\n\t\tios::pos_type\torigin;\n\n\t\told_state = os->rdstate();\n\t\t// reset the fail bit or else tellp() won't work below\n\t\tos->clear(os->rdstate() & ~ios::failbit);\n\t\tswitch( whence ) {\n\t\t\tcase SEEK_SET:\n                        default:\n\t\t\t\torigin = data->start_pos;\n\t\t\t\tbreak;\n\t\t\tcase SEEK_CUR:\n\t\t\t\torigin = os->tellp();\n\t\t\t\tbreak;\n\t\t\tcase SEEK_END:\n\t\t\t\tos->seekp(0, ios::end);\n\t\t\t\torigin = os->tellp();\n\t\t\t\tbreak;\n\t\t}\n\t\t// restore original stream state\n\t\tos->clear(old_state);\t\n\n\t\t// only do something if desired seek position is valid\n\t\tif( (static_cast<uint64>(origin) + off) > static_cast<uint64>(data->start_pos) ) {\n\t\t\tuint64\tnum_fill;\n\n\t\t\t// clear the fail bit \n\t\t\tos->clear(os->rdstate() & ~ios::failbit);\n\n\t\t\t// extend the stream to the expected size\n\t\t\tos->seekp(0, ios::end);\n\t\t\tnum_fill = (static_cast<uint64>(origin)) + off - os->tellp();\n\t\t\tfor( uint64 i = 0; i < num_fill; i++ )\n\t\t\t\tos->put('\\0');\n\n\t\t\t// retry the seek\n\t\t\tos->seekp(static_cast<ios::off_type>(static_cast<uint64>(origin) + off), ios::beg);\n\t\t}\n\t}\n\n\treturn static_cast<uint64>(os->tellp());\n}",
          "fn_code_pos": [
            [
              150,
              0
            ],
            [
              246,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffosSeekProc",
            "parameters": {
              "fd": "thandle_t",
              "off": "uint64",
              "whence": "int"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "static uint64\n_tiffisSeekProc(thandle_t fd, uint64 off, int whence)\n{\n\ttiffis_data\t*data = reinterpret_cast<tiffis_data *>(fd);\n\n\tswitch(whence) {\n\tcase SEEK_SET:\n\t\t{\n\t\t\t// Compute 64-bit offset\n\t\t\tuint64 new_offset = static_cast<uint64>(data->start_pos) + off;\n\t\t\t\n\t\t\t// Verify that value does not overflow\n\t\t\tios::off_type offset = static_cast<ios::off_type>(new_offset);\n\t\t\tif (static_cast<uint64>(offset) != new_offset)\n\t\t\t\treturn static_cast<uint64>(-1);\n\n\t\t\tdata->stream->seekg(offset, ios::beg);\n\t\t\tbreak;\n\t\t}\n\tcase SEEK_CUR:\n\t\t{\n\t\t\t// Verify that value does not overflow\n\t\t\tios::off_type offset = static_cast<ios::off_type>(off);\n\t\t\tif (static_cast<uint64>(offset) != off)\n\t\t\t\treturn static_cast<uint64>(-1);\n\n\t\t\tdata->stream->seekg(offset, ios::cur);\n\t\t\tbreak;\n\t\t}\n\tcase SEEK_END:\n\t\t{\n\t\t\t// Verify that value does not overflow\n\t\t\tios::off_type offset = static_cast<ios::off_type>(off);\n\t\t\tif (static_cast<uint64>(offset) != off)\n\t\t\t\treturn static_cast<uint64>(-1);\n\n\t\t\tdata->stream->seekg(offset, ios::end);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (uint64) (data->stream->tellg() - data->start_pos);\n}",
          "fn_code_pos": [
            [
              248,
              0
            ],
            [
              290,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffisSeekProc",
            "parameters": {
              "fd": "thandle_t",
              "off": "uint64",
              "whence": "int"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "static uint64\n_tiffosSizeProc(thandle_t fd)\n{\n\ttiffos_data\t*data = reinterpret_cast<tiffos_data *>(fd);\n\tostream\t\t*os = data->stream;\n\tios::pos_type\tpos = os->tellp();\n\tios::pos_type\tlen;\n\n\tos->seekp(0, ios::end);\n\tlen = os->tellp();\n\tos->seekp(pos);\n\n\treturn (uint64) len;\n}",
          "fn_code_pos": [
            [
              292,
              0
            ],
            [
              305,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffosSizeProc",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "static uint64\n_tiffisSizeProc(thandle_t fd)\n{\n\ttiffis_data\t*data = reinterpret_cast<tiffis_data *>(fd);\n\tios::pos_type\tpos = data->stream->tellg();\n\tios::pos_type\tlen;\n\n\tdata->stream->seekg(0, ios::end);\n\tlen = data->stream->tellg();\n\tdata->stream->seekg(pos);\n\n\treturn (uint64) len;\n}",
          "fn_code_pos": [
            [
              307,
              0
            ],
            [
              319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffisSizeProc",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "static int\n_tiffosCloseProc(thandle_t fd)\n{\n\t// Our stream was not allocated by us, so it shouldn't be closed by us.\n\tdelete reinterpret_cast<tiffos_data *>(fd);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              321,
              0
            ],
            [
              327,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffosCloseProc",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\n_tiffisCloseProc(thandle_t fd)\n{\n\t// Our stream was not allocated by us, so it shouldn't be closed by us.\n\tdelete reinterpret_cast<tiffis_data *>(fd);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              329,
              0
            ],
            [
              335,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffisCloseProc",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\n_tiffDummyMapProc(thandle_t , void** base, toff_t* size )\n{\n\t(void) base;\n\t(void) size;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              337,
              0
            ],
            [
              343,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffDummyMapProc",
            "parameters": {
              "base": "void",
              "size": "toff_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\n_tiffDummyUnmapProc(thandle_t , void* base, toff_t size )\n{\n\t(void) base;\n\t(void) size;\n}",
          "fn_code_pos": [
            [
              345,
              0
            ],
            [
              350,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffDummyUnmapProc",
            "parameters": {
              "base": "void",
              "size": "toff_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static TIFF*\n_tiffStreamOpen(const char* name, const char* mode, void *fd)\n{\n\tTIFF*\ttif;\n\n\tif( strchr(mode, 'w') ) {\n\t\ttiffos_data\t*data = new tiffos_data;\n\t\tdata->stream = reinterpret_cast<ostream *>(fd);\n\t\tdata->start_pos = data->stream->tellp();\n\n\t\t// Open for writing.\n\t\ttif = TIFFClientOpen(name, mode,\n\t\t\t\treinterpret_cast<thandle_t>(data),\n\t\t\t\t_tiffosReadProc,\n                                _tiffosWriteProc,\n\t\t\t\t_tiffosSeekProc,\n                                _tiffosCloseProc,\n\t\t\t\t_tiffosSizeProc,\n\t\t\t\t_tiffDummyMapProc,\n                                _tiffDummyUnmapProc);\n\t\tif (!tif) {\n\t\t\tdelete data;\n\t\t}\n\t} else {\n\t\ttiffis_data\t*data = new tiffis_data;\n\t\tdata->stream = reinterpret_cast<istream *>(fd);\n\t\tdata->start_pos = data->stream->tellg();\n\t\t// Open for reading.\n\t\ttif = TIFFClientOpen(name, mode,\n\t\t\t\treinterpret_cast<thandle_t>(data),\n\t\t\t\t_tiffisReadProc,\n                                _tiffisWriteProc,\n\t\t\t\t_tiffisSeekProc,\n                                _tiffisCloseProc,\n\t\t\t\t_tiffisSizeProc,\n\t\t\t\t_tiffDummyMapProc,\n                                _tiffDummyUnmapProc);\n\t\tif (!tif) {\n\t\t\tdelete data;\n\t\t}\n\t}\n\n\treturn (tif);\n}",
          "fn_code_pos": [
            [
              355,
              0
            ],
            [
              398,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffStreamOpen",
            "parameters": {
              "name": "char",
              "mode": "char",
              "fd": "void"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "TIFF*\nTIFFStreamOpen(const char* name, ostream *os)\n{\n\t// If os is either a ostrstream or ostringstream, and has no data\n\t// written to it yet, then tellp() will return -1 which will break us.\n\t// We workaround this by writing out a dummy character and\n\t// then seek back to the beginning.\n\tif( !os->fail() && static_cast<int>(os->tellp()) < 0 ) {\n\t\t*os << '\\0';\n\t\tos->seekp(0);\n\t}\n\n\t// NB: We don't support mapped files with streams so add 'm'\n\treturn _tiffStreamOpen(name, \"wm\", os);\n}",
          "fn_code_pos": [
            [
              402,
              0
            ],
            [
              416,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFStreamOpen",
            "parameters": {
              "name": "char",
              "os": "ostream"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "TIFF*\nTIFFStreamOpen(const char* name, istream *is)\n{\n\t// NB: We don't support mapped files with streams so add 'm'\n\treturn _tiffStreamOpen(name, \"rm\", is);\n}",
          "fn_code_pos": [
            [
              418,
              0
            ],
            [
              423,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFStreamOpen",
            "parameters": {
              "name": "char",
              "is": "istream"
            },
            "return_type": "TIFF"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "_tiffosReadProc(thandle_t, void*, tmsize_t)",
          "fn_dec_pos": [
            [
              80,
              17
            ],
            [
              80,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffosReadProc",
            "parameters": {},
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "_tiffisReadProc(thandle_t fd, void* buf, tmsize_t size)",
          "fn_dec_pos": [
            [
              81,
              17
            ],
            [
              81,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffisReadProc",
            "parameters": {
              "fd": "thandle_t",
              "buf": "void",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "_tiffosWriteProc(thandle_t fd, void* buf, tmsize_t size)",
          "fn_dec_pos": [
            [
              82,
              17
            ],
            [
              82,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffosWriteProc",
            "parameters": {
              "fd": "thandle_t",
              "buf": "void",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "_tiffisWriteProc(thandle_t, void*, tmsize_t)",
          "fn_dec_pos": [
            [
              83,
              17
            ],
            [
              83,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffisWriteProc",
            "parameters": {},
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "_tiffosSeekProc(thandle_t fd, uint64 off, int whence)",
          "fn_dec_pos": [
            [
              84,
              17
            ],
            [
              84,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffosSeekProc",
            "parameters": {
              "fd": "thandle_t",
              "off": "uint64",
              "whence": "int"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "_tiffisSeekProc(thandle_t fd, uint64 off, int whence)",
          "fn_dec_pos": [
            [
              85,
              17
            ],
            [
              85,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffisSeekProc",
            "parameters": {
              "fd": "thandle_t",
              "off": "uint64",
              "whence": "int"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "_tiffosSizeProc(thandle_t fd)",
          "fn_dec_pos": [
            [
              86,
              17
            ],
            [
              86,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffosSizeProc",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "_tiffisSizeProc(thandle_t fd)",
          "fn_dec_pos": [
            [
              87,
              17
            ],
            [
              87,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffisSizeProc",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "_tiffosCloseProc(thandle_t fd)",
          "fn_dec_pos": [
            [
              88,
              17
            ],
            [
              88,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffosCloseProc",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_tiffisCloseProc(thandle_t fd)",
          "fn_dec_pos": [
            [
              89,
              17
            ],
            [
              89,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffisCloseProc",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_tiffDummyMapProc(thandle_t , void** base, toff_t* size )",
          "fn_dec_pos": [
            [
              90,
              13
            ],
            [
              90,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffDummyMapProc",
            "parameters": {
              "base": "void",
              "size": "toff_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_tiffDummyUnmapProc(thandle_t , void* base, toff_t size )",
          "fn_dec_pos": [
            [
              91,
              17
            ],
            [
              91,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffDummyUnmapProc",
            "parameters": {
              "base": "void",
              "size": "toff_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_tiffStreamOpen(const char* name, const char* mode, void *fd)",
          "fn_dec_pos": [
            [
              92,
              17
            ],
            [
              92,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffStreamOpen",
            "parameters": {
              "name": "char",
              "mode": "char",
              "fd": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_tiffStreamOpen(const char* name, const char* mode, void *fd)",
          "fn_dec_pos": [
            [
              356,
              0
            ],
            [
              356,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffStreamOpen",
            "parameters": {
              "name": "char",
              "mode": "char",
              "fd": "void"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFStreamOpen(const char* name, ostream *os)",
          "fn_dec_pos": [
            [
              403,
              0
            ],
            [
              403,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFStreamOpen",
            "parameters": {
              "name": "char",
              "os": "ostream"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFStreamOpen(const char* name, istream *is)",
          "fn_dec_pos": [
            [
              419,
              0
            ],
            [
              419,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFStreamOpen",
            "parameters": {
              "name": "char",
              "is": "istream"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct tiffis_data\n{\n\tistream\t*stream;\n        ios::pos_type start_pos;\n}",
          {
            "*stream": "istream",
            "start_pos": "ios::pos_type"
          },
          "tiffis_data",
          [
            94,
            0
          ],
          [
            98,
            1
          ]
        ],
        [
          "struct tiffos_data\n{\n\tostream\t*stream;\n\tios::pos_type start_pos;\n}",
          {
            "*stream": "ostream",
            "start_pos": "ios::pos_type"
          },
          "tiffos_data",
          [
            100,
            0
          ],
          [
            104,
            1
          ]
        ],
        [
          "struct tiffis_data",
          {},
          "",
          [
            75,
            0
          ],
          [
            75,
            18
          ]
        ],
        [
          "struct tiffos_data",
          {},
          "",
          [
            76,
            0
          ],
          [
            76,
            18
          ]
        ],
        [
          "struct tiffis_data\n{\n\tistream\t*stream;\n        ios::pos_type start_pos;\n}",
          {
            "*stream": "istream",
            "start_pos": "ios::pos_type"
          },
          "tiffis_data",
          [
            94,
            0
          ],
          [
            98,
            1
          ]
        ],
        [
          "struct tiffos_data\n{\n\tostream\t*stream;\n\tios::pos_type start_pos;\n}",
          {
            "*stream": "ostream",
            "start_pos": "ios::pos_type"
          },
          "tiffos_data",
          [
            100,
            0
          ],
          [
            104,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <iostream>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_write.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nTIFFWriteScanline(TIFF* tif, void* buf, uint32 row, uint16 sample)\n{\n\tstatic const char module[] = \"TIFFWriteScanline\";\n\tregister TIFFDirectory *td;\n\tint status, imagegrew = 0;\n\tuint32 strip;\n\n\tif (!WRITECHECKSTRIPS(tif, module))\n\t\treturn (-1);\n\t/*\n\t * Handle delayed allocation of data buffer.  This\n\t * permits it to be sized more intelligently (using\n\t * directory information).\n\t */\n\tif (!BUFFERCHECK(tif))\n\t\treturn (-1);\n        tif->tif_flags |= TIFF_BUF4WRITE; /* not strictly sure this is right*/\n\n\ttd = &tif->tif_dir;\n\t/*\n\t * Extend image length if needed\n\t * (but only for PlanarConfig=1).\n\t */\n\tif (row >= td->td_imagelength) {\t/* extend image */\n\t\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Can not change \\\"ImageLength\\\" when using separate planes\");\n\t\t\treturn (-1);\n\t\t}\n\t\ttd->td_imagelength = row+1;\n\t\timagegrew = 1;\n\t}\n\t/*\n\t * Calculate strip and check for crossings.\n\t */\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE) {\n\t\tif (sample >= td->td_samplesperpixel) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"%lu: Sample out of range, max %lu\",\n\t\t\t    (unsigned long) sample, (unsigned long) td->td_samplesperpixel);\n\t\t\treturn (-1);\n\t\t}\n\t\tstrip = sample*td->td_stripsperimage + row/td->td_rowsperstrip;\n\t} else\n\t\tstrip = row / td->td_rowsperstrip;\n\t/*\n\t * Check strip array to make sure there's space. We don't support\n\t * dynamically growing files that have data organized in separate\n\t * bitplanes because it's too painful.  In that case we require that\n\t * the imagelength be set properly before the first write (so that the\n\t * strips array will be fully allocated above).\n\t */\n\tif (strip >= td->td_nstrips && !TIFFGrowStrips(tif, 1, module))\n\t\treturn (-1);\n\tif (strip != tif->tif_curstrip) {\n\t\t/*\n\t\t * Changing strips -- flush any data present.\n\t\t */\n\t\tif (!TIFFFlushData(tif))\n\t\t\treturn (-1);\n\t\ttif->tif_curstrip = strip;\n\t\t/*\n\t\t * Watch out for a growing image.  The value of strips/image\n\t\t * will initially be 1 (since it can't be deduced until the\n\t\t * imagelength is known).\n\t\t */\n\t\tif (strip >= td->td_stripsperimage && imagegrew)\n\t\t\ttd->td_stripsperimage =\n\t\t\t    TIFFhowmany_32(td->td_imagelength,td->td_rowsperstrip);\n                if (td->td_stripsperimage == 0) {\n                        TIFFErrorExt(tif->tif_clientdata, module, \"Zero strips per image\");\n                        return (-1);\n                }\n\t\ttif->tif_row =\n\t\t    (strip % td->td_stripsperimage) * td->td_rowsperstrip;\n\t\tif ((tif->tif_flags & TIFF_CODERSETUP) == 0) {\n\t\t\tif (!(*tif->tif_setupencode)(tif))\n\t\t\t\treturn (-1);\n\t\t\ttif->tif_flags |= TIFF_CODERSETUP;\n\t\t}\n        \n\t\ttif->tif_rawcc = 0;\n\t\ttif->tif_rawcp = tif->tif_rawdata;\n\n\t\tif( td->td_stripbytecount[strip] > 0 )\n\t\t{\n\t\t\t/* if we are writing over existing tiles, zero length */\n\t\t\ttd->td_stripbytecount[strip] = 0;\n\n\t\t\t/* this forces TIFFAppendToStrip() to do a seek */\n\t\t\ttif->tif_curoff = 0;\n\t\t}\n\n\t\tif (!(*tif->tif_preencode)(tif, sample))\n\t\t\treturn (-1);\n\t\ttif->tif_flags |= TIFF_POSTENCODE;\n\t}\n\t/*\n\t * Ensure the write is either sequential or at the\n\t * beginning of a strip (or that we can randomly\n\t * access the data -- i.e. no encoding).\n\t */\n\tif (row != tif->tif_row) {\n\t\tif (row < tif->tif_row) {\n\t\t\t/*\n\t\t\t * Moving backwards within the same strip:\n\t\t\t * backup to the start and then decode\n\t\t\t * forward (below).\n\t\t\t */\n\t\t\ttif->tif_row = (strip % td->td_stripsperimage) *\n\t\t\t    td->td_rowsperstrip;\n\t\t\ttif->tif_rawcp = tif->tif_rawdata;\n\t\t}\n\t\t/*\n\t\t * Seek forward to the desired row.\n\t\t */\n\t\tif (!(*tif->tif_seek)(tif, row - tif->tif_row))\n\t\t\treturn (-1);\n\t\ttif->tif_row = row;\n\t}\n\n\t/* swab if needed - note that source buffer will be altered */\n\ttif->tif_postdecode( tif, (uint8*) buf, tif->tif_scanlinesize );\n\n\tstatus = (*tif->tif_encoderow)(tif, (uint8*) buf,\n\t    tif->tif_scanlinesize, sample);\n\n        /* we are now poised at the beginning of the next row */\n\ttif->tif_row = row + 1;\n\treturn (status);\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              176,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteScanline",
            "parameters": {
              "tif": "TIFF",
              "buf": "void",
              "row": "uint32",
              "sample": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFWriteEncodedStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)\n{\n\tstatic const char module[] = \"TIFFWriteEncodedStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint16 sample;\n\n\tif (!WRITECHECKSTRIPS(tif, module))\n\t\treturn ((tmsize_t) -1);\n\t/*\n\t * Check strip array to make sure there's space.\n\t * We don't support dynamically growing files that\n\t * have data organized in separate bitplanes because\n\t * it's too painful.  In that case we require that\n\t * the imagelength be set properly before the first\n\t * write (so that the strips array will be fully\n\t * allocated above).\n\t */\n\tif (strip >= td->td_nstrips) {\n\t\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Can not grow image by strips when using separate planes\");\n\t\t\treturn ((tmsize_t) -1);\n\t\t}\n\t\tif (!TIFFGrowStrips(tif, 1, module))\n\t\t\treturn ((tmsize_t) -1);\n\t\ttd->td_stripsperimage =\n\t\t    TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip);  \n\t}\n\t/*\n\t * Handle delayed allocation of data buffer.  This\n\t * permits it to be sized according to the directory\n\t * info.\n\t */\n\tif (!BUFFERCHECK(tif))\n\t\treturn ((tmsize_t) -1);\n\n        tif->tif_flags |= TIFF_BUF4WRITE;\n\ttif->tif_curstrip = strip;\n\n        if (td->td_stripsperimage == 0) {\n                TIFFErrorExt(tif->tif_clientdata, module, \"Zero strips per image\");\n                return ((tmsize_t) -1);\n        }\n\n\ttif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;\n\tif ((tif->tif_flags & TIFF_CODERSETUP) == 0) {\n\t\tif (!(*tif->tif_setupencode)(tif))\n\t\t\treturn ((tmsize_t) -1);\n\t\ttif->tif_flags |= TIFF_CODERSETUP;\n\t}\n\n\tif( td->td_stripbytecount[strip] > 0 )\n        {\n            /* Make sure that at the first attempt of rewriting the tile, we will have */\n            /* more bytes available in the output buffer than the previous byte count, */\n            /* so that TIFFAppendToStrip() will detect the overflow when it is called the first */\n            /* time if the new compressed tile is bigger than the older one. (GDAL #4771) */\n            if( tif->tif_rawdatasize <= (tmsize_t)td->td_stripbytecount[strip] )\n            {\n                if( !(TIFFWriteBufferSetup(tif, NULL,\n                    (tmsize_t)TIFFroundup_64((uint64)(td->td_stripbytecount[strip] + 1), 1024))) )\n                    return ((tmsize_t)(-1));\n            }\n\n\t    /* Force TIFFAppendToStrip() to consider placing data at end\n               of file. */\n            tif->tif_curoff = 0;\n        }\n\n    tif->tif_rawcc = 0;\n    tif->tif_rawcp = tif->tif_rawdata;\n\n\ttif->tif_flags &= ~TIFF_POSTENCODE;\n\n    /* shortcut to avoid an extra memcpy() */\n    if( td->td_compression == COMPRESSION_NONE )\n    {\n        /* swab if needed - note that source buffer will be altered */\n        tif->tif_postdecode( tif, (uint8*) data, cc );\n\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits((uint8*) data, cc);\n\n        if (cc > 0 &&\n            !TIFFAppendToStrip(tif, strip, (uint8*) data, cc))\n            return ((tmsize_t) -1);\n        return (cc);\n    }\n\n\tsample = (uint16)(strip / td->td_stripsperimage);\n\tif (!(*tif->tif_preencode)(tif, sample))\n\t\treturn ((tmsize_t) -1);\n\n        /* swab if needed - note that source buffer will be altered */\n\ttif->tif_postdecode( tif, (uint8*) data, cc );\n\n\tif (!(*tif->tif_encodestrip)(tif, (uint8*) data, cc, sample))\n\t\treturn ((tmsize_t) -1);\n\tif (!(*tif->tif_postencode)(tif))\n\t\treturn ((tmsize_t) -1);\n\tif (!isFillOrder(tif, td->td_fillorder) &&\n\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\tTIFFReverseBits(tif->tif_rawdata, tif->tif_rawcc);\n\tif (tif->tif_rawcc > 0 &&\n\t    !TIFFAppendToStrip(tif, strip, tif->tif_rawdata, tif->tif_rawcc))\n\t\treturn ((tmsize_t) -1);\n\ttif->tif_rawcc = 0;\n\ttif->tif_rawcp = tif->tif_rawdata;\n\treturn (cc);\n}",
          "fn_code_pos": [
            [
              184,
              0
            ],
            [
              295,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteEncodedStrip",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32",
              "data": "void",
              "cc": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFWriteRawStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)\n{\n\tstatic const char module[] = \"TIFFWriteRawStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\tif (!WRITECHECKSTRIPS(tif, module))\n\t\treturn ((tmsize_t) -1);\n\t/*\n\t * Check strip array to make sure there's space.\n\t * We don't support dynamically growing files that\n\t * have data organized in separate bitplanes because\n\t * it's too painful.  In that case we require that\n\t * the imagelength be set properly before the first\n\t * write (so that the strips array will be fully\n\t * allocated above).\n\t */\n\tif (strip >= td->td_nstrips) {\n\t\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Can not grow image by strips when using separate planes\");\n\t\t\treturn ((tmsize_t) -1);\n\t\t}\n\t\t/*\n\t\t * Watch out for a growing image.  The value of\n\t\t * strips/image will initially be 1 (since it\n\t\t * can't be deduced until the imagelength is known).\n\t\t */\n\t\tif (strip >= td->td_stripsperimage)\n\t\t\ttd->td_stripsperimage =\n\t\t\t    TIFFhowmany_32(td->td_imagelength,td->td_rowsperstrip);\n\t\tif (!TIFFGrowStrips(tif, 1, module))\n\t\t\treturn ((tmsize_t) -1);\n\t}\n\ttif->tif_curstrip = strip;\n        if (td->td_stripsperimage == 0) {\n                TIFFErrorExt(tif->tif_clientdata, module,\"Zero strips per image\");\n                return ((tmsize_t) -1);\n        }\n\ttif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;\n\treturn (TIFFAppendToStrip(tif, strip, (uint8*) data, cc) ?\n\t    cc : (tmsize_t) -1);\n}",
          "fn_code_pos": [
            [
              302,
              0
            ],
            [
              344,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteRawStrip",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32",
              "data": "void",
              "cc": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFWriteTile(TIFF* tif, void* buf, uint32 x, uint32 y, uint32 z, uint16 s)\n{\n\tif (!TIFFCheckTile(tif, x, y, z, s))\n\t\treturn ((tmsize_t)(-1));\n\t/*\n\t * NB: A tile size of -1 is used instead of tif_tilesize knowing\n\t *     that TIFFWriteEncodedTile will clamp this to the tile size.\n\t *     This is done because the tile size may not be defined until\n\t *     after the output buffer is setup in TIFFWriteBufferSetup.\n\t */\n\treturn (TIFFWriteEncodedTile(tif,\n\t    TIFFComputeTile(tif, x, y, z, s), buf, (tmsize_t)(-1)));\n}",
          "fn_code_pos": [
            [
              350,
              0
            ],
            [
              363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteTile",
            "parameters": {
              "tif": "TIFF",
              "buf": "void",
              "x": "uint32",
              "y": "uint32",
              "z": "uint32",
              "s": "uint16"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFWriteEncodedTile(TIFF* tif, uint32 tile, void* data, tmsize_t cc)\n{\n\tstatic const char module[] = \"TIFFWriteEncodedTile\";\n\tTIFFDirectory *td;\n\tuint16 sample;\n        uint32 howmany32;\n\n\tif (!WRITECHECKTILES(tif, module))\n\t\treturn ((tmsize_t)(-1));\n\ttd = &tif->tif_dir;\n\tif (tile >= td->td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Tile %lu out of range, max %lu\",\n\t\t    (unsigned long) tile, (unsigned long) td->td_nstrips);\n\t\treturn ((tmsize_t)(-1));\n\t}\n\t/*\n\t * Handle delayed allocation of data buffer.  This\n\t * permits it to be sized more intelligently (using\n\t * directory information).\n\t */\n\tif (!BUFFERCHECK(tif))\n\t\treturn ((tmsize_t)(-1));\n\n        tif->tif_flags |= TIFF_BUF4WRITE;\n\ttif->tif_curtile = tile;\n\n\tif( td->td_stripbytecount[tile] > 0 )\n        {\n            /* Make sure that at the first attempt of rewriting the tile, we will have */\n            /* more bytes available in the output buffer than the previous byte count, */\n            /* so that TIFFAppendToStrip() will detect the overflow when it is called the first */\n            /* time if the new compressed tile is bigger than the older one. (GDAL #4771) */\n            if( tif->tif_rawdatasize <= (tmsize_t) td->td_stripbytecount[tile] )\n            {\n                if( !(TIFFWriteBufferSetup(tif, NULL,\n                    (tmsize_t)TIFFroundup_64((uint64)(td->td_stripbytecount[tile] + 1), 1024))) )\n                    return ((tmsize_t)(-1));\n            }\n\n\t    /* Force TIFFAppendToStrip() to consider placing data at end\n               of file. */\n            tif->tif_curoff = 0;\n        }\n\n\ttif->tif_rawcc = 0;\n\ttif->tif_rawcp = tif->tif_rawdata;\n\n\t/* \n\t * Compute tiles per row & per column to compute\n\t * current row and column\n\t */\n        howmany32=TIFFhowmany_32(td->td_imagelength, td->td_tilelength);\n        if (howmany32 == 0) {\n                 TIFFErrorExt(tif->tif_clientdata,module,\"Zero tiles\");\n                return ((tmsize_t)(-1));\n        }\n\ttif->tif_row = (tile % howmany32) * td->td_tilelength;\n        howmany32=TIFFhowmany_32(td->td_imagewidth, td->td_tilewidth);\n        if (howmany32 == 0) {\n                 TIFFErrorExt(tif->tif_clientdata,module,\"Zero tiles\");\n                return ((tmsize_t)(-1));\n        }\n\ttif->tif_col = (tile % howmany32) * td->td_tilewidth;\n\n\tif ((tif->tif_flags & TIFF_CODERSETUP) == 0) {\n\t\tif (!(*tif->tif_setupencode)(tif))\n\t\t\treturn ((tmsize_t)(-1));\n\t\ttif->tif_flags |= TIFF_CODERSETUP;\n\t}\n\ttif->tif_flags &= ~TIFF_POSTENCODE;\n\n\t/*\n\t * Clamp write amount to the tile size.  This is mostly\n\t * done so that callers can pass in some large number\n\t * (e.g. -1) and have the tile size used instead.\n\t */\n\tif ( cc < 1 || cc > tif->tif_tilesize)\n\t\tcc = tif->tif_tilesize;\n\n    /* shortcut to avoid an extra memcpy() */\n    if( td->td_compression == COMPRESSION_NONE )\n    {\n        /* swab if needed - note that source buffer will be altered */\n        tif->tif_postdecode( tif, (uint8*) data, cc );\n\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits((uint8*) data, cc);\n\n        if (cc > 0 &&\n            !TIFFAppendToStrip(tif, tile, (uint8*) data, cc))\n            return ((tmsize_t) -1);\n        return (cc);\n    }\n\n    sample = (uint16)(tile/td->td_stripsperimage);\n    if (!(*tif->tif_preencode)(tif, sample))\n        return ((tmsize_t)(-1));\n    /* swab if needed - note that source buffer will be altered */\n    tif->tif_postdecode( tif, (uint8*) data, cc );\n\n    if (!(*tif->tif_encodetile)(tif, (uint8*) data, cc, sample))\n            return ((tmsize_t) -1);\n    if (!(*tif->tif_postencode)(tif))\n            return ((tmsize_t)(-1));\n    if (!isFillOrder(tif, td->td_fillorder) &&\n        (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits((uint8*)tif->tif_rawdata, tif->tif_rawcc);\n    if (tif->tif_rawcc > 0 && !TIFFAppendToStrip(tif, tile,\n        tif->tif_rawdata, tif->tif_rawcc))\n            return ((tmsize_t)(-1));\n    tif->tif_rawcc = 0;\n    tif->tif_rawcp = tif->tif_rawdata;\n    return (cc);\n}",
          "fn_code_pos": [
            [
              377,
              0
            ],
            [
              492,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteEncodedTile",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32",
              "data": "void",
              "cc": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "tmsize_t\nTIFFWriteRawTile(TIFF* tif, uint32 tile, void* data, tmsize_t cc)\n{\n\tstatic const char module[] = \"TIFFWriteRawTile\";\n\n\tif (!WRITECHECKTILES(tif, module))\n\t\treturn ((tmsize_t)(-1));\n\tif (tile >= tif->tif_dir.td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Tile %lu out of range, max %lu\",\n\t\t    (unsigned long) tile,\n\t\t    (unsigned long) tif->tif_dir.td_nstrips);\n\t\treturn ((tmsize_t)(-1));\n\t}\n\treturn (TIFFAppendToStrip(tif, tile, (uint8*) data, cc) ?\n\t    cc : (tmsize_t)(-1));\n}",
          "fn_code_pos": [
            [
              503,
              0
            ],
            [
              518,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteRawTile",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32",
              "data": "void",
              "cc": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "int\nTIFFSetupStrips(TIFF* tif)\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\n\tif (isTiled(tif))\n\t\ttd->td_stripsperimage =\n\t\t    isUnspecified(tif, FIELD_TILEDIMENSIONS) ?\n\t\t\ttd->td_samplesperpixel : TIFFNumberOfTiles(tif);\n\telse\n\t\ttd->td_stripsperimage =\n\t\t    isUnspecified(tif, FIELD_ROWSPERSTRIP) ?\n\t\t\ttd->td_samplesperpixel : TIFFNumberOfStrips(tif);\n\ttd->td_nstrips = td->td_stripsperimage;\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\ttd->td_stripsperimage /= td->td_samplesperpixel;\n\ttd->td_stripoffset = (uint64 *)\n            _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint64),\n                             \"for \\\"StripOffsets\\\" array\");\n\ttd->td_stripbytecount = (uint64 *)\n            _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint64),\n                             \"for \\\"StripByteCounts\\\" array\");\n\tif (td->td_stripoffset == NULL || td->td_stripbytecount == NULL)\n\t\treturn (0);\n\t/*\n\t * Place data at the end-of-file\n\t * (by setting offsets to zero).\n\t */\n\t_TIFFmemset(td->td_stripoffset, 0, td->td_nstrips*sizeof (uint64));\n\t_TIFFmemset(td->td_stripbytecount, 0, td->td_nstrips*sizeof (uint64));\n\tTIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\n\tTIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              523,
              0
            ],
            [
              556,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetupStrips",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFWriteCheck(TIFF* tif, int tiles, const char* module)\n{\n\tif (tif->tif_mode == O_RDONLY) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"File not open for writing\");\n\t\treturn (0);\n\t}\n\tif (tiles ^ isTiled(tif)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, tiles ?\n\t\t    \"Can not write tiles to a stripped image\" :\n\t\t    \"Can not write scanlines to a tiled image\");\n\t\treturn (0);\n\t}\n\n        _TIFFFillStriles( tif );\n        \n\t/*\n\t * On the first write verify all the required information\n\t * has been setup and initialize any data structures that\n\t * had to wait until directory information was set.\n\t * Note that a lot of our work is assumed to remain valid\n\t * because we disallow any of the important parameters\n\t * from changing after we start writing (i.e. once\n\t * TIFF_BEENWRITING is set, TIFFSetField will only allow\n\t * the image's length to be changed).\n\t */\n\tif (!TIFFFieldSet(tif, FIELD_IMAGEDIMENSIONS)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Must set \\\"ImageWidth\\\" before writing data\");\n\t\treturn (0);\n\t}\n\tif (tif->tif_dir.td_samplesperpixel == 1) {\n\t\t/* \n\t\t * Planarconfiguration is irrelevant in case of single band\n\t\t * images and need not be included. We will set it anyway,\n\t\t * because this field is used in other parts of library even\n\t\t * in the single band case.\n\t\t */\n\t\tif (!TIFFFieldSet(tif, FIELD_PLANARCONFIG))\n                    tif->tif_dir.td_planarconfig = PLANARCONFIG_CONTIG;\n\t} else {\n\t\tif (!TIFFFieldSet(tif, FIELD_PLANARCONFIG)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Must set \\\"PlanarConfiguration\\\" before writing data\");\n\t\t\treturn (0);\n\t\t}\n\t}\n\tif (tif->tif_dir.td_stripoffset == NULL && !TIFFSetupStrips(tif)) {\n\t\ttif->tif_dir.td_nstrips = 0;\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"No space for %s arrays\",\n\t\t    isTiled(tif) ? \"tile\" : \"strip\");\n\t\treturn (0);\n\t}\n\tif (isTiled(tif))\n\t{\n\t\ttif->tif_tilesize = TIFFTileSize(tif);\n\t\tif (tif->tif_tilesize == 0)\n\t\t\treturn (0);\n\t}\n\telse\n\t\ttif->tif_tilesize = (tmsize_t)(-1);\n\ttif->tif_scanlinesize = TIFFScanlineSize(tif);\n\tif (tif->tif_scanlinesize == 0)\n\t\treturn (0);\n\ttif->tif_flags |= TIFF_BEENWRITING;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              565,
              0
            ],
            [
              631,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteCheck",
            "parameters": {
              "tif": "TIFF",
              "tiles": "int",
              "module": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFWriteBufferSetup(TIFF* tif, void* bp, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFWriteBufferSetup\";\n\n\tif (tif->tif_rawdata) {\n\t\tif (tif->tif_flags & TIFF_MYBUFFER) {\n\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\n\t\t}\n\t\ttif->tif_rawdata = NULL;\n\t}\n\tif (size == (tmsize_t)(-1)) {\n\t\tsize = (isTiled(tif) ?\n\t\t    tif->tif_tilesize : TIFFStripSize(tif));\n\t\t/*\n\t\t * Make raw data buffer at least 8K\n\t\t */\n\t\tif (size < 8*1024)\n\t\t\tsize = 8*1024;\n\t\tbp = NULL;\t\t\t/* NB: force malloc */\n\t}\n\tif (bp == NULL) {\n\t\tbp = _TIFFmalloc(size);\n\t\tif (bp == NULL) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"No space for output buffer\");\n\t\t\treturn (0);\n\t\t}\n\t\ttif->tif_flags |= TIFF_MYBUFFER;\n\t} else\n\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\n\ttif->tif_rawdata = (uint8*) bp;\n\ttif->tif_rawdatasize = size;\n\ttif->tif_rawcc = 0;\n\ttif->tif_rawcp = tif->tif_rawdata;\n\ttif->tif_flags |= TIFF_BUFFERSETUP;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              636,
              0
            ],
            [
              673,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteBufferSetup",
            "parameters": {
              "tif": "TIFF",
              "bp": "void",
              "size": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFGrowStrips(TIFF* tif, uint32 delta, const char* module)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64* new_stripoffset;\n\tuint64* new_stripbytecount;\n\n\tassert(td->td_planarconfig == PLANARCONFIG_CONTIG);\n\tnew_stripoffset = (uint64*)_TIFFrealloc(td->td_stripoffset,\n\t\t(td->td_nstrips + delta) * sizeof (uint64));\n\tnew_stripbytecount = (uint64*)_TIFFrealloc(td->td_stripbytecount,\n\t\t(td->td_nstrips + delta) * sizeof (uint64));\n\tif (new_stripoffset == NULL || new_stripbytecount == NULL) {\n\t\tif (new_stripoffset)\n\t\t\t_TIFFfree(new_stripoffset);\n\t\tif (new_stripbytecount)\n\t\t\t_TIFFfree(new_stripbytecount);\n\t\ttd->td_nstrips = 0;\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"No space to expand strip arrays\");\n\t\treturn (0);\n\t}\n\ttd->td_stripoffset = new_stripoffset;\n\ttd->td_stripbytecount = new_stripbytecount;\n\t_TIFFmemset(td->td_stripoffset + td->td_nstrips,\n\t\t    0, delta*sizeof (uint64));\n\t_TIFFmemset(td->td_stripbytecount + td->td_nstrips,\n\t\t    0, delta*sizeof (uint64));\n\ttd->td_nstrips += delta;\n        tif->tif_flags |= TIFF_DIRTYDIRECT;\n\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              678,
              0
            ],
            [
              709,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGrowStrips",
            "parameters": {
              "tif": "TIFF",
              "delta": "uint32",
              "module": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFAppendToStrip(TIFF* tif, uint32 strip, uint8* data, tmsize_t cc)\n{\n\tstatic const char module[] = \"TIFFAppendToStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64 m;\n        int64 old_byte_count = -1;\n\n\tif (td->td_stripoffset[strip] == 0 || tif->tif_curoff == 0) {\n            assert(td->td_nstrips > 0);\n\n            if( td->td_stripbytecount[strip] != 0 \n                && td->td_stripoffset[strip] != 0 \n                && td->td_stripbytecount[strip] >= (uint64) cc )\n            {\n                /* \n                 * There is already tile data on disk, and the new tile\n                 * data we have will fit in the same space.  The only \n                 * aspect of this that is risky is that there could be\n                 * more data to append to this strip before we are done\n                 * depending on how we are getting called.\n                 */\n                if (!SeekOK(tif, td->td_stripoffset[strip])) {\n                    TIFFErrorExt(tif->tif_clientdata, module,\n                                 \"Seek error at scanline %lu\",\n                                 (unsigned long)tif->tif_row);\n                    return (0);\n                }\n            }\n            else\n            {\n                /* \n                 * Seek to end of file, and set that as our location to \n                 * write this strip.\n                 */\n                td->td_stripoffset[strip] = TIFFSeekFile(tif, 0, SEEK_END);\n                tif->tif_flags |= TIFF_DIRTYSTRIP;\n            }\n\n            tif->tif_curoff = td->td_stripoffset[strip];\n\n            /*\n             * We are starting a fresh strip/tile, so set the size to zero.\n             */\n            old_byte_count = td->td_stripbytecount[strip];\n            td->td_stripbytecount[strip] = 0;\n\t}\n\n\tm = tif->tif_curoff+cc;\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\tm = (uint32)m;\n\tif ((m<tif->tif_curoff)||(m<(uint64)cc))\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Maximum TIFF file size exceeded\");\n\t\treturn (0);\n\t}\n\tif (!WriteOK(tif, data, cc)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Write error at scanline %lu\",\n\t\t    (unsigned long) tif->tif_row);\n\t\t    return (0);\n\t}\n\ttif->tif_curoff = m;\n\ttd->td_stripbytecount[strip] += cc;\n\n        if( (int64) td->td_stripbytecount[strip] != old_byte_count )\n            tif->tif_flags |= TIFF_DIRTYSTRIP;\n            \n\treturn (1);\n}",
          "fn_code_pos": [
            [
              714,
              0
            ],
            [
              782,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFAppendToStrip",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32",
              "data": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFFlushData1(TIFF* tif)\n{\n\tif (tif->tif_rawcc > 0 && tif->tif_flags & TIFF_BUF4WRITE ) {\n\t\tif (!isFillOrder(tif, tif->tif_dir.td_fillorder) &&\n\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\tTIFFReverseBits((uint8*)tif->tif_rawdata,\n\t\t\t    tif->tif_rawcc);\n\t\tif (!TIFFAppendToStrip(tif,\n\t\t    isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip,\n\t\t    tif->tif_rawdata, tif->tif_rawcc))\n        {\n            /* We update those variables even in case of error since there's */\n            /* code that doesn't really check the return code of this */\n            /* function */\n            tif->tif_rawcc = 0;\n            tif->tif_rawcp = tif->tif_rawdata;\n\t\t\treturn (0);\n        }\n\t\ttif->tif_rawcc = 0;\n\t\ttif->tif_rawcp = tif->tif_rawdata;\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              789,
              0
            ],
            [
              812,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFlushData1",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\nTIFFSetWriteOffset(TIFF* tif, toff_t off)\n{\n\ttif->tif_curoff = off;\n}",
          "fn_code_pos": [
            [
              820,
              0
            ],
            [
              824,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetWriteOffset",
            "parameters": {
              "tif": "TIFF",
              "off": "toff_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFGrowStrips(TIFF* tif, uint32 delta, const char* module)",
          "fn_dec_pos": [
            [
              42,
              11
            ],
            [
              42,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGrowStrips",
            "parameters": {
              "tif": "TIFF",
              "delta": "uint32",
              "module": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFAppendToStrip(TIFF* tif, uint32 strip, uint8* data, tmsize_t cc)",
          "fn_dec_pos": [
            [
              43,
              11
            ],
            [
              43,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFAppendToStrip",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32",
              "data": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_unix.c": {
      "fn_def_list": [
        {
          "fn_code": "static tmsize_t\n_tiffReadProc(thandle_t fd, void* buf, tmsize_t size)\n{\n\tfd_as_handle_union_t fdh;\n        const size_t bytes_total = (size_t) size;\n        size_t bytes_read;\n        tmsize_t count = -1;\n\tif ((tmsize_t) bytes_total != size)\n\t{\n\t\terrno=EINVAL;\n\t\treturn (tmsize_t) -1;\n\t}\n\tfdh.h = fd;\n        for (bytes_read=0; bytes_read < bytes_total; bytes_read+=count)\n        {\n                char *buf_offset = (char *) buf+bytes_read;\n                size_t io_size = bytes_total-bytes_read;\n                if (io_size > TIFF_IO_MAX)\n                        io_size = TIFF_IO_MAX;\n                count=read(fdh.fd, buf_offset, (TIFFIOSize_t) io_size);\n                if (count <= 0)\n                        break;\n        }\n        if (count < 0)\n                return (tmsize_t)-1;\n        return (tmsize_t) bytes_read;\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              91,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffReadProc",
            "parameters": {
              "fd": "thandle_t",
              "buf": "void",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static tmsize_t\n_tiffWriteProc(thandle_t fd, void* buf, tmsize_t size)\n{\n\tfd_as_handle_union_t fdh;\n\tconst size_t bytes_total = (size_t) size;\n        size_t bytes_written;\n        tmsize_t count = -1;\n\tif ((tmsize_t) bytes_total != size)\n\t{\n\t\terrno=EINVAL;\n\t\treturn (tmsize_t) -1;\n\t}\n\tfdh.h = fd;\n        for (bytes_written=0; bytes_written < bytes_total; bytes_written+=count)\n        {\n                const char *buf_offset = (char *) buf+bytes_written;\n                size_t io_size = bytes_total-bytes_written;\n                if (io_size > TIFF_IO_MAX)\n                        io_size = TIFF_IO_MAX;\n                count=write(fdh.fd, buf_offset, (TIFFIOSize_t) io_size);\n                if (count <= 0)\n                        break;\n        }\n        if (count < 0)\n                return (tmsize_t)-1;\n        return (tmsize_t) bytes_written;\n\t/* return ((tmsize_t) write(fdh.fd, buf, bytes_total)); */\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffWriteProc",
            "parameters": {
              "fd": "thandle_t",
              "buf": "void",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static uint64\n_tiffSeekProc(thandle_t fd, uint64 off, int whence)\n{\n\tfd_as_handle_union_t fdh;\n\t_TIFF_off_t off_io = (_TIFF_off_t) off;\n\tif ((uint64) off_io != off)\n\t{\n\t\terrno=EINVAL;\n\t\treturn (uint64) -1; /* this is really gross */\n\t}\n\tfdh.h = fd;\n\treturn((uint64)_TIFF_lseek_f(fdh.fd,off_io,whence));\n}",
          "fn_code_pos": [
            [
              122,
              0
            ],
            [
              134,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffSeekProc",
            "parameters": {
              "fd": "thandle_t",
              "off": "uint64",
              "whence": "int"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "static int\n_tiffCloseProc(thandle_t fd)\n{\n\tfd_as_handle_union_t fdh;\n\tfdh.h = fd;\n\treturn(close(fdh.fd));\n}",
          "fn_code_pos": [
            [
              136,
              0
            ],
            [
              142,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffCloseProc",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static uint64\n_tiffSizeProc(thandle_t fd)\n{\n\t_TIFF_stat_s sb;\n\tfd_as_handle_union_t fdh;\n\tfdh.h = fd;\n\tif (_TIFF_fstat_f(fdh.fd,&sb)<0)\n\t\treturn(0);\n\telse\n\t\treturn((uint64)sb.st_size);\n}",
          "fn_code_pos": [
            [
              144,
              0
            ],
            [
              154,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffSizeProc",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "static int\n_tiffMapProc(thandle_t fd, void** pbase, toff_t* psize)\n{\n\tuint64 size64 = _tiffSizeProc(fd);\n\ttmsize_t sizem = (tmsize_t)size64;\n\tif ((uint64)sizem==size64) {\n\t\tfd_as_handle_union_t fdh;\n\t\tfdh.h = fd;\n\t\t*pbase = (void*)\n\t\t    mmap(0, (size_t)sizem, PROT_READ, MAP_SHARED, fdh.fd, 0);\n\t\tif (*pbase != (void*) -1) {\n\t\t\t*psize = (tmsize_t)sizem;\n\t\t\treturn (1);\n\t\t}\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              159,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffMapProc",
            "parameters": {
              "fd": "thandle_t",
              "pbase": "void",
              "psize": "toff_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\n_tiffUnmapProc(thandle_t fd, void* base, toff_t size)\n{\n\t(void) fd;\n\t(void) munmap(base, (off_t) size);\n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              182,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffUnmapProc",
            "parameters": {
              "fd": "thandle_t",
              "base": "void",
              "size": "toff_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\n_tiffMapProc(thandle_t fd, void** pbase, toff_t* psize)\n{\n\t(void) fd; (void) pbase; (void) psize;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              184,
              0
            ],
            [
              189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffMapProc",
            "parameters": {
              "fd": "thandle_t",
              "pbase": "void",
              "psize": "toff_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\n_tiffUnmapProc(thandle_t fd, void* base, toff_t size)\n{\n\t(void) fd; (void) base; (void) size;\n}",
          "fn_code_pos": [
            [
              191,
              0
            ],
            [
              195,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffUnmapProc",
            "parameters": {
              "fd": "thandle_t",
              "base": "void",
              "size": "toff_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFF*\nTIFFFdOpen(int fd, const char* name, const char* mode)\n{\n\tTIFF* tif;\n\n\tfd_as_handle_union_t fdh;\n\tfdh.fd = fd;\n\ttif = TIFFClientOpen(name, mode,\n\t    fdh.h,\n\t    _tiffReadProc, _tiffWriteProc,\n\t    _tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n\t    _tiffMapProc, _tiffUnmapProc);\n\tif (tif)\n\t\ttif->tif_fd = fd;\n\treturn (tif);\n}",
          "fn_code_pos": [
            [
              201,
              0
            ],
            [
              216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFdOpen",
            "parameters": {
              "fd": "int",
              "name": "char",
              "mode": "char"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "TIFF*\nTIFFOpen(const char* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpen\";\n\tint m, fd;\n\tTIFF* tif;\n\n\tm = _TIFFgetMode(mode, module);\n\tif (m == -1)\n\t\treturn ((TIFF*)0);\n\n/* for cygwin and mingw */\n#ifdef O_BINARY\n\tm |= O_BINARY;\n#endif\n\n\tfd = open(name, m, 0666);\n\tif (fd < 0) {\n\t\tif (errno > 0 && strerror(errno) != NULL ) {\n\t\t\tTIFFErrorExt(0, module, \"%s: %s\", name, strerror(errno) );\n\t\t} else {\n\t\t\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\n\t\t}\n\t\treturn ((TIFF *)0);\n\t}\n\n\ttif = TIFFFdOpen((int)fd, name, mode);\n\tif(!tif)\n\t\tclose(fd);\n\treturn tif;\n}",
          "fn_code_pos": [
            [
              221,
              0
            ],
            [
              251,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFOpen",
            "parameters": {
              "name": "char",
              "mode": "char"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "TIFF*\nTIFFOpenW(const wchar_t* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpenW\";\n\tint m, fd;\n\tint mbsize;\n\tchar *mbname;\n\tTIFF* tif;\n\n\tm = _TIFFgetMode(mode, module);\n\tif (m == -1)\n\t\treturn ((TIFF*)0);\n\n/* for cygwin and mingw */\n#ifdef O_BINARY\n\tm |= O_BINARY;\n#endif\n\n\tfd = _wopen(name, m, 0666);\n\tif (fd < 0) {\n\t\tTIFFErrorExt(0, module, \"%ls: Cannot open\", name);\n\t\treturn ((TIFF *)0);\n\t}\n\n\tmbname = NULL;\n\tmbsize = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL);\n\tif (mbsize > 0) {\n\t\tmbname = _TIFFmalloc(mbsize);\n\t\tif (!mbname) {\n\t\t\tTIFFErrorExt(0, module,\n\t\t\t\"Can't allocate space for filename conversion buffer\");\n\t\t\treturn ((TIFF*)0);\n\t\t}\n\n\t\tWideCharToMultiByte(CP_ACP, 0, name, -1, mbname, mbsize,\n\t\t\t\t    NULL, NULL);\n\t}\n\n\ttif = TIFFFdOpen((int)fd, (mbname != NULL) ? mbname : \"<unknown>\",\n\t\t\t mode);\n\t\n\t_TIFFfree(mbname);\n\t\n\tif(!tif)\n\t\tclose(fd);\n\treturn tif;\n}",
          "fn_code_pos": [
            [
              258,
              0
            ],
            [
              304,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFOpenW",
            "parameters": {
              "name": "wchar_t",
              "mode": "char"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "void*\n_TIFFmalloc(tmsize_t s)\n{\n        if (s == 0)\n                return ((void *) NULL);\n\n\treturn (malloc((size_t) s));\n}",
          "fn_code_pos": [
            [
              307,
              0
            ],
            [
              314,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmalloc",
            "parameters": {
              "s": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void* _TIFFcalloc(tmsize_t nmemb, tmsize_t siz)\n{\n    if( nmemb == 0 || siz == 0 )\n        return ((void *) NULL);\n\n    return calloc((size_t) nmemb, (size_t)siz);\n}",
          "fn_code_pos": [
            [
              316,
              0
            ],
            [
              322,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFcalloc",
            "parameters": {
              "nmemb": "tmsize_t",
              "siz": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\n_TIFFfree(void* p)\n{\n\tfree(p);\n}",
          "fn_code_pos": [
            [
              324,
              0
            ],
            [
              328,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFfree",
            "parameters": {
              "p": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void*\n_TIFFrealloc(void* p, tmsize_t s)\n{\n\treturn (realloc(p, (size_t) s));\n}",
          "fn_code_pos": [
            [
              330,
              0
            ],
            [
              334,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFrealloc",
            "parameters": {
              "p": "void",
              "s": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\n_TIFFmemset(void* p, int v, tmsize_t c)\n{\n\tmemset(p, v, (size_t) c);\n}",
          "fn_code_pos": [
            [
              336,
              0
            ],
            [
              340,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmemset",
            "parameters": {
              "p": "void",
              "v": "int",
              "c": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\n_TIFFmemcpy(void* d, const void* s, tmsize_t c)\n{\n\tmemcpy(d, s, (size_t) c);\n}",
          "fn_code_pos": [
            [
              342,
              0
            ],
            [
              346,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmemcpy",
            "parameters": {
              "d": "void",
              "s": "void",
              "c": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\n_TIFFmemcmp(const void* p1, const void* p2, tmsize_t c)\n{\n\treturn (memcmp(p1, p2, (size_t) c));\n}",
          "fn_code_pos": [
            [
              348,
              0
            ],
            [
              352,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmemcmp",
            "parameters": {
              "p1": "void",
              "p2": "void",
              "c": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nunixWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n\tif (module != NULL)\n\t\tfprintf(stderr, \"%s: \", module);\n\tfprintf(stderr, \"Warning, \");\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \".\\n\");\n}",
          "fn_code_pos": [
            [
              354,
              0
            ],
            [
              362,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unixWarningHandler",
            "parameters": {
              "module": "char",
              "fmt": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nunixErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n\tif (module != NULL)\n\t\tfprintf(stderr, \"%s: \", module);\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \".\\n\");\n}",
          "fn_code_pos": [
            [
              365,
              0
            ],
            [
              372,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "unixErrorHandler",
            "parameters": {
              "module": "char",
              "fmt": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFFdOpen(int fd, const char* name, const char* mode)",
          "fn_dec_pos": [
            [
              202,
              0
            ],
            [
              202,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFdOpen",
            "parameters": {
              "fd": "int",
              "name": "char",
              "mode": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFOpen(const char* name, const char* mode)",
          "fn_dec_pos": [
            [
              222,
              0
            ],
            [
              222,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFOpen",
            "parameters": {
              "name": "char",
              "mode": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFOpenW(const wchar_t* name, const char* mode)",
          "fn_dec_pos": [
            [
              259,
              0
            ],
            [
              259,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFOpenW",
            "parameters": {
              "name": "wchar_t",
              "mode": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFmalloc(tmsize_t s)",
          "fn_dec_pos": [
            [
              308,
              0
            ],
            [
              308,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmalloc",
            "parameters": {
              "s": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFcalloc(tmsize_t nmemb, tmsize_t siz)",
          "fn_dec_pos": [
            [
              316,
              6
            ],
            [
              316,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFcalloc",
            "parameters": {
              "nmemb": "tmsize_t",
              "siz": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFrealloc(void* p, tmsize_t s)",
          "fn_dec_pos": [
            [
              331,
              0
            ],
            [
              331,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFrealloc",
            "parameters": {
              "p": "void",
              "s": "tmsize_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "# include <sys/types.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <sys/stat.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "# include <fcntl.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "# include <io.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include \"tiffiop.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <sys/mman.h>\n",
          [
            157,
            0
          ],
          [
            158,
            0
          ]
        ],
        [
          "#include <windows.h>\n",
          [
            254,
            0
          ],
          [
            255,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_zip.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nZIPFixupTags(TIFF* tif)\n{\n\t(void) tif;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              91,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZIPFixupTags",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nZIPSetupDecode(TIFF* tif)\n{\n\tstatic const char module[] = \"ZIPSetupDecode\";\n\tZIPState* sp = DecoderState(tif);\n\n\tassert(sp != NULL);\n        \n        /* if we were last encoding, terminate this mode */\n\tif (sp->state & ZSTATE_INIT_ENCODE) {\n\t    deflateEnd(&sp->stream);\n\t    sp->state = 0;\n\t}\n\n\t/* This function can possibly be called several times by */\n\t/* PredictorSetupDecode() if this function succeeds but */\n\t/* PredictorSetup() fails */\n\tif ((sp->state & ZSTATE_INIT_DECODE) == 0 &&\n\t    inflateInit(&sp->stream) != Z_OK) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s\", SAFE_MSG(sp));\n\t\treturn (0);\n\t} else {\n\t\tsp->state |= ZSTATE_INIT_DECODE;\n\t\treturn (1);\n\t}\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              118,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZIPSetupDecode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nZIPPreDecode(TIFF* tif, uint16 s)\n{\n\tZIPState* sp = DecoderState(tif);\n\n\t(void) s;\n\tassert(sp != NULL);\n\n\tif( (sp->state & ZSTATE_INIT_DECODE) == 0 )\n            tif->tif_setupdecode( tif );\n\n\tsp->stream.next_in = tif->tif_rawdata;\n\tassert(sizeof(sp->stream.avail_in)==4);  /* if this assert gets raised,\n\t    we need to simplify this code to reflect a ZLib that is likely updated\n\t    to deal with 8byte memory sizes, though this code will respond\n\t    appropriately even before we simplify it */\n\tsp->stream.avail_in = (uint64)tif->tif_rawcc < 0xFFFFFFFFU ? (uInt) tif->tif_rawcc : 0xFFFFFFFFU;\n\treturn (inflateReset(&sp->stream) == Z_OK);\n}",
          "fn_code_pos": [
            [
              123,
              0
            ],
            [
              141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZIPPreDecode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nZIPDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"ZIPDecode\";\n\tZIPState* sp = DecoderState(tif);\n\n\t(void) s;\n\tassert(sp != NULL);\n\tassert(sp->state == ZSTATE_INIT_DECODE);\n\n        sp->stream.next_in = tif->tif_rawcp;\n        \n\tsp->stream.next_out = op;\n\tassert(sizeof(sp->stream.avail_out)==4);  /* if this assert gets raised,\n\t    we need to simplify this code to reflect a ZLib that is likely updated\n\t    to deal with 8byte memory sizes, though this code will respond\n\t    appropriately even before we simplify it */\n\tdo {\n                int state;\n                uInt avail_in_before = (uint64)tif->tif_rawcc <= 0xFFFFFFFFU ? (uInt)tif->tif_rawcc : 0xFFFFFFFFU;\n                uInt avail_out_before = (uint64)occ < 0xFFFFFFFFU ? (uInt) occ : 0xFFFFFFFFU;\n                sp->stream.avail_in = avail_in_before;\n                sp->stream.avail_out = avail_out_before;\n\t\tstate = inflate(&sp->stream, Z_PARTIAL_FLUSH);\n\t\ttif->tif_rawcc -= (avail_in_before - sp->stream.avail_in);\n                occ -= (avail_out_before - sp->stream.avail_out);\n\t\tif (state == Z_STREAM_END)\n\t\t\tbreak;\n\t\tif (state == Z_DATA_ERROR) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Decoding error at scanline %lu, %s\",\n\t\t\t     (unsigned long) tif->tif_row, SAFE_MSG(sp));\n\t\t\t/* if (inflateSync(&sp->stream) != Z_OK) */\n\t\t\treturn (0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (state != Z_OK) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \n\t\t\t\t     \"ZLib error: %s\", SAFE_MSG(sp));\n\t\t\treturn (0);\n\t\t}\n\t} while (occ > 0);\n\tif (occ != 0) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Not enough data at scanline %lu (short \" TIFF_UINT64_FORMAT \" bytes)\",\n\t\t    (unsigned long) tif->tif_row, (TIFF_UINT64_T) occ);\n\t\treturn (0);\n\t}\n\n        tif->tif_rawcp = sp->stream.next_in;\n\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              143,
              0
            ],
            [
              195,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZIPDecode",
            "parameters": {
              "tif": "TIFF",
              "op": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nZIPSetupEncode(TIFF* tif)\n{\n\tstatic const char module[] = \"ZIPSetupEncode\";\n\tZIPState* sp = EncoderState(tif);\n\n\tassert(sp != NULL);\n\tif (sp->state & ZSTATE_INIT_DECODE) {\n\t\tinflateEnd(&sp->stream);\n\t\tsp->state = 0;\n\t}\n\n\tif (deflateInit(&sp->stream, sp->zipquality) != Z_OK) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s\", SAFE_MSG(sp));\n\t\treturn (0);\n\t} else {\n\t\tsp->state |= ZSTATE_INIT_ENCODE;\n\t\treturn (1);\n\t}\n}",
          "fn_code_pos": [
            [
              197,
              0
            ],
            [
              216,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZIPSetupEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nZIPPreEncode(TIFF* tif, uint16 s)\n{\n\tZIPState *sp = EncoderState(tif);\n\n\t(void) s;\n\tassert(sp != NULL);\n\tif( sp->state != ZSTATE_INIT_ENCODE )\n            tif->tif_setupencode( tif );\n\n\tsp->stream.next_out = tif->tif_rawdata;\n\tassert(sizeof(sp->stream.avail_out)==4);  /* if this assert gets raised,\n\t    we need to simplify this code to reflect a ZLib that is likely updated\n\t    to deal with 8byte memory sizes, though this code will respond\n\t    appropriately even before we simplify it */\n\tsp->stream.avail_out = (uint64)tif->tif_rawdatasize <= 0xFFFFFFFFU ? (uInt)tif->tif_rawdatasize : 0xFFFFFFFFU;\n\treturn (deflateReset(&sp->stream) == Z_OK);\n}",
          "fn_code_pos": [
            [
              221,
              0
            ],
            [
              238,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZIPPreEncode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nZIPEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\tstatic const char module[] = \"ZIPEncode\";\n\tZIPState *sp = EncoderState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->state == ZSTATE_INIT_ENCODE);\n\n\t(void) s;\n\tsp->stream.next_in = bp;\n\tassert(sizeof(sp->stream.avail_in)==4);  /* if this assert gets raised,\n\t    we need to simplify this code to reflect a ZLib that is likely updated\n\t    to deal with 8byte memory sizes, though this code will respond\n\t    appropriately even before we simplify it */\n\tdo {\n                uInt avail_in_before = (uint64)cc <= 0xFFFFFFFFU ? (uInt)cc : 0xFFFFFFFFU;\n                sp->stream.avail_in = avail_in_before;\n\t\tif (deflate(&sp->stream, Z_NO_FLUSH) != Z_OK) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \n\t\t\t\t     \"Encoder error: %s\",\n\t\t\t\t     SAFE_MSG(sp));\n\t\t\treturn (0);\n\t\t}\n\t\tif (sp->stream.avail_out == 0) {\n\t\t\ttif->tif_rawcc = tif->tif_rawdatasize;\n\t\t\tTIFFFlushData1(tif);\n\t\t\tsp->stream.next_out = tif->tif_rawdata;\n\t\t\tsp->stream.avail_out = (uint64)tif->tif_rawdatasize <= 0xFFFFFFFFU ? (uInt)tif->tif_rawdatasize : 0xFFFFFFFFU;\n\t\t}\n\t\tcc -= (avail_in_before - sp->stream.avail_in);\n\t} while (cc > 0);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              243,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZIPEncode",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nZIPPostEncode(TIFF* tif)\n{\n\tstatic const char module[] = \"ZIPPostEncode\";\n\tZIPState *sp = EncoderState(tif);\n\tint state;\n\n\tsp->stream.avail_in = 0;\n\tdo {\n\t\tstate = deflate(&sp->stream, Z_FINISH);\n\t\tswitch (state) {\n\t\tcase Z_STREAM_END:\n\t\tcase Z_OK:\n\t\t\tif ((tmsize_t)sp->stream.avail_out != tif->tif_rawdatasize)\n\t\t\t{\n\t\t\t\ttif->tif_rawcc =  tif->tif_rawdatasize - sp->stream.avail_out;\n\t\t\t\tTIFFFlushData1(tif);\n\t\t\t\tsp->stream.next_out = tif->tif_rawdata;\n\t\t\t\tsp->stream.avail_out = (uint64)tif->tif_rawdatasize <= 0xFFFFFFFFU ? (uInt)tif->tif_rawdatasize : 0xFFFFFFFFU;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \n\t\t\t\t     \"ZLib error: %s\", SAFE_MSG(sp));\n\t\t\treturn (0);\n\t\t}\n\t} while (state != Z_STREAM_END);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              282,
              0
            ],
            [
              310,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZIPPostEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nZIPCleanup(TIFF* tif)\n{\n\tZIPState* sp = ZState(tif);\n\n\tassert(sp != 0);\n\n\t(void)TIFFPredictorCleanup(tif);\n\n\ttif->tif_tagmethods.vgetfield = sp->vgetparent;\n\ttif->tif_tagmethods.vsetfield = sp->vsetparent;\n\n\tif (sp->state & ZSTATE_INIT_ENCODE) {\n\t\tdeflateEnd(&sp->stream);\n\t\tsp->state = 0;\n\t} else if( sp->state & ZSTATE_INIT_DECODE) {\n\t\tinflateEnd(&sp->stream);\n\t\tsp->state = 0;\n\t}\n\t_TIFFfree(sp);\n\ttif->tif_data = NULL;\n\n\t_TIFFSetDefaultCompressionState(tif);\n}",
          "fn_code_pos": [
            [
              312,
              0
            ],
            [
              335,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZIPCleanup",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nZIPVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tstatic const char module[] = \"ZIPVSetField\";\n\tZIPState* sp = ZState(tif);\n\n\tswitch (tag) {\n\tcase TIFFTAG_ZIPQUALITY:\n\t\tsp->zipquality = (int) va_arg(ap, int);\n\t\tif ( sp->state&ZSTATE_INIT_ENCODE ) {\n\t\t\tif (deflateParams(&sp->stream,\n\t\t\t    sp->zipquality, Z_DEFAULT_STRATEGY) != Z_OK) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"ZLib error: %s\",\n\t\t\t\t\t     SAFE_MSG(sp));\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\treturn (1);\n\tdefault:\n\t\treturn (*sp->vsetparent)(tif, tag, ap);\n\t}\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              337,
              0
            ],
            [
              359,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZIPVSetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nZIPVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tZIPState* sp = ZState(tif);\n\n\tswitch (tag) {\n\tcase TIFFTAG_ZIPQUALITY:\n\t\t*va_arg(ap, int*) = sp->zipquality;\n\t\tbreak;\n\tdefault:\n\t\treturn (*sp->vgetparent)(tif, tag, ap);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              361,
              0
            ],
            [
              374,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZIPVGetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFInitZIP(TIFF* tif, int scheme)\n{\n\tstatic const char module[] = \"TIFFInitZIP\";\n\tZIPState* sp;\n\n\tassert( (scheme == COMPRESSION_DEFLATE)\n\t\t|| (scheme == COMPRESSION_ADOBE_DEFLATE));\n\n\t/*\n\t * Merge codec-specific tag information.\n\t */\n\tif (!_TIFFMergeFields(tif, zipFields, TIFFArrayCount(zipFields))) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Merging Deflate codec-specific tags failed\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate state block so tag methods have storage to record values.\n\t */\n\ttif->tif_data = (uint8*) _TIFFmalloc(sizeof (ZIPState));\n\tif (tif->tif_data == NULL)\n\t\tgoto bad;\n\tsp = ZState(tif);\n\tsp->stream.zalloc = NULL;\n\tsp->stream.zfree = NULL;\n\tsp->stream.opaque = NULL;\n\tsp->stream.data_type = Z_BINARY;\n\n\t/*\n\t * Override parent get/set field methods.\n\t */\n\tsp->vgetparent = tif->tif_tagmethods.vgetfield;\n\ttif->tif_tagmethods.vgetfield = ZIPVGetField; /* hook for codec tags */\n\tsp->vsetparent = tif->tif_tagmethods.vsetfield;\n\ttif->tif_tagmethods.vsetfield = ZIPVSetField; /* hook for codec tags */\n\n\t/* Default values for codec-specific fields */\n\tsp->zipquality = Z_DEFAULT_COMPRESSION;\t/* default comp. level */\n\tsp->state = 0;\n\n\t/*\n\t * Install codec methods.\n\t */\n\ttif->tif_fixuptags = ZIPFixupTags; \n\ttif->tif_setupdecode = ZIPSetupDecode;\n\ttif->tif_predecode = ZIPPreDecode;\n\ttif->tif_decoderow = ZIPDecode;\n\ttif->tif_decodestrip = ZIPDecode;\n\ttif->tif_decodetile = ZIPDecode;  \n\ttif->tif_setupencode = ZIPSetupEncode;\n\ttif->tif_preencode = ZIPPreEncode;\n\ttif->tif_postencode = ZIPPostEncode;\n\ttif->tif_encoderow = ZIPEncode;\n\ttif->tif_encodestrip = ZIPEncode;\n\ttif->tif_encodetile = ZIPEncode;\n\ttif->tif_cleanup = ZIPCleanup;\n\t/*\n\t * Setup predictor setup.\n\t */\n\t(void) TIFFPredictorInit(tif);\n\treturn (1);\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"No space for ZIP state block\");\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              380,
              0
            ],
            [
              447,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitZIP",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "ZIPEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              83,
              11
            ],
            [
              83,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZIPEncode",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "ZIPDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)",
          "fn_dec_pos": [
            [
              84,
              11
            ],
            [
              84,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ZIPDecode",
            "parameters": {
              "tif": "TIFF",
              "op": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\tTIFFPredictorState predict;\n        z_stream        stream;\n\tint             zipquality;            /* compression level */\n\tint             state;                 /* state flags */\n#define ZSTATE_INIT_DECODE 0x01\n#define ZSTATE_INIT_ENCODE 0x02\n\n\tTIFFVGetMethod  vgetparent;            /* super-class method */\n\tTIFFVSetMethod  vsetparent;            /* super-class method */\n} ZIPState;",
          {
            "predict": "TIFFPredictorState",
            "stream": "z_stream",
            "zipquality": "int",
            "state": "int",
            "vgetparent": "TIFFVGetMethod",
            "vsetparent": "TIFFVSetMethod"
          },
          "ZIPState",
          [
            67,
            0
          ],
          [
            77,
            11
          ]
        ],
        [
          "typedef struct {\n\tTIFFPredictorState predict;\n        z_stream        stream;\n\tint             zipquality;            /* compression level */\n\tint             state;                 /* state flags */\n#define ZSTATE_INIT_DECODE 0x01\n#define ZSTATE_INIT_ENCODE 0x02\n\n\tTIFFVGetMethod  vgetparent;            /* super-class method */\n\tTIFFVSetMethod  vsetparent;            /* super-class method */\n} ZIPState;",
          {
            "predict": "TIFFPredictorState",
            "stream": "z_stream",
            "zipquality": "int",
            "state": "int",
            "vgetparent": "TIFFVGetMethod",
            "vsetparent": "TIFFVSetMethod"
          },
          "ZIPState",
          [
            67,
            0
          ],
          [
            77,
            11
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"tif_predict.h\"\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include \"zlib.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/mkspans.c": {
      "fn_def_list": [
        {
          "fn_code": "main()\n{\n\tunsigned char runs[2][256];\n\n\tmemset(runs[0], 0, 256*sizeof (char));\n\tmemset(runs[1], 0, 256*sizeof (char));\n\t{ register int run, runlen, i;\n\t  runlen = 1;\n\t  for (run = 0x80; run != 0xff; run = (run>>1)|0x80) {\n\t\tfor (i = run-1; i >= 0; i--) {\n\t\t\truns[1][run|i] = runlen;\n\t\t\truns[0][(~(run|i)) & 0xff] = runlen;\n\t\t}\n\t\trunlen++;\n\t  }\n\t  runs[1][0xff] = runs[0][0] = 8;\n\t}\n\tdumparray(\"bruns\", runs[0]);\n\tdumparray(\"wruns\", runs[1]);\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <string.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_dir.c": {
      "fn_def_list": [
        {
          "fn_code": "static void\nsetByteArray(void** vpp, void* vp, size_t nmemb, size_t elem_size)\n{\n\tif (*vpp) {\n\t\t_TIFFfree(*vpp);\n\t\t*vpp = 0;\n\t}\n\tif (vp) {\n\t\ttmsize_t bytes = (tmsize_t)(nmemb * elem_size);\n\t\tif (elem_size && bytes / elem_size == nmemb)\n\t\t\t*vpp = (void*) _TIFFmalloc(bytes);\n\t\tif (*vpp)\n\t\t\t_TIFFmemcpy(*vpp, vp, bytes);\n\t}\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              54,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setByteArray",
            "parameters": {
              "vpp": "void",
              "vp": "void",
              "nmemb": "size_t",
              "elem_size": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _TIFFsetByteArray(void** vpp, void* vp, uint32 n)\n    { setByteArray(vpp, vp, n, 1); }",
          "fn_code_pos": [
            [
              55,
              0
            ],
            [
              56,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFsetByteArray",
            "parameters": {
              "vpp": "void",
              "vp": "void",
              "n": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _TIFFsetString(char** cpp, char* cp)\n    { setByteArray((void**) cpp, (void*) cp, strlen(cp)+1, 1); }",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              58,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFsetString",
            "parameters": {
              "cpp": "char",
              "cp": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void _TIFFsetNString(char** cpp, char* cp, uint32 n)\n    { setByteArray((void**) cpp, (void*) cp, n, 1); }",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              60,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFsetNString",
            "parameters": {
              "cpp": "char",
              "cp": "char",
              "n": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _TIFFsetShortArray(uint16** wpp, uint16* wp, uint32 n)\n    { setByteArray((void**) wpp, (void*) wp, n, sizeof (uint16)); }",
          "fn_code_pos": [
            [
              61,
              0
            ],
            [
              62,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFsetShortArray",
            "parameters": {
              "wpp": "uint16",
              "wp": "uint16",
              "n": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _TIFFsetLongArray(uint32** lpp, uint32* lp, uint32 n)\n    { setByteArray((void**) lpp, (void*) lp, n, sizeof (uint32)); }",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              64,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFsetLongArray",
            "parameters": {
              "lpp": "uint32",
              "lp": "uint32",
              "n": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void _TIFFsetLong8Array(uint64** lpp, uint64* lp, uint32 n)\n    { setByteArray((void**) lpp, (void*) lp, n, sizeof (uint64)); }",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              66,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFsetLong8Array",
            "parameters": {
              "lpp": "uint64",
              "lp": "uint64",
              "n": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _TIFFsetFloatArray(float** fpp, float* fp, uint32 n)\n    { setByteArray((void**) fpp, (void*) fp, n, sizeof (float)); }",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              68,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFsetFloatArray",
            "parameters": {
              "fpp": "float",
              "fp": "float",
              "n": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void _TIFFsetDoubleArray(double** dpp, double* dp, uint32 n)\n    { setByteArray((void**) dpp, (void*) dp, n, sizeof (double)); }",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              70,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFsetDoubleArray",
            "parameters": {
              "dpp": "double",
              "dp": "double",
              "n": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nsetDoubleArrayOneValue(double** vpp, double value, size_t nmemb)\n{\n\tif (*vpp)\n\t\t_TIFFfree(*vpp);\n\t*vpp = _TIFFmalloc(nmemb*sizeof(double));\n\tif (*vpp)\n\t{\n\t\twhile (nmemb--)\n\t\t\t((double*)*vpp)[nmemb] = value;\n\t}\n}",
          "fn_code_pos": [
            [
              72,
              0
            ],
            [
              83,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setDoubleArrayOneValue",
            "parameters": {
              "vpp": "double",
              "value": "double",
              "nmemb": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nsetExtraSamples(TIFF* tif, va_list ap, uint32* v)\n{\n/* XXX: Unassociated alpha data == 999 is a known Corel Draw bug, see below */\n#define EXTRASAMPLE_COREL_UNASSALPHA 999 \n\n\tuint16* va;\n\tuint32 i;\n        TIFFDirectory* td = &tif->tif_dir;\n        static const char module[] = \"setExtraSamples\";\n\n\t*v = (uint16) va_arg(ap, uint16_vap);\n\tif ((uint16) *v > td->td_samplesperpixel)\n\t\treturn 0;\n\tva = va_arg(ap, uint16*);\n\tif (*v > 0 && va == NULL)\t\t/* typically missing param */\n\t\treturn 0;\n\tfor (i = 0; i < *v; i++) {\n\t\tif (va[i] > EXTRASAMPLE_UNASSALPHA) {\n\t\t\t/*\n\t\t\t * XXX: Corel Draw is known to produce incorrect\n\t\t\t * ExtraSamples tags which must be patched here if we\n\t\t\t * want to be able to open some of the damaged TIFF\n\t\t\t * files: \n\t\t\t */\n\t\t\tif (va[i] == EXTRASAMPLE_COREL_UNASSALPHA)\n\t\t\t\tva[i] = EXTRASAMPLE_UNASSALPHA;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n        if ( td->td_transferfunction[0] != NULL && (td->td_samplesperpixel - *v > 1) &&\n                !(td->td_samplesperpixel - td->td_extrasamples > 1))\n        {\n                TIFFWarningExt(tif->tif_clientdata,module,\n                    \"ExtraSamples tag value is changing, \"\n                    \"but TransferFunction was read with a different value. Cancelling it\");\n                TIFFClrFieldBit(tif,FIELD_TRANSFERFUNCTION);\n                _TIFFfree(td->td_transferfunction[0]);\n                td->td_transferfunction[0] = NULL;\n        }\n\n\ttd->td_extrasamples = (uint16) *v;\n\t_TIFFsetShortArray(&td->td_sampleinfo, va, td->td_extrasamples);\n\treturn 1;\n\n#undef EXTRASAMPLE_COREL_UNASSALPHA\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setExtraSamples",
            "parameters": {
              "tif": "TIFF",
              "ap": "va_list",
              "v": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static uint32\ncheckInkNamesString(TIFF* tif, uint32 slen, const char* s)\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\tuint16 i = td->td_samplesperpixel;\n\n\tif (slen > 0) {\n\t\tconst char* ep = s+slen;\n\t\tconst char* cp = s;\n\t\tfor (; i > 0; i--) {\n\t\t\tfor (; cp < ep && *cp != '\\0'; cp++) {}\n\t\t\tif (cp >= ep)\n\t\t\t\tgoto bad;\n\t\t\tcp++;\t\t\t\t/* skip \\0 */\n\t\t}\n\t\treturn ((uint32)(cp-s));\n\t}\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\",\n\t    \"%s: Invalid InkNames value; expecting %d names, found %d\",\n\t    tif->tif_name,\n\t    td->td_samplesperpixel,\n\t    td->td_samplesperpixel-i);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              142,
              0
            ],
            [
              166,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "checkInkNamesString",
            "parameters": {
              "tif": "TIFF",
              "slen": "uint32",
              "s": "char"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "static int\n_TIFFVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tstatic const char module[] = \"_TIFFVSetField\";\n\n\tTIFFDirectory* td = &tif->tif_dir;\n\tint status = 1;\n\tuint32 v32, i, v;\n    double dblval;\n\tchar* s;\n\tconst TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tuint32 standard_tag = tag;\n\tif( fip == NULL ) /* cannot happen since OkToChangeTag() already checks it */\n\t    return 0;\n\t/*\n\t * We want to force the custom code to be used for custom\n\t * fields even if the tag happens to match a well known \n\t * one - important for reinterpreted handling of standard\n\t * tag values in custom directories (i.e. EXIF) \n\t */\n\tif (fip->field_bit == FIELD_CUSTOM) {\n\t\tstandard_tag = 0;\n\t}\n\n\tswitch (standard_tag) {\n\tcase TIFFTAG_SUBFILETYPE:\n\t\ttd->td_subfiletype = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_IMAGEWIDTH:\n\t\ttd->td_imagewidth = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_IMAGELENGTH:\n\t\ttd->td_imagelength = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_BITSPERSAMPLE:\n\t\ttd->td_bitspersample = (uint16) va_arg(ap, uint16_vap);\n\t\t/*\n\t\t * If the data require post-decoding processing to byte-swap\n\t\t * samples, set it up here.  Note that since tags are required\n\t\t * to be ordered, compression code can override this behaviour\n\t\t * in the setup method if it wants to roll the post decoding\n\t\t * work in with its normal work.\n\t\t */\n\t\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t\tif (td->td_bitspersample == 8)\n\t\t\t\ttif->tif_postdecode = _TIFFNoPostDecode;\n\t\t\telse if (td->td_bitspersample == 16)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab16BitData;\n\t\t\telse if (td->td_bitspersample == 24)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab24BitData;\n\t\t\telse if (td->td_bitspersample == 32)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab32BitData;\n\t\t\telse if (td->td_bitspersample == 64)\n\t\t\t\ttif->tif_postdecode = _TIFFSwab64BitData;\n\t\t\telse if (td->td_bitspersample == 128) /* two 64's */\n\t\t\t\ttif->tif_postdecode = _TIFFSwab64BitData;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_COMPRESSION:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\t/*\n\t\t * If we're changing the compression scheme, the notify the\n\t\t * previous module so that it can cleanup any state it's\n\t\t * setup.\n\t\t */\n\t\tif (TIFFFieldSet(tif, FIELD_COMPRESSION)) {\n\t\t\tif ((uint32)td->td_compression == v)\n\t\t\t\tbreak;\n\t\t\t(*tif->tif_cleanup)(tif);\n\t\t\ttif->tif_flags &= ~TIFF_CODERSETUP;\n\t\t}\n\t\t/*\n\t\t * Setup new compression routine state.\n\t\t */\n\t\tif( (status = TIFFSetCompressionScheme(tif, v)) != 0 )\n\t\t    td->td_compression = (uint16) v;\n\t\telse\n\t\t    status = 0;\n\t\tbreak;\n\tcase TIFFTAG_PHOTOMETRIC:\n\t\ttd->td_photometric = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_THRESHHOLDING:\n\t\ttd->td_threshholding = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_FILLORDER:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v != FILLORDER_LSB2MSB && v != FILLORDER_MSB2LSB)\n\t\t\tgoto badvalue;\n\t\ttd->td_fillorder = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_ORIENTATION:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v < ORIENTATION_TOPLEFT || ORIENTATION_LEFTBOT < v)\n\t\t\tgoto badvalue;\n\t\telse\n\t\t\ttd->td_orientation = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v == 0)\n\t\t\tgoto badvalue;\n        if( v != td->td_samplesperpixel )\n        {\n            /* See http://bugzilla.maptools.org/show_bug.cgi?id=2500 */\n            if( td->td_sminsamplevalue != NULL )\n            {\n                TIFFWarningExt(tif->tif_clientdata,module,\n                    \"SamplesPerPixel tag value is changing, \"\n                    \"but SMinSampleValue tag was read with a different value. Cancelling it\");\n                TIFFClrFieldBit(tif,FIELD_SMINSAMPLEVALUE);\n                _TIFFfree(td->td_sminsamplevalue);\n                td->td_sminsamplevalue = NULL;\n            }\n            if( td->td_smaxsamplevalue != NULL )\n            {\n                TIFFWarningExt(tif->tif_clientdata,module,\n                    \"SamplesPerPixel tag value is changing, \"\n                    \"but SMaxSampleValue tag was read with a different value. Cancelling it\");\n                TIFFClrFieldBit(tif,FIELD_SMAXSAMPLEVALUE);\n                _TIFFfree(td->td_smaxsamplevalue);\n                td->td_smaxsamplevalue = NULL;\n            }\n            /* Test if 3 transfer functions instead of just one are now needed\n               See http://bugzilla.maptools.org/show_bug.cgi?id=2820 */\n            if( td->td_transferfunction[0] != NULL && (v - td->td_extrasamples > 1) &&\n                !(td->td_samplesperpixel - td->td_extrasamples > 1))\n            {\n                    TIFFWarningExt(tif->tif_clientdata,module,\n                        \"SamplesPerPixel tag value is changing, \"\n                        \"but TransferFunction was read with a different value. Cancelling it\");\n                    TIFFClrFieldBit(tif,FIELD_TRANSFERFUNCTION);\n                    _TIFFfree(td->td_transferfunction[0]);\n                    td->td_transferfunction[0] = NULL;\n            }\n        }\n\t\ttd->td_samplesperpixel = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_ROWSPERSTRIP:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 == 0)\n\t\t\tgoto badvalue32;\n\t\ttd->td_rowsperstrip = v32;\n\t\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\n\t\t\ttd->td_tilelength = v32;\n\t\t\ttd->td_tilewidth = td->td_imagewidth;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\ttd->td_minsamplevalue = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\ttd->td_maxsamplevalue = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t_TIFFsetDoubleArray(&td->td_sminsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);\n\t\telse\n\t\t\tsetDoubleArrayOneValue(&td->td_sminsamplevalue, va_arg(ap, double), td->td_samplesperpixel);\n\t\tbreak;\n\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t_TIFFsetDoubleArray(&td->td_smaxsamplevalue, va_arg(ap, double*), td->td_samplesperpixel);\n\t\telse\n\t\t\tsetDoubleArrayOneValue(&td->td_smaxsamplevalue, va_arg(ap, double), td->td_samplesperpixel);\n\t\tbreak;\n\tcase TIFFTAG_XRESOLUTION:\n        dblval = va_arg(ap, double);\n        if( dblval < 0 )\n            goto badvaluedouble;\n\t\ttd->td_xresolution = _TIFFClampDoubleToFloat( dblval );\n\t\tbreak;\n\tcase TIFFTAG_YRESOLUTION:\n        dblval = va_arg(ap, double);\n        if( dblval < 0 )\n            goto badvaluedouble;\n\t\ttd->td_yresolution = _TIFFClampDoubleToFloat( dblval );\n\t\tbreak;\n\tcase TIFFTAG_PLANARCONFIG:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v != PLANARCONFIG_CONTIG && v != PLANARCONFIG_SEPARATE)\n\t\t\tgoto badvalue;\n\t\ttd->td_planarconfig = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_XPOSITION:\n\t\ttd->td_xposition = _TIFFClampDoubleToFloat( va_arg(ap, double) );\n\t\tbreak;\n\tcase TIFFTAG_YPOSITION:\n\t\ttd->td_yposition = _TIFFClampDoubleToFloat( va_arg(ap, double) );\n\t\tbreak;\n\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v < RESUNIT_NONE || RESUNIT_CENTIMETER < v)\n\t\t\tgoto badvalue;\n\t\ttd->td_resolutionunit = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_PAGENUMBER:\n\t\ttd->td_pagenumber[0] = (uint16) va_arg(ap, uint16_vap);\n\t\ttd->td_pagenumber[1] = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_HALFTONEHINTS:\n\t\ttd->td_halftonehints[0] = (uint16) va_arg(ap, uint16_vap);\n\t\ttd->td_halftonehints[1] = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_COLORMAP:\n\t\tv32 = (uint32)(1L<<td->td_bitspersample);\n\t\t_TIFFsetShortArray(&td->td_colormap[0], va_arg(ap, uint16*), v32);\n\t\t_TIFFsetShortArray(&td->td_colormap[1], va_arg(ap, uint16*), v32);\n\t\t_TIFFsetShortArray(&td->td_colormap[2], va_arg(ap, uint16*), v32);\n\t\tbreak;\n\tcase TIFFTAG_EXTRASAMPLES:\n\t\tif (!setExtraSamples(tif, ap, &v))\n\t\t\tgoto badvalue;\n\t\tbreak;\n\tcase TIFFTAG_MATTEING:\n\t\ttd->td_extrasamples =  (((uint16) va_arg(ap, uint16_vap)) != 0);\n\t\tif (td->td_extrasamples) {\n\t\t\tuint16 sv = EXTRASAMPLE_ASSOCALPHA;\n\t\t\t_TIFFsetShortArray(&td->td_sampleinfo, &sv, 1);\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_TILEWIDTH:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 % 16) {\n\t\t\tif (tif->tif_mode != O_RDONLY)\n\t\t\t\tgoto badvalue32;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t\"Nonstandard tile width %d, convert file\", v32);\n\t\t}\n\t\ttd->td_tilewidth = v32;\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t\tbreak;\n\tcase TIFFTAG_TILELENGTH:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 % 16) {\n\t\t\tif (tif->tif_mode != O_RDONLY)\n\t\t\t\tgoto badvalue32;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t    \"Nonstandard tile length %d, convert file\", v32);\n\t\t}\n\t\ttd->td_tilelength = v32;\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t\tbreak;\n\tcase TIFFTAG_TILEDEPTH:\n\t\tv32 = (uint32) va_arg(ap, uint32);\n\t\tif (v32 == 0)\n\t\t\tgoto badvalue32;\n\t\ttd->td_tiledepth = v32;\n\t\tbreak;\n\tcase TIFFTAG_DATATYPE:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tswitch (v) {\n\t\tcase DATATYPE_VOID:\tv = SAMPLEFORMAT_VOID;\tbreak;\n\t\tcase DATATYPE_INT:\tv = SAMPLEFORMAT_INT;\tbreak;\n\t\tcase DATATYPE_UINT:\tv = SAMPLEFORMAT_UINT;\tbreak;\n\t\tcase DATATYPE_IEEEFP:\tv = SAMPLEFORMAT_IEEEFP;break;\n\t\tdefault:\t\tgoto badvalue;\n\t\t}\n\t\ttd->td_sampleformat = (uint16) v;\n\t\tbreak;\n\tcase TIFFTAG_SAMPLEFORMAT:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif (v < SAMPLEFORMAT_UINT || SAMPLEFORMAT_COMPLEXIEEEFP < v)\n\t\t\tgoto badvalue;\n\t\ttd->td_sampleformat = (uint16) v;\n\n\t\t/*  Try to fix up the SWAB function for complex data. */\n\t\tif( td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT\n\t\t    && td->td_bitspersample == 32\n\t\t    && tif->tif_postdecode == _TIFFSwab32BitData )\n\t\t    tif->tif_postdecode = _TIFFSwab16BitData;\n\t\telse if( (td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT\n\t\t\t  || td->td_sampleformat == SAMPLEFORMAT_COMPLEXIEEEFP)\n\t\t\t && td->td_bitspersample == 64\n\t\t\t && tif->tif_postdecode == _TIFFSwab64BitData )\n\t\t    tif->tif_postdecode = _TIFFSwab32BitData;\n\t\tbreak;\n\tcase TIFFTAG_IMAGEDEPTH:\n\t\ttd->td_imagedepth = (uint32) va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_SUBIFD:\n\t\tif ((tif->tif_flags & TIFF_INSUBIFD) == 0) {\n\t\t\ttd->td_nsubifd = (uint16) va_arg(ap, uint16_vap);\n\t\t\t_TIFFsetLong8Array(&td->td_subifd, (uint64*) va_arg(ap, uint64*),\n\t\t\t    (uint32) td->td_nsubifd);\n\t\t} else {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"%s: Sorry, cannot nest SubIFDs\",\n\t\t\t\t     tif->tif_name);\n\t\t\tstatus = 0;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\ttd->td_ycbcrpositioning = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\ttd->td_ycbcrsubsampling[0] = (uint16) va_arg(ap, uint16_vap);\n\t\ttd->td_ycbcrsubsampling[1] = (uint16) va_arg(ap, uint16_vap);\n\t\tbreak;\n\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\tv = (td->td_samplesperpixel - td->td_extrasamples) > 1 ? 3 : 1;\n\t\tfor (i = 0; i < v; i++)\n\t\t\t_TIFFsetShortArray(&td->td_transferfunction[i],\n\t\t\t    va_arg(ap, uint16*), 1U<<td->td_bitspersample);\n\t\tbreak;\n\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t/* XXX should check for null range */\n\t\t_TIFFsetFloatArray(&td->td_refblackwhite, va_arg(ap, float*), 6);\n\t\tbreak;\n\tcase TIFFTAG_INKNAMES:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\ts = va_arg(ap, char*);\n\t\tv = checkInkNamesString(tif, v, s);\n\t\tstatus = v > 0;\n\t\tif( v > 0 ) {\n\t\t\t_TIFFsetNString(&td->td_inknames, s, v);\n\t\t\ttd->td_inknameslen = v;\n\t\t}\n\t\tbreak;\n\tcase TIFFTAG_PERSAMPLE:\n\t\tv = (uint16) va_arg(ap, uint16_vap);\n\t\tif( v == PERSAMPLE_MULTI )\n\t\t\ttif->tif_flags |= TIFF_PERSAMPLE;\n\t\telse\n\t\t\ttif->tif_flags &= ~TIFF_PERSAMPLE;\n\t\tbreak;\n\tdefault: {\n\t\tTIFFTagValue *tv;\n\t\tint tv_size, iCustom;\n\n\t\t/*\n\t\t * This can happen if multiple images are open with different\n\t\t * codecs which have private tags.  The global tag information\n\t\t * table may then have tags that are valid for one file but not\n\t\t * the other. If the client tries to set a tag that is not valid\n\t\t * for the image's codec then we'll arrive here.  This\n\t\t * happens, for example, when tiffcp is used to convert between\n\t\t * compression schemes and codec-specific tags are blindly copied.\n\t\t */\n\t\tif(fip->field_bit != FIELD_CUSTOM) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"%s: Invalid %stag \\\"%s\\\" (not supported by codec)\",\n\t\t\t    tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\",\n\t\t\t    fip->field_name);\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Find the existing entry for this custom value.\n\t\t */\n\t\ttv = NULL;\n\t\tfor (iCustom = 0; iCustom < td->td_customValueCount; iCustom++) {\n\t\t\tif (td->td_customValues[iCustom].info->field_tag == tag) {\n\t\t\t\ttv = td->td_customValues + iCustom;\n\t\t\t\tif (tv->value != NULL) {\n\t\t\t\t\t_TIFFfree(tv->value);\n\t\t\t\t\ttv->value = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Grow the custom list if the entry was not found.\n\t\t */\n\t\tif(tv == NULL) {\n\t\t\tTIFFTagValue *new_customValues;\n\n\t\t\ttd->td_customValueCount++;\n\t\t\tnew_customValues = (TIFFTagValue *)\n\t\t\t    _TIFFrealloc(td->td_customValues,\n\t\t\t    sizeof(TIFFTagValue) * td->td_customValueCount);\n\t\t\tif (!new_customValues) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"%s: Failed to allocate space for list of custom values\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\ttd->td_customValues = new_customValues;\n\n\t\t\ttv = td->td_customValues + (td->td_customValueCount - 1);\n\t\t\ttv->info = fip;\n\t\t\ttv->value = NULL;\n\t\t\ttv->count = 0;\n\t\t}\n\n\t\t/*\n\t\t * Set custom value ... save a copy of the custom tag value.\n\t\t */\n\t\ttv_size = _TIFFDataSize(fip->field_type);\n\t\tif (tv_size == 0) {\n\t\t\tstatus = 0;\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"%s: Bad field type %d for \\\"%s\\\"\",\n\t\t\t    tif->tif_name, fip->field_type,\n\t\t\t    fip->field_name);\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (fip->field_type == TIFF_ASCII)\n\t\t{\n\t\t\tuint32 ma;\n\t\t\tchar* mb;\n\t\t\tif (fip->field_passcount)\n\t\t\t{\n\t\t\t\tassert(fip->field_writecount==TIFF_VARIABLE2);\n\t\t\t\tma=(uint32)va_arg(ap,uint32);\n\t\t\t\tmb=(char*)va_arg(ap,char*);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmb=(char*)va_arg(ap,char*);\n\t\t\t\tma=(uint32)(strlen(mb)+1);\n\t\t\t}\n\t\t\ttv->count=ma;\n\t\t\tsetByteArray(&tv->value,mb,ma,1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (fip->field_passcount) {\n\t\t\t\tif (fip->field_writecount == TIFF_VARIABLE2)\n\t\t\t\t\ttv->count = (uint32) va_arg(ap, uint32);\n\t\t\t\telse\n\t\t\t\t\ttv->count = (int) va_arg(ap, int);\n\t\t\t} else if (fip->field_writecount == TIFF_VARIABLE\n\t\t\t   || fip->field_writecount == TIFF_VARIABLE2)\n\t\t\t\ttv->count = 1;\n\t\t\telse if (fip->field_writecount == TIFF_SPP)\n\t\t\t\ttv->count = td->td_samplesperpixel;\n\t\t\telse\n\t\t\t\ttv->count = fip->field_writecount;\n\n\t\t\tif (tv->count == 0) {\n\t\t\t\tstatus = 0;\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"%s: Null count for \\\"%s\\\" (type \"\n\t\t\t\t\t     \"%d, writecount %d, passcount %d)\",\n\t\t\t\t\t     tif->tif_name,\n\t\t\t\t\t     fip->field_name,\n\t\t\t\t\t     fip->field_type,\n\t\t\t\t\t     fip->field_writecount,\n\t\t\t\t\t     fip->field_passcount);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\ttv->value = _TIFFCheckMalloc(tif, tv->count, tv_size,\n\t\t\t    \"custom tag binary object\");\n\t\t\tif (!tv->value) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tif (fip->field_tag == TIFFTAG_DOTRANGE \n\t\t\t    && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t/* TODO: This is an evil exception and should not have been\n\t\t\t\t   handled this way ... likely best if we move it into\n\t\t\t\t   the directory structure with an explicit field in \n\t\t\t\t   libtiff 4.1 and assign it a FIELD_ value */\n\t\t\t\tuint16 v2[2];\n\t\t\t\tv2[0] = (uint16)va_arg(ap, int);\n\t\t\t\tv2[1] = (uint16)va_arg(ap, int);\n\t\t\t\t_TIFFmemcpy(tv->value, &v2, 4);\n\t\t\t}\n\n\t\t\telse if (fip->field_passcount\n\t\t\t\t  || fip->field_writecount == TIFF_VARIABLE\n\t\t\t\t  || fip->field_writecount == TIFF_VARIABLE2\n\t\t\t\t  || fip->field_writecount == TIFF_SPP\n\t\t\t\t  || tv->count > 1) {\n\t\t\t\t_TIFFmemcpy(tv->value, va_arg(ap, void *),\n\t\t\t\t    tv->count * tv_size);\n\t\t\t} else {\n\t\t\t\tchar *val = (char *)tv->value;\n\t\t\t\tassert( tv->count == 1 );\n\n\t\t\t\tswitch (fip->field_type) {\n\t\t\t\tcase TIFF_BYTE:\n\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8 v2 = (uint8)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\t{\n\t\t\t\t\t\tint8 v2 = (int8)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint16 v2 = (uint16)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\t{\n\t\t\t\t\t\tint16 v2 = (int16)va_arg(ap, int);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG:\n\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32 v2 = va_arg(ap, uint32);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\t{\n\t\t\t\t\t\tint32 v2 = va_arg(ap, int32);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG8:\n\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\t{\n\t\t\t\t\t\tuint64 v2 = va_arg(ap, uint64);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\t{\n\t\t\t\t\t\tint64 v2 = va_arg(ap, int64);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat v2 = _TIFFClampDoubleToFloat(va_arg(ap, double));\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble v2 = va_arg(ap, double);\n\t\t\t\t\t\t_TIFFmemcpy(val, &v2, tv_size);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t_TIFFmemset(val, 0, tv_size);\n\t\t\t\t\tstatus = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t}\n\tif (status) {\n\t\tconst TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n\t\tif (fip2)                \n\t\t\tTIFFSetFieldBit(tif, fip2->field_bit);\n\t\ttif->tif_flags |= TIFF_DIRTYDIRECT;\n\t}\n\nend:\n\tva_end(ap);\n\treturn (status);\nbadvalue:\n        {\n\t\tconst TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"%s: Bad value %u for \\\"%s\\\" tag\",\n\t\t     tif->tif_name, v,\n\t\t     fip2 ? fip2->field_name : \"Unknown\");\n\t\tva_end(ap);\n        }\n\treturn (0);\nbadvalue32:\n        {\n\t\tconst TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"%s: Bad value %u for \\\"%s\\\" tag\",\n\t\t     tif->tif_name, v32,\n\t\t     fip2 ? fip2->field_name : \"Unknown\");\n\t\tva_end(ap);\n        }\n\treturn (0);\nbadvaluedouble:\n        {\n        const TIFFField* fip2=TIFFFieldWithTag(tif,tag);\n        TIFFErrorExt(tif->tif_clientdata, module,\n             \"%s: Bad value %f for \\\"%s\\\" tag\",\n             tif->tif_name, dblval,\n             fip2 ? fip2->field_name : \"Unknown\");\n        va_end(ap);\n        }\n    return (0);\n}",
          "fn_code_pos": [
            [
              168,
              0
            ],
            [
              761,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFVSetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOkToChangeTag(TIFF* tif, uint32 tag)\n{\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif (!fip) {\t\t\t/* unknown tag */\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\", \"%s: Unknown %stag %u\",\n\t\t    tif->tif_name, isPseudoTag(tag) ? \"pseudo-\" : \"\", tag);\n\t\treturn (0);\n\t}\n\tif (tag != TIFFTAG_IMAGELENGTH && (tif->tif_flags & TIFF_BEENWRITING) &&\n\t    !fip->field_oktochange) {\n\t\t/*\n\t\t * Consult info table to see if tag can be changed\n\t\t * after we've started writing.  We only allow changes\n\t\t * to those tags that don't/shouldn't affect the\n\t\t * compression and/or format of the data.\n\t\t */\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFSetField\",\n\t\t    \"%s: Cannot modify tag \\\"%s\\\" while writing\",\n\t\t    tif->tif_name, fip->field_name);\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              772,
              0
            ],
            [
              795,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OkToChangeTag",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFSetField(TIFF* tif, uint32 tag, ...)\n{\n\tva_list ap;\n\tint status;\n\n\tva_start(ap, tag);\n\tstatus = TIFFVSetField(tif, tag, ap);\n\tva_end(ap);\n\treturn (status);\n}",
          "fn_code_pos": [
            [
              804,
              0
            ],
            [
              814,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFUnsetField(TIFF* tif, uint32 tag)\n{\n    const TIFFField *fip =  TIFFFieldWithTag(tif, tag);\n    TIFFDirectory* td = &tif->tif_dir;\n\n    if( !fip )\n        return 0;\n\n    if( fip->field_bit != FIELD_CUSTOM )\n        TIFFClrFieldBit(tif, fip->field_bit);\n    else\n    {\n        TIFFTagValue *tv = NULL;\n        int i;\n\n        for (i = 0; i < td->td_customValueCount; i++) {\n                \n            tv = td->td_customValues + i;\n            if( tv->info->field_tag == tag )\n                break;\n        }\n\n        if( i < td->td_customValueCount )\n        {\n            _TIFFfree(tv->value);\n            for( ; i < td->td_customValueCount-1; i++) {\n                td->td_customValues[i] = td->td_customValues[i+1];\n            }\n            td->td_customValueCount--;\n        }\n    }\n        \n    tif->tif_flags |= TIFF_DIRTYDIRECT;\n\n    return (1);\n}",
          "fn_code_pos": [
            [
              819,
              0
            ],
            [
              855,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFUnsetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\treturn OkToChangeTag(tif, tag) ?\n\t    (*tif->tif_tagmethods.vsetfield)(tif, tag, ap) : 0;\n}",
          "fn_code_pos": [
            [
              863,
              0
            ],
            [
              868,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFVSetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\n_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\tint ret_val = 1;\n\tuint32 standard_tag = tag;\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif( fip == NULL ) /* cannot happen since TIFFGetField() already checks it */\n\t    return 0;\n\n\t/*\n\t * We want to force the custom code to be used for custom\n\t * fields even if the tag happens to match a well known \n\t * one - important for reinterpreted handling of standard\n\t * tag values in custom directories (i.e. EXIF) \n\t */\n\tif (fip->field_bit == FIELD_CUSTOM) {\n\t\tstandard_tag = 0;\n\t}\n\t\n        if( standard_tag == TIFFTAG_NUMBEROFINKS )\n        {\n            int i;\n            for (i = 0; i < td->td_customValueCount; i++) {\n                uint16 val;\n                TIFFTagValue *tv = td->td_customValues + i;\n                if (tv->info->field_tag != standard_tag)\n                    continue;\n                if( tv->value == NULL )\n                    return 0;\n                val = *(uint16 *)tv->value;\n                /* Truncate to SamplesPerPixel, since the */\n                /* setting code for INKNAMES assume that there are SamplesPerPixel */\n                /* inknames. */\n                /* Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2599 */\n                if( val > td->td_samplesperpixel )\n                {\n                    TIFFWarningExt(tif->tif_clientdata,\"_TIFFVGetField\",\n                                   \"Truncating NumberOfInks from %u to %u\",\n                                   val, td->td_samplesperpixel);\n                    val = td->td_samplesperpixel;\n                }\n                *va_arg(ap, uint16*) = val;\n                return 1;\n            }\n            return 0;\n        }\n\n\tswitch (standard_tag) {\n\t\tcase TIFFTAG_SUBFILETYPE:\n\t\t\t*va_arg(ap, uint32*) = td->td_subfiletype;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagewidth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGELENGTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagelength;\n\t\t\tbreak;\n\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t\t*va_arg(ap, uint16*) = td->td_bitspersample;\n\t\t\tbreak;\n\t\tcase TIFFTAG_COMPRESSION:\n\t\t\t*va_arg(ap, uint16*) = td->td_compression;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PHOTOMETRIC:\n\t\t\t*va_arg(ap, uint16*) = td->td_photometric;\n\t\t\tbreak;\n\t\tcase TIFFTAG_THRESHHOLDING:\n\t\t\t*va_arg(ap, uint16*) = td->td_threshholding;\n\t\t\tbreak;\n\t\tcase TIFFTAG_FILLORDER:\n\t\t\t*va_arg(ap, uint16*) = td->td_fillorder;\n\t\t\tbreak;\n\t\tcase TIFFTAG_ORIENTATION:\n\t\t\t*va_arg(ap, uint16*) = td->td_orientation;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\t\t*va_arg(ap, uint16*) = td->td_samplesperpixel;\n\t\t\tbreak;\n\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t\t*va_arg(ap, uint32*) = td->td_rowsperstrip;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t\t*va_arg(ap, uint16*) = td->td_minsamplevalue;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t\t*va_arg(ap, uint16*) = td->td_maxsamplevalue;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t\t*va_arg(ap, double**) = td->td_sminsamplevalue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* libtiff historically treats this as a single value. */\n\t\t\t\tuint16 i;\n\t\t\t\tdouble v = td->td_sminsamplevalue[0];\n\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\n\t\t\t\t\tif( td->td_sminsamplevalue[i] < v )\n\t\t\t\t\t\tv = td->td_sminsamplevalue[i];\n\t\t\t\t*va_arg(ap, double*) = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t\t*va_arg(ap, double**) = td->td_smaxsamplevalue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* libtiff historically treats this as a single value. */\n\t\t\t\tuint16 i;\n\t\t\t\tdouble v = td->td_smaxsamplevalue[0];\n\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\n\t\t\t\t\tif( td->td_smaxsamplevalue[i] > v )\n\t\t\t\t\t\tv = td->td_smaxsamplevalue[i];\n\t\t\t\t*va_arg(ap, double*) = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_XRESOLUTION:\n\t\t\t*va_arg(ap, float*) = td->td_xresolution;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YRESOLUTION:\n\t\t\t*va_arg(ap, float*) = td->td_yresolution;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PLANARCONFIG:\n\t\t\t*va_arg(ap, uint16*) = td->td_planarconfig;\n\t\t\tbreak;\n\t\tcase TIFFTAG_XPOSITION:\n\t\t\t*va_arg(ap, float*) = td->td_xposition;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YPOSITION:\n\t\t\t*va_arg(ap, float*) = td->td_yposition;\n\t\t\tbreak;\n\t\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\t\t*va_arg(ap, uint16*) = td->td_resolutionunit;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PAGENUMBER:\n\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_HALFTONEHINTS:\n\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_COLORMAP:\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[0];\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[1];\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[2];\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\t_TIFFFillStriles( tif );\n\t\t\t*va_arg(ap, uint64**) = td->td_stripoffset;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\t_TIFFFillStriles( tif );\n\t\t\t*va_arg(ap, uint64**) = td->td_stripbytecount;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MATTEING:\n\t\t\t*va_arg(ap, uint16*) =\n\t\t\t    (td->td_extrasamples == 1 &&\n\t\t\t    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\n\t\t\tbreak;\n\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\t*va_arg(ap, uint16*) = td->td_extrasamples;\n\t\t\t*va_arg(ap, uint16**) = td->td_sampleinfo;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILEWIDTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tilewidth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILELENGTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tilelength;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILEDEPTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tiledepth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_DATATYPE:\n\t\t\tswitch (td->td_sampleformat) {\n\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_UINT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_INT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_IEEEFP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_VOID:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_VOID;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t*va_arg(ap, uint16*) = td->td_sampleformat;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagedepth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SUBIFD:\n\t\t\t*va_arg(ap, uint16*) = td->td_nsubifd;\n\t\t\t*va_arg(ap, uint64**) = td->td_subifd;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrpositioning;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[0];\n\t\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\n\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[1];\n\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[2];\n\t\t\t} else {\n\t\t\t\t*va_arg(ap, uint16**) = NULL;\n\t\t\t\t*va_arg(ap, uint16**) = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t\t*va_arg(ap, float**) = td->td_refblackwhite;\n\t\t\tbreak;\n\t\tcase TIFFTAG_INKNAMES:\n\t\t\t*va_arg(ap, char**) = td->td_inknames;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\t/*\n\t\t\t\t * This can happen if multiple images are open\n\t\t\t\t * with different codecs which have private\n\t\t\t\t * tags.  The global tag information table may\n\t\t\t\t * then have tags that are valid for one file\n\t\t\t\t * but not the other. If the client tries to\n\t\t\t\t * get a tag that is not valid for the image's\n\t\t\t\t * codec then we'll arrive here.\n\t\t\t\t */\n\t\t\t\tif( fip->field_bit != FIELD_CUSTOM )\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFVGetField\",\n\t\t\t\t\t    \"%s: Invalid %stag \\\"%s\\\" \"\n\t\t\t\t\t    \"(not supported by codec)\",\n\t\t\t\t\t    tif->tif_name,\n\t\t\t\t\t    isPseudoTag(tag) ? \"pseudo-\" : \"\",\n\t\t\t\t\t    fip->field_name);\n\t\t\t\t\tret_val = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Do we have a custom value?\n\t\t\t\t */\n\t\t\t\tret_val = 0;\n\t\t\t\tfor (i = 0; i < td->td_customValueCount; i++) {\n\t\t\t\t\tTIFFTagValue *tv = td->td_customValues + i;\n\n\t\t\t\t\tif (tv->info->field_tag != tag)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (fip->field_passcount) {\n\t\t\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2)\n\t\t\t\t\t\t\t*va_arg(ap, uint32*) = (uint32)tv->count;\n\t\t\t\t\t\telse  /* Assume TIFF_VARIABLE */\n\t\t\t\t\t\t\t*va_arg(ap, uint16*) = (uint16)tv->count;\n\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t} else if (fip->field_tag == TIFFTAG_DOTRANGE\n\t\t\t\t\t\t   && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t\t\t/* TODO: This is an evil exception and should not have been\n\t\t\t\t\t\t   handled this way ... likely best if we move it into\n\t\t\t\t\t\t   the directory structure with an explicit field in \n\t\t\t\t\t\t   libtiff 4.1 and assign it a FIELD_ value */\n\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];\n\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (fip->field_type == TIFF_ASCII\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_SPP\n\t\t\t\t\t\t    || tv->count > 1) {\n\t\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\n\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchar *val = (char *)tv->value;\n\t\t\t\t\t\t\tassert( tv->count == 1 );\n\t\t\t\t\t\t\tswitch (fip->field_type) {\n\t\t\t\t\t\t\tcase TIFF_BYTE:\n\t\t\t\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint8*) =\n\t\t\t\t\t\t\t\t\t*(uint8 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\t\t\t\t*va_arg(ap, int8*) =\n\t\t\t\t\t\t\t\t\t*(int8 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint16*) =\n\t\t\t\t\t\t\t\t\t*(uint16 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\t\t\t\t*va_arg(ap, int16*) =\n\t\t\t\t\t\t\t\t\t*(int16 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_LONG:\n\t\t\t\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint32*) =\n\t\t\t\t\t\t\t\t\t*(uint32 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\t\t\t\t*va_arg(ap, int32*) =\n\t\t\t\t\t\t\t\t\t*(int32 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_LONG8:\n\t\t\t\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint64*) =\n\t\t\t\t\t\t\t\t\t*(uint64 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\t\t\t\t*va_arg(ap, int64*) =\n\t\t\t\t\t\t\t\t\t*(int64 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\t\t\t\t*va_arg(ap, float*) =\n\t\t\t\t\t\t\t\t\t*(float *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\t\t\t\t*va_arg(ap, double*) =\n\t\t\t\t\t\t\t\t\t*(double *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tret_val = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn(ret_val);\n}",
          "fn_code_pos": [
            [
              870,
              0
            ],
            [
              1223,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFVGetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFGetField(TIFF* tif, uint32 tag, ...)\n{\n\tint status;\n\tva_list ap;\n\n\tva_start(ap, tag);\n\tstatus = TIFFVGetField(tif, tag, ap);\n\tva_end(ap);\n\treturn (status);\n}",
          "fn_code_pos": [
            [
              1229,
              0
            ],
            [
              1239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\treturn (fip && (isPseudoTag(tag) || TIFFFieldSet(tif, fip->field_bit)) ?\n\t    (*tif->tif_tagmethods.vgetfield)(tif, tag, ap) : 0);\n}",
          "fn_code_pos": [
            [
              1247,
              0
            ],
            [
              1253,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFVGetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\nTIFFFreeDirectory(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tint            i;\n\n\t_TIFFmemset(td->td_fieldsset, 0, FIELD_SETLONGS);\n\tCleanupField(td_sminsamplevalue);\n\tCleanupField(td_smaxsamplevalue);\n\tCleanupField(td_colormap[0]);\n\tCleanupField(td_colormap[1]);\n\tCleanupField(td_colormap[2]);\n\tCleanupField(td_sampleinfo);\n\tCleanupField(td_subifd);\n\tCleanupField(td_inknames);\n\tCleanupField(td_refblackwhite);\n\tCleanupField(td_transferfunction[0]);\n\tCleanupField(td_transferfunction[1]);\n\tCleanupField(td_transferfunction[2]);\n\tCleanupField(td_stripoffset);\n\tCleanupField(td_stripbytecount);\n\tTIFFClrFieldBit(tif, FIELD_YCBCRSUBSAMPLING);\n\tTIFFClrFieldBit(tif, FIELD_YCBCRPOSITIONING);\n\n\t/* Cleanup custom tag values */\n\tfor( i = 0; i < td->td_customValueCount; i++ ) {\n\t\tif (td->td_customValues[i].value)\n\t\t\t_TIFFfree(td->td_customValues[i].value);\n\t}\n\n\ttd->td_customValueCount = 0;\n\tCleanupField(td_customValues);\n\n#if defined(DEFER_STRILE_LOAD)\n        _TIFFmemset( &(td->td_stripoffset_entry), 0, sizeof(TIFFDirEntry));\n        _TIFFmemset( &(td->td_stripbytecount_entry), 0, sizeof(TIFFDirEntry));\n#endif        \n}",
          "fn_code_pos": [
            [
              1265,
              0
            ],
            [
              1302,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFreeDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFExtendProc\nTIFFSetTagExtender(TIFFExtendProc extender)\n{\n\tTIFFExtendProc prev = _TIFFextender;\n\t_TIFFextender = extender;\n\treturn (prev);\n}",
          "fn_code_pos": [
            [
              1310,
              0
            ],
            [
              1316,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetTagExtender",
            "parameters": {
              "extender": "TIFFExtendProc"
            },
            "return_type": "TIFFExtendProc"
          }
        },
        {
          "fn_code": "int\nTIFFCreateDirectory(TIFF* tif)\n{\n\tTIFFDefaultDirectory(tif);\n\ttif->tif_diroff = 0;\n\ttif->tif_nextdiroff = 0;\n\ttif->tif_curoff = 0;\n\ttif->tif_row = (uint32) -1;\n\ttif->tif_curstrip = (uint32) -1;\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1325,
              0
            ],
            [
              1336,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCreateDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFCreateCustomDirectory(TIFF* tif, const TIFFFieldArray* infoarray)\n{\n\tTIFFDefaultDirectory(tif);\n\n\t/*\n\t * Reset the field definitions to match the application provided list. \n\t * Hopefully TIFFDefaultDirectory() won't have done anything irreversable\n\t * based on it's assumption this is an image directory.\n\t */\n\t_TIFFSetupFields(tif, infoarray);\n\n\ttif->tif_diroff = 0;\n\ttif->tif_nextdiroff = 0;\n\ttif->tif_curoff = 0;\n\ttif->tif_row = (uint32) -1;\n\ttif->tif_curstrip = (uint32) -1;\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1338,
              0
            ],
            [
              1357,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCreateCustomDirectory",
            "parameters": {
              "tif": "TIFF",
              "infoarray": "TIFFFieldArray"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFCreateEXIFDirectory(TIFF* tif)\n{\n\tconst TIFFFieldArray* exifFieldArray;\n\texifFieldArray = _TIFFGetExifFields();\n\treturn TIFFCreateCustomDirectory(tif, exifFieldArray);\n}",
          "fn_code_pos": [
            [
              1359,
              0
            ],
            [
              1365,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCreateEXIFDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFDefaultDirectory(TIFF* tif)\n{\n\tregister TIFFDirectory* td = &tif->tif_dir;\n\tconst TIFFFieldArray* tiffFieldArray;\n\n\ttiffFieldArray = _TIFFGetFields();\n\t_TIFFSetupFields(tif, tiffFieldArray);   \n\n\t_TIFFmemset(td, 0, sizeof (*td));\n\ttd->td_fillorder = FILLORDER_MSB2LSB;\n\ttd->td_bitspersample = 1;\n\ttd->td_threshholding = THRESHHOLD_BILEVEL;\n\ttd->td_orientation = ORIENTATION_TOPLEFT;\n\ttd->td_samplesperpixel = 1;\n\ttd->td_rowsperstrip = (uint32) -1;\n\ttd->td_tilewidth = 0;\n\ttd->td_tilelength = 0;\n\ttd->td_tiledepth = 1;\n\ttd->td_stripbytecountsorted = 1; /* Our own arrays always sorted. */  \n\ttd->td_resolutionunit = RESUNIT_INCH;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n\ttd->td_imagedepth = 1;\n\ttd->td_ycbcrsubsampling[0] = 2;\n\ttd->td_ycbcrsubsampling[1] = 2;\n\ttd->td_ycbcrpositioning = YCBCRPOSITION_CENTERED;\n\ttif->tif_postdecode = _TIFFNoPostDecode;  \n\ttif->tif_foundfield = NULL;\n\ttif->tif_tagmethods.vsetfield = _TIFFVSetField;  \n\ttif->tif_tagmethods.vgetfield = _TIFFVGetField;\n\ttif->tif_tagmethods.printdir = NULL;\n\t/*\n\t *  Give client code a chance to install their own\n\t *  tag extensions & methods, prior to compression overloads,\n\t *  but do some prior cleanup first. (http://trac.osgeo.org/gdal/ticket/5054)\n\t */\n\tif (tif->tif_nfieldscompat > 0) {\n\t\tuint32 i;\n\n\t\tfor (i = 0; i < tif->tif_nfieldscompat; i++) {\n\t\t\t\tif (tif->tif_fieldscompat[i].allocated_size)\n\t\t\t\t\t\t_TIFFfree(tif->tif_fieldscompat[i].fields);\n\t\t}\n\t\t_TIFFfree(tif->tif_fieldscompat);\n\t\ttif->tif_nfieldscompat = 0;\n\t\ttif->tif_fieldscompat = NULL;\n\t}\n\tif (_TIFFextender)\n\t\t(*_TIFFextender)(tif);\n\t(void) TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t/*\n\t * NB: The directory is marked dirty as a result of setting\n\t * up the default compression scheme.  However, this really\n\t * isn't correct -- we want TIFF_DIRTYDIRECT to be set only\n\t * if the user does something.  We could just do the setup\n\t * by hand, but it seems better to use the normal mechanism\n\t * (i.e. TIFFSetField).\n\t */\n\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\n\t/*\n\t * As per http://bugzilla.remotesensing.org/show_bug.cgi?id=19\n\t * we clear the ISTILED flag when setting up a new directory.\n\t * Should we also be clearing stuff like INSUBIFD?\n\t */\n\ttif->tif_flags &= ~TIFF_ISTILED;\n\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1370,
              0
            ],
            [
              1438,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFDefaultDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFAdvanceDirectory(TIFF* tif, uint64* nextdir, uint64* off)\n{\n\tstatic const char module[] = \"TIFFAdvanceDirectory\";\n\tif (isMapped(tif))\n\t{\n\t\tuint64 poff=*nextdir;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\ttmsize_t poffa,poffb,poffc,poffd;\n\t\t\tuint16 dircount;\n\t\t\tuint32 nextdir32;\n\t\t\tpoffa=(tmsize_t)poff;\n\t\t\tpoffb=poffa+sizeof(uint16);\n\t\t\tif (((uint64)poffa!=poff)||(poffb<poffa)||(poffb<(tmsize_t)sizeof(uint16))||(poffb>tif->tif_size))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Error fetching directory count\");\n                                  *nextdir=0;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(&dircount,tif->tif_base+poffa,sizeof(uint16));\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount);\n\t\t\tpoffc=poffb+dircount*12;\n\t\t\tpoffd=poffc+sizeof(uint32);\n\t\t\tif ((poffc<poffb)||(poffc<dircount*12)||(poffd<poffc)||(poffd<(tmsize_t)sizeof(uint32))||(poffd>tif->tif_size))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Error fetching directory link\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (off!=NULL)\n\t\t\t\t*off=(uint64)poffc;\n\t\t\t_TIFFmemcpy(&nextdir32,tif->tif_base+poffc,sizeof(uint32));\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&nextdir32);\n\t\t\t*nextdir=nextdir32;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmsize_t poffa,poffb,poffc,poffd;\n\t\t\tuint64 dircount64;\n\t\t\tuint16 dircount16;\n\t\t\tpoffa=(tmsize_t)poff;\n\t\t\tpoffb=poffa+sizeof(uint64);\n\t\t\tif (((uint64)poffa!=poff)||(poffb<poffa)||(poffb<(tmsize_t)sizeof(uint64))||(poffb>tif->tif_size))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Error fetching directory count\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(&dircount64,tif->tif_base+poffa,sizeof(uint64));\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>0xFFFF)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Sanity check on directory count failed\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tdircount16=(uint16)dircount64;\n\t\t\tpoffc=poffb+dircount16*20;\n\t\t\tpoffd=poffc+sizeof(uint64);\n\t\t\tif ((poffc<poffb)||(poffc<dircount16*20)||(poffd<poffc)||(poffd<(tmsize_t)sizeof(uint64))||(poffd>tif->tif_size))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Error fetching directory link\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (off!=NULL)\n\t\t\t\t*off=(uint64)poffc;\n\t\t\t_TIFFmemcpy(nextdir,tif->tif_base+poffc,sizeof(uint64));\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(nextdir);\n\t\t}\n\t\treturn(1);\n\t}\n\telse\n\t{\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t{\n\t\t\tuint16 dircount;\n\t\t\tuint32 nextdir32;\n\t\t\tif (!SeekOK(tif, *nextdir) ||\n\t\t\t    !ReadOK(tif, &dircount, sizeof (uint16))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory count\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabShort(&dircount);\n\t\t\tif (off != NULL)\n\t\t\t\t*off = TIFFSeekFile(tif,\n\t\t\t\t    dircount*12, SEEK_CUR);\n\t\t\telse\n\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t    dircount*12, SEEK_CUR);\n\t\t\tif (!ReadOK(tif, &nextdir32, sizeof (uint32))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory link\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&nextdir32);\n\t\t\t*nextdir=nextdir32;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuint64 dircount64;\n\t\t\tuint16 dircount16;\n\t\t\tif (!SeekOK(tif, *nextdir) ||\n\t\t\t    !ReadOK(tif, &dircount64, sizeof (uint64))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Error fetching directory count\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&dircount64);\n\t\t\tif (dircount64>0xFFFF)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Error fetching directory count\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tdircount16 = (uint16)dircount64;\n\t\t\tif (off != NULL)\n\t\t\t\t*off = TIFFSeekFile(tif,\n\t\t\t\t    dircount16*20, SEEK_CUR);\n\t\t\telse\n\t\t\t\t(void) TIFFSeekFile(tif,\n\t\t\t\t    dircount16*20, SEEK_CUR);\n\t\t\tif (!ReadOK(tif, nextdir, sizeof (uint64))) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n                                             \"%s: Error fetching directory link\",\n\t\t\t\t    tif->tif_name);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(nextdir);\n\t\t}\n\t\treturn (1);\n\t}\n}",
          "fn_code_pos": [
            [
              1440,
              0
            ],
            [
              1577,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFAdvanceDirectory",
            "parameters": {
              "tif": "TIFF",
              "nextdir": "uint64",
              "off": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "uint16\nTIFFNumberOfDirectories(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFNumberOfDirectories\";\n\tuint64 nextdir;\n\tuint16 n;\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\tnextdir = tif->tif_header.classic.tiff_diroff;\n\telse\n\t\tnextdir = tif->tif_header.big.tiff_diroff;\n\tn = 0;\n\twhile (nextdir != 0 && TIFFAdvanceDirectory(tif, &nextdir, NULL))\n        {\n                if (n != 65535) {\n                        ++n;\n                }\n\t\telse\n                {\n                        TIFFErrorExt(tif->tif_clientdata, module,\n                                     \"Directory count exceeded 65535 limit,\"\n                                     \" giving up on counting.\");\n                        return (65535);\n                }\n        }\n\treturn (n);\n}",
          "fn_code_pos": [
            [
              1582,
              0
            ],
            [
              1607,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFNumberOfDirectories",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint16"
          }
        },
        {
          "fn_code": "int\nTIFFSetDirectory(TIFF* tif, uint16 dirn)\n{\n\tuint64 nextdir;\n\tuint16 n;\n\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\tnextdir = tif->tif_header.classic.tiff_diroff;\n\telse\n\t\tnextdir = tif->tif_header.big.tiff_diroff;\n\tfor (n = dirn; n > 0 && nextdir != 0; n--)\n\t\tif (!TIFFAdvanceDirectory(tif, &nextdir, NULL))\n\t\t\treturn (0);\n\ttif->tif_nextdiroff = nextdir;\n\t/*\n\t * Set curdir to the actual directory index.  The\n\t * -1 is because TIFFReadDirectory will increment\n\t * tif_curdir after successfully reading the directory.\n\t */\n\ttif->tif_curdir = (dirn - n) - 1;\n\t/*\n\t * Reset tif_dirnumber counter and start new list of seen directories.\n\t * We need this to prevent IFD loops.\n\t */\n\ttif->tif_dirnumber = 0;\n\treturn (TIFFReadDirectory(tif));\n}",
          "fn_code_pos": [
            [
              1613,
              0
            ],
            [
              1639,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetDirectory",
            "parameters": {
              "tif": "TIFF",
              "dirn": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFSetSubDirectory(TIFF* tif, uint64 diroff)\n{\n\ttif->tif_nextdiroff = diroff;\n\t/*\n\t * Reset tif_dirnumber counter and start new list of seen directories.\n\t * We need this to prevent IFD loops.\n\t */\n\ttif->tif_dirnumber = 0;\n\treturn (TIFFReadDirectory(tif));\n}",
          "fn_code_pos": [
            [
              1647,
              0
            ],
            [
              1657,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetSubDirectory",
            "parameters": {
              "tif": "TIFF",
              "diroff": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "uint64\nTIFFCurrentDirOffset(TIFF* tif)\n{\n\treturn (tif->tif_diroff);\n}",
          "fn_code_pos": [
            [
              1662,
              0
            ],
            [
              1666,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCurrentDirOffset",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "int\nTIFFLastDirectory(TIFF* tif)\n{\n\treturn (tif->tif_nextdiroff == 0);\n}",
          "fn_code_pos": [
            [
              1672,
              0
            ],
            [
              1676,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFLastDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFUnlinkDirectory(TIFF* tif, uint16 dirn)\n{\n\tstatic const char module[] = \"TIFFUnlinkDirectory\";\n\tuint64 nextdir;\n\tuint64 off;\n\tuint16 n;\n\n\tif (tif->tif_mode == O_RDONLY) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n                             \"Can not unlink directory in read-only file\");\n\t\treturn (0);\n\t}\n\t/*\n\t * Go to the directory before the one we want\n\t * to unlink and nab the offset of the link\n\t * field we'll need to patch.\n\t */\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tnextdir = tif->tif_header.classic.tiff_diroff;\n\t\toff = 4;\n\t}\n\telse\n\t{\n\t\tnextdir = tif->tif_header.big.tiff_diroff;\n\t\toff = 8;\n\t}\n\tfor (n = dirn-1; n > 0; n--) {\n\t\tif (nextdir == 0) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Directory %d does not exist\", dirn);\n\t\t\treturn (0);\n\t\t}\n\t\tif (!TIFFAdvanceDirectory(tif, &nextdir, &off))\n\t\t\treturn (0);\n\t}\n\t/*\n\t * Advance to the directory to be unlinked and fetch\n\t * the offset of the directory that follows.\n\t */\n\tif (!TIFFAdvanceDirectory(tif, &nextdir, NULL))\n\t\treturn (0);\n\t/*\n\t * Go back and patch the link field of the preceding\n\t * directory to point to the offset of the directory\n\t * that follows.\n\t */\n\t(void) TIFFSeekFile(tif, off, SEEK_SET);\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tuint32 nextdir32;\n\t\tnextdir32=(uint32)nextdir;\n\t\tassert((uint64)nextdir32==nextdir);\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong(&nextdir32);\n\t\tif (!WriteOK(tif, &nextdir32, sizeof (uint32))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Error writing directory link\");\n\t\t\treturn (0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong8(&nextdir);\n\t\tif (!WriteOK(tif, &nextdir, sizeof (uint64))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Error writing directory link\");\n\t\t\treturn (0);\n\t\t}\n\t}\n\t/*\n\t * Leave directory state setup safely.  We don't have\n\t * facilities for doing inserting and removing directories,\n\t * so it's safest to just invalidate everything.  This\n\t * means that the caller can only append to the directory\n\t * chain.\n\t */\n\t(*tif->tif_cleanup)(tif);\n\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {\n\t\t_TIFFfree(tif->tif_rawdata);\n\t\ttif->tif_rawdata = NULL;\n\t\ttif->tif_rawcc = 0;\n                tif->tif_rawdataoff = 0;\n                tif->tif_rawdataloaded = 0;\n\t}\n\ttif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP|TIFF_POSTENCODE|TIFF_BUF4WRITE);\n\tTIFFFreeDirectory(tif);\n\tTIFFDefaultDirectory(tif);\n\ttif->tif_diroff = 0;\t\t\t/* force link on next write */\n\ttif->tif_nextdiroff = 0;\t\t/* next write must be at end */\n\ttif->tif_curoff = 0;\n\ttif->tif_row = (uint32) -1;\n\ttif->tif_curstrip = (uint32) -1;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1681,
              0
            ],
            [
              1774,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFUnlinkDirectory",
            "parameters": {
              "tif": "TIFF",
              "dirn": "uint16"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "va_arg(ap, uint16*)",
          "fn_dec_pos": [
            [
              912,
              17
            ],
            [
              912,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, double*)",
          "fn_dec_pos": [
            [
              969,
              5
            ],
            [
              969,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, double*)",
          "fn_dec_pos": [
            [
              983,
              5
            ],
            [
              983,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, uint16**)",
          "fn_dec_pos": [
            [
              1081,
              5
            ],
            [
              1081,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, uint16**)",
          "fn_dec_pos": [
            [
              1082,
              5
            ],
            [
              1082,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, uint16**)",
          "fn_dec_pos": [
            [
              1084,
              5
            ],
            [
              1084,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, uint16**)",
          "fn_dec_pos": [
            [
              1085,
              5
            ],
            [
              1085,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, void **)",
          "fn_dec_pos": [
            [
              1134,
              7
            ],
            [
              1134,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, uint16*) = ((uint16 *)tv->value",
          "fn_dec_pos": [
            [
              1142,
              7
            ],
            [
              1142,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, uint16*)",
          "fn_dec_pos": [
            [
              1142,
              7
            ],
            [
              1142,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, uint16*) = ((uint16 *)tv->value",
          "fn_dec_pos": [
            [
              1143,
              7
            ],
            [
              1143,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, uint16*)",
          "fn_dec_pos": [
            [
              1143,
              7
            ],
            [
              1143,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "va_arg(ap, void **)",
          "fn_dec_pos": [
            [
              1151,
              8
            ],
            [
              1151,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "va_arg",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_extension.c": {
      "fn_def_list": [
        {
          "fn_code": "int TIFFGetTagListCount( TIFF *tif )\n\n{\n    TIFFDirectory* td = &tif->tif_dir;\n    \n    return td->td_customValueCount;\n}",
          "fn_code_pos": [
            [
              33,
              0
            ],
            [
              39,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetTagListCount",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "uint32 TIFFGetTagListEntry( TIFF *tif, int tag_index )\n\n{\n    TIFFDirectory* td = &tif->tif_dir;\n\n    if( tag_index < 0 || tag_index >= td->td_customValueCount )\n        return (uint32)(-1);\n    else\n        return td->td_customValues[tag_index].info->field_tag;\n}",
          "fn_code_pos": [
            [
              41,
              0
            ],
            [
              50,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetTagListEntry",
            "parameters": {
              "tif": "TIFF",
              "tag_index": "int"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "TIFFTagMethods *TIFFAccessTagMethods( TIFF *tif )\n\n{\n    return &(tif->tif_tagmethods);\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              61,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFAccessTagMethods",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "TIFFTagMethods"
          }
        },
        {
          "fn_code": "void *TIFFGetClientInfo( TIFF *tif, const char *name )\n\n{\n    TIFFClientInfoLink *psLink = tif->tif_clientinfo;\n\n    while( psLink != NULL && strcmp(psLink->name,name) != 0 )\n        psLink = psLink->next;\n\n    if( psLink != NULL )\n        return psLink->data;\n    else\n        return NULL;\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              75,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetClientInfo",
            "parameters": {
              "tif": "TIFF",
              "name": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void TIFFSetClientInfo( TIFF *tif, void *data, const char *name )\n\n{\n    TIFFClientInfoLink *psLink = tif->tif_clientinfo;\n\n    /*\n    ** Do we have an existing link with this name?  If so, just\n    ** set it.\n    */\n    while( psLink != NULL && strcmp(psLink->name,name) != 0 )\n        psLink = psLink->next;\n\n    if( psLink != NULL )\n    {\n        psLink->data = data;\n        return;\n    }\n\n    /*\n    ** Create a new link.\n    */\n\n    psLink = (TIFFClientInfoLink *) _TIFFmalloc(sizeof(TIFFClientInfoLink));\n    assert (psLink != NULL);\n    psLink->next = tif->tif_clientinfo;\n    psLink->name = (char *) _TIFFmalloc((tmsize_t)(strlen(name)+1));\n    assert (psLink->name != NULL);\n    strcpy(psLink->name, name);\n    psLink->data = data;\n\n    tif->tif_clientinfo = psLink;\n}",
          "fn_code_pos": [
            [
              77,
              0
            ],
            [
              108,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetClientInfo",
            "parameters": {
              "tif": "TIFF",
              "data": "void",
              "name": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFAccessTagMethods( TIFF *tif )",
          "fn_dec_pos": [
            [
              57,
              16
            ],
            [
              57,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFAccessTagMethods",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFGetClientInfo( TIFF *tif, const char *name )",
          "fn_dec_pos": [
            [
              63,
              6
            ],
            [
              63,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetClientInfo",
            "parameters": {
              "tif": "TIFF",
              "name": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_dirinfo.c": {
      "fn_def_list": [
        {
          "fn_code": "static void *\ntd_lfind(const void *key, const void *base, size_t *nmemb, size_t size,\n         int(*compar)(const void *, const void *))\n{\n    char *element, *end;\n\n    end = (char *)base + *nmemb * size;\n    for (element = (char *)base; element < end; element += size)\n        if (!compar(key, element))\t\t/* key found */\n            return element;\n\n    return NULL;\n}",
          "fn_code_pos": [
            [
              289,
              0
            ],
            [
              301,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "td_lfind",
            "parameters": {
              "key": "void",
              "base": "void",
              "nmemb": "size_t",
              "size": "size_t",
              "compar": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "const TIFFFieldArray*\n_TIFFGetFields(void)\n{\n\treturn(&tiffFieldArray);\n}",
          "fn_code_pos": [
            [
              303,
              0
            ],
            [
              307,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFGetFields",
            "parameters": {},
            "return_type": "TIFFFieldArray"
          }
        },
        {
          "fn_code": "const TIFFFieldArray*\n_TIFFGetExifFields(void)\n{\n\treturn(&exifFieldArray);\n}",
          "fn_code_pos": [
            [
              309,
              0
            ],
            [
              313,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFGetExifFields",
            "parameters": {},
            "return_type": "TIFFFieldArray"
          }
        },
        {
          "fn_code": "void\n_TIFFSetupFields(TIFF* tif, const TIFFFieldArray* fieldarray)\n{\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\tuint32 i;\n\n\t\tfor (i = 0; i < tif->tif_nfields; i++) {\n\t\t\tTIFFField *fld = tif->tif_fields[i];\n\t\t\tif (fld->field_bit == FIELD_CUSTOM &&\n\t\t\t\tstrncmp(\"Tag \", fld->field_name, 4) == 0) {\n\t\t\t\t\t_TIFFfree(fld->field_name);\n\t\t\t\t\t_TIFFfree(fld);\n\t\t\t\t}\n\t\t}\n\n\t\t_TIFFfree(tif->tif_fields);\n\t\ttif->tif_fields = NULL;\n\t\ttif->tif_nfields = 0;\n\t}\n\tif (!_TIFFMergeFields(tif, fieldarray->fields, fieldarray->count)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFSetupFields\",\n\t\t\t     \"Setting up field info failed\");\n\t}\n}",
          "fn_code_pos": [
            [
              315,
              0
            ],
            [
              338,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFSetupFields",
            "parameters": {
              "tif": "TIFF",
              "fieldarray": "TIFFFieldArray"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ntagCompare(const void* a, const void* b)\n{\n\tconst TIFFField* ta = *(const TIFFField**) a;\n\tconst TIFFField* tb = *(const TIFFField**) b;\n\t/* NB: be careful of return values for 16-bit platforms */\n\tif (ta->field_tag != tb->field_tag)\n\t\treturn (int)ta->field_tag - (int)tb->field_tag;\n\telse\n\t\treturn (ta->field_type == TIFF_ANY) ?\n\t\t\t0 : ((int)tb->field_type - (int)ta->field_type);\n}",
          "fn_code_pos": [
            [
              340,
              0
            ],
            [
              351,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tagCompare",
            "parameters": {
              "a": "void",
              "b": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ntagNameCompare(const void* a, const void* b)\n{\n\tconst TIFFField* ta = *(const TIFFField**) a;\n\tconst TIFFField* tb = *(const TIFFField**) b;\n\tint ret = strcmp(ta->field_name, tb->field_name);\n\n\tif (ret)\n\t\treturn ret;\n\telse\n\t\treturn (ta->field_type == TIFF_ANY) ?\n\t\t\t0 : ((int)tb->field_type - (int)ta->field_type);\n}",
          "fn_code_pos": [
            [
              353,
              0
            ],
            [
              365,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tagNameCompare",
            "parameters": {
              "a": "void",
              "b": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\n_TIFFMergeFields(TIFF* tif, const TIFFField info[], uint32 n)\n{\n\tstatic const char module[] = \"_TIFFMergeFields\";\n\tstatic const char reason[] = \"for fields array\";\n\t/* TIFFField** tp; */\n\tuint32 i;\n\n        tif->tif_foundfield = NULL;\n\n\tif (tif->tif_fields && tif->tif_nfields > 0) {\n\t\ttif->tif_fields = (TIFFField**)\n\t\t\t_TIFFCheckRealloc(tif, tif->tif_fields,\n\t\t\t\t\t  (tif->tif_nfields + n),\n\t\t\t\t\t  sizeof(TIFFField *), reason);\n\t} else {\n\t\ttif->tif_fields = (TIFFField **)\n\t\t\t_TIFFCheckMalloc(tif, n, sizeof(TIFFField *),\n\t\t\t\t\t reason);\n\t}\n\tif (!tif->tif_fields) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Failed to allocate fields array\");\n\t\treturn 0;\n\t}\n\n\t/* tp = tif->tif_fields + tif->tif_nfields; */\n\tfor (i = 0; i < n; i++) {\n\t\tconst TIFFField *fip =\n\t\t\tTIFFFindField(tif, info[i].field_tag, TIFF_ANY);\n\n                /* only add definitions that aren't already present */\n\t\tif (!fip) {\n                        tif->tif_fields[tif->tif_nfields] = (TIFFField *) (info+i);\n                        tif->tif_nfields++;\n                }\n\t}\n\n        /* Sort the field info by tag number */\n\tqsort(tif->tif_fields, tif->tif_nfields,\n\t      sizeof(TIFFField *), tagCompare);\n\n\treturn n;\n}",
          "fn_code_pos": [
            [
              367,
              0
            ],
            [
              410,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFMergeFields",
            "parameters": {
              "tif": "TIFF",
              "info": "TIFFField",
              "n": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\n_TIFFPrintFieldInfo(TIFF* tif, FILE* fd)\n{\n\tuint32 i;\n\n\tfprintf(fd, \"%s: \\n\", tif->tif_name);\n\tfor (i = 0; i < tif->tif_nfields; i++) {\n\t\tconst TIFFField* fip = tif->tif_fields[i];\n\t\tfprintf(fd, \"field[%2d] %5lu, %2d, %2d, %d, %2d, %5s, %5s, %s\\n\"\n\t\t\t, (int)i\n\t\t\t, (unsigned long) fip->field_tag\n\t\t\t, fip->field_readcount, fip->field_writecount\n\t\t\t, fip->field_type\n\t\t\t, fip->field_bit\n\t\t\t, fip->field_oktochange ? \"TRUE\" : \"FALSE\"\n\t\t\t, fip->field_passcount ? \"TRUE\" : \"FALSE\"\n\t\t\t, fip->field_name\n\t\t);\n\t}\n}",
          "fn_code_pos": [
            [
              412,
              0
            ],
            [
              431,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFPrintFieldInfo",
            "parameters": {
              "tif": "TIFF",
              "fd": "FILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\nTIFFDataWidth(TIFFDataType type)\n{\n\tswitch(type)\n\t{\n\t\tcase 0:  /* nothing */\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_UNDEFINED:\n\t\t\treturn 1;\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\treturn 2;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_FLOAT:\n\t\tcase TIFF_IFD:\n\t\t\treturn 4;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\tcase TIFF_DOUBLE:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\tcase TIFF_IFD8:\n\t\t\treturn 8;\n\t\tdefault:\n\t\t\treturn 0; /* will return 0 for unknown types */\n\t}\n}",
          "fn_code_pos": [
            [
              436,
              0
            ],
            [
              465,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFDataWidth",
            "parameters": {
              "type": "TIFFDataType"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\n_TIFFDataSize(TIFFDataType type)\n{\n\tswitch (type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\n\t\t    return 1;\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t    return 2;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_FLOAT:\n\t\tcase TIFF_IFD:\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\t    return 4;\n\t\tcase TIFF_DOUBLE:\n\t\tcase TIFF_LONG8:\n\t\tcase TIFF_SLONG8:\n\t\tcase TIFF_IFD8:\n\t\t    return 8;\n\t\tdefault:\n\t\t    return 0;\n\t}\n}",
          "fn_code_pos": [
            [
              474,
              0
            ],
            [
              502,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFDataSize",
            "parameters": {
              "type": "TIFFDataType"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const TIFFField*\nTIFFFindField(TIFF* tif, uint32 tag, TIFFDataType dt)\n{\n\tTIFFField key = {0, 0, 0, TIFF_NOTYPE, 0, 0, 0, 0, 0, 0, NULL, NULL};\n\tTIFFField* pkey = &key;\n\tconst TIFFField **ret;\n\tif (tif->tif_foundfield && tif->tif_foundfield->field_tag == tag &&\n\t    (dt == TIFF_ANY || dt == tif->tif_foundfield->field_type))\n\t\treturn tif->tif_foundfield;\n\n\t/* If we are invoked with no field information, then just return. */\n\tif (!tif->tif_fields)\n\t\treturn NULL;\n\n\t/* NB: use sorted search (e.g. binary search) */\n\n\tkey.field_tag = tag;\n\tkey.field_type = dt;\n\n\tret = (const TIFFField **) bsearch(&pkey, tif->tif_fields,\n\t\t\t\t\t   tif->tif_nfields,\n\t\t\t\t\t   sizeof(TIFFField *), tagCompare);\n\treturn tif->tif_foundfield = (ret ? *ret : NULL);\n}",
          "fn_code_pos": [
            [
              504,
              0
            ],
            [
              527,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFindField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "dt": "TIFFDataType"
            },
            "return_type": "TIFFField"
          }
        },
        {
          "fn_code": "static const TIFFField*\n_TIFFFindFieldByName(TIFF* tif, const char *field_name, TIFFDataType dt)\n{\n\tTIFFField key = {0, 0, 0, TIFF_NOTYPE, 0, 0, 0, 0, 0, 0, NULL, NULL};\n\tTIFFField* pkey = &key;\n\tconst TIFFField **ret;\n\tif (tif->tif_foundfield\n\t    && streq(tif->tif_foundfield->field_name, field_name)\n\t    && (dt == TIFF_ANY || dt == tif->tif_foundfield->field_type))\n\t\treturn (tif->tif_foundfield);\n\n\t/* If we are invoked with no field information, then just return. */\n\tif (!tif->tif_fields)\n\t\treturn NULL;\n\n\t/* NB: use linear search since list is sorted by key#, not name */\n\n\tkey.field_name = (char *)field_name;\n\tkey.field_type = dt;\n\n\tret = (const TIFFField **) \n            td_lfind(&pkey, tif->tif_fields, &tif->tif_nfields,\n                     sizeof(TIFFField *), tagNameCompare);\n\n\treturn tif->tif_foundfield = (ret ? *ret : NULL);\n}",
          "fn_code_pos": [
            [
              529,
              0
            ],
            [
              554,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFFindFieldByName",
            "parameters": {
              "tif": "TIFF",
              "field_name": "char",
              "dt": "TIFFDataType"
            },
            "return_type": "TIFFField"
          }
        },
        {
          "fn_code": "const TIFFField*\nTIFFFieldWithTag(TIFF* tif, uint32 tag)\n{\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif (!fip) {\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFFieldWithTag\",\n\t\t\t     \"Internal error, unknown tag 0x%x\",\n\t\t\t     (unsigned int) tag);\n\t}\n\treturn (fip);\n}",
          "fn_code_pos": [
            [
              556,
              0
            ],
            [
              566,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldWithTag",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32"
            },
            "return_type": "TIFFField"
          }
        },
        {
          "fn_code": "const TIFFField*\nTIFFFieldWithName(TIFF* tif, const char *field_name)\n{\n\tconst TIFFField* fip =\n\t\t_TIFFFindFieldByName(tif, field_name, TIFF_ANY);\n\tif (!fip) {\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFFieldWithName\",\n\t\t\t     \"Internal error, unknown tag %s\", field_name);\n\t}\n\treturn (fip);\n}",
          "fn_code_pos": [
            [
              568,
              0
            ],
            [
              578,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldWithName",
            "parameters": {
              "tif": "TIFF",
              "field_name": "char"
            },
            "return_type": "TIFFField"
          }
        },
        {
          "fn_code": "uint32\nTIFFFieldTag(const TIFFField* fip)\n{\n\treturn fip->field_tag;\n}",
          "fn_code_pos": [
            [
              580,
              0
            ],
            [
              584,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldTag",
            "parameters": {
              "fip": "TIFFField"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "const char *\nTIFFFieldName(const TIFFField* fip)\n{\n\treturn fip->field_name;\n}",
          "fn_code_pos": [
            [
              586,
              0
            ],
            [
              590,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldName",
            "parameters": {
              "fip": "TIFFField"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "TIFFDataType\nTIFFFieldDataType(const TIFFField* fip)\n{\n\treturn fip->field_type;\n}",
          "fn_code_pos": [
            [
              592,
              0
            ],
            [
              596,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldDataType",
            "parameters": {
              "fip": "TIFFField"
            },
            "return_type": "TIFFDataType"
          }
        },
        {
          "fn_code": "int\nTIFFFieldPassCount(const TIFFField* fip)\n{\n\treturn fip->field_passcount;\n}",
          "fn_code_pos": [
            [
              598,
              0
            ],
            [
              602,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldPassCount",
            "parameters": {
              "fip": "TIFFField"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFFieldReadCount(const TIFFField* fip)\n{\n\treturn fip->field_readcount;\n}",
          "fn_code_pos": [
            [
              604,
              0
            ],
            [
              608,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldReadCount",
            "parameters": {
              "fip": "TIFFField"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFFieldWriteCount(const TIFFField* fip)\n{\n\treturn fip->field_writecount;\n}",
          "fn_code_pos": [
            [
              610,
              0
            ],
            [
              614,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldWriteCount",
            "parameters": {
              "fip": "TIFFField"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const TIFFField*\n_TIFFFindOrRegisterField(TIFF *tif, uint32 tag, TIFFDataType dt)\n\n{\n\tconst TIFFField *fld;\n\n\tfld = TIFFFindField(tif, tag, dt);\n\tif (fld == NULL) {\n\t\tfld = _TIFFCreateAnonField(tif, tag, dt);\n\t\tif (!_TIFFMergeFields(tif, fld, 1))\n\t\t\treturn NULL;\n\t}\n\n\treturn fld;\n}",
          "fn_code_pos": [
            [
              616,
              0
            ],
            [
              630,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFFindOrRegisterField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "dt": "TIFFDataType"
            },
            "return_type": "TIFFField"
          }
        },
        {
          "fn_code": "TIFFField*\n_TIFFCreateAnonField(TIFF *tif, uint32 tag, TIFFDataType field_type)\n{\n\tTIFFField *fld;\n\t(void) tif;\n\n\tfld = (TIFFField *) _TIFFmalloc(sizeof (TIFFField));\n\tif (fld == NULL)\n\t    return NULL;\n\t_TIFFmemset(fld, 0, sizeof(TIFFField));\n\n\tfld->field_tag = tag;\n\tfld->field_readcount = TIFF_VARIABLE2;\n\tfld->field_writecount = TIFF_VARIABLE2;\n\tfld->field_type = field_type;\n\tfld->reserved = 0;\n\tswitch (field_type)\n\t{\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_UNDEFINED:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT8;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT8;\n\t\t\tbreak;\n\t\tcase TIFF_ASCII:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_ASCII;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_ASCII;\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT16;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT16;\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT32;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT32;\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\tcase TIFF_FLOAT:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_FLOAT;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_FLOAT;\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT8;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT8;\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT16;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT16;\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT32;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT32;\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_DOUBLE;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_DOUBLE;\n\t\t\tbreak;\n\t\tcase TIFF_IFD:\n\t\tcase TIFF_IFD8:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_IFD8;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_IFD8;\n\t\t\tbreak;\n\t\tcase TIFF_LONG8:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_UINT64;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_UINT64;\n\t\t\tbreak;\n\t\tcase TIFF_SLONG8:\n\t\t\tfld->set_field_type = TIFF_SETGET_C32_SINT64;\n\t\t\tfld->get_field_type = TIFF_SETGET_C32_SINT64;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfld->set_field_type = TIFF_SETGET_UNDEFINED;\n\t\t\tfld->get_field_type = TIFF_SETGET_UNDEFINED;\n\t\t\tbreak;\n\t}\n\tfld->field_bit = FIELD_CUSTOM;\n\tfld->field_oktochange = TRUE;\n\tfld->field_passcount = TRUE;\n\tfld->field_name = (char *) _TIFFmalloc(32);\n\tif (fld->field_name == NULL) {\n\t    _TIFFfree(fld);\n\t    return NULL;\n\t}\n\tfld->field_subfields = NULL;\n\n\t/* \n\t * note that this name is a special sign to TIFFClose() and\n\t * _TIFFSetupFields() to free the field\n\t */\n\t(void) snprintf(fld->field_name, 32, \"Tag %d\", (int) tag);\n\n\treturn fld;    \n}",
          "fn_code_pos": [
            [
              632,
              0
            ],
            [
              724,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFCreateAnonField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "field_type": "TIFFDataType"
            },
            "return_type": "TIFFField"
          }
        },
        {
          "fn_code": "static TIFFSetGetFieldType\n_TIFFSetGetType(TIFFDataType type, short count, unsigned char passcount)\n{\n\tif (type == TIFF_ASCII && count == TIFF_VARIABLE && passcount == 0)\n\t\treturn TIFF_SETGET_ASCII;\n\n\telse if (count == 1 && passcount == 0) {\n\t\tswitch (type)\n\t\t{\n\t\t\tcase TIFF_BYTE:\n\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\treturn TIFF_SETGET_UINT8;\n\t\t\tcase TIFF_ASCII:\n\t\t\t\treturn TIFF_SETGET_ASCII;\n\t\t\tcase TIFF_SHORT:\n\t\t\t\treturn TIFF_SETGET_UINT16;\n\t\t\tcase TIFF_LONG:\n\t\t\t\treturn TIFF_SETGET_UINT32;\n\t\t\tcase TIFF_RATIONAL:\n\t\t\tcase TIFF_SRATIONAL:\n\t\t\tcase TIFF_FLOAT:\n\t\t\t\treturn TIFF_SETGET_FLOAT;\n\t\t\tcase TIFF_SBYTE:\n\t\t\t\treturn TIFF_SETGET_SINT8;\n\t\t\tcase TIFF_SSHORT:\n\t\t\t\treturn TIFF_SETGET_SINT16;\n\t\t\tcase TIFF_SLONG:\n\t\t\t\treturn TIFF_SETGET_SINT32;\n\t\t\tcase TIFF_DOUBLE:\n\t\t\t\treturn TIFF_SETGET_DOUBLE;\n\t\t\tcase TIFF_IFD:\n\t\t\tcase TIFF_IFD8:\n\t\t\t\treturn TIFF_SETGET_IFD8;\n\t\t\tcase TIFF_LONG8:\n\t\t\t\treturn TIFF_SETGET_UINT64;\n\t\t\tcase TIFF_SLONG8:\n\t\t\t\treturn TIFF_SETGET_SINT64;\n\t\t\tdefault:\n\t\t\t\treturn TIFF_SETGET_UNDEFINED;\n\t\t}\n\t}\n\n\telse if (count >= 1 && passcount == 0) {\n\t\tswitch (type)\n\t\t{\n\t\t\tcase TIFF_BYTE:\n\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\treturn TIFF_SETGET_C0_UINT8;\n\t\t\tcase TIFF_ASCII:\n\t\t\t\treturn TIFF_SETGET_C0_ASCII;\n\t\t\tcase TIFF_SHORT:\n\t\t\t\treturn TIFF_SETGET_C0_UINT16;\n\t\t\tcase TIFF_LONG:\n\t\t\t\treturn TIFF_SETGET_C0_UINT32;\n\t\t\tcase TIFF_RATIONAL:\n\t\t\tcase TIFF_SRATIONAL:\n\t\t\tcase TIFF_FLOAT:\n\t\t\t\treturn TIFF_SETGET_C0_FLOAT;\n\t\t\tcase TIFF_SBYTE:\n\t\t\t\treturn TIFF_SETGET_C0_SINT8;\n\t\t\tcase TIFF_SSHORT:\n\t\t\t\treturn TIFF_SETGET_C0_SINT16;\n\t\t\tcase TIFF_SLONG:\n\t\t\t\treturn TIFF_SETGET_C0_SINT32;\n\t\t\tcase TIFF_DOUBLE:\n\t\t\t\treturn TIFF_SETGET_C0_DOUBLE;\n\t\t\tcase TIFF_IFD:\n\t\t\tcase TIFF_IFD8:\n\t\t\t\treturn TIFF_SETGET_C0_IFD8;\n\t\t\tcase TIFF_LONG8:\n\t\t\t\treturn TIFF_SETGET_C0_UINT64;\n\t\t\tcase TIFF_SLONG8:\n\t\t\t\treturn TIFF_SETGET_C0_SINT64;\n\t\t\tdefault:\n\t\t\t\treturn TIFF_SETGET_UNDEFINED;\n\t\t}\n\t}\n\n\telse if (count == TIFF_VARIABLE && passcount == 1) {\n\t\tswitch (type)\n\t\t{\n\t\t\tcase TIFF_BYTE:\n\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\treturn TIFF_SETGET_C16_UINT8;\n\t\t\tcase TIFF_ASCII:\n\t\t\t\treturn TIFF_SETGET_C16_ASCII;\n\t\t\tcase TIFF_SHORT:\n\t\t\t\treturn TIFF_SETGET_C16_UINT16;\n\t\t\tcase TIFF_LONG:\n\t\t\t\treturn TIFF_SETGET_C16_UINT32;\n\t\t\tcase TIFF_RATIONAL:\n\t\t\tcase TIFF_SRATIONAL:\n\t\t\tcase TIFF_FLOAT:\n\t\t\t\treturn TIFF_SETGET_C16_FLOAT;\n\t\t\tcase TIFF_SBYTE:\n\t\t\t\treturn TIFF_SETGET_C16_SINT8;\n\t\t\tcase TIFF_SSHORT:\n\t\t\t\treturn TIFF_SETGET_C16_SINT16;\n\t\t\tcase TIFF_SLONG:\n\t\t\t\treturn TIFF_SETGET_C16_SINT32;\n\t\t\tcase TIFF_DOUBLE:\n\t\t\t\treturn TIFF_SETGET_C16_DOUBLE;\n\t\t\tcase TIFF_IFD:\n\t\t\tcase TIFF_IFD8:\n\t\t\t\treturn TIFF_SETGET_C16_IFD8;\n\t\t\tcase TIFF_LONG8:\n\t\t\t\treturn TIFF_SETGET_C16_UINT64;\n\t\t\tcase TIFF_SLONG8:\n\t\t\t\treturn TIFF_SETGET_C16_SINT64;\n\t\t\tdefault:\n\t\t\t\treturn TIFF_SETGET_UNDEFINED;\n\t\t}\n\t}\n\n\telse if (count == TIFF_VARIABLE2 && passcount == 1) {\n\t\tswitch (type)\n\t\t{\n\t\t\tcase TIFF_BYTE:\n\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\treturn TIFF_SETGET_C32_UINT8;\n\t\t\tcase TIFF_ASCII:\n\t\t\t\treturn TIFF_SETGET_C32_ASCII;\n\t\t\tcase TIFF_SHORT:\n\t\t\t\treturn TIFF_SETGET_C32_UINT16;\n\t\t\tcase TIFF_LONG:\n\t\t\t\treturn TIFF_SETGET_C32_UINT32;\n\t\t\tcase TIFF_RATIONAL:\n\t\t\tcase TIFF_SRATIONAL:\n\t\t\tcase TIFF_FLOAT:\n\t\t\t\treturn TIFF_SETGET_C32_FLOAT;\n\t\t\tcase TIFF_SBYTE:\n\t\t\t\treturn TIFF_SETGET_C32_SINT8;\n\t\t\tcase TIFF_SSHORT:\n\t\t\t\treturn TIFF_SETGET_C32_SINT16;\n\t\t\tcase TIFF_SLONG:\n\t\t\t\treturn TIFF_SETGET_C32_SINT32;\n\t\t\tcase TIFF_DOUBLE:\n\t\t\t\treturn TIFF_SETGET_C32_DOUBLE;\n\t\t\tcase TIFF_IFD:\n\t\t\tcase TIFF_IFD8:\n\t\t\t\treturn TIFF_SETGET_C32_IFD8;\n\t\t\tcase TIFF_LONG8:\n\t\t\t\treturn TIFF_SETGET_C32_UINT64;\n\t\t\tcase TIFF_SLONG8:\n\t\t\t\treturn TIFF_SETGET_C32_SINT64;\n\t\t\tdefault:\n\t\t\t\treturn TIFF_SETGET_UNDEFINED;\n\t\t}\n\t}\n\n\treturn TIFF_SETGET_UNDEFINED;\n}",
          "fn_code_pos": [
            [
              733,
              0
            ],
            [
              884,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFSetGetType",
            "parameters": {
              "type": "TIFFDataType",
              "count": "short",
              "passcount": "unsigned char"
            },
            "return_type": "TIFFSetGetFieldType"
          }
        },
        {
          "fn_code": "int\nTIFFMergeFieldInfo(TIFF* tif, const TIFFFieldInfo info[], uint32 n)\n{\n\tstatic const char module[] = \"TIFFMergeFieldInfo\";\n\tstatic const char reason[] = \"for fields array\";\n\tTIFFField *tp;\n\tsize_t nfields;\n\tuint32 i;\n\n\tif (tif->tif_nfieldscompat > 0) {\n\t\ttif->tif_fieldscompat = (TIFFFieldArray *)\n\t\t\t_TIFFCheckRealloc(tif, tif->tif_fieldscompat,\n\t\t\t\t\t  tif->tif_nfieldscompat + 1,\n\t\t\t\t\t  sizeof(TIFFFieldArray), reason);\n\t} else {\n\t\ttif->tif_fieldscompat = (TIFFFieldArray *)\n\t\t\t_TIFFCheckMalloc(tif, 1, sizeof(TIFFFieldArray),\n\t\t\t\t\t reason);\n\t}\n\tif (!tif->tif_fieldscompat) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Failed to allocate fields array\");\n\t\treturn -1;\n\t}\n\tnfields = tif->tif_nfieldscompat++;\n\n\ttif->tif_fieldscompat[nfields].type = tfiatOther;\n\ttif->tif_fieldscompat[nfields].allocated_size = n;\n\ttif->tif_fieldscompat[nfields].count = n;\n\ttif->tif_fieldscompat[nfields].fields =\n\t\t(TIFFField *)_TIFFCheckMalloc(tif, n, sizeof(TIFFField),\n\t\t\t\t\t      reason);\n\tif (!tif->tif_fieldscompat[nfields].fields) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Failed to allocate fields array\");\n\t\treturn -1;\n\t}\n\n\ttp = tif->tif_fieldscompat[nfields].fields;\n\tfor (i = 0; i < n; i++) {\n\t\ttp->field_tag = info[i].field_tag;\n\t\ttp->field_readcount = info[i].field_readcount;\n\t\ttp->field_writecount = info[i].field_writecount;\n\t\ttp->field_type = info[i].field_type;\n\t\ttp->reserved = 0;\n\t\ttp->set_field_type =\n\t\t     _TIFFSetGetType(info[i].field_type,\n\t\t\t\tinfo[i].field_readcount,\n\t\t\t\tinfo[i].field_passcount);\n\t\ttp->get_field_type =\n\t\t     _TIFFSetGetType(info[i].field_type,\n\t\t\t\tinfo[i].field_readcount,\n\t\t\t\tinfo[i].field_passcount);\n\t\ttp->field_bit = info[i].field_bit;\n\t\ttp->field_oktochange = info[i].field_oktochange;\n\t\ttp->field_passcount = info[i].field_passcount;\n\t\ttp->field_name = info[i].field_name;\n\t\ttp->field_subfields = NULL;\n\t\ttp++;\n\t}\n\n\tif (!_TIFFMergeFields(tif, tif->tif_fieldscompat[nfields].fields, n)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Setting up field info failed\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              886,
              0
            ],
            [
              954,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFMergeFieldInfo",
            "parameters": {
              "tif": "TIFF",
              "info": "TIFFFieldInfo",
              "n": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\n_TIFFCheckFieldIsValidForCodec(TIFF *tif, ttag_t tag)\n{\n\t/* Filter out non-codec specific tags */\n\tswitch (tag) {\n\t    /* Shared tags */\n\t    case TIFFTAG_PREDICTOR:\n\t    /* JPEG tags */\n\t    case TIFFTAG_JPEGTABLES:\n\t    /* OJPEG tags */\n\t    case TIFFTAG_JPEGIFOFFSET:\n\t    case TIFFTAG_JPEGIFBYTECOUNT:\n\t    case TIFFTAG_JPEGQTABLES:\n\t    case TIFFTAG_JPEGDCTABLES:\n\t    case TIFFTAG_JPEGACTABLES:\n\t    case TIFFTAG_JPEGPROC:\n\t    case TIFFTAG_JPEGRESTARTINTERVAL:\n\t    /* CCITT* */\n\t    case TIFFTAG_BADFAXLINES:\n\t    case TIFFTAG_CLEANFAXDATA:\n\t    case TIFFTAG_CONSECUTIVEBADFAXLINES:\n\t    case TIFFTAG_GROUP3OPTIONS:\n\t    case TIFFTAG_GROUP4OPTIONS:\n\t    /* LERC */\n\t    case TIFFTAG_LERC_PARAMETERS:\n\t\tbreak;\n\t    default:\n\t\treturn 1;\n\t}\n\t/* Check if codec specific tags are allowed for the current\n\t * compression scheme (codec) */\n\tswitch (tif->tif_dir.td_compression) {\n\t    case COMPRESSION_LZW:\n\t\tif (tag == TIFFTAG_PREDICTOR)\n\t\t    return 1;\n\t\tbreak;\n\t    case COMPRESSION_PACKBITS:\n\t\t/* No codec-specific tags */\n\t\tbreak;\n\t    case COMPRESSION_THUNDERSCAN:\n\t\t/* No codec-specific tags */\n\t\tbreak;\n\t    case COMPRESSION_NEXT:\n\t\t/* No codec-specific tags */\n\t\tbreak;\n\t    case COMPRESSION_JPEG:\n\t\tif (tag == TIFFTAG_JPEGTABLES)\n\t\t    return 1;\n\t\tbreak;\n\t    case COMPRESSION_OJPEG:\n\t\tswitch (tag) {\n\t\t    case TIFFTAG_JPEGIFOFFSET:\n\t\t    case TIFFTAG_JPEGIFBYTECOUNT:\n\t\t    case TIFFTAG_JPEGQTABLES:\n\t\t    case TIFFTAG_JPEGDCTABLES:\n\t\t    case TIFFTAG_JPEGACTABLES:\n\t\t    case TIFFTAG_JPEGPROC:\n\t\t    case TIFFTAG_JPEGRESTARTINTERVAL:\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\t    case COMPRESSION_CCITTRLE:\n\t    case COMPRESSION_CCITTRLEW:\n\t    case COMPRESSION_CCITTFAX3:\n\t    case COMPRESSION_CCITTFAX4:\n\t\tswitch (tag) {\n\t\t    case TIFFTAG_BADFAXLINES:\n\t\t    case TIFFTAG_CLEANFAXDATA:\n\t\t    case TIFFTAG_CONSECUTIVEBADFAXLINES:\n\t\t\treturn 1;\n\t\t    case TIFFTAG_GROUP3OPTIONS:\n\t\t\tif (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX3)\n\t\t\t    return 1;\n\t\t\tbreak;\n\t\t    case TIFFTAG_GROUP4OPTIONS:\n\t\t\tif (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX4)\n\t\t\t    return 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t    case COMPRESSION_JBIG:\n\t\t/* No codec-specific tags */\n\t\tbreak;\n\t    case COMPRESSION_DEFLATE:\n\t    case COMPRESSION_ADOBE_DEFLATE:\n\t\tif (tag == TIFFTAG_PREDICTOR)\n\t\t    return 1;\n\t\tbreak;\n\t   case COMPRESSION_PIXARLOG:\n\t\tif (tag == TIFFTAG_PREDICTOR)\n\t\t    return 1;\n\t\tbreak;\n\t    case COMPRESSION_SGILOG:\n\t    case COMPRESSION_SGILOG24:\n\t\t/* No codec-specific tags */\n\t\tbreak;\n\t    case COMPRESSION_LZMA:\n\t\tif (tag == TIFFTAG_PREDICTOR)\n\t\t    return 1;\n\t\tbreak;\n\t    case COMPRESSION_ZSTD:\n\t\tif (tag == TIFFTAG_PREDICTOR)\n\t\t    return 1;\n\t\tbreak;\n\t    case COMPRESSION_LERC:\n\t\tif (tag == TIFFTAG_LERC_PARAMETERS)\n\t\t    return 1;\n\t\tbreak;\n\t\t  case COMPRESSION_WEBP:\n\t\tif (tag == TIFFTAG_PREDICTOR)\n\t\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              956,
              0
            ],
            [
              1070,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFCheckFieldIsValidForCodec",
            "parameters": {
              "tif": "TIFF",
              "tag": "ttag_t"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "td_lfind(const void *key, const void *base, size_t *nmemb, size_t size,\n         int(*compar)(const void *, const void *))",
          "fn_dec_pos": [
            [
              290,
              0
            ],
            [
              291,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "td_lfind",
            "parameters": {
              "key": "void",
              "base": "void",
              "nmemb": "size_t",
              "size": "size_t",
              "compar": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*compar)(const void *, const void *)",
          "fn_dec_pos": [
            [
              291,
              12
            ],
            [
              291,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFGetFields(void)",
          "fn_dec_pos": [
            [
              304,
              0
            ],
            [
              304,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFGetFields",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFGetExifFields(void)",
          "fn_dec_pos": [
            [
              310,
              0
            ],
            [
              310,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFGetExifFields",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFFindField(TIFF* tif, uint32 tag, TIFFDataType dt)",
          "fn_dec_pos": [
            [
              505,
              0
            ],
            [
              505,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFindField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "dt": "TIFFDataType"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFFindFieldByName(TIFF* tif, const char *field_name, TIFFDataType dt)",
          "fn_dec_pos": [
            [
              530,
              0
            ],
            [
              530,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFFindFieldByName",
            "parameters": {
              "tif": "TIFF",
              "field_name": "char",
              "dt": "TIFFDataType"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFFieldWithTag(TIFF* tif, uint32 tag)",
          "fn_dec_pos": [
            [
              557,
              0
            ],
            [
              557,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldWithTag",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFFieldWithName(TIFF* tif, const char *field_name)",
          "fn_dec_pos": [
            [
              569,
              0
            ],
            [
              569,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldWithName",
            "parameters": {
              "tif": "TIFF",
              "field_name": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFFieldName(const TIFFField* fip)",
          "fn_dec_pos": [
            [
              587,
              0
            ],
            [
              587,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldName",
            "parameters": {
              "fip": "TIFFField"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFFindOrRegisterField(TIFF *tif, uint32 tag, TIFFDataType dt)",
          "fn_dec_pos": [
            [
              617,
              0
            ],
            [
              617,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFFindOrRegisterField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "dt": "TIFFDataType"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFCreateAnonField(TIFF *tif, uint32 tag, TIFFDataType field_type)",
          "fn_dec_pos": [
            [
              633,
              0
            ],
            [
              633,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFCreateAnonField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "field_type": "TIFFDataType"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/mkg3states.c": {
      "fn_def_list": [
        {
          "fn_code": "static void\nFillTable(TIFFFaxTabEnt *T, int Size, struct proto *P, int State)\n{\n    int limit = 1 << Size;\n\n    while (P->val) {\n\tint width = P->val & 15;\n\tint param = P->val >> 4;\n\tint incr = 1 << width;\n\tint code;\n\tfor (code = P->code; code < limit; code += incr) {\n\t    TIFFFaxTabEnt *E = T+code;\n\t    E->State = State;\n\t    E->Width = width;\n\t    E->Param = param;\n\t}\n\tP++;\n    }\n}",
          "fn_code_pos": [
            [
              316,
              0
            ],
            [
              334,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FillTable",
            "parameters": {
              "T": "TIFFFaxTabEnt",
              "Size": "int",
              "P": "struct proto",
              "State": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nWriteTable(FILE* fd, const TIFFFaxTabEnt* T, int Size, const char* name)\n{\n    int i;\n    char* sep;\n\n    fprintf(fd, \"%s %s TIFFFaxTabEnt %s[%d] = {\",\n\tstorage_class, const_class, name, Size);\n    if (packoutput) {\n\tsep = \"\\n\";\n\tfor (i = 0; i < Size; i++) {\n\t    fprintf(fd, \"%s%s%d,%d,%d%s\",\n\t\tsep, prebrace, T->State, T->Width, (int) T->Param, postbrace);\n\t    if (((i+1) % 10) == 0)\n\t\t    sep = \",\\n\";\n\t    else\n\t\t    sep = \",\";\n\t    T++;\n\t}\n    } else {\n\tsep = \"\\n \";\n\tfor (i = 0; i < Size; i++) {\n\t    fprintf(fd, \"%s%s%3d,%3d,%4d%s\",\n\t\tsep, prebrace, T->State, T->Width, (int) T->Param, postbrace);\n\t    if (((i+1) % 6) == 0)\n\t\t    sep = \",\\n \";\n\t    else\n\t\t    sep = \",\";\n\t    T++;\n\t}\n    }\n    fprintf(fd, \"\\n};\\n\");\n}",
          "fn_code_pos": [
            [
              342,
              0
            ],
            [
              374,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteTable",
            "parameters": {
              "fd": "FILE",
              "T": "TIFFFaxTabEnt",
              "Size": "int",
              "name": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n    FILE* fd;\n    char* outputfile;\n    int c;\n\n#if !HAVE_DECL_OPTARG\n    extern int optind;\n    extern char* optarg;\n#endif\n\n    while ((c = getopt(argc, argv, \"c:s:bp\")) != -1)\n\tswitch (c) {\n\tcase 'c':\n\t    const_class = optarg;\n\t    break;\n\tcase 's':\n\t    storage_class = optarg;\n\t    break;\n\tcase 'p':\n\t    packoutput = 0;\n\t    break;\n\tcase 'b':\n\t    prebrace = \"{\";\n\t    postbrace = \"}\";\n\t    break;\n\tcase '?':\n\t    fprintf(stderr,\n\t\t\"usage: %s [-c const] [-s storage] [-p] [-b] file\\n\",\n\t\targv[0]);\n\t    return (-1);\n\t}\n    outputfile = optind < argc ? argv[optind] : \"g3states.h\";\n    fd = fopen(outputfile, \"w\");\n    if (fd == NULL) {\n\tfprintf(stderr, \"%s: %s: Cannot create output file.\\n\",\n\t    argv[0], outputfile);\n\treturn (-2);\n    }\n    FillTable(MainTable, 7, Pass, S_Pass);\n    FillTable(MainTable, 7, Horiz, S_Horiz);\n    FillTable(MainTable, 7, V0, S_V0);\n    FillTable(MainTable, 7, VR, S_VR);\n    FillTable(MainTable, 7, VL, S_VL);\n    FillTable(MainTable, 7, Ext, S_Ext);\n    FillTable(MainTable, 7, EOLV, S_EOL);\n    FillTable(WhiteTable, 12, MakeUpW, S_MakeUpW);\n    FillTable(WhiteTable, 12, MakeUp, S_MakeUp);\n    FillTable(WhiteTable, 12, TermW, S_TermW);\n    FillTable(WhiteTable, 12, EOLH, S_EOL);\n    FillTable(BlackTable, 13, MakeUpB, S_MakeUpB);\n    FillTable(BlackTable, 13, MakeUp, S_MakeUp);\n    FillTable(BlackTable, 13, TermB, S_TermB);\n    FillTable(BlackTable, 13, EOLH, S_EOL);\n\n    fprintf(fd, \"/* WARNING, this file was automatically generated by the\\n\");\n    fprintf(fd, \"    mkg3states program */\\n\");\n    fprintf(fd, \"#include \\\"tiff.h\\\"\\n\");\n    fprintf(fd, \"#include \\\"tif_fax3.h\\\"\\n\");\n    WriteTable(fd, MainTable, 128, \"TIFFFaxMainTable\");\n    WriteTable(fd, WhiteTable, 4096, \"TIFFFaxWhiteTable\");\n    WriteTable(fd, BlackTable, 8192, \"TIFFFaxBlackTable\");\n    fclose(fd);\n    return (0);\n}",
          "fn_code_pos": [
            [
              377,
              0
            ],
            [
              442,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "getopt(int, char**, char*)",
          "fn_dec_pos": [
            [
              42,
              11
            ],
            [
              42,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct proto {\n    uint16 code;\t\t/* right justified, lsb-first, zero filled */\n    uint16 val;\t\t/* (pixel count)<<4 + code width  */\n}",
          {
            "code": "uint16",
            "val": "uint16"
          },
          "proto",
          [
            52,
            0
          ],
          [
            55,
            1
          ]
        ],
        [
          "struct proto {\n    uint16 code;\t\t/* right justified, lsb-first, zero filled */\n    uint16 val;\t\t/* (pixel count)<<4 + code width  */\n}",
          {
            "code": "uint16",
            "val": "uint16"
          },
          "proto",
          [
            52,
            0
          ],
          [
            55,
            1
          ]
        ],
        [
          "struct proto",
          {},
          "",
          [
            57,
            7
          ],
          [
            57,
            19
          ]
        ],
        [
          "struct proto",
          {},
          "",
          [
            62,
            7
          ],
          [
            62,
            19
          ]
        ],
        [
          "struct proto",
          {},
          "",
          [
            67,
            7
          ],
          [
            67,
            19
          ]
        ],
        [
          "struct proto",
          {},
          "",
          [
            72,
            7
          ],
          [
            72,
            19
          ]
        ],
        [
          "struct proto",
          {},
          "",
          [
            79,
            7
          ],
          [
            79,
            19
          ]
        ],
        [
          "struct proto",
          {},
          "",
          [
            86,
            7
          ],
          [
            86,
            19
          ]
        ],
        [
          "struct proto",
          {},
          "",
          [
            91,
            7
          ],
          [
            91,
            19
          ]
        ],
        [
          "struct proto",
          {},
          "",
          [
            96,
            7
          ],
          [
            96,
            19
          ]
        ],
        [
          "struct proto",
          {},
          "",
          [
            127,
            7
          ],
          [
            127,
            19
          ]
        ],
        [
          "struct proto",
          {},
          "",
          [
            158,
            7
          ],
          [
            158,
            19
          ]
        ],
        [
          "struct proto",
          {},
          "",
          [
            175,
            7
          ],
          [
            175,
            19
          ]
        ],
        [
          "struct proto",
          {},
          "",
          [
            243,
            7
          ],
          [
            243,
            19
          ]
        ],
        [
          "struct proto",
          {},
          "",
          [
            311,
            7
          ],
          [
            311,
            19
          ]
        ],
        [
          "struct proto",
          {},
          "",
          [
            317,
            38
          ],
          [
            317,
            50
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"tif_fax3.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_lzma.c": {
      "fn_def_list": [
        {
          "fn_code": "static const char *\nLZMAStrerror(lzma_ret ret)\n{\n\tswitch (ret) {\n\t\tcase LZMA_OK:\n\t\t    return \"operation completed successfully\";\n\t\tcase LZMA_STREAM_END:\n\t\t    return \"end of stream was reached\";\n\t\tcase LZMA_NO_CHECK:\n\t\t    return \"input stream has no integrity check\";\n\t\tcase LZMA_UNSUPPORTED_CHECK:\n\t\t    return \"cannot calculate the integrity check\";\n\t\tcase LZMA_GET_CHECK:\n\t\t    return \"integrity check type is now available\";\n\t\tcase LZMA_MEM_ERROR:\n\t\t    return \"cannot allocate memory\";\n\t\tcase LZMA_MEMLIMIT_ERROR:\n\t\t    return \"memory usage limit was reached\";\n\t\tcase LZMA_FORMAT_ERROR:\n\t\t    return \"file format not recognized\";\n\t\tcase LZMA_OPTIONS_ERROR:\n\t\t    return \"invalid or unsupported options\";\n\t\tcase LZMA_DATA_ERROR:\n\t\t    return \"data is corrupt\";\n\t\tcase LZMA_BUF_ERROR:\n\t\t    return \"no progress is possible (stream is truncated or corrupt)\";\n\t\tcase LZMA_PROG_ERROR:\n\t\t    return \"programming error\";\n\t\tdefault:\n\t\t    return \"unidentified liblzma error\";\n\t}\n}",
          "fn_code_pos": [
            [
              66,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZMAStrerror",
            "parameters": {
              "ret": "lzma_ret"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "static int\nLZMAFixupTags(TIFF* tif)\n{\n\t(void) tif;\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              104,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZMAFixupTags",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLZMASetupDecode(TIFF* tif)\n{\n\tLZMAState* sp = DecoderState(tif);\n\n\tassert(sp != NULL);\n        \n        /* if we were last encoding, terminate this mode */\n\tif (sp->state & LSTATE_INIT_ENCODE) {\n\t    lzma_end(&sp->stream);\n\t    sp->state = 0;\n\t}\n\n\tsp->state |= LSTATE_INIT_DECODE;\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              106,
              0
            ],
            [
              121,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZMASetupDecode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLZMAPreDecode(TIFF* tif, uint16 s)\n{\n\tstatic const char module[] = \"LZMAPreDecode\";\n\tLZMAState* sp = DecoderState(tif);\n\tlzma_ret ret;\n\n\t(void) s;\n\tassert(sp != NULL);\n\n\tif( (sp->state & LSTATE_INIT_DECODE) == 0 )\n            tif->tif_setupdecode(tif);\n\n\tsp->stream.next_in = tif->tif_rawdata;\n\tsp->stream.avail_in = (size_t) tif->tif_rawcc;\n\tif ((tmsize_t)sp->stream.avail_in != tif->tif_rawcc) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Liblzma cannot deal with buffers this size\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Disable memory limit when decoding. UINT64_MAX is a flag to disable\n\t * the limit, we are passing (uint64_t)-1 which should be the same.\n\t */\n\tret = lzma_stream_decoder(&sp->stream, (uint64_t)-1, 0);\n\tif (ret != LZMA_OK) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Error initializing the stream decoder, %s\",\n\t\t\t     LZMAStrerror(ret));\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              126,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZMAPreDecode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLZMADecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"LZMADecode\";\n\tLZMAState* sp = DecoderState(tif);\n\n\t(void) s;\n\tassert(sp != NULL);\n\tassert(sp->state == LSTATE_INIT_DECODE);\n\n        sp->stream.next_in = tif->tif_rawcp;\n        sp->stream.avail_in = (size_t) tif->tif_rawcc;\n\n\tsp->stream.next_out = op;\n\tsp->stream.avail_out = (size_t) occ;\n\tif ((tmsize_t)sp->stream.avail_out != occ) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Liblzma cannot deal with buffers this size\");\n\t\treturn 0;\n\t}\n\n\tdo {\n\t\t/*\n\t\t * Save the current stream state to properly recover from the\n\t\t * decoding errors later.\n\t\t */\n\t\tconst uint8_t *next_in = sp->stream.next_in;\n\t\tsize_t avail_in = sp->stream.avail_in;\n\n\t\tlzma_ret ret = lzma_code(&sp->stream, LZMA_RUN);\n\t\tif (ret == LZMA_STREAM_END)\n\t\t\tbreak;\n\t\tif (ret == LZMA_MEMLIMIT_ERROR) {\n\t\t\tlzma_ret r = lzma_stream_decoder(&sp->stream,\n\t\t\t\t\t\t\t lzma_memusage(&sp->stream), 0);\n\t\t\tif (r != LZMA_OK) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Error initializing the stream decoder, %s\",\n\t\t\t\t\t     LZMAStrerror(r));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsp->stream.next_in = next_in;\n\t\t\tsp->stream.avail_in = avail_in;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret != LZMA_OK) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Decoding error at scanline %lu, %s\",\n\t\t\t    (unsigned long) tif->tif_row, LZMAStrerror(ret));\n\t\t\tbreak;\n\t\t}\n\t} while (sp->stream.avail_out > 0);\n\tif (sp->stream.avail_out != 0) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Not enough data at scanline %lu (short %lu bytes)\",\n\t\t    (unsigned long) tif->tif_row, (unsigned long) sp->stream.avail_out);\n\t\treturn 0;\n\t}\n\n        tif->tif_rawcp = (uint8 *)sp->stream.next_in; /* cast away const */\n        tif->tif_rawcc = sp->stream.avail_in;\n        \n\treturn 1;\n}",
          "fn_code_pos": [
            [
              161,
              0
            ],
            [
              224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZMADecode",
            "parameters": {
              "tif": "TIFF",
              "op": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLZMASetupEncode(TIFF* tif)\n{\n\tLZMAState* sp = EncoderState(tif);\n\n\tassert(sp != NULL);\n\tif (sp->state & LSTATE_INIT_DECODE) {\n\t\tlzma_end(&sp->stream);\n\t\tsp->state = 0;\n\t}\n\n\tsp->state |= LSTATE_INIT_ENCODE;\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              226,
              0
            ],
            [
              239,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZMASetupEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLZMAPreEncode(TIFF* tif, uint16 s)\n{\n\tstatic const char module[] = \"LZMAPreEncode\";\n\tLZMAState *sp = EncoderState(tif);\n\tlzma_ret ret;\n\n\t(void) s;\n\tassert(sp != NULL);\n\tif( sp->state != LSTATE_INIT_ENCODE )\n            tif->tif_setupencode(tif);\n\n\tsp->stream.next_out = tif->tif_rawdata;\n\tsp->stream.avail_out = (size_t)tif->tif_rawdatasize;\n\tif ((tmsize_t)sp->stream.avail_out != tif->tif_rawdatasize) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Liblzma cannot deal with buffers this size\");\n\t\treturn 0;\n\t}\n\tret = lzma_stream_encoder(&sp->stream, sp->filters, sp->check);\n\tif (ret != LZMA_OK) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Error in lzma_stream_encoder(): %s\", LZMAStrerror(ret));\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              244,
              0
            ],
            [
              270,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZMAPreEncode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLZMAEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\tstatic const char module[] = \"LZMAEncode\";\n\tLZMAState *sp = EncoderState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->state == LSTATE_INIT_ENCODE);\n\n\t(void) s;\n\tsp->stream.next_in = bp;\n\tsp->stream.avail_in = (size_t) cc;\n\tif ((tmsize_t)sp->stream.avail_in != cc) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Liblzma cannot deal with buffers this size\");\n\t\treturn 0;\n\t}\n\tdo {\n\t\tlzma_ret ret = lzma_code(&sp->stream, LZMA_RUN);\n\t\tif (ret != LZMA_OK) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"Encoding error at scanline %lu, %s\",\n\t\t\t\t(unsigned long) tif->tif_row, LZMAStrerror(ret));\n\t\t\treturn 0;\n\t\t}\n\t\tif (sp->stream.avail_out == 0) {\n\t\t\ttif->tif_rawcc = tif->tif_rawdatasize;\n\t\t\tTIFFFlushData1(tif);\n\t\t\tsp->stream.next_out = tif->tif_rawdata;\n\t\t\tsp->stream.avail_out = (size_t)tif->tif_rawdatasize;  /* this is a safe typecast, as check is made already in LZMAPreEncode */\n\t\t}\n\t} while (sp->stream.avail_in > 0);\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              275,
              0
            ],
            [
              308,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZMAEncode",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLZMAPostEncode(TIFF* tif)\n{\n\tstatic const char module[] = \"LZMAPostEncode\";\n\tLZMAState *sp = EncoderState(tif);\n\tlzma_ret ret;\n\n\tsp->stream.avail_in = 0;\n\tdo {\n\t\tret = lzma_code(&sp->stream, LZMA_FINISH);\n\t\tswitch (ret) {\n\t\tcase LZMA_STREAM_END:\n\t\tcase LZMA_OK:\n\t\t\tif ((tmsize_t)sp->stream.avail_out != tif->tif_rawdatasize) {\n\t\t\t\ttif->tif_rawcc =\n\t\t\t\t\ttif->tif_rawdatasize - sp->stream.avail_out;\n\t\t\t\tTIFFFlushData1(tif);\n\t\t\t\tsp->stream.next_out = tif->tif_rawdata;\n\t\t\t\tsp->stream.avail_out = (size_t)tif->tif_rawdatasize;  /* this is a safe typecast, as check is made already in ZIPPreEncode */\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Liblzma error: %s\",\n\t\t\t\t     LZMAStrerror(ret));\n\t\t\treturn 0;\n\t\t}\n\t} while (ret != LZMA_STREAM_END);\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              314,
              0
            ],
            [
              342,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZMAPostEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nLZMACleanup(TIFF* tif)\n{\n\tLZMAState* sp = LState(tif);\n\n\tassert(sp != 0);\n\n\t(void)TIFFPredictorCleanup(tif);\n\n\ttif->tif_tagmethods.vgetfield = sp->vgetparent;\n\ttif->tif_tagmethods.vsetfield = sp->vsetparent;\n\n\tif (sp->state) {\n\t\tlzma_end(&sp->stream);\n\t\tsp->state = 0;\n\t}\n\t_TIFFfree(sp);\n\ttif->tif_data = NULL;\n\n\t_TIFFSetDefaultCompressionState(tif);\n}",
          "fn_code_pos": [
            [
              344,
              0
            ],
            [
              364,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZMACleanup",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nLZMAVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tstatic const char module[] = \"LZMAVSetField\";\n\tLZMAState* sp = LState(tif);\n\n\tswitch (tag) {\n\tcase TIFFTAG_LZMAPRESET:\n\t\tsp->preset = (int) va_arg(ap, int);\n\t\tlzma_lzma_preset(&sp->opt_lzma, sp->preset);\n\t\tif (sp->state & LSTATE_INIT_ENCODE) {\n\t\t\tlzma_ret ret = lzma_stream_encoder(&sp->stream,\n\t\t\t\t\t\t\t   sp->filters,\n\t\t\t\t\t\t\t   sp->check);\n\t\t\tif (ret != LZMA_OK) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t     \"Liblzma error: %s\",\n\t\t\t\t\t     LZMAStrerror(ret));\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\tdefault:\n\t\treturn (*sp->vsetparent)(tif, tag, ap);\n\t}\n\t/*NOTREACHED*/\n}",
          "fn_code_pos": [
            [
              366,
              0
            ],
            [
              391,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZMAVSetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLZMAVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tLZMAState* sp = LState(tif);\n\n\tswitch (tag) {\n\tcase TIFFTAG_LZMAPRESET:\n\t\t*va_arg(ap, int*) = sp->preset;\n\t\tbreak;\n\tdefault:\n\t\treturn (*sp->vgetparent)(tif, tag, ap);\n\t}\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              393,
              0
            ],
            [
              406,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZMAVGetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFInitLZMA(TIFF* tif, int scheme)\n{\n\tstatic const char module[] = \"TIFFInitLZMA\";\n\tLZMAState* sp;\n\tlzma_stream tmp_stream = LZMA_STREAM_INIT;\n\n\tassert( scheme == COMPRESSION_LZMA );\n\n\t/*\n\t * Merge codec-specific tag information.\n\t */\n\tif (!_TIFFMergeFields(tif, lzmaFields, TIFFArrayCount(lzmaFields))) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"Merging LZMA2 codec-specific tags failed\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate state block so tag methods have storage to record values.\n\t */\n\ttif->tif_data = (uint8*) _TIFFmalloc(sizeof(LZMAState));\n\tif (tif->tif_data == NULL)\n\t\tgoto bad;\n\tsp = LState(tif);\n\tmemcpy(&sp->stream, &tmp_stream, sizeof(lzma_stream));\n\n\t/*\n\t * Override parent get/set field methods.\n\t */\n\tsp->vgetparent = tif->tif_tagmethods.vgetfield;\n\ttif->tif_tagmethods.vgetfield = LZMAVGetField;\t/* hook for codec tags */\n\tsp->vsetparent = tif->tif_tagmethods.vsetfield;\n\ttif->tif_tagmethods.vsetfield = LZMAVSetField;\t/* hook for codec tags */\n\n\t/* Default values for codec-specific fields */\n\tsp->preset = LZMA_PRESET_DEFAULT;\t\t/* default comp. level */\n\tsp->check = LZMA_CHECK_NONE;\n\tsp->state = 0;\n\n\t/* Data filters. So far we are using delta and LZMA2 filters only. */\n\tsp->opt_delta.type = LZMA_DELTA_TYPE_BYTE;\n\t/*\n\t * The sample size in bytes seems to be reasonable distance for delta\n\t * filter.\n\t */\n\tsp->opt_delta.dist = (tif->tif_dir.td_bitspersample % 8) ?\n\t\t1 : tif->tif_dir.td_bitspersample / 8;\n\tsp->filters[0].id = LZMA_FILTER_DELTA;\n\tsp->filters[0].options = &sp->opt_delta;\n\n\tlzma_lzma_preset(&sp->opt_lzma, sp->preset);\n\tsp->filters[1].id = LZMA_FILTER_LZMA2;\n\tsp->filters[1].options = &sp->opt_lzma;\n\n\tsp->filters[2].id = LZMA_VLI_UNKNOWN;\n\tsp->filters[2].options = NULL;\n\n\t/*\n\t * Install codec methods.\n\t */\n\ttif->tif_fixuptags = LZMAFixupTags;\n\ttif->tif_setupdecode = LZMASetupDecode;\n\ttif->tif_predecode = LZMAPreDecode;\n\ttif->tif_decoderow = LZMADecode;\n\ttif->tif_decodestrip = LZMADecode;\n\ttif->tif_decodetile = LZMADecode;\n\ttif->tif_setupencode = LZMASetupEncode;\n\ttif->tif_preencode = LZMAPreEncode;\n\ttif->tif_postencode = LZMAPostEncode;\n\ttif->tif_encoderow = LZMAEncode;\n\ttif->tif_encodestrip = LZMAEncode;\n\ttif->tif_encodetile = LZMAEncode;\n\ttif->tif_cleanup = LZMACleanup;\n\t/*\n\t * Setup predictor setup.\n\t */\n\t(void) TIFFPredictorInit(tif);\n\treturn 1;\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"No space for LZMA2 state block\");\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              413,
              0
            ],
            [
              496,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitLZMA",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "LZMAEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              63,
              11
            ],
            [
              63,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZMAEncode",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "LZMADecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)",
          "fn_dec_pos": [
            [
              64,
              11
            ],
            [
              64,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZMADecode",
            "parameters": {
              "tif": "TIFF",
              "op": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "LZMAStrerror(lzma_ret ret)",
          "fn_dec_pos": [
            [
              67,
              0
            ],
            [
              67,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZMAStrerror",
            "parameters": {
              "ret": "lzma_ret"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\tTIFFPredictorState predict;\n        lzma_stream\tstream;\n\tlzma_filter\tfilters[LZMA_FILTERS_MAX + 1];\n\tlzma_options_delta opt_delta;\t\t/* delta filter options */\n\tlzma_options_lzma opt_lzma;\t\t/* LZMA2 filter options */\n\tint             preset;\t\t\t/* compression level */\n\tlzma_check\tcheck;\t\t\t/* type of the integrity check */\n\tint             state;\t\t\t/* state flags */\n#define LSTATE_INIT_DECODE 0x01\n#define LSTATE_INIT_ENCODE 0x02\n\n\tTIFFVGetMethod  vgetparent;            /* super-class method */\n\tTIFFVSetMethod  vsetparent;            /* super-class method */\n} LZMAState;",
          {
            "predict": "TIFFPredictorState",
            "stream": "lzma_stream",
            "filters[LZMA_FILTERS_MAX + 1]": "lzma_filter",
            "opt_delta": "lzma_options_delta",
            "opt_lzma": "lzma_options_lzma",
            "preset": "int",
            "check": "lzma_check",
            "state": "int",
            "vgetparent": "TIFFVGetMethod",
            "vsetparent": "TIFFVSetMethod"
          },
          "LZMAState",
          [
            43,
            0
          ],
          [
            57,
            12
          ]
        ],
        [
          "typedef struct {\n\tTIFFPredictorState predict;\n        lzma_stream\tstream;\n\tlzma_filter\tfilters[LZMA_FILTERS_MAX + 1];\n\tlzma_options_delta opt_delta;\t\t/* delta filter options */\n\tlzma_options_lzma opt_lzma;\t\t/* LZMA2 filter options */\n\tint             preset;\t\t\t/* compression level */\n\tlzma_check\tcheck;\t\t\t/* type of the integrity check */\n\tint             state;\t\t\t/* state flags */\n#define LSTATE_INIT_DECODE 0x01\n#define LSTATE_INIT_ENCODE 0x02\n\n\tTIFFVGetMethod  vgetparent;            /* super-class method */\n\tTIFFVSetMethod  vsetparent;            /* super-class method */\n} LZMAState;",
          {
            "predict": "TIFFPredictorState",
            "stream": "lzma_stream",
            "filters[LZMA_FILTERS_MAX + 1]": "lzma_filter",
            "opt_delta": "lzma_options_delta",
            "opt_lzma": "lzma_options_lzma",
            "preset": "int",
            "check": "lzma_check",
            "state": "int",
            "vgetparent": "TIFFVGetMethod",
            "vsetparent": "TIFFVSetMethod"
          },
          "LZMAState",
          [
            43,
            0
          ],
          [
            57,
            12
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include \"tif_predict.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"lzma.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_version.c": {
      "fn_def_list": [
        {
          "fn_code": "const char*\nTIFFGetVersion(void)\n{\n\treturn (TIFFVersion);\n}",
          "fn_code_pos": [
            [
              27,
              0
            ],
            [
              31,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetVersion",
            "parameters": {},
            "return_type": "char"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFGetVersion(void)",
          "fn_dec_pos": [
            [
              28,
              0
            ],
            [
              28,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetVersion",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_fax3sm.c": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiff.h\"\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ],
        [
          "#include \"tif_fax3.h\"\n",
          [
            3,
            0
          ],
          [
            4,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_ojpeg.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nTIFFInitOJPEG(TIFF* tif, int scheme)\n{\n\tstatic const char module[]=\"TIFFInitOJPEG\";\n\tOJPEGState* sp;\n\n\tassert(scheme==COMPRESSION_OJPEG);\n\n        /*\n\t * Merge codec-specific tag information.\n\t */\n\tif (!_TIFFMergeFields(tif, ojpegFields, TIFFArrayCount(ojpegFields))) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Merging Old JPEG codec-specific tags failed\");\n\t\treturn 0;\n\t}\n\n\t/* state block */\n\tsp=_TIFFmalloc(sizeof(OJPEGState));\n\tif (sp==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"No space for OJPEG state block\");\n\t\treturn(0);\n\t}\n\t_TIFFmemset(sp,0,sizeof(OJPEGState));\n\tsp->tif=tif;\n\tsp->jpeg_proc=1;\n\tsp->subsampling_hor=2;\n\tsp->subsampling_ver=2;\n\tTIFFSetField(tif,TIFFTAG_YCBCRSUBSAMPLING,2,2);\n\t/* tif codec methods */\n\ttif->tif_fixuptags=OJPEGFixupTags;  \n\ttif->tif_setupdecode=OJPEGSetupDecode;\n\ttif->tif_predecode=OJPEGPreDecode;\n\ttif->tif_postdecode=OJPEGPostDecode;  \n\ttif->tif_decoderow=OJPEGDecode;  \n\ttif->tif_decodestrip=OJPEGDecode;  \n\ttif->tif_decodetile=OJPEGDecode;  \n\ttif->tif_setupencode=OJPEGSetupEncode;\n\ttif->tif_preencode=OJPEGPreEncode;\n\ttif->tif_postencode=OJPEGPostEncode;\n\ttif->tif_encoderow=OJPEGEncode;  \n\ttif->tif_encodestrip=OJPEGEncode;  \n\ttif->tif_encodetile=OJPEGEncode;  \n\ttif->tif_cleanup=OJPEGCleanup;\n\ttif->tif_data=(uint8*)sp;\n\t/* tif tag methods */\n\tsp->vgetparent=tif->tif_tagmethods.vgetfield;\n\ttif->tif_tagmethods.vgetfield=OJPEGVGetField;\n\tsp->vsetparent=tif->tif_tagmethods.vsetfield;\n\ttif->tif_tagmethods.vsetfield=OJPEGVSetField;\n\tsp->printdir=tif->tif_tagmethods.printdir;\n\ttif->tif_tagmethods.printdir=OJPEGPrintDir;\n\t/* Some OJPEG files don't have strip or tile offsets or bytecounts tags.\n\t   Some others do, but have totally meaningless or corrupt values\n\t   in these tags. In these cases, the JpegInterchangeFormat stream is\n\t   reliable. In any case, this decoder reads the compressed data itself,\n\t   from the most reliable locations, and we need to notify encapsulating\n\t   LibTiff not to read raw strips or tiles for us. */\n\ttif->tif_flags|=TIFF_NOREADRAW;\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              416,
              0
            ],
            [
              477,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitOJPEG",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tswitch(tag)\n\t{\n\t\tcase TIFFTAG_JPEGIFOFFSET:\n\t\t\t*va_arg(ap,uint64*)=(uint64)sp->jpeg_interchange_format;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGIFBYTECOUNT:\n\t\t\t*va_arg(ap,uint64*)=(uint64)sp->jpeg_interchange_format_length;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\tif (sp->subsamplingcorrect_done==0)\n\t\t\t\tOJPEGSubsamplingCorrect(tif);\n\t\t\t*va_arg(ap,uint16*)=(uint16)sp->subsampling_hor;\n\t\t\t*va_arg(ap,uint16*)=(uint16)sp->subsampling_ver;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGQTABLES:\n\t\t\t*va_arg(ap,uint32*)=(uint32)sp->qtable_offset_count;\n\t\t\t*va_arg(ap,void**)=(void*)sp->qtable_offset; \n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGDCTABLES:\n\t\t\t*va_arg(ap,uint32*)=(uint32)sp->dctable_offset_count;\n\t\t\t*va_arg(ap,void**)=(void*)sp->dctable_offset;  \n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGACTABLES:\n\t\t\t*va_arg(ap,uint32*)=(uint32)sp->actable_offset_count;\n\t\t\t*va_arg(ap,void**)=(void*)sp->actable_offset;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGPROC:\n\t\t\t*va_arg(ap,uint16*)=(uint16)sp->jpeg_proc;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGRESTARTINTERVAL:\n\t\t\t*va_arg(ap,uint16*)=sp->restart_interval;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (*sp->vgetparent)(tif,tag,ap);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              479,
              0
            ],
            [
              519,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGVGetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tstatic const char module[]=\"OJPEGVSetField\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint32 ma;\n\tuint64* mb;\n\tuint32 n;\n\tconst TIFFField* fip;\n\n\tswitch(tag)\n\t{\n\t\tcase TIFFTAG_JPEGIFOFFSET:\n\t\t\tsp->jpeg_interchange_format=(uint64)va_arg(ap,uint64);\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGIFBYTECOUNT:\n\t\t\tsp->jpeg_interchange_format_length=(uint64)va_arg(ap,uint64);\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\tsp->subsampling_tag=1;\n\t\t\tsp->subsampling_hor=(uint8)va_arg(ap,uint16_vap);\n\t\t\tsp->subsampling_ver=(uint8)va_arg(ap,uint16_vap);\n\t\t\ttif->tif_dir.td_ycbcrsubsampling[0]=sp->subsampling_hor;\n\t\t\ttif->tif_dir.td_ycbcrsubsampling[1]=sp->subsampling_ver;\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGQTABLES:\n\t\t\tma=(uint32)va_arg(ap,uint32);\n\t\t\tif (ma!=0)\n\t\t\t{\n\t\t\t\tif (ma>3)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JpegQTables tag has incorrect count\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsp->qtable_offset_count=(uint8)ma;\n\t\t\t\tmb=(uint64*)va_arg(ap,uint64*);\n\t\t\t\tfor (n=0; n<ma; n++)\n\t\t\t\t\tsp->qtable_offset[n]=mb[n];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGDCTABLES:\n\t\t\tma=(uint32)va_arg(ap,uint32);\n\t\t\tif (ma!=0)\n\t\t\t{\n\t\t\t\tif (ma>3)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JpegDcTables tag has incorrect count\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsp->dctable_offset_count=(uint8)ma;\n\t\t\t\tmb=(uint64*)va_arg(ap,uint64*);\n\t\t\t\tfor (n=0; n<ma; n++)\n\t\t\t\t\tsp->dctable_offset[n]=mb[n];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGACTABLES:\n\t\t\tma=(uint32)va_arg(ap,uint32);\n\t\t\tif (ma!=0)\n\t\t\t{\n\t\t\t\tif (ma>3)\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JpegAcTables tag has incorrect count\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsp->actable_offset_count=(uint8)ma;\n\t\t\t\tmb=(uint64*)va_arg(ap,uint64*);\n\t\t\t\tfor (n=0; n<ma; n++)\n\t\t\t\t\tsp->actable_offset[n]=mb[n];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGPROC:\n\t\t\tsp->jpeg_proc=(uint8)va_arg(ap,uint16_vap);\n\t\t\tbreak;\n\t\tcase TIFFTAG_JPEGRESTARTINTERVAL:\n\t\t\tsp->restart_interval=(uint16)va_arg(ap,uint16_vap);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn (*sp->vsetparent)(tif,tag,ap);\n\t}\n\tfip = TIFFFieldWithTag(tif,tag);\n\tif( fip == NULL ) /* shouldn't happen */\n\t    return(0);\n\tTIFFSetFieldBit(tif,fip->field_bit);\n\ttif->tif_flags|=TIFF_DIRTYDIRECT;\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              521,
              0
            ],
            [
              606,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGVSetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nOJPEGPrintDir(TIFF* tif, FILE* fd, long flags)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\t(void)flags;\n\tassert(sp!=NULL);\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGINTERCHANGEFORMAT))\n\t\tfprintf(fd,\"  JpegInterchangeFormat: \" TIFF_UINT64_FORMAT \"\\n\",(TIFF_UINT64_T)sp->jpeg_interchange_format);  \n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGINTERCHANGEFORMATLENGTH))\n\t\tfprintf(fd,\"  JpegInterchangeFormatLength: \" TIFF_UINT64_FORMAT \"\\n\",(TIFF_UINT64_T)sp->jpeg_interchange_format_length);  \n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGQTABLES))\n\t{\n\t\tfprintf(fd,\"  JpegQTables:\");\n\t\tfor (m=0; m<sp->qtable_offset_count; m++)\n\t\t\tfprintf(fd,\" \" TIFF_UINT64_FORMAT,(TIFF_UINT64_T)sp->qtable_offset[m]);\n\t\tfprintf(fd,\"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGDCTABLES))\n\t{\n\t\tfprintf(fd,\"  JpegDcTables:\");\n\t\tfor (m=0; m<sp->dctable_offset_count; m++)\n\t\t\tfprintf(fd,\" \" TIFF_UINT64_FORMAT,(TIFF_UINT64_T)sp->dctable_offset[m]);\n\t\tfprintf(fd,\"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGACTABLES))\n\t{\n\t\tfprintf(fd,\"  JpegAcTables:\");\n\t\tfor (m=0; m<sp->actable_offset_count; m++)\n\t\t\tfprintf(fd,\" \" TIFF_UINT64_FORMAT,(TIFF_UINT64_T)sp->actable_offset[m]);\n\t\tfprintf(fd,\"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGPROC))\n\t\tfprintf(fd,\"  JpegProc: %u\\n\",(unsigned int)sp->jpeg_proc);\n\tif (TIFFFieldSet(tif,FIELD_OJPEG_JPEGRESTARTINTERVAL))\n\t\tfprintf(fd,\"  JpegRestartInterval: %u\\n\",(unsigned int)sp->restart_interval);\n\tif (sp->printdir)\n\t\t(*sp->printdir)(tif, fd, flags);\n}",
          "fn_code_pos": [
            [
              608,
              0
            ],
            [
              646,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGPrintDir",
            "parameters": {
              "tif": "TIFF",
              "fd": "FILE",
              "flags": "long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nOJPEGFixupTags(TIFF* tif)\n{\n\t(void) tif;\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              648,
              0
            ],
            [
              653,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGFixupTags",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGSetupDecode(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGSetupDecode\";\n\tTIFFWarningExt(tif->tif_clientdata,module,\"Depreciated and troublesome old-style JPEG compression mode, please convert to new-style JPEG compression and notify vendor of writing software\");\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              655,
              0
            ],
            [
              661,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGSetupDecode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGPreDecode(TIFF* tif, uint16 s)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint32 m;\n\tif (sp->subsamplingcorrect_done==0)\n\t\tOJPEGSubsamplingCorrect(tif);\n\tif (sp->readheader_done==0)\n\t{\n\t\tif (OJPEGReadHeaderInfo(tif)==0)\n\t\t\treturn(0);\n\t}\n\tif (sp->sos_end[s].log==0)\n\t{\n\t\tif (OJPEGReadSecondarySos(tif,s)==0)\n\t\t\treturn(0);\n\t}\n\tif isTiled(tif)\n\t\tm=tif->tif_curtile;\n\telse\n\t\tm=tif->tif_curstrip;\n\tif ((sp->writeheader_done!=0) && ((sp->write_cursample!=s) || (sp->write_curstrile>m)))\n\t{\n\t\tif (sp->libjpeg_session_active!=0)\n\t\t\tOJPEGLibjpegSessionAbort(tif);\n\t\tsp->writeheader_done=0;\n\t}\n\tif (sp->writeheader_done==0)\n\t{\n\t\tsp->plane_sample_offset=(uint8)s;\n\t\tsp->write_cursample=s;\n\t\tsp->write_curstrile=s*tif->tif_dir.td_stripsperimage;\n\t\tif ((sp->in_buffer_file_pos_log==0) ||\n\t\t    (sp->in_buffer_file_pos-sp->in_buffer_togo!=sp->sos_end[s].in_buffer_file_pos))\n\t\t{\n\t\t\tsp->in_buffer_source=sp->sos_end[s].in_buffer_source;\n\t\t\tsp->in_buffer_next_strile=sp->sos_end[s].in_buffer_next_strile;\n\t\t\tsp->in_buffer_file_pos=sp->sos_end[s].in_buffer_file_pos;\n\t\t\tsp->in_buffer_file_pos_log=0;\n\t\t\tsp->in_buffer_file_togo=sp->sos_end[s].in_buffer_file_togo;\n\t\t\tsp->in_buffer_togo=0;\n\t\t\tsp->in_buffer_cur=0;\n\t\t}\n\t\tif (OJPEGWriteHeaderInfo(tif)==0)\n\t\t\treturn(0);\n\t}\n\twhile (sp->write_curstrile<m)          \n\t{\n\t\tif (sp->libjpeg_jpeg_query_style==0)\n\t\t{\n\t\t\tif (OJPEGPreDecodeSkipRaw(tif)==0)\n\t\t\t\treturn(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (OJPEGPreDecodeSkipScanlines(tif)==0)\n\t\t\t\treturn(0);\n\t\t}\n\t\tsp->write_curstrile++;\n\t}\n\tsp->decoder_ok = 1;\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              663,
              0
            ],
            [
              725,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGPreDecode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGPreDecodeSkipRaw(TIFF* tif)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint32 m;\n\tm=sp->lines_per_strile;\n\tif (sp->subsampling_convert_state!=0)\n\t{\n\t\tif (sp->subsampling_convert_clines-sp->subsampling_convert_state>=m)\n\t\t{\n\t\t\tsp->subsampling_convert_state+=m;\n\t\t\tif (sp->subsampling_convert_state==sp->subsampling_convert_clines)\n\t\t\t\tsp->subsampling_convert_state=0;\n\t\t\treturn(1);\n\t\t}\n\t\tm-=sp->subsampling_convert_clines-sp->subsampling_convert_state;\n\t\tsp->subsampling_convert_state=0;\n\t}\n\twhile (m>=sp->subsampling_convert_clines)\n\t{\n\t\tif (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)\n\t\t\treturn(0);\n\t\tm-=sp->subsampling_convert_clines;\n\t}\n\tif (m>0)\n\t{\n\t\tif (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)\n\t\t\treturn(0);\n\t\tsp->subsampling_convert_state=m;\n\t}\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              727,
              0
            ],
            [
              758,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGPreDecodeSkipRaw",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGPreDecodeSkipScanlines(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGPreDecodeSkipScanlines\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint32 m;\n\tif (sp->skip_buffer==NULL)\n\t{\n\t\tsp->skip_buffer=_TIFFmalloc(sp->bytes_per_line);\n\t\tif (sp->skip_buffer==NULL)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\treturn(0);\n\t\t}\n\t}\n\tfor (m=0; m<sp->lines_per_strile; m++)\n\t{\n\t\tif (jpeg_read_scanlines_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),&sp->skip_buffer,1)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              760,
              0
            ],
            [
              781,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGPreDecodeSkipScanlines",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n{\n        static const char module[]=\"OJPEGDecode\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\t(void)s;\n        if( !sp->decoder_ok )\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\"Cannot decode: decoder not correctly initialized\");\n            return 0;\n        }\n\tif (sp->libjpeg_jpeg_query_style==0)\n\t{\n\t\tif (OJPEGDecodeRaw(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\telse\n\t{\n\t\tif (OJPEGDecodeScanlines(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              783,
              0
            ],
            [
              805,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGDecode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc)\n{\n\tstatic const char module[]=\"OJPEGDecodeRaw\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8* m;\n\ttmsize_t n;\n\tuint8* oy;\n\tuint8* ocb;\n\tuint8* ocr;\n\tuint8* p;\n\tuint32 q;\n\tuint8* r;\n\tuint8 sx,sy;\n\tif (cc%sp->bytes_per_line!=0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Fractional scanline not read\");\n\t\treturn(0);\n\t}\n\tassert(cc>0);\n\tm=buf;\n\tn=cc;\n\tdo\n\t{\n\t\tif (sp->subsampling_convert_state==0)\n\t\t{\n\t\t\tif (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0)\n\t\t\t\treturn(0);\n\t\t}\n\t\toy=sp->subsampling_convert_ybuf+sp->subsampling_convert_state*sp->subsampling_ver*sp->subsampling_convert_ylinelen;\n\t\tocb=sp->subsampling_convert_cbbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen;\n\t\tocr=sp->subsampling_convert_crbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen;\n\t\tp=m;\n\t\tfor (q=0; q<sp->subsampling_convert_clinelenout; q++)\n\t\t{\n\t\t\tr=oy;\n\t\t\tfor (sy=0; sy<sp->subsampling_ver; sy++)\n\t\t\t{\n\t\t\t\tfor (sx=0; sx<sp->subsampling_hor; sx++)\n\t\t\t\t\t*p++=*r++;\n\t\t\t\tr+=sp->subsampling_convert_ylinelen-sp->subsampling_hor;\n\t\t\t}\n\t\t\toy+=sp->subsampling_hor;\n\t\t\t*p++=*ocb++;\n\t\t\t*p++=*ocr++;\n\t\t}\n\t\tsp->subsampling_convert_state++;\n\t\tif (sp->subsampling_convert_state==sp->subsampling_convert_clines)\n\t\t\tsp->subsampling_convert_state=0;\n\t\tm+=sp->bytes_per_line;\n\t\tn-=sp->bytes_per_line;\n\t} while(n>0);\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              807,
              0
            ],
            [
              860,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGDecodeRaw",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGDecodeScanlines(TIFF* tif, uint8* buf, tmsize_t cc)\n{\n\tstatic const char module[]=\"OJPEGDecodeScanlines\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8* m;\n\ttmsize_t n;\n\tif (cc%sp->bytes_per_line!=0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Fractional scanline not read\");\n\t\treturn(0);\n\t}\n\tassert(cc>0);\n\tm=buf;\n\tn=cc;\n\tdo\n\t{\n\t\tif (jpeg_read_scanlines_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),&m,1)==0)\n\t\t\treturn(0);\n\t\tm+=sp->bytes_per_line;\n\t\tn-=sp->bytes_per_line;\n\t} while(n>0);\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              862,
              0
            ],
            [
              885,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGDecodeScanlines",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nOJPEGPostDecode(TIFF* tif, uint8* buf, tmsize_t cc)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\t(void)buf;\n\t(void)cc;\n\tsp->write_curstrile++;\n\tif (sp->write_curstrile%tif->tif_dir.td_stripsperimage==0)  \n\t{\n\t\tassert(sp->libjpeg_session_active!=0);\n\t\tOJPEGLibjpegSessionAbort(tif);\n\t\tsp->writeheader_done=0;\n\t}\n}",
          "fn_code_pos": [
            [
              887,
              0
            ],
            [
              900,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGPostDecode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nOJPEGSetupEncode(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGSetupEncode\";\n\tTIFFErrorExt(tif->tif_clientdata,module,\"OJPEG encoding not supported; use new-style JPEG compression instead\");\n\treturn(0);\n}",
          "fn_code_pos": [
            [
              902,
              0
            ],
            [
              908,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGSetupEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGPreEncode(TIFF* tif, uint16 s)\n{\n\tstatic const char module[]=\"OJPEGPreEncode\";\n\t(void)s;\n\tTIFFErrorExt(tif->tif_clientdata,module,\"OJPEG encoding not supported; use new-style JPEG compression instead\");\n\treturn(0);\n}",
          "fn_code_pos": [
            [
              910,
              0
            ],
            [
              917,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGPreEncode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n{\n\tstatic const char module[]=\"OJPEGEncode\";\n\t(void)buf;\n\t(void)cc;\n\t(void)s;\n\tTIFFErrorExt(tif->tif_clientdata,module,\"OJPEG encoding not supported; use new-style JPEG compression instead\");\n\treturn(0);\n}",
          "fn_code_pos": [
            [
              919,
              0
            ],
            [
              928,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGEncode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGPostEncode(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGPostEncode\";\n\tTIFFErrorExt(tif->tif_clientdata,module,\"OJPEG encoding not supported; use new-style JPEG compression instead\");\n\treturn(0);\n}",
          "fn_code_pos": [
            [
              930,
              0
            ],
            [
              936,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGPostEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nOJPEGCleanup(TIFF* tif)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tif (sp!=0)\n\t{\n\t\ttif->tif_tagmethods.vgetfield=sp->vgetparent;\n\t\ttif->tif_tagmethods.vsetfield=sp->vsetparent;\n\t\ttif->tif_tagmethods.printdir=sp->printdir;\n\t\tif (sp->qtable[0]!=0)\n\t\t\t_TIFFfree(sp->qtable[0]);\n\t\tif (sp->qtable[1]!=0)\n\t\t\t_TIFFfree(sp->qtable[1]);\n\t\tif (sp->qtable[2]!=0)\n\t\t\t_TIFFfree(sp->qtable[2]);\n\t\tif (sp->qtable[3]!=0)\n\t\t\t_TIFFfree(sp->qtable[3]);\n\t\tif (sp->dctable[0]!=0)\n\t\t\t_TIFFfree(sp->dctable[0]);\n\t\tif (sp->dctable[1]!=0)\n\t\t\t_TIFFfree(sp->dctable[1]);\n\t\tif (sp->dctable[2]!=0)\n\t\t\t_TIFFfree(sp->dctable[2]);\n\t\tif (sp->dctable[3]!=0)\n\t\t\t_TIFFfree(sp->dctable[3]);\n\t\tif (sp->actable[0]!=0)\n\t\t\t_TIFFfree(sp->actable[0]);\n\t\tif (sp->actable[1]!=0)\n\t\t\t_TIFFfree(sp->actable[1]);\n\t\tif (sp->actable[2]!=0)\n\t\t\t_TIFFfree(sp->actable[2]);\n\t\tif (sp->actable[3]!=0)\n\t\t\t_TIFFfree(sp->actable[3]);\n\t\tif (sp->libjpeg_session_active!=0)\n\t\t\tOJPEGLibjpegSessionAbort(tif);\n\t\tif (sp->subsampling_convert_ycbcrbuf!=0)\n\t\t\t_TIFFfree(sp->subsampling_convert_ycbcrbuf);\n\t\tif (sp->subsampling_convert_ycbcrimage!=0)\n\t\t\t_TIFFfree(sp->subsampling_convert_ycbcrimage);\n\t\tif (sp->skip_buffer!=0)\n\t\t\t_TIFFfree(sp->skip_buffer);\n\t\t_TIFFfree(sp);\n\t\ttif->tif_data=NULL;\n\t\t_TIFFSetDefaultCompressionState(tif);\n\t}\n}",
          "fn_code_pos": [
            [
              938,
              0
            ],
            [
              983,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGCleanup",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nOJPEGSubsamplingCorrect(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGSubsamplingCorrect\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 mh;\n\tuint8 mv;\n        _TIFFFillStriles( tif );\n        \n\tassert(sp->subsamplingcorrect_done==0);\n\tif ((tif->tif_dir.td_samplesperpixel!=3) || ((tif->tif_dir.td_photometric!=PHOTOMETRIC_YCBCR) &&\n\t    (tif->tif_dir.td_photometric!=PHOTOMETRIC_ITULAB)))\n\t{\n\t\tif (sp->subsampling_tag!=0)\n\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling tag not appropriate for this Photometric and/or SamplesPerPixel\");\n\t\tsp->subsampling_hor=1;\n\t\tsp->subsampling_ver=1;\n\t\tsp->subsampling_force_desubsampling_inside_decompression=0;\n\t}\n\telse\n\t{\n\t\tsp->subsamplingcorrect_done=1;\n\t\tmh=sp->subsampling_hor;\n\t\tmv=sp->subsampling_ver;\n\t\tsp->subsamplingcorrect=1;\n\t\tOJPEGReadHeaderInfoSec(tif);\n\t\tif (sp->subsampling_force_desubsampling_inside_decompression!=0)\n\t\t{\n\t\t\tsp->subsampling_hor=1;\n\t\t\tsp->subsampling_ver=1;\n\t\t}\n\t\tsp->subsamplingcorrect=0;\n\t\tif (((sp->subsampling_hor!=mh) || (sp->subsampling_ver!=mv)) && (sp->subsampling_force_desubsampling_inside_decompression==0))\n\t\t{\n\t\t\tif (sp->subsampling_tag==0)\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling tag is not set, yet subsampling inside JPEG data [%d,%d] does not match default values [2,2]; assuming subsampling inside JPEG data is correct\",sp->subsampling_hor,sp->subsampling_ver);\n\t\t\telse\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling inside JPEG data [%d,%d] does not match subsampling tag values [%d,%d]; assuming subsampling inside JPEG data is correct\",sp->subsampling_hor,sp->subsampling_ver,mh,mv);\n\t\t}\n\t\tif (sp->subsampling_force_desubsampling_inside_decompression!=0)\n\t\t{\n\t\t\tif (sp->subsampling_tag==0)\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling tag is not set, yet subsampling inside JPEG data does not match default values [2,2] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampling inside JPEG decompression\");\n\t\t\telse\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling inside JPEG data does not match subsampling tag values [%d,%d] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampling inside JPEG decompression\",mh,mv);\n\t\t}\n\t\tif (sp->subsampling_force_desubsampling_inside_decompression==0)\n\t\t{\n\t\t\tif (sp->subsampling_hor<sp->subsampling_ver)\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,module,\"Subsampling values [%d,%d] are not allowed in TIFF\",sp->subsampling_hor,sp->subsampling_ver);\n\t\t}\n\t}\n\tsp->subsamplingcorrect_done=1;\n}",
          "fn_code_pos": [
            [
              985,
              0
            ],
            [
              1038,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGSubsamplingCorrect",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nOJPEGReadHeaderInfo(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfo\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(sp->readheader_done==0);\n\tsp->image_width=tif->tif_dir.td_imagewidth;\n\tsp->image_length=tif->tif_dir.td_imagelength;\n\tif isTiled(tif)\n\t{\n\t\tsp->strile_width=tif->tif_dir.td_tilewidth;\n\t\tsp->strile_length=tif->tif_dir.td_tilelength;\n\t\tsp->strile_length_total=((sp->image_length+sp->strile_length-1)/sp->strile_length)*sp->strile_length;\n\t}\n\telse\n\t{\n\t\tsp->strile_width=sp->image_width;\n\t\tsp->strile_length=tif->tif_dir.td_rowsperstrip;\n\t\tsp->strile_length_total=sp->image_length;\n\t}",
          "fn_code_pos": [
            [
              1040,
              0
            ],
            [
              1059,
              2
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfo",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "isTiled(tif)\n\t{\n\t\tsp->strile_width=tif->tif_dir.td_tilewidth;\n\t\tsp->strile_length=tif->tif_dir.td_tilelength;\n\t\tsp->strile_length_total=((sp->image_length+sp->strile_length-1)/sp->strile_length)*sp->strile_length;\n\t}",
          "fn_code_pos": [
            [
              1048,
              4
            ],
            [
              1053,
              2
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "isTiled",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static int\nOJPEGReadSecondarySos(TIFF* tif, uint16 s)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tassert(s>0);\n\tassert(s<3);\n\tassert(sp->sos_end[0].log!=0);\n\tassert(sp->sos_end[s].log==0);\n\tsp->plane_sample_offset=(uint8)(s-1);\n\twhile(sp->sos_end[sp->plane_sample_offset].log==0)\n\t\tsp->plane_sample_offset--;\n\tsp->in_buffer_source=sp->sos_end[sp->plane_sample_offset].in_buffer_source;\n\tsp->in_buffer_next_strile=sp->sos_end[sp->plane_sample_offset].in_buffer_next_strile;\n\tsp->in_buffer_file_pos=sp->sos_end[sp->plane_sample_offset].in_buffer_file_pos;\n\tsp->in_buffer_file_pos_log=0;\n\tsp->in_buffer_file_togo=sp->sos_end[sp->plane_sample_offset].in_buffer_file_togo;\n\tsp->in_buffer_togo=0;\n\tsp->in_buffer_cur=0;\n\twhile(sp->plane_sample_offset<s)\n\t{\n\t\tdo\n\t\t{\n\t\t\tif (OJPEGReadByte(sp,&m)==0)\n\t\t\t\treturn(0);\n\t\t\tif (m==255)\n\t\t\t{\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tif (OJPEGReadByte(sp,&m)==0)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\tif (m!=255)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} while(1);\n\t\t\t\tif (m==JPEG_MARKER_SOS)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while(1);\n\t\tsp->plane_sample_offset++;\n\t\tif (OJPEGReadHeaderInfoSecStreamSos(tif)==0)\n\t\t\treturn(0);\n\t\tsp->sos_end[sp->plane_sample_offset].log=1;\n\t\tsp->sos_end[sp->plane_sample_offset].in_buffer_source=sp->in_buffer_source;\n\t\tsp->sos_end[sp->plane_sample_offset].in_buffer_next_strile=sp->in_buffer_next_strile;\n\t\tsp->sos_end[sp->plane_sample_offset].in_buffer_file_pos=sp->in_buffer_file_pos-sp->in_buffer_togo;\n\t\tsp->sos_end[sp->plane_sample_offset].in_buffer_file_togo=sp->in_buffer_file_togo+sp->in_buffer_togo;\n\t}\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              1102,
              0
            ],
            [
              1150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadSecondarySos",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGWriteHeaderInfo(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGWriteHeaderInfo\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8** m;\n\tuint32 n;\n\t/* if a previous attempt failed, don't try again */\n\tif (sp->libjpeg_session_active != 0) \n\t\treturn 0;\n\tsp->out_state=ososSoi;\n\tsp->restart_index=0;\n\tjpeg_std_error(&(sp->libjpeg_jpeg_error_mgr));\n\tsp->libjpeg_jpeg_error_mgr.output_message=OJPEGLibjpegJpegErrorMgrOutputMessage;\n\tsp->libjpeg_jpeg_error_mgr.error_exit=OJPEGLibjpegJpegErrorMgrErrorExit;\n\tsp->libjpeg_jpeg_decompress_struct.err=&(sp->libjpeg_jpeg_error_mgr);\n\tsp->libjpeg_jpeg_decompress_struct.client_data=(void*)tif;\n\tif (jpeg_create_decompress_encap(sp,&(sp->libjpeg_jpeg_decompress_struct))==0)\n\t\treturn(0);\n\tsp->libjpeg_session_active=1;\n\tsp->libjpeg_jpeg_source_mgr.bytes_in_buffer=0;\n\tsp->libjpeg_jpeg_source_mgr.init_source=OJPEGLibjpegJpegSourceMgrInitSource;\n\tsp->libjpeg_jpeg_source_mgr.fill_input_buffer=OJPEGLibjpegJpegSourceMgrFillInputBuffer;\n\tsp->libjpeg_jpeg_source_mgr.skip_input_data=OJPEGLibjpegJpegSourceMgrSkipInputData;\n\tsp->libjpeg_jpeg_source_mgr.resync_to_restart=OJPEGLibjpegJpegSourceMgrResyncToRestart;\n\tsp->libjpeg_jpeg_source_mgr.term_source=OJPEGLibjpegJpegSourceMgrTermSource;\n\tsp->libjpeg_jpeg_decompress_struct.src=&(sp->libjpeg_jpeg_source_mgr);\n\tif (jpeg_read_header_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),1)==0)\n\t\treturn(0);\n\tif ((sp->subsampling_force_desubsampling_inside_decompression==0) && (sp->samples_per_pixel_per_plane>1))\n\t{\n\t\tsp->libjpeg_jpeg_decompress_struct.raw_data_out=1;\n#if JPEG_LIB_VERSION >= 70\n\t\tsp->libjpeg_jpeg_decompress_struct.do_fancy_upsampling=FALSE;\n#endif\n\t\tsp->libjpeg_jpeg_query_style=0;\n\t\tif (sp->subsampling_convert_log==0)\n\t\t{\n\t\t\tassert(sp->subsampling_convert_ycbcrbuf==0);\n\t\t\tassert(sp->subsampling_convert_ycbcrimage==0);\n\t\t\tsp->subsampling_convert_ylinelen=((sp->strile_width+sp->subsampling_hor*8-1)/(sp->subsampling_hor*8)*sp->subsampling_hor*8);\n\t\t\tsp->subsampling_convert_ylines=sp->subsampling_ver*8;\n\t\t\tsp->subsampling_convert_clinelen=sp->subsampling_convert_ylinelen/sp->subsampling_hor;\n\t\t\tsp->subsampling_convert_clines=8;\n\t\t\tsp->subsampling_convert_ybuflen=sp->subsampling_convert_ylinelen*sp->subsampling_convert_ylines;\n\t\t\tsp->subsampling_convert_cbuflen=sp->subsampling_convert_clinelen*sp->subsampling_convert_clines;\n\t\t\tsp->subsampling_convert_ycbcrbuflen=sp->subsampling_convert_ybuflen+2*sp->subsampling_convert_cbuflen;\n\t\t\tsp->subsampling_convert_ycbcrbuf=_TIFFmalloc(sp->subsampling_convert_ycbcrbuflen);\n\t\t\tif (sp->subsampling_convert_ycbcrbuf==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsp->subsampling_convert_ybuf=sp->subsampling_convert_ycbcrbuf;\n\t\t\tsp->subsampling_convert_cbbuf=sp->subsampling_convert_ybuf+sp->subsampling_convert_ybuflen;\n\t\t\tsp->subsampling_convert_crbuf=sp->subsampling_convert_cbbuf+sp->subsampling_convert_cbuflen;\n\t\t\tsp->subsampling_convert_ycbcrimagelen=3+sp->subsampling_convert_ylines+2*sp->subsampling_convert_clines;\n\t\t\tsp->subsampling_convert_ycbcrimage=_TIFFmalloc(sp->subsampling_convert_ycbcrimagelen*sizeof(uint8*));\n\t\t\tif (sp->subsampling_convert_ycbcrimage==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tm=sp->subsampling_convert_ycbcrimage;\n\t\t\t*m++=(uint8*)(sp->subsampling_convert_ycbcrimage+3);\n\t\t\t*m++=(uint8*)(sp->subsampling_convert_ycbcrimage+3+sp->subsampling_convert_ylines);\n\t\t\t*m++=(uint8*)(sp->subsampling_convert_ycbcrimage+3+sp->subsampling_convert_ylines+sp->subsampling_convert_clines);\n\t\t\tfor (n=0; n<sp->subsampling_convert_ylines; n++)\n\t\t\t\t*m++=sp->subsampling_convert_ybuf+n*sp->subsampling_convert_ylinelen;\n\t\t\tfor (n=0; n<sp->subsampling_convert_clines; n++)\n\t\t\t\t*m++=sp->subsampling_convert_cbbuf+n*sp->subsampling_convert_clinelen;\n\t\t\tfor (n=0; n<sp->subsampling_convert_clines; n++)\n\t\t\t\t*m++=sp->subsampling_convert_crbuf+n*sp->subsampling_convert_clinelen;\n\t\t\tsp->subsampling_convert_clinelenout=((sp->strile_width+sp->subsampling_hor-1)/sp->subsampling_hor);\n\t\t\tsp->subsampling_convert_state=0;\n\t\t\tsp->bytes_per_line=sp->subsampling_convert_clinelenout*(sp->subsampling_ver*sp->subsampling_hor+2);\n\t\t\tsp->lines_per_strile=((sp->strile_length+sp->subsampling_ver-1)/sp->subsampling_ver);\n\t\t\tsp->subsampling_convert_log=1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tsp->libjpeg_jpeg_decompress_struct.jpeg_color_space=JCS_UNKNOWN;\n\t\tsp->libjpeg_jpeg_decompress_struct.out_color_space=JCS_UNKNOWN;\n\t\tsp->libjpeg_jpeg_query_style=1;\n\t\tsp->bytes_per_line=sp->samples_per_pixel_per_plane*sp->strile_width;\n\t\tsp->lines_per_strile=sp->strile_length;\n\t}\n\tif (jpeg_start_decompress_encap(sp,&(sp->libjpeg_jpeg_decompress_struct))==0)\n\t\treturn(0);\n\tsp->writeheader_done=1;\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              1152,
              0
            ],
            [
              1244,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteHeaderInfo",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nOJPEGLibjpegSessionAbort(TIFF* tif)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(sp->libjpeg_session_active!=0);\n\tjpeg_destroy((jpeg_common_struct*)(&(sp->libjpeg_jpeg_decompress_struct)));\n\tsp->libjpeg_session_active=0;\n}",
          "fn_code_pos": [
            [
              1246,
              0
            ],
            [
              1253,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGLibjpegSessionAbort",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nOJPEGReadHeaderInfoSec(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSec\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tuint16 n;\n\tuint8 o;\n\tif (sp->file_size==0)\n\t\tsp->file_size=TIFFGetFileSize(tif);\n\tif (sp->jpeg_interchange_format!=0)\n\t{\n\t\tif (sp->jpeg_interchange_format>=sp->file_size)\n\t\t{\n\t\t\tsp->jpeg_interchange_format=0;\n\t\t\tsp->jpeg_interchange_format_length=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((sp->jpeg_interchange_format_length==0) || (sp->jpeg_interchange_format+sp->jpeg_interchange_format_length>sp->file_size))\n\t\t\t\tsp->jpeg_interchange_format_length=sp->file_size-sp->jpeg_interchange_format;\n\t\t}\n\t}\n\tsp->in_buffer_source=osibsNotSetYet;\n\tsp->in_buffer_next_strile=0;\n\tsp->in_buffer_strile_count=tif->tif_dir.td_nstrips;\n\tsp->in_buffer_file_togo=0;\n\tsp->in_buffer_togo=0;\n\tdo\n\t{\n\t\tif (OJPEGReadBytePeek(sp,&m)==0)\n\t\t\treturn(0);\n\t\tif (m!=255)\n\t\t\tbreak;\n\t\tOJPEGReadByteAdvance(sp);\n\t\tdo\n\t\t{\n\t\t\tif (OJPEGReadByte(sp,&m)==0)\n\t\t\t\treturn(0);\n\t\t} while(m==255);\n\t\tswitch(m)\n\t\t{\n\t\t\tcase JPEG_MARKER_SOI:\n\t\t\t\t/* this type of marker has no data, and should be skipped */\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_COM:\n\t\t\tcase JPEG_MARKER_APP0:\n\t\t\tcase JPEG_MARKER_APP0+1:\n\t\t\tcase JPEG_MARKER_APP0+2:\n\t\t\tcase JPEG_MARKER_APP0+3:\n\t\t\tcase JPEG_MARKER_APP0+4:\n\t\t\tcase JPEG_MARKER_APP0+5:\n\t\t\tcase JPEG_MARKER_APP0+6:\n\t\t\tcase JPEG_MARKER_APP0+7:\n\t\t\tcase JPEG_MARKER_APP0+8:\n\t\t\tcase JPEG_MARKER_APP0+9:\n\t\t\tcase JPEG_MARKER_APP0+10:\n\t\t\tcase JPEG_MARKER_APP0+11:\n\t\t\tcase JPEG_MARKER_APP0+12:\n\t\t\tcase JPEG_MARKER_APP0+13:\n\t\t\tcase JPEG_MARKER_APP0+14:\n\t\t\tcase JPEG_MARKER_APP0+15:\n\t\t\t\t/* this type of marker has data, but it has no use to us (and no place here) and should be skipped */\n\t\t\t\tif (OJPEGReadWord(sp,&n)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tif (n<2)\n\t\t\t\t{\n\t\t\t\t\tif (sp->subsamplingcorrect==0)\n\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JPEG data\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tif (n>2)\n\t\t\t\t\tOJPEGReadSkip(sp,n-2);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_DRI:\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamDri(tif)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_DQT:\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamDqt(tif)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_DHT:\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamDht(tif)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_SOF0:\n\t\t\tcase JPEG_MARKER_SOF1:\n\t\t\tcase JPEG_MARKER_SOF3:\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamSof(tif,m)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tif (sp->subsamplingcorrect!=0)\n\t\t\t\t\treturn(1);\n\t\t\t\tbreak;\n\t\t\tcase JPEG_MARKER_SOS:\n\t\t\t\tif (sp->subsamplingcorrect!=0)\n\t\t\t\t\treturn(1);\n\t\t\t\tassert(sp->plane_sample_offset==0);\n\t\t\t\tif (OJPEGReadHeaderInfoSecStreamSos(tif)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Unknown marker type %d in JPEG data\",m);\n\t\t\t\treturn(0);\n\t\t}\n\t} while(m!=JPEG_MARKER_SOS);\n\tif (sp->subsamplingcorrect)\n\t\treturn(1);\n\tif (sp->sof_log==0)\n\t{\n\t\tif (OJPEGReadHeaderInfoSecTablesQTable(tif)==0)\n\t\t\treturn(0);\n\t\tsp->sof_marker_id=JPEG_MARKER_SOF0;\n\t\tfor (o=0; o<sp->samples_per_pixel; o++)\n\t\t\tsp->sof_c[o]=o;\n\t\tsp->sof_hv[0]=((sp->subsampling_hor<<4)|sp->subsampling_ver);\n\t\tfor (o=1; o<sp->samples_per_pixel; o++)\n\t\t\tsp->sof_hv[o]=17;\n\t\tsp->sof_x=sp->strile_width;\n\t\tsp->sof_y=sp->strile_length_total;\n\t\tsp->sof_log=1;\n\t\tif (OJPEGReadHeaderInfoSecTablesDcTable(tif)==0)\n\t\t\treturn(0);\n\t\tif (OJPEGReadHeaderInfoSecTablesAcTable(tif)==0)\n\t\t\treturn(0);\n\t\tfor (o=1; o<sp->samples_per_pixel; o++)\n\t\t\tsp->sos_cs[o]=o;\n\t}\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              1255,
              0
            ],
            [
              1384,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSec",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGReadHeaderInfoSecStreamDri(TIFF* tif)\n{\n\t/* This could easily cause trouble in some cases... but no such cases have\n           occurred so far */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamDri\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m!=4)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DRI marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tsp->restart_interval=m;\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              1386,
              0
            ],
            [
              1405,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSecStreamDri",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGReadHeaderInfoSecStreamDqt(TIFF* tif)\n{\n\t/* this is a table marker, and it is to be saved as a whole for exact pushing on the jpeg stream later on */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamDqt\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tuint32 na;\n\tuint8* nb;\n\tuint8 o;\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m<=2)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DQT marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tif (sp->subsamplingcorrect!=0)\n\t\tOJPEGReadSkip(sp,m-2);\n\telse\n\t{\n\t\tm-=2;\n\t\tdo\n\t\t{\n\t\t\tif (m<65)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DQT marker in JPEG data\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tna=sizeof(uint32)+69;\n\t\t\tnb=_TIFFmalloc(na);\n\t\t\tif (nb==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t*(uint32*)nb=na;\n\t\t\tnb[sizeof(uint32)]=255;\n\t\t\tnb[sizeof(uint32)+1]=JPEG_MARKER_DQT;\n\t\t\tnb[sizeof(uint32)+2]=0;\n\t\t\tnb[sizeof(uint32)+3]=67;\n\t\t\tif (OJPEGReadBlock(sp,65,&nb[sizeof(uint32)+4])==0) {\n\t\t\t\t_TIFFfree(nb);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\to=nb[sizeof(uint32)+4]&15;\n\t\t\tif (3<o)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DQT marker in JPEG data\");\n\t\t\t\t_TIFFfree(nb);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (sp->qtable[o]!=0)\n\t\t\t\t_TIFFfree(sp->qtable[o]);\n\t\t\tsp->qtable[o]=nb;\n\t\t\tm-=65;\n\t\t} while(m>0);\n\t}\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              1407,
              0
            ],
            [
              1467,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSecStreamDqt",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGReadHeaderInfoSecStreamDht(TIFF* tif)\n{\n\t/* this is a table marker, and it is to be saved as a whole for exact pushing on the jpeg stream later on */\n\t/* TODO: the following assumes there is only one table in this marker... but i'm not quite sure that assumption is guaranteed correct */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamDht\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tuint32 na;\n\tuint8* nb;\n\tuint8 o;\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m<=2)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tif (sp->subsamplingcorrect!=0)\n\t{\n\t\tOJPEGReadSkip(sp,m-2);\n\t}\n\telse\n\t{\n\t\tna=sizeof(uint32)+2+m;\n\t\tnb=_TIFFmalloc(na);\n\t\tif (nb==0)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\treturn(0);\n\t\t}\n\t\t*(uint32*)nb=na;\n\t\tnb[sizeof(uint32)]=255;\n\t\tnb[sizeof(uint32)+1]=JPEG_MARKER_DHT;\n\t\tnb[sizeof(uint32)+2]=(m>>8);\n\t\tnb[sizeof(uint32)+3]=(m&255);\n\t\tif (OJPEGReadBlock(sp,m-2,&nb[sizeof(uint32)+4])==0) {\n                        _TIFFfree(nb);\n\t\t\treturn(0);\n                }\n\t\to=nb[sizeof(uint32)+4];\n\t\tif ((o&240)==0)\n\t\t{\n\t\t\tif (3<o)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n                                _TIFFfree(nb);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (sp->dctable[o]!=0)\n\t\t\t\t_TIFFfree(sp->dctable[o]);\n\t\t\tsp->dctable[o]=nb;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((o&240)!=16)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n                                _TIFFfree(nb);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\to&=15;\n\t\t\tif (3<o)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n                                _TIFFfree(nb);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (sp->actable[o]!=0)\n\t\t\t\t_TIFFfree(sp->actable[o]);\n\t\t\tsp->actable[o]=nb;\n\t\t}\n\t}\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              1469,
              0
            ],
            [
              1544,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSecStreamDht",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGReadHeaderInfoSecStreamSof(TIFF* tif, uint8 marker_id)\n{\n\t/* this marker needs to be checked, and part of its data needs to be saved for regeneration later on */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamSof\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tuint16 n;\n\tuint8 o;\n\tuint16 p;\n\tuint16 q;\n\tif (sp->sof_log!=0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JPEG data\");\n\t\treturn(0);\n\t}\n\tif (sp->subsamplingcorrect==0)\n\t\tsp->sof_marker_id=marker_id;\n\t/* Lf: data length */\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m<11)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOF marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tm-=8;\n\tif (m%3!=0)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOF marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tn=m/3;\n\tif (sp->subsamplingcorrect==0)\n\t{\n\t\tif (n!=sp->samples_per_pixel)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected number of samples\");\n\t\t\treturn(0);\n\t\t}\n\t}\n\t/* P: Sample precision */\n\tif (OJPEGReadByte(sp,&o)==0)\n\t\treturn(0);\n\tif (o!=8)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected number of bits per sample\");\n\t\treturn(0);\n\t}\n\t/* Y: Number of lines, X: Number of samples per line */\n\tif (sp->subsamplingcorrect)\n\t\tOJPEGReadSkip(sp,4);\n\telse\n\t{\n\t\t/* Y: Number of lines */\n\t\tif (OJPEGReadWord(sp,&p)==0)\n\t\t\treturn(0);\n\t\tif (((uint32)p<sp->image_length) && ((uint32)p<sp->strile_length_total))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected height\");\n\t\t\treturn(0);\n\t\t}\n\t\tsp->sof_y=p;\n\t\t/* X: Number of samples per line */\n\t\tif (OJPEGReadWord(sp,&p)==0)\n\t\t\treturn(0);\n\t\tif (((uint32)p<sp->image_width) && ((uint32)p<sp->strile_width))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected width\");\n\t\t\treturn(0);\n\t\t}\n\t\tif ((uint32)p>sp->strile_width)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data image width exceeds expected image width\");\n\t\t\treturn(0);\n\t\t}\n\t\tsp->sof_x=p;\n\t}\n\t/* Nf: Number of image components in frame */\n\tif (OJPEGReadByte(sp,&o)==0)\n\t\treturn(0);\n\tif (o!=n)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOF marker in JPEG data\");\n\t\treturn(0);\n\t}\n\t/* per component stuff */\n\t/* TODO: double-check that flow implies that n cannot be as big as to make us overflow sof_c, sof_hv and sof_tq arrays */\n\tfor (q=0; q<n; q++)\n\t{\n\t\t/* C: Component identifier */\n\t\tif (OJPEGReadByte(sp,&o)==0)\n\t\t\treturn(0);\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tsp->sof_c[q]=o;\n\t\t/* H: Horizontal sampling factor, and V: Vertical sampling factor */\n\t\tif (OJPEGReadByte(sp,&o)==0)\n\t\t\treturn(0);\n\t\tif (sp->subsamplingcorrect!=0)\n\t\t{\n\t\t\tif (q==0)\n\t\t\t{\n\t\t\t\tsp->subsampling_hor=(o>>4);\n\t\t\t\tsp->subsampling_ver=(o&15);\n\t\t\t\tif (((sp->subsampling_hor!=1) && (sp->subsampling_hor!=2) && (sp->subsampling_hor!=4)) ||\n\t\t\t\t\t((sp->subsampling_ver!=1) && (sp->subsampling_ver!=2) && (sp->subsampling_ver!=4)))\n\t\t\t\t\tsp->subsampling_force_desubsampling_inside_decompression=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (o!=17)\n\t\t\t\t\tsp->subsampling_force_desubsampling_inside_decompression=1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsp->sof_hv[q]=o;\n\t\t\tif (sp->subsampling_force_desubsampling_inside_decompression==0)\n\t\t\t{\n\t\t\t\tif (q==0)\n\t\t\t\t{\n\t\t\t\t\tif (o!=((sp->subsampling_hor<<4)|sp->subsampling_ver))\n\t\t\t\t\t{\n\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected subsampling values\");\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (o!=17)\n\t\t\t\t\t{\n\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"JPEG compressed data indicates unexpected subsampling values\");\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* Tq: Quantization table destination selector */\n\t\tif (OJPEGReadByte(sp,&o)==0)\n\t\t\treturn(0);\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tsp->sof_tq[q]=o;\n\t}\n\tif (sp->subsamplingcorrect==0)\n\t\tsp->sof_log=1;\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              1546,
              0
            ],
            [
              1696,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSecStreamSof",
            "parameters": {
              "tif": "TIFF",
              "marker_id": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGReadHeaderInfoSecStreamSos(TIFF* tif)\n{\n\t/* this marker needs to be checked, and part of its data needs to be saved for regeneration later on */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamSos\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tuint8 n;\n\tuint8 o;\n\tassert(sp->subsamplingcorrect==0);\n\tif (sp->sof_log==0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOS marker in JPEG data\");\n\t\treturn(0);\n\t}\n\t/* Ls */\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m!=6+sp->samples_per_pixel_per_plane*2)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOS marker in JPEG data\");\n\t\treturn(0);\n\t}\n\t/* Ns */\n\tif (OJPEGReadByte(sp,&n)==0)\n\t\treturn(0);\n\tif (n!=sp->samples_per_pixel_per_plane)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt SOS marker in JPEG data\");\n\t\treturn(0);\n\t}\n\t/* Cs, Td, and Ta */\n\tfor (o=0; o<sp->samples_per_pixel_per_plane; o++)\n\t{\n\t\t/* Cs */\n\t\tif (OJPEGReadByte(sp,&n)==0)\n\t\t\treturn(0);\n\t\tsp->sos_cs[sp->plane_sample_offset+o]=n;\n\t\t/* Td and Ta */\n\t\tif (OJPEGReadByte(sp,&n)==0)\n\t\t\treturn(0);\n\t\tsp->sos_tda[sp->plane_sample_offset+o]=n;\n\t}\n\t/* skip Ss, Se, Ah, en Al -> no check, as per Tom Lane recommendation, as per LibJpeg source */\n\tOJPEGReadSkip(sp,3);\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              1698,
              0
            ],
            [
              1744,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSecStreamSos",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGReadHeaderInfoSecTablesQTable(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecTablesQTable\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tuint8 n;\n\tuint32 oa;\n\tuint8* ob;\n\tuint32 p;\n\tif (sp->qtable_offset[0]==0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Missing JPEG tables\");\n\t\treturn(0);\n\t}\n\tsp->in_buffer_file_pos_log=0;\n\tfor (m=0; m<sp->samples_per_pixel; m++)\n\t{\n\t\tif ((sp->qtable_offset[m]!=0) && ((m==0) || (sp->qtable_offset[m]!=sp->qtable_offset[m-1])))\n\t\t{\n\t\t\tfor (n=0; n<m-1; n++)\n\t\t\t{\n\t\t\t\tif (sp->qtable_offset[m]==sp->qtable_offset[n])\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JpegQTables tag value\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\toa=sizeof(uint32)+69;\n\t\t\tob=_TIFFmalloc(oa);\n\t\t\tif (ob==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t*(uint32*)ob=oa;\n\t\t\tob[sizeof(uint32)]=255;\n\t\t\tob[sizeof(uint32)+1]=JPEG_MARKER_DQT;\n\t\t\tob[sizeof(uint32)+2]=0;\n\t\t\tob[sizeof(uint32)+3]=67;\n\t\t\tob[sizeof(uint32)+4]=m;\n\t\t\tTIFFSeekFile(tif,sp->qtable_offset[m],SEEK_SET); \n\t\t\tp=(uint32)TIFFReadFile(tif,&ob[sizeof(uint32)+5],64);\n\t\t\tif (p!=64)\n                        {\n                                _TIFFfree(ob);\n\t\t\t\treturn(0);\n                        }\n\t\t\tif (sp->qtable[m]!=0)\n\t\t\t\t_TIFFfree(sp->qtable[m]);\n\t\t\tsp->qtable[m]=ob;\n\t\t\tsp->sof_tq[m]=m;\n\t\t}\n\t\telse\n\t\t\tsp->sof_tq[m]=sp->sof_tq[m-1];\n\t}\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              1746,
              0
            ],
            [
              1803,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSecTablesQTable",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGReadHeaderInfoSecTablesDcTable(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecTablesDcTable\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tuint8 n;\n\tuint8 o[16];\n\tuint32 p;\n\tuint32 q;\n\tuint32 ra;\n\tuint8* rb;\n\tif (sp->dctable_offset[0]==0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Missing JPEG tables\");\n\t\treturn(0);\n\t}\n\tsp->in_buffer_file_pos_log=0;\n\tfor (m=0; m<sp->samples_per_pixel; m++)\n\t{\n\t\tif ((sp->dctable_offset[m]!=0) && ((m==0) || (sp->dctable_offset[m]!=sp->dctable_offset[m-1])))\n\t\t{\n\t\t\tfor (n=0; n<m-1; n++)\n\t\t\t{\n\t\t\t\tif (sp->dctable_offset[m]==sp->dctable_offset[n])\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JpegDcTables tag value\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTIFFSeekFile(tif,sp->dctable_offset[m],SEEK_SET);\n\t\t\tp=(uint32)TIFFReadFile(tif,o,16);\n\t\t\tif (p!=16)\n\t\t\t\treturn(0);\n\t\t\tq=0;\n\t\t\tfor (n=0; n<16; n++)\n\t\t\t\tq+=o[n];\n\t\t\tra=sizeof(uint32)+21+q;\n\t\t\trb=_TIFFmalloc(ra);\n\t\t\tif (rb==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t*(uint32*)rb=ra;\n\t\t\trb[sizeof(uint32)]=255;\n\t\t\trb[sizeof(uint32)+1]=JPEG_MARKER_DHT;\n\t\t\trb[sizeof(uint32)+2]=(uint8)((19+q)>>8);\n\t\t\trb[sizeof(uint32)+3]=((19+q)&255);\n\t\t\trb[sizeof(uint32)+4]=m;\n\t\t\tfor (n=0; n<16; n++)\n\t\t\t\trb[sizeof(uint32)+5+n]=o[n];\n\t\t\tp=(uint32)TIFFReadFile(tif,&(rb[sizeof(uint32)+21]),q);\n\t\t\tif (p!=q)\n                        {\n                                _TIFFfree(rb);\n\t\t\t\treturn(0);\n                        }\n\t\t\tif (sp->dctable[m]!=0)\n\t\t\t\t_TIFFfree(sp->dctable[m]);\n\t\t\tsp->dctable[m]=rb;\n\t\t\tsp->sos_tda[m]=(m<<4);\n\t\t}\n\t\telse\n\t\t\tsp->sos_tda[m]=sp->sos_tda[m-1];\n\t}\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              1805,
              0
            ],
            [
              1872,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSecTablesDcTable",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGReadHeaderInfoSecTablesAcTable(TIFF* tif)\n{\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecTablesAcTable\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tuint8 n;\n\tuint8 o[16];\n\tuint32 p;\n\tuint32 q;\n\tuint32 ra;\n\tuint8* rb;\n\tif (sp->actable_offset[0]==0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Missing JPEG tables\");\n\t\treturn(0);\n\t}\n\tsp->in_buffer_file_pos_log=0;\n\tfor (m=0; m<sp->samples_per_pixel; m++)\n\t{\n\t\tif ((sp->actable_offset[m]!=0) && ((m==0) || (sp->actable_offset[m]!=sp->actable_offset[m-1])))\n\t\t{\n\t\t\tfor (n=0; n<m-1; n++)\n\t\t\t{\n\t\t\t\tif (sp->actable_offset[m]==sp->actable_offset[n])\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt JpegAcTables tag value\");\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTIFFSeekFile(tif,sp->actable_offset[m],SEEK_SET);  \n\t\t\tp=(uint32)TIFFReadFile(tif,o,16);\n\t\t\tif (p!=16)\n\t\t\t\treturn(0);\n\t\t\tq=0;\n\t\t\tfor (n=0; n<16; n++)\n\t\t\t\tq+=o[n];\n\t\t\tra=sizeof(uint32)+21+q;\n\t\t\trb=_TIFFmalloc(ra);\n\t\t\tif (rb==0)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t*(uint32*)rb=ra;\n\t\t\trb[sizeof(uint32)]=255;\n\t\t\trb[sizeof(uint32)+1]=JPEG_MARKER_DHT;\n\t\t\trb[sizeof(uint32)+2]=(uint8)((19+q)>>8);\n\t\t\trb[sizeof(uint32)+3]=((19+q)&255);\n\t\t\trb[sizeof(uint32)+4]=(16|m);\n\t\t\tfor (n=0; n<16; n++)\n\t\t\t\trb[sizeof(uint32)+5+n]=o[n];\n\t\t\tp=(uint32)TIFFReadFile(tif,&(rb[sizeof(uint32)+21]),q);\n\t\t\tif (p!=q)\n                        {\n                                _TIFFfree(rb);\n\t\t\t\treturn(0);\n                        }\n\t\t\tif (sp->actable[m]!=0)\n\t\t\t\t_TIFFfree(sp->actable[m]);\n\t\t\tsp->actable[m]=rb;\n\t\t\tsp->sos_tda[m]=(sp->sos_tda[m]|m);\n\t\t}\n\t\telse\n\t\t\tsp->sos_tda[m]=(sp->sos_tda[m]|(sp->sos_tda[m-1]&15));\n\t}\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              1874,
              0
            ],
            [
              1941,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSecTablesAcTable",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGReadBufferFill(OJPEGState* sp)\n{\n\tuint16 m;\n\ttmsize_t n;\n\t/* TODO: double-check: when subsamplingcorrect is set, no call to TIFFErrorExt or TIFFWarningExt should be made\n\t * in any other case, seek or read errors should be passed through */\n\tdo\n\t{\n\t\tif (sp->in_buffer_file_togo!=0)\n\t\t{\n\t\t\tif (sp->in_buffer_file_pos_log==0)\n\t\t\t{\n\t\t\t\tTIFFSeekFile(sp->tif,sp->in_buffer_file_pos,SEEK_SET);\n\t\t\t\tsp->in_buffer_file_pos_log=1;\n\t\t\t}\n\t\t\tm=OJPEG_BUFFER;\n\t\t\tif ((uint64)m>sp->in_buffer_file_togo)\n\t\t\t\tm=(uint16)sp->in_buffer_file_togo;\n\t\t\tn=TIFFReadFile(sp->tif,sp->in_buffer,(tmsize_t)m);\n\t\t\tif (n==0)\n\t\t\t\treturn(0);\n\t\t\tassert(n>0);\n\t\t\tassert(n<=OJPEG_BUFFER);\n\t\t\tassert(n<65536);\n\t\t\tassert((uint64)n<=sp->in_buffer_file_togo);\n\t\t\tm=(uint16)n;\n\t\t\tsp->in_buffer_togo=m;\n\t\t\tsp->in_buffer_cur=sp->in_buffer;\n\t\t\tsp->in_buffer_file_togo-=m;\n\t\t\tsp->in_buffer_file_pos+=m;\n\t\t\tbreak;\n\t\t}\n\t\tsp->in_buffer_file_pos_log=0;\n\t\tswitch(sp->in_buffer_source)\n\t\t{\n\t\t\tcase osibsNotSetYet:\n\t\t\t\tif (sp->jpeg_interchange_format!=0)\n\t\t\t\t{\n\t\t\t\t\tsp->in_buffer_file_pos=sp->jpeg_interchange_format;\n\t\t\t\t\tsp->in_buffer_file_togo=sp->jpeg_interchange_format_length;\n\t\t\t\t}\n\t\t\t\tsp->in_buffer_source=osibsJpegInterchangeFormat;\n\t\t\t\tbreak;\n\t\t\tcase osibsJpegInterchangeFormat:\n\t\t\t\tsp->in_buffer_source=osibsStrile;\n                                break;\n\t\t\tcase osibsStrile:\n\t\t\t\tif (!_TIFFFillStriles( sp->tif ) \n\t\t\t\t    || sp->tif->tif_dir.td_stripoffset == NULL\n\t\t\t\t    || sp->tif->tif_dir.td_stripbytecount == NULL)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tif (sp->in_buffer_next_strile==sp->in_buffer_strile_count)\n\t\t\t\t\tsp->in_buffer_source=osibsEof;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsp->in_buffer_file_pos=sp->tif->tif_dir.td_stripoffset[sp->in_buffer_next_strile];\n\t\t\t\t\tif (sp->in_buffer_file_pos!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (sp->in_buffer_file_pos>=sp->file_size)\n\t\t\t\t\t\t\tsp->in_buffer_file_pos=0;\n\t\t\t\t\t\telse if (sp->tif->tif_dir.td_stripbytecount==NULL)\n\t\t\t\t\t\t\tsp->in_buffer_file_togo=sp->file_size-sp->in_buffer_file_pos;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (sp->tif->tif_dir.td_stripbytecount == 0) {\n\t\t\t\t\t\t\t\tTIFFErrorExt(sp->tif->tif_clientdata,sp->tif->tif_name,\"Strip byte counts are missing\");\n\t\t\t\t\t\t\t\treturn(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsp->in_buffer_file_togo=sp->tif->tif_dir.td_stripbytecount[sp->in_buffer_next_strile];\n\t\t\t\t\t\t\tif (sp->in_buffer_file_togo==0)\n\t\t\t\t\t\t\t\tsp->in_buffer_file_pos=0;\n\t\t\t\t\t\t\telse if (sp->in_buffer_file_pos+sp->in_buffer_file_togo>sp->file_size)\n\t\t\t\t\t\t\t\tsp->in_buffer_file_togo=sp->file_size-sp->in_buffer_file_pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsp->in_buffer_next_strile++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn(0);\n\t\t}\n\t} while (1);\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              1943,
              0
            ],
            [
              2028,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadBufferFill",
            "parameters": {
              "sp": "OJPEGState"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGReadByte(OJPEGState* sp, uint8* byte)\n{\n\tif (sp->in_buffer_togo==0)\n\t{\n\t\tif (OJPEGReadBufferFill(sp)==0)\n\t\t\treturn(0);\n\t\tassert(sp->in_buffer_togo>0);\n\t}\n\t*byte=*(sp->in_buffer_cur);\n\tsp->in_buffer_cur++;\n\tsp->in_buffer_togo--;\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              2030,
              0
            ],
            [
              2043,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadByte",
            "parameters": {
              "sp": "OJPEGState",
              "byte": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGReadBytePeek(OJPEGState* sp, uint8* byte)\n{\n\tif (sp->in_buffer_togo==0)\n\t{\n\t\tif (OJPEGReadBufferFill(sp)==0)\n\t\t\treturn(0);\n\t\tassert(sp->in_buffer_togo>0);\n\t}\n\t*byte=*(sp->in_buffer_cur);\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              2045,
              0
            ],
            [
              2056,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadBytePeek",
            "parameters": {
              "sp": "OJPEGState",
              "byte": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nOJPEGReadByteAdvance(OJPEGState* sp)\n{\n\tassert(sp->in_buffer_togo>0);\n\tsp->in_buffer_cur++;\n\tsp->in_buffer_togo--;\n}",
          "fn_code_pos": [
            [
              2058,
              0
            ],
            [
              2064,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadByteAdvance",
            "parameters": {
              "sp": "OJPEGState"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nOJPEGReadWord(OJPEGState* sp, uint16* word)\n{\n\tuint8 m;\n\tif (OJPEGReadByte(sp,&m)==0)\n\t\treturn(0);\n\t*word=(m<<8);\n\tif (OJPEGReadByte(sp,&m)==0)\n\t\treturn(0);\n\t*word|=m;\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              2066,
              0
            ],
            [
              2077,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadWord",
            "parameters": {
              "sp": "OJPEGState",
              "word": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nOJPEGReadBlock(OJPEGState* sp, uint16 len, void* mem)\n{\n\tuint16 mlen;\n\tuint8* mmem;\n\tuint16 n;\n\tassert(len>0);\n\tmlen=len;\n\tmmem=mem;\n\tdo\n\t{\n\t\tif (sp->in_buffer_togo==0)\n\t\t{\n\t\t\tif (OJPEGReadBufferFill(sp)==0)\n\t\t\t\treturn(0);\n\t\t\tassert(sp->in_buffer_togo>0);\n\t\t}\n\t\tn=mlen;\n\t\tif (n>sp->in_buffer_togo)\n\t\t\tn=sp->in_buffer_togo;\n\t\t_TIFFmemcpy(mmem,sp->in_buffer_cur,n);\n\t\tsp->in_buffer_cur+=n;\n\t\tsp->in_buffer_togo-=n;\n\t\tmlen-=n;\n\t\tmmem+=n;\n\t} while(mlen>0);\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              2079,
              0
            ],
            [
              2106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadBlock",
            "parameters": {
              "sp": "OJPEGState",
              "len": "uint16",
              "mem": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nOJPEGReadSkip(OJPEGState* sp, uint16 len)\n{\n\tuint16 m;\n\tuint16 n;\n\tm=len;\n\tn=m;\n\tif (n>sp->in_buffer_togo)\n\t\tn=sp->in_buffer_togo;\n\tsp->in_buffer_cur+=n;\n\tsp->in_buffer_togo-=n;\n\tm-=n;\n\tif (m>0)\n\t{\n\t\tassert(sp->in_buffer_togo==0);\n\t\tn=m;\n\t\tif ((uint64)n>sp->in_buffer_file_togo)\n\t\t\tn=(uint16)sp->in_buffer_file_togo;\n\t\tsp->in_buffer_file_pos+=n;\n\t\tsp->in_buffer_file_togo-=n;\n\t\tsp->in_buffer_file_pos_log=0;\n\t\t/* we don't skip past jpeginterchangeformat/strile block...\n\t\t * if that is asked from us, we're dealing with totally bazurk\n\t\t * data anyway, and we've not seen this happening on any\n\t\t * testfile, so we might as well likely cause some other\n\t\t * meaningless error to be passed at some later time\n\t\t */\n\t}\n}",
          "fn_code_pos": [
            [
              2108,
              0
            ],
            [
              2136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadSkip",
            "parameters": {
              "sp": "OJPEGState",
              "len": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nOJPEGWriteStream(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\t*len=0;\n\tdo\n\t{\n\t\tassert(sp->out_state<=ososEoi);\n\t\tswitch(sp->out_state)\n\t\t{\n\t\t\tcase ososSoi:\n\t\t\t\tOJPEGWriteStreamSoi(tif,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososQTable0:\n\t\t\t\tOJPEGWriteStreamQTable(tif,0,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososQTable1:\n\t\t\t\tOJPEGWriteStreamQTable(tif,1,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososQTable2:\n\t\t\t\tOJPEGWriteStreamQTable(tif,2,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososQTable3:\n\t\t\t\tOJPEGWriteStreamQTable(tif,3,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososDcTable0:\n\t\t\t\tOJPEGWriteStreamDcTable(tif,0,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososDcTable1:\n\t\t\t\tOJPEGWriteStreamDcTable(tif,1,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososDcTable2:\n\t\t\t\tOJPEGWriteStreamDcTable(tif,2,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososDcTable3:\n\t\t\t\tOJPEGWriteStreamDcTable(tif,3,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososAcTable0:\n\t\t\t\tOJPEGWriteStreamAcTable(tif,0,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososAcTable1:\n\t\t\t\tOJPEGWriteStreamAcTable(tif,1,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososAcTable2:\n\t\t\t\tOJPEGWriteStreamAcTable(tif,2,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososAcTable3:\n\t\t\t\tOJPEGWriteStreamAcTable(tif,3,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososDri:\n\t\t\t\tOJPEGWriteStreamDri(tif,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososSof:\n\t\t\t\tOJPEGWriteStreamSof(tif,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososSos:\n\t\t\t\tOJPEGWriteStreamSos(tif,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososCompressed:\n\t\t\t\tif (OJPEGWriteStreamCompressed(tif,mem,len)==0)\n\t\t\t\t\treturn(0);\n\t\t\t\tbreak;\n\t\t\tcase ososRst:\n\t\t\t\tOJPEGWriteStreamRst(tif,mem,len);\n\t\t\t\tbreak;\n\t\t\tcase ososEoi:\n\t\t\t\tOJPEGWriteStreamEoi(tif,mem,len);\n\t\t\t\tbreak;\n\t\t}\n\t} while (*len==0);\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              2138,
              0
            ],
            [
              2209,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStream",
            "parameters": {
              "tif": "TIFF",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nOJPEGWriteStreamSoi(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(OJPEG_BUFFER>=2);\n\tsp->out_buffer[0]=255;\n\tsp->out_buffer[1]=JPEG_MARKER_SOI;\n\t*len=2;\n\t*mem=(void*)sp->out_buffer;\n\tsp->out_state++;\n}",
          "fn_code_pos": [
            [
              2211,
              0
            ],
            [
              2221,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamSoi",
            "parameters": {
              "tif": "TIFF",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nOJPEGWriteStreamQTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tif (sp->qtable[table_index]!=0)\n\t{\n\t\t*mem=(void*)(sp->qtable[table_index]+sizeof(uint32));\n\t\t*len=*((uint32*)sp->qtable[table_index])-sizeof(uint32);\n\t}\n\tsp->out_state++;\n}",
          "fn_code_pos": [
            [
              2223,
              0
            ],
            [
              2233,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamQTable",
            "parameters": {
              "tif": "TIFF",
              "table_index": "uint8",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nOJPEGWriteStreamDcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tif (sp->dctable[table_index]!=0)\n\t{\n\t\t*mem=(void*)(sp->dctable[table_index]+sizeof(uint32));\n\t\t*len=*((uint32*)sp->dctable[table_index])-sizeof(uint32);\n\t}\n\tsp->out_state++;\n}",
          "fn_code_pos": [
            [
              2235,
              0
            ],
            [
              2245,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamDcTable",
            "parameters": {
              "tif": "TIFF",
              "table_index": "uint8",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nOJPEGWriteStreamAcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tif (sp->actable[table_index]!=0)\n\t{\n\t\t*mem=(void*)(sp->actable[table_index]+sizeof(uint32));\n\t\t*len=*((uint32*)sp->actable[table_index])-sizeof(uint32);\n\t}\n\tsp->out_state++;\n}",
          "fn_code_pos": [
            [
              2247,
              0
            ],
            [
              2257,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamAcTable",
            "parameters": {
              "tif": "TIFF",
              "table_index": "uint8",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nOJPEGWriteStreamDri(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(OJPEG_BUFFER>=6);\n\tif (sp->restart_interval!=0)\n\t{\n\t\tsp->out_buffer[0]=255;\n\t\tsp->out_buffer[1]=JPEG_MARKER_DRI;\n\t\tsp->out_buffer[2]=0;\n\t\tsp->out_buffer[3]=4;\n\t\tsp->out_buffer[4]=(sp->restart_interval>>8);\n\t\tsp->out_buffer[5]=(sp->restart_interval&255);\n\t\t*len=6;\n\t\t*mem=(void*)sp->out_buffer;\n\t}\n\tsp->out_state++;\n}",
          "fn_code_pos": [
            [
              2259,
              0
            ],
            [
              2276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamDri",
            "parameters": {
              "tif": "TIFF",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nOJPEGWriteStreamSof(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tassert(OJPEG_BUFFER>=2+8+sp->samples_per_pixel_per_plane*3);\n\tassert(255>=8+sp->samples_per_pixel_per_plane*3);\n\tsp->out_buffer[0]=255;\n\tsp->out_buffer[1]=sp->sof_marker_id;\n\t/* Lf */\n\tsp->out_buffer[2]=0;\n\tsp->out_buffer[3]=8+sp->samples_per_pixel_per_plane*3;\n\t/* P */\n\tsp->out_buffer[4]=8;\n\t/* Y */\n\tsp->out_buffer[5]=(uint8)(sp->sof_y>>8);\n\tsp->out_buffer[6]=(sp->sof_y&255);\n\t/* X */\n\tsp->out_buffer[7]=(uint8)(sp->sof_x>>8);\n\tsp->out_buffer[8]=(sp->sof_x&255);\n\t/* Nf */\n\tsp->out_buffer[9]=sp->samples_per_pixel_per_plane;\n\tfor (m=0; m<sp->samples_per_pixel_per_plane; m++)\n\t{\n\t\t/* C */\n\t\tsp->out_buffer[10+m*3]=sp->sof_c[sp->plane_sample_offset+m];\n\t\t/* H and V */\n\t\tsp->out_buffer[10+m*3+1]=sp->sof_hv[sp->plane_sample_offset+m];\n\t\t/* Tq */\n\t\tsp->out_buffer[10+m*3+2]=sp->sof_tq[sp->plane_sample_offset+m];\n\t}\n\t*len=10+sp->samples_per_pixel_per_plane*3;\n\t*mem=(void*)sp->out_buffer;\n\tsp->out_state++;\n}",
          "fn_code_pos": [
            [
              2278,
              0
            ],
            [
              2312,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamSof",
            "parameters": {
              "tif": "TIFF",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nOJPEGWriteStreamSos(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint8 m;\n\tassert(OJPEG_BUFFER>=2+6+sp->samples_per_pixel_per_plane*2);\n\tassert(255>=6+sp->samples_per_pixel_per_plane*2);\n\tsp->out_buffer[0]=255;\n\tsp->out_buffer[1]=JPEG_MARKER_SOS;\n\t/* Ls */\n\tsp->out_buffer[2]=0;\n\tsp->out_buffer[3]=6+sp->samples_per_pixel_per_plane*2;\n\t/* Ns */\n\tsp->out_buffer[4]=sp->samples_per_pixel_per_plane;\n\tfor (m=0; m<sp->samples_per_pixel_per_plane; m++)\n\t{\n\t\t/* Cs */\n\t\tsp->out_buffer[5+m*2]=sp->sos_cs[sp->plane_sample_offset+m];\n\t\t/* Td and Ta */\n\t\tsp->out_buffer[5+m*2+1]=sp->sos_tda[sp->plane_sample_offset+m];\n\t}\n\t/* Ss */\n\tsp->out_buffer[5+sp->samples_per_pixel_per_plane*2]=0;\n\t/* Se */\n\tsp->out_buffer[5+sp->samples_per_pixel_per_plane*2+1]=63;\n\t/* Ah and Al */\n\tsp->out_buffer[5+sp->samples_per_pixel_per_plane*2+2]=0;\n\t*len=8+sp->samples_per_pixel_per_plane*2;\n\t*mem=(void*)sp->out_buffer;\n\tsp->out_state++;\n}",
          "fn_code_pos": [
            [
              2314,
              0
            ],
            [
              2344,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamSos",
            "parameters": {
              "tif": "TIFF",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nOJPEGWriteStreamCompressed(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tif (sp->in_buffer_togo==0)\n\t{\n\t\tif (OJPEGReadBufferFill(sp)==0)\n\t\t\treturn(0);\n\t\tassert(sp->in_buffer_togo>0);\n\t}\n\t*len=sp->in_buffer_togo;\n\t*mem=(void*)sp->in_buffer_cur;\n\tsp->in_buffer_togo=0;\n\tif (sp->in_buffer_file_togo==0)\n\t{\n\t\tswitch(sp->in_buffer_source)\n\t\t{\n\t\t\tcase osibsStrile:\n\t\t\t\tif (sp->in_buffer_next_strile<sp->in_buffer_strile_count)\n\t\t\t\t\tsp->out_state=ososRst;\n\t\t\t\telse\n\t\t\t\t\tsp->out_state=ososEoi;\n\t\t\t\tbreak;\n\t\t\tcase osibsEof:\n\t\t\t\tsp->out_state=ososEoi;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              2346,
              0
            ],
            [
              2377,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamCompressed",
            "parameters": {
              "tif": "TIFF",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nOJPEGWriteStreamRst(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(OJPEG_BUFFER>=2);\n\tsp->out_buffer[0]=255;\n\tsp->out_buffer[1]=JPEG_MARKER_RST0+sp->restart_index;\n\tsp->restart_index++;\n\tif (sp->restart_index==8)\n\t\tsp->restart_index=0;\n\t*len=2;\n\t*mem=(void*)sp->out_buffer;\n\tsp->out_state=ososCompressed;\n}",
          "fn_code_pos": [
            [
              2379,
              0
            ],
            [
              2392,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamRst",
            "parameters": {
              "tif": "TIFF",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nOJPEGWriteStreamEoi(TIFF* tif, void** mem, uint32* len)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tassert(OJPEG_BUFFER>=2);\n\tsp->out_buffer[0]=255;\n\tsp->out_buffer[1]=JPEG_MARKER_EOI;\n\t*len=2;\n\t*mem=(void*)sp->out_buffer;\n}",
          "fn_code_pos": [
            [
              2394,
              0
            ],
            [
              2403,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamEoi",
            "parameters": {
              "tif": "TIFF",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\njpeg_create_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo)\n{\n\tif( SETJMP(sp->exit_jmpbuf) )\n\t\treturn 0;\n\telse {\n\t\tjpeg_create_decompress(cinfo);\n\t\treturn 1;\n\t}\n}",
          "fn_code_pos": [
            [
              2406,
              0
            ],
            [
              2415,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_create_decompress_encap",
            "parameters": {
              "sp": "OJPEGState",
              "cinfo": "jpeg_decompress_struct"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\njpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8 require_image)\n{\n\tif( SETJMP(sp->exit_jmpbuf) )\n\t\treturn 0;\n\telse {\n\t\tjpeg_read_header(cinfo,require_image);\n\t\treturn 1;\n\t}\n}",
          "fn_code_pos": [
            [
              2419,
              0
            ],
            [
              2428,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_read_header_encap",
            "parameters": {
              "sp": "OJPEGState",
              "cinfo": "jpeg_decompress_struct",
              "require_image": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\njpeg_start_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo)\n{\n\tif( SETJMP(sp->exit_jmpbuf) )\n\t\treturn 0;\n\telse {\n\t\tjpeg_start_decompress(cinfo);\n\t\treturn 1;\n\t}\n}",
          "fn_code_pos": [
            [
              2432,
              0
            ],
            [
              2441,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_start_decompress_encap",
            "parameters": {
              "sp": "OJPEGState",
              "cinfo": "jpeg_decompress_struct"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\njpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32 max_lines)\n{\n\tif( SETJMP(sp->exit_jmpbuf) )\n\t\treturn 0;\n\telse {\n\t\tjpeg_read_scanlines(cinfo,scanlines,max_lines);\n\t\treturn 1;\n\t}\n}",
          "fn_code_pos": [
            [
              2445,
              0
            ],
            [
              2454,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_read_scanlines_encap",
            "parameters": {
              "sp": "OJPEGState",
              "cinfo": "jpeg_decompress_struct",
              "scanlines": "void",
              "max_lines": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\njpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32 max_lines)\n{\n\tif( SETJMP(sp->exit_jmpbuf) )\n\t\treturn 0;\n\telse {\n\t\tjpeg_read_raw_data(cinfo,data,max_lines);\n\t\treturn 1;\n\t}\n}",
          "fn_code_pos": [
            [
              2458,
              0
            ],
            [
              2467,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_read_raw_data_encap",
            "parameters": {
              "sp": "OJPEGState",
              "cinfo": "jpeg_decompress_struct",
              "data": "void",
              "max_lines": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\njpeg_encap_unwind(TIFF* tif)\n{\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tLONGJMP(sp->exit_jmpbuf,1);\n}",
          "fn_code_pos": [
            [
              2471,
              0
            ],
            [
              2476,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_encap_unwind",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nOJPEGLibjpegJpegErrorMgrOutputMessage(jpeg_common_struct* cinfo)\n{\n\tchar buffer[JMSG_LENGTH_MAX];\n\t(*cinfo->err->format_message)(cinfo,buffer);\n\tTIFFWarningExt(((TIFF*)(cinfo->client_data))->tif_clientdata,\"LibJpeg\",\"%s\",buffer);\n}",
          "fn_code_pos": [
            [
              2479,
              0
            ],
            [
              2485,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGLibjpegJpegErrorMgrOutputMessage",
            "parameters": {
              "cinfo": "jpeg_common_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nOJPEGLibjpegJpegErrorMgrErrorExit(jpeg_common_struct* cinfo)\n{\n\tchar buffer[JMSG_LENGTH_MAX];\n\t(*cinfo->err->format_message)(cinfo,buffer);\n\tTIFFErrorExt(((TIFF*)(cinfo->client_data))->tif_clientdata,\"LibJpeg\",\"%s\",buffer);\n\tjpeg_encap_unwind((TIFF*)(cinfo->client_data));\n}",
          "fn_code_pos": [
            [
              2487,
              0
            ],
            [
              2494,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGLibjpegJpegErrorMgrErrorExit",
            "parameters": {
              "cinfo": "jpeg_common_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nOJPEGLibjpegJpegSourceMgrInitSource(jpeg_decompress_struct* cinfo)\n{\n\t(void)cinfo;\n}",
          "fn_code_pos": [
            [
              2496,
              0
            ],
            [
              2500,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGLibjpegJpegSourceMgrInitSource",
            "parameters": {
              "cinfo": "jpeg_decompress_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static boolean\nOJPEGLibjpegJpegSourceMgrFillInputBuffer(jpeg_decompress_struct* cinfo)\n{\n\tTIFF* tif=(TIFF*)cinfo->client_data;\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tvoid* mem=0;\n\tuint32 len=0U;\n\tif (OJPEGWriteStream(tif,&mem,&len)==0)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,\"LibJpeg\",\"Premature end of JPEG data\");\n\t\tjpeg_encap_unwind(tif);\n\t}\n\tsp->libjpeg_jpeg_source_mgr.bytes_in_buffer=len;\n\tsp->libjpeg_jpeg_source_mgr.next_input_byte=mem;\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              2502,
              0
            ],
            [
              2517,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGLibjpegJpegSourceMgrFillInputBuffer",
            "parameters": {
              "cinfo": "jpeg_decompress_struct"
            },
            "return_type": "boolean"
          }
        },
        {
          "fn_code": "static void\nOJPEGLibjpegJpegSourceMgrSkipInputData(jpeg_decompress_struct* cinfo, long num_bytes)\n{\n\tTIFF* tif=(TIFF*)cinfo->client_data;\n\t(void)num_bytes;\n\tTIFFErrorExt(tif->tif_clientdata,\"LibJpeg\",\"Unexpected error\");\n\tjpeg_encap_unwind(tif);\n}",
          "fn_code_pos": [
            [
              2519,
              0
            ],
            [
              2526,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGLibjpegJpegSourceMgrSkipInputData",
            "parameters": {
              "cinfo": "jpeg_decompress_struct",
              "num_bytes": "long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static boolean\nOJPEGLibjpegJpegSourceMgrResyncToRestart(jpeg_decompress_struct* cinfo, int desired)\n{\n\tTIFF* tif=(TIFF*)cinfo->client_data;\n\t(void)desired;\n\tTIFFErrorExt(tif->tif_clientdata,\"LibJpeg\",\"Unexpected error\");\n\tjpeg_encap_unwind(tif);\n\treturn(0);\n}",
          "fn_code_pos": [
            [
              2532,
              0
            ],
            [
              2540,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGLibjpegJpegSourceMgrResyncToRestart",
            "parameters": {
              "cinfo": "jpeg_decompress_struct",
              "desired": "int"
            },
            "return_type": "boolean"
          }
        },
        {
          "fn_code": "static void\nOJPEGLibjpegJpegSourceMgrTermSource(jpeg_decompress_struct* cinfo)\n{\n\t(void)cinfo;\n}",
          "fn_code_pos": [
            [
              2545,
              0
            ],
            [
              2549,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGLibjpegJpegSourceMgrTermSource",
            "parameters": {
              "cinfo": "jpeg_decompress_struct"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "OJPEGVGetField(TIFF* tif, uint32 tag, va_list ap)",
          "fn_dec_pos": [
            [
              337,
              11
            ],
            [
              337,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGVGetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGVSetField(TIFF* tif, uint32 tag, va_list ap)",
          "fn_dec_pos": [
            [
              338,
              11
            ],
            [
              338,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGVSetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGPrintDir(TIFF* tif, FILE* fd, long flags)",
          "fn_dec_pos": [
            [
              339,
              12
            ],
            [
              339,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGPrintDir",
            "parameters": {
              "tif": "TIFF",
              "fd": "FILE",
              "flags": "long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGFixupTags(TIFF* tif)",
          "fn_dec_pos": [
            [
              341,
              11
            ],
            [
              341,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGFixupTags",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGSetupDecode(TIFF* tif)",
          "fn_dec_pos": [
            [
              342,
              11
            ],
            [
              342,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGSetupDecode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGPreDecode(TIFF* tif, uint16 s)",
          "fn_dec_pos": [
            [
              343,
              11
            ],
            [
              343,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGPreDecode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGPreDecodeSkipRaw(TIFF* tif)",
          "fn_dec_pos": [
            [
              344,
              11
            ],
            [
              344,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGPreDecodeSkipRaw",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGPreDecodeSkipScanlines(TIFF* tif)",
          "fn_dec_pos": [
            [
              345,
              11
            ],
            [
              345,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGPreDecodeSkipScanlines",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              346,
              11
            ],
            [
              346,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGDecode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc)",
          "fn_dec_pos": [
            [
              347,
              11
            ],
            [
              347,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGDecodeRaw",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGDecodeScanlines(TIFF* tif, uint8* buf, tmsize_t cc)",
          "fn_dec_pos": [
            [
              348,
              11
            ],
            [
              348,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGDecodeScanlines",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGPostDecode(TIFF* tif, uint8* buf, tmsize_t cc)",
          "fn_dec_pos": [
            [
              349,
              12
            ],
            [
              349,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGPostDecode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGSetupEncode(TIFF* tif)",
          "fn_dec_pos": [
            [
              350,
              11
            ],
            [
              350,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGSetupEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGPreEncode(TIFF* tif, uint16 s)",
          "fn_dec_pos": [
            [
              351,
              11
            ],
            [
              351,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGPreEncode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              352,
              11
            ],
            [
              352,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGEncode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGPostEncode(TIFF* tif)",
          "fn_dec_pos": [
            [
              353,
              11
            ],
            [
              353,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGPostEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGCleanup(TIFF* tif)",
          "fn_dec_pos": [
            [
              354,
              12
            ],
            [
              354,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGCleanup",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGSubsamplingCorrect(TIFF* tif)",
          "fn_dec_pos": [
            [
              356,
              12
            ],
            [
              356,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGSubsamplingCorrect",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGReadHeaderInfo(TIFF* tif)",
          "fn_dec_pos": [
            [
              357,
              11
            ],
            [
              357,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfo",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGReadSecondarySos(TIFF* tif, uint16 s)",
          "fn_dec_pos": [
            [
              358,
              11
            ],
            [
              358,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadSecondarySos",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGWriteHeaderInfo(TIFF* tif)",
          "fn_dec_pos": [
            [
              359,
              11
            ],
            [
              359,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteHeaderInfo",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGLibjpegSessionAbort(TIFF* tif)",
          "fn_dec_pos": [
            [
              360,
              12
            ],
            [
              360,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGLibjpegSessionAbort",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGReadHeaderInfoSec(TIFF* tif)",
          "fn_dec_pos": [
            [
              362,
              11
            ],
            [
              362,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSec",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGReadHeaderInfoSecStreamDri(TIFF* tif)",
          "fn_dec_pos": [
            [
              363,
              11
            ],
            [
              363,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSecStreamDri",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGReadHeaderInfoSecStreamDqt(TIFF* tif)",
          "fn_dec_pos": [
            [
              364,
              11
            ],
            [
              364,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSecStreamDqt",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGReadHeaderInfoSecStreamDht(TIFF* tif)",
          "fn_dec_pos": [
            [
              365,
              11
            ],
            [
              365,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSecStreamDht",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGReadHeaderInfoSecStreamSof(TIFF* tif, uint8 marker_id)",
          "fn_dec_pos": [
            [
              366,
              11
            ],
            [
              366,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSecStreamSof",
            "parameters": {
              "tif": "TIFF",
              "marker_id": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGReadHeaderInfoSecStreamSos(TIFF* tif)",
          "fn_dec_pos": [
            [
              367,
              11
            ],
            [
              367,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSecStreamSos",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGReadHeaderInfoSecTablesQTable(TIFF* tif)",
          "fn_dec_pos": [
            [
              368,
              11
            ],
            [
              368,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSecTablesQTable",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGReadHeaderInfoSecTablesDcTable(TIFF* tif)",
          "fn_dec_pos": [
            [
              369,
              11
            ],
            [
              369,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSecTablesDcTable",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGReadHeaderInfoSecTablesAcTable(TIFF* tif)",
          "fn_dec_pos": [
            [
              370,
              11
            ],
            [
              370,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadHeaderInfoSecTablesAcTable",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGReadBufferFill(OJPEGState* sp)",
          "fn_dec_pos": [
            [
              372,
              11
            ],
            [
              372,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadBufferFill",
            "parameters": {
              "sp": "OJPEGState"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGReadByte(OJPEGState* sp, uint8* byte)",
          "fn_dec_pos": [
            [
              373,
              11
            ],
            [
              373,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadByte",
            "parameters": {
              "sp": "OJPEGState",
              "byte": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGReadBytePeek(OJPEGState* sp, uint8* byte)",
          "fn_dec_pos": [
            [
              374,
              11
            ],
            [
              374,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadBytePeek",
            "parameters": {
              "sp": "OJPEGState",
              "byte": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGReadByteAdvance(OJPEGState* sp)",
          "fn_dec_pos": [
            [
              375,
              12
            ],
            [
              375,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadByteAdvance",
            "parameters": {
              "sp": "OJPEGState"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGReadWord(OJPEGState* sp, uint16* word)",
          "fn_dec_pos": [
            [
              376,
              11
            ],
            [
              376,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadWord",
            "parameters": {
              "sp": "OJPEGState",
              "word": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGReadBlock(OJPEGState* sp, uint16 len, void* mem)",
          "fn_dec_pos": [
            [
              377,
              11
            ],
            [
              377,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadBlock",
            "parameters": {
              "sp": "OJPEGState",
              "len": "uint16",
              "mem": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGReadSkip(OJPEGState* sp, uint16 len)",
          "fn_dec_pos": [
            [
              378,
              12
            ],
            [
              378,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGReadSkip",
            "parameters": {
              "sp": "OJPEGState",
              "len": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGWriteStream(TIFF* tif, void** mem, uint32* len)",
          "fn_dec_pos": [
            [
              380,
              11
            ],
            [
              380,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStream",
            "parameters": {
              "tif": "TIFF",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGWriteStreamSoi(TIFF* tif, void** mem, uint32* len)",
          "fn_dec_pos": [
            [
              381,
              12
            ],
            [
              381,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamSoi",
            "parameters": {
              "tif": "TIFF",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGWriteStreamQTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)",
          "fn_dec_pos": [
            [
              382,
              12
            ],
            [
              382,
              89
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamQTable",
            "parameters": {
              "tif": "TIFF",
              "table_index": "uint8",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGWriteStreamDcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)",
          "fn_dec_pos": [
            [
              383,
              12
            ],
            [
              383,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamDcTable",
            "parameters": {
              "tif": "TIFF",
              "table_index": "uint8",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGWriteStreamAcTable(TIFF* tif, uint8 table_index, void** mem, uint32* len)",
          "fn_dec_pos": [
            [
              384,
              12
            ],
            [
              384,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamAcTable",
            "parameters": {
              "tif": "TIFF",
              "table_index": "uint8",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGWriteStreamDri(TIFF* tif, void** mem, uint32* len)",
          "fn_dec_pos": [
            [
              385,
              12
            ],
            [
              385,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamDri",
            "parameters": {
              "tif": "TIFF",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGWriteStreamSof(TIFF* tif, void** mem, uint32* len)",
          "fn_dec_pos": [
            [
              386,
              12
            ],
            [
              386,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamSof",
            "parameters": {
              "tif": "TIFF",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGWriteStreamSos(TIFF* tif, void** mem, uint32* len)",
          "fn_dec_pos": [
            [
              387,
              12
            ],
            [
              387,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamSos",
            "parameters": {
              "tif": "TIFF",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGWriteStreamCompressed(TIFF* tif, void** mem, uint32* len)",
          "fn_dec_pos": [
            [
              388,
              11
            ],
            [
              388,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamCompressed",
            "parameters": {
              "tif": "TIFF",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "OJPEGWriteStreamRst(TIFF* tif, void** mem, uint32* len)",
          "fn_dec_pos": [
            [
              389,
              12
            ],
            [
              389,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamRst",
            "parameters": {
              "tif": "TIFF",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGWriteStreamEoi(TIFF* tif, void** mem, uint32* len)",
          "fn_dec_pos": [
            [
              390,
              12
            ],
            [
              390,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGWriteStreamEoi",
            "parameters": {
              "tif": "TIFF",
              "mem": "void",
              "len": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "jpeg_create_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo)",
          "fn_dec_pos": [
            [
              393,
              11
            ],
            [
              393,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_create_decompress_encap",
            "parameters": {
              "sp": "OJPEGState",
              "cinfo": "jpeg_decompress_struct"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "jpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8 require_image)",
          "fn_dec_pos": [
            [
              394,
              11
            ],
            [
              394,
              101
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_read_header_encap",
            "parameters": {
              "sp": "OJPEGState",
              "cinfo": "jpeg_decompress_struct",
              "require_image": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "jpeg_start_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo)",
          "fn_dec_pos": [
            [
              395,
              11
            ],
            [
              395,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_start_decompress_encap",
            "parameters": {
              "sp": "OJPEGState",
              "cinfo": "jpeg_decompress_struct"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "jpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32 max_lines)",
          "fn_dec_pos": [
            [
              396,
              11
            ],
            [
              396,
              118
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_read_scanlines_encap",
            "parameters": {
              "sp": "OJPEGState",
              "cinfo": "jpeg_decompress_struct",
              "scanlines": "void",
              "max_lines": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "jpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32 max_lines)",
          "fn_dec_pos": [
            [
              397,
              11
            ],
            [
              397,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_read_raw_data_encap",
            "parameters": {
              "sp": "OJPEGState",
              "cinfo": "jpeg_decompress_struct",
              "data": "void",
              "max_lines": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "jpeg_encap_unwind(TIFF* tif)",
          "fn_dec_pos": [
            [
              398,
              12
            ],
            [
              398,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_encap_unwind",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "jpeg_create_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* j)",
          "fn_dec_pos": [
            [
              400,
              11
            ],
            [
              400,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_create_decompress_encap",
            "parameters": {
              "sp": "OJPEGState",
              "j": "jpeg_decompress_struct"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "jpeg_read_header_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, uint8 require_image)",
          "fn_dec_pos": [
            [
              401,
              11
            ],
            [
              401,
              101
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_read_header_encap",
            "parameters": {
              "sp": "OJPEGState",
              "cinfo": "jpeg_decompress_struct",
              "require_image": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "jpeg_start_decompress_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo)",
          "fn_dec_pos": [
            [
              402,
              11
            ],
            [
              402,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_start_decompress_encap",
            "parameters": {
              "sp": "OJPEGState",
              "cinfo": "jpeg_decompress_struct"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "jpeg_read_scanlines_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* scanlines, uint32 max_lines)",
          "fn_dec_pos": [
            [
              403,
              11
            ],
            [
              403,
              118
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_read_scanlines_encap",
            "parameters": {
              "sp": "OJPEGState",
              "cinfo": "jpeg_decompress_struct",
              "scanlines": "void",
              "max_lines": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "jpeg_read_raw_data_encap(OJPEGState* sp, jpeg_decompress_struct* cinfo, void* data, uint32 max_lines)",
          "fn_dec_pos": [
            [
              404,
              11
            ],
            [
              404,
              112
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_read_raw_data_encap",
            "parameters": {
              "sp": "OJPEGState",
              "cinfo": "jpeg_decompress_struct",
              "data": "void",
              "max_lines": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "jpeg_encap_unwind(TIFF* tif)",
          "fn_dec_pos": [
            [
              405,
              12
            ],
            [
              405,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "jpeg_encap_unwind",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGLibjpegJpegErrorMgrOutputMessage(jpeg_common_struct* cinfo)",
          "fn_dec_pos": [
            [
              408,
              12
            ],
            [
              408,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGLibjpegJpegErrorMgrOutputMessage",
            "parameters": {
              "cinfo": "jpeg_common_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGLibjpegJpegErrorMgrErrorExit(jpeg_common_struct* cinfo)",
          "fn_dec_pos": [
            [
              409,
              12
            ],
            [
              409,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGLibjpegJpegErrorMgrErrorExit",
            "parameters": {
              "cinfo": "jpeg_common_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGLibjpegJpegSourceMgrInitSource(jpeg_decompress_struct* cinfo)",
          "fn_dec_pos": [
            [
              410,
              12
            ],
            [
              410,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGLibjpegJpegSourceMgrInitSource",
            "parameters": {
              "cinfo": "jpeg_decompress_struct"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGLibjpegJpegSourceMgrFillInputBuffer(jpeg_decompress_struct* cinfo)",
          "fn_dec_pos": [
            [
              411,
              15
            ],
            [
              411,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGLibjpegJpegSourceMgrFillInputBuffer",
            "parameters": {
              "cinfo": "jpeg_decompress_struct"
            },
            "return_type": "boolean"
          }
        },
        {
          "fn_code": "OJPEGLibjpegJpegSourceMgrSkipInputData(jpeg_decompress_struct* cinfo, long num_bytes)",
          "fn_dec_pos": [
            [
              412,
              12
            ],
            [
              412,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGLibjpegJpegSourceMgrSkipInputData",
            "parameters": {
              "cinfo": "jpeg_decompress_struct",
              "num_bytes": "long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "OJPEGLibjpegJpegSourceMgrResyncToRestart(jpeg_decompress_struct* cinfo, int desired)",
          "fn_dec_pos": [
            [
              413,
              15
            ],
            [
              413,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGLibjpegJpegSourceMgrResyncToRestart",
            "parameters": {
              "cinfo": "jpeg_decompress_struct",
              "desired": "int"
            },
            "return_type": "boolean"
          }
        },
        {
          "fn_code": "OJPEGLibjpegJpegSourceMgrTermSource(jpeg_decompress_struct* cinfo)",
          "fn_dec_pos": [
            [
              414,
              12
            ],
            [
              414,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OJPEGLibjpegJpegSourceMgrTermSource",
            "parameters": {
              "cinfo": "jpeg_decompress_struct"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\tTIFF* tif;\n        int decoder_ok;\n\t#ifndef LIBJPEG_ENCAP_EXTERNAL\n\tJMP_BUF exit_jmpbuf;\n\t#endif\n\tTIFFVGetMethod vgetparent;\n\tTIFFVSetMethod vsetparent;\n\tTIFFPrintMethod printdir;\n\tuint64 file_size;\n\tuint32 image_width;\n\tuint32 image_length;\n\tuint32 strile_width;\n\tuint32 strile_length;\n\tuint32 strile_length_total;\n\tuint8 samples_per_pixel;\n\tuint8 plane_sample_offset;\n\tuint8 samples_per_pixel_per_plane;\n\tuint64 jpeg_interchange_format;\n\tuint64 jpeg_interchange_format_length;\n\tuint8 jpeg_proc;\n\tuint8 subsamplingcorrect;\n\tuint8 subsamplingcorrect_done;\n\tuint8 subsampling_tag;\n\tuint8 subsampling_hor;\n\tuint8 subsampling_ver;\n\tuint8 subsampling_force_desubsampling_inside_decompression;\n\tuint8 qtable_offset_count;\n\tuint8 dctable_offset_count;\n\tuint8 actable_offset_count;\n\tuint64 qtable_offset[3];\n\tuint64 dctable_offset[3];\n\tuint64 actable_offset[3];\n\tuint8* qtable[4];\n\tuint8* dctable[4];\n\tuint8* actable[4];\n\tuint16 restart_interval;\n\tuint8 restart_index;\n\tuint8 sof_log;\n\tuint8 sof_marker_id;\n\tuint32 sof_x;\n\tuint32 sof_y;\n\tuint8 sof_c[3];\n\tuint8 sof_hv[3];\n\tuint8 sof_tq[3];\n\tuint8 sos_cs[3];\n\tuint8 sos_tda[3];\n\tstruct {\n\t\tuint8 log;\n\t\tOJPEGStateInBufferSource in_buffer_source;\n\t\tuint32 in_buffer_next_strile;\n\t\tuint64 in_buffer_file_pos;\n\t\tuint64 in_buffer_file_togo;\n\t} sos_end[3];\n\tuint8 readheader_done;\n\tuint8 writeheader_done;\n\tuint16 write_cursample;\n\tuint32 write_curstrile;\n\tuint8 libjpeg_session_active;\n\tuint8 libjpeg_jpeg_query_style;\n\tjpeg_error_mgr libjpeg_jpeg_error_mgr;\n\tjpeg_decompress_struct libjpeg_jpeg_decompress_struct;\n\tjpeg_source_mgr libjpeg_jpeg_source_mgr;\n\tuint8 subsampling_convert_log;\n\tuint32 subsampling_convert_ylinelen;\n\tuint32 subsampling_convert_ylines;\n\tuint32 subsampling_convert_clinelen;\n\tuint32 subsampling_convert_clines;\n\tuint32 subsampling_convert_ybuflen;\n\tuint32 subsampling_convert_cbuflen;\n\tuint32 subsampling_convert_ycbcrbuflen;\n\tuint8* subsampling_convert_ycbcrbuf;\n\tuint8* subsampling_convert_ybuf;\n\tuint8* subsampling_convert_cbbuf;\n\tuint8* subsampling_convert_crbuf;\n\tuint32 subsampling_convert_ycbcrimagelen;\n\tuint8** subsampling_convert_ycbcrimage;\n\tuint32 subsampling_convert_clinelenout;\n\tuint32 subsampling_convert_state;\n\tuint32 bytes_per_line;   /* if the codec outputs subsampled data, a 'line' in bytes_per_line */\n\tuint32 lines_per_strile; /* and lines_per_strile means subsampling_ver desubsampled rows     */\n\tOJPEGStateInBufferSource in_buffer_source;\n\tuint32 in_buffer_next_strile;\n\tuint32 in_buffer_strile_count;\n\tuint64 in_buffer_file_pos;\n\tuint8 in_buffer_file_pos_log;\n\tuint64 in_buffer_file_togo;\n\tuint16 in_buffer_togo;\n\tuint8* in_buffer_cur;\n\tuint8 in_buffer[OJPEG_BUFFER];\n\tOJPEGStateOutState out_state;\n\tuint8 out_buffer[OJPEG_BUFFER];\n\tuint8* skip_buffer;\n} OJPEGState;",
          {
            "* tif": "TIFF",
            "decoder_ok": "int",
            "exit_jmpbuf": "JMP_BUF",
            "vgetparent": "TIFFVGetMethod",
            "vsetparent": "TIFFVSetMethod",
            "printdir": "TIFFPrintMethod",
            "file_size": "uint64",
            "image_width": "uint32",
            "image_length": "uint32",
            "strile_width": "uint32",
            "strile_length": "uint32",
            "strile_length_total": "uint32",
            "samples_per_pixel": "uint8",
            "plane_sample_offset": "uint8",
            "samples_per_pixel_per_plane": "uint8",
            "jpeg_interchange_format": "uint64",
            "jpeg_interchange_format_length": "uint64",
            "jpeg_proc": "uint8",
            "subsamplingcorrect": "uint8",
            "subsamplingcorrect_done": "uint8",
            "subsampling_tag": "uint8",
            "subsampling_hor": "uint8",
            "subsampling_ver": "uint8",
            "subsampling_force_desubsampling_inside_decompression": "uint8",
            "qtable_offset_count": "uint8",
            "dctable_offset_count": "uint8",
            "actable_offset_count": "uint8",
            "qtable_offset[3]": "uint64",
            "dctable_offset[3]": "uint64",
            "actable_offset[3]": "uint64",
            "* qtable[4]": "uint8",
            "* dctable[4]": "uint8",
            "* actable[4]": "uint8",
            "restart_interval": "uint16",
            "restart_index": "uint8",
            "sof_log": "uint8",
            "sof_marker_id": "uint8",
            "sof_x": "uint32",
            "sof_y": "uint32",
            "sof_c[3]": "uint8",
            "sof_hv[3]": "uint8",
            "sof_tq[3]": "uint8",
            "sos_cs[3]": "uint8",
            "sos_tda[3]": "uint8",
            "sos_end[3]": "struct {\n\t\tuint8 log;\n\t\tOJPEGStateInBufferSource in_buffer_source;\n\t\tuint32 in_buffer_next_strile;\n\t\tuint64 in_buffer_file_pos;\n\t\tuint64 in_buffer_file_togo;\n\t}",
            "log": "uint8",
            "in_buffer_source": "OJPEGStateInBufferSource",
            "in_buffer_next_strile": "uint32",
            "in_buffer_file_pos": "uint64",
            "in_buffer_file_togo": "uint64",
            "readheader_done": "uint8",
            "writeheader_done": "uint8",
            "write_cursample": "uint16",
            "write_curstrile": "uint32",
            "libjpeg_session_active": "uint8",
            "libjpeg_jpeg_query_style": "uint8",
            "libjpeg_jpeg_error_mgr": "jpeg_error_mgr",
            "libjpeg_jpeg_decompress_struct": "jpeg_decompress_struct",
            "libjpeg_jpeg_source_mgr": "jpeg_source_mgr",
            "subsampling_convert_log": "uint8",
            "subsampling_convert_ylinelen": "uint32",
            "subsampling_convert_ylines": "uint32",
            "subsampling_convert_clinelen": "uint32",
            "subsampling_convert_clines": "uint32",
            "subsampling_convert_ybuflen": "uint32",
            "subsampling_convert_cbuflen": "uint32",
            "subsampling_convert_ycbcrbuflen": "uint32",
            "* subsampling_convert_ycbcrbuf": "uint8",
            "* subsampling_convert_ybuf": "uint8",
            "* subsampling_convert_cbbuf": "uint8",
            "* subsampling_convert_crbuf": "uint8",
            "subsampling_convert_ycbcrimagelen": "uint32",
            "** subsampling_convert_ycbcrimage": "uint8",
            "subsampling_convert_clinelenout": "uint32",
            "subsampling_convert_state": "uint32",
            "bytes_per_line": "uint32",
            "lines_per_strile": "uint32",
            "in_buffer_strile_count": "uint32",
            "in_buffer_file_pos_log": "uint8",
            "in_buffer_togo": "uint16",
            "* in_buffer_cur": "uint8",
            "in_buffer[OJPEG_BUFFER]": "uint8",
            "out_state": "OJPEGStateOutState",
            "out_buffer[OJPEG_BUFFER]": "uint8",
            "* skip_buffer": "uint8"
          },
          "OJPEGState",
          [
            242,
            0
          ],
          [
            335,
            13
          ]
        ],
        [
          "struct {\n\t\tuint8 log;\n\t\tOJPEGStateInBufferSource in_buffer_source;\n\t\tuint32 in_buffer_next_strile;\n\t\tuint64 in_buffer_file_pos;\n\t\tuint64 in_buffer_file_togo;\n\t}",
          {
            "log": "uint8",
            "in_buffer_source": "OJPEGStateInBufferSource",
            "in_buffer_next_strile": "uint32",
            "in_buffer_file_pos": "uint64",
            "in_buffer_file_togo": "uint64"
          },
          "",
          [
            289,
            1
          ],
          [
            295,
            2
          ]
        ],
        [
          "typedef struct jpeg_error_mgr jpeg_error_mgr;",
          {},
          "jpeg_error_mgr",
          [
            217,
            0
          ],
          [
            217,
            45
          ]
        ],
        [
          "typedef struct jpeg_common_struct jpeg_common_struct;",
          {},
          "jpeg_common_struct",
          [
            218,
            0
          ],
          [
            218,
            53
          ]
        ],
        [
          "typedef struct jpeg_decompress_struct jpeg_decompress_struct;",
          {},
          "jpeg_decompress_struct",
          [
            219,
            0
          ],
          [
            219,
            61
          ]
        ],
        [
          "typedef struct jpeg_source_mgr jpeg_source_mgr;",
          {},
          "jpeg_source_mgr",
          [
            220,
            0
          ],
          [
            220,
            47
          ]
        ],
        [
          "typedef struct {\n\tTIFF* tif;\n        int decoder_ok;\n\t#ifndef LIBJPEG_ENCAP_EXTERNAL\n\tJMP_BUF exit_jmpbuf;\n\t#endif\n\tTIFFVGetMethod vgetparent;\n\tTIFFVSetMethod vsetparent;\n\tTIFFPrintMethod printdir;\n\tuint64 file_size;\n\tuint32 image_width;\n\tuint32 image_length;\n\tuint32 strile_width;\n\tuint32 strile_length;\n\tuint32 strile_length_total;\n\tuint8 samples_per_pixel;\n\tuint8 plane_sample_offset;\n\tuint8 samples_per_pixel_per_plane;\n\tuint64 jpeg_interchange_format;\n\tuint64 jpeg_interchange_format_length;\n\tuint8 jpeg_proc;\n\tuint8 subsamplingcorrect;\n\tuint8 subsamplingcorrect_done;\n\tuint8 subsampling_tag;\n\tuint8 subsampling_hor;\n\tuint8 subsampling_ver;\n\tuint8 subsampling_force_desubsampling_inside_decompression;\n\tuint8 qtable_offset_count;\n\tuint8 dctable_offset_count;\n\tuint8 actable_offset_count;\n\tuint64 qtable_offset[3];\n\tuint64 dctable_offset[3];\n\tuint64 actable_offset[3];\n\tuint8* qtable[4];\n\tuint8* dctable[4];\n\tuint8* actable[4];\n\tuint16 restart_interval;\n\tuint8 restart_index;\n\tuint8 sof_log;\n\tuint8 sof_marker_id;\n\tuint32 sof_x;\n\tuint32 sof_y;\n\tuint8 sof_c[3];\n\tuint8 sof_hv[3];\n\tuint8 sof_tq[3];\n\tuint8 sos_cs[3];\n\tuint8 sos_tda[3];\n\tstruct {\n\t\tuint8 log;\n\t\tOJPEGStateInBufferSource in_buffer_source;\n\t\tuint32 in_buffer_next_strile;\n\t\tuint64 in_buffer_file_pos;\n\t\tuint64 in_buffer_file_togo;\n\t} sos_end[3];\n\tuint8 readheader_done;\n\tuint8 writeheader_done;\n\tuint16 write_cursample;\n\tuint32 write_curstrile;\n\tuint8 libjpeg_session_active;\n\tuint8 libjpeg_jpeg_query_style;\n\tjpeg_error_mgr libjpeg_jpeg_error_mgr;\n\tjpeg_decompress_struct libjpeg_jpeg_decompress_struct;\n\tjpeg_source_mgr libjpeg_jpeg_source_mgr;\n\tuint8 subsampling_convert_log;\n\tuint32 subsampling_convert_ylinelen;\n\tuint32 subsampling_convert_ylines;\n\tuint32 subsampling_convert_clinelen;\n\tuint32 subsampling_convert_clines;\n\tuint32 subsampling_convert_ybuflen;\n\tuint32 subsampling_convert_cbuflen;\n\tuint32 subsampling_convert_ycbcrbuflen;\n\tuint8* subsampling_convert_ycbcrbuf;\n\tuint8* subsampling_convert_ybuf;\n\tuint8* subsampling_convert_cbbuf;\n\tuint8* subsampling_convert_crbuf;\n\tuint32 subsampling_convert_ycbcrimagelen;\n\tuint8** subsampling_convert_ycbcrimage;\n\tuint32 subsampling_convert_clinelenout;\n\tuint32 subsampling_convert_state;\n\tuint32 bytes_per_line;   /* if the codec outputs subsampled data, a 'line' in bytes_per_line */\n\tuint32 lines_per_strile; /* and lines_per_strile means subsampling_ver desubsampled rows     */\n\tOJPEGStateInBufferSource in_buffer_source;\n\tuint32 in_buffer_next_strile;\n\tuint32 in_buffer_strile_count;\n\tuint64 in_buffer_file_pos;\n\tuint8 in_buffer_file_pos_log;\n\tuint64 in_buffer_file_togo;\n\tuint16 in_buffer_togo;\n\tuint8* in_buffer_cur;\n\tuint8 in_buffer[OJPEG_BUFFER];\n\tOJPEGStateOutState out_state;\n\tuint8 out_buffer[OJPEG_BUFFER];\n\tuint8* skip_buffer;\n} OJPEGState;",
          {
            "* tif": "TIFF",
            "decoder_ok": "int",
            "exit_jmpbuf": "JMP_BUF",
            "vgetparent": "TIFFVGetMethod",
            "vsetparent": "TIFFVSetMethod",
            "printdir": "TIFFPrintMethod",
            "file_size": "uint64",
            "image_width": "uint32",
            "image_length": "uint32",
            "strile_width": "uint32",
            "strile_length": "uint32",
            "strile_length_total": "uint32",
            "samples_per_pixel": "uint8",
            "plane_sample_offset": "uint8",
            "samples_per_pixel_per_plane": "uint8",
            "jpeg_interchange_format": "uint64",
            "jpeg_interchange_format_length": "uint64",
            "jpeg_proc": "uint8",
            "subsamplingcorrect": "uint8",
            "subsamplingcorrect_done": "uint8",
            "subsampling_tag": "uint8",
            "subsampling_hor": "uint8",
            "subsampling_ver": "uint8",
            "subsampling_force_desubsampling_inside_decompression": "uint8",
            "qtable_offset_count": "uint8",
            "dctable_offset_count": "uint8",
            "actable_offset_count": "uint8",
            "qtable_offset[3]": "uint64",
            "dctable_offset[3]": "uint64",
            "actable_offset[3]": "uint64",
            "* qtable[4]": "uint8",
            "* dctable[4]": "uint8",
            "* actable[4]": "uint8",
            "restart_interval": "uint16",
            "restart_index": "uint8",
            "sof_log": "uint8",
            "sof_marker_id": "uint8",
            "sof_x": "uint32",
            "sof_y": "uint32",
            "sof_c[3]": "uint8",
            "sof_hv[3]": "uint8",
            "sof_tq[3]": "uint8",
            "sos_cs[3]": "uint8",
            "sos_tda[3]": "uint8",
            "sos_end[3]": "struct {\n\t\tuint8 log;\n\t\tOJPEGStateInBufferSource in_buffer_source;\n\t\tuint32 in_buffer_next_strile;\n\t\tuint64 in_buffer_file_pos;\n\t\tuint64 in_buffer_file_togo;\n\t}",
            "log": "uint8",
            "in_buffer_source": "OJPEGStateInBufferSource",
            "in_buffer_next_strile": "uint32",
            "in_buffer_file_pos": "uint64",
            "in_buffer_file_togo": "uint64",
            "readheader_done": "uint8",
            "writeheader_done": "uint8",
            "write_cursample": "uint16",
            "write_curstrile": "uint32",
            "libjpeg_session_active": "uint8",
            "libjpeg_jpeg_query_style": "uint8",
            "libjpeg_jpeg_error_mgr": "jpeg_error_mgr",
            "libjpeg_jpeg_decompress_struct": "jpeg_decompress_struct",
            "libjpeg_jpeg_source_mgr": "jpeg_source_mgr",
            "subsampling_convert_log": "uint8",
            "subsampling_convert_ylinelen": "uint32",
            "subsampling_convert_ylines": "uint32",
            "subsampling_convert_clinelen": "uint32",
            "subsampling_convert_clines": "uint32",
            "subsampling_convert_ybuflen": "uint32",
            "subsampling_convert_cbuflen": "uint32",
            "subsampling_convert_ycbcrbuflen": "uint32",
            "* subsampling_convert_ycbcrbuf": "uint8",
            "* subsampling_convert_ybuf": "uint8",
            "* subsampling_convert_cbbuf": "uint8",
            "* subsampling_convert_crbuf": "uint8",
            "subsampling_convert_ycbcrimagelen": "uint32",
            "** subsampling_convert_ycbcrimage": "uint8",
            "subsampling_convert_clinelenout": "uint32",
            "subsampling_convert_state": "uint32",
            "bytes_per_line": "uint32",
            "lines_per_strile": "uint32",
            "in_buffer_strile_count": "uint32",
            "in_buffer_file_pos_log": "uint8",
            "in_buffer_togo": "uint16",
            "* in_buffer_cur": "uint8",
            "in_buffer[OJPEG_BUFFER]": "uint8",
            "out_state": "OJPEGStateOutState",
            "out_buffer[OJPEG_BUFFER]": "uint8",
            "* skip_buffer": "uint8"
          },
          "OJPEGState",
          [
            242,
            0
          ],
          [
            335,
            13
          ]
        ],
        [
          "struct {\n\t\tuint8 log;\n\t\tOJPEGStateInBufferSource in_buffer_source;\n\t\tuint32 in_buffer_next_strile;\n\t\tuint64 in_buffer_file_pos;\n\t\tuint64 in_buffer_file_togo;\n\t}",
          {
            "log": "uint8",
            "in_buffer_source": "OJPEGStateInBufferSource",
            "in_buffer_next_strile": "uint32",
            "in_buffer_file_pos": "uint64",
            "in_buffer_file_togo": "uint64"
          },
          "",
          [
            289,
            1
          ],
          [
            295,
            2
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            123,
            0
          ],
          [
            124,
            0
          ]
        ],
        [
          "#include <setjmp.h>\n",
          [
            187,
            0
          ],
          [
            188,
            0
          ]
        ],
        [
          "#include \"jpeglib.h\"\n",
          [
            214,
            0
          ],
          [
            215,
            0
          ]
        ],
        [
          "#include \"jerror.h\"\n",
          [
            215,
            0
          ],
          [
            216,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n\tosibsNotSetYet,\n\tosibsJpegInterchangeFormat,\n\tosibsStrile,\n\tosibsEof\n} OJPEGStateInBufferSource;",
          {
            "osibsNotSetYet": "",
            "osibsJpegInterchangeFormat": "",
            "osibsStrile": "",
            "osibsEof": ""
          },
          "OJPEGStateInBufferSource",
          [
            222,
            0
          ],
          [
            227,
            27
          ]
        ],
        [
          "typedef enum {\n\tososSoi,\n\tososQTable0,ososQTable1,ososQTable2,ososQTable3,\n\tososDcTable0,ososDcTable1,ososDcTable2,ososDcTable3,\n\tososAcTable0,ososAcTable1,ososAcTable2,ososAcTable3,\n\tososDri,\n\tososSof,\n\tososSos,\n\tososCompressed,\n\tososRst,\n\tososEoi\n} OJPEGStateOutState;",
          {
            "ososSoi": "",
            "ososQTable0": "",
            "ososQTable1": "",
            "ososQTable2": "",
            "ososQTable3": "",
            "ososDcTable0": "",
            "ososDcTable1": "",
            "ososDcTable2": "",
            "ososDcTable3": "",
            "ososAcTable0": "",
            "ososAcTable1": "",
            "ososAcTable2": "",
            "ososAcTable3": "",
            "ososDri": "",
            "ososSof": "",
            "ososSos": "",
            "ososCompressed": "",
            "ososRst": "",
            "ososEoi": ""
          },
          "OJPEGStateOutState",
          [
            229,
            0
          ],
          [
            240,
            21
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_print.c": {
      "fn_def_list": [
        {
          "fn_code": "static void\n_TIFFPrintField(FILE* fd, const TIFFField *fip,\n\t\tuint32 value_count, void *raw_data)\n{\n\tuint32 j;\n\t\t\n\tfprintf(fd, \"  %s: \", fip->field_name);\n\n\tfor(j = 0; j < value_count; j++) {\n\t\tif(fip->field_type == TIFF_BYTE)\n\t\t\tfprintf(fd, \"%u\", ((uint8 *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_UNDEFINED)\n\t\t\tfprintf(fd, \"0x%x\",\n\t\t\t    (unsigned int) ((unsigned char *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_SBYTE)\n\t\t\tfprintf(fd, \"%d\", ((int8 *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_SHORT)\n\t\t\tfprintf(fd, \"%u\", ((uint16 *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_SSHORT)\n\t\t\tfprintf(fd, \"%d\", ((int16 *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_LONG)\n\t\t\tfprintf(fd, \"%lu\",\n\t\t\t    (unsigned long)((uint32 *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_SLONG)\n\t\t\tfprintf(fd, \"%ld\", (long)((int32 *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_IFD)\n\t\t\tfprintf(fd, \"0x%lx\",\n\t\t\t\t(unsigned long)((uint32 *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_RATIONAL\n\t\t\t|| fip->field_type == TIFF_SRATIONAL\n\t\t\t|| fip->field_type == TIFF_FLOAT)\n\t\t\tfprintf(fd, \"%f\", ((float *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_LONG8)\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tfprintf(fd, \"%I64u\",\n\t\t\t    (unsigned __int64)((uint64 *) raw_data)[j]);\n#else\n\t\t\tfprintf(fd, \"%llu\",\n\t\t\t    (unsigned long long)((uint64 *) raw_data)[j]);\n#endif\n\t\telse if(fip->field_type == TIFF_SLONG8)\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tfprintf(fd, \"%I64d\", (__int64)((int64 *) raw_data)[j]);\n#else\n\t\t\tfprintf(fd, \"%lld\", (long long)((int64 *) raw_data)[j]);\n#endif\n\t\telse if(fip->field_type == TIFF_IFD8)\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tfprintf(fd, \"0x%I64x\",\n\t\t\t\t(unsigned __int64)((uint64 *) raw_data)[j]);\n#else\n\t\t\tfprintf(fd, \"0x%llx\",\n\t\t\t\t(unsigned long long)((uint64 *) raw_data)[j]);\n#endif\n\t\telse if(fip->field_type == TIFF_FLOAT)\n\t\t\tfprintf(fd, \"%f\", ((float *)raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_DOUBLE)\n\t\t\tfprintf(fd, \"%f\", ((double *) raw_data)[j]);\n\t\telse if(fip->field_type == TIFF_ASCII) {\n\t\t\tfprintf(fd, \"%s\", (char *) raw_data);\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tfprintf(fd, \"<unsupported data type in TIFFPrint>\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif(j < value_count - 1)\n\t\t\tfprintf(fd, \",\");\n\t}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              134,
              2
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFPrintField",
            "parameters": {
              "fd": "FILE",
              "fip": "TIFFField",
              "value_count": "uint32",
              "raw_data": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\n_TIFFPrettyPrintField(TIFF* tif, const TIFFField *fip, FILE* fd, uint32 tag,\n\t\t      uint32 value_count, void *raw_data)\n{\n        (void) tif;\n\n\t/* do not try to pretty print auto-defined fields */\n\tif (strncmp(fip->field_name,\"Tag \", 4) == 0) {\n\t\treturn 0;\n\t}\n        \n\tswitch (tag)\n\t{\n\t\tcase TIFFTAG_INKSET:\n\t\t\tif (value_count == 2 && fip->field_type == TIFF_SHORT) {\n\t\t\t\tfprintf(fd, \"  Ink Set: \");\n\t\t\t\tswitch (*((uint16*)raw_data)) {\n\t\t\t\tcase INKSET_CMYK:\n\t\t\t\t\tfprintf(fd, \"CMYK\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t\t\t\t*((uint16*)raw_data),\n\t\t\t\t\t\t*((uint16*)raw_data));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\n\t\tcase TIFFTAG_DOTRANGE:\n\t\t\tif (value_count == 2 && fip->field_type == TIFF_SHORT) {\n\t\t\t\tfprintf(fd, \"  Dot Range: %u-%u\\n\",\n\t\t\t\t\t((uint16*)raw_data)[0], ((uint16*)raw_data)[1]);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\n\t\tcase TIFFTAG_WHITEPOINT:\n\t\t\tif (value_count == 2 && fip->field_type == TIFF_RATIONAL) {\n\t\t\t\tfprintf(fd, \"  White Point: %g-%g\\n\",\n\t\t\t\t\t((float *)raw_data)[0], ((float *)raw_data)[1]);\n\t\t\t\treturn 1;\n\t\t\t} \n\t\t\treturn 0;\n\n\t\tcase TIFFTAG_XMLPACKET:\n\t\t{\n\t\t\tuint32 i;\n\n\t\t\tfprintf(fd, \"  XMLPacket (XMP Metadata):\\n\" );\n\t\t\tfor(i = 0; i < value_count; i++)\n\t\t\t\tfputc(((char *)raw_data)[i], fd);\n\t\t\tfprintf( fd, \"\\n\" );\n\t\t\treturn 1;\n\t\t}\n\t\tcase TIFFTAG_RICHTIFFIPTC:\n\t\t\t/*\n\t\t\t * XXX: for some weird reason RichTIFFIPTC tag\n\t\t\t * defined as array of LONG values.\n\t\t\t */\n\t\t\tfprintf(fd,\n\t\t\t    \"  RichTIFFIPTC Data: <present>, %lu bytes\\n\",\n\t\t\t    (unsigned long) value_count * 4);\n\t\t\treturn 1;\n\n\t\tcase TIFFTAG_PHOTOSHOP:\n\t\t\tfprintf(fd, \"  Photoshop Data: <present>, %lu bytes\\n\",\n\t\t\t    (unsigned long) value_count);\n\t\t\treturn 1;\n\n\t\tcase TIFFTAG_ICCPROFILE:\n\t\t\tfprintf(fd, \"  ICC Profile: <present>, %lu bytes\\n\",\n\t\t\t    (unsigned long) value_count);\n\t\t\treturn 1;\n\n\t\tcase TIFFTAG_STONITS:\n\t\t\tif (value_count == 1 && fip->field_type == TIFF_DOUBLE) { \n\t\t\t\tfprintf(fd,\n\t\t\t\t\t\"  Sample to Nits conversion factor: %.4e\\n\",\n\t\t\t\t\t*((double*)raw_data));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              139,
              0
            ],
            [
              226,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFPrettyPrintField",
            "parameters": {
              "tif": "TIFF",
              "fip": "TIFFField",
              "fd": "FILE",
              "tag": "uint32",
              "value_count": "uint32",
              "raw_data": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\nTIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tchar *sep;\n\tlong l, n;\n\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\tfprintf(fd, \"TIFF Directory at offset 0x%I64x (%I64u)\\n\",\n\t\t(unsigned __int64) tif->tif_diroff,\n\t\t(unsigned __int64) tif->tif_diroff);\n#else\n\tfprintf(fd, \"TIFF Directory at offset 0x%llx (%llu)\\n\",\n\t\t(unsigned long long) tif->tif_diroff,\n\t\t(unsigned long long) tif->tif_diroff);\n#endif\n\tif (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) {\n\t\tfprintf(fd, \"  Subfile Type:\");\n\t\tsep = \" \";\n\t\tif (td->td_subfiletype & FILETYPE_REDUCEDIMAGE) {\n\t\t\tfprintf(fd, \"%sreduced-resolution image\", sep);\n\t\t\tsep = \"/\";\n\t\t}\n\t\tif (td->td_subfiletype & FILETYPE_PAGE) {\n\t\t\tfprintf(fd, \"%smulti-page document\", sep);\n\t\t\tsep = \"/\";\n\t\t}\n\t\tif (td->td_subfiletype & FILETYPE_MASK)\n\t\t\tfprintf(fd, \"%stransparency mask\", sep);\n\t\tfprintf(fd, \" (%lu = 0x%lx)\\n\",\n\t\t    (unsigned long) td->td_subfiletype, (long) td->td_subfiletype);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) {\n\t\tfprintf(fd, \"  Image Width: %lu Image Length: %lu\",\n\t\t    (unsigned long) td->td_imagewidth, (unsigned long) td->td_imagelength);\n\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))\n\t\t\tfprintf(fd, \" Image Depth: %lu\",\n\t\t\t    (unsigned long) td->td_imagedepth);\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) {\n\t\tfprintf(fd, \"  Tile Width: %lu Tile Length: %lu\",\n\t\t    (unsigned long) td->td_tilewidth, (unsigned long) td->td_tilelength);\n\t\tif (TIFFFieldSet(tif,FIELD_TILEDEPTH))\n\t\t\tfprintf(fd, \" Tile Depth: %lu\",\n\t\t\t    (unsigned long) td->td_tiledepth);\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_RESOLUTION)) {\n\t\tfprintf(fd, \"  Resolution: %g, %g\",\n\t\t    td->td_xresolution, td->td_yresolution);\n\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) {\n\t\t\tswitch (td->td_resolutionunit) {\n\t\t\tcase RESUNIT_NONE:\n\t\t\t\tfprintf(fd, \" (unitless)\");\n\t\t\t\tbreak;\n\t\t\tcase RESUNIT_INCH:\n\t\t\t\tfprintf(fd, \" pixels/inch\");\n\t\t\t\tbreak;\n\t\t\tcase RESUNIT_CENTIMETER:\n\t\t\t\tfprintf(fd, \" pixels/cm\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(fd, \" (unit %u = 0x%x)\",\n\t\t\t\t    td->td_resolutionunit,\n\t\t\t\t    td->td_resolutionunit);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_POSITION))\n\t\tfprintf(fd, \"  Position: %g, %g\\n\",\n\t\t    td->td_xposition, td->td_yposition);\n\tif (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\tfprintf(fd, \"  Bits/Sample: %u\\n\", td->td_bitspersample);\n\tif (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) {\n\t\tfprintf(fd, \"  Sample Format: \");\n\t\tswitch (td->td_sampleformat) {\n\t\tcase SAMPLEFORMAT_VOID:\n\t\t\tfprintf(fd, \"void\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_INT:\n\t\t\tfprintf(fd, \"signed integer\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_UINT:\n\t\t\tfprintf(fd, \"unsigned integer\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\tfprintf(fd, \"IEEE floating point\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_COMPLEXINT:\n\t\t\tfprintf(fd, \"complex signed integer\\n\");\n\t\t\tbreak;\n\t\tcase SAMPLEFORMAT_COMPLEXIEEEFP:\n\t\t\tfprintf(fd, \"complex IEEE floating point\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_sampleformat, td->td_sampleformat);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_COMPRESSION)) {\n\t\tconst TIFFCodec* c = TIFFFindCODEC(td->td_compression);\n\t\tfprintf(fd, \"  Compression Scheme: \");\n\t\tif (c)\n\t\t\tfprintf(fd, \"%s\\n\", c->name);\n\t\telse\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_compression, td->td_compression);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) {\n\t\tfprintf(fd, \"  Photometric Interpretation: \");\n\t\tif (td->td_photometric < NPHOTONAMES)\n\t\t\tfprintf(fd, \"%s\\n\", photoNames[td->td_photometric]);\n\t\telse {\n\t\t\tswitch (td->td_photometric) {\n\t\t\tcase PHOTOMETRIC_LOGL:\n\t\t\t\tfprintf(fd, \"CIE Log2(L)\\n\");\n\t\t\t\tbreak;\n\t\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\t\tfprintf(fd, \"CIE Log2(L) (u',v')\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t\t    td->td_photometric, td->td_photometric);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_EXTRASAMPLES) && td->td_extrasamples) {\n\t\tuint16 i;\n\t\tfprintf(fd, \"  Extra Samples: %u<\", td->td_extrasamples);\n\t\tsep = \"\";\n\t\tfor (i = 0; i < td->td_extrasamples; i++) {\n\t\t\tswitch (td->td_sampleinfo[i]) {\n\t\t\tcase EXTRASAMPLE_UNSPECIFIED:\n\t\t\t\tfprintf(fd, \"%sunspecified\", sep);\n\t\t\t\tbreak;\n\t\t\tcase EXTRASAMPLE_ASSOCALPHA:\n\t\t\t\tfprintf(fd, \"%sassoc-alpha\", sep);\n\t\t\t\tbreak;\n\t\t\tcase EXTRASAMPLE_UNASSALPHA:\n\t\t\t\tfprintf(fd, \"%sunassoc-alpha\", sep);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(fd, \"%s%u (0x%x)\", sep,\n\t\t\t\t    td->td_sampleinfo[i], td->td_sampleinfo[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsep = \", \";\n\t\t}\n\t\tfprintf(fd, \">\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_INKNAMES)) {\n\t\tchar* cp;\n\t\tuint16 i;\n\t\tfprintf(fd, \"  Ink Names: \");\n\t\ti = td->td_samplesperpixel;\n\t\tsep = \"\";\n\t\tfor (cp = td->td_inknames; \n\t\t     i > 0 && cp < td->td_inknames + td->td_inknameslen; \n\t\t     cp = strchr(cp,'\\0')+1, i--) {\n\t\t\tsize_t max_chars = \n\t\t\t\ttd->td_inknameslen - (cp - td->td_inknames);\n\t\t\tfputs(sep, fd);\n\t\t\t_TIFFprintAsciiBounded(fd, cp, max_chars);\n\t\t\tsep = \", \";\n\t\t}\n                fputs(\"\\n\", fd);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) {\n\t\tfprintf(fd, \"  Thresholding: \");\n\t\tswitch (td->td_threshholding) {\n\t\tcase THRESHHOLD_BILEVEL:\n\t\t\tfprintf(fd, \"bilevel art scan\\n\");\n\t\t\tbreak;\n\t\tcase THRESHHOLD_HALFTONE:\n\t\t\tfprintf(fd, \"halftone or dithered scan\\n\");\n\t\t\tbreak;\n\t\tcase THRESHHOLD_ERRORDIFFUSE:\n\t\t\tfprintf(fd, \"error diffused\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_threshholding, td->td_threshholding);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_FILLORDER)) {\n\t\tfprintf(fd, \"  FillOrder: \");\n\t\tswitch (td->td_fillorder) {\n\t\tcase FILLORDER_MSB2LSB:\n\t\t\tfprintf(fd, \"msb-to-lsb\\n\");\n\t\t\tbreak;\n\t\tcase FILLORDER_LSB2MSB:\n\t\t\tfprintf(fd, \"lsb-to-msb\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_fillorder, td->td_fillorder);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))\n        {\n\t\tfprintf(fd, \"  YCbCr Subsampling: %u, %u\\n\",\n\t\t\ttd->td_ycbcrsubsampling[0], td->td_ycbcrsubsampling[1] );\n\t}\n\tif (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) {\n\t\tfprintf(fd, \"  YCbCr Positioning: \");\n\t\tswitch (td->td_ycbcrpositioning) {\n\t\tcase YCBCRPOSITION_CENTERED:\n\t\t\tfprintf(fd, \"centered\\n\");\n\t\t\tbreak;\n\t\tcase YCBCRPOSITION_COSITED:\n\t\t\tfprintf(fd, \"cosited\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_ycbcrpositioning, td->td_ycbcrpositioning);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))\n\t\tfprintf(fd, \"  Halftone Hints: light %u dark %u\\n\",\n\t\t    td->td_halftonehints[0], td->td_halftonehints[1]);\n\tif (TIFFFieldSet(tif,FIELD_ORIENTATION)) {\n\t\tfprintf(fd, \"  Orientation: \");\n\t\tif (td->td_orientation < NORIENTNAMES)\n\t\t\tfprintf(fd, \"%s\\n\", orientNames[td->td_orientation]);\n\t\telse\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_orientation, td->td_orientation);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\tfprintf(fd, \"  Samples/Pixel: %u\\n\", td->td_samplesperpixel);\n\tif (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) {\n\t\tfprintf(fd, \"  Rows/Strip: \");\n\t\tif (td->td_rowsperstrip == (uint32) -1)\n\t\t\tfprintf(fd, \"(infinite)\\n\");\n\t\telse\n\t\t\tfprintf(fd, \"%lu\\n\", (unsigned long) td->td_rowsperstrip);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))\n\t\tfprintf(fd, \"  Min Sample Value: %u\\n\", td->td_minsamplevalue);\n\tif (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))\n\t\tfprintf(fd, \"  Max Sample Value: %u\\n\", td->td_maxsamplevalue);\n\tif (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) {\n\t\tint i;\n\t\tint count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;\n\t\tfprintf(fd, \"  SMin Sample Value:\");\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tfprintf(fd, \" %g\", td->td_sminsamplevalue[i]);\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) {\n\t\tint i;\n\t\tint count = (tif->tif_flags & TIFF_PERSAMPLE) ? td->td_samplesperpixel : 1;\n\t\tfprintf(fd, \"  SMax Sample Value:\");\n\t\tfor (i = 0; i < count; ++i)\n\t\t\tfprintf(fd, \" %g\", td->td_smaxsamplevalue[i]);\n\t\tfprintf(fd, \"\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) {\n\t\tfprintf(fd, \"  Planar Configuration: \");\n\t\tswitch (td->td_planarconfig) {\n\t\tcase PLANARCONFIG_CONTIG:\n\t\t\tfprintf(fd, \"single image plane\\n\");\n\t\t\tbreak;\n\t\tcase PLANARCONFIG_SEPARATE:\n\t\t\tfprintf(fd, \"separate image planes\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(fd, \"%u (0x%x)\\n\",\n\t\t\t    td->td_planarconfig, td->td_planarconfig);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (TIFFFieldSet(tif,FIELD_PAGENUMBER))\n\t\tfprintf(fd, \"  Page Number: %u-%u\\n\",\n\t\t    td->td_pagenumber[0], td->td_pagenumber[1]);\n\tif (TIFFFieldSet(tif,FIELD_COLORMAP)) {\n\t\tfprintf(fd, \"  Color Map: \");\n\t\tif (flags & TIFFPRINT_COLORMAP) {\n\t\t\tfprintf(fd, \"\\n\");\n\t\t\tn = 1L<<td->td_bitspersample;\n\t\t\tfor (l = 0; l < n; l++)\n\t\t\t\tfprintf(fd, \"   %5ld: %5u %5u %5u\\n\",\n\t\t\t\t    l,\n\t\t\t\t    td->td_colormap[0][l],\n\t\t\t\t    td->td_colormap[1][l],\n\t\t\t\t    td->td_colormap[2][l]);\n\t\t} else\n\t\t\tfprintf(fd, \"(present)\\n\");\n\t}\n\tif (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) {\n\t\tint i;\n\t\tfprintf(fd, \"  Reference Black/White:\\n\");\n\t\tfor (i = 0; i < 3; i++)\n\t\tfprintf(fd, \"    %2d: %5g %5g\\n\", i,\n\t\t\ttd->td_refblackwhite[2*i+0],\n\t\t\ttd->td_refblackwhite[2*i+1]);\n\t}\n\tif (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) {\n\t\tfprintf(fd, \"  Transfer Function: \");\n\t\tif (flags & TIFFPRINT_CURVES) {\n\t\t\tfprintf(fd, \"\\n\");\n\t\t\tn = 1L<<td->td_bitspersample;\n\t\t\tfor (l = 0; l < n; l++) {\n\t\t\t\tuint16 i;\n\t\t\t\tfprintf(fd, \"    %2ld: %5u\",\n\t\t\t\t    l, td->td_transferfunction[0][l]);\n\t\t\t\tfor (i = 1; i < td->td_samplesperpixel - td->td_extrasamples && i < 3; i++)\n\t\t\t\t\tfprintf(fd, \" %5u\",\n\t\t\t\t\t    td->td_transferfunction[i][l]);\n\t\t\t\tfputc('\\n', fd);\n\t\t\t}\n\t\t} else\n\t\t\tfprintf(fd, \"(present)\\n\");\n\t}\n\tif (TIFFFieldSet(tif, FIELD_SUBIFD) && (td->td_subifd)) {\n\t\tuint16 i;\n\t\tfprintf(fd, \"  SubIFD Offsets:\");\n\t\tfor (i = 0; i < td->td_nsubifd; i++)\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tfprintf(fd, \" %5I64u\",\n\t\t\t\t(unsigned __int64) td->td_subifd[i]);\n#else\n\t\t\tfprintf(fd, \" %5llu\",\n\t\t\t\t(unsigned long long) td->td_subifd[i]);\n#endif\n\t\tfputc('\\n', fd);\n\t}\n\n\t/*\n\t** Custom tag support.\n\t*/\n\t{\n\t\tint  i;\n\t\tshort count;\n\n\t\tcount = (short) TIFFGetTagListCount(tif);\n\t\tfor(i = 0; i < count; i++) {\n\t\t\tuint32 tag = TIFFGetTagListEntry(tif, i);\n\t\t\tconst TIFFField *fip;\n\t\t\tuint32 value_count;\n\t\t\tint mem_alloc = 0;\n\t\t\tvoid *raw_data;\n\n\t\t\tfip = TIFFFieldWithTag(tif, tag);\n\t\t\tif(fip == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif(fip->field_passcount) {\n\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2 ) {\n\t\t\t\t\tif(TIFFGetField(tif, tag, &value_count, &raw_data) != 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else if (fip->field_readcount == TIFF_VARIABLE ) {\n\t\t\t\t\tuint16 small_value_count;\n\t\t\t\t\tif(TIFFGetField(tif, tag, &small_value_count, &raw_data) != 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvalue_count = small_value_count;\n\t\t\t\t} else {\n\t\t\t\t\tassert (fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t\t\t|| fip->field_readcount == TIFF_VARIABLE2);\n\t\t\t\t\tcontinue;\n\t\t\t\t} \n\t\t\t} else {\n\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2)\n\t\t\t\t\tvalue_count = 1;\n\t\t\t\telse if (fip->field_readcount == TIFF_SPP)\n\t\t\t\t\tvalue_count = td->td_samplesperpixel;\n\t\t\t\telse\n\t\t\t\t\tvalue_count = fip->field_readcount;\n\t\t\t\tif (fip->field_tag == TIFFTAG_DOTRANGE\n\t\t\t\t    && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t\t/* TODO: This is an evil exception and should not have been\n\t\t\t\t\t   handled this way ... likely best if we move it into\n\t\t\t\t\t   the directory structure with an explicit field in \n\t\t\t\t\t   libtiff 4.1 and assign it a FIELD_ value */\n\t\t\t\t\tstatic uint16 dotrange[2];\n\t\t\t\t\traw_data = dotrange;\n\t\t\t\t\tTIFFGetField(tif, tag, dotrange+0, dotrange+1);\n\t\t\t\t} else if (fip->field_type == TIFF_ASCII\n\t\t\t\t\t   || fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t\t   || fip->field_readcount == TIFF_VARIABLE2\n\t\t\t\t\t   || fip->field_readcount == TIFF_SPP\n\t\t\t\t\t   || value_count > 1) {\n\t\t\t\t\tif(TIFFGetField(tif, tag, &raw_data) != 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\traw_data = _TIFFmalloc(\n\t\t\t\t\t    _TIFFDataSize(fip->field_type)\n\t\t\t\t\t    * value_count);\n\t\t\t\t\tmem_alloc = 1;\n\t\t\t\t\tif(TIFFGetField(tif, tag, raw_data) != 1) {\n\t\t\t\t\t\t_TIFFfree(raw_data);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Catch the tags which needs to be specially handled\n\t\t\t * and pretty print them. If tag not handled in\n\t\t\t * _TIFFPrettyPrintField() fall down and print it as\n\t\t\t * any other tag.\n\t\t\t */\n\t\t\tif (!_TIFFPrettyPrintField(tif, fip, fd, tag, value_count, raw_data))\n\t\t\t\t_TIFFPrintField(fd, fip, value_count, raw_data);\n\n\t\t\tif(mem_alloc)\n\t\t\t\t_TIFFfree(raw_data);\n\t\t}\n\t}\n        \n\tif (tif->tif_tagmethods.printdir)\n\t\t(*tif->tif_tagmethods.printdir)(tif, fd, flags);\n\n        _TIFFFillStriles( tif );\n        \n\tif ((flags & TIFFPRINT_STRIPS) &&\n\t    TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) {\n\t\tuint32 s;\n\n\t\tfprintf(fd, \"  %lu %s:\\n\",\n\t\t    (unsigned long) td->td_nstrips,\n\t\t    isTiled(tif) ? \"Tiles\" : \"Strips\");\n\t\tfor (s = 0; s < td->td_nstrips; s++)\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tfprintf(fd, \"    %3lu: [%8I64u, %8I64u]\\n\",\n\t\t\t    (unsigned long) s,\n\t\t\t    td->td_stripoffset ? (unsigned __int64) td->td_stripoffset[s] : 0,\n\t\t\t    td->td_stripbytecount ? (unsigned __int64) td->td_stripbytecount[s] : 0);\n#else\n\t\t\tfprintf(fd, \"    %3lu: [%8llu, %8llu]\\n\",\n\t\t\t    (unsigned long) s,\n\t\t\t    td->td_stripoffset ? (unsigned long long) td->td_stripoffset[s] : 0,\n\t\t\t    td->td_stripbytecount ? (unsigned long long) td->td_stripbytecount[s] : 0);\n#endif\n\t}\n}",
          "fn_code_pos": [
            [
              232,
              0
            ],
            [
              676,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFPrintDirectory",
            "parameters": {
              "tif": "TIFF",
              "fd": "FILE",
              "flags": "long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\n_TIFFprintAscii(FILE* fd, const char* cp)\n{\n\t_TIFFprintAsciiBounded( fd, cp, strlen(cp));\n}",
          "fn_code_pos": [
            [
              678,
              0
            ],
            [
              682,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFprintAscii",
            "parameters": {
              "fd": "FILE",
              "cp": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\n_TIFFprintAsciiBounded(FILE* fd, const char* cp, size_t max_chars)\n{\n\tfor (; max_chars > 0 && *cp != '\\0'; cp++, max_chars--) {\n\t\tconst char* tp;\n\n\t\tif (isprint((int)*cp)) {\n\t\t\tfputc(*cp, fd);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (tp = \"\\tt\\bb\\rr\\nn\\vv\"; *tp; tp++)\n\t\t\tif (*tp++ == *cp)\n\t\t\t\tbreak;\n\t\tif (*tp)\n\t\t\tfprintf(fd, \"\\\\%c\", *tp);\n\t\telse\n\t\t\tfprintf(fd, \"\\\\%03o\", *cp & 0xff);\n\t}\n}",
          "fn_code_pos": [
            [
              684,
              0
            ],
            [
              702,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFprintAsciiBounded",
            "parameters": {
              "fd": "FILE",
              "cp": "char",
              "max_chars": "size_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\n_TIFFprintAsciiTag(FILE* fd, const char* name, const char* value)\n{\n\tfprintf(fd, \"  %s: \\\"\", name);\n\t_TIFFprintAscii(fd, value);\n\tfprintf(fd, \"\\\"\\n\");\n}",
          "fn_code_pos": [
            [
              704,
              0
            ],
            [
              710,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFprintAsciiTag",
            "parameters": {
              "fd": "FILE",
              "name": "char",
              "value": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "_TIFFprintAsciiBounded(FILE* fd, const char* cp, size_t max_chars)",
          "fn_dec_pos": [
            [
              35,
              0
            ],
            [
              35,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFprintAsciiBounded",
            "parameters": {
              "fd": "FILE",
              "cp": "char",
              "max_chars": "size_t"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_compress.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nTIFFNoEncode(TIFF* tif, const char* method)\n{\n\tconst TIFFCodec* c = TIFFFindCODEC(tif->tif_dir.td_compression);\n\n\tif (c) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"%s %s encoding is not implemented\",\n\t\t\t     c->name, method);\n\t} else {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\"Compression scheme %u %s encoding is not implemented\",\n\t\t\t     tif->tif_dir.td_compression, method);\n\t}\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              46,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFNoEncode",
            "parameters": {
              "tif": "TIFF",
              "method": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\n_TIFFNoRowEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)\n{\n\t(void) pp; (void) cc; (void) s;\n\treturn (TIFFNoEncode(tif, \"scanline\"));\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              53,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoRowEncode",
            "parameters": {
              "tif": "TIFF",
              "pp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\n_TIFFNoStripEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)\n{\n\t(void) pp; (void) cc; (void) s;\n\treturn (TIFFNoEncode(tif, \"strip\"));\n}",
          "fn_code_pos": [
            [
              55,
              0
            ],
            [
              60,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoStripEncode",
            "parameters": {
              "tif": "TIFF",
              "pp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\n_TIFFNoTileEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)\n{\n\t(void) pp; (void) cc; (void) s;\n\treturn (TIFFNoEncode(tif, \"tile\"));\n}",
          "fn_code_pos": [
            [
              62,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoTileEncode",
            "parameters": {
              "tif": "TIFF",
              "pp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFNoDecode(TIFF* tif, const char* method)\n{\n\tconst TIFFCodec* c = TIFFFindCODEC(tif->tif_dir.td_compression);\n\n\tif (c)\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"%s %s decoding is not implemented\",\n\t\t\t     c->name, method);\n\telse\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"Compression scheme %u %s decoding is not implemented\",\n\t\t\t     tif->tif_dir.td_compression, method);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              83,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFNoDecode",
            "parameters": {
              "tif": "TIFF",
              "method": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\n_TIFFNoFixupTags(TIFF* tif)\n{\n\t(void) tif;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              85,
              0
            ],
            [
              90,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoFixupTags",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\n_TIFFNoRowDecode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)\n{\n\t(void) pp; (void) cc; (void) s;\n\treturn (TIFFNoDecode(tif, \"scanline\"));\n}",
          "fn_code_pos": [
            [
              92,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoRowDecode",
            "parameters": {
              "tif": "TIFF",
              "pp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\n_TIFFNoStripDecode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)\n{\n\t(void) pp; (void) cc; (void) s;\n\treturn (TIFFNoDecode(tif, \"strip\"));\n}",
          "fn_code_pos": [
            [
              99,
              0
            ],
            [
              104,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoStripDecode",
            "parameters": {
              "tif": "TIFF",
              "pp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\n_TIFFNoTileDecode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)\n{\n\t(void) pp; (void) cc; (void) s;\n\treturn (TIFFNoDecode(tif, \"tile\"));\n}",
          "fn_code_pos": [
            [
              106,
              0
            ],
            [
              111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoTileDecode",
            "parameters": {
              "tif": "TIFF",
              "pp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\n_TIFFNoSeek(TIFF* tif, uint32 off)\n{\n\t(void) off;\n\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t     \"Compression algorithm does not support random access\");\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              113,
              0
            ],
            [
              120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoSeek",
            "parameters": {
              "tif": "TIFF",
              "off": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\n_TIFFNoPreCode(TIFF* tif, uint16 s)\n{\n\t(void) tif; (void) s;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              122,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoPreCode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int _TIFFtrue(TIFF* tif) { (void) tif; return (1); }",
          "fn_code_pos": [
            [
              129,
              0
            ],
            [
              129,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFtrue",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void _TIFFvoid(TIFF* tif) { (void) tif; }",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              130,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFvoid",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\n_TIFFSetDefaultCompressionState(TIFF* tif)\n{\n\ttif->tif_fixuptags = _TIFFNoFixupTags; \n\ttif->tif_decodestatus = TRUE;\n\ttif->tif_setupdecode = _TIFFtrue;\n\ttif->tif_predecode = _TIFFNoPreCode;\n\ttif->tif_decoderow = _TIFFNoRowDecode;  \n\ttif->tif_decodestrip = _TIFFNoStripDecode;\n\ttif->tif_decodetile = _TIFFNoTileDecode;  \n\ttif->tif_encodestatus = TRUE;\n\ttif->tif_setupencode = _TIFFtrue;\n\ttif->tif_preencode = _TIFFNoPreCode;\n\ttif->tif_postencode = _TIFFtrue;\n\ttif->tif_encoderow = _TIFFNoRowEncode;\n\ttif->tif_encodestrip = _TIFFNoStripEncode;  \n\ttif->tif_encodetile = _TIFFNoTileEncode;  \n\ttif->tif_close = _TIFFvoid;\n\ttif->tif_seek = _TIFFNoSeek;\n\ttif->tif_cleanup = _TIFFvoid;\n\ttif->tif_defstripsize = _TIFFDefaultStripSize;\n\ttif->tif_deftilesize = _TIFFDefaultTileSize;\n\ttif->tif_flags &= ~(TIFF_NOBITREV|TIFF_NOREADRAW);\n}",
          "fn_code_pos": [
            [
              132,
              0
            ],
            [
              155,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFSetDefaultCompressionState",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\nTIFFSetCompressionScheme(TIFF* tif, int scheme)\n{\n\tconst TIFFCodec *c = TIFFFindCODEC((uint16) scheme);\n\n\t_TIFFSetDefaultCompressionState(tif);\n\t/*\n\t * Don't treat an unknown compression scheme as an error.\n\t * This permits applications to open files with data that\n\t * the library does not have builtin support for, but which\n\t * may still be meaningful.\n\t */\n\treturn (c ? (*c->init)(tif, scheme) : 1);\n}",
          "fn_code_pos": [
            [
              157,
              0
            ],
            [
              170,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetCompressionScheme",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "const TIFFCodec*\nTIFFFindCODEC(uint16 scheme)\n{\n\tconst TIFFCodec* c;\n\tcodec_t* cd;\n\n\tfor (cd = registeredCODECS; cd; cd = cd->next)\n\t\tif (cd->info->scheme == scheme)\n\t\t\treturn ((const TIFFCodec*) cd->info);\n\tfor (c = _TIFFBuiltinCODECS; c->name; c++)\n\t\tif (c->scheme == scheme)\n\t\t\treturn (c);\n\treturn ((const TIFFCodec*) 0);\n}",
          "fn_code_pos": [
            [
              183,
              0
            ],
            [
              196,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFindCODEC",
            "parameters": {
              "scheme": "uint16"
            },
            "return_type": "TIFFCodec"
          }
        },
        {
          "fn_code": "TIFFCodec*\nTIFFRegisterCODEC(uint16 scheme, const char* name, TIFFInitMethod init)\n{\n\tcodec_t* cd = (codec_t*)\n\t    _TIFFmalloc((tmsize_t)(sizeof (codec_t) + sizeof (TIFFCodec) + strlen(name)+1));\n\n\tif (cd != NULL) {\n\t\tcd->info = (TIFFCodec*) ((uint8*) cd + sizeof (codec_t));\n\t\tcd->info->name = (char*)\n\t\t    ((uint8*) cd->info + sizeof (TIFFCodec));\n\t\tstrcpy(cd->info->name, name);\n\t\tcd->info->scheme = scheme;\n\t\tcd->info->init = init;\n\t\tcd->next = registeredCODECS;\n\t\tregisteredCODECS = cd;\n\t} else {\n\t\tTIFFErrorExt(0, \"TIFFRegisterCODEC\",\n\t\t    \"No space to register compression scheme %s\", name);\n\t\treturn NULL;\n\t}\n\treturn (cd->info);\n}",
          "fn_code_pos": [
            [
              198,
              0
            ],
            [
              219,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRegisterCODEC",
            "parameters": {
              "scheme": "uint16",
              "name": "char",
              "init": "TIFFInitMethod"
            },
            "return_type": "TIFFCodec"
          }
        },
        {
          "fn_code": "void\nTIFFUnRegisterCODEC(TIFFCodec* c)\n{\n\tcodec_t* cd;\n\tcodec_t** pcd;\n\n\tfor (pcd = &registeredCODECS; (cd = *pcd) != NULL; pcd = &cd->next)\n\t\tif (cd->info == c) {\n\t\t\t*pcd = cd->next;\n\t\t\t_TIFFfree(cd);\n\t\t\treturn;\n\t\t}\n\tTIFFErrorExt(0, \"TIFFUnRegisterCODEC\",\n\t    \"Cannot remove compression scheme %s; not registered\", c->name);\n}",
          "fn_code_pos": [
            [
              221,
              0
            ],
            [
              235,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFUnRegisterCODEC",
            "parameters": {
              "c": "TIFFCodec"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFCodec*\nTIFFGetConfiguredCODECs()\n{\n\tint i = 1;\n\tcodec_t *cd;\n\tconst TIFFCodec* c;\n\tTIFFCodec* codecs = NULL;\n\tTIFFCodec* new_codecs;\n\n\tfor (cd = registeredCODECS; cd; cd = cd->next) {\n\t\tnew_codecs = (TIFFCodec *)\n\t\t\t_TIFFrealloc(codecs, i * sizeof(TIFFCodec));\n\t\tif (!new_codecs) {\n\t\t\t_TIFFfree (codecs);\n\t\t\treturn NULL;\n\t\t}\n\t\tcodecs = new_codecs;\n\t\t_TIFFmemcpy(codecs + i - 1, cd, sizeof(TIFFCodec));\n\t\ti++;\n\t}\n\tfor (c = _TIFFBuiltinCODECS; c->name; c++) {\n\t\tif (TIFFIsCODECConfigured(c->scheme)) {\n\t\t\tnew_codecs = (TIFFCodec *)\n\t\t\t\t_TIFFrealloc(codecs, i * sizeof(TIFFCodec));\n\t\t\tif (!new_codecs) {\n\t\t\t\t_TIFFfree (codecs);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcodecs = new_codecs;\n\t\t\t_TIFFmemcpy(codecs + i - 1, (const void*)c, sizeof(TIFFCodec));\n\t\t\ti++;\n\t\t}\n\t}\n\n\tnew_codecs = (TIFFCodec *) _TIFFrealloc(codecs, i * sizeof(TIFFCodec));\n\tif (!new_codecs) {\n\t\t_TIFFfree (codecs);\n\t\treturn NULL;\n\t}\n\tcodecs = new_codecs;\n\t_TIFFmemset(codecs + i - 1, 0, sizeof(TIFFCodec));\n\n\treturn codecs;\n}",
          "fn_code_pos": [
            [
              249,
              0
            ],
            [
              292,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetConfiguredCODECs",
            "parameters": {},
            "return_type": "TIFFCodec"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFFindCODEC(uint16 scheme)",
          "fn_dec_pos": [
            [
              184,
              0
            ],
            [
              184,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFindCODEC",
            "parameters": {
              "scheme": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFRegisterCODEC(uint16 scheme, const char* name, TIFFInitMethod init)",
          "fn_dec_pos": [
            [
              199,
              0
            ],
            [
              199,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRegisterCODEC",
            "parameters": {
              "scheme": "uint16",
              "name": "char",
              "init": "TIFFInitMethod"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFGetConfiguredCODECs()",
          "fn_dec_pos": [
            [
              250,
              0
            ],
            [
              250,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetConfiguredCODECs",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct _codec {\n\tstruct _codec* next;\n\tTIFFCodec* info;\n} codec_t;",
          {
            "* next": "struct _codec",
            "* info": "TIFFCodec"
          },
          "codec_t",
          [
            177,
            0
          ],
          [
            180,
            10
          ]
        ],
        [
          "typedef struct _codec {\n\tstruct _codec* next;\n\tTIFFCodec* info;\n} codec_t;",
          {
            "* next": "struct _codec",
            "* info": "TIFFCodec"
          },
          "codec_t",
          [
            177,
            0
          ],
          [
            180,
            10
          ]
        ],
        [
          "struct _codec",
          {},
          "",
          [
            178,
            1
          ],
          [
            178,
            14
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_warning.c": {
      "fn_def_list": [
        {
          "fn_code": "TIFFErrorHandler\nTIFFSetWarningHandler(TIFFErrorHandler handler)\n{\n\tTIFFErrorHandler prev = _TIFFwarningHandler;\n\t_TIFFwarningHandler = handler;\n\treturn (prev);\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              37,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetWarningHandler",
            "parameters": {
              "handler": "TIFFErrorHandler"
            },
            "return_type": "TIFFErrorHandler"
          }
        },
        {
          "fn_code": "TIFFErrorHandlerExt\nTIFFSetWarningHandlerExt(TIFFErrorHandlerExt handler)\n{\n\tTIFFErrorHandlerExt prev = _TIFFwarningHandlerExt;\n\t_TIFFwarningHandlerExt = handler;\n\treturn (prev);\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              45,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetWarningHandlerExt",
            "parameters": {
              "handler": "TIFFErrorHandlerExt"
            },
            "return_type": "TIFFErrorHandlerExt"
          }
        },
        {
          "fn_code": "void\nTIFFWarning(const char* module, const char* fmt, ...)\n{\n\tva_list ap;\n\tif (_TIFFwarningHandler) {\n\t\tva_start(ap, fmt);\n\t\t(*_TIFFwarningHandler)(module, fmt, ap);\n\t\tva_end(ap);\n\t}\n\tif (_TIFFwarningHandlerExt) {\n\t\tva_start(ap, fmt);\n\t\t(*_TIFFwarningHandlerExt)(0, module, fmt, ap);\n\t\tva_end(ap);\n\t}\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              61,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWarning",
            "parameters": {
              "module": "char",
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFWarningExt(thandle_t fd, const char* module, const char* fmt, ...)\n{\n\tva_list ap;\n\tif (_TIFFwarningHandler) {\n\t\tva_start(ap, fmt);\t\n\t\t(*_TIFFwarningHandler)(module, fmt, ap);\n\t\tva_end(ap);\n\t}\n\tif (_TIFFwarningHandlerExt) {\n\t\tva_start(ap, fmt);\n\t\t(*_TIFFwarningHandlerExt)(fd, module, fmt, ap);\n\t\tva_end(ap);\n\t}\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              77,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWarningExt",
            "parameters": {
              "fd": "thandle_t",
              "module": "char",
              "fmt": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_lzw.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nLZWFixupTags(TIFF* tif)\n{\n\t(void) tif;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              189,
              0
            ],
            [
              194,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZWFixupTags",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLZWSetupDecode(TIFF* tif)\n{\n\tstatic const char module[] = \"LZWSetupDecode\";\n\tLZWCodecState* sp = DecoderState(tif);\n\tint code;\n\n\tif( sp == NULL )\n\t{\n\t\t/*\n\t\t * Allocate state block so tag methods have storage to record\n\t\t * values.\n\t\t*/\n\t\ttif->tif_data = (uint8*) _TIFFmalloc(sizeof(LZWCodecState));\n\t\tif (tif->tif_data == NULL)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"No space for LZW state block\");\n\t\t\treturn (0);\n\t\t}\n\n\t\tDecoderState(tif)->dec_codetab = NULL;\n\t\tDecoderState(tif)->dec_decode = NULL;\n\n\t\t/*\n\t\t * Setup predictor setup.\n\t\t */\n\t\t(void) TIFFPredictorInit(tif);\n\n\t\tsp = DecoderState(tif);\n\t}\n\n\tassert(sp != NULL);\n\n\tif (sp->dec_codetab == NULL) {\n\t\tsp->dec_codetab = (code_t*)_TIFFmalloc(CSIZE*sizeof (code_t));\n\t\tif (sp->dec_codetab == NULL) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"No space for LZW code table\");\n\t\t\treturn (0);\n\t\t}\n\t\t/*\n\t\t * Pre-load the table.\n\t\t */\n\t\tcode = 255;\n\t\tdo {\n\t\t\tsp->dec_codetab[code].value = (unsigned char)code;\n\t\t\tsp->dec_codetab[code].firstchar = (unsigned char)code;\n\t\t\tsp->dec_codetab[code].length = 1;\n\t\t\tsp->dec_codetab[code].next = NULL;\n\t\t} while (code--);\n\t\t/*\n\t\t * Zero-out the unused entries\n                 */\n                 _TIFFmemset(&sp->dec_codetab[CODE_CLEAR], 0,\n\t\t\t     (CODE_FIRST - CODE_CLEAR) * sizeof (code_t));\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              196,
              0
            ],
            [
              253,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZWSetupDecode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLZWPreDecode(TIFF* tif, uint16 s)\n{\n\tstatic const char module[] = \"LZWPreDecode\";\n\tLZWCodecState *sp = DecoderState(tif);\n\n\t(void) s;\n\tassert(sp != NULL);\n\tif( sp->dec_codetab == NULL )\n        {\n            tif->tif_setupdecode( tif );\n\t    if( sp->dec_codetab == NULL )\n\t\treturn (0);\n        }\n\n\t/*\n\t * Check for old bit-reversed codes.\n\t */\n\tif (tif->tif_rawcc >= 2 &&\n\t    tif->tif_rawdata[0] == 0 && (tif->tif_rawdata[1] & 0x1)) {\n#ifdef LZW_COMPAT\n\t\tif (!sp->dec_decode) {\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t    \"Old-style LZW codes, convert file\");\n\t\t\t/*\n\t\t\t * Override default decoding methods with\n\t\t\t * ones that deal with the old coding.\n\t\t\t * Otherwise the predictor versions set\n\t\t\t * above will call the compatibility routines\n\t\t\t * through the dec_decode method.\n\t\t\t */\n\t\t\ttif->tif_decoderow = LZWDecodeCompat;\n\t\t\ttif->tif_decodestrip = LZWDecodeCompat;\n\t\t\ttif->tif_decodetile = LZWDecodeCompat;\n\t\t\t/*\n\t\t\t * If doing horizontal differencing, must\n\t\t\t * re-setup the predictor logic since we\n\t\t\t * switched the basic decoder methods...\n\t\t\t */\n\t\t\t(*tif->tif_setupdecode)(tif);\n\t\t\tsp->dec_decode = LZWDecodeCompat;\n\t\t}\n\t\tsp->lzw_maxcode = MAXCODE(BITS_MIN);\n#else /* !LZW_COMPAT */\n\t\tif (!sp->dec_decode) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Old-style LZW codes not supported\");\n\t\t\tsp->dec_decode = LZWDecode;\n\t\t}\n\t\treturn (0);\n#endif/* !LZW_COMPAT */\n\t} else {\n\t\tsp->lzw_maxcode = MAXCODE(BITS_MIN)-1;\n\t\tsp->dec_decode = LZWDecode;\n\t}\n\tsp->lzw_nbits = BITS_MIN;\n\tsp->lzw_nextbits = 0;\n\tsp->lzw_nextdata = 0;\n\n\tsp->dec_restart = 0;\n\tsp->dec_nbitsmask = MAXCODE(BITS_MIN);\n#ifdef LZW_CHECKEOS\n\tsp->dec_bitsleft = 0;\n        sp->old_tif_rawcc = 0;\n#endif\n\tsp->dec_free_entp = sp->dec_codetab + CODE_FIRST;\n\t/*\n\t * Zero entries that are not yet filled in.  We do\n\t * this to guard against bogus input data that causes\n\t * us to index into undefined entries.  If you can\n\t * come up with a way to safely bounds-check input codes\n\t * while decoding then you can remove this operation.\n\t */\n\t_TIFFmemset(sp->dec_free_entp, 0, (CSIZE-CODE_FIRST)*sizeof (code_t));\n\tsp->dec_oldcodep = &sp->dec_codetab[-1];\n\tsp->dec_maxcodep = &sp->dec_codetab[sp->dec_nbitsmask-1];\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              258,
              0
            ],
            [
              335,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZWPreDecode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ncodeLoop(TIFF* tif, const char* module)\n{\n\tTIFFErrorExt(tif->tif_clientdata, module,\n\t    \"Bogus encoding, loop in the code table; scanline %d\",\n\t    tif->tif_row);\n}",
          "fn_code_pos": [
            [
              351,
              0
            ],
            [
              357,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "codeLoop",
            "parameters": {
              "tif": "TIFF",
              "module": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nLZWDecode(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n{\n\tstatic const char module[] = \"LZWDecode\";\n\tLZWCodecState *sp = DecoderState(tif);\n\tchar *op = (char*) op0;\n\tlong occ = (long) occ0;\n\tchar *tp;\n\tunsigned char *bp;\n\thcode_t code;\n\tint len;\n\tlong nbits, nextbits, nbitsmask;\n        unsigned long nextdata;\n\tcode_t *codep, *free_entp, *maxcodep, *oldcodep;\n\n\t(void) s;\n\tassert(sp != NULL);\n        assert(sp->dec_codetab != NULL);\n\n\t/*\n\t  Fail if value does not fit in long.\n\t*/\n\tif ((tmsize_t) occ != occ0)\n\t        return (0);\n\t/*\n\t * Restart interrupted output operation.\n\t */\n\tif (sp->dec_restart) {\n\t\tlong residue;\n\n\t\tcodep = sp->dec_codep;\n\t\tresidue = codep->length - sp->dec_restart;\n\t\tif (residue > occ) {\n\t\t\t/*\n\t\t\t * Residue from previous decode is sufficient\n\t\t\t * to satisfy decode request.  Skip to the\n\t\t\t * start of the decoded string, place decoded\n\t\t\t * values in the output buffer, and return.\n\t\t\t */\n\t\t\tsp->dec_restart += occ;\n\t\t\tdo {\n\t\t\t\tcodep = codep->next;\n\t\t\t} while (--residue > occ && codep);\n\t\t\tif (codep) {\n\t\t\t\ttp = op + occ;\n\t\t\t\tdo {\n\t\t\t\t\t*--tp = codep->value;\n\t\t\t\t\tcodep = codep->next;\n\t\t\t\t} while (--occ && codep);\n\t\t\t}\n\t\t\treturn (1);\n\t\t}\n\t\t/*\n\t\t * Residue satisfies only part of the decode request.\n\t\t */\n\t\top += residue;\n\t\tocc -= residue;\n\t\ttp = op;\n\t\tdo {\n\t\t\tint t;\n\t\t\t--tp;\n\t\t\tt = codep->value;\n\t\t\tcodep = codep->next;\n\t\t\t*tp = (char)t;\n\t\t} while (--residue && codep);\n\t\tsp->dec_restart = 0;\n\t}\n\n\tbp = (unsigned char *)tif->tif_rawcp;\n#ifdef LZW_CHECKEOS\n\tsp->dec_bitsleft += (((uint64)tif->tif_rawcc - sp->old_tif_rawcc) << 3);\n#endif\n\tnbits = sp->lzw_nbits;\n\tnextdata = sp->lzw_nextdata;\n\tnextbits = sp->lzw_nextbits;\n\tnbitsmask = sp->dec_nbitsmask;\n\toldcodep = sp->dec_oldcodep;\n\tfree_entp = sp->dec_free_entp;\n\tmaxcodep = sp->dec_maxcodep;\n\n\twhile (occ > 0) {\n\t\tNextCode(tif, sp, bp, code, GetNextCode);\n\t\tif (code == CODE_EOI)\n\t\t\tbreak;\n\t\tif (code == CODE_CLEAR) {\n\t\t\tdo {\n\t\t\t\tfree_entp = sp->dec_codetab + CODE_FIRST;\n\t\t\t\t_TIFFmemset(free_entp, 0,\n\t\t\t\t\t    (CSIZE - CODE_FIRST) * sizeof (code_t));\n\t\t\t\tnbits = BITS_MIN;\n\t\t\t\tnbitsmask = MAXCODE(BITS_MIN);\n\t\t\t\tmaxcodep = sp->dec_codetab + nbitsmask-1;\n\t\t\t\tNextCode(tif, sp, bp, code, GetNextCode);\n\t\t\t} while (code == CODE_CLEAR);\t/* consecutive CODE_CLEAR codes */\n\t\t\tif (code == CODE_EOI)\n\t\t\t\tbreak;\n\t\t\tif (code > CODE_CLEAR) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t\"LZWDecode: Corrupted LZW table at scanline %d\",\n\t\t\t\t\t     tif->tif_row);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\t*op++ = (char)code;\n\t\t\tocc--;\n\t\t\toldcodep = sp->dec_codetab + code;\n\t\t\tcontinue;\n\t\t}\n\t\tcodep = sp->dec_codetab + code;\n\n\t\t/*\n\t\t * Add the new entry to the code table.\n\t\t */\n\t\tif (free_entp < &sp->dec_codetab[0] ||\n\t\t    free_entp >= &sp->dec_codetab[CSIZE]) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Corrupted LZW table at scanline %d\",\n\t\t\t    tif->tif_row);\n\t\t\treturn (0);\n\t\t}\n\n\t\tfree_entp->next = oldcodep;\n\t\tif (free_entp->next < &sp->dec_codetab[0] ||\n\t\t    free_entp->next >= &sp->dec_codetab[CSIZE]) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Corrupted LZW table at scanline %d\",\n\t\t\t    tif->tif_row);\n\t\t\treturn (0);\n\t\t}\n\t\tfree_entp->firstchar = free_entp->next->firstchar;\n\t\tfree_entp->length = free_entp->next->length+1;\n\t\tfree_entp->value = (codep < free_entp) ?\n\t\t    codep->firstchar : free_entp->firstchar;\n\t\tif (++free_entp > maxcodep) {\n\t\t\tif (++nbits > BITS_MAX)\t\t/* should not happen */\n\t\t\t\tnbits = BITS_MAX;\n\t\t\tnbitsmask = MAXCODE(nbits);\n\t\t\tmaxcodep = sp->dec_codetab + nbitsmask-1;\n\t\t}\n\t\toldcodep = codep;\n\t\tif (code >= 256) {\n\t\t\t/*\n\t\t\t * Code maps to a string, copy string\n\t\t\t * value to output (written in reverse).\n\t\t\t */\n\t\t\tif(codep->length == 0) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Wrong length of decoded string: \"\n\t\t\t\t    \"data probably corrupted at scanline %d\",\n\t\t\t\t    tif->tif_row);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (codep->length > occ) {\n\t\t\t\t/*\n\t\t\t\t * String is too long for decode buffer,\n\t\t\t\t * locate portion that will fit, copy to\n\t\t\t\t * the decode buffer, and setup restart\n\t\t\t\t * logic for the next decoding call.\n\t\t\t\t */\n\t\t\t\tsp->dec_codep = codep;\n\t\t\t\tdo {\n\t\t\t\t\tcodep = codep->next;\n\t\t\t\t} while (codep && codep->length > occ);\n\t\t\t\tif (codep) {\n\t\t\t\t\tsp->dec_restart = (long)occ;\n\t\t\t\t\ttp = op + occ;\n\t\t\t\t\tdo  {\n\t\t\t\t\t\t*--tp = codep->value;\n\t\t\t\t\t\tcodep = codep->next;\n\t\t\t\t\t}  while (--occ && codep);\n\t\t\t\t\tif (codep)\n\t\t\t\t\t\tcodeLoop(tif, module);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = codep->length;\n\t\t\ttp = op + len;\n\t\t\tdo {\n\t\t\t\tint t;\n\t\t\t\t--tp;\n\t\t\t\tt = codep->value;\n\t\t\t\tcodep = codep->next;\n\t\t\t\t*tp = (char)t;\n\t\t\t} while (codep && tp > op);\n\t\t\tif (codep) {\n\t\t\t    codeLoop(tif, module);\n\t\t\t    break;\n\t\t\t}\n\t\t\tassert(occ >= len);\n\t\t\top += len;\n\t\t\tocc -= len;\n\t\t} else {\n\t\t\t*op++ = (char)code;\n\t\t\tocc--;\n\t\t}\n\t}\n\n\ttif->tif_rawcc -= (tmsize_t)( (uint8*) bp - tif->tif_rawcp );\n\ttif->tif_rawcp = (uint8*) bp;\n#ifdef LZW_CHECKEOS\n\tsp->old_tif_rawcc = tif->tif_rawcc;\n#endif\n\tsp->lzw_nbits = (unsigned short) nbits;\n\tsp->lzw_nextdata = nextdata;\n\tsp->lzw_nextbits = nextbits;\n\tsp->dec_nbitsmask = nbitsmask;\n\tsp->dec_oldcodep = oldcodep;\n\tsp->dec_free_entp = free_entp;\n\tsp->dec_maxcodep = maxcodep;\n\n\tif (occ > 0) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Not enough data at scanline %d (short %I64d bytes)\",\n\t\t\t     tif->tif_row, (unsigned __int64) occ);\n#else\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Not enough data at scanline %d (short %llu bytes)\",\n\t\t\t     tif->tif_row, (unsigned long long) occ);\n#endif\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              359,
              0
            ],
            [
              581,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZWDecode",
            "parameters": {
              "tif": "TIFF",
              "op0": "uint8",
              "occ0": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLZWDecodeCompat(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n{\n\tstatic const char module[] = \"LZWDecodeCompat\";\n\tLZWCodecState *sp = DecoderState(tif);\n\tchar *op = (char*) op0;\n\tlong occ = (long) occ0;\n\tchar *tp;\n\tunsigned char *bp;\n\tint code, nbits;\n\tint len;\n\tlong nextbits, nextdata, nbitsmask;\n\tcode_t *codep, *free_entp, *maxcodep, *oldcodep;\n\n\t(void) s;\n\tassert(sp != NULL);\n\n\t/*\n\t  Fail if value does not fit in long.\n\t*/\n\tif ((tmsize_t) occ != occ0)\n\t        return (0);\n\n\t/*\n\t * Restart interrupted output operation.\n\t */\n\tif (sp->dec_restart) {\n\t\tlong residue;\n\n\t\tcodep = sp->dec_codep;\n\t\tresidue = codep->length - sp->dec_restart;\n\t\tif (residue > occ) {\n\t\t\t/*\n\t\t\t * Residue from previous decode is sufficient\n\t\t\t * to satisfy decode request.  Skip to the\n\t\t\t * start of the decoded string, place decoded\n\t\t\t * values in the output buffer, and return.\n\t\t\t */\n\t\t\tsp->dec_restart += occ;\n\t\t\tdo {\n\t\t\t\tcodep = codep->next;\n\t\t\t} while (--residue > occ);\n\t\t\ttp = op + occ;\n\t\t\tdo {\n\t\t\t\t*--tp = codep->value;\n\t\t\t\tcodep = codep->next;\n\t\t\t} while (--occ);\n\t\t\treturn (1);\n\t\t}\n\t\t/*\n\t\t * Residue satisfies only part of the decode request.\n\t\t */\n\t\top += residue;\n\t\tocc -= residue;\n\t\ttp = op;\n\t\tdo {\n\t\t\t*--tp = codep->value;\n\t\t\tcodep = codep->next;\n\t\t} while (--residue);\n\t\tsp->dec_restart = 0;\n\t}\n\n\tbp = (unsigned char *)tif->tif_rawcp;\n#ifdef LZW_CHECKEOS\n\tsp->dec_bitsleft += (((uint64)tif->tif_rawcc - sp->old_tif_rawcc) << 3);\n#endif\n\tnbits = sp->lzw_nbits;\n\tnextdata = sp->lzw_nextdata;\n\tnextbits = sp->lzw_nextbits;\n\tnbitsmask = sp->dec_nbitsmask;\n\toldcodep = sp->dec_oldcodep;\n\tfree_entp = sp->dec_free_entp;\n\tmaxcodep = sp->dec_maxcodep;\n\n\twhile (occ > 0) {\n\t\tNextCode(tif, sp, bp, code, GetNextCodeCompat);\n\t\tif (code == CODE_EOI)\n\t\t\tbreak;\n\t\tif (code == CODE_CLEAR) {\n\t\t\tdo {\n\t\t\t\tfree_entp = sp->dec_codetab + CODE_FIRST;\n\t\t\t\t_TIFFmemset(free_entp, 0,\n\t\t\t\t\t    (CSIZE - CODE_FIRST) * sizeof (code_t));\n\t\t\t\tnbits = BITS_MIN;\n\t\t\t\tnbitsmask = MAXCODE(BITS_MIN);\n\t\t\t\tmaxcodep = sp->dec_codetab + nbitsmask;\n\t\t\t\tNextCode(tif, sp, bp, code, GetNextCodeCompat);\n\t\t\t} while (code == CODE_CLEAR);\t/* consecutive CODE_CLEAR codes */\n\t\t\tif (code == CODE_EOI)\n\t\t\t\tbreak;\n\t\t\tif (code > CODE_CLEAR) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t\t\"LZWDecode: Corrupted LZW table at scanline %d\",\n\t\t\t\t\t     tif->tif_row);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\t*op++ = (char)code;\n\t\t\tocc--;\n\t\t\toldcodep = sp->dec_codetab + code;\n\t\t\tcontinue;\n\t\t}\n\t\tcodep = sp->dec_codetab + code;\n\n\t\t/*\n\t\t * Add the new entry to the code table.\n\t\t */\n\t\tif (free_entp < &sp->dec_codetab[0] ||\n\t\t    free_entp >= &sp->dec_codetab[CSIZE]) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Corrupted LZW table at scanline %d\", tif->tif_row);\n\t\t\treturn (0);\n\t\t}\n\n\t\tfree_entp->next = oldcodep;\n\t\tif (free_entp->next < &sp->dec_codetab[0] ||\n\t\t    free_entp->next >= &sp->dec_codetab[CSIZE]) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Corrupted LZW table at scanline %d\", tif->tif_row);\n\t\t\treturn (0);\n\t\t}\n\t\tfree_entp->firstchar = free_entp->next->firstchar;\n\t\tfree_entp->length = free_entp->next->length+1;\n\t\tfree_entp->value = (codep < free_entp) ?\n\t\t    codep->firstchar : free_entp->firstchar;\n\t\tif (++free_entp > maxcodep) {\n\t\t\tif (++nbits > BITS_MAX)\t\t/* should not happen */\n\t\t\t\tnbits = BITS_MAX;\n\t\t\tnbitsmask = MAXCODE(nbits);\n\t\t\tmaxcodep = sp->dec_codetab + nbitsmask;\n\t\t}\n\t\toldcodep = codep;\n\t\tif (code >= 256) {\n\t\t\t/*\n\t\t\t * Code maps to a string, copy string\n\t\t\t * value to output (written in reverse).\n\t\t\t */\n\t\t\tif(codep->length == 0) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Wrong length of decoded \"\n\t\t\t\t    \"string: data probably corrupted at scanline %d\",\n\t\t\t\t    tif->tif_row);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (codep->length > occ) {\n\t\t\t\t/*\n\t\t\t\t * String is too long for decode buffer,\n\t\t\t\t * locate portion that will fit, copy to\n\t\t\t\t * the decode buffer, and setup restart\n\t\t\t\t * logic for the next decoding call.\n\t\t\t\t */\n\t\t\t\tsp->dec_codep = codep;\n\t\t\t\tdo {\n\t\t\t\t\tcodep = codep->next;\n\t\t\t\t} while (codep->length > occ);\n\t\t\t\tsp->dec_restart = occ;\n\t\t\t\ttp = op + occ;\n\t\t\t\tdo  {\n\t\t\t\t\t*--tp = codep->value;\n\t\t\t\t\tcodep = codep->next;\n\t\t\t\t}  while (--occ);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen = codep->length;\n\t\t\ttp = op + len;\n\t\t\tdo {\n\t\t\t\tint t;\n\t\t\t\t--tp;\n\t\t\t\tt = codep->value;\n\t\t\t\tcodep = codep->next;\n\t\t\t\t*tp = (char)t;\n\t\t\t} while (codep && tp > op);\n\t\t\tassert(occ >= len);\n\t\t\top += len;\n\t\t\tocc -= len;\n\t\t} else {\n\t\t\t*op++ = (char)code;\n\t\t\tocc--;\n\t\t}\n\t}\n\n\ttif->tif_rawcc -= (tmsize_t)( (uint8*) bp - tif->tif_rawcp );\n\ttif->tif_rawcp = (uint8*) bp;\n#ifdef LZW_CHECKEOS\n\tsp->old_tif_rawcc = tif->tif_rawcc;\n#endif\n\tsp->lzw_nbits = (unsigned short)nbits;\n\tsp->lzw_nextdata = nextdata;\n\tsp->lzw_nextbits = nextbits;\n\tsp->dec_nbitsmask = nbitsmask;\n\tsp->dec_oldcodep = oldcodep;\n\tsp->dec_free_entp = free_entp;\n\tsp->dec_maxcodep = maxcodep;\n\n\tif (occ > 0) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Not enough data at scanline %d (short %I64d bytes)\",\n\t\t\t     tif->tif_row, (unsigned __int64) occ);\n#else\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"Not enough data at scanline %d (short %llu bytes)\",\n\t\t\t     tif->tif_row, (unsigned long long) occ);\n#endif\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              599,
              0
            ],
            [
              805,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZWDecodeCompat",
            "parameters": {
              "tif": "TIFF",
              "op0": "uint8",
              "occ0": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLZWSetupEncode(TIFF* tif)\n{\n\tstatic const char module[] = \"LZWSetupEncode\";\n\tLZWCodecState* sp = EncoderState(tif);\n\n\tassert(sp != NULL);\n\tsp->enc_hashtab = (hash_t*) _TIFFmalloc(HSIZE*sizeof (hash_t));\n\tif (sp->enc_hashtab == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"No space for LZW hash table\");\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              812,
              0
            ],
            [
              826,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZWSetupEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLZWPreEncode(TIFF* tif, uint16 s)\n{\n\tLZWCodecState *sp = EncoderState(tif);\n\n\t(void) s;\n\tassert(sp != NULL);\n\n\tif( sp->enc_hashtab == NULL )\n        {\n            tif->tif_setupencode( tif );\n        }\n\n\tsp->lzw_nbits = BITS_MIN;\n\tsp->lzw_maxcode = MAXCODE(BITS_MIN);\n\tsp->lzw_free_ent = CODE_FIRST;\n\tsp->lzw_nextbits = 0;\n\tsp->lzw_nextdata = 0;\n\tsp->enc_checkpoint = CHECK_GAP;\n\tsp->enc_ratio = 0;\n\tsp->enc_incount = 0;\n\tsp->enc_outcount = 0;\n\t/*\n\t * The 4 here insures there is space for 2 max-sized\n\t * codes in LZWEncode and LZWPostDecode.\n\t */\n\tsp->enc_rawlimit = tif->tif_rawdata + tif->tif_rawdatasize-1 - 4;\n\tcl_hash(sp);\t\t/* clear hash table */\n\tsp->enc_oldcode = (hcode_t) -1;\t/* generates CODE_CLEAR in LZWEncode */\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              831,
              0
            ],
            [
              861,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZWPreEncode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLZWEncode(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\tregister LZWCodecState *sp = EncoderState(tif);\n\tregister long fcode;\n\tregister hash_t *hp;\n\tregister int h, c;\n\thcode_t ent;\n\tlong disp;\n\tlong incount, outcount, checkpoint;\n\tunsigned long nextdata;\n        long nextbits;\n\tint free_ent, maxcode, nbits;\n\tuint8* op;\n\tuint8* limit;\n\n\t(void) s;\n\tif (sp == NULL)\n\t\treturn (0);\n\n        assert(sp->enc_hashtab != NULL);\n\n\t/*\n\t * Load local state.\n\t */\n\tincount = sp->enc_incount;\n\toutcount = sp->enc_outcount;\n\tcheckpoint = sp->enc_checkpoint;\n\tnextdata = sp->lzw_nextdata;\n\tnextbits = sp->lzw_nextbits;\n\tfree_ent = sp->lzw_free_ent;\n\tmaxcode = sp->lzw_maxcode;\n\tnbits = sp->lzw_nbits;\n\top = tif->tif_rawcp;\n\tlimit = sp->enc_rawlimit;\n\tent = (hcode_t)sp->enc_oldcode;\n\n\tif (ent == (hcode_t) -1 && cc > 0) {\n\t\t/*\n\t\t * NB: This is safe because it can only happen\n\t\t *     at the start of a strip where we know there\n\t\t *     is space in the data buffer.\n\t\t */\n\t\tPutNextCode(op, CODE_CLEAR);\n\t\tent = *bp++; cc--; incount++;\n\t}\n\twhile (cc > 0) {\n\t\tc = *bp++; cc--; incount++;\n\t\tfcode = ((long)c << BITS_MAX) + ent;\n\t\th = (c << HSHIFT) ^ ent;\t/* xor hashing */\n#ifdef _WINDOWS\n\t\t/*\n\t\t * Check hash index for an overflow.\n\t\t */\n\t\tif (h >= HSIZE)\n\t\t\th -= HSIZE;\n#endif\n\t\thp = &sp->enc_hashtab[h];\n\t\tif (hp->hash == fcode) {\n\t\t\tent = hp->code;\n\t\t\tcontinue;\n\t\t}\n\t\tif (hp->hash >= 0) {\n\t\t\t/*\n\t\t\t * Primary hash failed, check secondary hash.\n\t\t\t */\n\t\t\tdisp = HSIZE - h;\n\t\t\tif (h == 0)\n\t\t\t\tdisp = 1;\n\t\t\tdo {\n\t\t\t\t/*\n\t\t\t\t * Avoid pointer arithmetic because of\n\t\t\t\t * wraparound problems with segments.\n\t\t\t\t */\n\t\t\t\tif ((h -= disp) < 0)\n\t\t\t\t\th += HSIZE;\n\t\t\t\thp = &sp->enc_hashtab[h];\n\t\t\t\tif (hp->hash == fcode) {\n\t\t\t\t\tent = hp->code;\n\t\t\t\t\tgoto hit;\n\t\t\t\t}\n\t\t\t} while (hp->hash >= 0);\n\t\t}\n\t\t/*\n\t\t * New entry, emit code and add to table.\n\t\t */\n\t\t/*\n\t\t * Verify there is space in the buffer for the code\n\t\t * and any potential Clear code that might be emitted\n\t\t * below.  The value of limit is setup so that there\n\t\t * are at least 4 bytes free--room for 2 codes.\n\t\t */\n\t\tif (op > limit) {\n\t\t\ttif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata);\n\t\t\tif( !TIFFFlushData1(tif) )\n                            return 0;\n\t\t\top = tif->tif_rawdata;\n\t\t}\n\t\tPutNextCode(op, ent);\n\t\tent = (hcode_t)c;\n\t\thp->code = (hcode_t)(free_ent++);\n\t\thp->hash = fcode;\n\t\tif (free_ent == CODE_MAX-1) {\n\t\t\t/* table is full, emit clear code and reset */\n\t\t\tcl_hash(sp);\n\t\t\tsp->enc_ratio = 0;\n\t\t\tincount = 0;\n\t\t\toutcount = 0;\n\t\t\tfree_ent = CODE_FIRST;\n\t\t\tPutNextCode(op, CODE_CLEAR);\n\t\t\tnbits = BITS_MIN;\n\t\t\tmaxcode = MAXCODE(BITS_MIN);\n\t\t} else {\n\t\t\t/*\n\t\t\t * If the next entry is going to be too big for\n\t\t\t * the code size, then increase it, if possible.\n\t\t\t */\n\t\t\tif (free_ent > maxcode) {\n\t\t\t\tnbits++;\n\t\t\t\tassert(nbits <= BITS_MAX);\n\t\t\t\tmaxcode = (int) MAXCODE(nbits);\n\t\t\t} else if (incount >= checkpoint) {\n\t\t\t\tlong rat;\n\t\t\t\t/*\n\t\t\t\t * Check compression ratio and, if things seem\n\t\t\t\t * to be slipping, clear the hash table and\n\t\t\t\t * reset state.  The compression ratio is a\n\t\t\t\t * 24+8-bit fractional number.\n\t\t\t\t */\n\t\t\t\tcheckpoint = incount+CHECK_GAP;\n\t\t\t\tCALCRATIO(sp, rat);\n\t\t\t\tif (rat <= sp->enc_ratio) {\n\t\t\t\t\tcl_hash(sp);\n\t\t\t\t\tsp->enc_ratio = 0;\n\t\t\t\t\tincount = 0;\n\t\t\t\t\toutcount = 0;\n\t\t\t\t\tfree_ent = CODE_FIRST;\n\t\t\t\t\tPutNextCode(op, CODE_CLEAR);\n\t\t\t\t\tnbits = BITS_MIN;\n\t\t\t\t\tmaxcode = MAXCODE(BITS_MIN);\n\t\t\t\t} else\n\t\t\t\t\tsp->enc_ratio = rat;\n\t\t\t}\n\t\t}\n\thit:\n\t\t;\n\t}\n\n\t/*\n\t * Restore global state.\n\t */\n\tsp->enc_incount = incount;\n\tsp->enc_outcount = outcount;\n\tsp->enc_checkpoint = checkpoint;\n\tsp->enc_oldcode = ent;\n\tsp->lzw_nextdata = nextdata;\n\tsp->lzw_nextbits = nextbits;\n\tsp->lzw_free_ent = (unsigned short)free_ent;\n\tsp->lzw_maxcode = (unsigned short)maxcode;\n\tsp->lzw_nbits = (unsigned short)nbits;\n\ttif->tif_rawcp = op;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              898,
              0
            ],
            [
              1060,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZWEncode",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nLZWPostEncode(TIFF* tif)\n{\n\tregister LZWCodecState *sp = EncoderState(tif);\n\tuint8* op = tif->tif_rawcp;\n\tlong nextbits = sp->lzw_nextbits;\n\tunsigned long nextdata = sp->lzw_nextdata;\n\tlong outcount = sp->enc_outcount;\n\tint nbits = sp->lzw_nbits;\n\n\tif (op > sp->enc_rawlimit) {\n\t\ttif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata);\n\t\tif( !TIFFFlushData1(tif) )\n                    return 0;\n\t\top = tif->tif_rawdata;\n\t}\n\tif (sp->enc_oldcode != (hcode_t) -1) {\n                int free_ent = sp->lzw_free_ent;\n\n\t\tPutNextCode(op, sp->enc_oldcode);\n\t\tsp->enc_oldcode = (hcode_t) -1;\n                free_ent ++;\n\n                if (free_ent == CODE_MAX-1) {\n                        /* table is full, emit clear code and reset */\n                        outcount = 0;\n                        PutNextCode(op, CODE_CLEAR);\n                        nbits = BITS_MIN;\n                } else {\n                        /*\n                        * If the next entry is going to be too big for\n                        * the code size, then increase it, if possible.\n                        */\n                        if (free_ent > sp->lzw_maxcode) {\n                                nbits++;\n                                assert(nbits <= BITS_MAX);\n                        }\n                }\n\t}\n\tPutNextCode(op, CODE_EOI);\n        /* Explicit 0xff masking to make icc -check=conversions happy */\n\tif (nextbits > 0) \n\t\t*op++ = (unsigned char)((nextdata << (8-nextbits))&0xff);\n\ttif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              1066,
              0
            ],
            [
              1111,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZWPostEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ncl_hash(LZWCodecState* sp)\n{\n\tregister hash_t *hp = &sp->enc_hashtab[HSIZE-1];\n\tregister long i = HSIZE-8;\n\n\tdo {\n\t\ti -= 8;\n\t\thp[-7].hash = -1;\n\t\thp[-6].hash = -1;\n\t\thp[-5].hash = -1;\n\t\thp[-4].hash = -1;\n\t\thp[-3].hash = -1;\n\t\thp[-2].hash = -1;\n\t\thp[-1].hash = -1;\n\t\thp[ 0].hash = -1;\n\t\thp -= 8;\n\t} while (i >= 0);\n\tfor (i += 8; i > 0; i--, hp--)\n\t\thp->hash = -1;\n}",
          "fn_code_pos": [
            [
              1116,
              0
            ],
            [
              1136,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cl_hash",
            "parameters": {
              "sp": "LZWCodecState"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nLZWCleanup(TIFF* tif)\n{\n\t(void)TIFFPredictorCleanup(tif);\n\n\tassert(tif->tif_data != 0);\n\n\tif (DecoderState(tif)->dec_codetab)\n\t\t_TIFFfree(DecoderState(tif)->dec_codetab);\n\n\tif (EncoderState(tif)->enc_hashtab)\n\t\t_TIFFfree(EncoderState(tif)->enc_hashtab);\n\n\t_TIFFfree(tif->tif_data);\n\ttif->tif_data = NULL;\n\n\t_TIFFSetDefaultCompressionState(tif);\n}",
          "fn_code_pos": [
            [
              1138,
              0
            ],
            [
              1155,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZWCleanup",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\nTIFFInitLZW(TIFF* tif, int scheme)\n{\n\tstatic const char module[] = \"TIFFInitLZW\";\n\tassert(scheme == COMPRESSION_LZW);\n\t/*\n\t * Allocate state block so tag methods have storage to record values.\n\t */\n\ttif->tif_data = (uint8*) _TIFFmalloc(sizeof (LZWCodecState));\n\tif (tif->tif_data == NULL)\n\t\tgoto bad;\n\tDecoderState(tif)->dec_codetab = NULL;\n\tDecoderState(tif)->dec_decode = NULL;\n\tEncoderState(tif)->enc_hashtab = NULL;\n        LZWState(tif)->rw_mode = tif->tif_mode;\n\n\t/*\n\t * Install codec methods.\n\t */\n\ttif->tif_fixuptags = LZWFixupTags; \n\ttif->tif_setupdecode = LZWSetupDecode;\n\ttif->tif_predecode = LZWPreDecode;\n\ttif->tif_decoderow = LZWDecode;\n\ttif->tif_decodestrip = LZWDecode;\n\ttif->tif_decodetile = LZWDecode;\n\ttif->tif_setupencode = LZWSetupEncode;\n\ttif->tif_preencode = LZWPreEncode;\n\ttif->tif_postencode = LZWPostEncode;\n\ttif->tif_encoderow = LZWEncode;\n\ttif->tif_encodestrip = LZWEncode;\n\ttif->tif_encodetile = LZWEncode;\n\ttif->tif_cleanup = LZWCleanup;\n\t/*\n\t * Setup predictor setup.\n\t */\n\t(void) TIFFPredictorInit(tif);\n\treturn (1);\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, module, \n\t\t     \"No space for LZW state block\");\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              1157,
              0
            ],
            [
              1198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitLZW",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "(*decodeFunc)(TIFF*, uint8*, tmsize_t, uint16)",
          "fn_dec_pos": [
            [
              125,
              12
            ],
            [
              125,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "LZWDecode(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)",
          "fn_dec_pos": [
            [
              159,
              11
            ],
            [
              159,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZWDecode",
            "parameters": {
              "tif": "TIFF",
              "op0": "uint8",
              "occ0": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "LZWDecodeCompat(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)",
          "fn_dec_pos": [
            [
              161,
              11
            ],
            [
              161,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LZWDecodeCompat",
            "parameters": {
              "tif": "TIFF",
              "op0": "uint8",
              "occ0": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "cl_hash(LZWCodecState*)",
          "fn_dec_pos": [
            [
              163,
              12
            ],
            [
              163,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cl_hash",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\tTIFFPredictorState predict;     /* predictor super class */\n\n\tunsigned short  nbits;          /* # of bits/code */\n\tunsigned short  maxcode;        /* maximum code for lzw_nbits */\n\tunsigned short  free_ent;       /* next free entry in hash table */\n\tunsigned long   nextdata;       /* next bits of i/o */\n\tlong            nextbits;       /* # of valid bits in lzw_nextdata */\n\n\tint             rw_mode;        /* preserve rw_mode from init */\n} LZWBaseState;",
          {
            "predict": "TIFFPredictorState",
            "nbits": "unsigned short",
            "maxcode": "unsigned short",
            "free_ent": "unsigned short",
            "nextdata": "unsigned long",
            "nextbits": "long",
            "rw_mode": "int"
          },
          "LZWBaseState",
          [
            88,
            0
          ],
          [
            98,
            15
          ]
        ],
        [
          "typedef struct {\n\tlong\thash;\n\thcode_t\tcode;\n} hash_t;",
          {
            "hash": "long",
            "code": "hcode_t"
          },
          "hash_t",
          [
            110,
            0
          ],
          [
            113,
            9
          ]
        ],
        [
          "typedef struct code_ent {\n\tstruct code_ent *next;\n\tunsigned short\tlength;\t\t/* string len, including this token */\n\tunsigned char\tvalue;\t\t/* data value */\n\tunsigned char\tfirstchar;\t/* first token of string */\n} code_t;",
          {
            "*next": "struct code_ent",
            "length": "unsigned short",
            "value": "unsigned char",
            "firstchar": "unsigned char"
          },
          "code_t",
          [
            118,
            0
          ],
          [
            123,
            9
          ]
        ],
        [
          "typedef struct {\n\tLZWBaseState base;\n\n\t/* Decoding specific data */\n\tlong    dec_nbitsmask;\t\t/* lzw_nbits 1 bits, right adjusted */\n\tlong    dec_restart;\t\t/* restart count */\n#ifdef LZW_CHECKEOS\n\tuint64  dec_bitsleft;\t\t/* available bits in raw data */\n\ttmsize_t old_tif_rawcc;         /* value of tif_rawcc at the end of the previous TIFLZWDecode() call */\n#endif\n\tdecodeFunc dec_decode;\t\t/* regular or backwards compatible */\n\tcode_t* dec_codep;\t\t/* current recognized code */\n\tcode_t* dec_oldcodep;\t\t/* previously recognized code */\n\tcode_t* dec_free_entp;\t\t/* next free entry */\n\tcode_t* dec_maxcodep;\t\t/* max available entry */\n\tcode_t* dec_codetab;\t\t/* kept separate for small machines */\n\n\t/* Encoding specific data */\n\tint     enc_oldcode;\t\t/* last code encountered */\n\tlong    enc_checkpoint;\t\t/* point at which to clear table */\n#define CHECK_GAP\t10000\t\t/* enc_ratio check interval */\n\tlong    enc_ratio;\t\t/* current compression ratio */\n\tlong    enc_incount;\t\t/* (input) data bytes encoded */\n\tlong    enc_outcount;\t\t/* encoded (output) bytes */\n\tuint8*  enc_rawlimit;\t\t/* bound on tif_rawdata buffer */\n\thash_t* enc_hashtab;\t\t/* kept separate for small machines */\n} LZWCodecState;",
          {
            "base": "LZWBaseState",
            "dec_nbitsmask": "long",
            "dec_restart": "long",
            "dec_bitsleft": "uint64",
            "old_tif_rawcc": "tmsize_t",
            "dec_decode": "decodeFunc",
            "* dec_codep": "code_t",
            "* dec_oldcodep": "code_t",
            "* dec_free_entp": "code_t",
            "* dec_maxcodep": "code_t",
            "* dec_codetab": "code_t",
            "enc_oldcode": "int",
            "enc_checkpoint": "long",
            "enc_ratio": "long",
            "enc_incount": "long",
            "enc_outcount": "long",
            "*  enc_rawlimit": "uint8",
            "* enc_hashtab": "hash_t"
          },
          "LZWCodecState",
          [
            127,
            0
          ],
          [
            153,
            16
          ]
        ],
        [
          "typedef struct {\n\tTIFFPredictorState predict;     /* predictor super class */\n\n\tunsigned short  nbits;          /* # of bits/code */\n\tunsigned short  maxcode;        /* maximum code for lzw_nbits */\n\tunsigned short  free_ent;       /* next free entry in hash table */\n\tunsigned long   nextdata;       /* next bits of i/o */\n\tlong            nextbits;       /* # of valid bits in lzw_nextdata */\n\n\tint             rw_mode;        /* preserve rw_mode from init */\n} LZWBaseState;",
          {
            "predict": "TIFFPredictorState",
            "nbits": "unsigned short",
            "maxcode": "unsigned short",
            "free_ent": "unsigned short",
            "nextdata": "unsigned long",
            "nextbits": "long",
            "rw_mode": "int"
          },
          "LZWBaseState",
          [
            88,
            0
          ],
          [
            98,
            15
          ]
        ],
        [
          "typedef struct {\n\tlong\thash;\n\thcode_t\tcode;\n} hash_t;",
          {
            "hash": "long",
            "code": "hcode_t"
          },
          "hash_t",
          [
            110,
            0
          ],
          [
            113,
            9
          ]
        ],
        [
          "typedef struct code_ent {\n\tstruct code_ent *next;\n\tunsigned short\tlength;\t\t/* string len, including this token */\n\tunsigned char\tvalue;\t\t/* data value */\n\tunsigned char\tfirstchar;\t/* first token of string */\n} code_t;",
          {
            "*next": "struct code_ent",
            "length": "unsigned short",
            "value": "unsigned char",
            "firstchar": "unsigned char"
          },
          "code_t",
          [
            118,
            0
          ],
          [
            123,
            9
          ]
        ],
        [
          "struct code_ent",
          {},
          "",
          [
            119,
            1
          ],
          [
            119,
            16
          ]
        ],
        [
          "typedef struct {\n\tLZWBaseState base;\n\n\t/* Decoding specific data */\n\tlong    dec_nbitsmask;\t\t/* lzw_nbits 1 bits, right adjusted */\n\tlong    dec_restart;\t\t/* restart count */\n#ifdef LZW_CHECKEOS\n\tuint64  dec_bitsleft;\t\t/* available bits in raw data */\n\ttmsize_t old_tif_rawcc;         /* value of tif_rawcc at the end of the previous TIFLZWDecode() call */\n#endif\n\tdecodeFunc dec_decode;\t\t/* regular or backwards compatible */\n\tcode_t* dec_codep;\t\t/* current recognized code */\n\tcode_t* dec_oldcodep;\t\t/* previously recognized code */\n\tcode_t* dec_free_entp;\t\t/* next free entry */\n\tcode_t* dec_maxcodep;\t\t/* max available entry */\n\tcode_t* dec_codetab;\t\t/* kept separate for small machines */\n\n\t/* Encoding specific data */\n\tint     enc_oldcode;\t\t/* last code encountered */\n\tlong    enc_checkpoint;\t\t/* point at which to clear table */\n#define CHECK_GAP\t10000\t\t/* enc_ratio check interval */\n\tlong    enc_ratio;\t\t/* current compression ratio */\n\tlong    enc_incount;\t\t/* (input) data bytes encoded */\n\tlong    enc_outcount;\t\t/* encoded (output) bytes */\n\tuint8*  enc_rawlimit;\t\t/* bound on tif_rawdata buffer */\n\thash_t* enc_hashtab;\t\t/* kept separate for small machines */\n} LZWCodecState;",
          {
            "base": "LZWBaseState",
            "dec_nbitsmask": "long",
            "dec_restart": "long",
            "dec_bitsleft": "uint64",
            "old_tif_rawcc": "tmsize_t",
            "dec_decode": "decodeFunc",
            "* dec_codep": "code_t",
            "* dec_oldcodep": "code_t",
            "* dec_free_entp": "code_t",
            "* dec_maxcodep": "code_t",
            "* dec_codetab": "code_t",
            "enc_oldcode": "int",
            "enc_checkpoint": "long",
            "enc_ratio": "long",
            "enc_incount": "long",
            "enc_outcount": "long",
            "*  enc_rawlimit": "uint8",
            "* enc_hashtab": "hash_t"
          },
          "LZWCodecState",
          [
            127,
            0
          ],
          [
            153,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include \"tif_predict.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_jpeg_12.c": {
      "fn_def_list": [
        {
          "fn_code": "int TIFFReInitJPEG_12( TIFF *tif, int scheme, int is_encode )\n\n{\n    JPEGState* sp;\n\n    assert(scheme == COMPRESSION_JPEG);\n\n    sp = JState(tif);\n    sp->tif = tif;\t\t\t\t/* back link */\n\n    /*\n     * Override parent get/set field methods.\n     */\n    tif->tif_tagmethods.vgetfield = JPEGVGetField; /* hook for codec tags */\n    tif->tif_tagmethods.vsetfield = JPEGVSetField; /* hook for codec tags */\n    tif->tif_tagmethods.printdir = JPEGPrintDir;   /* hook for codec tags */\n\n    /*\n     * Install codec methods.\n     */\n    tif->tif_fixuptags = JPEGFixupTags;\n    tif->tif_setupdecode = JPEGSetupDecode;\n    tif->tif_predecode = JPEGPreDecode;\n    tif->tif_decoderow = JPEGDecode;\n    tif->tif_decodestrip = JPEGDecode;\n    tif->tif_decodetile = JPEGDecode;\n    tif->tif_setupencode = JPEGSetupEncode;\n    tif->tif_preencode = JPEGPreEncode;\n    tif->tif_postencode = JPEGPostEncode;\n    tif->tif_encoderow = JPEGEncode;\n    tif->tif_encodestrip = JPEGEncode;\n    tif->tif_encodetile = JPEGEncode;  \n    tif->tif_cleanup = JPEGCleanup;\n    tif->tif_defstripsize = JPEGDefaultStripSize;\n    tif->tif_deftilesize = JPEGDefaultTileSize;\n    tif->tif_flags |= TIFF_NOBITREV;\t/* no bit reversal, please */\n\n    sp->cinfo_initialized = FALSE;\n\n    if( is_encode )\n        return JPEGSetupEncode(tif);\n    else\n        return JPEGSetupDecode(tif);\n}",
          "fn_code_pos": [
            [
              15,
              0
            ],
            [
              58,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReInitJPEG_12",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int",
              "is_encode": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFInitJPEG_12(TIFF* tif, int scheme)",
          "fn_dec_pos": [
            [
              9,
              0
            ],
            [
              9,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitJPEG_12",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            1,
            0
          ],
          [
            2,
            0
          ]
        ],
        [
          "#  include LIBJPEG_12_PATH\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ],
        [
          "#  include \"tif_jpeg.c\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_flush.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nTIFFFlush(TIFF* tif)\n{\n    if( tif->tif_mode == O_RDONLY )\n        return 1;\n\n    if (!TIFFFlushData(tif))\n        return (0);\n                \n    /* In update (r+) mode we try to detect the case where \n       only the strip/tile map has been altered, and we try to \n       rewrite only that portion of the directory without \n       making any other changes */\n                \n    if( (tif->tif_flags & TIFF_DIRTYSTRIP)\n        && !(tif->tif_flags & TIFF_DIRTYDIRECT) \n        && tif->tif_mode == O_RDWR )\n    {\n        uint64  *offsets=NULL, *sizes=NULL;\n\n        if( TIFFIsTiled(tif) )\n        {\n            if( TIFFGetField( tif, TIFFTAG_TILEOFFSETS, &offsets ) \n                && TIFFGetField( tif, TIFFTAG_TILEBYTECOUNTS, &sizes ) \n                && _TIFFRewriteField( tif, TIFFTAG_TILEOFFSETS, TIFF_LONG8, \n                                      tif->tif_dir.td_nstrips, offsets )\n                && _TIFFRewriteField( tif, TIFFTAG_TILEBYTECOUNTS, TIFF_LONG8, \n                                      tif->tif_dir.td_nstrips, sizes ) )\n            {\n                tif->tif_flags &= ~TIFF_DIRTYSTRIP;\n                tif->tif_flags &= ~TIFF_BEENWRITING;\n                return 1;\n            }\n        }\n        else\n        {\n            if( TIFFGetField( tif, TIFFTAG_STRIPOFFSETS, &offsets ) \n                && TIFFGetField( tif, TIFFTAG_STRIPBYTECOUNTS, &sizes ) \n                && _TIFFRewriteField( tif, TIFFTAG_STRIPOFFSETS, TIFF_LONG8, \n                                      tif->tif_dir.td_nstrips, offsets )\n                && _TIFFRewriteField( tif, TIFFTAG_STRIPBYTECOUNTS, TIFF_LONG8, \n                                      tif->tif_dir.td_nstrips, sizes ) )\n            {\n                tif->tif_flags &= ~TIFF_DIRTYSTRIP;\n                tif->tif_flags &= ~TIFF_BEENWRITING;\n                return 1;\n            }\n        }\n    }\n\n    if ((tif->tif_flags & (TIFF_DIRTYDIRECT|TIFF_DIRTYSTRIP)) \n        && !TIFFRewriteDirectory(tif))\n        return (0);\n\n    return (1);\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              84,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFlush",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFFlushData(TIFF* tif)\n{\n\tif ((tif->tif_flags & TIFF_BEENWRITING) == 0)\n\t\treturn (1);\n\tif (tif->tif_flags & TIFF_POSTENCODE) {\n\t\ttif->tif_flags &= ~TIFF_POSTENCODE;\n\t\tif (!(*tif->tif_postencode)(tif))\n\t\t\treturn (0);\n\t}\n\treturn (TIFFFlushData1(tif));\n}",
          "fn_code_pos": [
            [
              95,
              0
            ],
            [
              106,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFlushData",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_swab.c": {
      "fn_def_list": [
        {
          "fn_code": "void\nTIFFSwabShort(uint16* wp)\n{\n\tregister unsigned char* cp = (unsigned char*) wp;\n\tunsigned char t;\n\tassert(sizeof(uint16)==2);\n\tt = cp[1]; cp[1] = cp[0]; cp[0] = t;\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              39,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabShort",
            "parameters": {
              "wp": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFSwabLong(uint32* lp)\n{\n\tregister unsigned char* cp = (unsigned char*) lp;\n\tunsigned char t;\n\tassert(sizeof(uint32)==4);\n\tt = cp[3]; cp[3] = cp[0]; cp[0] = t;\n\tt = cp[2]; cp[2] = cp[1]; cp[1] = t;\n}",
          "fn_code_pos": [
            [
              43,
              0
            ],
            [
              51,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabLong",
            "parameters": {
              "lp": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFSwabLong8(uint64* lp)\n{\n\tregister unsigned char* cp = (unsigned char*) lp;\n\tunsigned char t;\n\tassert(sizeof(uint64)==8);\n\tt = cp[7]; cp[7] = cp[0]; cp[0] = t;\n\tt = cp[6]; cp[6] = cp[1]; cp[1] = t;\n\tt = cp[5]; cp[5] = cp[2]; cp[2] = t;\n\tt = cp[4]; cp[4] = cp[3]; cp[3] = t;\n}",
          "fn_code_pos": [
            [
              55,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabLong8",
            "parameters": {
              "lp": "uint64"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFSwabArrayOfShort(register uint16* wp, tmsize_t n)\n{\n\tregister unsigned char* cp;\n\tregister unsigned char t;\n\tassert(sizeof(uint16)==2);\n\t/* XXX unroll loop some */\n\twhile (n-- > 0) {\n\t\tcp = (unsigned char*) wp;\n\t\tt = cp[1]; cp[1] = cp[0]; cp[0] = t;\n\t\twp++;\n\t}\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              81,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabArrayOfShort",
            "parameters": {
              "wp": "uint16",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFSwabArrayOfTriples(register uint8* tp, tmsize_t n)\n{\n\tunsigned char* cp;\n\tunsigned char t;\n\n\t/* XXX unroll loop some */\n\twhile (n-- > 0) {\n\t\tcp = (unsigned char*) tp;\n\t\tt = cp[2]; cp[2] = cp[0]; cp[0] = t;\n\t\ttp += 3;\n\t}\n}",
          "fn_code_pos": [
            [
              85,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabArrayOfTriples",
            "parameters": {
              "tp": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFSwabArrayOfLong(register uint32* lp, tmsize_t n)\n{\n\tregister unsigned char *cp;\n\tregister unsigned char t;\n\tassert(sizeof(uint32)==4);\n\t/* XXX unroll loop some */\n\twhile (n-- > 0) {\n\t\tcp = (unsigned char *)lp;\n\t\tt = cp[3]; cp[3] = cp[0]; cp[0] = t;\n\t\tt = cp[2]; cp[2] = cp[1]; cp[1] = t;\n\t\tlp++;\n\t}\n}",
          "fn_code_pos": [
            [
              101,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabArrayOfLong",
            "parameters": {
              "lp": "uint32",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFSwabArrayOfLong8(register uint64* lp, tmsize_t n)\n{\n\tregister unsigned char *cp;\n\tregister unsigned char t;\n\tassert(sizeof(uint64)==8);\n\t/* XXX unroll loop some */\n\twhile (n-- > 0) {\n\t\tcp = (unsigned char *)lp;\n\t\tt = cp[7]; cp[7] = cp[0]; cp[0] = t;\n\t\tt = cp[6]; cp[6] = cp[1]; cp[1] = t;\n\t\tt = cp[5]; cp[5] = cp[2]; cp[2] = t;\n\t\tt = cp[4]; cp[4] = cp[3]; cp[3] = t;\n\t\tlp++;\n\t}\n}",
          "fn_code_pos": [
            [
              118,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabArrayOfLong8",
            "parameters": {
              "lp": "uint64",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFSwabFloat(float* fp)\n{\n\tregister unsigned char* cp = (unsigned char*) fp;\n\tunsigned char t;\n\tassert(sizeof(float)==4);\n\tt = cp[3]; cp[3] = cp[0]; cp[0] = t;\n\tt = cp[2]; cp[2] = cp[1]; cp[1] = t;\n}",
          "fn_code_pos": [
            [
              137,
              0
            ],
            [
              145,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabFloat",
            "parameters": {
              "fp": "float"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFSwabArrayOfFloat(register float* fp, tmsize_t n)\n{\n\tregister unsigned char *cp;\n\tregister unsigned char t;\n\tassert(sizeof(float)==4);\n\t/* XXX unroll loop some */\n\twhile (n-- > 0) {\n\t\tcp = (unsigned char *)fp;\n\t\tt = cp[3]; cp[3] = cp[0]; cp[0] = t;\n\t\tt = cp[2]; cp[2] = cp[1]; cp[1] = t;\n\t\tfp++;\n\t}\n}",
          "fn_code_pos": [
            [
              149,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabArrayOfFloat",
            "parameters": {
              "fp": "float",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFSwabDouble(double *dp)\n{\n\tregister unsigned char* cp = (unsigned char*) dp;\n\tunsigned char t;\n\tassert(sizeof(double)==8);\n\tt = cp[7]; cp[7] = cp[0]; cp[0] = t;\n\tt = cp[6]; cp[6] = cp[1]; cp[1] = t;\n\tt = cp[5]; cp[5] = cp[2]; cp[2] = t;\n\tt = cp[4]; cp[4] = cp[3]; cp[3] = t;\n}",
          "fn_code_pos": [
            [
              166,
              0
            ],
            [
              176,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabDouble",
            "parameters": {
              "dp": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFSwabArrayOfDouble(double* dp, tmsize_t n)\n{\n\tregister unsigned char *cp;\n\tregister unsigned char t;\n\tassert(sizeof(double)==8);\n\t/* XXX unroll loop some */\n\twhile (n-- > 0) {\n\t\tcp = (unsigned char *)dp;\n\t\tt = cp[7]; cp[7] = cp[0]; cp[0] = t;\n\t\tt = cp[6]; cp[6] = cp[1]; cp[1] = t;\n\t\tt = cp[5]; cp[5] = cp[2]; cp[2] = t;\n\t\tt = cp[4]; cp[4] = cp[3]; cp[3] = t;\n\t\tdp++;\n\t}\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              195,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabArrayOfDouble",
            "parameters": {
              "dp": "double",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "const unsigned char*\nTIFFGetBitRevTable(int reversed)\n{\n\treturn (reversed ? TIFFBitRevTable : TIFFNoBitRevTable);\n}",
          "fn_code_pos": [
            [
              276,
              0
            ],
            [
              280,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetBitRevTable",
            "parameters": {
              "reversed": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void\nTIFFReverseBits(uint8* cp, tmsize_t n)  \n{\n\tfor (; n > 8; n -= 8) {\n\t\tcp[0] = TIFFBitRevTable[cp[0]];\n\t\tcp[1] = TIFFBitRevTable[cp[1]];\n\t\tcp[2] = TIFFBitRevTable[cp[2]];\n\t\tcp[3] = TIFFBitRevTable[cp[3]];\n\t\tcp[4] = TIFFBitRevTable[cp[4]];\n\t\tcp[5] = TIFFBitRevTable[cp[5]];\n\t\tcp[6] = TIFFBitRevTable[cp[6]];\n\t\tcp[7] = TIFFBitRevTable[cp[7]];\n\t\tcp += 8;\n\t}\n\twhile (n-- > 0) {\n\t\t*cp = TIFFBitRevTable[*cp];\n\t\tcp++;\n\t}\n}",
          "fn_code_pos": [
            [
              282,
              0
            ],
            [
              300,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReverseBits",
            "parameters": {
              "cp": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFGetBitRevTable(int reversed)",
          "fn_dec_pos": [
            [
              277,
              0
            ],
            [
              277,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetBitRevTable",
            "parameters": {
              "reversed": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_predict.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nPredictorSetup(TIFF* tif)\n{\n\tstatic const char module[] = \"PredictorSetup\";\n\n\tTIFFPredictorState* sp = PredictorState(tif);\n\tTIFFDirectory* td = &tif->tif_dir;\n\n\tswitch (sp->predictor)\t\t/* no differencing */\n\t{\n\t\tcase PREDICTOR_NONE:\n\t\t\treturn 1;\n\t\tcase PREDICTOR_HORIZONTAL:\n\t\t\tif (td->td_bitspersample != 8\n\t\t\t    && td->td_bitspersample != 16\n\t\t\t    && td->td_bitspersample != 32) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Horizontal differencing \\\"Predictor\\\" not supported with %d-bit samples\",\n\t\t\t\t    td->td_bitspersample);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PREDICTOR_FLOATINGPOINT:\n\t\t\tif (td->td_sampleformat != SAMPLEFORMAT_IEEEFP) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Floating point \\\"Predictor\\\" not supported with %d data format\",\n\t\t\t\t    td->td_sampleformat);\n\t\t\t\treturn 0;\n\t\t\t}\n                        if (td->td_bitspersample != 16\n                            && td->td_bitspersample != 24\n                            && td->td_bitspersample != 32\n                            && td->td_bitspersample != 64) { /* Should 64 be allowed? */\n                                TIFFErrorExt(tif->tif_clientdata, module,\n                                             \"Floating point \\\"Predictor\\\" not supported with %d-bit samples\",\n                                             td->td_bitspersample);\n\t\t\t\treturn 0;\n                            }\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"\\\"Predictor\\\" value %d not supported\",\n\t\t\t    sp->predictor);\n\t\t\treturn 0;\n\t}\n\tsp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?\n\t    td->td_samplesperpixel : 1);\n\t/*\n\t * Calculate the scanline/tile-width size in bytes.\n\t */\n\tif (isTiled(tif))\n\t\tsp->rowsize = TIFFTileRowSize(tif);\n\telse\n\t\tsp->rowsize = TIFFScanlineSize(tif);\n\tif (sp->rowsize == 0)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              109,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PredictorSetup",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPredictorSetupDecode(TIFF* tif)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\tTIFFDirectory* td = &tif->tif_dir;\n\n\t/* Note: when PredictorSetup() fails, the effets of setupdecode() */\n\t/* will not be \"cancelled\" so setupdecode() might be robust to */\n\t/* be called several times. */\n\tif (!(*sp->setupdecode)(tif) || !PredictorSetup(tif))\n\t\treturn 0;\n\n\tif (sp->predictor == 2) {\n\t\tswitch (td->td_bitspersample) {\n\t\t\tcase 8:  sp->decodepfunc = horAcc8; break;\n\t\t\tcase 16: sp->decodepfunc = horAcc16; break;\n\t\t\tcase 32: sp->decodepfunc = horAcc32; break;\n\t\t}\n\t\t/*\n\t\t * Override default decoding method with one that does the\n\t\t * predictor stuff.\n\t\t */\n                if( tif->tif_decoderow != PredictorDecodeRow )\n                {\n                    sp->decoderow = tif->tif_decoderow;\n                    tif->tif_decoderow = PredictorDecodeRow;\n                    sp->decodestrip = tif->tif_decodestrip;\n                    tif->tif_decodestrip = PredictorDecodeTile;\n                    sp->decodetile = tif->tif_decodetile;\n                    tif->tif_decodetile = PredictorDecodeTile;\n                }\n\n\t\t/*\n\t\t * If the data is horizontally differenced 16-bit data that\n\t\t * requires byte-swapping, then it must be byte swapped before\n\t\t * the accumulation step.  We do this with a special-purpose\n\t\t * routine and override the normal post decoding logic that\n\t\t * the library setup when the directory was read.\n\t\t */\n\t\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t\tif (sp->decodepfunc == horAcc16) {\n\t\t\t\tsp->decodepfunc = swabHorAcc16;\n\t\t\t\ttif->tif_postdecode = _TIFFNoPostDecode;\n            } else if (sp->decodepfunc == horAcc32) {\n\t\t\t\tsp->decodepfunc = swabHorAcc32;\n\t\t\t\ttif->tif_postdecode = _TIFFNoPostDecode;\n            }\n\t\t}\n\t}\n\n\telse if (sp->predictor == 3) {\n\t\tsp->decodepfunc = fpAcc;\n\t\t/*\n\t\t * Override default decoding method with one that does the\n\t\t * predictor stuff.\n\t\t */\n                if( tif->tif_decoderow != PredictorDecodeRow )\n                {\n                    sp->decoderow = tif->tif_decoderow;\n                    tif->tif_decoderow = PredictorDecodeRow;\n                    sp->decodestrip = tif->tif_decodestrip;\n                    tif->tif_decodestrip = PredictorDecodeTile;\n                    sp->decodetile = tif->tif_decodetile;\n                    tif->tif_decodetile = PredictorDecodeTile;\n                }\n\t\t/*\n\t\t * The data should not be swapped outside of the floating\n\t\t * point predictor, the accumulation routine should return\n\t\t * byres in the native order.\n\t\t */\n\t\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t\ttif->tif_postdecode = _TIFFNoPostDecode;\n\t\t}\n\t\t/*\n\t\t * Allocate buffer to keep the decoded bytes before\n\t\t * rearranging in the right order\n\t\t */\n\t}\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              111,
              0
            ],
            [
              191,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PredictorSetupDecode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPredictorSetupEncode(TIFF* tif)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\tTIFFDirectory* td = &tif->tif_dir;\n\n\tif (!(*sp->setupencode)(tif) || !PredictorSetup(tif))\n\t\treturn 0;\n\n\tif (sp->predictor == 2) {\n\t\tswitch (td->td_bitspersample) {\n\t\t\tcase 8:  sp->encodepfunc = horDiff8; break;\n\t\t\tcase 16: sp->encodepfunc = horDiff16; break;\n\t\t\tcase 32: sp->encodepfunc = horDiff32; break;\n\t\t}\n\t\t/*\n\t\t * Override default encoding method with one that does the\n\t\t * predictor stuff.\n\t\t */\n                if( tif->tif_encoderow != PredictorEncodeRow )\n                {\n                    sp->encoderow = tif->tif_encoderow;\n                    tif->tif_encoderow = PredictorEncodeRow;\n                    sp->encodestrip = tif->tif_encodestrip;\n                    tif->tif_encodestrip = PredictorEncodeTile;\n                    sp->encodetile = tif->tif_encodetile;\n                    tif->tif_encodetile = PredictorEncodeTile;\n                }\n\n                /*\n                 * If the data is horizontally differenced 16-bit data that\n                 * requires byte-swapping, then it must be byte swapped after\n                 * the differentiation step.  We do this with a special-purpose\n                 * routine and override the normal post decoding logic that\n                 * the library setup when the directory was read.\n                 */\n                if (tif->tif_flags & TIFF_SWAB) {\n                    if (sp->encodepfunc == horDiff16) {\n                            sp->encodepfunc = swabHorDiff16;\n                            tif->tif_postdecode = _TIFFNoPostDecode;\n                    } else if (sp->encodepfunc == horDiff32) {\n                            sp->encodepfunc = swabHorDiff32;\n                            tif->tif_postdecode = _TIFFNoPostDecode;\n                    }\n                }\n        }\n\n\telse if (sp->predictor == 3) {\n\t\tsp->encodepfunc = fpDiff;\n\t\t/*\n\t\t * Override default encoding method with one that does the\n\t\t * predictor stuff.\n\t\t */\n                if( tif->tif_encoderow != PredictorEncodeRow )\n                {\n                    sp->encoderow = tif->tif_encoderow;\n                    tif->tif_encoderow = PredictorEncodeRow;\n                    sp->encodestrip = tif->tif_encodestrip;\n                    tif->tif_encodestrip = PredictorEncodeTile;\n                    sp->encodetile = tif->tif_encodetile;\n                    tif->tif_encodetile = PredictorEncodeTile;\n                }\n\t}\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              193,
              0
            ],
            [
              258,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PredictorSetupEncode",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPredictorVSetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->vsetparent != NULL);\n\n\tswitch (tag) {\n\tcase TIFFTAG_PREDICTOR:\n\t\tsp->predictor = (uint16) va_arg(ap, uint16_vap);\n\t\tTIFFSetFieldBit(tif, FIELD_PREDICTOR);\n\t\tbreak;\n\tdefault:\n\t\treturn (*sp->vsetparent)(tif, tag, ap);\n\t}\n\ttif->tif_flags |= TIFF_DIRTYDIRECT;\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              757,
              0
            ],
            [
              775,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PredictorVSetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nPredictorVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->vgetparent != NULL);\n\n\tswitch (tag) {\n\tcase TIFFTAG_PREDICTOR:\n\t\t*va_arg(ap, uint16*) = (uint16)sp->predictor;\n\t\tbreak;\n\tdefault:\n\t\treturn (*sp->vgetparent)(tif, tag, ap);\n\t}\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              777,
              0
            ],
            [
              793,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PredictorVGetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nPredictorPrintDir(TIFF* tif, FILE* fd, long flags)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\n\t(void) flags;\n\tif (TIFFFieldSet(tif,FIELD_PREDICTOR)) {\n\t\tfprintf(fd, \"  Predictor: \");\n\t\tswitch (sp->predictor) {\n\t\t\tcase 1: fprintf(fd, \"none \"); break;\n\t\t\tcase 2: fprintf(fd, \"horizontal differencing \"); break;\n\t\t\tcase 3: fprintf(fd, \"floating point predictor \"); break;\n\t\t}\n\t\tfprintf(fd, \"%d (0x%x)\\n\", sp->predictor, sp->predictor);\n\t}\n\tif (sp->printdir)\n\t\t(*sp->printdir)(tif, fd, flags);\n}",
          "fn_code_pos": [
            [
              795,
              0
            ],
            [
              812,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PredictorPrintDir",
            "parameters": {
              "tif": "TIFF",
              "fd": "FILE",
              "flags": "long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\nTIFFPredictorInit(TIFF* tif)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\n\tassert(sp != 0);\n\n\t/*\n\t * Merge codec-specific tag information.\n\t */\n\tif (!_TIFFMergeFields(tif, predictFields,\n\t\t\t      TIFFArrayCount(predictFields))) {\n\t\tTIFFErrorExt(tif->tif_clientdata, \"TIFFPredictorInit\",\n\t\t    \"Merging Predictor codec-specific tags failed\");\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Override parent get/set field methods.\n\t */\n\tsp->vgetparent = tif->tif_tagmethods.vgetfield;\n\ttif->tif_tagmethods.vgetfield =\n            PredictorVGetField;/* hook for predictor tag */\n\tsp->vsetparent = tif->tif_tagmethods.vsetfield;\n\ttif->tif_tagmethods.vsetfield =\n\t    PredictorVSetField;/* hook for predictor tag */\n\tsp->printdir = tif->tif_tagmethods.printdir;\n\ttif->tif_tagmethods.printdir =\n            PredictorPrintDir;\t/* hook for predictor tag */\n\n\tsp->setupdecode = tif->tif_setupdecode;\n\ttif->tif_setupdecode = PredictorSetupDecode;\n\tsp->setupencode = tif->tif_setupencode;\n\ttif->tif_setupencode = PredictorSetupEncode;\n\n\tsp->predictor = 1;\t\t\t/* default value */\n\tsp->encodepfunc = NULL;\t\t\t/* no predictor routine */\n\tsp->decodepfunc = NULL;\t\t\t/* no predictor routine */\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              814,
              0
            ],
            [
              853,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFPredictorInit",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFPredictorCleanup(TIFF* tif)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\n\tassert(sp != 0);\n\n\ttif->tif_tagmethods.vgetfield = sp->vgetparent;\n\ttif->tif_tagmethods.vsetfield = sp->vsetparent;\n\ttif->tif_tagmethods.printdir = sp->printdir;\n\ttif->tif_setupdecode = sp->setupdecode;\n\ttif->tif_setupencode = sp->setupencode;\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              855,
              0
            ],
            [
              869,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFPredictorCleanup",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              34,
              11
            ],
            [
              34,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horAcc8",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              35,
              11
            ],
            [
              35,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horAcc16",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "horAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              36,
              11
            ],
            [
              36,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horAcc32",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "swabHorAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              37,
              11
            ],
            [
              37,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "swabHorAcc16",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "swabHorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              38,
              11
            ],
            [
              38,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "swabHorAcc32",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              39,
              11
            ],
            [
              39,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horDiff8",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              40,
              11
            ],
            [
              40,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horDiff16",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              41,
              11
            ],
            [
              41,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horDiff32",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              42,
              11
            ],
            [
              42,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "swabHorDiff16",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              43,
              11
            ],
            [
              43,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "swabHorDiff32",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              44,
              11
            ],
            [
              44,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fpAcc",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              45,
              11
            ],
            [
              45,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fpDiff",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "PredictorDecodeRow(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)",
          "fn_dec_pos": [
            [
              46,
              11
            ],
            [
              46,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PredictorDecodeRow",
            "parameters": {
              "tif": "TIFF",
              "op0": "uint8",
              "occ0": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)",
          "fn_dec_pos": [
            [
              47,
              11
            ],
            [
              47,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PredictorDecodeTile",
            "parameters": {
              "tif": "TIFF",
              "op0": "uint8",
              "occ0": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "PredictorEncodeRow(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              48,
              11
            ],
            [
              48,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PredictorEncodeRow",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s)",
          "fn_dec_pos": [
            [
              49,
              11
            ],
            [
              49,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PredictorEncodeTile",
            "parameters": {
              "tif": "TIFF",
              "bp0": "uint8",
              "cc0": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              279,
              0
            ],
            [
              279,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horAcc8",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "swabHorAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              336,
              0
            ],
            [
              336,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "swabHorAcc16",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              347,
              0
            ],
            [
              347,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horAcc16",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "swabHorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              371,
              0
            ],
            [
              371,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "swabHorAcc32",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "horAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              382,
              0
            ],
            [
              382,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horAcc32",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              409,
              0
            ],
            [
              409,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fpAcc",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PredictorDecodeRow(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)",
          "fn_dec_pos": [
            [
              456,
              0
            ],
            [
              456,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PredictorDecodeRow",
            "parameters": {
              "tif": "TIFF",
              "op0": "uint8",
              "occ0": "tmsize_t",
              "s": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)",
          "fn_dec_pos": [
            [
              478,
              0
            ],
            [
              478,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PredictorDecodeTile",
            "parameters": {
              "tif": "TIFF",
              "op0": "uint8",
              "occ0": "tmsize_t",
              "s": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              508,
              0
            ],
            [
              508,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horDiff8",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              562,
              0
            ],
            [
              562,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horDiff16",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              588,
              0
            ],
            [
              588,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "swabHorDiff16",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              602,
              0
            ],
            [
              602,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "horDiff32",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              628,
              0
            ],
            [
              628,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "swabHorDiff32",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)",
          "fn_dec_pos": [
            [
              645,
              0
            ],
            [
              645,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fpDiff",
            "parameters": {
              "tif": "TIFF",
              "cp0": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PredictorEncodeRow(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              687,
              0
            ],
            [
              687,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PredictorEncodeRow",
            "parameters": {
              "tif": "TIFF",
              "bp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s)",
          "fn_dec_pos": [
            [
              702,
              0
            ],
            [
              702,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PredictorEncodeTile",
            "parameters": {
              "tif": "TIFF",
              "bp0": "uint8",
              "cc0": "tmsize_t",
              "s": "uint16"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"tif_predict.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_next.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nNeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)\n{\n\tstatic const char module[] = \"NeXTDecode\";\n\tunsigned char *bp, *op;\n\ttmsize_t cc;\n\tuint8* row;\n\ttmsize_t scanline, n;\n\n\t(void) s;\n\t/*\n\t * Each scanline is assumed to start off as all\n\t * white (we assume a PhotometricInterpretation\n\t * of ``min-is-black'').\n\t */\n\tfor (op = (unsigned char*) buf, cc = occ; cc-- > 0;)\n\t\t*op++ = 0xff;\n\n\tbp = (unsigned char *)tif->tif_rawcp;\n\tcc = tif->tif_rawcc;\n\tscanline = tif->tif_scanlinesize;\n\tif (occ % scanline)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Fractional scanlines cannot be read\");\n\t\treturn (0);\n\t}\n\tfor (row = buf; cc > 0 && occ > 0; occ -= scanline, row += scanline) {\n\t\tn = *bp++;\n\t\tcc--;\n\t\tswitch (n) {\n\t\tcase LITERALROW:\n\t\t\t/*\n\t\t\t * The entire scanline is given as literal values.\n\t\t\t */\n\t\t\tif (cc < scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row, bp, scanline);\n\t\t\tbp += scanline;\n\t\t\tcc -= scanline;\n\t\t\tbreak;\n\t\tcase LITERALSPAN: {\n\t\t\ttmsize_t off;\n\t\t\t/*\n\t\t\t * The scanline has a literal span that begins at some\n\t\t\t * offset.\n\t\t\t */\n\t\t\tif( cc < 4 )\n\t\t\t\tgoto bad;\n\t\t\toff = (bp[0] * 256) + bp[1];\n\t\t\tn = (bp[2] * 256) + bp[3];\n\t\t\tif (cc < 4+n || off+n > scanline)\n\t\t\t\tgoto bad;\n\t\t\t_TIFFmemcpy(row+off, bp+4, n);\n\t\t\tbp += 4+n;\n\t\t\tcc -= 4+n;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tuint32 npixels = 0, grey;\n\t\t\ttmsize_t op_offset = 0;\n\t\t\tuint32 imagewidth = tif->tif_dir.td_imagewidth;\n            if( isTiled(tif) )\n                imagewidth = tif->tif_dir.td_tilewidth;\n\n\t\t\t/*\n\t\t\t * The scanline is composed of a sequence of constant\n\t\t\t * color ``runs''.  We shift into ``run mode'' and\n\t\t\t * interpret bytes as codes of the form\n\t\t\t * <color><npixels> until we've filled the scanline.\n\t\t\t */\n\t\t\top = row;\n\t\t\tfor (;;) {\n\t\t\t\tgrey = (uint32)((n>>6) & 0x3);\n\t\t\t\tn &= 0x3f;\n\t\t\t\t/*\n\t\t\t\t * Ensure the run does not exceed the scanline\n\t\t\t\t * bounds, potentially resulting in a security\n\t\t\t\t * issue.\n\t\t\t\t */\n\t\t\t\twhile (n-- > 0 && npixels < imagewidth && op_offset < scanline)\n\t\t\t\t\tSETPIXEL(op, grey);\n\t\t\t\tif (npixels >= imagewidth)\n\t\t\t\t\tbreak;\n                if (op_offset >= scanline ) {\n                    TIFFErrorExt(tif->tif_clientdata, module, \"Invalid data for scanline %ld\",\n                        (long) tif->tif_row);\n                    return (0);\n                }\n\t\t\t\tif (cc == 0)\n\t\t\t\t\tgoto bad;\n\t\t\t\tn = *bp++;\n\t\t\t\tcc--;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t}\n\ttif->tif_rawcp = (uint8*) bp;\n\ttif->tif_rawcc = cc;\n\treturn (1);\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, module, \"Not enough data for scanline %ld\",\n\t    (long) tif->tif_row);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              149,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NeXTDecode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "occ": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nNeXTPreDecode(TIFF* tif, uint16 s)\n{\n\tstatic const char module[] = \"NeXTPreDecode\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\t(void)s;\n\n\tif( td->td_bitspersample != 2 )\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Unsupported BitsPerSample = %d\",\n\t\t\t\t\t td->td_bitspersample);\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              151,
              0
            ],
            [
              165,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NeXTPreDecode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFInitNeXT(TIFF* tif, int scheme)\n{\n\t(void) scheme;\n\ttif->tif_predecode = NeXTPreDecode;  \n\ttif->tif_decoderow = NeXTDecode;  \n\ttif->tif_decodestrip = NeXTDecode;  \n\ttif->tif_decodetile = NeXTDecode;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              167,
              0
            ],
            [
              176,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitNeXT",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_win32.c": {
      "fn_def_list": [
        {
          "fn_code": "static tmsize_t\n_tiffReadProc(thandle_t fd, void* buf, tmsize_t size)\n{\n\t/* tmsize_t is 64bit on 64bit systems, but the WinAPI ReadFile takes\n\t * 32bit sizes, so we loop through the data in suitable 32bit sized\n\t * chunks */\n\tuint8* ma;\n\tuint64 mb;\n\tDWORD n;\n\tDWORD o;\n\ttmsize_t p;\n\tma=(uint8*)buf;\n\tmb=size;\n\tp=0;\n\twhile (mb>0)\n\t{\n\t\tn=0x80000000UL;\n\t\tif ((uint64)n>mb)\n\t\t\tn=(DWORD)mb;\n\t\tif (!ReadFile(fd,(LPVOID)ma,n,&o,NULL))\n\t\t\treturn(0);\n\t\tma+=o;\n\t\tmb-=o;\n\t\tp+=o;\n\t\tif (o!=n)\n\t\t\tbreak;\n\t}\n\treturn(p);\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              85,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffReadProc",
            "parameters": {
              "fd": "thandle_t",
              "buf": "void",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static tmsize_t\n_tiffWriteProc(thandle_t fd, void* buf, tmsize_t size)\n{\n\t/* tmsize_t is 64bit on 64bit systems, but the WinAPI WriteFile takes\n\t * 32bit sizes, so we loop through the data in suitable 32bit sized\n\t * chunks */\n\tuint8* ma;\n\tuint64 mb;\n\tDWORD n;\n\tDWORD o;\n\ttmsize_t p;\n\tma=(uint8*)buf;\n\tmb=size;\n\tp=0;\n\twhile (mb>0)\n\t{\n\t\tn=0x80000000UL;\n\t\tif ((uint64)n>mb)\n\t\t\tn=(DWORD)mb;\n\t\tif (!WriteFile(fd,(LPVOID)ma,n,&o,NULL))\n\t\t\treturn(0);\n\t\tma+=o;\n\t\tmb-=o;\n\t\tp+=o;\n\t\tif (o!=n)\n\t\t\tbreak;\n\t}\n\treturn(p);\n}",
          "fn_code_pos": [
            [
              87,
              0
            ],
            [
              115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffWriteProc",
            "parameters": {
              "fd": "thandle_t",
              "buf": "void",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static uint64\n_tiffSeekProc(thandle_t fd, uint64 off, int whence)\n{\n\tLARGE_INTEGER offli;\n\tDWORD dwMoveMethod;\n\toffli.QuadPart = off;\n\tswitch(whence)\n\t{\n\t\tcase SEEK_SET:\n\t\t\tdwMoveMethod = FILE_BEGIN;\n\t\t\tbreak;\n\t\tcase SEEK_CUR:\n\t\t\tdwMoveMethod = FILE_CURRENT;\n\t\t\tbreak;\n\t\tcase SEEK_END:\n\t\t\tdwMoveMethod = FILE_END;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdwMoveMethod = FILE_BEGIN;\n\t\t\tbreak;\n\t}\n\toffli.LowPart=SetFilePointer(fd,offli.LowPart,&offli.HighPart,dwMoveMethod);\n\tif ((offli.LowPart==INVALID_SET_FILE_POINTER)&&(GetLastError()!=NO_ERROR))\n\t\toffli.QuadPart=0;\n\treturn(offli.QuadPart);\n}",
          "fn_code_pos": [
            [
              117,
              0
            ],
            [
              142,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffSeekProc",
            "parameters": {
              "fd": "thandle_t",
              "off": "uint64",
              "whence": "int"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "static int\n_tiffCloseProc(thandle_t fd)\n{\n\treturn (CloseHandle(fd) ? 0 : -1);\n}",
          "fn_code_pos": [
            [
              144,
              0
            ],
            [
              148,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffCloseProc",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static uint64\n_tiffSizeProc(thandle_t fd)\n{\n\tULARGE_INTEGER m;\n\tm.LowPart=GetFileSize(fd,&m.HighPart);\n\treturn(m.QuadPart);\n}",
          "fn_code_pos": [
            [
              150,
              0
            ],
            [
              156,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffSizeProc",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "static int\n_tiffDummyMapProc(thandle_t fd, void** pbase, toff_t* psize)\n{\n\t(void) fd;\n\t(void) pbase;\n\t(void) psize;\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              158,
              0
            ],
            [
              165,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffDummyMapProc",
            "parameters": {
              "fd": "thandle_t",
              "pbase": "void",
              "psize": "toff_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\n_tiffMapProc(thandle_t fd, void** pbase, toff_t* psize)\n{\n\tuint64 size;\n\ttmsize_t sizem;\n\tHANDLE hMapFile;\n\n\tsize = _tiffSizeProc(fd);\n\tsizem = (tmsize_t)size;\n\tif ((uint64)sizem!=size)\n\t\treturn (0);\n\n\t/* By passing in 0 for the maximum file size, it specifies that we\n\t   create a file mapping object for the full file size. */\n\thMapFile = CreateFileMapping(fd, NULL, PAGE_READONLY, 0, 0, NULL);\n\tif (hMapFile == NULL)\n\t\treturn (0);\n\t*pbase = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);\n\tCloseHandle(hMapFile);\n\tif (*pbase == NULL)\n\t\treturn (0);\n\t*psize = size;\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              178,
              0
            ],
            [
              201,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffMapProc",
            "parameters": {
              "fd": "thandle_t",
              "pbase": "void",
              "psize": "toff_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\n_tiffDummyUnmapProc(thandle_t fd, void* base, toff_t size)\n{\n\t(void) fd;\n\t(void) base;\n\t(void) size;\n}",
          "fn_code_pos": [
            [
              203,
              0
            ],
            [
              209,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffDummyUnmapProc",
            "parameters": {
              "fd": "thandle_t",
              "base": "void",
              "size": "toff_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\n_tiffUnmapProc(thandle_t fd, void* base, toff_t size)\n{\n\t(void) fd;\n\t(void) size;\n\tUnmapViewOfFile(base);\n}",
          "fn_code_pos": [
            [
              211,
              0
            ],
            [
              217,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_tiffUnmapProc",
            "parameters": {
              "fd": "thandle_t",
              "base": "void",
              "size": "toff_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFF*\nTIFFFdOpen(int ifd, const char* name, const char* mode)\n{\n\tTIFF* tif;\n\tint fSuppressMap;\n\tint m;\n\tfSuppressMap=0;\n\tfor (m=0; mode[m]!=0; m++)\n\t{\n\t\tif (mode[m]=='u')\n\t\t{\n\t\t\tfSuppressMap=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttif = TIFFClientOpen(name, mode, (thandle_t)ifd, /* FIXME: WIN64 cast to pointer warning */\n\t\t\t_tiffReadProc, _tiffWriteProc,\n\t\t\t_tiffSeekProc, _tiffCloseProc, _tiffSizeProc,\n\t\t\tfSuppressMap ? _tiffDummyMapProc : _tiffMapProc,\n\t\t\tfSuppressMap ? _tiffDummyUnmapProc : _tiffUnmapProc);\n\tif (tif)\n\t\ttif->tif_fd = ifd;\n\treturn (tif);\n}",
          "fn_code_pos": [
            [
              224,
              0
            ],
            [
              247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFdOpen",
            "parameters": {
              "ifd": "int",
              "name": "char",
              "mode": "char"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "TIFF*\nTIFFOpen(const char* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpen\";\n\tthandle_t fd;\n\tint m;\n\tDWORD dwMode;\n\tTIFF* tif;\n\n\tm = _TIFFgetMode(mode, module);\n\n\tswitch(m) {\n\t\tcase O_RDONLY:\t\t\tdwMode = OPEN_EXISTING; break;\n\t\tcase O_RDWR:\t\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_CREAT:\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_TRUNC:\t\tdwMode = CREATE_ALWAYS; break;\n\t\tcase O_RDWR|O_CREAT|O_TRUNC:\tdwMode = CREATE_ALWAYS; break;\n\t\tdefault:\t\t\treturn ((TIFF*)0);\n\t}\n        \n\tfd = (thandle_t)CreateFileA(name,\n\t\t(m == O_RDONLY)?GENERIC_READ:(GENERIC_READ | GENERIC_WRITE),\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, dwMode,\n\t\t(m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL,\n\t\tNULL);\n\tif (fd == INVALID_HANDLE_VALUE) {\n\t\tTIFFErrorExt(0, module, \"%s: Cannot open\", name);\n\t\treturn ((TIFF *)0);\n\t}\n\n\ttif = TIFFFdOpen((int)fd, name, mode);   /* FIXME: WIN64 cast from pointer to int warning */\n\tif(!tif)\n\t\tCloseHandle(fd);\n\treturn tif;\n}",
          "fn_code_pos": [
            [
              254,
              0
            ],
            [
              288,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFOpen",
            "parameters": {
              "name": "char",
              "mode": "char"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "TIFF*\nTIFFOpenW(const wchar_t* name, const char* mode)\n{\n\tstatic const char module[] = \"TIFFOpenW\";\n\tthandle_t fd;\n\tint m;\n\tDWORD dwMode;\n\tint mbsize;\n\tchar *mbname;\n\tTIFF *tif;\n\n\tm = _TIFFgetMode(mode, module);\n\n\tswitch(m) {\n\t\tcase O_RDONLY:\t\t\tdwMode = OPEN_EXISTING; break;\n\t\tcase O_RDWR:\t\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_CREAT:\t\tdwMode = OPEN_ALWAYS;   break;\n\t\tcase O_RDWR|O_TRUNC:\t\tdwMode = CREATE_ALWAYS; break;\n\t\tcase O_RDWR|O_CREAT|O_TRUNC:\tdwMode = CREATE_ALWAYS; break;\n\t\tdefault:\t\t\treturn ((TIFF*)0);\n\t}\n\n\tfd = (thandle_t)CreateFileW(name,\n\t\t(m == O_RDONLY)?GENERIC_READ:(GENERIC_READ|GENERIC_WRITE),\n\t\tFILE_SHARE_READ | FILE_SHARE_WRITE, NULL, dwMode,\n\t\t(m == O_RDONLY)?FILE_ATTRIBUTE_READONLY:FILE_ATTRIBUTE_NORMAL,\n\t\tNULL);\n\tif (fd == INVALID_HANDLE_VALUE) {\n\t\tTIFFErrorExt(0, module, \"%S: Cannot open\", name);\n\t\treturn ((TIFF *)0);\n\t}\n\n\tmbname = NULL;\n\tmbsize = WideCharToMultiByte(CP_ACP, 0, name, -1, NULL, 0, NULL, NULL);\n\tif (mbsize > 0) {\n\t\tmbname = (char *)_TIFFmalloc(mbsize);\n\t\tif (!mbname) {\n\t\t\tTIFFErrorExt(0, module,\n\t\t\t\"Can't allocate space for filename conversion buffer\");\n\t\t\treturn ((TIFF*)0);\n\t\t}\n\n\t\tWideCharToMultiByte(CP_ACP, 0, name, -1, mbname, mbsize,\n\t\t\t\t    NULL, NULL);\n\t}\n\n\ttif = TIFFFdOpen((int)fd,    /* FIXME: WIN64 cast from pointer to int warning */\n\t\t\t (mbname != NULL) ? mbname : \"<unknown>\", mode);\n\tif(!tif)\n\t\tCloseHandle(fd);\n\n\t_TIFFfree(mbname);\n\n\treturn tif;\n}",
          "fn_code_pos": [
            [
              293,
              0
            ],
            [
              347,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFOpenW",
            "parameters": {
              "name": "wchar_t",
              "mode": "char"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "void*\n_TIFFmalloc(tmsize_t s)\n{\n        if (s == 0)\n                return ((void *) NULL);\n\n\treturn (malloc((size_t) s));\n}",
          "fn_code_pos": [
            [
              351,
              0
            ],
            [
              358,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmalloc",
            "parameters": {
              "s": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void* _TIFFcalloc(tmsize_t nmemb, tmsize_t siz)\n{\n    if( nmemb == 0 || siz == 0 )\n        return ((void *) NULL);\n\n    return calloc((size_t) nmemb, (size_t)siz);\n}",
          "fn_code_pos": [
            [
              360,
              0
            ],
            [
              366,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFcalloc",
            "parameters": {
              "nmemb": "tmsize_t",
              "siz": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\n_TIFFfree(void* p)\n{\n\tfree(p);\n}",
          "fn_code_pos": [
            [
              368,
              0
            ],
            [
              372,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFfree",
            "parameters": {
              "p": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void*\n_TIFFrealloc(void* p, tmsize_t s)\n{\n\treturn (realloc(p, (size_t) s));\n}",
          "fn_code_pos": [
            [
              374,
              0
            ],
            [
              378,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFrealloc",
            "parameters": {
              "p": "void",
              "s": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\n_TIFFmemset(void* p, int v, tmsize_t c)\n{\n\tmemset(p, v, (size_t) c);\n}",
          "fn_code_pos": [
            [
              380,
              0
            ],
            [
              384,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmemset",
            "parameters": {
              "p": "void",
              "v": "int",
              "c": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\n_TIFFmemcpy(void* d, const void* s, tmsize_t c)\n{\n\tmemcpy(d, s, (size_t) c);\n}",
          "fn_code_pos": [
            [
              386,
              0
            ],
            [
              390,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmemcpy",
            "parameters": {
              "d": "void",
              "s": "void",
              "c": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\n_TIFFmemcmp(const void* p1, const void* p2, tmsize_t c)\n{\n\treturn (memcmp(p1, p2, (size_t) c));\n}",
          "fn_code_pos": [
            [
              392,
              0
            ],
            [
              396,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmemcmp",
            "parameters": {
              "p1": "void",
              "p2": "void",
              "c": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nWin32WarningHandler(const char* module, const char* fmt, va_list ap)\n{\n\tif (module != NULL)\n\t\tfprintf(stderr, \"%s: \", module);\n\tfprintf(stderr, \"Warning, \");\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \".\\n\");\n}",
          "fn_code_pos": [
            [
              404,
              0
            ],
            [
              412,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Win32WarningHandler",
            "parameters": {
              "module": "char",
              "fmt": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nWin32ErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n\tif (module != NULL)\n\t\tfprintf(stderr, \"%s: \", module);\n\tvfprintf(stderr, fmt, ap);\n\tfprintf(stderr, \".\\n\");\n}",
          "fn_code_pos": [
            [
              415,
              0
            ],
            [
              422,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Win32ErrorHandler",
            "parameters": {
              "module": "char",
              "fmt": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFFdOpen(int ifd, const char* name, const char* mode)",
          "fn_dec_pos": [
            [
              225,
              0
            ],
            [
              225,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFdOpen",
            "parameters": {
              "ifd": "int",
              "name": "char",
              "mode": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFOpen(const char* name, const char* mode)",
          "fn_dec_pos": [
            [
              255,
              0
            ],
            [
              255,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFOpen",
            "parameters": {
              "name": "char",
              "mode": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFOpenW(const wchar_t* name, const char* mode)",
          "fn_dec_pos": [
            [
              294,
              0
            ],
            [
              294,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFOpenW",
            "parameters": {
              "name": "wchar_t",
              "mode": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFmalloc(tmsize_t s)",
          "fn_dec_pos": [
            [
              352,
              0
            ],
            [
              352,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmalloc",
            "parameters": {
              "s": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFcalloc(tmsize_t nmemb, tmsize_t siz)",
          "fn_dec_pos": [
            [
              360,
              6
            ],
            [
              360,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFcalloc",
            "parameters": {
              "nmemb": "tmsize_t",
              "siz": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFrealloc(void* p, tmsize_t s)",
          "fn_dec_pos": [
            [
              375,
              0
            ],
            [
              375,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFrealloc",
            "parameters": {
              "p": "void",
              "s": "tmsize_t"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ],
        [
          "#include <windows.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/archive/tools/sgi2tiff.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tIMAGE *in;\n\tTIFF *out;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"c:p:r:\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'c':\t\t/* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'f':\t\t/* fill order */\n\t\t\tif (streq(optarg, \"lsb2msb\"))\n\t\t\t\tfillorder = FILLORDER_LSB2MSB;\n\t\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t\t\tfillorder = FILLORDER_MSB2LSB;\n\t\t\telse\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'p':\t\t/* planar configuration */\n\t\t\tif (streq(optarg, \"separate\"))\n\t\t\t\tconfig = PLANARCONFIG_SEPARATE;\n\t\t\telse if (streq(optarg, \"contig\"))\n\t\t\t\tconfig = PLANARCONFIG_CONTIG;\n\t\t\telse\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* rows/strip */\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind != 2)\n\t\tusage();\n\tin = iopen(argv[optind], \"r\");\n\tif (in == NULL)\n\t\treturn (-1);\n\tout = TIFFOpen(argv[optind+1], \"w\");\n\tif (out == NULL)\n\t\treturn (-2);\n\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, (uint32) in->xsize);\n\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, (uint32) in->ysize);\n\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\tif (in->zsize == 1)\n\t\tphotometric = PHOTOMETRIC_MINISBLACK;\n\telse\n\t\tphotometric = PHOTOMETRIC_RGB;\n\tswitch (compression) {\n\tcase COMPRESSION_JPEG:\n\t\tif (photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB)\n\t\t\tphotometric = PHOTOMETRIC_YCBCR;\n\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\tbreak;\n\tcase COMPRESSION_LZW:\n\tcase COMPRESSION_DEFLATE:\n\t\tif (predictor != 0)\n\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\tbreak;\n\t}\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\n\tif (fillorder != 0)\n\t\tTIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, in->zsize);\n\tif (in->zsize > 3) {\n\t    uint16 v[1];\n\t    v[0] = EXTRASAMPLE_UNASSALPHA;\n\t    TIFFSetField(out, TIFFTAG_EXTRASAMPLES, 1, v);\n\t}\n\tTIFFSetField(out, TIFFTAG_MINSAMPLEVALUE, (uint16) in->min);\n\tTIFFSetField(out, TIFFTAG_MAXSAMPLEVALUE, (uint16) in->max);\n\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n\tif (config != PLANARCONFIG_SEPARATE)\n\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\n\t\t    TIFFDefaultStripSize(out, rowsperstrip));\n\telse\t\t\t/* force 1 row/strip for library limitation */\n\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, 1L);\n\tif (in->name[0] != '\\0')\n\t\tTIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, in->name);\n\tif (config == PLANARCONFIG_CONTIG)\n\t\tcpContig(in, out);\n\telse\n\t\tcpSeparate(in, out);\n\t(void) iclose(in);\n\t(void) TIFFClose(out);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nprocessCompressOptions(char* opt)\n{\n\tif (streq(opt, \"none\"))\n\t\tcompression = COMPRESSION_NONE;\n\telse if (streq(opt, \"packbits\"))\n\t\tcompression = COMPRESSION_PACKBITS;\n\telse if (strneq(opt, \"jpeg\", 4)) {\n\t\tchar* cp = strchr(opt, ':');\n\n                defcompression = COMPRESSION_JPEG;\n                while( cp )\n                {\n                    if (isdigit((int)cp[1]))\n\t\t\tquality = atoi(cp+1);\n                    else if (cp[1] == 'r' )\n\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;\n                    else\n                        usage();\n\n                    cp = strchr(cp+1,':');\n                }\n\t} else if (strneq(opt, \"lzw\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_LZW;\n\t} else if (strneq(opt, \"zip\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_DEFLATE;\n\t} else\n\t\treturn (0);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              187,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {
              "opt": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncpContig(IMAGE* in, TIFF* out)\n{\n\ttdata_t buf = _TIFFmalloc(TIFFScanlineSize(out));\n\tshort *r = NULL;\n\tint x, y;\n\n\tif (in->zsize == 3) {\n\t\tshort *g, *b;\n\n\t\tr = (short *)_TIFFmalloc(3 * in->xsize * sizeof (short));\n\t\tg = r + in->xsize;\n\t\tb = g + in->xsize;\n\t\tfor (y = in->ysize-1; y >= 0; y--) {\n\t\t\tuint8* pp = (uint8*) buf;\n\n\t\t\tgetrow(in, r, y, 0);\n\t\t\tgetrow(in, g, y, 1);\n\t\t\tgetrow(in, b, y, 2);\n\t\t\tfor (x = 0; x < in->xsize; x++) {\n\t\t\t\tpp[0] = r[x];\n\t\t\t\tpp[1] = g[x];\n\t\t\t\tpp[2] = b[x];\n\t\t\t\tpp += 3;\n\t\t\t}\n\t\t\tif (TIFFWriteScanline(out, buf, in->ysize-y-1, 0) < 0)\n\t\t\t\tgoto bad;\n\t\t}\n\t} else if (in->zsize == 4) {\n\t\tshort *g, *b, *a;\n\n\t\tr = (short *)_TIFFmalloc(4 * in->xsize * sizeof (short));\n\t\tg = r + in->xsize;\n\t\tb = g + in->xsize;\n\t\ta = b + in->xsize;\n\t\tfor (y = in->ysize-1; y >= 0; y--) {\n\t\t\tuint8* pp = (uint8*) buf;\n\n\t\t\tgetrow(in, r, y, 0);\n\t\t\tgetrow(in, g, y, 1);\n\t\t\tgetrow(in, b, y, 2);\n\t\t\tgetrow(in, a, y, 3);\n\t\t\tfor (x = 0; x < in->xsize; x++) {\n\t\t\t\tpp[0] = r[x];\n\t\t\t\tpp[1] = g[x];\n\t\t\t\tpp[2] = b[x];\n\t\t\t\tpp[3] = a[x];\n\t\t\t\tpp += 4;\n\t\t\t}\n\t\t\tif (TIFFWriteScanline(out, buf, in->ysize-y-1, 0) < 0)\n\t\t\t\tgoto bad;\n\t\t}\n\t} else {\n\t\tuint8* pp = (uint8*) buf;\n\n\t\tr = (short *)_TIFFmalloc(in->xsize * sizeof (short));\n\t\tfor (y = in->ysize-1; y >= 0; y--) {\n\t\t\tgetrow(in, r, y, 0);\n\t\t\tfor (x = in->xsize-1; x >= 0; x--)\n\t\t\t\tpp[x] = r[x];\n\t\t\tif (TIFFWriteScanline(out, buf, in->ysize-y-1, 0) < 0)\n\t\t\t\tgoto bad;\n\t\t}\n\t}\n\tif (r)\n\t\t_TIFFfree(r);\n\t_TIFFfree(buf);\n\treturn (1);\nbad:\n\tif (r)\n\t\t_TIFFfree(r);\n\t_TIFFfree(buf);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              189,
              0
            ],
            [
              262,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpContig",
            "parameters": {
              "in": "IMAGE",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncpSeparate(IMAGE* in, TIFF* out)\n{\n\ttdata_t buf = _TIFFmalloc(TIFFScanlineSize(out));\n\tshort *r = (short *)_TIFFmalloc(in->xsize * sizeof (short));\n\tuint8* pp = (uint8*) buf;\n\tint x, y, z;\n\n\tfor (z = 0; z < in->zsize; z++) {\n\t\tfor (y = in->ysize-1; y >= 0; y--) {\n\t\t\tgetrow(in, r, y, z);\n\t\t\tfor (x = 0; x < in->xsize; x++)\n\t\t\t\tpp[x] = r[x];\n\t\t\tif (TIFFWriteScanline(out, buf, in->ysize-y-1, z) < 0)\n\t\t\t\tgoto bad;\n\t\t}\n\t}\n\t_TIFFfree(r);\n\t_TIFFfree(buf);\n\treturn (1);\nbad:\n\t_TIFFfree(r);\n\t_TIFFfree(buf);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              264,
              0
            ],
            [
              288,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpSeparate",
            "parameters": {
              "in": "IMAGE",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              317,
              0
            ],
            [
              327,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              44,
              12
            ],
            [
              44,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "cpContig(IMAGE*, TIFF*)",
          "fn_dec_pos": [
            [
              45,
              11
            ],
            [
              45,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpContig",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "cpSeparate(IMAGE*, TIFF*)",
          "fn_dec_pos": [
            [
              46,
              11
            ],
            [
              46,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpSeparate",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "processCompressOptions(char*)",
          "fn_dec_pos": [
            [
              47,
              11
            ],
            [
              47,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "iopen(const char*, const char*)",
          "fn_dec_pos": [
            [
              50,
              14
            ],
            [
              50,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iopen",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "iclose(IMAGE*)",
          "fn_dec_pos": [
            [
              51,
              12
            ],
            [
              51,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "iclose",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "getrow(IMAGE*, short*, int, int)",
          "fn_dec_pos": [
            [
              52,
              12
            ],
            [
              52,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getrow",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <gl/image.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/archive/tools/ycbcr.c": {
      "fn_def_list": [
        {
          "fn_code": "static int abs(int v) { return (v < 0 ? -v : v); }",
          "fn_code_pos": [
            [
              23,
              0
            ],
            [
              23,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "abs",
            "parameters": {
              "v": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static double pct(int v,double range) { return (v*100. / range); }",
          "fn_code_pos": [
            [
              24,
              0
            ],
            [
              24,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pct",
            "parameters": {
              "v": "int",
              "range": "double"
            },
            "return_type": "double"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char** argv)\n{\n    int R, G, B;\n\n    if (argc > 1) {\n\trefBlackWhite[0] = 16;\n\trefBlackWhite[1] = 235;\n\trefBlackWhite[2] = 128;\n\trefBlackWhite[3] = 240;\n\trefBlackWhite[4] = 128;\n\trefBlackWhite[5] = 240;\n    }\n    D3 = 2 - 2*LumaRed;\n    D4 = 2 - 2*LumaBlue;\n    D1 = 1. / D3;\n    D2 = 1. / D4;\n    D5 = D3*LumaRed / LumaGreen;\n    D6 = D4*LumaBlue / LumaGreen;\n    setupLumaTables();\n    for (R = 0; R < 256; R++) {\n\tfor (G = 0; G < 256; G++)\n\t    for (B = 0; B < 256; B++)\n\t\tcheck(R, G, B);\n\tprintf(\"[%3u] c %u/%u b %u/%u (R %u/%d/%u G %u/%d/%u B %u/%d/%u)\\n\"\n\t    , R\n\t    , eCodes - preveCodes, eCodes\n\t    , eBits - preveBits, eBits\n\t    , abs(AbseRtotal - preveRtotal), eRtotal , AbseRtotal\n\t    , abs(AbseGtotal - preveGtotal), eGtotal , AbseGtotal\n\t    , abs(AbseBtotal - preveBtotal), eBtotal , AbseBtotal\n\t);\n\tpreveRtotal = AbseRtotal;\n\tpreveGtotal = AbseGtotal;\n\tpreveBtotal = AbseBtotal;\n\tpreveCodes = eCodes;\n\tpreveBits = eBits;\n    }\n    printf(\"%u total codes\\n\", 256*256*256);\n    printf(\"total error: %u codes %u bits (R %d/%u G %d/%u B %d/%u)\\n\"\n\t, eCodes\n\t, eBits\n\t, eRtotal , AbseRtotal\n\t, eGtotal , AbseGtotal\n\t, eBtotal , AbseBtotal\n    );\n    return (0);\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              78,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static float*\nsetupLuma(float c)\n{\n    float *v = (float *)_TIFFmalloc(256 * sizeof (float));\n    int i;\n    for (i = 0; i < 256; i++)\n\tv[i] = c * i;\n    return (v);\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              92,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setupLuma",
            "parameters": {
              "c": "float"
            },
            "return_type": "float"
          }
        },
        {
          "fn_code": "static void\nsetupLumaTables(void)\n{\n    lumaRed = setupLuma(LumaRed);\n    lumaGreen = setupLuma(LumaGreen);\n    lumaBlue = setupLuma(LumaBlue);\n}",
          "fn_code_pos": [
            [
              94,
              0
            ],
            [
              100,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setupLumaTables",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static unsigned\nV2Code(float f, unsigned long RB, unsigned long RW, int CR)\n{\n    unsigned int c = (unsigned int)((((f)*(RW-RB)/CR)+RB)+.5);\n    return (c > 255 ? 255 : c);\n}",
          "fn_code_pos": [
            [
              102,
              0
            ],
            [
              107,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "V2Code",
            "parameters": {
              "f": "float",
              "RB": "unsigned long",
              "RW": "unsigned long",
              "CR": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static\nvoid\ncheck(int R, int G, int B)\n{\n    float Y, Cb, Cr;\n    int iY, iCb, iCr;\n    float rY, rCb, rCr;\n    float rR, rG, rB;\n    int eR, eG, eB;\n\n    Y = lumaRed[R] + lumaGreen[G] + lumaBlue[B];\n    Cb = (B - Y)*D2;\n    Cr = (R - Y)*D1;\n    iY = V2Code(Y, refBlackWhite[0], refBlackWhite[1], 255);\n    iCb = V2Code(Cb, refBlackWhite[2], refBlackWhite[3], 127);\n    iCr = V2Code(Cr, refBlackWhite[4], refBlackWhite[5], 127);\n    rCb = Code2V(iCb, refBlackWhite[2], refBlackWhite[3], 127);\n    rCr = Code2V(iCr, refBlackWhite[4], refBlackWhite[5], 127);\n    rY = Code2V(iY, refBlackWhite[0], refBlackWhite[1], 255);\n    rR = rY + rCr*D3;\n    rB = rY + rCb*D4;\n    rG = rY - rCb*D6 - rCr*D5;\n    eR = R - CLAMP(rR,0,255);\n    eG = G - CLAMP(rG,0,255);\n    eB = B - CLAMP(rB,0,255);\n    if (abs(eR) > 1 || abs(eG) > 1 || abs(eB) > 1) {\n\tprintf(\"R %u G %u B %u\", R, G, B);\n\tprintf(\" Y %g Cb %g Cr %g\", Y, Cb, Cr);\n\tprintf(\" iY %u iCb %u iCr %u\", iY, iCb, iCr);\n\tprintf(\"\\n -> Y %g Cb %g Cr %g\", rY, rCb, rCr);\n\tprintf(\" R %g (%u) G %g (%u) B %g (%u) E=[%d %d %d])\\n\"\n\t    , rR, CLAMP(rR,0,255)\n\t    , rG, CLAMP(rG,0,255)\n\t    , rB, CLAMP(rB,0,255)\n\t    , eR, eG, eB\n\t);\n    }\n    eRtotal += eR;\n    eGtotal += eG;\n    eBtotal += eB;\n    AbseRtotal += abs(eR);\n    AbseGtotal += abs(eG);\n    AbseBtotal += abs(eB);\n    if (eR | eG | eB)\n\teCodes++;\n    eBits += abs(eR) + abs(eG) + abs(eB);\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              160,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "check",
            "parameters": {
              "R": "int",
              "G": "int",
              "B": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "setupLumaTables()",
          "fn_dec_pos": [
            [
              22,
              12
            ],
            [
              22,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setupLumaTables",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "check(int R, int G, int B)",
          "fn_dec_pos": [
            [
              25,
              12
            ],
            [
              25,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "check",
            "parameters": {
              "R": "int",
              "G": "int",
              "B": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "setupLuma(float c)",
          "fn_dec_pos": [
            [
              85,
              0
            ],
            [
              85,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setupLuma",
            "parameters": {
              "c": "float"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/archive/tools/gif2tiff.c": {
      "fn_def_list": [
        {
          "fn_code": "void\nmakegamtab(float gam)\n{\n    int i;\n\n    for(i=0; i<256; i++) \n\tgamtab[i] = (unsigned short) (IMAX*pow(i/255.0,gam)+0.5);\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "makegamtab",
            "parameters": {
              "gam": "float"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              85,
              0
            ],
            [
              96,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n#if !HAVE_DECL_OPTARG\n    extern int optind;\n    extern char *optarg;\n#endif\n\n    int c, status;\n\n    while ((c = getopt(argc, argv, \"c:r:\")) != -1)\n\t    switch (c) {\n\t    case 'c':\t\t/* compression scheme */\n\t\t    if (!processCompressOptions(optarg))\n\t\t\t    usage();\n\t\t    break;\n\t    case 'r':\t\t/* rows/strip */\n\t\t    rowsperstrip = atoi(optarg);\n\t\t    break;\n\t    case '?':\n\t\t    usage();\n\t\t    /*NOTREACHED*/\n\t    }\n    if (argc - optind != 2)\n\t    usage();\n\n    makegamtab(GIFGAMMA);\n    filename = argv[optind];\n    imagename = argv[optind+1];\n    if ((infile = fopen(imagename, \"rb\")) != NULL) {\n\tint c;\n\tfclose(infile);\n\tprintf(\"overwrite %s? \", imagename); fflush(stdout);\n\tc = getc(stdin);\n\tif (c != 'y' && c != 'Y')\n\t    return (1);\n    }\n    if ((infile = fopen(filename, \"rb\")) == NULL) {\n\tperror(filename);\n\treturn (1);\n    }\n    status = convert();\n    fclose(infile);\n    return (status);\n}",
          "fn_code_pos": [
            [
              134,
              0
            ],
            [
              178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nprocessCompressOptions(char* opt)\n{\n\tif (streq(opt, \"none\"))\n\t\tcompression = COMPRESSION_NONE;\n\telse if (streq(opt, \"packbits\"))\n\t\tcompression = COMPRESSION_PACKBITS;\n\telse if (strneq(opt, \"lzw\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_LZW;\n\t} else if (strneq(opt, \"zip\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_DEFLATE;\n\t} else\n\t\treturn (0);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {
              "opt": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nconvert(void)\n{\n    int ch;\n    char* mode = \"w\";\n\n    if (!checksignature())\n        return (-1);\n    if (!readscreen())\n        return (-1);\n    while ((ch = getc(infile)) != ';' && ch != EOF) {\n        switch (ch) {\n            case '\\0':  break;  /* this kludge for non-standard files */\n            case ',':   if (!readgifimage(mode))\n                           return (-1);\n\t\t\tmode = \"a\";\t\t/* subsequent images append */\n                        break;\n        case '!':   if (!readextension())\n                            return (-1);\n                        break;\n            default:    fprintf(stderr, \"illegal GIF block type\\n\");\n                        return (-1);\n        }\n    }\n    return (0);\n}",
          "fn_code_pos": [
            [
              202,
              0
            ],
            [
              227,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "convert",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nchecksignature(void)\n{\n    char buf[6];\n\n    if (fread(buf,1,6,infile) != 6) {\n        fprintf(stderr, \"short read from file %s (%s)\\n\",\n                filename, strerror(errno));\n        return 0;\n    }\n    if (strncmp(buf,\"GIF\",3)) {\n        fprintf(stderr, \"file is not a GIF file\\n\");\n        return 0;\n    }\n    if (strncmp(&buf[3],\"87a\",3)) {\n        fprintf(stderr, \"unknown GIF version number\\n\");\n        return 0;\n    }\n    return 1;\n}",
          "fn_code_pos": [
            [
              229,
              0
            ],
            [
              248,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "checksignature",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nreadscreen(void)\n{\n    unsigned char buf[7];\n\n    if (fread(buf,1,7,infile) != 7) {\n        fprintf(stderr, \"short read from file %s (%s)\\n\",\n                filename, strerror(errno));\n        return 0;\n    }\n    global = buf[4] & 0x80;\n    if (global) {\n        globalbits = (buf[4] & 0x07) + 1;\n        if (fread(globalmap,3,((size_t)1)<<globalbits,infile) !=\n            ((size_t)1)<<globalbits) {\n            fprintf(stderr, \"short read from file %s (%s)\\n\",\n                    filename, strerror(errno));\n            return 0;\n        }\n    }\n    return 1;\n}",
          "fn_code_pos": [
            [
              255,
              0
            ],
            [
              276,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readscreen",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nreadgifimage(char* mode)\n{\n    unsigned char buf[9];\n    int local, interleaved;\n    unsigned char localmap[256][3];\n    int localbits;\n    int status;\n    size_t raster_size;\n\n    if (fread(buf, 1, 9, infile) != 9) {\n        fprintf(stderr, \"short read from file %s (%s)\\n\",\n                filename, strerror(errno));\n\treturn (0);\n    }\n    width = (buf[4] + (buf[5] << 8)) & 0xffff; /* 16 bit */\n    height = (buf[6] + (buf[7] << 8)) & 0xffff;  /* 16 bit */\n    local = buf[8] & 0x80;\n    interleaved = buf[8] & 0x40;\n    if (width == 0UL || height == 0UL || (width > 2000000000UL / height)) {\n        fprintf(stderr, \"Invalid value of width or height\\n\");\n        return(0);\n    }\n    if (local == 0 && global == 0) {\n        fprintf(stderr, \"no colormap present for image\\n\");\n        return (0);\n    }\n    raster_size=width*height;\n    if ((raster_size/width) == height) {\n        raster_size += EXTRAFUDGE;  /* Add elbow room */\n    } else {\n        raster_size=0;\n    }\n    if ((raster = (unsigned char*) _TIFFmalloc(raster_size)) == NULL) {\n        fprintf(stderr, \"not enough memory for image\\n\");\n        return (0);\n    }\n    if (local) {\n        localbits = (buf[8] & 0x7) + 1;\n\n        fprintf(stderr, \"   local colors: %d\\n\", 1<<localbits);\n\n        if (fread(localmap, 3, ((size_t)1)<<localbits, infile) !=\n            ((size_t)1)<<localbits) {\n            fprintf(stderr, \"short read from file %s (%s)\\n\",\n                    filename, strerror(errno));\n            return (0);\n        }\n        initcolors(localmap, 1<<localbits);\n    } else if (global) {\n        initcolors(globalmap, 1<<globalbits);\n    }\n    if ((status = readraster()))\n\trasterize(interleaved, mode);\n    _TIFFfree(raster);\n    return status;\n}",
          "fn_code_pos": [
            [
              278,
              0
            ],
            [
              334,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readgifimage",
            "parameters": {
              "mode": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nreadextension(void)\n{\n    int count;\n    char buf[255];\n    int status = 1;\n\n    (void) getc(infile);\n    while ((count = getc(infile)) && count <= 255)\n        if (fread(buf, 1, count, infile) != (size_t) count) {\n            fprintf(stderr, \"short read from file %s (%s)\\n\",\n                    filename, strerror(errno));\n            status = 0;\n            break;\n        }\n    return status;\n}",
          "fn_code_pos": [
            [
              341,
              0
            ],
            [
              357,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readextension",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nreadraster(void)\n{\n    unsigned char *fill = raster;\n    unsigned char buf[255];\n    register int bits=0;\n    register unsigned long datum=0;\n    register unsigned char *ch;\n    register int count, code;\n    int status = 1;\n\n    datasize = getc(infile);\n    if (datasize > 12)\n\treturn 0;\n    clear = 1 << datasize;\n    eoi = clear + 1;\n    avail = clear + 2;\n    oldcode = -1;\n    codesize = datasize + 1;\n    codemask = (1 << codesize) - 1;\n    for (code = 0; code < clear; code++) {\n\tprefix[code] = 0;\n\tsuffix[code] = code;\n    }\n    stackp = stack;\n    for (count = getc(infile); count > 0 && count <= 255; count = getc(infile)) {\n\tif (fread(buf,1,count,infile) != (size_t)count) {\n            fprintf(stderr, \"short read from file %s (%s)\\n\",\n                    filename, strerror(errno));\n            return 0;\n        }\n\tfor (ch=buf; count-- > 0; ch++) {\n\t    datum += (unsigned long) *ch << bits;\n\t    bits += 8;\n\t    while (bits >= codesize) {\n\t\tcode = datum & codemask;\n\t\tdatum >>= codesize;\n\t\tbits -= codesize;\n\t\tif (code == eoi) {               /* This kludge put in */\n\t\t    goto exitloop;               /* because some GIF files*/\n\t\t}                                /* aren't standard */\n\t\tif (!process(code, &fill)) {\n\t\t    status = 0;\n\t\t    goto exitloop;\n\t\t}\n\t    }\n\t}\n\tif (fill >= raster + width*height) {\n\t    fprintf(stderr, \"raster full before eoi code\\n\");\n\t    break;\n\t}\n    }\nexitloop:\n    if (fill != raster + width*height)  {\n\tfprintf(stderr, \"warning: wrong rastersize: %ld bytes\\n\",\n\t\t\t\t\t\t      (long) (fill-raster));\n\tfprintf(stderr, \"         instead of %ld bytes\\n\",\n\t\t\t\t\t\t      (long) width*height);\n    }\n    return status;\n}",
          "fn_code_pos": [
            [
              364,
              0
            ],
            [
              424,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readraster",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nprocess(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n    }\n\n    if (oldcode == -1) {\n        if (code >= clear) {\n            fprintf(stderr, \"bad input: code=%d is larger than clear=%d\\n\",code, clear);\n            return 0;\n        }\n        if (*fill >= raster + width*height) {\n            fprintf(stderr, \"raster full before eoi code\\n\");\n            return 0;\n        }\n\t*(*fill)++ = suffix[code];\n\tfirstchar = oldcode = code;\n\treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n\n    incode = code;\n    if (code == avail) {      /* the first code is always < avail */\n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n        if (*fill >= raster + width*height) {\n            fprintf(stderr, \"raster full before eoi code\\n\");\n            return 0;\n        }\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}",
          "fn_code_pos": [
            [
              432,
              0
            ],
            [
              492,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process",
            "parameters": {
              "code": "int",
              "fill": "unsigned char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\ninitcolors(unsigned char colormap[COLSIZE][3], int ncolors)\n{\n    register int i;\n\n    for (i = 0; i < ncolors; i++) {\n        red[i]   = gamtab[colormap[i][0]];\n        green[i] = gamtab[colormap[i][1]];\n        blue[i]  = gamtab[colormap[i][2]];\n    }\n}",
          "fn_code_pos": [
            [
              500,
              0
            ],
            [
              510,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initcolors",
            "parameters": {
              "colormap": "unsigned char",
              "ncolors": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nrasterize(int interleaved, char* mode)\n{\n    register unsigned long row;\n    unsigned char *newras;\n    unsigned char *ras;\n    TIFF *tif;\n    tstrip_t strip;\n    tsize_t stripsize;\n\n    if ((newras = (unsigned char*) _TIFFmalloc(width*height+EXTRAFUDGE)) == NULL) {\n        fprintf(stderr, \"not enough memory for image\\n\");\n        return;\n    }\n#define DRAWSEGMENT(offset, step) {\t\t\t\\\n        for (row = offset; row < height; row += step) {\t\\\n            _TIFFmemcpy(newras + row*width, ras, width);\\\n            ras += width;                            \t\\\n        }\t\t\t\t\t\t\\\n    }\n    ras = raster;\n    if (interleaved) {\n        DRAWSEGMENT(0, 8);\n        DRAWSEGMENT(4, 8);\n        DRAWSEGMENT(2, 4);\n        DRAWSEGMENT(1, 2);\n    } else \n        DRAWSEGMENT(0, 1);\n#undef DRAWSEGMENT\n\n    tif = TIFFOpen(imagename, mode);\n    if (!tif) {\n\tTIFFError(imagename,\"Can not open output image\");\n\texit(-1);\n    }\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, (uint32) width);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, (uint32) height);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, \n\trowsperstrip = TIFFDefaultStripSize(tif, rowsperstrip));\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\n    switch (compression) {\n    case COMPRESSION_LZW:\n    case COMPRESSION_DEFLATE:\n\t    if (predictor != 0)\n\t\t    TIFFSetField(tif, TIFFTAG_PREDICTOR, predictor);\n\t    break;\n    }\n    TIFFSetField(tif, TIFFTAG_COLORMAP, red, green, blue);\n    TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    strip = 0;\n    stripsize = TIFFStripSize(tif);\n    for (row=0; row<height; row += rowsperstrip) {\n\tif (rowsperstrip > height-row) {\n\t    rowsperstrip = height-row;\n\t    stripsize = TIFFVStripSize(tif, rowsperstrip);\n\t}\n\tif (TIFFWriteEncodedStrip(tif, strip, newras+row*width, stripsize) < 0)\n\t    break;\n\tstrip++;\n    }\n    TIFFClose(tif);\n\n    _TIFFfree(newras);\n}",
          "fn_code_pos": [
            [
              512,
              0
            ],
            [
              579,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rasterize",
            "parameters": {
              "interleaved": "int",
              "mode": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "processCompressOptions(char*)",
          "fn_dec_pos": [
            [
              122,
              11
            ],
            [
              122,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "convert(void)",
          "fn_dec_pos": [
            [
              124,
              4
            ],
            [
              124,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "convert",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "checksignature(void)",
          "fn_dec_pos": [
            [
              125,
              4
            ],
            [
              125,
              24
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "checksignature",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "readscreen(void)",
          "fn_dec_pos": [
            [
              126,
              4
            ],
            [
              126,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readscreen",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "readgifimage(char*)",
          "fn_dec_pos": [
            [
              127,
              4
            ],
            [
              127,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readgifimage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "readextension(void)",
          "fn_dec_pos": [
            [
              128,
              4
            ],
            [
              128,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readextension",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "readraster(void)",
          "fn_dec_pos": [
            [
              129,
              4
            ],
            [
              129,
              20
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readraster",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "process(int, unsigned char**)",
          "fn_dec_pos": [
            [
              130,
              4
            ],
            [
              130,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "initcolors(unsigned char [COLSIZE][3], int)",
          "fn_dec_pos": [
            [
              131,
              5
            ],
            [
              131,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initcolors",
            "parameters": {
              "COLSIZE": "unsigned char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "rasterize(int, char*)",
          "fn_dec_pos": [
            [
              132,
              5
            ],
            [
              132,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rasterize",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/archive/tools/sgisv.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"c:p:r:\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'b':\t\t/* save as b&w */\n\t\t\tphotometric = PHOTOMETRIC_MINISBLACK;\n\t\t\tbreak;\n\t\tcase 'c':\t\t/* compression scheme */\n\t\t\tif (streq(optarg, \"none\"))\n\t\t\t\tcompression = COMPRESSION_NONE;\n\t\t\telse if (streq(optarg, \"packbits\"))\n\t\t\t\tcompression = COMPRESSION_PACKBITS;\n\t\t\telse if (strneq(optarg, \"jpeg\", 4)) {\n\t\t\t\tchar* cp = strchr(optarg, ':');\n\t\t\t\tif (cp && isdigit(cp[1]))\n\t\t\t\t\tquality = atoi(cp+1);\n\t\t\t\tif (cp && strchr(cp, 'r'))\n\t\t\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;\n\t\t\t\tcompression = COMPRESSION_JPEG;\n\t\t\t} else if (strneq(optarg, \"lzw\", 3)) {\n\t\t\t\tchar* cp = strchr(optarg, ':');\n\t\t\t\tif (cp)\n\t\t\t\t\tpredictor = atoi(cp+1);\n\t\t\t\tcompression = COMPRESSION_LZW;\n\t\t\t} else\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'p':\t\t/* planar configuration */\n\t\t\tif (streq(optarg, \"separate\"))\n\t\t\t\tconfig = PLANARCONFIG_SEPARATE;\n\t\t\telse if (streq(optarg, \"contig\"))\n\t\t\t\tconfig = PLANARCONFIG_CONTIG;\n\t\t\telse\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* rows/strip */\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind != 1 && argc - optind != 5)\n\t\tusage();\n\txmaxscreen = getgdesc(GD_XPMAX)-1;\n\tymaxscreen = getgdesc(GD_YPMAX)-1;\n\tforeground();\n\tnoport();\n\twinopen(\"tiffsv\");\n\tif (argc - optind == 5)\n\t\ttiffsv(argv[optind],\n\t\t    atoi(argv[optind+1]), atoi(argv[optind+2]),\n\t\t    atoi(argv[optind+3]), atoi(argv[optind+4]));\n\telse\n\t\ttiffsv(argv[optind], 0, xmaxscreen, 0, ymaxscreen);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              140,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nsvRGBSeparate(TIFF* tif, uint32* ss, int xsize, int ysize)\n{\n\ttsize_t stripsize = TIFFStripSize(tif);\n\tunsigned char *rbuf = (unsigned char *)_TIFFmalloc(3*stripsize);\n\tunsigned char *gbuf = rbuf + stripsize;\n\tunsigned char *bbuf = gbuf + stripsize;\n\tregister int y;\n\n\tfor (y = 0; y <= ysize; y += rowsperstrip) {\n\t\tunsigned char *rp, *gp, *bp;\n\t\tregister int x;\n\t\tregister uint32 n;\n\n\t\tn = rowsperstrip;\n\t\tif (n > ysize-y+1)\n\t\t\tn = ysize-y+1;\n\t\trp = rbuf; gp = gbuf; bp = bbuf;\n\t\tdo {\n\t\t\tfor (x = 0; x <= xsize; x++) {\n\t\t\t\tuint32 v = ss[x];\n\t\t\t\trp[x] = v;\n\t\t\t\tgp[x] = v >> 8;\n\t\t\t\tbp[x] = v >> 16;\n\t\t\t}\n\t\t\trp += xsize+1, gp += xsize+1, bp += xsize+1;\n\t\t\tss += xsize+1;\n\t\t} while (--n);\n\t\tif (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,0),\n\t\t    rbuf, stripsize) < 0)\n\t\t\tbreak;\n\t\tif (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,1),\n\t\t    gbuf, stripsize) < 0)\n\t\t\tbreak;\n\t\tif (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,2),\n\t\t    bbuf, stripsize) < 0)\n\t\t\tbreak;\n\t}\n\t_TIFFfree(rbuf);\n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              191,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "svRGBSeparate",
            "parameters": {
              "tif": "TIFF",
              "ss": "uint32",
              "xsize": "int",
              "ysize": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nsvRGBContig(TIFF* tif, uint32* ss, int xsize, int ysize)\n{\n\tregister int x, y;\n\ttsize_t stripsize = TIFFStripSize(tif);\n\tunsigned char *strip = (unsigned char *)_TIFFmalloc(stripsize);\n\n\tfor (y = 0; y <= ysize; y += rowsperstrip) {\n\t\tregister unsigned char *pp = strip;\n\t\tregister uint32 n;\n\n\t\tn = rowsperstrip;\n\t\tif (n > ysize-y+1)\n\t\t\tn = ysize-y+1;\n\t\tdo {\n\t\t\tfor (x = 0; x <= xsize; x++) {\n\t\t\t\tuint32 v = ss[x];\n\t\t\t\tpp[0] = v;\n\t\t\t\tpp[1] = v >> 8;\n\t\t\t\tpp[2] = v >> 16;\n\t\t\t\tpp += 3;\n\t\t\t}\n\t\t\tss += xsize+1;\n\t\t} while (--n);\n\t\tif (TIFFWriteEncodedStrip(tif, TIFFComputeStrip(tif,y,0),\n\t\t    strip, stripsize) < 0)\n\t\t\tbreak;\n\t}\n\t_TIFFfree(strip);\n}",
          "fn_code_pos": [
            [
              193,
              0
            ],
            [
              222,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "svRGBContig",
            "parameters": {
              "tif": "TIFF",
              "ss": "uint32",
              "xsize": "int",
              "ysize": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nsvGrey(TIFF* tif, uint32* ss, int xsize, int ysize)\n{\n\tregister int x, y;\n\tunsigned char *buf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif));\n\n\tfor (y = 0; y <= ysize; y++) {\n\t\tfor (x = 0; x <= xsize; x++) {\n\t\t\tunsigned char *cp = (unsigned char *)&ss[x];\n\t\t\tbuf[x] = (RED*cp[3] + GREEN*cp[2] + BLUE*cp[1]) >> 8;\n\t\t}\n\t\tif (TIFFWriteScanline(tif, buf, (uint32) y, 0) < 0)\n\t\t\tbreak;\n\t\tss += xsize+1;\n\t}\n\t_TIFFfree(buf);\n}",
          "fn_code_pos": [
            [
              232,
              0
            ],
            [
              248,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "svGrey",
            "parameters": {
              "tif": "TIFF",
              "ss": "uint32",
              "xsize": "int",
              "ysize": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ntiffsv(char* name, int x1, int x2, int y1, int y2)\n{\n\tTIFF *tif;\n\tint xsize, ysize;\n\tint xorg, yorg;\n\tuint32 *scrbuf;\n\n\txorg = MIN(x1,x2);\n\tyorg = MIN(y1,y2);\n\tif (xorg<0)\n\t\txorg = 0;\n\tif (yorg<0)\n\t\tyorg = 0;\n\txsize = ABS(x2-x1);\n\tysize = ABS(y2-y1);\n\tif (xorg+xsize > xmaxscreen)\n\t\txsize = xmaxscreen-xorg;\n\tif (yorg+ysize > ymaxscreen)\n\t\tysize = ymaxscreen-yorg;\n\ttif = TIFFOpen(name, \"w\");\n\tTIFFSetField(tif, TIFFTAG_IMAGEWIDTH, (uint32) (xsize+1));\n\tTIFFSetField(tif, TIFFTAG_IMAGELENGTH, (uint32) (ysize+1));\n\tTIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL,\n\t    photometric == PHOTOMETRIC_RGB ? 3 : 1);\n\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, config);\n\tTIFFSetField(tif, TIFFTAG_COMPRESSION, compression);\n\tswitch (compression) {\n\tcase COMPRESSION_JPEG:\n\t\tif (photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB)\n\t\t\tphotometric = PHOTOMETRIC_YCBCR;\n\t\tTIFFSetField(tif, TIFFTAG_JPEGQUALITY, quality);\n\t\tTIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\tbreak;\n\tcase COMPRESSION_LZW:\n\t\tif (predictor != 0)\n\t\t\tTIFFSetField(tif, TIFFTAG_PREDICTOR, predictor);\n\t\tbreak;\n\t}\n\tTIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric);\n\tTIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_BOTLEFT);\n\trowsperstrip = TIFFDefaultStripSize(tif, rowsperstrip);\n\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\tscrbuf = (uint32 *)_TIFFmalloc((xsize+1)*(ysize+1)*sizeof (uint32));\n\treaddisplay(xorg, yorg, xorg+xsize, yorg+ysize, scrbuf, RD_FREEZE);\n\tif (photometric == PHOTOMETRIC_RGB) {\n\t\tif (config == PLANARCONFIG_SEPARATE)\n\t\t\tsvRGBSeparate(tif, scrbuf, xsize, ysize);\n\t\telse\n\t\t\tsvRGBContig(tif, scrbuf, xsize, ysize);\n\t} else\n\t\tsvGrey(tif, scrbuf, xsize, ysize);\n\t(void) TIFFClose(tif);\n\t_TIFFfree((char *)scrbuf);\n}",
          "fn_code_pos": [
            [
              253,
              0
            ],
            [
              308,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiffsv",
            "parameters": {
              "name": "char",
              "x1": "int",
              "x2": "int",
              "y1": "int",
              "y2": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              49,
              12
            ],
            [
              49,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "tiffsv(char*, int, int, int, int)",
          "fn_dec_pos": [
            [
              50,
              12
            ],
            [
              50,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiffsv",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <gl.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/archive/tools/bmp2tiff.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tuint32\twidth, length;\n\tuint16\tnbands = 1;\t\t/* number of bands in input image */\n        uint16\tdepth = 8;\t\t/* bits per pixel in input image */\n\tuint32\trowsperstrip = (uint32) -1;\n        uint16\tphotometric = PHOTOMETRIC_MINISBLACK;\n\tint\tfd = 0;\n\t_TIFF_stat_s instat;\n\tchar\t*outfilename = NULL, *infilename = NULL;\n\tTIFF\t*out = NULL;\n\n\tBMPFileHeader file_hdr;\n        BMPInfoHeader info_hdr;\n        int     bmp_type;\n        uint32  clr_tbl_size, n_clr_elems = 3;\n        unsigned char *clr_tbl;\n\tunsigned short *red_tbl = NULL, *green_tbl = NULL, *blue_tbl = NULL;\n\tuint32\trow, clr;\n\n\tint\tc;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"c:r:o:h\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'c':\t\t/* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* rows/strip */\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\toutfilename = optarg;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (argc - optind < 2)\n\t\tusage();\n\n\tif (outfilename == NULL)\n\t\toutfilename = argv[argc-1];\n\tout = TIFFOpen(outfilename, \"w\");\n\tif (out == NULL) {\n\t\tTIFFError(infilename, \"Cannot open file %s for output\",\n\t\t\t  outfilename);\n\t\tgoto bad3;\n\t}\n\t\n\n\twhile (optind < argc-1) {\n\t\tinfilename = argv[optind];\n\t\toptind++;\n\t    \n\t\tfd = open(infilename, O_RDONLY|O_BINARY, 0);\n\t\tif (fd < 0) {\n\t\t\tTIFFError(infilename, \"Cannot open input file\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (read(fd, file_hdr.bType, 2) != 2) {\n                        TIFFError(infilename, \"Failed to read from file (%s)\",\n                                  strerror(errno));\n\t\t\tgoto bad;\n                }\n\t\tif(file_hdr.bType[0] != 'B' || file_hdr.bType[1] != 'M') {\n\t\t\tTIFFError(infilename, \"File is not BMP\");\n\t\t\tgoto bad;\n\t\t}\n\n                /* -------------------------------------------------------------------- */\n                /*      Read the BMPFileHeader. We need iOffBits value only             */\n                /* -------------------------------------------------------------------- */\n                if (_TIFF_lseek_f(fd, 10, SEEK_SET) == (_TIFF_off_t)-1) {\n                        TIFFError(infilename, \"Failed to seek to offset\");\n                        goto bad;\n                }\n                if (read(fd, &file_hdr.iOffBits, 4) != 4) {\n                        TIFFError(infilename, \"Failed to read from file (%s)\",\n                                  strerror(errno));\n\t\t\tgoto bad;\n                }\n#ifdef WORDS_BIGENDIAN\n\t\tTIFFSwabLong(&file_hdr.iOffBits);\n#endif\n\t\tif (_TIFF_fstat_f(fd, &instat) == -1) {\n                        TIFFError(infilename, \"Failed obtain file information\");\n                        goto bad;\n                }\n\t\tfile_hdr.iSize = instat.st_size;\n\n                /* -------------------------------------------------------------------- */\n                /*      Read the BMPInfoHeader.                                         */\n                /* -------------------------------------------------------------------- */\n\n\t\tif (_TIFF_lseek_f(fd, BFH_SIZE, SEEK_SET) == (_TIFF_off_t)-1) {\n                        TIFFError(infilename, \"Failed to seek to offset\");\n                        goto bad;\n                }\n                if (read(fd, &info_hdr.iSize, 4) != 4) {\n                        TIFFError(infilename, \"Failed to read from file (%s)\",\n                                  strerror(errno));\n\t\t\tgoto bad;\n                }\n#ifdef WORDS_BIGENDIAN\n\t\tTIFFSwabLong(&info_hdr.iSize);\n#endif\n\n\t\tif (info_hdr.iSize == BIH_WIN4SIZE)\n\t\t\tbmp_type = BMPT_WIN4;\n\t\telse if (info_hdr.iSize == BIH_OS21SIZE)\n\t\t\tbmp_type = BMPT_OS21;\n\t\telse if (info_hdr.iSize == BIH_OS22SIZE\n\t\t\t || info_hdr.iSize == 16)\n\t\t\tbmp_type = BMPT_OS22;\n\t\telse\n\t\t\tbmp_type = BMPT_WIN5;\n\n\t\tif (bmp_type == BMPT_WIN4\n\t\t    || bmp_type == BMPT_WIN5\n\t\t    || bmp_type == BMPT_OS22) {\n\t\t\tif ((read(fd, &info_hdr.iWidth, 4) != 4) ||\n                            (read(fd, &info_hdr.iHeight, 4) != 4) ||\n                            (read(fd, &info_hdr.iPlanes, 2) != 2) ||\n                            (read(fd, &info_hdr.iBitCount, 2) != 2) ||\n                            (read(fd, &info_hdr.iCompression, 4) != 4) ||\n                            (read(fd, &info_hdr.iSizeImage, 4) != 4) ||\n                            (read(fd, &info_hdr.iXPelsPerMeter, 4) != 4) ||\n                            (read(fd, &info_hdr.iYPelsPerMeter, 4) != 4) ||\n                            (read(fd, &info_hdr.iClrUsed, 4) != 4) ||\n                            (read(fd, &info_hdr.iClrImportant, 4) != 4)) {\n                                TIFFError(infilename, \"Failed to read from file (%s)\",\n                                          strerror(errno));\n                                goto bad;\n                        }\n#ifdef WORDS_BIGENDIAN\n\t\t\tTIFFSwabLong((uint32*) &info_hdr.iWidth);\n\t\t\tTIFFSwabLong((uint32*) &info_hdr.iHeight);\n\t\t\tTIFFSwabShort((uint16*) &info_hdr.iPlanes);\n\t\t\tTIFFSwabShort((uint16*) &info_hdr.iBitCount);\n\t\t\tTIFFSwabLong((uint32*) &info_hdr.iCompression);\n\t\t\tTIFFSwabLong((uint32*) &info_hdr.iSizeImage);\n\t\t\tTIFFSwabLong((uint32*) &info_hdr.iXPelsPerMeter);\n\t\t\tTIFFSwabLong((uint32*) &info_hdr.iYPelsPerMeter);\n\t\t\tTIFFSwabLong((uint32*) &info_hdr.iClrUsed);\n\t\t\tTIFFSwabLong((uint32*) &info_hdr.iClrImportant);\n#endif\n\t\t\tn_clr_elems = 4;\n\t\t}\n\n\t\tif (bmp_type == BMPT_OS22) {\n\t\t\t/* \n\t\t\t * FIXME: different info in different documents\n\t\t\t * regarding this!\n\t\t\t */\n                        n_clr_elems = 3;\n\t\t}\n\n\t\tif (bmp_type == BMPT_OS21) {\n\t\t\tint16  iShort;\n\n\t\t\tif ( read(fd, &iShort, 2) != 2 ) {\n                                TIFFError(infilename, \"Failed to read from file (%s)\",\n                                          strerror(errno));\n                                goto bad;\n                        }\n#ifdef WORDS_BIGENDIAN\n\t\t\tTIFFSwabShort((uint16*) &iShort);\n#endif\n\t\t\tinfo_hdr.iWidth = iShort;\n\t\t\tif ( read(fd, &iShort, 2) != 2 ) {\n                                TIFFError(infilename, \"Failed to read from file (%s)\",\n                                          strerror(errno));\n                                goto bad;\n                        }\n#ifdef WORDS_BIGENDIAN\n\t\t\tTIFFSwabShort((uint16*) &iShort);\n#endif\n\t\t\tinfo_hdr.iHeight = iShort;\n\t\t\tif (read(fd, &iShort, 2) != 2 ) {\n                                TIFFError(infilename, \"Failed to read from file (%s)\",\n                                          strerror(errno));\n                                goto bad;\n                        }\n#ifdef WORDS_BIGENDIAN\n\t\t\tTIFFSwabShort((uint16*) &iShort);\n#endif\n\t\t\tinfo_hdr.iPlanes = iShort;\n\t\t\tif ( read(fd, &iShort, 2) != 2 ) {\n                                TIFFError(infilename, \"Failed to read from file (%s)\",\n                                          strerror(errno));\n                                goto bad;\n                        }\n#ifdef WORDS_BIGENDIAN\n\t\t\tTIFFSwabShort((uint16*) &iShort);\n#endif\n\t\t\tinfo_hdr.iBitCount = iShort;\n\t\t\tinfo_hdr.iCompression = BMPC_RGB;\n\t\t\tn_clr_elems = 3;\n\t\t}\n\n\t\tif (info_hdr.iBitCount != 1  && info_hdr.iBitCount != 4  &&\n\t\t    info_hdr.iBitCount != 8  && info_hdr.iBitCount != 16 &&\n\t\t    info_hdr.iBitCount != 24 && info_hdr.iBitCount != 32) {\n                        TIFFError(infilename,\n                                  \"Cannot process BMP file with bit count %d\",\n                                  info_hdr.iBitCount);\n                        close(fd);\n                        return 0;\n\t\t}\n\n\t\twidth = info_hdr.iWidth;\n\t\tlength = (info_hdr.iHeight > 0) ? info_hdr.iHeight : -info_hdr.iHeight;\n                if( width <= 0 || length <= 0 )\n                        {\n                                TIFFError(infilename,\n                                          \"Invalid dimensions of BMP file\" );\n                                close(fd);\n                                return -1;\n                        }\n\n\t\tswitch (info_hdr.iBitCount)\n                        {\n\t\t\tcase 1:\n\t\t\tcase 4:\n\t\t\tcase 8:\n\t\t\t\tnbands = 1;\n\t\t\t\tdepth = info_hdr.iBitCount;\n\t\t\t\tphotometric = PHOTOMETRIC_PALETTE;\n\t\t\t\t/* Allocate memory for colour table and read it. */\n\t\t\t\tif (info_hdr.iClrUsed)\n                                        clr_tbl_size =\n                                                ((uint32)(1<<depth)<info_hdr.iClrUsed)\n                                                ? (uint32) (1 << depth)\n                                                : info_hdr.iClrUsed;\n\t\t\t\telse\n                                        clr_tbl_size = 1 << depth;\n\t\t\t\tclr_tbl = (unsigned char *)\n\t\t\t\t\t_TIFFmalloc(n_clr_elems * clr_tbl_size);\n\t\t\t\tif (!clr_tbl) {\n\t\t\t\t\tTIFFError(infilename,\n                                                  \"Can't allocate space for color table\");\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\n\t\t\t\tif (_TIFF_lseek_f(fd, BFH_SIZE + info_hdr.iSize, SEEK_SET) == (_TIFF_off_t)-1) {\n                                        TIFFError(infilename, \"Failed to seek to offset\");\n                                        goto bad;\n                                }\n\t\t\t\tif ( read(fd, clr_tbl, n_clr_elems * clr_tbl_size)\n                                     != (long) (n_clr_elems * clr_tbl_size) ) {\n                                        TIFFError(infilename, \"Failed to read from file (%s)\",\n                                                  strerror(errno));\n                                        goto bad;\n                                }\n\n\t\t\t\tred_tbl = (unsigned short*)\n\t\t\t\t\t_TIFFmalloc(((tmsize_t)1)<<depth * sizeof(unsigned short));\n\t\t\t\tif (!red_tbl) {\n\t\t\t\t\tTIFFError(infilename,\n                                                  \"Can't allocate space for red component table\");\n\t\t\t\t\t_TIFFfree(clr_tbl);\n\t\t\t\t\tgoto bad1;\n\t\t\t\t}\n\t\t\t\tgreen_tbl = (unsigned short*)\n\t\t\t\t\t_TIFFmalloc(((tmsize_t)1)<<depth * sizeof(unsigned short));\n\t\t\t\tif (!green_tbl) {\n\t\t\t\t\tTIFFError(infilename,\n                                                  \"Can't allocate space for green component table\");\n\t\t\t\t\t_TIFFfree(clr_tbl);\n\t\t\t\t\tgoto bad2;\n\t\t\t\t}\n\t\t\t\tblue_tbl = (unsigned short*)\n\t\t\t\t\t_TIFFmalloc(((tmsize_t)1)<<depth * sizeof(unsigned short));\n\t\t\t\tif (!blue_tbl) {\n\t\t\t\t\tTIFFError(infilename,\n                                                  \"Can't allocate space for blue component table\");\n\t\t\t\t\t_TIFFfree(clr_tbl);\n\t\t\t\t\tgoto bad3;\n\t\t\t\t}\n\n\t\t\t\tfor(clr = 0; clr < clr_tbl_size; clr++) {\n                                        red_tbl[clr] = 257*clr_tbl[clr*n_clr_elems+2];\n                                        green_tbl[clr] = 257*clr_tbl[clr*n_clr_elems+1];\n                                        blue_tbl[clr] = 257*clr_tbl[clr*n_clr_elems];\n\t\t\t\t}\n\n\t\t\t\t_TIFFfree(clr_tbl);\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\tcase 24:\n\t\t\t\tnbands = 3;\n\t\t\t\tdepth = info_hdr.iBitCount / nbands;\n\t\t\t\tphotometric = PHOTOMETRIC_RGB;\n\t\t\t\tbreak;\n\t\t\tcase 32:\n\t\t\t\tnbands = 3;\n\t\t\t\tdepth = 8;\n\t\t\t\tphotometric = PHOTOMETRIC_RGB;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n                        }\n\n                /* -------------------------------------------------------------------- */\n                /*  Create output file.                                                 */\n                /* -------------------------------------------------------------------- */\n\n\t\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n\t\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, length);\n\t\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, nbands);\n\t\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, depth);\n\t\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\n\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\n\t\t\t     TIFFDefaultStripSize(out, rowsperstrip));\n\t\t\n\t\tif (red_tbl && green_tbl && blue_tbl) {\n\t\t\tTIFFSetField(out, TIFFTAG_COLORMAP,\n\t\t\t\t     red_tbl, green_tbl, blue_tbl);\n\t\t}\n\t\t\n\t\tif (compression == (uint16) -1)\n\t\t\tcompression = COMPRESSION_PACKBITS;\n\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\t\tswitch (compression) {\n\t\tcase COMPRESSION_JPEG:\n\t\t\tif (photometric == PHOTOMETRIC_RGB\n\t\t\t    && jpegcolormode == JPEGCOLORMODE_RGB)\n\t\t\t\tphotometric = PHOTOMETRIC_YCBCR;\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\t\tbreak;\n\t\tcase COMPRESSION_LZW:\n\t\tcase COMPRESSION_DEFLATE:\n\t\t\tif (predictor != 0)\n\t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\t\tbreak;\n\t\t}\n\n                /* -------------------------------------------------------------------- */\n                /*  Read uncompressed image data.                                       */\n                /* -------------------------------------------------------------------- */\n\n\t\tif (info_hdr.iCompression == BMPC_RGB) {\n\t\t\tuint32 offset, size;\n\t\t\tchar *scanbuf;\n\n\t\t\t/* XXX: Avoid integer overflow. We can calculate size\n\t\t\t * in one step using\n\t\t\t *\n\t\t\t *  size = ((width * info_hdr.iBitCount + 31) & ~31) / 8\n\t\t\t *\n\t\t\t * formulae, but we should check for overflow\n\t\t\t * conditions during calculation.\n\t\t\t */\n\t\t\tsize = width * info_hdr.iBitCount + 31;\n\t\t\tif (!width || !info_hdr.iBitCount\n\t\t\t    || (size - 31) / info_hdr.iBitCount != width ) {\n\t\t\t\tTIFFError(infilename,\n\t\t\t\t\t  \"Wrong image parameters; can't \"\n\t\t\t\t\t  \"allocate space for scanline buffer\");\n\t\t\t\tgoto bad3;\n\t\t\t}\n\t\t\tsize = (size & ~31) / 8;\n\n\t\t\tscanbuf = (char *) _TIFFmalloc(size);\n\t\t\tif (!scanbuf) {\n\t\t\t\tTIFFError(infilename,\n                                          \"Can't allocate space for scanline buffer\");\n\t\t\t\tgoto bad3;\n\t\t\t}\n\n\t\t\tfor (row = 0; row < length; row++) {\n\t\t\t\tif (info_hdr.iHeight > 0)\n\t\t\t\t\toffset = file_hdr.iOffBits+(length-row-1)*size;\n\t\t\t\telse\n\t\t\t\t\toffset = file_hdr.iOffBits + row * size;\n\t\t\t\tif (_TIFF_lseek_f(fd, offset, SEEK_SET) == (_TIFF_off_t)-1) {\n\t\t\t\t\tTIFFError(infilename,\n\t\t\t\t\t\t  \"scanline %lu: Seek error\",\n\t\t\t\t\t\t  (unsigned long) row);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (read(fd, scanbuf, size) != (long) size) {\n\t\t\t\t\tTIFFError(infilename,\n\t\t\t\t\t\t  \"scanline %lu: Read error\",\n\t\t\t\t\t\t  (unsigned long) row);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\trearrangePixels(scanbuf, width, info_hdr.iBitCount);\n\n\t\t\t\tif (TIFFWriteScanline(out, scanbuf, row, 0)<0) {\n\t\t\t\t\tTIFFError(infilename,\n\t\t\t\t\t\t  \"scanline %lu: Write error\",\n\t\t\t\t\t\t  (unsigned long) row);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_TIFFfree(scanbuf);\n\n                        /* -------------------------------------------------------------------- */\n                        /*  Read compressed image data.                                         */\n                        /* -------------------------------------------------------------------- */\n\n\t\t} else if ( info_hdr.iCompression == BMPC_RLE8\n\t\t\t    || info_hdr.iCompression == BMPC_RLE4 ) {\n\t\t\tuint32\t\ti, j, k, runlength;\n\t\t\tuint32\t\tcompr_size, uncompr_size;\n\t\t\tunsigned char   *comprbuf;\n\t\t\tunsigned char   *uncomprbuf;\n\n\t\t\tcompr_size = file_hdr.iSize - file_hdr.iOffBits;\n\t\t\tuncompr_size = width * length;\n                        /* Detect int overflow */\n                        if( uncompr_size / width != length ) {\n                                TIFFError(infilename,\n                                          \"Invalid dimensions of BMP file\" );\n                                close(fd);\n                                return -1;\n                        }\n                        if ( (compr_size == 0) ||\n                             (compr_size > ((uint32) ~0) >> 1) ||\n                             (uncompr_size == 0) ||\n                             (uncompr_size > ((uint32) ~0) >> 1) ) {\n                                TIFFError(infilename,\n                                          \"Invalid dimensions of BMP file\" );\n                                close(fd);\n                                return -1;  \n                        }\n\t\t\tcomprbuf = (unsigned char *) _TIFFmalloc( compr_size );\n\t\t\tif (!comprbuf) {\n\t\t\t\tTIFFError(infilename,\n                                          \"Can't allocate space for compressed scanline buffer\");\n\t\t\t\tgoto bad3;\n\t\t\t}\n\t\t\tuncomprbuf = (unsigned char *)_TIFFmalloc(uncompr_size);\n\t\t\tif (!uncomprbuf) {\n\t\t\t\tTIFFError(infilename,\n                                          \"Can't allocate space for uncompressed scanline buffer\");\n\t\t\t\tgoto bad3;\n\t\t\t}\n\n\t\t\tif (_TIFF_lseek_f(fd, file_hdr.iOffBits, SEEK_SET) == (_TIFF_off_t)-1) {\n                                TIFFError(infilename, \"Failed to seek to offset\");\n                                goto bad3;\n                        }\n\t\t\tif ( read(fd, comprbuf, compr_size) != (long) compr_size ) {\n                                TIFFError(infilename, \"Failed to read from file (%s)\",\n                                          strerror(errno));\n                                goto bad;\n                        }\n\t\t\ti = 0;\n\t\t\tj = 0;\n\t\t\tif (info_hdr.iBitCount == 8) {\t\t/* RLE8 */\n                                while(j < uncompr_size && i < compr_size) {\n                                        if ( comprbuf[i] ) {\n                                                runlength = comprbuf[i++];\n                                                while( runlength > 0\n                                                       && j < uncompr_size\n                                                       && i < compr_size ) {\n                                                        uncomprbuf[j++] = comprbuf[i];\n                                                        runlength--;\n                                                }\n                                                i++;\n                                        } else {\n                                                i++;\n                                                if (comprbuf[i] == 0) /* Next scanline */\n                                                        i++;\n                                                else if (comprbuf[i] == 1) /* End of image */\n                                                        break;\n                                                else if (comprbuf[i] == 2) { /* Move to... */\n                                                        i++;\n                                                        if (i < compr_size - 1) {\n                                                                j+=comprbuf[i]+comprbuf[i+1]*width;\n                                                                i += 2;\n                                                        }\n                                                        else\n                                                                break;\n                                                } else {            /* Absolute mode */\n                                                        runlength = comprbuf[i++];\n                                                        for (k = 0; k < runlength && j < uncompr_size && i < compr_size; k++)\n                                                                uncomprbuf[j++] = comprbuf[i++];\n                                                        if ( k & 0x01 )\n                                                                i++;\n                                                }\n                                        }\n                                }\n\t\t\t}\n\t\t\telse {\t\t\t\t    /* RLE4 */\n                                while( j < uncompr_size && i < compr_size ) {\n                                        if ( comprbuf[i] ) {\n                                                runlength = comprbuf[i++];\n                                                while( runlength > 0 && j < uncompr_size && i < compr_size ) {\n                                                        if ( runlength & 0x01 )\n                                                                uncomprbuf[j++] = (comprbuf[i] & 0xF0) >> 4;\n                                                        else\n                                                                uncomprbuf[j++] = comprbuf[i] & 0x0F;\n                                                        runlength--;\n                                                }\n                                                i++;\n                                        } else {\n                                                i++;\n                                                if (comprbuf[i] == 0) /* Next scanline */\n                                                        i++;\n                                                else if (comprbuf[i] == 1) /* End of image */\n                                                        break;\n                                                else if (comprbuf[i] == 2) { /* Move to... */\n                                                        i++;\n                                                        if (i < compr_size - 1) {\n                                                                j+=comprbuf[i]+comprbuf[i+1]*width;\n                                                                i += 2;\n                                                        }\n                                                        else\n                                                                break;\n                                                } else {            /* Absolute mode */\n                                                        runlength = comprbuf[i++];\n                                                        for (k = 0; k < runlength && j < uncompr_size && i < compr_size; k++) {\n                                                                if (k & 0x01)\n                                                                        uncomprbuf[j++] = comprbuf[i++] & 0x0F;\n                                                                else\n                                                                        uncomprbuf[j++] = (comprbuf[i] & 0xF0) >> 4;\n                                                        }\n                                                        if (k & 0x01)\n                                                                i++;\n                                                }\n                                        }\n                                }\n\t\t\t}\n\n\t\t\t_TIFFfree(comprbuf);\n\n\t\t\tfor (row = 0; row < length; row++) {\n\t\t\t\tif (TIFFWriteScanline(out,\n                                                      uncomprbuf + (length - row - 1) * width,\n                                                      row, 0) < 0) {\n\t\t\t\t\tTIFFError(infilename,\n                                                  \"scanline %lu: Write error.\\n\",\n\t\t\t\t\t\t  (unsigned long) row);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_TIFFfree(uncomprbuf);\n\t\t}\n\t\tTIFFWriteDirectory(out);\n\t\tif (blue_tbl) {\n                        _TIFFfree(blue_tbl);\n                        blue_tbl=NULL;\n\t\t}\n\t\tif (green_tbl) {\n                        _TIFFfree(green_tbl);\n                        green_tbl=NULL;\n\t\t}\n\t\tif (red_tbl) {\n                        _TIFFfree(red_tbl);\n                        red_tbl=NULL;\n\t\t}\n\t}\n\n bad3:\n\tif (blue_tbl)\n\t\t_TIFFfree(blue_tbl);\n bad2:\n\tif (green_tbl)\n\t\t_TIFFfree(green_tbl);\n bad1:\n\tif (red_tbl)\n\t\t_TIFFfree(red_tbl);\n bad:\n        close(fd);\n\n\tif (out)\n\t\tTIFFClose(out);\n        return 0;\n}",
          "fn_code_pos": [
            [
              227,
              0
            ],
            [
              814,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nrearrangePixels(char *buf, uint32 width, uint32 bit_count)\n{\n\tchar tmp;\n\tuint32 i;\n\n        switch(bit_count) {\n\t\tcase 16:    /* FIXME: need a sample file */\n                        break;\n                case 24:\n\t\t\tfor (i = 0; i < width; i++, buf += 3) {\n\t\t\t\ttmp = *buf;\n\t\t\t\t*buf = *(buf + 2);\n\t\t\t\t*(buf + 2) = tmp;\n\t\t\t}\n                        break;\n                case 32:\n\t\t\t{\n\t\t\t\tchar\t*buf1 = buf;\n\n\t\t\t\tfor (i = 0; i < width; i++, buf += 4) {\n\t\t\t\t\ttmp = *buf;\n\t\t\t\t\t*buf1++ = *(buf + 2);\n\t\t\t\t\t*buf1++ = *(buf + 1);\n\t\t\t\t\t*buf1++ = tmp;\n\t\t\t\t}\n\t\t\t}\n                        break;\n                default:\n                        break;\n        }\n}",
          "fn_code_pos": [
            [
              820,
              0
            ],
            [
              851,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rearrangePixels",
            "parameters": {
              "buf": "char",
              "width": "uint32",
              "bit_count": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nprocessCompressOptions(char* opt)\n{\n\tif (strcmp(opt, \"none\") == 0)\n\t\tcompression = COMPRESSION_NONE;\n\telse if (strcmp(opt, \"packbits\") == 0)\n\t\tcompression = COMPRESSION_PACKBITS;\n\telse if (strncmp(opt, \"jpeg\", 4) == 0) {\n\t\tchar* cp = strchr(opt, ':');\n\n                compression = COMPRESSION_JPEG;\n                while( cp )\n                {\n                    if (isdigit((int)cp[1]))\n\t\t\tquality = atoi(cp+1);\n                    else if (cp[1] == 'r' )\n\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;\n                    else\n                        usage();\n\n                    cp = strchr(cp+1,':');\n                }\n\t} else if (strncmp(opt, \"lzw\", 3) == 0) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_LZW;\n\t} else if (strncmp(opt, \"zip\", 3) == 0) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_DEFLATE;\n\t} else\n\t\treturn (0);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              853,
              0
            ],
            [
              888,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {
              "opt": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              915,
              0
            ],
            [
              926,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              223,
              12
            ],
            [
              223,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "processCompressOptions(char*)",
          "fn_dec_pos": [
            [
              224,
              11
            ],
            [
              224,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "rearrangePixels(char *, uint32, uint32)",
          "fn_dec_pos": [
            [
              225,
              12
            ],
            [
              225,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rearrangePixels",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct\n{\n    int32   iCIEX;\n    int32   iCIEY;\n    int32   iCIEZ;\n} BMPCIEXYZ;",
          {
            "iCIEX": "int32",
            "iCIEY": "int32",
            "iCIEZ": "int32"
          },
          "BMPCIEXYZ",
          [
            117,
            0
          ],
          [
            122,
            12
          ]
        ],
        [
          "typedef struct                  /* This structure contains the x, y, and z */\n{\t\t\t\t/* coordinates of the three colors that */\n\t\t\t\t/* correspond */\n    BMPCIEXYZ   iCIERed;        /* to the red, green, and blue endpoints for */\n    BMPCIEXYZ   iCIEGreen;      /* a specified logical color space. */\n    BMPCIEXYZ\tiCIEBlue;\n} BMPCIEXYZTriple;",
          {
            "iCIERed": "BMPCIEXYZ",
            "iCIEGreen": "BMPCIEXYZ",
            "iCIEBlue": "BMPCIEXYZ"
          },
          "BMPCIEXYZTriple",
          [
            124,
            0
          ],
          [
            130,
            18
          ]
        ],
        [
          "typedef struct\n{\n    char\tbType[2];       /* Signature \"BM\" */\n    uint32\tiSize;          /* Size in bytes of the bitmap file. Should\n\t\t\t\t * always be ignored while reading because\n\t\t\t\t * of error in Windows 3.0 SDK's description\n\t\t\t\t * of this field */\n    uint16\tiReserved1;     /* Reserved, set as 0 */\n    uint16\tiReserved2;     /* Reserved, set as 0 */\n    uint32\tiOffBits;       /* Offset of the image from file start in bytes */\n} BMPFileHeader;",
          {
            "bType[2]": "char",
            "iSize": "uint32",
            "iReserved1": "uint16",
            "iReserved2": "uint16",
            "iOffBits": "uint32"
          },
          "BMPFileHeader",
          [
            132,
            0
          ],
          [
            142,
            16
          ]
        ],
        [
          "typedef struct\n{\n    uint32\tiSize;          /* Size of BMPInfoHeader structure in bytes.\n\t\t\t\t * Should be used to determine start of the\n\t\t\t\t * colour table */\n    int32\tiWidth;         /* Image width */\n    int32\tiHeight;        /* Image height. If positive, image has bottom\n\t\t\t\t * left origin, if negative --- top left. */\n    int16\tiPlanes;        /* Number of image planes (must be set to 1) */\n    int16\tiBitCount;      /* Number of bits per pixel (1, 4, 8, 16, 24\n\t\t\t\t * or 32). If 0 then the number of bits per\n\t\t\t\t * pixel is specified or is implied by the\n\t\t\t\t * JPEG or PNG format. */\n    uint32\tiCompression;\t/* Compression method */\n    uint32\tiSizeImage;     /* Size of uncomressed image in bytes. May\n\t\t\t\t * be 0 for BMPC_RGB bitmaps. If iCompression\n\t\t\t\t * is BI_JPEG or BI_PNG, iSizeImage indicates\n\t\t\t\t * the size of the JPEG or PNG image buffer. */\n    int32\tiXPelsPerMeter; /* X resolution, pixels per meter (0 if not used) */\n    int32\tiYPelsPerMeter; /* Y resolution, pixels per meter (0 if not used) */\n    uint32\tiClrUsed;       /* Size of colour table. If 0, iBitCount should\n\t\t\t\t * be used to calculate this value\n\t\t\t\t * (1<<iBitCount). This value should be\n\t\t\t\t * unsigned for proper shifting. */\n    int32\tiClrImportant;  /* Number of important colours. If 0, all\n\t\t\t\t * colours are required */\n\n    /*\n     * Fields above should be used for bitmaps, compatible with Windows NT 3.51\n     * and earlier. Windows 98/Me, Windows 2000/XP introduces additional fields:\n     */\n\n    int32\tiRedMask;       /* Colour mask that specifies the red component\n\t\t\t\t * of each pixel, valid only if iCompression\n\t\t\t\t * is set to BI_BITFIELDS. */\n    int32\tiGreenMask;     /* The same for green component */\n    int32\tiBlueMask;      /* The same for blue component */\n    int32\tiAlphaMask;     /* Colour mask that specifies the alpha\n\t\t\t\t * component of each pixel. */\n    uint32\tiCSType;        /* Colour space of the DIB. */\n    BMPCIEXYZTriple sEndpoints; /* This member is ignored unless the iCSType\n\t\t\t\t * member specifies BMPLT_CALIBRATED_RGB. */\n    int32\tiGammaRed;      /* Toned response curve for red. This member\n\t\t\t\t * is ignored unless color values are\n\t\t\t\t * calibrated RGB values and iCSType is set to\n\t\t\t\t * BMPLT_CALIBRATED_RGB. Specified\n\t\t\t\t * in 16^16 format. */\n    int32\tiGammaGreen;    /* Toned response curve for green. */\n    int32\tiGammaBlue;     /* Toned response curve for blue. */\n} BMPInfoHeader;",
          {
            "iSize": "uint32",
            "iWidth": "int32",
            "iHeight": "int32",
            "iPlanes": "int16",
            "iBitCount": "int16",
            "iCompression": "uint32",
            "iSizeImage": "uint32",
            "iXPelsPerMeter": "int32",
            "iYPelsPerMeter": "int32",
            "iClrUsed": "uint32",
            "iClrImportant": "int32",
            "iRedMask": "int32",
            "iGreenMask": "int32",
            "iBlueMask": "int32",
            "iAlphaMask": "int32",
            "iCSType": "uint32",
            "sEndpoints": "BMPCIEXYZTriple",
            "iGammaRed": "int32",
            "iGammaGreen": "int32",
            "iGammaBlue": "int32"
          },
          "BMPInfoHeader",
          [
            147,
            0
          ],
          [
            196,
            16
          ]
        ],
        [
          "typedef struct\n{\n    char       bBlue;\n    char       bGreen;\n    char       bRed;\n    char       bReserved;      /* Must be 0 */\n} BMPColorEntry;",
          {
            "bBlue": "char",
            "bGreen": "char",
            "bRed": "char",
            "bReserved": "char"
          },
          "BMPColorEntry",
          [
            210,
            0
          ],
          [
            216,
            16
          ]
        ],
        [
          "typedef struct\n{\n    int32   iCIEX;\n    int32   iCIEY;\n    int32   iCIEZ;\n} BMPCIEXYZ;",
          {
            "iCIEX": "int32",
            "iCIEY": "int32",
            "iCIEZ": "int32"
          },
          "BMPCIEXYZ",
          [
            117,
            0
          ],
          [
            122,
            12
          ]
        ],
        [
          "typedef struct                  /* This structure contains the x, y, and z */\n{\t\t\t\t/* coordinates of the three colors that */\n\t\t\t\t/* correspond */\n    BMPCIEXYZ   iCIERed;        /* to the red, green, and blue endpoints for */\n    BMPCIEXYZ   iCIEGreen;      /* a specified logical color space. */\n    BMPCIEXYZ\tiCIEBlue;\n} BMPCIEXYZTriple;",
          {
            "iCIERed": "BMPCIEXYZ",
            "iCIEGreen": "BMPCIEXYZ",
            "iCIEBlue": "BMPCIEXYZ"
          },
          "BMPCIEXYZTriple",
          [
            124,
            0
          ],
          [
            130,
            18
          ]
        ],
        [
          "typedef struct\n{\n    char\tbType[2];       /* Signature \"BM\" */\n    uint32\tiSize;          /* Size in bytes of the bitmap file. Should\n\t\t\t\t * always be ignored while reading because\n\t\t\t\t * of error in Windows 3.0 SDK's description\n\t\t\t\t * of this field */\n    uint16\tiReserved1;     /* Reserved, set as 0 */\n    uint16\tiReserved2;     /* Reserved, set as 0 */\n    uint32\tiOffBits;       /* Offset of the image from file start in bytes */\n} BMPFileHeader;",
          {
            "bType[2]": "char",
            "iSize": "uint32",
            "iReserved1": "uint16",
            "iReserved2": "uint16",
            "iOffBits": "uint32"
          },
          "BMPFileHeader",
          [
            132,
            0
          ],
          [
            142,
            16
          ]
        ],
        [
          "typedef struct\n{\n    uint32\tiSize;          /* Size of BMPInfoHeader structure in bytes.\n\t\t\t\t * Should be used to determine start of the\n\t\t\t\t * colour table */\n    int32\tiWidth;         /* Image width */\n    int32\tiHeight;        /* Image height. If positive, image has bottom\n\t\t\t\t * left origin, if negative --- top left. */\n    int16\tiPlanes;        /* Number of image planes (must be set to 1) */\n    int16\tiBitCount;      /* Number of bits per pixel (1, 4, 8, 16, 24\n\t\t\t\t * or 32). If 0 then the number of bits per\n\t\t\t\t * pixel is specified or is implied by the\n\t\t\t\t * JPEG or PNG format. */\n    uint32\tiCompression;\t/* Compression method */\n    uint32\tiSizeImage;     /* Size of uncomressed image in bytes. May\n\t\t\t\t * be 0 for BMPC_RGB bitmaps. If iCompression\n\t\t\t\t * is BI_JPEG or BI_PNG, iSizeImage indicates\n\t\t\t\t * the size of the JPEG or PNG image buffer. */\n    int32\tiXPelsPerMeter; /* X resolution, pixels per meter (0 if not used) */\n    int32\tiYPelsPerMeter; /* Y resolution, pixels per meter (0 if not used) */\n    uint32\tiClrUsed;       /* Size of colour table. If 0, iBitCount should\n\t\t\t\t * be used to calculate this value\n\t\t\t\t * (1<<iBitCount). This value should be\n\t\t\t\t * unsigned for proper shifting. */\n    int32\tiClrImportant;  /* Number of important colours. If 0, all\n\t\t\t\t * colours are required */\n\n    /*\n     * Fields above should be used for bitmaps, compatible with Windows NT 3.51\n     * and earlier. Windows 98/Me, Windows 2000/XP introduces additional fields:\n     */\n\n    int32\tiRedMask;       /* Colour mask that specifies the red component\n\t\t\t\t * of each pixel, valid only if iCompression\n\t\t\t\t * is set to BI_BITFIELDS. */\n    int32\tiGreenMask;     /* The same for green component */\n    int32\tiBlueMask;      /* The same for blue component */\n    int32\tiAlphaMask;     /* Colour mask that specifies the alpha\n\t\t\t\t * component of each pixel. */\n    uint32\tiCSType;        /* Colour space of the DIB. */\n    BMPCIEXYZTriple sEndpoints; /* This member is ignored unless the iCSType\n\t\t\t\t * member specifies BMPLT_CALIBRATED_RGB. */\n    int32\tiGammaRed;      /* Toned response curve for red. This member\n\t\t\t\t * is ignored unless color values are\n\t\t\t\t * calibrated RGB values and iCSType is set to\n\t\t\t\t * BMPLT_CALIBRATED_RGB. Specified\n\t\t\t\t * in 16^16 format. */\n    int32\tiGammaGreen;    /* Toned response curve for green. */\n    int32\tiGammaBlue;     /* Toned response curve for blue. */\n} BMPInfoHeader;",
          {
            "iSize": "uint32",
            "iWidth": "int32",
            "iHeight": "int32",
            "iPlanes": "int16",
            "iBitCount": "int16",
            "iCompression": "uint32",
            "iSizeImage": "uint32",
            "iXPelsPerMeter": "int32",
            "iYPelsPerMeter": "int32",
            "iClrUsed": "uint32",
            "iClrImportant": "int32",
            "iRedMask": "int32",
            "iGreenMask": "int32",
            "iBlueMask": "int32",
            "iAlphaMask": "int32",
            "iCSType": "uint32",
            "sEndpoints": "BMPCIEXYZTriple",
            "iGammaRed": "int32",
            "iGammaGreen": "int32",
            "iGammaBlue": "int32"
          },
          "BMPInfoHeader",
          [
            147,
            0
          ],
          [
            196,
            16
          ]
        ],
        [
          "typedef struct\n{\n    char       bBlue;\n    char       bGreen;\n    char       bRed;\n    char       bReserved;      /* Must be 0 */\n} BMPColorEntry;",
          {
            "bBlue": "char",
            "bGreen": "char",
            "bRed": "char",
            "bReserved": "char"
          },
          "BMPColorEntry",
          [
            210,
            0
          ],
          [
            216,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <sys/stat.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "# include <fcntl.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "# include <sys/types.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "# include <io.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include \"tiffiop.h\"\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "enum BMPType\n{\n    BMPT_WIN4,      /* BMP used in Windows 3.0/NT 3.51/95 */\n    BMPT_WIN5,      /* BMP used in Windows NT 4.0/98/Me/2000/XP */\n    BMPT_OS21,      /* BMP used in OS/2 PM 1.x */\n    BMPT_OS22       /* BMP used in OS/2 PM 2.x */\n}",
          {
            "BMPT_WIN4": "",
            "BMPT_WIN5": "",
            "BMPT_OS21": "",
            "BMPT_OS22": ""
          },
          "BMPType",
          [
            65,
            0
          ],
          [
            71,
            1
          ]
        ],
        [
          "enum BMPComprMethod\n{\n    BMPC_RGB = 0L,          /* Uncompressed */\n    BMPC_RLE8 = 1L,         /* RLE for 8 bpp images */\n    BMPC_RLE4 = 2L,         /* RLE for 4 bpp images */\n    BMPC_BITFIELDS = 3L,    /* Bitmap is not compressed and the colour table\n\t\t\t     * consists of three DWORD color masks that specify\n\t\t\t     * the red, green, and blue components of each\n\t\t\t     * pixel. This is valid when used with\n\t\t\t     * 16- and 32-bpp bitmaps. */\n    BMPC_JPEG = 4L,         /* Indicates that the image is a JPEG image. */\n    BMPC_PNG = 5L           /* Indicates that the image is a PNG image. */\n}",
          {
            "BMPC_RGB": "",
            "BMPC_RLE8": "",
            "BMPC_RLE4": "",
            "BMPC_BITFIELDS": "",
            "BMPC_JPEG": "",
            "BMPC_PNG": ""
          },
          "BMPComprMethod",
          [
            94,
            0
          ],
          [
            106,
            1
          ]
        ],
        [
          "enum BMPLCSType                 /* Type of logical color space. */\n{\n    BMPLT_CALIBRATED_RGB = 0,\t/* This value indicates that endpoints and\n\t\t\t\t * gamma values are given in the appropriate\n\t\t\t\t * fields. */\n    BMPLT_DEVICE_RGB = 1,\n    BMPLT_DEVICE_CMYK = 2\n}",
          {
            "BMPLT_CALIBRATED_RGB": "",
            "BMPLT_DEVICE_RGB": "",
            "BMPLT_DEVICE_CMYK": ""
          },
          "",
          [
            108,
            0
          ],
          [
            115,
            1
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/archive/tools/ras2tiff.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tunsigned char* buf;\n\tlong row;\n\ttsize_t linebytes, scanline;\n\tTIFF *out;\n\tFILE *in;\n\tstruct rasterfile h;\n\tuint16 photometric;\n\tuint16 config = PLANARCONFIG_CONTIG;\n\tuint32 rowsperstrip = (uint32) -1;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"c:r:h\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'c':\t\t/* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* rows/strip */\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind != 2)\n\t\tusage();\n\tin = fopen(argv[optind], \"rb\");\n\tif (in == NULL) {\n\t\tfprintf(stderr, \"%s: Can not open.\\n\", argv[optind]);\n\t\treturn (-1);\n\t}\n\tif (fread(&h, sizeof (h), 1, in) != 1) {\n\t\tfprintf(stderr, \"%s: Can not read header.\\n\", argv[optind]);\n\t\tfclose(in);\n\t\treturn (-2);\n\t}\n\tif (strcmp(h.ras_magic, RAS_MAGIC) == 0) {\n#ifndef WORDS_BIGENDIAN\n\t\t\tTIFFSwabLong((uint32 *)&h.ras_width);\n\t\t\tTIFFSwabLong((uint32 *)&h.ras_height);\n\t\t\tTIFFSwabLong((uint32 *)&h.ras_depth);\n\t\t\tTIFFSwabLong((uint32 *)&h.ras_length);\n\t\t\tTIFFSwabLong((uint32 *)&h.ras_type);\n\t\t\tTIFFSwabLong((uint32 *)&h.ras_maptype);\n\t\t\tTIFFSwabLong((uint32 *)&h.ras_maplength);\n#endif\n\t} else if (strcmp(h.ras_magic, RAS_MAGIC_INV) == 0) {\n#ifdef WORDS_BIGENDIAN\n\t\t\tTIFFSwabLong((uint32 *)&h.ras_width);\n\t\t\tTIFFSwabLong((uint32 *)&h.ras_height);\n\t\t\tTIFFSwabLong((uint32 *)&h.ras_depth);\n\t\t\tTIFFSwabLong((uint32 *)&h.ras_length);\n\t\t\tTIFFSwabLong((uint32 *)&h.ras_type);\n\t\t\tTIFFSwabLong((uint32 *)&h.ras_maptype);\n\t\t\tTIFFSwabLong((uint32 *)&h.ras_maplength);\n#endif\n\t} else {\n\t\tfprintf(stderr, \"%s: Not a rasterfile.\\n\", argv[optind]);\n\t\tfclose(in);\n\t\treturn (-3);\n\t}\n        if ((h.ras_width <= 0) || (h.ras_width >= INT_MAX) ||\n            (h.ras_height <= 0) || (h.ras_height >= INT_MAX) ||\n            (h.ras_depth <= 0) || (h.ras_depth >= INT_MAX) ||\n            (h.ras_length <= 0) || (h.ras_length >= INT_MAX) ||\n            (h.ras_type <= 0) ||\n            (h.ras_maptype <= 0) ||\n            (h.ras_maplength <= 0) || (h.ras_maplength >= INT_MAX)) {\n                fprintf(stderr, \"%s: Improper image header.\\n\", argv[optind]);\n                fclose(in);\n\t\treturn (-2);\n        }\n        if ((h.ras_depth != 1) &&\n            (h.ras_depth != 8) &&\n            (h.ras_depth != 24)) {\n                fprintf(stderr, \"%s: Improper image depth (%d).\\n\",\n                        argv[optind], h.ras_depth);\n                fclose(in);\n\t\treturn (-2);\n        }\n\tout = TIFFOpen(argv[optind+1], \"w\");\n\tif (out == NULL)\n\t{\n\t\tfclose(in);\n\t\treturn (-4);\n\t}\n\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, (uint32) h.ras_width);\n\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, (uint32) h.ras_height);\n\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, h.ras_depth > 8 ? 3 : 1);\n\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, h.ras_depth > 1 ? 8 : 1);\n\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n\tif (h.ras_maptype != RMT_NONE) {\n\t\tuint16* red;\n\t\tregister uint16* map;\n\t\tregister int i, j;\n\t\tint mapsize;\n\n\t\tbuf = (unsigned char *)_TIFFmalloc(h.ras_maplength);\n\t\tif (buf == NULL) {\n\t\t\tfprintf(stderr, \"No space to read in colormap.\\n\");\n\t\t\treturn (-5);\n\t\t}\n\t\tif (fread(buf, h.ras_maplength, 1, in) != 1) {\n\t\t\tfprintf(stderr, \"%s: Read error on colormap.\\n\",\n\t\t\t    argv[optind]);\n\t\t\treturn (-6);\n\t\t}\n\t\tmapsize = 1<<h.ras_depth; \n\t\tif (h.ras_maplength > mapsize*3) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: Huh, %d colormap entries, should be %d?\\n\",\n\t\t\t    argv[optind], h.ras_maplength, mapsize*3);\n\t\t\treturn (-7);\n\t\t}\n\t\tred = (uint16*)_TIFFmalloc(mapsize * 3 * sizeof (uint16));\n\t\tif (red == NULL) {\n\t\t\tfprintf(stderr, \"No space for colormap.\\n\");\n\t\t\treturn (-8);\n\t\t}\n\t\tmap = red;\n\t\tfor (j = 0; j < 3; j++) {\n#define\tSCALE(x)\t(((x)*((1L<<16)-1))/255)\n\t\t\tfor (i = h.ras_maplength/3; i-- > 0;)\n\t\t\t\t*map++ = SCALE(*buf++);\n\t\t\tif ((i = h.ras_maplength/3) < mapsize) {\n\t\t\t\ti = mapsize - i;\n\t\t\t\t_TIFFmemset(map, 0, i*sizeof (uint16));\n\t\t\t\tmap += i;\n\t\t\t}\n\t\t}\n\t\tTIFFSetField(out, TIFFTAG_COLORMAP,\n\t\t     red, red + mapsize, red + 2*mapsize);\n\t\tphotometric = PHOTOMETRIC_PALETTE;\n\t\tif (compression == (uint16) -1)\n\t\t\tcompression = COMPRESSION_PACKBITS;\n\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\t} else {\n\t\t/* XXX this is bogus... */\n\t\tphotometric = h.ras_depth == 24 ?\n\t\t    PHOTOMETRIC_RGB : PHOTOMETRIC_MINISBLACK;\n\t\tif (compression == (uint16) -1)\n\t\t\tcompression = COMPRESSION_LZW;\n\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\t}\n\tswitch (compression) {\n\tcase COMPRESSION_JPEG:\n\t\tif (photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB)\n\t\t\tphotometric = PHOTOMETRIC_YCBCR;\n\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\tbreak;\n\tcase COMPRESSION_LZW:\n\tcase COMPRESSION_DEFLATE:\n\t\tif (predictor != 0)\n\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\tbreak;\n\t}\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\n\tlinebytes = ((h.ras_depth*h.ras_width+15) >> 3) &~ 1;\n\tscanline = TIFFScanlineSize(out);\n\tif (scanline > linebytes) {\n\t\tbuf = (unsigned char *)_TIFFmalloc(scanline);\n\t\t_TIFFmemset(buf+linebytes, 0, scanline-linebytes);\n\t} else\n\t\tbuf = (unsigned char *)_TIFFmalloc(linebytes);\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\n\t    TIFFDefaultStripSize(out, rowsperstrip));\n\tfor (row = 0; row < h.ras_height; row++) {\n\t\tif (fread(buf, linebytes, 1, in) != 1) {\n\t\t\tfprintf(stderr, \"%s: scanline %ld: Read error.\\n\",\n\t\t\t    argv[optind], row);\n\t\t\tbreak;\n\t\t}\n\t\tif (h.ras_type == RT_STANDARD && h.ras_depth == 24) {\n\t\t\ttsize_t cc = h.ras_width;\n\t\t\tunsigned char* cp = buf;\n#define\tSWAP(a,b)\t{ unsigned char t = (a); (a) = (b); (b) = t; }\n\t\t\tdo {\n\t\t\t\tSWAP(cp[0], cp[2]);\n\t\t\t\tcp += 3;\n\t\t\t} while (--cc);\n\t\t}\n\t\tif (TIFFWriteScanline(out, buf, row, 0) < 0)\n\t\t\tbreak;\n\t}\n\t(void) TIFFClose(out);\n\tfclose(in);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              253,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nprocessCompressOptions(char* opt)\n{\n\tif (streq(opt, \"none\"))\n\t\tcompression = COMPRESSION_NONE;\n\telse if (streq(opt, \"packbits\"))\n\t\tcompression = COMPRESSION_PACKBITS;\n\telse if (strneq(opt, \"jpeg\", 4)) {\n\t\tchar* cp = strchr(opt, ':');\n\n                compression = COMPRESSION_JPEG;\n                while( cp )\n                {\n                    if (isdigit((int)cp[1]))\n\t\t\tquality = atoi(cp+1);\n                    else if (cp[1] == 'r' )\n\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;\n                    else\n                        usage();\n\n                    cp = strchr(cp+1,':');\n                }\n\t} else if (strneq(opt, \"lzw\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_LZW;\n\t} else if (strneq(opt, \"zip\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_DEFLATE;\n\t} else\n\t\treturn (0);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              255,
              0
            ],
            [
              290,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {
              "opt": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              315,
              0
            ],
            [
              326,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              54,
              12
            ],
            [
              54,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "processCompressOptions(char*)",
          "fn_dec_pos": [
            [
              55,
              11
            ],
            [
              55,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct rasterfile",
          {},
          "",
          [
            65,
            1
          ],
          [
            65,
            18
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"rasterfile.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/pds/tif_imageiter.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nisCCITTCompression(TIFF* tif)\n{\n    uint16 compress;\n    TIFFGetField(tif, TIFFTAG_COMPRESSION, &compress);\n    return (compress == COMPRESSION_CCITTFAX3 ||\n\t    compress == COMPRESSION_CCITTFAX4 ||\n\t    compress == COMPRESSION_CCITTRLE ||\n\t    compress == COMPRESSION_CCITTRLEW);\n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "isCCITTCompression",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFImageIterBegin(TIFFImageIter* img, TIFF* tif, int stop, char emsg[1024])\n{\n    uint16* sampleinfo;\n    uint16 extrasamples;\n    uint16 planarconfig;\n    int colorchannels;\n\n    img->tif = tif;\n    img->stoponerr = stop;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &img->bitspersample);\n    img->alpha = 0;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\n\t&extrasamples, &sampleinfo);\n    if (extrasamples == 1)\n\tswitch (sampleinfo[0]) {\n\tcase EXTRASAMPLE_ASSOCALPHA:\t/* data is pre-multiplied */\n\tcase EXTRASAMPLE_UNASSALPHA:\t/* data is not pre-multiplied */\n\t    img->alpha = sampleinfo[0];\n\t    break;\n\t}\n    colorchannels = img->samplesperpixel - extrasamples;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarconfig);\n    if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &img->photometric)) {\n\tswitch (colorchannels) {\n\tcase 1:\n\t    if (isCCITTCompression(tif))\n\t\timg->photometric = PHOTOMETRIC_MINISWHITE;\n\t    else\n\t\timg->photometric = PHOTOMETRIC_MINISBLACK;\n\t    break;\n\tcase 3:\n\t    img->photometric = PHOTOMETRIC_RGB;\n\t    break;\n\tdefault:\n\t    sprintf(emsg, \"Missing needed %s tag\", photoTag);\n\t    return (0);\n\t}\n    }\n    switch (img->photometric) {\n    case PHOTOMETRIC_PALETTE:\n\tif (!TIFFGetField(tif, TIFFTAG_COLORMAP,\n\t    &img->redcmap, &img->greencmap, &img->bluecmap)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Missing required \\\"Colormap\\\" tag\");\n\t    return (0);\n\t}\n\t/* fall through... */\n    case PHOTOMETRIC_MINISWHITE:\n    case PHOTOMETRIC_MINISBLACK:\n/* This should work now so skip the check - BSR\n\tif (planarconfig == PLANARCONFIG_CONTIG && img->samplesperpixel != 1) {\n\t    sprintf(emsg,\n\t\t\"Sorry, can not handle contiguous data with %s=%d, and %s=%d\",\n\t\tphotoTag, img->photometric,\n\t\t\"Samples/pixel\", img->samplesperpixel);\n\t    return (0);\n\t}\n */\n\tbreak;\n    case PHOTOMETRIC_YCBCR:\n\tif (planarconfig != PLANARCONFIG_CONTIG) {\n\t    sprintf(emsg, \"Sorry, can not handle YCbCr images with %s=%d\",\n\t\t\"Planarconfiguration\", planarconfig);\n\t    return (0);\n\t}\n\t/* It would probably be nice to have a reality check here. */\n\t{ uint16 compress;\n\t  TIFFGetField(tif, TIFFTAG_COMPRESSION, &compress);\n\t  if (compress == COMPRESSION_JPEG && planarconfig == PLANARCONFIG_CONTIG) {\n\t    /* can rely on libjpeg to convert to RGB */\n\t    /* XXX should restore current state on exit */\n\t    TIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t    img->photometric = PHOTOMETRIC_RGB;\n\t  }\n\t}\n\tbreak;\n    case PHOTOMETRIC_RGB: \n\tif (colorchannels < 3) {\n\t    sprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",\n\t\t\"Color channels\", colorchannels);\n\t    return (0);\n\t}\n\tbreak;\n    case PHOTOMETRIC_SEPARATED: {\n\tuint16 inkset;\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);\n\tif (inkset != INKSET_CMYK) {\n\t    sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",\n\t\t\"InkSet\", inkset);\n\t    return (0);\n\t}\n\tif (img->samplesperpixel != 4) {\n\t    sprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",\n\t\t\"Samples/pixel\", img->samplesperpixel);\n\t    return (0);\n\t}\n\tbreak;\n    }\n    default:\n\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",\n\t    photoTag, img->photometric);\n\treturn (0);\n    }\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &img->width);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &img->height);\n\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ORIENTATION, &img->orientation);\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:\t/* XXX */\n    case ORIENTATION_LEFTBOT:\t/* XXX */\n\tTIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n\timg->orientation = ORIENTATION_BOTLEFT;\n\t/* fall through... */\n    case ORIENTATION_BOTLEFT:\n\tbreak;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:\t/* XXX */\n    case ORIENTATION_LEFTTOP:\t/* XXX */\n    default:\n\tTIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n\timg->orientation = ORIENTATION_TOPLEFT;\n\t/* fall through... */\n    case ORIENTATION_TOPLEFT:\n\tbreak;\n    }\n\n    img->isContig =\n\t!(planarconfig == PLANARCONFIG_SEPARATE && colorchannels > 1);\n    if (img->isContig) {\n\timg->get = TIFFIsTiled(tif) ? gtTileContig : gtStripContig;\n    } else {\n\timg->get = TIFFIsTiled(tif) ? gtTileSeparate : gtStripSeparate;\n    }\n    return (1);\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFImageIterBegin",
            "parameters": {
              "img": "TIFFImageIter",
              "tif": "TIFF",
              "stop": "int",
              "emsg": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nTIFFImageIterGet(TIFFImageIter* img, void *udata, uint32 w, uint32 h)\n{\n    if (img->get == NULL) {\n\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif), \"No \\\"get\\\" routine setup\");\n\treturn (0);\n    }\n    if (img->callback.any == NULL) {\n\tTIFFErrorExt(img->tif->tif_clientdata, TIFFFileName(img->tif),\n\t\t\"No \\\"put\\\" routine setupl; probably can not handle image format\");\n\treturn (0);\n    }\n    return (*img->get)(img, udata, w, h);\n}",
          "fn_code_pos": [
            [
              207,
              0
            ],
            [
              220,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFImageIterGet",
            "parameters": {
              "img": "TIFFImageIter",
              "udata": "void",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFImageIterEnd(TIFFImageIter* img)\n{\n    /* Nothing to free... ? */\n}",
          "fn_code_pos": [
            [
              222,
              0
            ],
            [
              225,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFImageIterEnd",
            "parameters": {
              "img": "TIFFImageIter"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "int\nTIFFReadImageIter(TIFF* tif,\n    uint32 rwidth, uint32 rheight, uint8* raster, int stop)\n{\n    char emsg[1024];\n    TIFFImageIter img;\n    int ok;\n\n    if (TIFFImageIterBegin(&img, tif, stop, emsg)) {\n\t/* XXX verify rwidth and rheight against width and height */\n\tok = TIFFImageIterGet(&img, raster, rwidth, img.height);\n\tTIFFImageIterEnd(&img);\n    } else {\n\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), emsg);\n\tok = 0;\n    }\n    return (ok);\n}",
          "fn_code_pos": [
            [
              230,
              0
            ],
            [
              247,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadImageIter",
            "parameters": {
              "tif": "TIFF",
              "rwidth": "uint32",
              "rheight": "uint32",
              "raster": "uint8",
              "stop": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ngtTileContig(TIFFImageIter* img, void *udata, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    ImageIterTileContigRoutine callback = img->callback.contig;\n    uint16 orientation;\n    uint32 col, row;\n    uint32 tw, th;\n    u_char* buf;\n    int32 fromskew;\n    uint32 nrow;\n\n    buf = (u_char*) _TIFFmalloc(TIFFTileSize(tif));\n    if (buf == 0) {\n\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for tile buffer\");\n\treturn (0);\n    }\n    TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n    orientation = img->orientation;\n    for (row = 0; row < h; row += th) {\n\tnrow = (row + th > h ? h - row : th);\n\tfor (col = 0; col < w; col += tw) {\n\t    if (TIFFReadTile(tif, buf, col, row, 0, 0) < 0 && img->stoponerr)\n\t\tbreak;\n\t    if (col + tw > w) {\n\t\t/*\n\t\t * Tile is clipped horizontally.  Calculate\n\t\t * visible portion and skewing factors.\n\t\t */\n\t\tuint32 npix = w - col;\n\t\tfromskew = tw - npix;\n\t\t(*callback)(img, udata, col, row, npix, nrow, fromskew, buf);\n\t    } else {\n\t\t(*callback)(img, udata, col, row, tw, nrow, 0, buf);\n\t    }\n\t}\n    }\n    _TIFFfree(buf);\n    return (1);\n}",
          "fn_code_pos": [
            [
              256,
              0
            ],
            [
              296,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gtTileContig",
            "parameters": {
              "img": "TIFFImageIter",
              "udata": "void",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ngtTileSeparate(TIFFImageIter* img, void *udata, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    ImageIterTileSeparateRoutine callback = img->callback.separate;\n    uint16 orientation;\n    uint32 col, row;\n    uint32 tw, th;\n    u_char* buf;\n    u_char* r;\n    u_char* g;\n    u_char* b;\n    u_char* a;\n    tsize_t tilesize;\n    int32 fromskew;\n    int alpha = img->alpha;\n    uint32 nrow;\n\n    tilesize = TIFFTileSize(tif);\n    buf = (u_char*) _TIFFmalloc(4*tilesize);\n    if (buf == 0) {\n\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for tile buffer\");\n\treturn (0);\n    }\n    r = buf;\n    g = r + tilesize;\n    b = g + tilesize;\n    a = b + tilesize;\n    if (!alpha)\n\tmemset(a, 0xff, tilesize);\n    TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n    orientation = img->orientation;\n    for (row = 0; row < h; row += th) {\n\tnrow = (row + th > h ? h - row : th);\n\tfor (col = 0; col < w; col += tw) {\n\t    if (TIFFReadTile(tif, r, col, row,0,0) < 0 && img->stoponerr)\n\t\tbreak;\n\t    if (TIFFReadTile(tif, g, col, row,0,1) < 0 && img->stoponerr)\n\t\tbreak;\n\t    if (TIFFReadTile(tif, b, col, row,0,2) < 0 && img->stoponerr)\n\t\tbreak;\n\t    if (alpha && TIFFReadTile(tif,a,col,row,0,3) < 0 && img->stoponerr)\n\t\tbreak;\n\t    if (col + tw > w) {\n\t\t/*\n\t\t * Tile is clipped horizontally.  Calculate\n\t\t * visible portion and skewing factors.\n\t\t */\n\t\tuint32 npix = w - col;\n\t\tfromskew = tw - npix;\n\t\t(*callback)(img, udata, col, row, npix, nrow, fromskew, r, g, b, a);\n\t    } else {\n\t\t(*callback)(img, udata, col, row, tw, nrow, 0, r, g, b, a);\n\t    }\n\t}\n    }\n    _TIFFfree(buf);\n    return (1);\n}",
          "fn_code_pos": [
            [
              304,
              0
            ],
            [
              363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gtTileSeparate",
            "parameters": {
              "img": "TIFFImageIter",
              "udata": "void",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ngtStripContig(TIFFImageIter* img, void *udata, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    ImageIterTileContigRoutine callback = img->callback.contig;\n    uint16 orientation;\n    uint32 row, nrow;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n\treturn (0);\n    }\n    orientation = img->orientation;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0);\n    for (row = 0; row < h; row += rowsperstrip) {\n\tnrow = (row + rowsperstrip > h ? h - row : rowsperstrip);\n\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 0),\n\t    buf, nrow*scanline) < 0 && img->stoponerr)\n\t\tbreak;\n\t(*callback)(img, udata, 0, row, w, nrow, fromskew, buf);\n    }\n    _TIFFfree(buf);\n    return (1);\n}",
          "fn_code_pos": [
            [
              371,
              0
            ],
            [
              402,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gtStripContig",
            "parameters": {
              "img": "TIFFImageIter",
              "udata": "void",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ngtStripSeparate(TIFFImageIter* img, void *udata, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    ImageIterTileSeparateRoutine callback = img->callback.separate;\n    uint16 orientation;\n    u_char *buf;\n    u_char *r, *g, *b, *a;\n    uint32 row, nrow;\n    tsize_t scanline;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t stripsize;\n    int32 fromskew;\n    int alpha = img->alpha;\n\n    stripsize = TIFFStripSize(tif);\n    r = buf = (u_char *)_TIFFmalloc(4*stripsize);\n    if (buf == 0) {\n\tTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for tile buffer\");\n\treturn (0);\n    }\n    g = r + stripsize;\n    b = g + stripsize;\n    a = b + stripsize;\n    if (!alpha)\n\tmemset(a, 0xff, stripsize);\n    orientation = img->orientation;\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0);\n    for (row = 0; row < h; row += rowsperstrip) {\n\tnrow = (row + rowsperstrip > h ? h - row : rowsperstrip);\n\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 0),\n\t    r, nrow*scanline) < 0 && img->stoponerr)\n\t    break;\n\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 1),\n\t    g, nrow*scanline) < 0 && img->stoponerr)\n\t    break;\n\tif (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 2),\n\t    b, nrow*scanline) < 0 && img->stoponerr)\n\t    break;\n\tif (alpha &&\n\t    (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 3),\n\t    a, nrow*scanline) < 0 && img->stoponerr))\n\t    break;\n\t(*callback)(img, udata, 0, row, w, nrow, fromskew, r, g, b, a);\n    }\n    _TIFFfree(buf);\n    return (1);\n}",
          "fn_code_pos": [
            [
              410,
              0
            ],
            [
              460,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gtStripSeparate",
            "parameters": {
              "img": "TIFFImageIter",
              "udata": "void",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "DECLAREContigCallbackFunc(TestContigCallback)\n{\n    printf(\"Contig Callback called with x = %d, y = %d, w = %d, h = %d, fromskew = %d\\n\",\n\t   x, y, w, h, fromskew);\n}",
          "fn_code_pos": [
            [
              462,
              0
            ],
            [
              466,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigCallbackFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLARESepCallbackFunc(TestSepCallback)\n{\n    printf(\"Sep Callback called with x = %d, y = %d, w = %d, h = %d, fromskew = %d\\n\",\n\t   x, y, w, h, fromskew);\n}",
          "fn_code_pos": [
            [
              469,
              0
            ],
            [
              473,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLARESepCallbackFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "main(int argc, char **argv)\n{\n    char emsg[1024];\n    TIFFImageIter img;\n    int ok;\n    int stop = 1;\n\n    TIFF *tif;\n    unsigned long nx, ny;\n    unsigned short BitsPerSample, SamplesPerPixel;\n    int isColorMapped, isPliFile;\n    unsigned char *ColorMap;\n    unsigned char *data;\n\n    if (argc < 2) {\n\tfprintf(stderr,\"usage: %s tiff_file\\n\",argv[0]);\n\texit(1);\n    }\n    tif = (TIFF *)PLIGetImage(argv[1], (void *) &data, &ColorMap, \n\t\t\t      &nx, &ny, &BitsPerSample, &SamplesPerPixel, \n\t\t\t      &isColorMapped, &isPliFile);\n    if (tif != NULL) {\n\n\tif (TIFFImageIterBegin(&img, tif, stop, emsg)) {\n\t    /* Here need to set data and callback function! */\n\t    if (img.isContig) {\n\t\timg.callback = TestContigCallback;\n\t    } else {\n\t\timg.callback = TestSepCallback;\n\t    }\n\t    ok = TIFFImageIterGet(&img, NULL, img.width, img.height);\n\t    TIFFImageIterEnd(&img);\n\t} else {\n\t    TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), emsg);\n\t}\n    }\n    \n}",
          "fn_code_pos": [
            [
              477,
              0
            ],
            [
              514,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "gtTileContig(TIFFImageIter*, void *udata, uint32, uint32)",
          "fn_dec_pos": [
            [
              51,
              11
            ],
            [
              51,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gtTileContig",
            "parameters": {
              "udata": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "gtTileSeparate(TIFFImageIter*, void *udata, uint32, uint32)",
          "fn_dec_pos": [
            [
              52,
              11
            ],
            [
              52,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gtTileSeparate",
            "parameters": {
              "udata": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "gtStripContig(TIFFImageIter*, void *udata, uint32, uint32)",
          "fn_dec_pos": [
            [
              53,
              11
            ],
            [
              53,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gtStripContig",
            "parameters": {
              "udata": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "gtStripSeparate(TIFFImageIter*, void *udata, uint32, uint32)",
          "fn_dec_pos": [
            [
              54,
              11
            ],
            [
              54,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "gtStripSeparate",
            "parameters": {
              "udata": "void"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include \"tif_imageiter.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/pds/tif_pdsdirread.c": {
      "fn_def_list": [
        {
          "fn_code": "static char *\nCheckMalloc(TIFF* tif, tsize_t n, const char* what)\n{\n\tchar *cp = (char*)_TIFFmalloc(n);\n\tif (cp == NULL)\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"No space %s\", what);\n\treturn (cp);\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              91,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMalloc",
            "parameters": {
              "tif": "TIFF",
              "n": "tsize_t",
              "what": "char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int\nTIFFReadPrivateDataSubDirectory(TIFF* tif, toff_t pdir_offset,\n\t\t\t\tTIFFFieldInfo *field_info,\n\t\t\t\tint (*setFieldFn)(TIFF *tif, ttag_t tag, ...))\n{\n\tregister TIFFDirEntry* dp;\n\tregister int n;\n\tregister TIFFDirectory* td;\n\tTIFFDirEntry* dir;\n\tint iv;\n\tlong v;\n\tdouble dv;\n\tconst TIFFFieldInfo* fip;\n\tint fix;\n\tuint16 dircount;\n\tuint32 nextdiroff;\n\tchar* cp;\n\tint diroutoforderwarning = 0;\n\n\t/* Skipped part about checking for directories or compression data. */\n\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif, pdir_offset)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t    \"Seek error accessing TIFF private subdirectory\");\n\t\t\treturn (0);\n\t\t}\n\t\tif (!ReadOK(tif, &dircount, sizeof (uint16))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t    \"Can not read TIFF private subdirectory count\");\n\t\t\treturn (0);\n\t\t}\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabShort(&dircount);\n\t\tdir = (TIFFDirEntry *)CheckMalloc(tif,\n\t\t    dircount * sizeof (TIFFDirEntry), \"to read TIFF private subdirectory\");\n\t\tif (dir == NULL)\n\t\t\treturn (0);\n\t\tif (!ReadOK(tif, dir, dircount*sizeof (TIFFDirEntry))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Can not read TIFF private subdirectory\");\n\t\t\tgoto bad;\n\t\t}\n\t\t/*\n\t\t * Read offset to next directory for sequential scans.\n\t\t */\n\t\t(void) ReadOK(tif, &nextdiroff, sizeof (uint32));\n\t} else {\n\t\ttoff_t off = pdir_offset;\n\n\t\tif (off + sizeof (short) > tif->tif_size) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t    \"Can not read TIFF private subdirectory count\");\n\t\t\treturn (0);\n\t\t} else\n\t\t\t_TIFFmemcpy(&dircount, tif->tif_base + off, sizeof (uint16));\n\t\toff += sizeof (uint16);\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabShort(&dircount);\n\t\tdir = (TIFFDirEntry *)CheckMalloc(tif,\n\t\t    dircount * sizeof (TIFFDirEntry), \"to read TIFF private subdirectory\");\n\t\tif (dir == NULL)\n\t\t\treturn (0);\n\t\tif (off + dircount*sizeof (TIFFDirEntry) > tif->tif_size) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Can not read TIFF private subdirectory\");\n\t\t\tgoto bad;\n\t\t} else\n\t\t\t_TIFFmemcpy(dir, tif->tif_base + off,\n\t\t\t    dircount*sizeof (TIFFDirEntry));\n\t\toff += dircount* sizeof (TIFFDirEntry);\n\t\tif (off + sizeof (uint32) < tif->tif_size)\n\t\t\t_TIFFmemcpy(&nextdiroff, tif->tif_base+off, sizeof (uint32));\n\t}\n\tif (tif->tif_flags & TIFF_SWAB)\n\t\tTIFFSwabLong(&nextdiroff);\n\n\t/*\n\t * Setup default value and then make a pass over\n\t * the fields to check type and tag information,\n\t * and to extract info required to size data\n\t * structures.  A second pass is made afterwards\n\t * to read in everything not taken in the first pass.\n\t */\n\ttd = &tif->tif_dir;\n\t\n\tfor (fip = field_info, dp = dir, n = dircount;\n\t     n > 0; n--, dp++) {\n\t\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t\tTIFFSwabArrayOfShort(&dp->tdir_tag, 2);\n\t\t\tTIFFSwabArrayOfLong(&dp->tdir_count, 2);\n\t\t}\n\t\t/*\n\t\t * Find the field information entry for this tag.\n\t\t */\n\t\t/*\n\t\t * Silicon Beach (at least) writes unordered\n\t\t * directory tags (violating the spec).  Handle\n\t\t * it here, but be obnoxious (maybe they'll fix it?).\n\t\t */\n\t\tif (dp->tdir_tag < fip->field_tag) {\n\t\t\tif (!diroutoforderwarning) {\n\t\t\t\tTIFFWarning(tif->tif_name,\n\t\"invalid TIFF private subdirectory; tags are not sorted in ascending order\");\n\t\t\t\tdiroutoforderwarning = 1;\n\t\t\t}\n\t\t\tfip = field_info;    /* O(n^2) */\n\t\t}\n\n\t\twhile (fip->field_tag && fip->field_tag < dp->tdir_tag)\n\t\t\tfip++;\n\t\tif (!fip->field_tag || fip->field_tag != dp->tdir_tag) {\n\t\t\tTIFFWarning(tif->tif_name,\n\t\t\t    \"unknown field with tag %d (0x%x) in private subdirectory ignored\",\n\t\t\t    dp->tdir_tag,  dp->tdir_tag);\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tfip = field_info;/* restart search */\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Null out old tags that we ignore.\n\t\t */\n\n\t\t/* Not implemented yet, since FIELD_IGNORE is specific to\n\t\t   the main directories. Could pass this in too... */\n\t\tif (0 /* && fip->field_bit == FIELD_IGNORE */) {\n\tignore:\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check data type.\n\t\t */\n\n\t\twhile (dp->tdir_type != (u_short)fip->field_type) {\n\t\t\tif (fip->field_type == TIFF_ANY)\t/* wildcard */\n\t\t\t\tbreak;\n\t\t\tfip++;\n\t\t\tif (!fip->field_tag || fip->field_tag != dp->tdir_tag) {\n\t\t\t\tTIFFWarning(tif->tif_name,\n\t\t\t\t   \"wrong data type %d for \\\"%s\\\"; tag ignored\",\n\t\t\t\t    dp->tdir_type, fip[-1].field_name);\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Check count if known in advance.\n\t\t */\n\t\tif (fip->field_readcount != TIFF_VARIABLE) {\n\t\t\tuint32 expected = (fip->field_readcount == TIFF_SPP) ?\n\t\t\t    (uint32) td->td_samplesperpixel :\n\t\t\t    (uint32) fip->field_readcount;\n\t\t\tif (!CheckDirCount(tif, dp, expected))\n\t\t\t\tgoto ignore;\n\t\t}\n\n\t\t/* Now read in and process data from field. */\n\t\tif (!TIFFFetchNormalSubTag(tif, dp, fip, setFieldFn))\n\t\t    goto bad;\n\n\t}\n\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn (1);\nbad:\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadPrivateDataSubDirectory",
            "parameters": {
              "tif": "TIFF",
              "pdir_offset": "toff_t",
              "field_info": "TIFFFieldInfo",
              "setFieldFn": "int",
              "tag": "ttag_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nEstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)\n{\n\tregister TIFFDirEntry *dp;\n\tregister TIFFDirectory *td = &tif->tif_dir;\n\tuint16 i;\n\n\tif (td->td_stripbytecount)\n\t\t_TIFFfree(td->td_stripbytecount);\n\ttd->td_stripbytecount = (uint32*)\n\t    CheckMalloc(tif, td->td_nstrips * sizeof (uint32),\n\t\t\"for \\\"StripByteCounts\\\" array\");\n\tif (td->td_compression != COMPRESSION_NONE) {\n\t\tuint32 space = (uint32)(sizeof (TIFFHeader)\n\t\t    + sizeof (uint16)\n\t\t    + (dircount * sizeof (TIFFDirEntry))\n\t\t    + sizeof (uint32));\n\t\ttoff_t filesize = TIFFGetFileSize(tif);\n\t\tuint16 n;\n\n\t\t/* calculate amount of space used by indirect values */\n\t\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\n\t\t\tuint32 cc = dp->tdir_count*TIFFDataWidth(dp->tdir_type);\n\t\t\tif (cc > sizeof (uint32))\n\t\t\t\tspace += cc;\n\t\t}\n\t\tspace = (filesize - space) / td->td_samplesperpixel;\n\t\tfor (i = 0; i < td->td_nstrips; i++)\n\t\t\ttd->td_stripbytecount[i] = space;\n\t\t/*\n\t\t * This gross hack handles the case were the offset to\n\t\t * the last strip is past the place where we think the strip\n\t\t * should begin.  Since a strip of data must be contiguous,\n\t\t * it's safe to assume that we've overestimated the amount\n\t\t * of data in the strip and trim this number back accordingly.\n\t\t */ \n\t\ti--;\n\t\tif (td->td_stripoffset[i] + td->td_stripbytecount[i] > filesize)\n\t\t\ttd->td_stripbytecount[i] =\n\t\t\t    filesize - td->td_stripoffset[i];\n\t} else {\n\t\tuint32 rowbytes = TIFFScanlineSize(tif);\n\t\tuint32 rowsperstrip = td->td_imagelength / td->td_nstrips;\n\t\tfor (i = 0; i < td->td_nstrips; i++)\n\t\t\ttd->td_stripbytecount[i] = rowbytes*rowsperstrip;\n\t}\n\tTIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);\n\tif (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP))\n\t\ttd->td_rowsperstrip = td->td_imagelength;\n}",
          "fn_code_pos": [
            [
              284,
              0
            ],
            [
              333,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EstimateStripByteCounts",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "dircount": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nMissingRequired(TIFF* tif, const char* tagname)\n{\n\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t    \"TIFF directory is missing required \\\"%s\\\" field\", tagname);\n}",
          "fn_code_pos": [
            [
              335,
              0
            ],
            [
              340,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MissingRequired",
            "parameters": {
              "tif": "TIFF",
              "tagname": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nCheckDirCount(TIFF* tif, TIFFDirEntry* dir, uint32 count)\n{\n\tif (count != dir->tdir_count) {\n\t\tTIFFWarning(tif->tif_name,\n\t\"incorrect count for field \\\"%s\\\" (%lu, expecting %lu); tag ignored\",\n\t\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name,\n\t\t    dir->tdir_count, count);\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              348,
              0
            ],
            [
              359,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckDirCount",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "count": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static tsize_t\nTIFFFetchData(TIFF* tif, TIFFDirEntry* dir, char* cp)\n{\n\tint w = TIFFDataWidth(dir->tdir_type);\n\ttsize_t cc = dir->tdir_count * w;\n\n\tif (!isMapped(tif)) {\n\t\tif (!SeekOK(tif, dir->tdir_offset))\n\t\t\tgoto bad;\n\t\tif (!ReadOK(tif, cp, cc))\n\t\t\tgoto bad;\n\t} else {\n\t\tif (dir->tdir_offset + cc > tif->tif_size)\n\t\t\tgoto bad;\n\t\t_TIFFmemcpy(cp, tif->tif_base + dir->tdir_offset, cc);\n\t}\n\tif (tif->tif_flags & TIFF_SWAB) {\n\t\tswitch (dir->tdir_type) {\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\tTIFFSwabArrayOfShort((uint16*) cp, dir->tdir_count);\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_FLOAT:\n\t\t\tTIFFSwabArrayOfLong((uint32*) cp, dir->tdir_count);\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\t\tTIFFSwabArrayOfLong((uint32*) cp, 2*dir->tdir_count);\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\tTIFFSwabArrayOfDouble((double*) cp, dir->tdir_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (cc);\nbad:\n\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error fetching data for field \\\"%s\\\"\",\n\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\treturn ((tsize_t) 0);\n}",
          "fn_code_pos": [
            [
              364,
              0
            ],
            [
              405,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchData",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "cp": "char"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "static tsize_t\nTIFFFetchString(TIFF* tif, TIFFDirEntry* dir, char* cp)\n{\n\tif (dir->tdir_count <= 4) {\n\t\tuint32 l = dir->tdir_offset;\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong(&l);\n\t\t_TIFFmemcpy(cp, &l, dir->tdir_count);\n\t\treturn (1);\n\t}\n\treturn (TIFFFetchData(tif, dir, cp));\n}",
          "fn_code_pos": [
            [
              410,
              0
            ],
            [
              421,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchString",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "cp": "char"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "static int\ncvtRational(TIFF* tif, TIFFDirEntry* dir, uint32 num, uint32 denom, float* rv)\n{\n\tif (denom == 0) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t    \"%s: Rational with zero denominator (num = %lu)\",\n\t\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name, num);\n\t\treturn (0);\n\t} else {\n\t\tif (dir->tdir_type == TIFF_RATIONAL)\n\t\t\t*rv = ((float)num / (float)denom);\n\t\telse\n\t\t\t*rv = ((float)(int32)num / (float)(int32)denom);\n\t\treturn (1);\n\t}\n}",
          "fn_code_pos": [
            [
              426,
              0
            ],
            [
              441,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cvtRational",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "num": "uint32",
              "denom": "uint32",
              "rv": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static float\nTIFFFetchRational(TIFF* tif, TIFFDirEntry* dir)\n{\n\tuint32 l[2];\n\tfloat v;\n\n\treturn (!TIFFFetchData(tif, dir, (char *)l) ||\n\t    !cvtRational(tif, dir, l[0], l[1], &v) ? 1.0f : v);\n}",
          "fn_code_pos": [
            [
              448,
              0
            ],
            [
              456,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchRational",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry"
            },
            "return_type": "float"
          }
        },
        {
          "fn_code": "static float\nTIFFFetchFloat(TIFF* tif, TIFFDirEntry* dir)\n{\n\t/* This appears to be a flagrant bug in the TIFF library, yet I\n\t   actually don't understand how it could have ever worked the old\n\t   way. Look at the comments in my new code and you'll understand. */\n#if (0)\n\tfloat v = (float)\n\t    TIFFExtractData(tif, dir->tdir_type, dir->tdir_offset);\n\tTIFFCvtIEEEFloatToNative(tif, 1, &v);\n#else\n\tfloat v;\n\t/* This is a little bit tricky - if we just cast the uint32 to a float,\n\t   C will perform a numerical conversion, which is not what we want.\n\t   We want to take the actual bit pattern in the uint32 and interpret\n\t   it as a float. Thus we cast a uint32 * into a float * and then\n\t   dereference to get v. */\n\tuint32 l = (uint32)\n\t    TIFFExtractData(tif, dir->tdir_type, dir->tdir_offset);\n\tv = * (float *) &l;\n\tTIFFCvtIEEEFloatToNative(tif, 1, &v);\n#endif\n\treturn (v);\n\n}",
          "fn_code_pos": [
            [
              463,
              0
            ],
            [
              487,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchFloat",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry"
            },
            "return_type": "float"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchByteArray(TIFF* tif, TIFFDirEntry* dir, uint16* v)\n{\n\tif (dir->tdir_count <= 4) {\n\t\t/*\n\t\t * Extract data from offset field.\n\t\t */\n\t\tif (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {\n\t\t\tswitch (dir->tdir_count) {\n\t\t\tcase 4: v[3] = dir->tdir_offset & 0xff;\n\t\t\tcase 3: v[2] = (dir->tdir_offset >> 8) & 0xff;\n\t\t\tcase 2: v[1] = (dir->tdir_offset >> 16) & 0xff;\n\t\t\tcase 1: v[0] = dir->tdir_offset >> 24;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (dir->tdir_count) {\n\t\t\tcase 4: v[3] = dir->tdir_offset >> 24;\n\t\t\tcase 3: v[2] = (dir->tdir_offset >> 16) & 0xff;\n\t\t\tcase 2: v[1] = (dir->tdir_offset >> 8) & 0xff;\n\t\t\tcase 1: v[0] = dir->tdir_offset & 0xff;\n\t\t\t}\n\t\t}\n\t\treturn (1);\n\t} else\n\t\treturn (TIFFFetchData(tif, dir, (char*) v) != 0);\t/* XXX */\n}",
          "fn_code_pos": [
            [
              492,
              0
            ],
            [
              517,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchByteArray",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "v": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchShortArray(TIFF* tif, TIFFDirEntry* dir, uint16* v)\n{\n\tif (dir->tdir_count <= 2) {\n\t\tif (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {\n\t\t\tswitch (dir->tdir_count) {\n\t\t\tcase 2: v[1] = dir->tdir_offset & 0xffff;\n\t\t\tcase 1: v[0] = dir->tdir_offset >> 16;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (dir->tdir_count) {\n\t\t\tcase 2: v[1] = dir->tdir_offset >> 16;\n\t\t\tcase 1: v[0] = dir->tdir_offset & 0xffff;\n\t\t\t}\n\t\t}\n\t\treturn (1);\n\t} else\n\t\treturn (TIFFFetchData(tif, dir, (char *)v) != 0);\n}",
          "fn_code_pos": [
            [
              522,
              0
            ],
            [
              540,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchShortArray",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "v": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchShortPair(TIFF* tif, TIFFDirEntry* dir)\n{\n\tuint16 v[2];\n\tint ok = 0;\n\n\tswitch (dir->tdir_type) {\n\tcase TIFF_SHORT:\n\tcase TIFF_SSHORT:\n\t\tok = TIFFFetchShortArray(tif, dir, v);\n\t\tbreak;\n\tcase TIFF_BYTE:\n\tcase TIFF_SBYTE:\n\t\tok  = TIFFFetchByteArray(tif, dir, v);\n\t\tbreak;\n\t}\n\tif (ok)\n\t\tTIFFSetField(tif, dir->tdir_tag, v[0], v[1]);\n\treturn (ok);\n}",
          "fn_code_pos": [
            [
              545,
              0
            ],
            [
              564,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchShortPair",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchLongArray(TIFF* tif, TIFFDirEntry* dir, uint32* v)\n{\n\tif (dir->tdir_count == 1) {\n\t\tv[0] = dir->tdir_offset;\n\t\treturn (1);\n\t} else\n\t\treturn (TIFFFetchData(tif, dir, (char*) v) != 0);\n}",
          "fn_code_pos": [
            [
              569,
              0
            ],
            [
              577,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchLongArray",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "v": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchRationalArray(TIFF* tif, TIFFDirEntry* dir, float* v)\n{\n\tint ok = 0;\n\tuint32* l;\n\n\tl = (uint32*)CheckMalloc(tif,\n\t    dir->tdir_count*TIFFDataWidth(dir->tdir_type),\n\t    \"to fetch array of rationals\");\n\tif (l) {\n\t\tif (TIFFFetchData(tif, dir, (char *)l)) {\n\t\t\tuint32 i;\n\t\t\tfor (i = 0; i < dir->tdir_count; i++) {\n\t\t\t\tok = cvtRational(tif, dir,\n\t\t\t\t    l[2*i+0], l[2*i+1], &v[i]);\n\t\t\t\tif (!ok)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t_TIFFfree((char *)l);\n\t}\n\treturn (ok);\n}",
          "fn_code_pos": [
            [
              582,
              0
            ],
            [
              604,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchRationalArray",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "v": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchFloatArray(TIFF* tif, TIFFDirEntry* dir, float* v)\n{\n\n\tif (dir->tdir_count == 1) {\n\t\tv[0] = *(float*) &dir->tdir_offset;\n\t\tTIFFCvtIEEEFloatToNative(tif, dir->tdir_count, v);\n\t\treturn (1);\n\t} else\tif (TIFFFetchData(tif, dir, (char*) v)) {\n\t\tTIFFCvtIEEEFloatToNative(tif, dir->tdir_count, v);\n\t\treturn (1);\n\t} else\n\t\treturn (0);\n}",
          "fn_code_pos": [
            [
              609,
              0
            ],
            [
              622,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchFloatArray",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "v": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchDoubleArray(TIFF* tif, TIFFDirEntry* dir, double* v)\n{\n\tif (TIFFFetchData(tif, dir, (char*) v)) {\n\t\tTIFFCvtIEEEDoubleToNative(tif, dir->tdir_count, v);\n\t\treturn (1);\n\t} else\n\t\treturn (0);\n}",
          "fn_code_pos": [
            [
              627,
              0
            ],
            [
              635,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchDoubleArray",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "v": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchAnyArray(TIFF* tif, TIFFDirEntry* dir, double* v)\n{\n\tint i;\n\n\tswitch (dir->tdir_type) {\n\tcase TIFF_BYTE:\n\tcase TIFF_SBYTE:\n\t\tif (!TIFFFetchByteArray(tif, dir, (uint16*) v))\n\t\t\treturn (0);\n\t\tif (dir->tdir_type == TIFF_BYTE) {\n\t\t\tuint16* vp = (uint16*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t} else {\n\t\t\tint16* vp = (int16*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t}\n\t\tbreak;\n\tcase TIFF_SHORT:\n\tcase TIFF_SSHORT:\n\t\tif (!TIFFFetchShortArray(tif, dir, (uint16*) v))\n\t\t\treturn (0);\n\t\tif (dir->tdir_type == TIFF_SHORT) {\n\t\t\tuint16* vp = (uint16*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t} else {\n\t\t\tint16* vp = (int16*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t}\n\t\tbreak;\n\tcase TIFF_LONG:\n\tcase TIFF_SLONG:\n\t\tif (!TIFFFetchLongArray(tif, dir, (uint32*) v))\n\t\t\treturn (0);\n\t\tif (dir->tdir_type == TIFF_LONG) {\n\t\t\tuint32* vp = (uint32*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t} else {\n\t\t\tint32* vp = (int32*) v;\n\t\t\tfor (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\t\tv[i] = vp[i];\n\t\t}\n\t\tbreak;\n\tcase TIFF_RATIONAL:\n\tcase TIFF_SRATIONAL:\n\t\tif (!TIFFFetchRationalArray(tif, dir, (float*) v))\n\t\t\treturn (0);\n\t\t{ float* vp = (float*) v;\n\t\t  for (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\tv[i] = vp[i];\n\t\t}\n\t\tbreak;\n\tcase TIFF_FLOAT:\n\t\tif (!TIFFFetchFloatArray(tif, dir, (float*) v))\n\t\t\treturn (0);\n\t\t{ float* vp = (float*) v;\n\t\t  for (i = dir->tdir_count-1; i >= 0; i--)\n\t\t\tv[i] = vp[i];\n\t\t}\n\t\tbreak;\n\tcase TIFF_DOUBLE:\n\t\treturn (TIFFFetchDoubleArray(tif, dir, (double*) v));\n\tdefault:\n\t\t/* TIFF_NOTYPE */\n\t\t/* TIFF_ASCII */\n\t\t/* TIFF_UNDEFINED */\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t    \"Cannot read TIFF_ANY type %d for field \\\"%s\\\"\",\n\t\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              648,
              0
            ],
            [
              725,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchAnyArray",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "v": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchNormalSubTag(TIFF* tif, TIFFDirEntry* dp, const TIFFFieldInfo* fip,\n\t\t      int (*setFieldFn)(TIFF *tif, ttag_t tag, ...))\n{\n\tstatic char mesg[] = \"to fetch tag value\";\n\tint ok = 0;\n\n\tif (dp->tdir_count > 1) {\t\t/* array of values */\n\t\tchar* cp = NULL;\n\n\t\tswitch (dp->tdir_type) {\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\t\t/* NB: always expand BYTE values to shorts */\n\t\t\tcp = CheckMalloc(tif,\n\t\t\t    dp->tdir_count * sizeof (uint16), mesg);\n\t\t\tok = cp && TIFFFetchByteArray(tif, dp, (uint16*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\tcp = CheckMalloc(tif,\n\t\t\t    dp->tdir_count * sizeof (uint16), mesg);\n\t\t\tok = cp && TIFFFetchShortArray(tif, dp, (uint16*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\t\tcp = CheckMalloc(tif,\n\t\t\t    dp->tdir_count * sizeof (uint32), mesg);\n\t\t\tok = cp && TIFFFetchLongArray(tif, dp, (uint32*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\t\tcp = CheckMalloc(tif,\n\t\t\t    dp->tdir_count * sizeof (float), mesg);\n\t\t\tok = cp && TIFFFetchRationalArray(tif, dp, (float*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_FLOAT:\n\t\t\tcp = CheckMalloc(tif,\n\t\t\t    dp->tdir_count * sizeof (float), mesg);\n\t\t\tok = cp && TIFFFetchFloatArray(tif, dp, (float*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\tcp = CheckMalloc(tif,\n\t\t\t    dp->tdir_count * sizeof (double), mesg);\n\t\t\tok = cp && TIFFFetchDoubleArray(tif, dp, (double*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\t\t/* bit of a cheat... */\n\t\t\t/*\n\t\t\t * Some vendors write strings w/o the trailing\n\t\t\t * NULL byte, so always append one just in case.\n\t\t\t */\n\t\t\tcp = CheckMalloc(tif, dp->tdir_count+1, mesg);\n\t\t\tif (ok = (cp && TIFFFetchString(tif, dp, cp)))\n\t\t\t\tcp[dp->tdir_count] = '\\0';\t/* XXX */\n\t\t\tbreak;\n\t\t}\n\t\tif (ok) {\n\t\t\tok = (fip->field_passcount ?\n\t\t\t    (*setFieldFn)(tif, dp->tdir_tag, dp->tdir_count, cp)\n\t\t\t  : (*setFieldFn)(tif, dp->tdir_tag, cp));\n\t\t}\n\t\tif (cp != NULL)\n\t\t\t_TIFFfree(cp);\n\t} else if (CheckDirCount(tif, dp, 1)) {\t/* singleton value */\n\t\tswitch (dp->tdir_type) {\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\t/*\n\t\t\t * If the tag is also acceptable as a LONG or SLONG\n\t\t\t * then (*setFieldFn) will expect an uint32 parameter\n\t\t\t * passed to it (through varargs).  Thus, for machines\n\t\t\t * where sizeof (int) != sizeof (uint32) we must do\n\t\t\t * a careful check here.  It's hard to say if this\n\t\t\t * is worth optimizing.\n\t\t\t *\n\t\t\t * NB: We use TIFFFieldWithTag here knowing that\n\t\t\t *     it returns us the first entry in the table\n\t\t\t *     for the tag and that that entry is for the\n\t\t\t *     widest potential data type the tag may have.\n\t\t\t */\n\t\t\t{ TIFFDataType type = fip->field_type;\n\t\t\t  if (type != TIFF_LONG && type != TIFF_SLONG) {\n\t\t\t\tuint16 v = (uint16)\n\t\t\t   TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset);\n\t\t\t\tok = (fip->field_passcount ?\n\t\t\t\t    (*setFieldFn)(tif, dp->tdir_tag, 1, &v)\n\t\t\t\t  : (*setFieldFn)(tif, dp->tdir_tag, v));\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t}\n\t\t\t/* fall through... */\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\t\t{ uint32 v32 =\n\t\t    TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset);\n\t\t\t  ok = (fip->field_passcount ? \n\t\t\t      (*setFieldFn)(tif, dp->tdir_tag, 1, &v32)\n\t\t\t    : (*setFieldFn)(tif, dp->tdir_tag, v32));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\tcase TIFF_FLOAT:\n\t\t\t{ float v = (dp->tdir_type == TIFF_FLOAT ? \n\t\t\t      TIFFFetchFloat(tif, dp)\n\t\t\t    : TIFFFetchRational(tif, dp));\n\t\t\t  ok = (fip->field_passcount ?\n\t\t\t      (*setFieldFn)(tif, dp->tdir_tag, 1, &v)\n\t\t\t    : (*setFieldFn)(tif, dp->tdir_tag, v));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\t{ double v;\n\t\t\t  ok = (TIFFFetchDoubleArray(tif, dp, &v) &&\n\t\t\t    (fip->field_passcount ?\n\t\t\t      (*setFieldFn)(tif, dp->tdir_tag, 1, &v)\n\t\t\t    : (*setFieldFn)(tif, dp->tdir_tag, v))\n\t\t\t  );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\t\t/* bit of a cheat... */\n\t\t\t{ char c[2];\n\t\t\t  if (ok = (TIFFFetchString(tif, dp, c) != 0)) {\n\t\t\t\tc[1] = '\\0';\t\t/* XXX paranoid */\n\t\t\t\tok = (*setFieldFn)(tif, dp->tdir_tag, c);\n\t\t\t  }\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (ok);\n}",
          "fn_code_pos": [
            [
              734,
              0
            ],
            [
              869,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchNormalSubTag",
            "parameters": {
              "tif": "TIFF",
              "dp": "TIFFDirEntry",
              "fip": "TIFFFieldInfo",
              "setFieldFn": "int",
              "tag": "ttag_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchPerSampleShorts(TIFF* tif, TIFFDirEntry* dir, int* pl)\n{\n\tint samples = tif->tif_dir.td_samplesperpixel;\n\tint status = 0;\n\n\tif (CheckDirCount(tif, dir, (uint32) samples)) {\n\t\tuint16 buf[10];\n\t\tuint16* v = buf;\n\n\t\tif (samples > NITEMS(buf))\n\t\t\tv = (uint16*) _TIFFmalloc(samples * sizeof (uint16));\n\t\tif (TIFFFetchShortArray(tif, dir, v)) {\n\t\t\tint i;\n\t\t\tfor (i = 1; i < samples; i++)\n\t\t\t\tif (v[i] != v[0]) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\"Cannot handle different per-sample values for field \\\"%s\\\"\",\n\t\t\t   _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t*pl = v[0];\n\t\t\tstatus = 1;\n\t\t}\n\tbad:\n\t\tif (v != buf)\n\t\t\t_TIFFfree((char*) v);\n\t}\n\treturn (status);\n}",
          "fn_code_pos": [
            [
              881,
              0
            ],
            [
              910,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchPerSampleShorts",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "pl": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchPerSampleAnys(TIFF* tif, TIFFDirEntry* dir, double* pl)\n{\n\tint samples = (int) tif->tif_dir.td_samplesperpixel;\n\tint status = 0;\n\n\tif (CheckDirCount(tif, dir, (uint32) samples)) {\n\t\tdouble buf[10];\n\t\tdouble* v = buf;\n\n\t\tif (samples > NITEMS(buf))\n\t\t\tv = (double*) _TIFFmalloc(samples * sizeof (double));\n\t\tif (TIFFFetchAnyArray(tif, dir, v)) {\n\t\t\tint i;\n\t\t\tfor (i = 1; i < samples; i++)\n\t\t\t\tif (v[i] != v[0]) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\"Cannot handle different per-sample values for field \\\"%s\\\"\",\n\t\t\t   _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t*pl = v[0];\n\t\t\tstatus = 1;\n\t\t}\n\tbad:\n\t\tif (v != buf)\n\t\t\t_TIFFfree(v);\n\t}\n\treturn (status);\n}",
          "fn_code_pos": [
            [
              917,
              0
            ],
            [
              946,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchPerSampleAnys",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "pl": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, long nstrips, uint32** lpp)\n{\n\tregister uint32* lp;\n\tint status;\n\n\tif (!CheckDirCount(tif, dir, (uint32) nstrips))\n\t\treturn (0);\n\t/*\n\t * Allocate space for strip information.\n\t */\n\tif (*lpp == NULL &&\n\t    (*lpp = (uint32 *)CheckMalloc(tif,\n\t      nstrips * sizeof (uint32), \"for strip array\")) == NULL)\n\t\treturn (0);\n\tlp = *lpp;\n\tif (dir->tdir_type == (int)TIFF_SHORT) {\n\t\t/*\n\t\t * Handle uint16->uint32 expansion.\n\t\t */\n\t\tuint16* dp = (uint16*) CheckMalloc(tif,\n\t\t    dir->tdir_count* sizeof (uint16), \"to fetch strip tag\");\n\t\tif (dp == NULL)\n\t\t\treturn (0);\n\t\tif (status = TIFFFetchShortArray(tif, dir, dp)) {\n\t\t\tregister uint16* wp = dp;\n\t\t\twhile (nstrips-- > 0)\n\t\t\t\t*lp++ = *wp++;\n\t\t}\n\t\t_TIFFfree((char*) dp);\n\t} else\n\t\tstatus = TIFFFetchLongArray(tif, dir, lp);\n\treturn (status);\n}",
          "fn_code_pos": [
            [
              954,
              0
            ],
            [
              987,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchStripThing",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "nstrips": "long",
              "lpp": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchExtraSamples(TIFF* tif, TIFFDirEntry* dir)\n{\n\tuint16 buf[10];\n\tuint16* v = buf;\n\tint status;\n\n\tif (dir->tdir_count > NITEMS(buf))\n\t\tv = (uint16*) _TIFFmalloc(dir->tdir_count * sizeof (uint16));\n\tif (dir->tdir_type == TIFF_BYTE)\n\t\tstatus = TIFFFetchByteArray(tif, dir, v);\n\telse\n\t\tstatus = TIFFFetchShortArray(tif, dir, v);\n\tif (status)\n\t\tstatus = TIFFSetField(tif, dir->tdir_tag, dir->tdir_count, v);\n\tif (v != buf)\n\t\t_TIFFfree((char*) v);\n\treturn (status);\n}",
          "fn_code_pos": [
            [
              993,
              0
            ],
            [
              1011,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchExtraSamples",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFFetchRefBlackWhite(TIFF* tif, TIFFDirEntry* dir)\n{\n\tstatic char mesg[] = \"for \\\"ReferenceBlackWhite\\\" array\";\n\tchar* cp;\n\tint ok;\n\n\tif (dir->tdir_type == TIFF_RATIONAL)\n\t\treturn (1/*TIFFFetchNormalTag(tif, dir) just so linker won't complain - this part of the code is never used anyway */);\n\t/*\n\t * Handle LONG's for backward compatibility.\n\t */\n\tcp = CheckMalloc(tif, dir->tdir_count * sizeof (uint32), mesg);\n\tif (ok = (cp && TIFFFetchLongArray(tif, dir, (uint32*) cp))) {\n\t\tfloat* fp = (float*)\n\t\t    CheckMalloc(tif, dir->tdir_count * sizeof (float), mesg);\n\t\tif (ok = (fp != NULL)) {\n\t\t\tuint32 i;\n\t\t\tfor (i = 0; i < dir->tdir_count; i++)\n\t\t\t\tfp[i] = (float)((uint32*) cp)[i];\n\t\t\tok = TIFFSetField(tif, dir->tdir_tag, fp);\n\t\t\t_TIFFfree((char*) fp);\n\t\t}\n\t}\n\tif (cp)\n\t\t_TIFFfree(cp);\n\treturn (ok);\n}",
          "fn_code_pos": [
            [
              1018,
              0
            ],
            [
              1045,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchRefBlackWhite",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nChopUpSingleUncompressedStrip(TIFF* tif)\n{\n\tregister TIFFDirectory *td = &tif->tif_dir;\n\tuint32 bytecount = td->td_stripbytecount[0];\n\tuint32 offset = td->td_stripoffset[0];\n\ttsize_t rowbytes = TIFFVTileSize(tif, 1), stripbytes;\n\ttstrip_t strip, nstrips, rowsperstrip;\n\tuint32* newcounts;\n\tuint32* newoffsets;\n\n\t/*\n\t * Make the rows hold at least one\n\t * scanline, but fill 8k if possible.\n\t */\n\tif (rowbytes > 8192) {\n\t\tstripbytes = rowbytes;\n\t\trowsperstrip = 1;\n\t} else {\n\t\trowsperstrip = 8192 / rowbytes;\n\t\tstripbytes = rowbytes * rowsperstrip;\n\t}\n\t/* never increase the number of strips in an image */\n\tif (rowsperstrip >= td->td_rowsperstrip)\n\t\treturn;\n\tnstrips = (tstrip_t) TIFFhowmany(bytecount, stripbytes);\n\tnewcounts = (uint32*) CheckMalloc(tif, nstrips * sizeof (uint32),\n\t\t\t\t\"for chopped \\\"StripByteCounts\\\" array\");\n\tnewoffsets = (uint32*) CheckMalloc(tif, nstrips * sizeof (uint32),\n\t\t\t\t\"for chopped \\\"StripOffsets\\\" array\");\n\tif (newcounts == NULL || newoffsets == NULL) {\n\t        /*\n\t\t * Unable to allocate new strip information, give\n\t\t * up and use the original one strip information.\n\t\t */\n\t\tif (newcounts != NULL)\n\t\t\t_TIFFfree(newcounts);\n\t\tif (newoffsets != NULL)\n\t\t\t_TIFFfree(newoffsets);\n\t\treturn;\n\t}\n\t/*\n\t * Fill the strip information arrays with\n\t * new bytecounts and offsets that reflect\n\t * the broken-up format.\n\t */\n\tfor (strip = 0; strip < nstrips; strip++) {\n\t\tif (stripbytes > bytecount)\n\t\t\tstripbytes = bytecount;\n\t\tnewcounts[strip] = stripbytes;\n\t\tnewoffsets[strip] = offset;\n\t\toffset += stripbytes;\n\t\tbytecount -= stripbytes;\n\t}\n\t/*\n\t * Replace old single strip info with multi-strip info.\n\t */\n\ttd->td_stripsperimage = td->td_nstrips = nstrips;\n\tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n\t_TIFFfree(td->td_stripbytecount);\n\t_TIFFfree(td->td_stripoffset);\n\ttd->td_stripbytecount = newcounts;\n\ttd->td_stripoffset = newoffsets;\n}",
          "fn_code_pos": [
            [
              1056,
              0
            ],
            [
              1120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ChopUpSingleUncompressedStrip",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFCvtIEEEFloatToNative(TIFF*, uint32, float*)",
          "fn_dec_pos": [
            [
              57,
              12
            ],
            [
              57,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCvtIEEEFloatToNative",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFCvtIEEEDoubleToNative(TIFF*, uint32, double*)",
          "fn_dec_pos": [
            [
              58,
              12
            ],
            [
              58,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCvtIEEEDoubleToNative",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "EstimateStripByteCounts(TIFF*, TIFFDirEntry*, uint16)",
          "fn_dec_pos": [
            [
              61,
              12
            ],
            [
              61,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "EstimateStripByteCounts",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "MissingRequired(TIFF*, const char*)",
          "fn_dec_pos": [
            [
              62,
              12
            ],
            [
              62,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MissingRequired",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "CheckDirCount(TIFF*, TIFFDirEntry*, uint32)",
          "fn_dec_pos": [
            [
              63,
              11
            ],
            [
              63,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckDirCount",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFetchData(TIFF*, TIFFDirEntry*, char*)",
          "fn_dec_pos": [
            [
              64,
              15
            ],
            [
              64,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchData",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "TIFFFetchString(TIFF*, TIFFDirEntry*, char*)",
          "fn_dec_pos": [
            [
              65,
              15
            ],
            [
              65,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchString",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "TIFFFetchRational(TIFF*, TIFFDirEntry*)",
          "fn_dec_pos": [
            [
              66,
              13
            ],
            [
              66,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchRational",
            "parameters": {},
            "return_type": "float"
          }
        },
        {
          "fn_code": "TIFFFetchNormalSubTag(TIFF*, TIFFDirEntry*, const TIFFFieldInfo*,\n\t\t\t\t  int (*getFieldFn)(TIFF *tif,ttag_t tag,...))",
          "fn_dec_pos": [
            [
              67,
              11
            ],
            [
              68,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchNormalSubTag",
            "parameters": {
              "getFieldFn": "int",
              "tif": "TIFF",
              "tag": "ttag_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*getFieldFn)(TIFF *tif,ttag_t tag,...)",
          "fn_dec_pos": [
            [
              68,
              10
            ],
            [
              68,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "tif": "TIFF",
              "tag": "ttag_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFetchPerSampleShorts(TIFF*, TIFFDirEntry*, int*)",
          "fn_dec_pos": [
            [
              69,
              11
            ],
            [
              69,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchPerSampleShorts",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFetchPerSampleAnys(TIFF*, TIFFDirEntry*, double*)",
          "fn_dec_pos": [
            [
              70,
              11
            ],
            [
              70,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchPerSampleAnys",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFetchShortArray(TIFF*, TIFFDirEntry*, uint16*)",
          "fn_dec_pos": [
            [
              71,
              11
            ],
            [
              71,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchShortArray",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFetchStripThing(TIFF*, TIFFDirEntry*, long, uint32**)",
          "fn_dec_pos": [
            [
              72,
              11
            ],
            [
              72,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchStripThing",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFetchExtraSamples(TIFF*, TIFFDirEntry*)",
          "fn_dec_pos": [
            [
              73,
              11
            ],
            [
              73,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchExtraSamples",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFetchRefBlackWhite(TIFF*, TIFFDirEntry*)",
          "fn_dec_pos": [
            [
              74,
              11
            ],
            [
              74,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchRefBlackWhite",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFetchFloat(TIFF*, TIFFDirEntry*)",
          "fn_dec_pos": [
            [
              75,
              13
            ],
            [
              75,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchFloat",
            "parameters": {},
            "return_type": "float"
          }
        },
        {
          "fn_code": "TIFFFetchFloatArray(TIFF*, TIFFDirEntry*, float*)",
          "fn_dec_pos": [
            [
              76,
              11
            ],
            [
              76,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchFloatArray",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFetchDoubleArray(TIFF*, TIFFDirEntry*, double*)",
          "fn_dec_pos": [
            [
              77,
              11
            ],
            [
              77,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchDoubleArray",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFetchAnyArray(TIFF*, TIFFDirEntry*, double*)",
          "fn_dec_pos": [
            [
              78,
              11
            ],
            [
              78,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchAnyArray",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFetchShortPair(TIFF*, TIFFDirEntry*)",
          "fn_dec_pos": [
            [
              79,
              11
            ],
            [
              79,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFetchShortPair",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "ChopUpSingleUncompressedStrip(TIFF*)",
          "fn_dec_pos": [
            [
              81,
              12
            ],
            [
              81,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ChopUpSingleUncompressedStrip",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "CheckMalloc(TIFF* tif, tsize_t n, const char* what)",
          "fn_dec_pos": [
            [
              85,
              0
            ],
            [
              85,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckMalloc",
            "parameters": {
              "tif": "TIFF",
              "n": "tsize_t",
              "what": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*setFieldFn)(TIFF *tif, ttag_t tag, ...)",
          "fn_dec_pos": [
            [
              117,
              8
            ],
            [
              117,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "tif": "TIFF",
              "tag": "ttag_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*setFieldFn)(TIFF *tif, ttag_t tag, ...)",
          "fn_dec_pos": [
            [
              736,
              12
            ],
            [
              736,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "tif": "TIFF",
              "tag": "ttag_t"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/pds/tif_pdsdirwrite.c": {
      "fn_def_list": [
        {
          "fn_code": "toff_t\nTIFFWritePrivateDataSubDirectory(TIFF* tif,\n\t\t\t\t uint32 pdir_fieldsset[], int pdir_fields_last,\n\t\t\t\t TIFFFieldInfo *field_info,\n\t\t\t\t int (*getFieldFn)(TIFF *tif, ttag_t tag, ...))\n{\n\tuint16 dircount;\n\tuint32 diroff, nextdiroff;\n\tttag_t tag;\n\tuint32 nfields;\n\ttsize_t dirsize;\n\tchar* data;\n\tTIFFDirEntry* dir;\n\tu_long b, *fields, fields_size;\n\ttoff_t directory_offset;\n\tTIFFFieldInfo* fip;\n\n\t/*\n\t * Deleted out all of the encoder flushing and such code from here -\n\t * not necessary for subdirectories.\n\t */\n\n\t/* Finish writing out any image data. */\n\tTIFFFlushData(tif);\n\n\t/*\n\t * Size the directory so that we can calculate\n\t * offsets for the data items that aren't kept\n\t * in-place in each field.\n\t */\n\tnfields = 0;\n\tfor (b = 0; b <= pdir_fields_last; b++)\n\t\tif (FieldSet(pdir_fieldsset, b))\n\t\t\t/* Deleted code to make size of first 4 tags 2\n\t\t\t   instead of 1. */\n\t\t\tnfields += 1;\n\tdirsize = nfields * sizeof (TIFFDirEntry);\n\tdata = (char*) _TIFFmalloc(dirsize);\n\tif (data == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t    \"Cannot write private subdirectory, out of space\");\n\t\treturn (0);\n\t}\n\t/*\n\t * Place directory in data section of the file. If there isn't one\n\t * yet, place it at the end of the file. The directory is treated as\n\t * data, so we don't link it into the directory structure at all.\n\t */\n\tif (tif->tif_dataoff == 0)\n\t    tif->tif_dataoff =(TIFFSeekFile(tif, (toff_t) 0, SEEK_END)+1) &~ 1;\n\tdiroff = tif->tif_dataoff;\n\ttif->tif_dataoff = (toff_t)(\n\t    diroff + sizeof (uint16) + dirsize + sizeof (toff_t));\n\tif (tif->tif_dataoff & 1)\n\t\ttif->tif_dataoff++;\n\t(void) TIFFSeekFile(tif, tif->tif_dataoff, SEEK_SET);\n\t/*tif->tif_curdir++;*/\n\tdir = (TIFFDirEntry*) data;\n\t/*\n\t * Setup external form of directory\n\t * entries and write data items.\n\t */\n\t/*\n\t * We make a local copy of the fieldsset here so that we don't mess\n\t * up the original one when we call ResetFieldBit(). But I'm not sure\n\t * why the original code calls ResetFieldBit(), since we're already\n\t * going through the fields in order...\n\t *\n\t * fields_size is the number of uint32's we will need to hold the\n\t * bit-mask for all of the fields. If our highest field number is\n\t * 100, then we'll need 100 / (8*4)+1 == 4 uint32's to hold the\n\t * fieldset.\n\t *\n\t * Unlike the original code, we allocate fields dynamically based\n\t * on the requested pdir_fields_last value, allowing private\n\t * data subdirectories to contain more than the built-in code's limit\n\t * of 95 tags in a directory.\n\t */\n\tfields_size = pdir_fields_last / (8*sizeof(uint32)) + 1;\n\tfields = _TIFFmalloc(fields_size*sizeof(uint32));\n\t_TIFFmemcpy(fields, pdir_fieldsset, fields_size * sizeof(uint32));\n\n\t/* Deleted \"write out extra samples tag\" code here. */\n\n\t/* Deleted code for checking a billion little special cases for the\n\t * standard TIFF tags. Should add a general mechanism for overloading\n\t * write function for each field, just like Brian kept telling me!!!\n\t */\n\tfor (fip = field_info; fip->field_tag; fip++) {\n\t\t/* Deleted code to check for FIELD_IGNORE!! */\n\t\tif (/* fip->field_bit == FIELD_IGNORE || */\n\t\t    !FieldSet(fields, fip->field_bit))\n\t\t\tcontinue;\n\t\tif (!TIFFWriteNormalSubTag(tif, dir, fip, getFieldFn))\n\t\t\tgoto bad;\n\t\tdir++;\n\t\tResetFieldBit(fields, fip->field_bit);\n\t}\n\n\t/* Now we've written all of the referenced data, and are about to\n\t   write the main directory structure, so grab the tif_dataoff value\n\t   now so we can remember where we wrote the directory. */\n\tdirectory_offset = tif->tif_dataoff;\n\n\t/*\n\t * Write directory.\n\t */\n\tdircount = (uint16) nfields;\n\t/* Deleted code to link to the next directory - we set it to zero! */\n\tnextdiroff = 0;\n\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t/*\n\t\t * The file's byte order is opposite to the\n\t\t * native machine architecture.  We overwrite\n\t\t * the directory information with impunity\n\t\t * because it'll be released below after we\n\t\t * write it to the file.  Note that all the\n\t\t * other tag construction routines assume that\n\t\t * we do this byte-swapping; i.e. they only\n\t\t * byte-swap indirect data.\n\t\t */\n\t\tfor (dir = (TIFFDirEntry*) data; dircount; dir++, dircount--) {\n\t\t\tTIFFSwabArrayOfShort(&dir->tdir_tag, 2);\n\t\t\tTIFFSwabArrayOfLong(&dir->tdir_count, 2);\n\t\t}\n\t\tdircount = (uint16) nfields;\n\t\tTIFFSwabShort(&dircount);\n\t\tTIFFSwabLong(&nextdiroff);\n\t}\n\n\t(void) TIFFSeekFile(tif, tif->tif_dataoff, SEEK_SET);\n\tif (!WriteOK(tif, &dircount, sizeof (dircount))) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error writing private subdirectory count\");\n\t\tgoto bad;\n\t}\n\tif (!WriteOK(tif, data, dirsize)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error writing private subdirectory contents\");\n\t\tgoto bad;\n\t}\n\tif (!WriteOK(tif, &nextdiroff, sizeof (nextdiroff))) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error writing private subdirectory link\");\n\t\tgoto bad;\n\t}\n\ttif->tif_dataoff += sizeof(dircount) + dirsize + sizeof(nextdiroff);\n\n\t_TIFFfree(data);\n\t_TIFFfree(fields);\n\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\n#if (0)\n\t/* This stuff commented out because I don't think we want it for\n\t   subdirectories, but I could be wrong. */\n\t(*tif->tif_cleanup)(tif);\n\n\t/*\n\t * Reset directory-related state for subsequent\n\t * directories.\n\t */\n\tTIFFDefaultDirectory(tif);\n\ttif->tif_curoff = 0;\n\ttif->tif_row = (uint32) -1;\n\ttif->tif_curstrip = (tstrip_t) -1;\n#endif\n\n\treturn (directory_offset);\nbad:\n\t_TIFFfree(data);\n\t_TIFFfree(fields);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              138,
              0
            ],
            [
              307,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWritePrivateDataSubDirectory",
            "parameters": {
              "tif": "TIFF",
              "pdir_fieldsset": "uint32",
              "pdir_fields_last": "int",
              "field_info": "TIFFFieldInfo",
              "getFieldFn": "int",
              "tag": "ttag_t"
            },
            "return_type": "toff_t"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteNormalSubTag(TIFF* tif, TIFFDirEntry* dir, const TIFFFieldInfo* fip,\n\t\t      int (*getFieldFn)(TIFF *tif, ttag_t tag, ...))\n{\n\tu_short wc = (u_short) fip->field_writecount;\n\n\tdir->tdir_tag = fip->field_tag;\n\tdir->tdir_type = (u_short) fip->field_type;\n\tdir->tdir_count = wc;\n#define\tWRITEF(x,y)\tx(tif, fip->field_type, fip->field_tag, dir, wc, y)\n\tswitch (fip->field_type) {\n\tcase TIFF_SHORT:\n\tcase TIFF_SSHORT:\n\t\tif (wc > 1) {\n\t\t\tuint16* wp;\n\t\t\tif (wc == (u_short) TIFF_VARIABLE) {\n\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &wc, &wp);\n\t\t\t\tdir->tdir_count = wc;\n\t\t\t} else\n\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &wp);\n\t\t\tif (!WRITEF(TIFFWriteShortArray, wp))\n\t\t\t\treturn (0);\n\t\t} else {\n\t\t\tuint16 sv;\n\t\t\t(*getFieldFn)(tif, fip->field_tag, &sv);\n\t\t\tdir->tdir_offset =\n\t\t\t    TIFFInsertData(tif, dir->tdir_type, sv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_LONG:\n\tcase TIFF_SLONG:\n\t\tif (wc > 1) {\n\t\t\tuint32* lp;\n\t\t\tif (wc == (u_short) TIFF_VARIABLE) {\n\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &wc, &lp);\n\t\t\t\tdir->tdir_count = wc;\n\t\t\t} else\n\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &lp);\n\t\t\tif (!WRITEF(TIFFWriteLongArray, lp))\n\t\t\t\treturn (0);\n\t\t} else {\n\t\t\t/* XXX handle LONG->SHORT conversion */\n\t\t\t(*getFieldFn)(tif, fip->field_tag, &dir->tdir_offset);\n\t\t}\n\t\tbreak;\n\tcase TIFF_RATIONAL:\n\tcase TIFF_SRATIONAL:\n\t\tif (wc > 1) {\n\t\t\tfloat* fp;\n\t\t\tif (wc == (u_short) TIFF_VARIABLE) {\n\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &wc, &fp);\n\t\t\t\tdir->tdir_count = wc;\n\t\t\t} else\n\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &fp);\n\t\t\tif (!WRITEF(TIFFWriteRationalArray, fp))\n\t\t\t\treturn (0);\n\t\t} else {\n\t\t\tfloat fv;\n\t\t\t(*getFieldFn)(tif, fip->field_tag, &fv);\n\t\t\tif (!WRITEF(TIFFWriteRationalArray, &fv))\n\t\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\tcase TIFF_FLOAT:\n\t\tif (wc > 1) {\n\t\t\tfloat* fp;\n\t\t\tif (wc == (u_short) TIFF_VARIABLE) {\n\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &wc, &fp);\n\t\t\t\tdir->tdir_count = wc;\n\t\t\t} else\n\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &fp);\n\t\t\tif (!WRITEF(TIFFWriteFloatArray, fp))\n\t\t\t\treturn (0);\n\t\t} else {\n\t\t\tfloat fv;\n\t\t\t(*getFieldFn)(tif, fip->field_tag, &fv);\n\t\t\tif (!WRITEF(TIFFWriteFloatArray, &fv))\n\t\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\tcase TIFF_DOUBLE:\n\t\t/* Hey - I think this is a bug, or at least a \"gross\n\t\t   inconsistency\", in the TIFF library. Look at the original\n\t\t   TIFF library code below within the \"#if (0) ... #else\".\n\t\t   Just from the type of *dp, you can see that this code\n\t\t   expects TIFFGetField() to be handed a double ** for\n\t\t   any TIFF_DOUBLE tag, even for the constant wc==1 case.\n\t\t   This is totally inconsistent with other fields (like\n\t\t   TIFF_FLOAT, above) and is also inconsistent with the\n\t\t   TIFFSetField() function for TIFF_DOUBLEs, which expects\n\t\t   to be passed a single double by value for the wc==1 case.\n\t\t   (See the handling of TIFFFetchNormalTag() in tif_dirread.c\n\t\t   for an example.) Maybe this function was written before\n\t\t   TIFFWriteDoubleArray() was written, not that that's an\n\t\t   excuse. Anyway, the new code below is a trivial modification\n\t\t   of the TIFF_FLOAT code above. The fact that even single\n\t\t   doubles get written out in the data segment and get an\n\t\t   offset value stored is irrelevant here - that is all\n\t\t   handled by TIFFWriteDoubleArray(). */\n#if (0)\n\t\t{ double* dp;\n\t\t  if (wc == (u_short) TIFF_VARIABLE) {\n\t\t\t(*getFieldFn)(tif, fip->field_tag, &wc, &dp);\n\t\t\tdir->tdir_count = wc;\n\t\t  } else\n\t\t\t(*getFieldFn)(tif, fip->field_tag, &dp);\n\t\t  TIFFCvtNativeToIEEEDouble(tif, wc, dp);\n\t\t  if (!TIFFWriteData(tif, dir, (char*) dp))\n\t\t\treturn (0);\n\t\t}\n#else\n\t\tif (wc > 1) {\n\t\t\tdouble* dp;\n\t\t\tif (wc == (u_short) TIFF_VARIABLE) {\n\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &wc, &dp);\n\t\t\t\tdir->tdir_count = wc;\n\t\t\t} else\n\t\t\t\t(*getFieldFn)(tif, fip->field_tag, &dp);\n\t\t\tif (!WRITEF(TIFFWriteDoubleArray, dp))\n\t\t\t\treturn (0);\n\t\t} else {\n\t\t\tdouble dv;\n\t\t\t(*getFieldFn)(tif, fip->field_tag, &dv);\n\t\t\tif (!WRITEF(TIFFWriteDoubleArray, &dv))\n\t\t\t\treturn (0);\n\t\t}\n#endif\n\t\tbreak;\n\tcase TIFF_ASCII:\n\t\t{ char* cp;\n\t\t  (*getFieldFn)(tif, fip->field_tag, &cp);\n\t\t  dir->tdir_count = (uint32) (strlen(cp) + 1);\n\t\t  if (!TIFFWriteByteArray(tif, dir, cp))\n\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\tcase TIFF_UNDEFINED:\n\t\t{ char* cp;\n\t\t  if (wc == (u_short) TIFF_VARIABLE) {\n\t\t\t(*getFieldFn)(tif, fip->field_tag, &wc, &cp);\n\t\t\tdir->tdir_count = wc;\n\t\t  } else \n\t\t\t(*getFieldFn)(tif, fip->field_tag, &cp);\n\t\t  if (!TIFFWriteByteArray(tif, dir, cp))\n\t\t\treturn (0);\n\t\t}\n\t\tbreak;\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              316,
              0
            ],
            [
              465,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteNormalSubTag",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "fip": "TIFFFieldInfo",
              "getFieldFn": "int",
              "tag": "ttag_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nTIFFSetupShortLong(TIFF* tif, ttag_t tag, TIFFDirEntry* dir, uint32 v)\n{\n\tdir->tdir_tag = tag;\n\tdir->tdir_count = 1;\n\tif (v > 0xffffL) {\n\t\tdir->tdir_type = (short) TIFF_LONG;\n\t\tdir->tdir_offset = v;\n\t} else {\n\t\tdir->tdir_type = (short) TIFF_SHORT;\n\t\tdir->tdir_offset = TIFFInsertData(tif, (int) TIFF_SHORT, v);\n\t}\n}",
          "fn_code_pos": [
            [
              476,
              0
            ],
            [
              488,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetupShortLong",
            "parameters": {
              "tif": "TIFF",
              "tag": "ttag_t",
              "dir": "TIFFDirEntry",
              "v": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteRational(TIFF* tif,\n    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, float v)\n{\n\treturn (TIFFWriteRationalArray(tif, type, tag, dir, 1, &v));\n}",
          "fn_code_pos": [
            [
              496,
              0
            ],
            [
              501,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteRational",
            "parameters": {
              "tif": "TIFF",
              "type": "TIFFDataType",
              "tag": "ttag_t",
              "dir": "TIFFDirEntry",
              "v": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWritePerSampleShorts(TIFF* tif, ttag_t tag, TIFFDirEntry* dir)\n{\n\tuint16 buf[10], v;\n\tuint16* w = buf;\n\tint i, status, samples = tif->tif_dir.td_samplesperpixel;\n\n\tif (samples > NITEMS(buf))\n\t\tw = (uint16*) _TIFFmalloc(samples * sizeof (uint16));\n\tTIFFGetField(tif, tag, &v);\n\tfor (i = 0; i < samples; i++)\n\t\tw[i] = v;\n\tstatus = TIFFWriteShortArray(tif, TIFF_SHORT, tag, dir, samples, w);\n\tif (w != buf)\n\t\t_TIFFfree((char*) w);\n\treturn (status);\n}",
          "fn_code_pos": [
            [
              511,
              0
            ],
            [
              527,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWritePerSampleShorts",
            "parameters": {
              "tif": "TIFF",
              "tag": "ttag_t",
              "dir": "TIFFDirEntry"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWritePerSampleAnys(TIFF* tif,\n    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir)\n{\n\tdouble buf[10], v;\n\tdouble* w = buf;\n\tint i, status;\n\tint samples = (int) tif->tif_dir.td_samplesperpixel;\n\n\tif (samples > NITEMS(buf))\n\t\tw = (double*) _TIFFmalloc(samples * sizeof (double));\n\tTIFFGetField(tif, tag, &v);\n\tfor (i = 0; i < samples; i++)\n\t\tw[i] = v;\n\tstatus = TIFFWriteAnyArray(tif, type, tag, dir, samples, w);\n\tif (w != buf)\n\t\t_TIFFfree(w);\n\treturn (status);\n}",
          "fn_code_pos": [
            [
              534,
              0
            ],
            [
              552,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWritePerSampleAnys",
            "parameters": {
              "tif": "TIFF",
              "type": "TIFFDataType",
              "tag": "ttag_t",
              "dir": "TIFFDirEntry"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFSetupShortPair(TIFF* tif, ttag_t tag, TIFFDirEntry* dir)\n{\n\tuint16 v[2];\n\n\tTIFFGetField(tif, tag, &v[0], &v[1]);\n\treturn (TIFFWriteShortArray(tif, TIFF_SHORT, tag, dir, 2, v));\n}",
          "fn_code_pos": [
            [
              559,
              0
            ],
            [
              566,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetupShortPair",
            "parameters": {
              "tif": "TIFF",
              "tag": "ttag_t",
              "dir": "TIFFDirEntry"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteShortTable(TIFF* tif,\n    ttag_t tag, TIFFDirEntry* dir, uint32 n, uint16** table)\n{\n\tuint32 i, off;\n\n\tdir->tdir_tag = tag;\n\tdir->tdir_type = (short) TIFF_SHORT;\n\t/* XXX -- yech, fool TIFFWriteData */\n\tdir->tdir_count = (uint32) (1L<<tif->tif_dir.td_bitspersample);\n\toff = tif->tif_dataoff;\n\tfor (i = 0; i < n; i++)\n\t\tif (!TIFFWriteData(tif, dir, (char *)table[i]))\n\t\t\treturn (0);\n\tdir->tdir_count *= n;\n\tdir->tdir_offset = off;\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              573,
              0
            ],
            [
              590,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteShortTable",
            "parameters": {
              "tif": "TIFF",
              "tag": "ttag_t",
              "dir": "TIFFDirEntry",
              "n": "uint32",
              "table": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteByteArray(TIFF* tif, TIFFDirEntry* dir, char* cp)\n{\n\tif (dir->tdir_count > 4) {\n\t\tif (!TIFFWriteData(tif, dir, cp))\n\t\t\treturn (0);\n\t} else\n\t\t_TIFFmemcpy(&dir->tdir_offset, cp, dir->tdir_count);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              595,
              0
            ],
            [
              604,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteByteArray",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "cp": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteShortArray(TIFF* tif,\n    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, uint16* v)\n{\n\tdir->tdir_tag = tag;\n\tdir->tdir_type = (short) type;\n\tdir->tdir_count = n;\n\tif (n <= 2) {\n\t\tif (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {\n\t\t\tdir->tdir_offset = (uint32) ((long) v[0] << 16);\n\t\t\tif (n == 2)\n\t\t\t\tdir->tdir_offset |= v[1] & 0xffff;\n\t\t} else {\n\t\t\tdir->tdir_offset = v[0] & 0xffff;\n\t\t\tif (n == 2)\n\t\t\t\tdir->tdir_offset |= (long) v[1] << 16;\n\t\t}\n\t\treturn (1);\n\t} else\n\t\treturn (TIFFWriteData(tif, dir, (char*) v));\n}",
          "fn_code_pos": [
            [
              610,
              0
            ],
            [
              630,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteShortArray",
            "parameters": {
              "tif": "TIFF",
              "type": "TIFFDataType",
              "tag": "ttag_t",
              "dir": "TIFFDirEntry",
              "n": "uint32",
              "v": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteLongArray(TIFF* tif,\n    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, uint32* v)\n{\n\tdir->tdir_tag = tag;\n\tdir->tdir_type = (short) type;\n\tdir->tdir_count = n;\n\tif (n == 1) {\n\t\tdir->tdir_offset = v[0];\n\t\treturn (1);\n\t} else\n\t\treturn (TIFFWriteData(tif, dir, (char*) v));\n}",
          "fn_code_pos": [
            [
              636,
              0
            ],
            [
              648,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteLongArray",
            "parameters": {
              "tif": "TIFF",
              "type": "TIFFDataType",
              "tag": "ttag_t",
              "dir": "TIFFDirEntry",
              "n": "uint32",
              "v": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteRationalArray(TIFF* tif,\n    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, float* v)\n{\n\tuint32 i;\n\tuint32* t;\n\tint status;\n\n\tdir->tdir_tag = tag;\n\tdir->tdir_type = (short) type;\n\tdir->tdir_count = n;\n\tt = (uint32*) _TIFFmalloc(2*n * sizeof (uint32));\n\tfor (i = 0; i < n; i++) {\n\t\tfloat fv = v[i];\n\t\tint sign = 1;\n\t\tuint32 den;\n\n\t\tif (fv < 0) {\n\t\t\tif (type == TIFF_RATIONAL) {\n\t\t\t\tTIFFWarning(tif->tif_name,\n\t\"\\\"%s\\\": Information lost writing value (%g) as (unsigned) RATIONAL\",\n\t\t\t\t_TIFFFieldWithTag(tif,tag)->field_name, v);\n\t\t\t\tfv = 0;\n\t\t\t} else\n\t\t\t\tfv = -fv, sign = -1;\n\t\t}\n\t\tden = 1L;\n\t\tif (fv > 0) {\n\t\t\twhile (fv < 1L<<(31-3) && den < 1L<<(31-3))\n\t\t\t\tfv *= 1<<3, den *= 1L<<3;\n\t\t}\n\t\tt[2*i+0] = sign * (fv + 0.5);\n\t\tt[2*i+1] = den;\n\t}\n\tstatus = TIFFWriteData(tif, dir, (char *)t);\n\t_TIFFfree((char*) t);\n\treturn (status);\n}",
          "fn_code_pos": [
            [
              654,
              0
            ],
            [
              691,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteRationalArray",
            "parameters": {
              "tif": "TIFF",
              "type": "TIFFDataType",
              "tag": "ttag_t",
              "dir": "TIFFDirEntry",
              "n": "uint32",
              "v": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteFloatArray(TIFF* tif,\n    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, float* v)\n{\n\tdir->tdir_tag = tag;\n\tdir->tdir_type = (short) type;\n\tdir->tdir_count = n;\n\tTIFFCvtNativeToIEEEFloat(tif, n, v);\n\tif (n == 1) {\n\t\tdir->tdir_offset = *(uint32*) &v[0];\n\t\treturn (1);\n\t} else\n\t\treturn (TIFFWriteData(tif, dir, (char*) v));\n}",
          "fn_code_pos": [
            [
              693,
              0
            ],
            [
              706,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteFloatArray",
            "parameters": {
              "tif": "TIFF",
              "type": "TIFFDataType",
              "tag": "ttag_t",
              "dir": "TIFFDirEntry",
              "n": "uint32",
              "v": "float"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteDoubleArray(TIFF* tif,\n    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, double* v)\n{\n\tdir->tdir_tag = tag;\n\tdir->tdir_type = (short) type;\n\tdir->tdir_count = n;\n\tTIFFCvtNativeToIEEEDouble(tif, n, v);\n\treturn (TIFFWriteData(tif, dir, (char*) v));\n}",
          "fn_code_pos": [
            [
              708,
              0
            ],
            [
              717,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDoubleArray",
            "parameters": {
              "tif": "TIFF",
              "type": "TIFFDataType",
              "tag": "ttag_t",
              "dir": "TIFFDirEntry",
              "n": "uint32",
              "v": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteAnyArray(TIFF* tif,\n    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir, uint32 n, double* v)\n{\n\tchar buf[10 * sizeof(double)];\n\tchar* w = buf;\n\tint i, status = 0;\n\n\tif (n * TIFFDataWidth(type) > sizeof buf)\n\t\tw = (char*) _TIFFmalloc(n * TIFFDataWidth(type));\n\tswitch (type) {\n\tcase TIFF_BYTE:\n\t\t{ unsigned char* bp = (unsigned char*) w;\n\t\t  for (i = 0; i < n; i++)\n\t\t\tbp[i] = (unsigned char) v[i];\n\t\t  dir->tdir_tag = tag;\n\t\t  dir->tdir_type = (short) type;\n\t\t  dir->tdir_count = n;\n\t\t  if (!TIFFWriteByteArray(tif, dir, (char*) bp))\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase TIFF_SBYTE:\n\t\t{ signed char* bp = (signed char*) w;\n\t\t  for (i = 0; i < n; i++)\n\t\t\tbp[i] = (signed char) v[i];\n\t\t  dir->tdir_tag = tag;\n\t\t  dir->tdir_type = (short) type;\n\t\t  dir->tdir_count = n;\n\t\t  if (!TIFFWriteByteArray(tif, dir, (char*) bp))\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase TIFF_SHORT:\n\t\t{ uint16* bp = (uint16*) w;\n\t\t  for (i = 0; i < n; i++)\n\t\t\tbp[i] = (uint16) v[i];\n\t\t  if (!TIFFWriteShortArray(tif, type, tag, dir, n, (uint16*)bp))\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase TIFF_SSHORT:\n\t\t{ int16* bp = (int16*) w;\n\t\t  for (i = 0; i < n; i++)\n\t\t\tbp[i] = (int16) v[i];\n\t\t  if (!TIFFWriteShortArray(tif, type, tag, dir, n, (uint16*)bp))\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase TIFF_LONG:\n\t\t{ uint32* bp = (uint32*) w;\n\t\t  for (i = 0; i < n; i++)\n\t\t\tbp[i] = (uint32) v[i];\n\t\t  if (!TIFFWriteLongArray(tif, type, tag, dir, n, bp))\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase TIFF_SLONG:\n\t\t{ int32* bp = (int32*) w;\n\t\t  for (i = 0; i < n; i++)\n\t\t\tbp[i] = (int32) v[i];\n\t\t  if (!TIFFWriteLongArray(tif, type, tag, dir, n, (uint32*) bp))\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase TIFF_FLOAT:\n\t\t{ float* bp = (float*) w;\n\t\t  for (i = 0; i < n; i++)\n\t\t\tbp[i] = (float) v[i];\n\t\t  if (!TIFFWriteFloatArray(tif, type, tag, dir, n, bp))\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase TIFF_DOUBLE:\n\t\treturn (TIFFWriteDoubleArray(tif, type, tag, dir, n, v));\n\tdefault:\n\t\t/* TIFF_NOTYPE */\n\t\t/* TIFF_ASCII */\n\t\t/* TIFF_UNDEFINED */\n\t\t/* TIFF_RATIONAL */\n\t\t/* TIFF_SRATIONAL */\n\t\tgoto out;\n\t}\n\tstatus = 1;\n out:\n\tif (w != buf)\n\t\t_TIFFfree(w);\n\treturn (status);\n}",
          "fn_code_pos": [
            [
              728,
              0
            ],
            [
              816,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteAnyArray",
            "parameters": {
              "tif": "TIFF",
              "type": "TIFFDataType",
              "tag": "ttag_t",
              "dir": "TIFFDirEntry",
              "n": "uint32",
              "v": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteTransferFunction(TIFF* tif, TIFFDirEntry* dir)\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\ttsize_t n = (1L<<td->td_bitspersample) * sizeof (uint16);\n\tuint16** tf = td->td_transferfunction;\n\tint ncols;\n\n\t/*\n\t * Check if the table can be written as a single column,\n\t * or if it must be written as 3 columns.  Note that we\n\t * write a 3-column tag if there are 2 samples/pixel and\n\t * a single column of data won't suffice--hmm.\n\t */\n\tswitch (td->td_samplesperpixel - td->td_extrasamples) {\n\tdefault:\tif (_TIFFmemcmp(tf[0], tf[2], n)) { ncols = 3; break; }\n\tcase 2:\t\tif (_TIFFmemcmp(tf[0], tf[1], n)) { ncols = 3; break; }\n\tcase 1: case 0:\tncols = 1;\n\t}\n\treturn (TIFFWriteShortTable(tif,\n\t    TIFFTAG_TRANSFERFUNCTION, dir, ncols, tf));\n}",
          "fn_code_pos": [
            [
              819,
              0
            ],
            [
              840,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteTransferFunction",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFWriteData(TIFF* tif, TIFFDirEntry* dir, char* cp)\n{\n\ttsize_t cc;\n\n\tif (tif->tif_flags & TIFF_SWAB) {\n\t\tswitch (dir->tdir_type) {\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\tTIFFSwabArrayOfShort((uint16*) cp, dir->tdir_count);\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\tcase TIFF_FLOAT:\n\t\t\tTIFFSwabArrayOfLong((uint32*) cp, dir->tdir_count);\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\t\tTIFFSwabArrayOfLong((uint32*) cp, 2*dir->tdir_count);\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\tTIFFSwabArrayOfDouble((double*) cp, dir->tdir_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdir->tdir_offset = tif->tif_dataoff;\n\tcc = dir->tdir_count * TIFFDataWidth(dir->tdir_type);\n\tif (SeekOK(tif, dir->tdir_offset) &&\n\t    WriteOK(tif, cp, cc)) {\n\t\ttif->tif_dataoff += (cc + 1) & ~1;\n\t\treturn (1);\n\t}\n\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error writing data for field \\\"%s\\\"\",\n\t    _TIFFFieldWithTag(tif, dir->tdir_tag)->field_name);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              846,
              0
            ],
            [
              881,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteData",
            "parameters": {
              "tif": "TIFF",
              "dir": "TIFFDirEntry",
              "cp": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nTIFFLinkDirectory(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFLinkDirectory\";\n\tuint32 nextdir;\n\tuint32 diroff;\n\n\ttif->tif_diroff = (TIFFSeekFile(tif, (toff_t) 0, SEEK_END)+1) &~ 1;\n\tdiroff = (uint32) tif->tif_diroff;\n\tif (tif->tif_flags & TIFF_SWAB)\n\t\tTIFFSwabLong(&diroff);\n#if SUBIFD_SUPPORT\n\tif (tif->tif_flags & TIFF_INSUBIFD) {\n\t\t(void) TIFFSeekFile(tif, tif->tif_subifdoff, SEEK_SET);\n\t\tif (!WriteOK(tif, &diroff, sizeof (diroff))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"%s: Error writing SubIFD directory link\",\n\t\t\t    tif->tif_name);\n\t\t\treturn (0);\n\t\t}\n\t\t/*\n\t\t * Advance to the next SubIFD or, if this is\n\t\t * the last one configured, revert back to the\n\t\t * normal directory linkage.\n\t\t */\n\t\tif (--tif->tif_nsubifd)\n\t\t\ttif->tif_subifdoff += sizeof (diroff);\n\t\telse\n\t\t\ttif->tif_flags &= ~TIFF_INSUBIFD;\n\t\treturn (1);\n\t}\n#endif\n\tif (tif->tif_header.tiff_diroff == 0) {\n\t\t/*\n\t\t * First directory, overwrite offset in header.\n\t\t */\n\t\ttif->tif_header.tiff_diroff = (uint32) tif->tif_diroff;\n#define\tHDROFF(f)\t((toff_t) &(((TIFFHeader*) 0)->f))\n\t\t(void) TIFFSeekFile(tif, HDROFF(tiff_diroff), SEEK_SET);\n\t\tif (!WriteOK(tif, &diroff, sizeof (diroff))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"Error writing TIFF header\");\n\t\t\treturn (0);\n\t\t}\n\t\treturn (1);\n\t}\n\t/*\n\t * Not the first directory, search to the last and append.\n\t */\n\tnextdir = tif->tif_header.tiff_diroff;\n\tdo {\n\t\tuint16 dircount;\n\n\t\tif (!SeekOK(tif, nextdir) ||\n\t\t    !ReadOK(tif, &dircount, sizeof (dircount))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Error fetching directory count\");\n\t\t\treturn (0);\n\t\t}\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabShort(&dircount);\n\t\t(void) TIFFSeekFile(tif,\n\t\t    dircount * sizeof (TIFFDirEntry), SEEK_CUR);\n\t\tif (!ReadOK(tif, &nextdir, sizeof (nextdir))) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Error fetching directory link\");\n\t\t\treturn (0);\n\t\t}\n\t\tif (tif->tif_flags & TIFF_SWAB)\n\t\t\tTIFFSwabLong(&nextdir);\n\t} while (nextdir != 0);\n\t(void) TIFFSeekFile(tif, -(toff_t) sizeof (nextdir), SEEK_CUR);\n\tif (!WriteOK(tif, &diroff, sizeof (diroff))) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Error writing directory link\");\n\t\treturn (0);\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              887,
              0
            ],
            [
              961,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFLinkDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFCvtNativeToIEEEFloat(TIFF*, uint32, float*)",
          "fn_dec_pos": [
            [
              65,
              12
            ],
            [
              65,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCvtNativeToIEEEFloat",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFCvtNativeToIEEEDouble(TIFF*, uint32, double*)",
          "fn_dec_pos": [
            [
              66,
              12
            ],
            [
              66,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCvtNativeToIEEEDouble",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFWriteNormalTag(TIFF*, TIFFDirEntry*, const TIFFFieldInfo*)",
          "fn_dec_pos": [
            [
              69,
              11
            ],
            [
              69,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteNormalTag",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteNormalSubTag(TIFF*, TIFFDirEntry*, const TIFFFieldInfo*,\n\t\t\t\t  int (*getFieldFn)(TIFF *tif,ttag_t tag,...))",
          "fn_dec_pos": [
            [
              70,
              11
            ],
            [
              71,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteNormalSubTag",
            "parameters": {
              "getFieldFn": "int",
              "tif": "TIFF",
              "tag": "ttag_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*getFieldFn)(TIFF *tif,ttag_t tag,...)",
          "fn_dec_pos": [
            [
              71,
              10
            ],
            [
              71,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "tif": "TIFF",
              "tag": "ttag_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFSetupShortLong(TIFF*, ttag_t, TIFFDirEntry*, uint32)",
          "fn_dec_pos": [
            [
              72,
              12
            ],
            [
              72,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetupShortLong",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFSetupShortPair(TIFF*, ttag_t, TIFFDirEntry*)",
          "fn_dec_pos": [
            [
              73,
              11
            ],
            [
              73,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetupShortPair",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWritePerSampleShorts(TIFF*, ttag_t, TIFFDirEntry*)",
          "fn_dec_pos": [
            [
              74,
              11
            ],
            [
              74,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWritePerSampleShorts",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWritePerSampleAnys(TIFF*, TIFFDataType, ttag_t, TIFFDirEntry*)",
          "fn_dec_pos": [
            [
              75,
              11
            ],
            [
              75,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWritePerSampleAnys",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteShortTable(TIFF*, ttag_t, TIFFDirEntry*, uint32, uint16**)",
          "fn_dec_pos": [
            [
              76,
              11
            ],
            [
              76,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteShortTable",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteShortArray(TIFF*,\n\t    TIFFDataType, ttag_t, TIFFDirEntry*, uint32, uint16*)",
          "fn_dec_pos": [
            [
              77,
              11
            ],
            [
              78,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteShortArray",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteLongArray(TIFF *,\n\t    TIFFDataType, ttag_t, TIFFDirEntry*, uint32, uint32*)",
          "fn_dec_pos": [
            [
              79,
              11
            ],
            [
              80,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteLongArray",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteRationalArray(TIFF *,\n\t    TIFFDataType, ttag_t, TIFFDirEntry*, uint32, float*)",
          "fn_dec_pos": [
            [
              81,
              11
            ],
            [
              82,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteRationalArray",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteFloatArray(TIFF *,\n\t    TIFFDataType, ttag_t, TIFFDirEntry*, uint32, float*)",
          "fn_dec_pos": [
            [
              83,
              11
            ],
            [
              84,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteFloatArray",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDoubleArray(TIFF *,\n\t    TIFFDataType, ttag_t, TIFFDirEntry*, uint32, double*)",
          "fn_dec_pos": [
            [
              85,
              11
            ],
            [
              86,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDoubleArray",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteByteArray(TIFF*, TIFFDirEntry*, char*)",
          "fn_dec_pos": [
            [
              87,
              11
            ],
            [
              87,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteByteArray",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteAnyArray(TIFF*,\n\t    TIFFDataType, ttag_t, TIFFDirEntry*, uint32, double*)",
          "fn_dec_pos": [
            [
              88,
              11
            ],
            [
              89,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteAnyArray",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteTransferFunction(TIFF*, TIFFDirEntry*)",
          "fn_dec_pos": [
            [
              91,
              11
            ],
            [
              91,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteTransferFunction",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteData(TIFF*, TIFFDirEntry*, char*)",
          "fn_dec_pos": [
            [
              93,
              11
            ],
            [
              93,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteData",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFLinkDirectory(TIFF*)",
          "fn_dec_pos": [
            [
              94,
              11
            ],
            [
              94,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFLinkDirectory",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteRational(TIFF*,\n\t    TIFFDataType, ttag_t, TIFFDirEntry*, float)",
          "fn_dec_pos": [
            [
              106,
              11
            ],
            [
              107,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteRational",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*getFieldFn)(TIFF *tif, ttag_t tag, ...)",
          "fn_dec_pos": [
            [
              142,
              9
            ],
            [
              142,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "tif": "TIFF",
              "tag": "ttag_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*getFieldFn)(TIFF *tif, ttag_t tag, ...)",
          "fn_dec_pos": [
            [
              318,
              12
            ],
            [
              318,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "tif": "TIFF",
              "tag": "ttag_t"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/tags/maketif.c": {
      "fn_def_list": [
        {
          "fn_code": "void main()\n{\n\tTIFF *tif=(TIFF*)0;  /* TIFF-level descriptor */\n\t\n\ttif=XTIFFOpen(\"newtif.tif\",\"w\");\n\tif (!tif) goto failure;\n\t\n\tSetUpTIFFDirectory(tif);\n\tWriteImage(tif);\n\t\n\tXTIFFClose(tif);\n\texit (0);\n\t\nfailure:\n\tprintf(\"failure in maketif\\n\");\n\tif (tif) XTIFFClose(tif);\n\texit (-1);\n}",
          "fn_code_pos": [
            [
              15,
              0
            ],
            [
              32,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void SetUpTIFFDirectory(TIFF *tif)\n{\n\tdouble mymulti[6]={0.0,1.0,2.0,  3.1415926, 5.0,1.0};\n\tuint32 mysingle=3456;\n\tchar *ascii=\"This file was produced by Steven Spielberg. NOT\";\n\n\tTIFFSetField(tif,TIFFTAG_IMAGEWIDTH,WIDTH);\n\tTIFFSetField(tif,TIFFTAG_IMAGELENGTH,HEIGHT);\n\tTIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE);\n\tTIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_MINISBLACK);\n\tTIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);\n\tTIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8);\n\tTIFFSetField(tif,TIFFTAG_ROWSPERSTRIP,20);\n\n\t/* Install the extended TIFF tag examples */\n\tTIFFSetField(tif,TIFFTAG_EXAMPLE_MULTI,6,mymulti);\n\tTIFFSetField(tif,TIFFTAG_EXAMPLE_SINGLE,mysingle);\n\tTIFFSetField(tif,TIFFTAG_EXAMPLE_ASCII,ascii);\n}",
          "fn_code_pos": [
            [
              35,
              0
            ],
            [
              53,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetUpTIFFDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void WriteImage(TIFF *tif)\n{\n\tint i;\n\tchar buffer[WIDTH];\n\t\n\tmemset(buffer,0,sizeof(buffer));\n\tfor (i=0;i<HEIGHT;i++)\n\t\tif (!TIFFWriteScanline(tif, buffer, i, 0))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, \"WriteImage\",\"failure in WriteScanline\\n\");\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteImage",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "SetUpTIFFDirectory(TIFF *tif)",
          "fn_dec_pos": [
            [
              9,
              5
            ],
            [
              9,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetUpTIFFDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "WriteImage(TIFF *tif)",
          "fn_dec_pos": [
            [
              10,
              5
            ],
            [
              10,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "WriteImage",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdlib.h>\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ],
        [
          "#include \"xtiffio.h\"\n",
          [
            6,
            0
          ],
          [
            7,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/tags/listtif.c": {
      "fn_def_list": [
        {
          "fn_code": "void main(int argc,char *argv[])\n{\n\tchar *fname=\"newtif.tif\";\n\tint flags;\n\n\tTIFF *tif=(TIFF*)0;  /* TIFF-level descriptor */\n\n\tif (argc>1) fname=argv[1];\n\t\n\ttif=XTIFFOpen(fname,\"r\");\n\tif (!tif) goto failure;\n\t\n\t/* We want the double array listed */\n\tflags = TIFFPRINT_MYMULTIDOUBLES;\n\t\n\tTIFFPrintDirectory(tif,stdout,flags);\n\tXTIFFClose(tif);\n\texit (0);\n\t\nfailure:\n\tprintf(\"failure in listtif\\n\");\n\tif (tif) XTIFFClose(tif);\n\texit (-1);\n}",
          "fn_code_pos": [
            [
              7,
              0
            ],
            [
              30,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"xtiffio.h\"\n",
          [
            4,
            0
          ],
          [
            5,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/tags/xtif_dir.c": {
      "fn_def_list": [
        {
          "fn_code": "static void\n_XTIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)\n{\n\txtiff *xt = XTIFFDIR(tif);\n\tXTIFFDirectory *xd = &xt->xtif_dir;\n\tint i,num;\n\n\t/* call the inherited method */\n\tif (PARENT(xt,printdir))\n\t\t(PARENT(xt,printdir))(tif,fd,flags);\n\n\t/* XXX Add field printing here. Replace the three example\n         *    tags implemented below with your own.\n         */\n\n\tfprintf(fd,\"--My Example Tags--\\n\");\n\n\t/* Our first example tag may have a lot of values, so we\n         * will only print them out if the TIFFPRINT_MYMULTIDOUBLES\n         * flag is passed into the print method.\n         */\n\tif (TIFFFieldSet(tif,FIELD_EXAMPLE_MULTI))\n\t{\n\t\tfprintf(fd, \"  My Multi-Valued Doubles:\");\n\t\tif (flags & TIFFPRINT_MYMULTIDOUBLES) \n\t\t{\n\t\t\tdouble *value = xd->xd_example_multi;\n\t\n\t\t\tnum = xd->xd_num_multi;\n\t\t\tfprintf(fd,\"(\");\n\t\t\tfor (i=0;i<num;i++) fprintf(fd, \" %lg\", *value++);\n\t\t\tfprintf(fd,\")\\n\");\n\t\t} else\n\t\t\tfprintf(fd, \"(present)\\n\");\n\t}\n\n\tif (TIFFFieldSet(tif,FIELD_EXAMPLE_SINGLE))\n\t{\n\t\tfprintf(fd, \"  My Single Long Tag:  %lu\\n\", xd->xd_example_single);\n\t}\n\n\tif (TIFFFieldSet(tif,FIELD_EXAMPLE_ASCII))\n\t{\n\t\t_TIFFprintAsciiTag(fd,\"My ASCII Tag\",\n\t\t\t xd->xd_example_ascii);\n\t}\n}",
          "fn_code_pos": [
            [
              39,
              0
            ],
            [
              85,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_XTIFFPrintDirectory",
            "parameters": {
              "tif": "TIFF",
              "fd": "FILE",
              "flags": "long"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\n_XTIFFVSetField(TIFF* tif, ttag_t tag, va_list ap)\n{\n\txtiff *xt = XTIFFDIR(tif);\n\tXTIFFDirectory* xd = &xt->xtif_dir;\n\tint status = 1;\n\tuint32 v32=0;\n\tint i=0, v=0;\n\tva_list ap1 = ap;\n\n\t/* va_start is called by the calling routine */\n\t\n\tswitch (tag) {\n\t\t/* \n                 * XXX put your extended tags here; replace the implemented\n                 *     example tags with your own. \n                 */\n\tcase TIFFTAG_EXAMPLE_MULTI:\n\t\t/* multi-valued tags need to store the count as well */\n\t\txd->xd_num_multi = (uint16) va_arg(ap, int);\n\t\t_TIFFsetDoubleArray(&xd->xd_example_multi, va_arg(ap, double*),\n\t\t\t(long) xd->xd_num_multi);\n\t\tbreak;\n\tcase TIFFTAG_EXAMPLE_SINGLE:\n\t\txd->xd_example_single = va_arg(ap, uint32);\n\t\tbreak;\n\tcase TIFFTAG_EXAMPLE_ASCII:\n\t\t_TIFFsetString(&xd->xd_example_ascii, va_arg(ap, char*));\n\t\tbreak;\n\tdefault:\n\t\t/* call the inherited method */\n\t\treturn (PARENT(xt,vsetfield))(tif,tag,ap);\n\t\tbreak;\n\t}\n\tif (status) {\n\t\t/* we have to override the print method here,\n \t\t * after the compression tags have gotten to it.\n\t\t * This makes sense because the only time we would\n\t\t * need the extended print method is if an extended\n\t\t * tag is set by the reader.\n\t\t */\n\t\tif (!(xt->xtif_flags & XTIFFP_PRINT))\n\t\t{\n\t        \tPARENT(xt,printdir) =  TIFFMEMBER(tif,printdir);\n      \t\t  \tTIFFMEMBER(tif,printdir) = _XTIFFPrintDirectory;\n\t\t\txt->xtif_flags |= XTIFFP_PRINT;\n\t\t}\n\t\tTIFFSetFieldBit(tif, _TIFFFieldWithTag(tif, tag)->field_bit);\n\t\ttif->tif_flags |= TIFF_DIRTYDIRECT;\n\t}\n\tva_end(ap);\n\treturn (status);\nbadvalue:\n\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"%d: Bad value for \\\"%s\\\"\", v,\n\t    _TIFFFieldWithTag(tif, tag)->field_name);\n\tva_end(ap);\n\treturn (0);\nbadvalue32:\n\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name, \"%ld: Bad value for \\\"%s\\\"\", v32,\n\t    _TIFFFieldWithTag(tif, tag)->field_name);\n\tva_end(ap);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              87,
              0
            ],
            [
              149,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_XTIFFVSetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "ttag_t",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\n_XTIFFVGetField(TIFF* tif, ttag_t tag, va_list ap)\n{\n\txtiff *xt = XTIFFDIR(tif);\n\tXTIFFDirectory* xd = &xt->xtif_dir;\n\n\tswitch (tag) {\n\t\t/* \n                 * XXX put your extended tags here; replace the implemented\n                 *     example tags with your own.\n                 */\n\tcase TIFFTAG_EXAMPLE_MULTI:\n\t\t*va_arg(ap, uint16*) = xd->xd_num_multi;\n\t\t*va_arg(ap, double**) = xd->xd_example_multi;\n\t\tbreak;\n\tcase TIFFTAG_EXAMPLE_ASCII:\n\t\t*va_arg(ap, char**) = xd->xd_example_ascii;\n\t\tbreak;\n\tcase TIFFTAG_EXAMPLE_SINGLE:\n\t\t*va_arg(ap, uint32*) = xd->xd_example_single;\n\t\tbreak;\n\tdefault:\n\t\t/* return inherited method */\n\t\treturn (PARENT(xt,vgetfield))(tif,tag,ap);\n\t\tbreak;\n\t}\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              179,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_XTIFFVGetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "ttag_t",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\n_XTIFFFreeDirectory(xtiff* xt)\n{\n\tXTIFFDirectory* xd = &xt->xtif_dir;\n\n\t/* \n\t *  XXX - Purge all Your allocated memory except\n\t *  for the xtiff directory itself. This includes\n\t *  all fields that require a _TIFFsetXXX call in\n\t *  _XTIFFVSetField().\n\t */\n\t\n\tCleanupField(xd_example_multi);\n\tCleanupField(xd_example_ascii);\n\t\n}",
          "fn_code_pos": [
            [
              190,
              0
            ],
            [
              205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_XTIFFFreeDirectory",
            "parameters": {
              "xt": "xtiff"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void _XTIFFLocalDefaultDirectory(TIFF *tif)\n{\n\txtiff *xt = XTIFFDIR(tif);\n\tXTIFFDirectory* xd = &xt->xtif_dir;\n\n\t/* Install the extended Tag field info */\n\t_TIFFMergeFieldInfo(tif, xtiffFieldInfo, N(xtiffFieldInfo));\n\n\t/*\n\t *  free up any dynamically allocated arrays\n\t *  before the new directory is read in.\n\t */\n\t \n\t_XTIFFFreeDirectory(xt);\t\n\t_TIFFmemset(xt,0,sizeof(xtiff));\n\n\t/* Override the tag access methods */\n\n\tPARENT(xt,vsetfield) =  TIFFMEMBER(tif,vsetfield);\n\tTIFFMEMBER(tif,vsetfield) = _XTIFFVSetField;\n\tPARENT(xt,vgetfield) =  TIFFMEMBER(tif,vgetfield);\n\tTIFFMEMBER(tif,vgetfield) = _XTIFFVGetField;\n\n\t/* \n\t * XXX Set up any default values here.\n\t */\n\t\n\txd->xd_example_single = 234;\n}",
          "fn_code_pos": [
            [
              208,
              0
            ],
            [
              236,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_XTIFFLocalDefaultDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\n_XTIFFDefaultDirectory(TIFF *tif)\n{\n\txtiff *xt;\n\t\n\t/* Allocate Directory Structure if first time, and install it */\n\tif (!(tif->tif_flags & XTIFF_INITIALIZED))\n\t{\n\t\txt = _TIFFmalloc(sizeof(xtiff));\n\t\tif (!xt)\n\t\t{\n\t\t\t/* handle memory allocation failure here ! */\n\t\t\treturn;\n\t\t}\n\t\t_TIFFmemset(xt,0,sizeof(xtiff));\n\t\t/*\n\t\t * Install into TIFF structure.\n\t\t */\n\t\tTIFFMEMBER(tif,clientdir) = (tidata_t)xt;\n\t\ttif->tif_flags |= XTIFF_INITIALIZED; /* don't do this again! */\n\t}\n\t\n\t/* set up our own defaults */\n\t_XTIFFLocalDefaultDirectory(tif);\n\n\t/* Since an XTIFF client module may have overridden\n\t * the default directory method, we call it now to\n\t * allow it to set up the rest of its own methods.\n         */\n\n\tif (_ParentExtender) \n\t\t(*_ParentExtender)(tif);\n\n}",
          "fn_code_pos": [
            [
              252,
              0
            ],
            [
              285,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_XTIFFDefaultDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid _XTIFFInitialize(void)\n{\n\tstatic first_time=1;\n\t\n\tif (! first_time) return; /* Been there. Done that. */\n\tfirst_time = 0;\n\t\n\t/* Grab the inherited method and install */\n\t_ParentExtender = TIFFSetTagExtender(_XTIFFDefaultDirectory);\n}",
          "fn_code_pos": [
            [
              292,
              0
            ],
            [
              302,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_XTIFFInitialize",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFF*\nXTIFFOpen(const char* name, const char* mode)\n{\n\t/* Set up the callback */\n\t_XTIFFInitialize();\t\n\t\n\t/* Open the file; the callback will set everything up\n\t */\n\treturn TIFFOpen(name, mode);\n}",
          "fn_code_pos": [
            [
              308,
              0
            ],
            [
              317,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XTIFFOpen",
            "parameters": {
              "name": "char",
              "mode": "char"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "TIFF*\nXTIFFFdOpen(int fd, const char* name, const char* mode)\n{\n\t/* Set up the callback */\n\t_XTIFFInitialize();\t\n\n\t/* Open the file; the callback will set everything up\n\t */\n\treturn TIFFFdOpen(fd, name, mode);\n}",
          "fn_code_pos": [
            [
              319,
              0
            ],
            [
              328,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XTIFFFdOpen",
            "parameters": {
              "fd": "int",
              "name": "char",
              "mode": "char"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "void\nXTIFFClose(TIFF *tif)\n{\n\txtiff *xt = XTIFFDIR(tif);\n\t\n\t/* call inherited function first */\n\tTIFFClose(tif);\n\t\n\t/* Free up extended allocated memory */\n\t_XTIFFFreeDirectory(xt);\n\t_TIFFfree(xt);\n}",
          "fn_code_pos": [
            [
              331,
              0
            ],
            [
              342,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XTIFFClose",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "XTIFFOpen(const char* name, const char* mode)",
          "fn_dec_pos": [
            [
              309,
              0
            ],
            [
              309,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XTIFFOpen",
            "parameters": {
              "name": "char",
              "mode": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "XTIFFFdOpen(int fd, const char* name, const char* mode)",
          "fn_dec_pos": [
            [
              320,
              0
            ],
            [
              320,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XTIFFFdOpen",
            "parameters": {
              "fd": "int",
              "name": "char",
              "mode": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"xtiffiop.h\"\n",
          [
            13,
            0
          ],
          [
            14,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/addtiffo/tif_overview.c": {
      "fn_def_list": [
        {
          "fn_code": "uint32 TIFF_WriteOverview( TIFF *hTIFF, uint32 nXSize, uint32 nYSize,\n                           int nBitsPerPixel, int nPlanarConfig, int nSamples, \n                           int nBlockXSize, int nBlockYSize,\n                           int bTiled, int nCompressFlag, int nPhotometric,\n                           int nSampleFormat,\n                           unsigned short *panRed,\n                           unsigned short *panGreen,\n                           unsigned short *panBlue,\n                           int bUseSubIFDs,\n                           int nHorSubsampling, int nVerSubsampling )\n\n{\n    toff_t\tnBaseDirOffset;\n    toff_t\tnOffset;\n    tdir_t\tiNumDir;\n\n    (void) bUseSubIFDs;\n\n    nBaseDirOffset = TIFFCurrentDirOffset( hTIFF );\n\n    TIFFCreateDirectory( hTIFF );\n\n/* -------------------------------------------------------------------- */\n/*      Setup TIFF fields.                                              */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    if( nSamples == 1 )\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n    else\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, nPlanarConfig );\n\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerPixel );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, nSamples );\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, nCompressFlag );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, nPhotometric );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat );\n\n    if( bTiled )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize );\n        TIFFSetField( hTIFF, TIFFTAG_TILELENGTH, nBlockYSize );\n    }\n    else\n        TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, nBlockYSize );\n\n    TIFFSetField( hTIFF, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE );\n\n    if( nPhotometric == PHOTOMETRIC_YCBCR || nPhotometric == PHOTOMETRIC_ITULAB )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_YCBCRSUBSAMPLING, nHorSubsampling, nVerSubsampling);\n        /* TODO: also write YCbCrPositioning and YCbCrCoefficients tag identical to source IFD */\n    }\n    /* TODO: add command-line parameter for selecting jpeg compression quality\n     * that gets ignored when compression isn't jpeg */\n\n/* -------------------------------------------------------------------- */\n/*\tWrite color table if one is present.\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( panRed != NULL )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panRed, panGreen, panBlue );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write directory, and return byte offset.                        */\n/* -------------------------------------------------------------------- */\n    if( TIFFWriteCheck( hTIFF, bTiled, \"TIFFBuildOverviews\" ) == 0 )\n        return 0;\n\n    TIFFWriteDirectory( hTIFF );\n    iNumDir = TIFFNumberOfDirectories(hTIFF);\n    if( iNumDir > TIFF_DIR_MAX )\n    {\n        TIFFErrorExt( TIFFClientdata(hTIFF),\n                      \"TIFF_WriteOverview\",\n                      \"File `%s' has too many directories.\\n\",\n                      TIFFFileName(hTIFF) );\n        exit(-1);\n    }\n    TIFFSetDirectory( hTIFF, (tdir_t) (iNumDir - 1) );\n\n    nOffset = TIFFCurrentDirOffset( hTIFF );\n\n    TIFFSetSubDirectory( hTIFF, nBaseDirOffset );\n\n    return nOffset;\n}",
          "fn_code_pos": [
            [
              81,
              0
            ],
            [
              168,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFF_WriteOverview",
            "parameters": {
              "hTIFF": "TIFF",
              "nXSize": "uint32",
              "nYSize": "uint32",
              "nBitsPerPixel": "int",
              "nPlanarConfig": "int",
              "nSamples": "int",
              "nBlockXSize": "int",
              "nBlockYSize": "int",
              "bTiled": "int",
              "nCompressFlag": "int",
              "nPhotometric": "int",
              "nSampleFormat": "int",
              "panRed": "unsigned short",
              "panGreen": "unsigned short",
              "panBlue": "unsigned short",
              "bUseSubIFDs": "int",
              "nHorSubsampling": "int",
              "nVerSubsampling": "int"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "static void \nTIFF_GetSourceSamples( double * padfSamples, unsigned char *pabySrc, \n                       int nPixelBytes, int nSampleFormat, \n                       uint32 nXSize, uint32 nYSize, \n                       int nPixelOffset, int nLineOffset )\n{\n    uint32  iXOff, iYOff;\n    int     iSample;\n\n    iSample = 0;\n\n    for( iYOff = 0; iYOff < nYSize; iYOff++ )\n    {\n        for( iXOff = 0; iXOff < nXSize; iXOff++ )\n        {\n            unsigned char *pabyData;\n\n            pabyData = pabySrc + iYOff * nLineOffset + iXOff * nPixelOffset;\n\n            if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 1 )\n            {\n                padfSamples[iSample++] = *pabyData;\n            }\n            else if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 2 )\n            {\n                padfSamples[iSample++] = ((uint16 *) pabyData)[0];\n            }\n            else if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 4 )\n            {\n                padfSamples[iSample++] = ((uint32 *) pabyData)[0];\n            }\n            else if( nSampleFormat == SAMPLEFORMAT_INT && nPixelBytes == 2 )\n            {\n                padfSamples[iSample++] = ((int16 *) pabyData)[0];\n            }\n            else if( nSampleFormat == SAMPLEFORMAT_INT && nPixelBytes == 32 )\n            {\n                padfSamples[iSample++] = ((int32 *) pabyData)[0];\n            }\n            else if( nSampleFormat == SAMPLEFORMAT_IEEEFP && nPixelBytes == 4 )\n            {\n                padfSamples[iSample++] = ((float *) pabyData)[0];\n            }\n            else if( nSampleFormat == SAMPLEFORMAT_IEEEFP && nPixelBytes == 8 )\n            {\n                padfSamples[iSample++] = ((double *) pabyData)[0];\n            }\n        }\n    }\n}",
          "fn_code_pos": [
            [
              174,
              0
            ],
            [
              223,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFF_GetSourceSamples",
            "parameters": {
              "padfSamples": "double",
              "pabySrc": "unsigned char",
              "nPixelBytes": "int",
              "nSampleFormat": "int",
              "nXSize": "uint32",
              "nYSize": "uint32",
              "nPixelOffset": "int",
              "nLineOffset": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void \nTIFF_SetSample( unsigned char * pabyData, int nPixelBytes, int nSampleFormat, \n                double dfValue )\n\n{\n    if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 1 )\n    {\n        *pabyData = (unsigned char) MAX(0,MIN(255,dfValue));\n    }\n    else if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 2 )\n    {\n        *((uint16 *)pabyData) = (uint16) MAX(0,MIN(65535,dfValue));\n    }\n    else if( nSampleFormat == SAMPLEFORMAT_UINT && nPixelBytes == 4 )\n    {\n        *((uint32 *)pabyData) = (uint32) dfValue;\n    }\n    else if( nSampleFormat == SAMPLEFORMAT_INT && nPixelBytes == 2 )\n    {\n        *((int16 *)pabyData) = (int16) MAX(-32768,MIN(32767,dfValue));\n    }\n    else if( nSampleFormat == SAMPLEFORMAT_INT && nPixelBytes == 32 )\n    {\n        *((int32 *)pabyData) = (int32) dfValue;\n    }\n    else if( nSampleFormat == SAMPLEFORMAT_IEEEFP && nPixelBytes == 4 )\n    {\n        *((float *)pabyData) = (float) dfValue;\n    }\n    else if( nSampleFormat == SAMPLEFORMAT_IEEEFP && nPixelBytes == 8 )\n    {\n        *((double *)pabyData) = dfValue;\n    }\n}",
          "fn_code_pos": [
            [
              229,
              0
            ],
            [
              262,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFF_SetSample",
            "parameters": {
              "pabyData": "unsigned char",
              "nPixelBytes": "int",
              "nSampleFormat": "int",
              "dfValue": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid TIFF_DownSample( unsigned char *pabySrcTile,\n                      uint32 nBlockXSize, uint32 nBlockYSize,\n                      int nPixelSkewBits, int nBitsPerPixel,\n                      unsigned char * pabyOTile,\n                      uint32 nOBlockXSize, uint32 nOBlockYSize,\n                      uint32 nTXOff, uint32 nTYOff, int nOMult,\n                      int nSampleFormat, const char * pszResampling )\n\n{\n    uint32\ti, j;\n    int         k, nPixelBytes = (nBitsPerPixel) / 8;\n    int\t\tnPixelGroupBytes = (nBitsPerPixel+nPixelSkewBits)/8;\n    unsigned char *pabySrc, *pabyDst;\n    double      *padfSamples;\n    size_t      tpadfSamples_size, padfSamples_size;\n\n    assert( nBitsPerPixel >= 8 );\n\n    /* sizeof(double) * nOMult * nOMult */\n    tpadfSamples_size=nOMult*nOMult;\n    if ((nOMult != 0) && (tpadfSamples_size/nOMult == (size_t) nOMult)) {\n        padfSamples_size=tpadfSamples_size;\n        tpadfSamples_size=padfSamples_size*sizeof(double);\n        if ((tpadfSamples_size / padfSamples_size) == sizeof(double))\n            padfSamples_size=tpadfSamples_size;\n        else\n            padfSamples_size=0;\n    } else {\n        padfSamples_size=0;\n    }\n    if (padfSamples_size == 0) {\n        /* TODO: This is an error condition */\n        return;\n    }\n    padfSamples = (double *) malloc(padfSamples_size);\n\n/* ==================================================================== */\n/*      Loop over scanline chunks to process, establishing where the    */\n/*      data is going.                                                  */\n/* ==================================================================== */\n    for( j = 0; j*nOMult < nBlockYSize; j++ )\n    {\n        if( j + nTYOff >= nOBlockYSize )\n            break;\n\n        pabyDst = pabyOTile + ((j+nTYOff)*nOBlockXSize + nTXOff)\n            * nPixelBytes * nPixelGroupBytes;\n\n/* -------------------------------------------------------------------- */\n/*      Handler nearest resampling ... we don't even care about the     */\n/*      data type, we just do a bytewise copy.                          */\n/* -------------------------------------------------------------------- */\n        if( strncmp(pszResampling,\"nearest\",4) == 0\n            || strncmp(pszResampling,\"NEAR\",4) == 0 )\n        {\n            pabySrc = pabySrcTile + j*nOMult*nBlockXSize * nPixelGroupBytes;\n\n            for( i = 0; i*nOMult < nBlockXSize; i++ )\n            {\n                if( i + nTXOff >= nOBlockXSize )\n                    break;\n            \n                /*\n                 * For now use simple subsampling, from the top left corner\n                 * of the source block of pixels.\n                 */\n\n                for( k = 0; k < nPixelBytes; k++ )\n                    pabyDst[k] = pabySrc[k];\n\n                pabyDst += nPixelBytes * nPixelGroupBytes;\n                pabySrc += nOMult * nPixelGroupBytes;\n            }\n        }\n\n/* -------------------------------------------------------------------- */\n/*      Handle the case of averaging.  For this we also have to         */\n/*      handle each sample format we are concerned with.                */\n/* -------------------------------------------------------------------- */\n        else if( strncmp(pszResampling,\"averag\",6) == 0\n                 || strncmp(pszResampling,\"AVERAG\",6) == 0 )\n        {\n            pabySrc = pabySrcTile + j*nOMult*nBlockXSize * nPixelGroupBytes;\n\n            for( i = 0; i*nOMult < nBlockXSize; i++ )\n            {\n                double   dfTotal;\n                uint32   nXSize, nYSize, iSample;\n\n                if( i + nTXOff >= nOBlockXSize )\n                    break;\n\n                nXSize = MIN((uint32)nOMult,nBlockXSize-i);\n                nYSize = MIN((uint32)nOMult,nBlockYSize-j);\n\n                TIFF_GetSourceSamples( padfSamples, pabySrc,\n                                       nPixelBytes, nSampleFormat,\n                                       nXSize, nYSize,\n                                       nPixelGroupBytes,\n                                       nPixelGroupBytes * nBlockXSize );\n\n                dfTotal = 0;\n                for( iSample = 0; iSample < nXSize*nYSize; iSample++ )\n                {\n                    dfTotal += padfSamples[iSample];\n                }\n\n                TIFF_SetSample( pabyDst, nPixelBytes, nSampleFormat, \n                                dfTotal / (nXSize*nYSize) );\n\n                pabySrc += nOMult * nPixelGroupBytes;\n                pabyDst += nPixelBytes;\n            }\n        }\n    }\n\n    free( padfSamples );\n}",
          "fn_code_pos": [
            [
              271,
              0
            ],
            [
              389,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFF_DownSample",
            "parameters": {
              "pabySrcTile": "unsigned char",
              "nBlockXSize": "uint32",
              "nBlockYSize": "uint32",
              "nPixelSkewBits": "int",
              "nBitsPerPixel": "int",
              "pabyOTile": "unsigned char",
              "nOBlockXSize": "uint32",
              "nOBlockYSize": "uint32",
              "nTXOff": "uint32",
              "nTYOff": "uint32",
              "nOMult": "int",
              "nSampleFormat": "int",
              "pszResampling": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static\nvoid TIFF_DownSample_Subsampled( unsigned char *pabySrcTile, int nSample,\n                                 uint32 nBlockXSize, uint32 nBlockYSize,\n                                 unsigned char * pabyOTile,\n                                 uint32 nOBlockXSize, uint32 nOBlockYSize,\n                                 uint32 nTXOff, uint32 nTYOff, int nOMult,\n                                 const char *pszResampling,\n                                 int nHorSubsampling, int nVerSubsampling )\n{\n    /* TODO: test with variety of subsampling values, and incovinient tile/strip sizes */\n    int nSampleBlockSize;\n    int nSourceSampleRowSize;\n    int nDestSampleRowSize;\n    uint32  nSourceX, nSourceY;\n    uint32  nSourceXSec, nSourceYSec;\n    uint32  nSourceXSecEnd, nSourceYSecEnd;\n    uint32  nDestX, nDestY;\n    int nSampleOffsetInSampleBlock;\n    unsigned int nCummulator;\n    unsigned int nCummulatorCount;\n\n    nSampleBlockSize = nHorSubsampling * nVerSubsampling + 2;\n    nSourceSampleRowSize = \n        ( ( nBlockXSize + nHorSubsampling - 1 ) / nHorSubsampling ) * nSampleBlockSize;\n    nDestSampleRowSize = \n        ( ( nOBlockXSize + nHorSubsampling - 1 ) / nHorSubsampling ) * nSampleBlockSize;\n\n    if( strncmp(pszResampling,\"nearest\",4) == 0\n        || strncmp(pszResampling,\"NEAR\",4) == 0 )\n    {\n    \tif( nSample == 0 )\n        {\n            for( nSourceY = 0, nDestY = nTYOff; \n                 nSourceY < nBlockYSize; \n                 nSourceY += nOMult, nDestY ++)\n            {\n                if( nDestY >= nOBlockYSize )\n                    break;\n\n                for( nSourceX = 0, nDestX = nTXOff; \n                     nSourceX < nBlockXSize; \n                     nSourceX += nOMult, nDestX ++)\n                {\n                    if( nDestX >= nOBlockXSize )\n                        break;\n\n                    * ( pabyOTile + ( nDestY / nVerSubsampling ) * nDestSampleRowSize\n                        + ( nDestY % nVerSubsampling ) * nHorSubsampling\n                        + ( nDestX / nHorSubsampling ) * nSampleBlockSize\n                        + ( nDestX % nHorSubsampling ) ) =\n                        * ( pabySrcTile + ( nSourceY / nVerSubsampling ) * nSourceSampleRowSize\n                            + ( nSourceY % nVerSubsampling ) * nHorSubsampling\n                            + ( nSourceX / nHorSubsampling ) * nSampleBlockSize\n                            + ( nSourceX % nHorSubsampling ) );\n                }\n            }\n        }\n        else\n        {\n            nSampleOffsetInSampleBlock = nHorSubsampling * nVerSubsampling + nSample - 1;\n            for( nSourceY = 0, nDestY = ( nTYOff / nVerSubsampling ); \n                 nSourceY < ( nBlockYSize / nVerSubsampling );\n                 nSourceY += nOMult, nDestY ++)\n            {\n                if( nDestY*nVerSubsampling >= nOBlockYSize )\n                    break;\n\n            \tfor( nSourceX = 0, nDestX = ( nTXOff / nHorSubsampling ); \n                     nSourceX < ( nBlockXSize / nHorSubsampling );\n                     nSourceX += nOMult, nDestX ++)\n                {\n                    if( nDestX*nHorSubsampling >= nOBlockXSize )\n                        break;\n\n                    * ( pabyOTile + nDestY * nDestSampleRowSize\n                        + nDestX * nSampleBlockSize\n                        + nSampleOffsetInSampleBlock ) =\n                    \t* ( pabySrcTile + nSourceY * nSourceSampleRowSize\n                            + nSourceX * nSampleBlockSize\n                            + nSampleOffsetInSampleBlock );\n                }\n            }\n        }\n    }\n    else if( strncmp(pszResampling,\"averag\",6) == 0\n             || strncmp(pszResampling,\"AVERAG\",6) == 0 )\n    {\n    \tif( nSample == 0 )\n        {\n            for( nSourceY = 0, nDestY = nTYOff; nSourceY < nBlockYSize; nSourceY += nOMult, nDestY ++)\n            {\n                if( nDestY >= nOBlockYSize )\n                    break;\n\n                for( nSourceX = 0, nDestX = nTXOff; nSourceX < nBlockXSize; nSourceX += nOMult, nDestX ++)\n                {\n                    if( nDestX >= nOBlockXSize )\n                        break;\n\n                    nSourceXSecEnd = nSourceX + nOMult;\n                    if( nSourceXSecEnd > nBlockXSize )\n                        nSourceXSecEnd = nBlockXSize;\n                    nSourceYSecEnd = nSourceY + nOMult;\n                    if( nSourceYSecEnd > nBlockYSize )\n                        nSourceYSecEnd = nBlockYSize;\n                    nCummulator = 0;\n                    for( nSourceYSec = nSourceY; nSourceYSec < nSourceYSecEnd; nSourceYSec ++)\n                    {\n                        for( nSourceXSec = nSourceX; nSourceXSec < nSourceXSecEnd; nSourceXSec ++)\n                        {\n                            nCummulator += * ( pabySrcTile + ( nSourceYSec / nVerSubsampling ) * nSourceSampleRowSize\n                                               + ( nSourceYSec % nVerSubsampling ) * nHorSubsampling\n                                               + ( nSourceXSec / nHorSubsampling ) * nSampleBlockSize\n                                               + ( nSourceXSec % nHorSubsampling ) );\n                        }\n                    }\n                    nCummulatorCount = ( nSourceXSecEnd - nSourceX ) * ( nSourceYSecEnd - nSourceY );\n                    * ( pabyOTile + ( nDestY / nVerSubsampling ) * nDestSampleRowSize\n                        + ( nDestY % nVerSubsampling ) * nHorSubsampling\n                        + ( nDestX / nHorSubsampling ) * nSampleBlockSize\n                        + ( nDestX % nHorSubsampling ) ) =\n                        ( ( nCummulator + ( nCummulatorCount >> 1 ) ) / nCummulatorCount );\n                }\n            }\n        }\n        else\n        {\n            nSampleOffsetInSampleBlock = nHorSubsampling * nVerSubsampling + nSample - 1;\n            for( nSourceY = 0, nDestY = ( nTYOff / nVerSubsampling ); nSourceY < ( nBlockYSize / nVerSubsampling );\n                 nSourceY += nOMult, nDestY ++)\n            {\n                if( nDestY*nVerSubsampling >= nOBlockYSize )\n                    break;\n\n                for( nSourceX = 0, nDestX = ( nTXOff / nHorSubsampling ); nSourceX < ( nBlockXSize / nHorSubsampling );\n                     nSourceX += nOMult, nDestX ++)\n                {\n                    if( nDestX*nHorSubsampling >= nOBlockXSize )\n                        break;\n\n                    nSourceXSecEnd = nSourceX + nOMult;\n                    if( nSourceXSecEnd > ( nBlockXSize / nHorSubsampling ) )\n                        nSourceXSecEnd = ( nBlockXSize / nHorSubsampling );\n                    nSourceYSecEnd = nSourceY + nOMult;\n                    if( nSourceYSecEnd > ( nBlockYSize / nVerSubsampling ) )\n                        nSourceYSecEnd = ( nBlockYSize / nVerSubsampling );\n                    nCummulator = 0;\n                    for( nSourceYSec = nSourceY; nSourceYSec < nSourceYSecEnd; nSourceYSec ++)\n                    {\n                        for( nSourceXSec = nSourceX; nSourceXSec < nSourceXSecEnd; nSourceXSec ++)\n                        {\n                            nCummulator += * ( pabySrcTile + nSourceYSec * nSourceSampleRowSize\n                                               + nSourceXSec * nSampleBlockSize\n                                               + nSampleOffsetInSampleBlock );\n                        }\n                    }\n                    nCummulatorCount = ( nSourceXSecEnd - nSourceX ) * ( nSourceYSecEnd - nSourceY );\n                    * ( pabyOTile + nDestY * nDestSampleRowSize\n                        + nDestX * nSampleBlockSize\n                        + nSampleOffsetInSampleBlock ) =\n                        ( ( nCummulator + ( nCummulatorCount >> 1 ) ) / nCummulatorCount );\n                }\n            }\n        }\n    }\n}",
          "fn_code_pos": [
            [
              394,
              0
            ],
            [
              559,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFF_DownSample_Subsampled",
            "parameters": {
              "pabySrcTile": "unsigned char",
              "nSample": "int",
              "nBlockXSize": "uint32",
              "nBlockYSize": "uint32",
              "pabyOTile": "unsigned char",
              "nOBlockXSize": "uint32",
              "nOBlockYSize": "uint32",
              "nTXOff": "uint32",
              "nTYOff": "uint32",
              "nOMult": "int",
              "pszResampling": "char",
              "nHorSubsampling": "int",
              "nVerSubsampling": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void TIFF_ProcessFullResBlock( TIFF *hTIFF, int nPlanarConfig,\n                               int bSubsampled,\n                               int nHorSubsampling, int nVerSubsampling,\n                               int nOverviews, int * panOvList,\n                               int nBitsPerPixel,\n                               int nSamples, TIFFOvrCache ** papoRawBIs,\n                               uint32 nSXOff, uint32 nSYOff,\n                               unsigned char *pabySrcTile,\n                               uint32 nBlockXSize, uint32 nBlockYSize,\n                               int nSampleFormat, const char * pszResampling )\n    \n{\n    int\t\tiOverview, iSample;\n\n    for( iSample = 0; iSample < nSamples; iSample++ )\n    {\n        /*\n         * We have to read a tile/strip for each sample for\n         * PLANARCONFIG_SEPARATE.  Otherwise, we just read all the samples\n         * at once when handling the first sample.\n         */\n        if( nPlanarConfig == PLANARCONFIG_SEPARATE || iSample == 0 )\n        {\n            if( TIFFIsTiled(hTIFF) )\n            {\n                TIFFReadEncodedTile( hTIFF,\n                                     TIFFComputeTile(hTIFF, nSXOff, nSYOff,\n                                                     0, (tsample_t)iSample ),\n                                     pabySrcTile,\n                                     TIFFTileSize(hTIFF));\n            }\n            else\n            {\n                TIFFReadEncodedStrip( hTIFF,\n                                      TIFFComputeStrip(hTIFF, nSYOff,\n                                                       (tsample_t) iSample),\n                                      pabySrcTile,\n                                      TIFFStripSize(hTIFF) );\n            }\n        }\n\n        /*        \n         * Loop over destination overview layers\n         */\n        for( iOverview = 0; iOverview < nOverviews; iOverview++ )\n        {\n            TIFFOvrCache *poRBI = papoRawBIs[iOverview];\n            unsigned char *pabyOTile;\n            uint32  nTXOff, nTYOff, nOXOff, nOYOff, nOMult;\n            uint32  nOBlockXSize = poRBI->nBlockXSize;\n            uint32  nOBlockYSize = poRBI->nBlockYSize;\n            int     nSkewBits, nSampleByteOffset; \n\n            /*\n             * Fetch the destination overview tile\n             */\n            nOMult = panOvList[iOverview];\n            nOXOff = (nSXOff/nOMult) / nOBlockXSize;\n            nOYOff = (nSYOff/nOMult) / nOBlockYSize;\n\n            if( bSubsampled )\n            {\n                pabyOTile = TIFFGetOvrBlock_Subsampled( poRBI, nOXOff, nOYOff );\n\n                /*\n                 * Establish the offset into this tile at which we should\n                 * start placing data.\n                 */\n                nTXOff = (nSXOff - nOXOff*nOMult*nOBlockXSize) / nOMult;\n                nTYOff = (nSYOff - nOYOff*nOMult*nOBlockYSize) / nOMult;\n\n\n#ifdef DBMALLOC\n                malloc_chain_check( 1 );\n#endif\n                TIFF_DownSample_Subsampled( pabySrcTile, iSample,\n                                            nBlockXSize, nBlockYSize,\n                                            pabyOTile,\n                                            poRBI->nBlockXSize, poRBI->nBlockYSize,\n                                            nTXOff, nTYOff,\n                                            nOMult, pszResampling,\n                                            nHorSubsampling, nVerSubsampling );\n#ifdef DBMALLOC\n                malloc_chain_check( 1 );\n#endif\n\n            }\n            else\n            {\n\n                pabyOTile = TIFFGetOvrBlock( poRBI, nOXOff, nOYOff, iSample );\n\n                /*\n                 * Establish the offset into this tile at which we should\n                 * start placing data.\n                 */\n                nTXOff = (nSXOff - nOXOff*nOMult*nOBlockXSize) / nOMult;\n                nTYOff = (nSYOff - nOYOff*nOMult*nOBlockYSize) / nOMult;\n\n                /*\n                 * Figure out the skew (extra space between ``our samples'') and\n                 * the byte offset to the first sample.\n                 */\n                assert( (nBitsPerPixel % 8) == 0 );\n                if( nPlanarConfig == PLANARCONFIG_SEPARATE )\n                {\n                    nSkewBits = 0;\n                    nSampleByteOffset = 0;\n                }\n                else\n                {\n                    nSkewBits = nBitsPerPixel * (nSamples-1);\n                    nSampleByteOffset = (nBitsPerPixel/8) * iSample;\n                }\n\n                /*\n                 * Perform the downsampling.\n                 */\n#ifdef DBMALLOC\n                malloc_chain_check( 1 );\n#endif\n                TIFF_DownSample( pabySrcTile + nSampleByteOffset,\n                               nBlockXSize, nBlockYSize,\n                               nSkewBits, nBitsPerPixel, pabyOTile,\n                               poRBI->nBlockXSize, poRBI->nBlockYSize,\n                               nTXOff, nTYOff,\n                               nOMult, nSampleFormat, pszResampling );\n#ifdef DBMALLOC\n                malloc_chain_check( 1 );\n#endif\n            }\n        }\n    }\n}",
          "fn_code_pos": [
            [
              568,
              0
            ],
            [
              701,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFF_ProcessFullResBlock",
            "parameters": {
              "hTIFF": "TIFF",
              "nPlanarConfig": "int",
              "bSubsampled": "int",
              "nHorSubsampling": "int",
              "nVerSubsampling": "int",
              "nOverviews": "int",
              "panOvList": "int",
              "nBitsPerPixel": "int",
              "nSamples": "int",
              "papoRawBIs": "TIFFOvrCache",
              "nSXOff": "uint32",
              "nSYOff": "uint32",
              "pabySrcTile": "unsigned char",
              "nBlockXSize": "uint32",
              "nBlockYSize": "uint32",
              "nSampleFormat": "int",
              "pszResampling": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void TIFFBuildOverviews( TIFF *hTIFF, int nOverviews, int * panOvList,\n                         int bUseSubIFDs, const char *pszResampleMethod,\n                         int (*pfnProgress)( double, void * ),\n                         void * pProgressData )\n\n{\n    TIFFOvrCache\t**papoRawBIs;\n    uint32\t\tnXSize, nYSize, nBlockXSize, nBlockYSize;\n    uint16\t\tnBitsPerPixel, nPhotometric, nCompressFlag, nSamples,\n        nPlanarConfig, nSampleFormat;\n    int         bSubsampled;\n    uint16      nHorSubsampling, nVerSubsampling;\n    int\t\t\tbTiled, nSXOff, nSYOff, i;\n    unsigned char\t*pabySrcTile;\n    uint16\t\t*panRedMap, *panGreenMap, *panBlueMap;\n    TIFFErrorHandler    pfnWarning;\n\n    (void) pfnProgress;\n    (void) pProgressData;\n\n/* -------------------------------------------------------------------- */\n/*      Get the base raster size.                                       */\n/* -------------------------------------------------------------------- */\n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &nXSize );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &nYSize );\n\n    TIFFGetField( hTIFF, TIFFTAG_BITSPERSAMPLE, &nBitsPerPixel );\n    /* TODO: nBitsPerPixel seems misnomer and may need renaming to nBitsPerSample */\n    TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, &nSamples );\n    TIFFGetFieldDefaulted( hTIFF, TIFFTAG_PLANARCONFIG, &nPlanarConfig );\n\n    TIFFGetFieldDefaulted( hTIFF, TIFFTAG_PHOTOMETRIC, &nPhotometric );\n    TIFFGetFieldDefaulted( hTIFF, TIFFTAG_COMPRESSION, &nCompressFlag );\n    TIFFGetFieldDefaulted( hTIFF, TIFFTAG_SAMPLEFORMAT, &nSampleFormat );\n\n    if( nPhotometric == PHOTOMETRIC_YCBCR || nPhotometric == PHOTOMETRIC_ITULAB )\n    {\n        if( nBitsPerPixel != 8 || nSamples != 3 || nPlanarConfig != PLANARCONFIG_CONTIG ||\n            nSampleFormat != SAMPLEFORMAT_UINT)\n        {\n            /* TODO: use of TIFFError is inconsistent with use of fprintf in addtiffo.c, sort out */\n            TIFFErrorExt( TIFFClientdata(hTIFF), \"TIFFBuildOverviews\",\n                          \"File `%s' has an unsupported subsampling configuration.\\n\",\n                          TIFFFileName(hTIFF) );\n            /* If you need support for this particular flavor, please contact either\n             * Frank Warmerdam warmerdam@pobox.com\n             * Joris Van Damme info@awaresystems.be\n             */\n            return;\n        }\n        bSubsampled = 1;\n        TIFFGetField( hTIFF, TIFFTAG_YCBCRSUBSAMPLING, &nHorSubsampling, &nVerSubsampling );\n        /* TODO: find out if maybe TIFFGetFieldDefaulted is better choice for YCbCrSubsampling tag */\n    }\n    else\n    {\n        if( nBitsPerPixel < 8 )\n        {\n            /* TODO: use of TIFFError is inconsistent with use of fprintf in addtiffo.c, sort out */\n            TIFFErrorExt( TIFFClientdata(hTIFF), \"TIFFBuildOverviews\",\n                          \"File `%s' has samples of %d bits per sample.  Sample\\n\"\n                          \"sizes of less than 8 bits per sample are not supported.\\n\",\n                          TIFFFileName(hTIFF), nBitsPerPixel );\n            return;\n        }\n        bSubsampled = 0;\n        nHorSubsampling = 1;\n        nVerSubsampling = 1;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Turn off warnings to avoid alot of repeated warnings while      */\n/*      rereading directories.                                          */\n/* -------------------------------------------------------------------- */\n    pfnWarning = TIFFSetWarningHandler( NULL );\n\n/* -------------------------------------------------------------------- */\n/*      Get the base raster block size.                                 */\n/* -------------------------------------------------------------------- */\n    if( TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP, &(nBlockYSize) ) )\n    {\n        nBlockXSize = nXSize;\n        bTiled = FALSE;\n    }\n    else\n    {\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &nBlockXSize );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &nBlockYSize );\n        bTiled = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*\tCapture the pallette if there is one.\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( TIFFGetField( hTIFF, TIFFTAG_COLORMAP,\n                      &panRedMap, &panGreenMap, &panBlueMap ) )\n    {\n        uint16\t\t*panRed2, *panGreen2, *panBlue2;\n        int             nColorCount = 1 << nBitsPerPixel;\n\n        panRed2 = (uint16 *) _TIFFmalloc(2*nColorCount);\n        panGreen2 = (uint16 *) _TIFFmalloc(2*nColorCount);\n        panBlue2 = (uint16 *) _TIFFmalloc(2*nColorCount);\n\n        memcpy( panRed2, panRedMap, 2 * nColorCount );\n        memcpy( panGreen2, panGreenMap, 2 * nColorCount );\n        memcpy( panBlue2, panBlueMap, 2 * nColorCount );\n\n        panRedMap = panRed2;\n        panGreenMap = panGreen2;\n        panBlueMap = panBlue2;\n    }\n    else\n    {\n        panRedMap = panGreenMap = panBlueMap = NULL;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Initialize overviews.                                           */\n/* -------------------------------------------------------------------- */\n    papoRawBIs = (TIFFOvrCache **) _TIFFmalloc(nOverviews*sizeof(void*));\n\n    for( i = 0; i < nOverviews; i++ )\n    {\n        uint32  nOXSize, nOYSize, nOBlockXSize, nOBlockYSize;\n        toff_t  nDirOffset;\n\n        nOXSize = (nXSize + panOvList[i] - 1) / panOvList[i];\n        nOYSize = (nYSize + panOvList[i] - 1) / panOvList[i];\n\n        nOBlockXSize = MIN(nBlockXSize,nOXSize);\n        nOBlockYSize = MIN(nBlockYSize,nOYSize);\n\n        if( bTiled )\n        {\n            if( (nOBlockXSize % 16) != 0 )\n                nOBlockXSize = nOBlockXSize + 16 - (nOBlockXSize % 16);\n\n            if( (nOBlockYSize % 16) != 0 )\n                nOBlockYSize = nOBlockYSize + 16 - (nOBlockYSize % 16);\n        }\n\n        nDirOffset = TIFF_WriteOverview( hTIFF, nOXSize, nOYSize,\n                                         nBitsPerPixel, nPlanarConfig,\n                                         nSamples, nOBlockXSize, nOBlockYSize,\n                                         bTiled, nCompressFlag, nPhotometric,\n                                         nSampleFormat,\n                                         panRedMap, panGreenMap, panBlueMap,\n                                         bUseSubIFDs,\n                                         nHorSubsampling, nVerSubsampling );\n        \n        papoRawBIs[i] = TIFFCreateOvrCache( hTIFF, nDirOffset );\n    }\n\n    if( panRedMap != NULL )\n    {\n        _TIFFfree( panRedMap );\n        _TIFFfree( panGreenMap );\n        _TIFFfree( panBlueMap );\n    }\n    \n/* -------------------------------------------------------------------- */\n/*      Allocate a buffer to hold a source block.                       */\n/* -------------------------------------------------------------------- */\n    if( bTiled )\n        pabySrcTile = (unsigned char *) _TIFFmalloc(TIFFTileSize(hTIFF));\n    else\n        pabySrcTile = (unsigned char *) _TIFFmalloc(TIFFStripSize(hTIFF));\n    \n/* -------------------------------------------------------------------- */\n/*      Loop over the source raster, applying data to the               */\n/*      destination raster.                                             */\n/* -------------------------------------------------------------------- */\n    for( nSYOff = 0; nSYOff < (int) nYSize; nSYOff += nBlockYSize )\n    {\n        for( nSXOff = 0; nSXOff < (int) nXSize; nSXOff += nBlockXSize )\n        {\n            /*\n             * Read and resample into the various overview images.\n             */\n            \n            TIFF_ProcessFullResBlock( hTIFF, nPlanarConfig,\n                                      bSubsampled,nHorSubsampling,nVerSubsampling,\n                                      nOverviews, panOvList,\n                                      nBitsPerPixel, nSamples, papoRawBIs,\n                                      nSXOff, nSYOff, pabySrcTile,\n                                      nBlockXSize, nBlockYSize,\n                                      nSampleFormat, pszResampleMethod );\n        }\n    }\n\n    _TIFFfree( pabySrcTile );\n\n/* -------------------------------------------------------------------- */\n/*      Cleanup the rawblockedimage files.                              */\n/* -------------------------------------------------------------------- */\n    for( i = 0; i < nOverviews; i++ )\n    {\n        TIFFDestroyOvrCache( papoRawBIs[i] );\n    }\n\n    if( papoRawBIs != NULL )\n        _TIFFfree( papoRawBIs );\n\n    TIFFSetWarningHandler( pfnWarning );\n}",
          "fn_code_pos": [
            [
              713,
              0
            ],
            [
              918,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFBuildOverviews",
            "parameters": {
              "hTIFF": "TIFF",
              "nOverviews": "int",
              "panOvList": "int",
              "bUseSubIFDs": "int",
              "pszResampleMethod": "char",
              "pfnProgress": "int",
              "pProgressData": "void"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFBuildOverviews( TIFF *, int, int *, int, const char *,\n                         int (*)(double,void*), void * )",
          "fn_dec_pos": [
            [
              69,
              5
            ],
            [
              70,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFBuildOverviews",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*pfnProgress)( double, void * )",
          "fn_dec_pos": [
            [
              715,
              29
            ],
            [
              715,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            50,
            0
          ],
          [
            51,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include \"tif_ovrcache.h\"\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/addtiffo/addtiffo.c": {
      "fn_def_list": [
        {
          "fn_code": "int main( int argc, char ** argv )\n\n{\n    int\t\tanOverviews[100];   /* TODO: un-hardwire array length, flexible allocate */\n    int\t\tnOverviewCount = 0;\n    int\t\tbUseSubIFD = 0;\n    TIFF\t*hTIFF;\n    const char  *pszResampling = \"nearest\";\n\n/* -------------------------------------------------------------------- */\n/*      Usage:                                                          */\n/* -------------------------------------------------------------------- */\n    if( argc < 2 )\n    {\n        printf( \"Usage: addtiffo [-r {nearest,average,mode}]\\n\"\n                \"                tiff_filename [resolution_reductions]\\n\"\n                \"\\n\"\n                \"Example:\\n\"\n                \" %% addtiffo abc.tif 2 4 8 16\\n\" );\n        return( 1 );\n    }\n\n    while( argv[1][0] == '-' )\n    {\n        if( strcmp(argv[1],\"-subifd\") == 0 )\n        {\n            bUseSubIFD = 1;\n            argv++;\n            argc--;\n        }\n        else if( strcmp(argv[1],\"-r\") == 0 )\n        {\n            argv += 2;\n            argc -= 2;\n            pszResampling = *argv;\n        }\n        else\n        {\n            fprintf( stderr, \"Incorrect parameters\\n\" );\n            return( 1 );\n        }\n    }\n\n    /* TODO: resampling mode parameter needs to be encoded in an integer from this point on */\n\n/* -------------------------------------------------------------------- */\n/*      Collect the user requested reduction factors.                   */\n/* -------------------------------------------------------------------- */\n    while( nOverviewCount < argc - 2 && nOverviewCount < 100 )\n    {\n        anOverviews[nOverviewCount] = atoi(argv[nOverviewCount+2]);\n        if( (anOverviews[nOverviewCount] <= 0) ||\n            ((anOverviews[nOverviewCount] > 1024)))\n        {\n            fprintf( stderr, \"Incorrect parameters\\n\" );\n            return(1);\n        }\n        nOverviewCount++;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Default to four overview levels.  It would be nicer if it       */\n/*      defaulted based on the size of the source image.                */\n/* -------------------------------------------------------------------- */\n    /* TODO: make it default based on the size of the source image */\n    if( nOverviewCount == 0 )\n    {\n        nOverviewCount = 4;\n\n        anOverviews[0] = 2;\n        anOverviews[1] = 4;\n        anOverviews[2] = 8;\n        anOverviews[3] = 16;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Build the overview.                                             */\n/* -------------------------------------------------------------------- */\n    hTIFF = TIFFOpen( argv[1], \"r+\" );\n    if( hTIFF == NULL )\n    {\n        fprintf( stderr, \"TIFFOpen(%s) failed.\\n\", argv[1] );\n        return( 1 );\n    }\n\n    TIFFBuildOverviews( hTIFF, nOverviewCount, anOverviews, bUseSubIFD,\n                        pszResampling, NULL, NULL );\n\n    TIFFClose( hTIFF );\n\n/* -------------------------------------------------------------------- */\n/*      Optionally test for memory leaks.                               */\n/* -------------------------------------------------------------------- */\n#ifdef DBMALLOC\n    malloc_dump(1);\n#endif\n\n    return( 0 );\n}",
          "fn_code_pos": [
            [
              73,
              0
            ],
            [
              171,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFBuildOverviews( TIFF *, int, int *, int, const char *,\n                         int (*)(double,void*), void * )",
          "fn_dec_pos": [
            [
              66,
              5
            ],
            [
              67,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFBuildOverviews",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            62,
            0
          ],
          [
            63,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/addtiffo/tif_ovrcache.c": {
      "fn_def_list": [
        {
          "fn_code": "TIFFOvrCache *TIFFCreateOvrCache( TIFF *hTIFF, toff_t nDirOffset )\n\n{\n    TIFFOvrCache\t*psCache;\n    toff_t\t\tnBaseDirOffset;\n\n    psCache = (TIFFOvrCache *) _TIFFmalloc(sizeof(TIFFOvrCache));\n    psCache->nDirOffset = nDirOffset;\n    psCache->hTIFF = hTIFF;\n    \n/* -------------------------------------------------------------------- */\n/*      Get definition of this raster from the TIFF file itself.        */\n/* -------------------------------------------------------------------- */\n    nBaseDirOffset = TIFFCurrentDirOffset( psCache->hTIFF );\n    TIFFSetSubDirectory( hTIFF, nDirOffset );\n    \n    TIFFGetField( hTIFF, TIFFTAG_IMAGEWIDTH, &(psCache->nXSize) );\n    TIFFGetField( hTIFF, TIFFTAG_IMAGELENGTH, &(psCache->nYSize) );\n\n    TIFFGetField( hTIFF, TIFFTAG_BITSPERSAMPLE, &(psCache->nBitsPerPixel) );\n    TIFFGetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, &(psCache->nSamples) );\n    TIFFGetField( hTIFF, TIFFTAG_PLANARCONFIG, &(psCache->nPlanarConfig) );\n\n    if( !TIFFIsTiled( hTIFF ) )\n    {\n        TIFFGetField( hTIFF, TIFFTAG_ROWSPERSTRIP, &(psCache->nBlockYSize) );\n        psCache->nBlockXSize = psCache->nXSize;\n        psCache->nBytesPerBlock = TIFFStripSize(hTIFF);\n        psCache->bTiled = FALSE;\n    }\n    else\n    {\n        TIFFGetField( hTIFF, TIFFTAG_TILEWIDTH, &(psCache->nBlockXSize) );\n        TIFFGetField( hTIFF, TIFFTAG_TILELENGTH, &(psCache->nBlockYSize) );\n        psCache->nBytesPerBlock = TIFFTileSize(hTIFF);\n        psCache->bTiled = TRUE;\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Compute some values from this.                                  */\n/* -------------------------------------------------------------------- */\n\n    psCache->nBlocksPerRow = (psCache->nXSize + psCache->nBlockXSize - 1)\n        \t\t/ psCache->nBlockXSize;\n    psCache->nBlocksPerColumn = (psCache->nYSize + psCache->nBlockYSize - 1)\n        \t\t/ psCache->nBlockYSize;\n\n    if (psCache->nPlanarConfig == PLANARCONFIG_SEPARATE)\n        psCache->nBytesPerRow = psCache->nBytesPerBlock\n            * psCache->nBlocksPerRow * psCache->nSamples;\n    else\n        psCache->nBytesPerRow =\n            psCache->nBytesPerBlock * psCache->nBlocksPerRow;\n\n\n/* -------------------------------------------------------------------- */\n/*      Allocate and initialize the data buffers.                       */\n/* -------------------------------------------------------------------- */\n\n    psCache->pabyRow1Blocks =\n        (unsigned char *) _TIFFmalloc(psCache->nBytesPerRow);\n    psCache->pabyRow2Blocks =\n        (unsigned char *) _TIFFmalloc(psCache->nBytesPerRow);\n\n    if ( psCache->pabyRow1Blocks == NULL\n         || psCache->pabyRow2Blocks == NULL )\n    {\n\t\tTIFFErrorExt( hTIFF->tif_clientdata, hTIFF->tif_name,\n\t\t\t\t\t  \"Can't allocate memory for overview cache.\" );\n                /* TODO: use of TIFFError is inconsistent with use of fprintf in addtiffo.c, sort out */\n                if (psCache->pabyRow1Blocks) _TIFFfree(psCache->pabyRow1Blocks);\n                if (psCache->pabyRow2Blocks) _TIFFfree(psCache->pabyRow2Blocks);\n                _TIFFfree( psCache );\n        return NULL;\n    }\n\n    _TIFFmemset( psCache->pabyRow1Blocks, 0, psCache->nBytesPerRow );\n    _TIFFmemset( psCache->pabyRow2Blocks, 0, psCache->nBytesPerRow );\n\n    psCache->nBlockOffset = 0;\n\n    TIFFSetSubDirectory( psCache->hTIFF, nBaseDirOffset );\n    \n    return psCache;\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCreateOvrCache",
            "parameters": {
              "hTIFF": "TIFF",
              "nDirOffset": "toff_t"
            },
            "return_type": "TIFFOvrCache"
          }
        },
        {
          "fn_code": "static void TIFFWriteOvrRow( TIFFOvrCache * psCache )\n\n{\n    int\t\tnRet, iTileX, iTileY = psCache->nBlockOffset;\n    unsigned char *pabyData;\n    toff_t\tnBaseDirOffset;\n    uint32      RowsInStrip;\n\n/* -------------------------------------------------------------------- */\n/*      If the output cache is multi-byte per sample, and the file      */\n/*      being written to is of a different byte order than the current  */\n/*      platform, we will need to byte swap the data.                   */\n/* -------------------------------------------------------------------- */\n    if( TIFFIsByteSwapped(psCache->hTIFF) )\n    {\n        if( psCache->nBitsPerPixel == 16 )\n            TIFFSwabArrayOfShort( (uint16 *) psCache->pabyRow1Blocks,\n                      (psCache->nBytesPerBlock * psCache->nSamples) / 2 );\n\n        else if( psCache->nBitsPerPixel == 32 )\n            TIFFSwabArrayOfLong( (uint32 *) psCache->pabyRow1Blocks,\n                         (psCache->nBytesPerBlock * psCache->nSamples) / 4 );\n\n        else if( psCache->nBitsPerPixel == 64 )\n            TIFFSwabArrayOfDouble( (double *) psCache->pabyRow1Blocks,\n                         (psCache->nBytesPerBlock * psCache->nSamples) / 8 );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Record original directory position, so we can restore it at     */\n/*      end.                                                            */\n/* -------------------------------------------------------------------- */\n    nBaseDirOffset = TIFFCurrentDirOffset( psCache->hTIFF );\n    nRet = TIFFSetSubDirectory( psCache->hTIFF, psCache->nDirOffset );\n    assert( nRet == 1 );\n\n/* -------------------------------------------------------------------- */\n/*      Write blocks to TIFF file.                                      */\n/* -------------------------------------------------------------------- */\n\tfor( iTileX = 0; iTileX < psCache->nBlocksPerRow; iTileX++ )\n\t{\n\t\tint nTileID;\n\n\t\tif (psCache->nPlanarConfig == PLANARCONFIG_SEPARATE)\n\t\t{\n\t\t\tint iSample;\n\n\t\t\tfor( iSample = 0; iSample < psCache->nSamples; iSample++ )\n\t\t\t{\n\t\t\t\tpabyData = TIFFGetOvrBlock( psCache, iTileX, iTileY, iSample );\n\n\t\t\t\tif( psCache->bTiled )\n\t\t\t\t{\n\t\t\t\t\tnTileID = TIFFComputeTile( psCache->hTIFF,\n\t\t\t\t\t    iTileX * psCache->nBlockXSize,\n\t\t\t\t\t    iTileY * psCache->nBlockYSize,\n\t\t\t\t\t    0, (tsample_t) iSample );\n\t\t\t\t\tTIFFWriteEncodedTile( psCache->hTIFF, nTileID,\n\t\t\t\t\t    pabyData,\n\t\t\t\t\t    TIFFTileSize(psCache->hTIFF) );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnTileID = TIFFComputeStrip( psCache->hTIFF,\n\t\t\t\t\t    iTileY * psCache->nBlockYSize,\n\t\t\t\t\t    (tsample_t) iSample );\n\t\t\t\t\tRowsInStrip=psCache->nBlockYSize;\n\t\t\t\t\tif ((iTileY+1)*psCache->nBlockYSize>psCache->nYSize)\n\t\t\t\t\t\tRowsInStrip=psCache->nYSize-iTileY*psCache->nBlockYSize;\n\t\t\t\t\tTIFFWriteEncodedStrip( psCache->hTIFF, nTileID,\n\t\t\t\t\t    pabyData,\n\t\t\t\t\t    TIFFVStripSize(psCache->hTIFF,RowsInStrip) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpabyData = TIFFGetOvrBlock( psCache, iTileX, iTileY, 0 );\n\n\t\t\tif( psCache->bTiled )\n\t\t\t{\n\t\t\t\tnTileID = TIFFComputeTile( psCache->hTIFF,\n\t\t\t\t    iTileX * psCache->nBlockXSize,\n\t\t\t\t    iTileY * psCache->nBlockYSize,\n\t\t\t\t    0, 0 );\n\t\t\t\tTIFFWriteEncodedTile( psCache->hTIFF, nTileID,\n\t\t\t\t    pabyData,\n\t\t\t\t    TIFFTileSize(psCache->hTIFF) );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnTileID = TIFFComputeStrip( psCache->hTIFF,\n\t\t\t\t    iTileY * psCache->nBlockYSize,\n\t\t\t\t    0 );\n\t\t\t\tRowsInStrip=psCache->nBlockYSize;\n\t\t\t\tif ((iTileY+1)*psCache->nBlockYSize>psCache->nYSize)\n\t\t\t\t\tRowsInStrip=psCache->nYSize-iTileY*psCache->nBlockYSize;\n\t\t\t\tTIFFWriteEncodedStrip( psCache->hTIFF, nTileID,\n\t\t\t\t    pabyData,\n\t\t\t\t    TIFFVStripSize(psCache->hTIFF,RowsInStrip) );\n\t\t\t}\n\t\t}\n\t}\n\t/* TODO: add checks on error status return of TIFFWriteEncodedTile and TIFFWriteEncodedStrip */\n\n/* -------------------------------------------------------------------- */\n/*      Rotate buffers.                                                 */\n/* -------------------------------------------------------------------- */\n    pabyData = psCache->pabyRow1Blocks;\n    psCache->pabyRow1Blocks = psCache->pabyRow2Blocks;\n    psCache->pabyRow2Blocks = pabyData;\n\n    _TIFFmemset( pabyData, 0, psCache->nBytesPerRow );\n\n    psCache->nBlockOffset++;\n\n/* -------------------------------------------------------------------- */\n/*      Restore access to original directory.                           */\n/* -------------------------------------------------------------------- */\n    TIFFFlush( psCache->hTIFF );\n    /* TODO: add checks on error status return of TIFFFlush */\n    TIFFSetSubDirectory( psCache->hTIFF, nBaseDirOffset );\n    /* TODO: add checks on error status return of TIFFSetSubDirectory */\n}",
          "fn_code_pos": [
            [
              134,
              0
            ],
            [
              258,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteOvrRow",
            "parameters": {
              "psCache": "TIFFOvrCache"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned char *TIFFGetOvrBlock( TIFFOvrCache *psCache, int iTileX, int iTileY,\n                                int iSample )\n\n{\n    long\t       nRowOffset;\n\n    if ( iTileY > psCache->nBlockOffset + 1 )\n        TIFFWriteOvrRow( psCache );\n\n    assert( iTileX >= 0 && iTileX < psCache->nBlocksPerRow );\n    assert( iTileY >= 0 && iTileY < psCache->nBlocksPerColumn );\n    assert( iTileY >= psCache->nBlockOffset\n            && iTileY < psCache->nBlockOffset+2 );\n    assert( iSample >= 0 && iSample < psCache->nSamples );\n\n    if (psCache->nPlanarConfig == PLANARCONFIG_SEPARATE)\n        nRowOffset = ((((toff_t) iTileX * psCache->nSamples) + iSample)\n                      * psCache->nBytesPerBlock);\n    else\n        nRowOffset = iTileX * psCache->nBytesPerBlock +\n            (psCache->nBitsPerPixel + 7) / 8 * iSample;\n\n    if ( iTileY == psCache->nBlockOffset )\n        return psCache->pabyRow1Blocks + nRowOffset;\n    else\n        return psCache->pabyRow2Blocks + nRowOffset;\n}",
          "fn_code_pos": [
            [
              266,
              0
            ],
            [
              292,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetOvrBlock",
            "parameters": {
              "psCache": "TIFFOvrCache",
              "iTileX": "int",
              "iTileY": "int",
              "iSample": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned char *TIFFGetOvrBlock_Subsampled( TIFFOvrCache *psCache, \n                                           int iTileX, int iTileY )\n\n{\n    int\t\tnRowOffset;\n\n    if( iTileY > psCache->nBlockOffset + 1 )\n        TIFFWriteOvrRow( psCache );\n\n    assert( iTileX >= 0 && iTileX < psCache->nBlocksPerRow );\n    assert( iTileY >= 0 && iTileY < psCache->nBlocksPerColumn );\n    assert( iTileY >= psCache->nBlockOffset\n            && iTileY < psCache->nBlockOffset+2 );\n    assert( psCache->nPlanarConfig != PLANARCONFIG_SEPARATE );\n\n    nRowOffset = iTileX * psCache->nBytesPerBlock;\n\n    if( iTileY == psCache->nBlockOffset )\n        return psCache->pabyRow1Blocks + nRowOffset;\n    else\n        return psCache->pabyRow2Blocks + nRowOffset;\n}",
          "fn_code_pos": [
            [
              298,
              0
            ],
            [
              319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetOvrBlock_Subsampled",
            "parameters": {
              "psCache": "TIFFOvrCache",
              "iTileX": "int",
              "iTileY": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "void TIFFDestroyOvrCache( TIFFOvrCache * psCache )\n\n{\n    while( psCache->nBlockOffset < psCache->nBlocksPerColumn )\n        TIFFWriteOvrRow( psCache );\n\n    _TIFFfree( psCache->pabyRow1Blocks );\n    _TIFFfree( psCache->pabyRow2Blocks );\n    _TIFFfree( psCache );\n}",
          "fn_code_pos": [
            [
              325,
              0
            ],
            [
              334,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFDestroyOvrCache",
            "parameters": {
              "psCache": "TIFFOvrCache"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFFCreateOvrCache( TIFF *hTIFF, toff_t nDirOffset )",
          "fn_dec_pos": [
            [
              40,
              14
            ],
            [
              40,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCreateOvrCache",
            "parameters": {
              "hTIFF": "TIFF",
              "nDirOffset": "toff_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFGetOvrBlock( TIFFOvrCache *psCache, int iTileX, int iTileY,\n                                int iSample )",
          "fn_dec_pos": [
            [
              266,
              15
            ],
            [
              267,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetOvrBlock",
            "parameters": {
              "psCache": "TIFFOvrCache",
              "iTileX": "int",
              "iTileY": "int",
              "iSample": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFGetOvrBlock_Subsampled( TIFFOvrCache *psCache, \n                                           int iTileX, int iTileY )",
          "fn_dec_pos": [
            [
              298,
              15
            ],
            [
              299,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetOvrBlock_Subsampled",
            "parameters": {
              "psCache": "TIFFOvrCache",
              "iTileX": "int",
              "iTileY": "int"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"tif_ovrcache.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/mfs/mfs_file.c": {
      "fn_def_list": [
        {
          "fn_code": "int mfs_open (void *buffer, int size, char *mode)\n{\n    int ret, i;\n    void *tmp;\n\n    if (library_init_done == FALSE)\n    {\n        mem_init ();\n        library_init_done = TRUE;\n    }\n\n    ret = -1;\n\n    /* Find a free fd */\n\n    for (i = 0; i < MAX_BUFFS; i++)\n    {\n        if (fds[i] == -1)\n        {\n            ret = i;\n            break;\n        }\n    }\n\n    if (i == MAX_BUFFS)     /* No more free descriptors */\n    {\n        ret = -1;\n        errno = EMFILE;\n    }\n\n    if (ret >= 0 && *mode == 'r')\n    {\n        if (buffer == (void *)NULL)\n        {\n            ret = -1;\n            errno = EINVAL;\n        }\n        else\n        {\n            buf[ret] = (char *)buffer;\n            buf_size[ret] = size;\n            buf_off[ret] = 0;\n        }\n    }\n    else if (ret >= 0 && *mode == 'w')\n    {\n\n        if (buffer != (void *)NULL)\n        {\n            ret = -1;\n            errno = EINVAL;\n        }\n\n        else\n        {\n            tmp = malloc (0);   /* Get a pointer */\n            if (tmp == (void *)NULL)\n            {\n                ret = -1;\n                errno = EDQUOT;\n            }\n            else\n            {\n                buf[ret] = (char *)tmp;\n                buf_size[ret] = 0;\n                buf_off[ret] = 0;\n            }\n        }\n    }\n    else if (ret >= 0 && *mode == 'a')\n    {\n        if (buffer == (void *) NULL)    /* Create space for client */\n        {\n            tmp = malloc (0);   /* Get a pointer */\n            if (tmp == (void *)NULL)\n            {\n                ret = -1;\n                errno = EDQUOT;\n            }\n            else\n            {\n                buf[ret] = (char *)tmp;\n                buf_size[ret] = 0;\n                buf_off[ret] = 0;\n            }\n        }\n        else                            /* Client has file read in already */\n        {\n            buf[ret] = (char *)buffer;\n            buf_size[ret] = size;\n            buf_off[ret] = 0;\n        }\n    }\n    else        /* Some other invalid combination of parameters */\n    {\n        ret = -1;\n        errno = EINVAL;\n    }\n\n    if (ret != -1)\n    {\n        fds[ret] = 0;\n        buf_mode[ret] = *mode;\n    }\n\n    return (ret);\n}",
          "fn_code_pos": [
            [
              118,
              0
            ],
            [
              224,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mfs_open",
            "parameters": {
              "buffer": "void",
              "size": "int",
              "mode": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int mfs_lseek (int fd, int offset, int whence)\n{\n    int ret;\n    long test_off;\n\n    if (fds[fd] == -1)  /* Not open */\n    {\n        ret = -1;\n        errno = EBADF;\n    }\n    else if (offset < 0 && whence == SEEK_SET)\n    {\n        ret = -1;\n        errno = EINVAL;\n    }\n    else\n    {\n        switch (whence)\n        {\n            case SEEK_SET:\n                if (offset > buf_size[fd])\n                    extend_mem_file (fd, offset);\n                buf_off[fd] = offset;\n                ret = offset;\n                break;\n\n            case SEEK_CUR:\n                test_off = buf_off[fd] + offset;\n\n                if (test_off < 0)\n                {\n                    ret = -1;\n                    errno = EINVAL;\n                }\n                else\n                {\n                    if (test_off > buf_size[fd])\n                        extend_mem_file (fd, test_off);\n                    buf_off[fd] = test_off;\n                    ret = test_off;\n                }\n                break;\n\n            case SEEK_END:\n                test_off = buf_size[fd] + offset;\n\n                if (test_off < 0)\n                {\n                    ret = -1;\n                    errno = EINVAL;\n                }\n                else\n                {\n                    if (test_off > buf_size[fd])\n                        extend_mem_file (fd, test_off);\n                    buf_off[fd] = test_off;\n                    ret = test_off;\n                }\n                break;\n\n            default:\n                errno = EINVAL;\n                ret = -1;\n                break;\n        }\n    }\n\n    return (ret);\n}",
          "fn_code_pos": [
            [
              241,
              0
            ],
            [
              309,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mfs_lseek",
            "parameters": {
              "fd": "int",
              "offset": "int",
              "whence": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int mfs_read (int fd, void *clnt_buf, int size)\n{\n    int ret;\n\n    if (fds[fd] == -1 || buf_mode[fd] != 'r')\n    {\n        /* File is either not open, or not opened for read */\n\n        ret = -1;\n        errno = EBADF;\n    }\n    else if (buf_off[fd] + size > buf_size[fd])\n    {\n        ret = 0;        /* EOF */\n    }\n    else\n    {\n        memcpy (clnt_buf, (void *) (buf[fd] + buf_off[fd]), size);\n        buf_off[fd] = buf_off[fd] + size;\n        ret = size;\n    }\n\n    return (ret);\n}",
          "fn_code_pos": [
            [
              326,
              0
            ],
            [
              349,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mfs_read",
            "parameters": {
              "fd": "int",
              "clnt_buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int mfs_write (int fd, void *clnt_buf, int size)\n{\n    int ret;\n\n    if (fds[fd] == -1 || buf_mode[fd] == 'r')\n    {\n        /* Either the file is not open or it is opened for reading only */\n\n        ret = -1;\n        errno = EBADF;\n    }\n    else if (buf_mode[fd] == 'w')\n    {\n        /* Write */\n\n        if (buf_off[fd] + size > buf_size[fd])\n        {       \n            extend_mem_file (fd, buf_off[fd] + size);\n            buf_size[fd] = (buf_off[fd] + size);\n        }\n\n        memcpy ((buf[fd] + buf_off[fd]), clnt_buf, size);\n        buf_off[fd] = buf_off[fd] + size;\n\n        ret = size;\n    }\n    else\n    {\n        /* Append */\n\n        if (buf_off[fd] != buf_size[fd])\n            buf_off[fd] = buf_size[fd];\n\n        extend_mem_file (fd, buf_off[fd] + size);\n        buf_size[fd] += size;\n\n        memcpy ((buf[fd] + buf_off[fd]), clnt_buf, size);\n        buf_off[fd] = buf_off[fd] + size;\n\n        ret = size;\n    }\n\n    return (ret);\n}",
          "fn_code_pos": [
            [
              366,
              0
            ],
            [
              409,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mfs_write",
            "parameters": {
              "fd": "int",
              "clnt_buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int mfs_size (int fd)\n{\n    int ret;\n\n    if (fds[fd] == -1)  /* Not open */\n    {\n        ret = -1;\n        errno = EBADF;\n    }\n    else\n        ret = buf_size[fd];\n\n    return (ret);\n}",
          "fn_code_pos": [
            [
              424,
              0
            ],
            [
              437,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mfs_size",
            "parameters": {
              "fd": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int mfs_map (int fd, char **addr, size_t *len)\n{\n    int ret; \n\n    if (fds[fd] == -1)  /* Not open */\n    {\n        ret = -1;\n        errno = EBADF;\n    }\n    else\n    {\n        *addr = buf[fd];\n        *len = buf_size[fd];\n        ret = 0;\n    }\n\n    return (ret);\n}",
          "fn_code_pos": [
            [
              455,
              0
            ],
            [
              472,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mfs_map",
            "parameters": {
              "fd": "int",
              "addr": "char",
              "len": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int mfs_unmap (int fd)\n{\n    return (0);\n}",
          "fn_code_pos": [
            [
              488,
              0
            ],
            [
              491,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mfs_unmap",
            "parameters": {
              "fd": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int mfs_close (int fd)\n{\n    int ret; \n\n    if (fds[fd] == -1)  /* Not open */\n    {\n        ret = -1;\n        errno = EBADF;\n    }\n    else\n    {\n        fds[fd] = -1;\n        ret = 0;\n    }\n\n    return (ret);\n}",
          "fn_code_pos": [
            [
              506,
              0
            ],
            [
              522,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mfs_close",
            "parameters": {
              "fd": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int extend_mem_file (int fd, int size)\n{\n    void *new_mem;\n    int ret;\n\n    if ((new_mem = realloc (buf[fd], size)) == (void *) NULL)\n        ret = -1;\n    else\n    {\n        buf[fd] = (char *) new_mem;\n        ret = 0;\n    }\n\n    return (ret);\n}",
          "fn_code_pos": [
            [
              537,
              0
            ],
            [
              551,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extend_mem_file",
            "parameters": {
              "fd": "int",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void mem_init ()\n{\n    int i;\n\n    for (i = 0; i < MAX_BUFFS; i++)\n    {\n        fds[i] = -1;\n        buf[i] = (char *)NULL;\n        buf_size[i] = 0;\n        buf_off[i] = 0;\n    }\n}",
          "fn_code_pos": [
            [
              566,
              0
            ],
            [
              577,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mem_init",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "mfs_open (void *ptr, int size, char *mode)",
          "fn_dec_pos": [
            [
              78,
              4
            ],
            [
              78,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mfs_open",
            "parameters": {
              "ptr": "void",
              "size": "int",
              "mode": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "mfs_lseek (int fd, int offset, int whence)",
          "fn_dec_pos": [
            [
              79,
              4
            ],
            [
              79,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mfs_lseek",
            "parameters": {
              "fd": "int",
              "offset": "int",
              "whence": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "mfs_read (int fd, void *buf, int size)",
          "fn_dec_pos": [
            [
              80,
              4
            ],
            [
              80,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mfs_read",
            "parameters": {
              "fd": "int",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "mfs_write (int fd, void *buf, int size)",
          "fn_dec_pos": [
            [
              81,
              4
            ],
            [
              81,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mfs_write",
            "parameters": {
              "fd": "int",
              "buf": "void",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "mfs_size (int fd)",
          "fn_dec_pos": [
            [
              82,
              4
            ],
            [
              82,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mfs_size",
            "parameters": {
              "fd": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "mfs_map (int fd, char **addr, size_t *len)",
          "fn_dec_pos": [
            [
              83,
              4
            ],
            [
              83,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mfs_map",
            "parameters": {
              "fd": "int",
              "addr": "char",
              "len": "size_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "mfs_unmap (int fd)",
          "fn_dec_pos": [
            [
              84,
              4
            ],
            [
              84,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mfs_unmap",
            "parameters": {
              "fd": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "mfs_close (int fd)",
          "fn_dec_pos": [
            [
              85,
              4
            ],
            [
              85,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mfs_close",
            "parameters": {
              "fd": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "extend_mem_file (int fd, int size)",
          "fn_dec_pos": [
            [
              86,
              11
            ],
            [
              86,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extend_mem_file",
            "parameters": {
              "fd": "int",
              "size": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "mem_init ()",
          "fn_dec_pos": [
            [
              87,
              12
            ],
            [
              87,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mem_init",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include    <stdio.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include    <stdlib.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include    <string.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/oss-fuzz/tiff_read_rgba_fuzzer.cc": {
      "fn_def_list": [
        {
          "fn_code": "void handle_error(const char *unused, const char *unused2, va_list unused3) {\n    return;\n}",
          "fn_code_pos": [
            [
              35,
              11
            ],
            [
              37,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "handle_error",
            "parameters": {
              "unused": "char",
              "unused2": "char",
              "unused3": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n  TIFFSetErrorHandler(handle_error);\n  TIFFSetWarningHandler(handle_error);\n  std::istringstream s(std::string(Data,Data+Size));\n  TIFF* tif = TIFFStreamOpen(\"MemTIFF\", &s);\n  if (!tif) {\n      return 0;\n  }\n  uint32 w, h;\n  uint32* raster;\n\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n  TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n  /* don't continue if file size is ludicrous */\n  if (TIFFTileSize64(tif) > MAX_SIZE) {\n      TIFFClose(tif);\n      return 0;\n  }\n  uint64 bufsize = TIFFTileSize64(tif);\n  /* don't continue if the buffer size greater than the max allowed by the fuzzer */\n  if (bufsize > MAX_SIZE || bufsize == 0) {\n      TIFFClose(tif);\n      return 0;\n  }\n  /* another hack to work around an OOM in tif_fax3.c */\n  uint32 tilewidth = 0;\n  uint32 imagewidth = 0;\n  TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tilewidth);\n  TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &imagewidth);\n  tilewidth = __TIFFSafeMultiply(uint32, tilewidth, 2);\n  imagewidth = __TIFFSafeMultiply(uint32, imagewidth, 2);\n  if (tilewidth * 2 > MAX_SIZE || imagewidth * 2 > MAX_SIZE || tilewidth == 0 || imagewidth == 0) {\n      TIFFClose(tif);\n      return 0;\n  }\n  uint32 size = __TIFFSafeMultiply(uint32, w, h);\n  if (size > MAX_SIZE || size == 0) {\n      TIFFClose(tif);\n      return 0;\n  }\n  raster = (uint32*) _TIFFmalloc(size * sizeof (uint32));\n  if (raster != NULL) {\n      TIFFReadRGBAImage(tif, w, h, raster, 0);\n      _TIFFfree(raster);\n  }\n  TIFFClose(tif);\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              39,
              11
            ],
            [
              87,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LLVMFuzzerTestOneInput",
            "parameters": {
              "Data": "uint8_t",
              "Size": "size_t"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <cstdint>\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <sstream>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <tiffio.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <tiffio.hxx>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/iptcutil/iptcutil.c": {
      "fn_def_list": [
        {
          "fn_code": "void formatString(FILE *ofile, const char *s, int len)\n{\n  putc('\"', ofile);\n  for (; len > 0; --len, ++s) {\n    int c = *s;\n    switch (c) {\n    case '&':\n      fputs(\"&amp;\", ofile);\n      break;\n#ifdef HANDLE_GT_LT\n    case '<':\n      fputs(\"&lt;\", ofile);\n      break;\n    case '>':\n      fputs(\"&gt;\", ofile);\n      break;\n#endif\n    case '\"':\n      fputs(\"&quot;\", ofile);\n      break;\n    default:\n      if (iscntrl(c))\n        fprintf(ofile, \"&#%d;\", c);\n      else\n        putc(*s, ofile);\n      break;\n    }\n  }\n  fputs(\"\\\"\\n\", ofile);\n}",
          "fn_code_pos": [
            [
              93,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "formatString",
            "parameters": {
              "ofile": "FILE",
              "s": "char",
              "len": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int convertHTMLcodes(char *s, int len)\n{\n  if (len <=0 || s==(char*)NULL || *s=='\\0')\n    return 0;\n\n  if (s[1] == '#')\n    {\n      int val, o;\n\n      if (sscanf(s,\"&#%d;\",&val) == 1)\n        {\n          o = 3;\n          while (s[o] != ';')\n            {\n              o++;\n              if (o > 5)\n                break;\n            }\n          if (o < 5)\n            strcpy(s+1, s+1+o);\n          *s = val;\n          return o;\n        }\n    }\n  else\n    {\n      int\n        i,\n        codes = sizeof(html_codes) / sizeof(html_code);\n\n      for (i=0; i < codes; i++)\n        {\n          if (html_codes[i].len <= len)\n            if (STRNICMP(s, html_codes[i].code, html_codes[i].len) == 0)\n              {\n                strcpy(s+1, s+html_codes[i].len);\n                *s = html_codes[i].val;\n                return html_codes[i].len-1;\n              }\n        }\n    }\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              147,
              0
            ],
            [
              190,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "convertHTMLcodes",
            "parameters": {
              "s": "char",
              "len": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int formatIPTC(FILE *ifile, FILE *ofile)\n{\n  unsigned int\n    foundiptc,\n    tagsfound;\n\n  char\n    *readable,\n    *str;\n\n  long\n    tagindx,\n    taglen;\n\n  int\n    i,\n    tagcount = sizeof(tags) / sizeof(tag_spec);\n\n  int\n    c,\n    dataset,\n    recnum;\n\n  foundiptc = 0; /* found the IPTC-Header */\n  tagsfound = 0; /* number of tags found */\n\n  c = getc(ifile);\n  while (c != EOF)\n    {\n      if (c == 0x1c)\n        foundiptc = 1;\n      else\n        {\n          if (foundiptc)\n            {\n              return -1;\n            }\n          else\n            {\n              c = getc(ifile);\n              continue;\n            }\n        }\n\n      /* we found the 0x1c tag and now grab the dataset and record number tags */\n      dataset = getc(ifile);\n      if ((char) dataset == EOF)\n        return -1;\n      recnum = getc(ifile);\n      if ((char) recnum == EOF)\n        return -1;\n      /* try to match this record to one of the ones in our named table */\n      for (i=0; i< tagcount; i++)\n        {\n          if (tags[i].id == recnum)\n            break;\n        }\n      if (i < tagcount)\n        readable = tags[i].name;\n      else\n        readable = \"\";\n\n      /* then we decode the length of the block that follows - long or short fmt */\n      c = getc(ifile);\n      if (c == EOF)\n        return 0;\n      if (c & (unsigned char) 0x80)\n        {\n          unsigned char\n            buffer[4];\n\n          for (i=0; i<4; i++)\n            {\n              c = getc(ifile);\n              if (c == EOF)\n                return -1;\n              buffer[i] = c;\n            }\n          taglen = (((long) buffer[ 0 ]) << 24) |\n            (((long) buffer[ 1 ]) << 16) | \n            (((long) buffer[ 2 ]) <<  8) |\n            (((long) buffer[ 3 ]));\n        }\n      else\n        {\n          int\n            x = c;\n\n          taglen = x << 8;\n          x = getc(ifile);\n          if (x == EOF)\n            return -1;\n          taglen |= (long) x;\n        }\n      /* Place limits on tag length */\n      if ((taglen <= 0) || (taglen > 1048576))\n        {\n          printf(\"Inappropriate IPTC tag length %ld\\n\",taglen);\n          return -1;\n        }\n      /* make a buffer to hold the tag data and snag it from the input stream */\n      str = (char *) malloc((unsigned int) (taglen+1));\n      if (str == (char *) NULL)\n        {\n          printf(\"Memory allocation failed\");\n          return 0;\n        }\n      for (tagindx=0; tagindx<taglen; tagindx++)\n        {\n          c = getc(ifile);\n          if (c == EOF)\n            {\n              free(str);\n              return -1;\n            }\n          str[tagindx] = c;\n        }\n      str[ taglen ] = 0;\n\n      /* now finish up by formatting this binary data into ASCII equivalent */\n      if (strlen(readable) > 0)\n        fprintf(ofile, \"%d#%d#%s=\",(unsigned int)dataset, (unsigned int) recnum, readable);\n      else\n        fprintf(ofile, \"%d#%d=\",(unsigned int)dataset, (unsigned int) recnum);\n      formatString( ofile, str, taglen );\n      free(str);\n\n      tagsfound++;\n\n      c = getc(ifile);\n    }\n  return tagsfound;\n}",
          "fn_code_pos": [
            [
              192,
              0
            ],
            [
              324,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "formatIPTC",
            "parameters": {
              "ifile": "FILE",
              "ofile": "FILE"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "char *super_fgets(char *b, int *blen, FILE *file)\n{\n  int\n    c,\n    len;\n\n  char\n    *q;\n\n  len=*blen;\n  for (q=b; ; q++)\n    {\n      c=fgetc(file);\n      if (c == EOF || c == '\\n')\n        break;\n      if (((long)q - (long)b + 1 ) >= (long) len)\n        {\n          long\n            tlen;\n\n          tlen=(long)q-(long)b;\n          len<<=1;\n          b=(char *) realloc((char *) b,(len+2));\n          if ((char *) b == (char *) NULL)\n            break;\n          q=b+tlen;\n        }\n      *q=(unsigned char) c;\n    }\n  *blen=0;\n  if ((unsigned char *)b != (unsigned char *) NULL)\n    {\n      int\n        tlen;\n\n      tlen=(long)q - (long)b;\n      if (tlen == 0)\n        return (char *) NULL;\n      b[tlen] = '\\0';\n      *blen=++tlen;\n    }\n  return b;\n}",
          "fn_code_pos": [
            [
              330,
              0
            ],
            [
              372,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "super_fgets",
            "parameters": {
              "b": "char",
              "blen": "int",
              "file": "FILE"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "int main(int argc, char *argv[])\n{            \n  /* unsigned int */\n  /*   length; */\n\n  /*unsigned char\n   *buffer;*/\n\n  int\n    i,\n    mode; /* iptc binary, or iptc text */\n\n  FILE\n    *ifile = stdin,\n    *ofile = stdout;\n\n  char\n    c,\n    *usage = \"usage: iptcutil -t | -b [-i file] [-o file] <input >output\";\n\n  if( argc < 2 )\n    {\n      puts(usage);\n      return 1;\n    }\n\n  mode = 0;\n  /* length = -1; */\n  /* buffer = (unsigned char *)NULL; */\n\n  for (i=1; i<argc; i++)\n    {\n      c = argv[i][0];\n      if (c == '-' || c == '/')\n        {\n          c = argv[i][1];\n          switch( c )\n            {\n            case 't':\n              mode = 1;\n#ifdef WIN32\n              /* Set \"stdout\" to binary mode: */\n              _setmode( _fileno( ofile ), _O_BINARY );\n#endif\n              break;\n            case 'b':\n              mode = 0;\n#ifdef WIN32\n              /* Set \"stdin\" to binary mode: */\n              _setmode( _fileno( ifile ), _O_BINARY );\n#endif\n              break;\n            case 'i':\n              if (mode == 0)\n                ifile = fopen(argv[++i], \"rb\");\n              else\n                ifile = fopen(argv[++i], \"rt\");\n              if (ifile == (FILE *)NULL)\n                {\n                  printf(\"Unable to open: %s\\n\", argv[i]);\n                  return 1;\n                }\n              break;\n            case 'o':\n              if (mode == 0)\n                ofile = fopen(argv[++i], \"wt\");\n              else\n                ofile = fopen(argv[++i], \"wb\");\n              if (ofile == (FILE *)NULL)\n                {\n                  printf(\"Unable to open: %s\\n\", argv[i]);\n                  return 1;\n                }\n              break;\n            default:\n              printf(\"Unknown option: %s\\n\", argv[i]);\n              return 1;\n            }\n        }\n      else\n        {\n          puts(usage);\n          return 1;\n        }\n    }\n\n  if (mode == 0) /* handle binary iptc info */\n    formatIPTC(ifile, ofile);\n\n  if (mode == 1) /* handle text form of iptc info */\n    {\n      char\n        brkused,\n        quoted,\n        *line,\n        *token,\n        *newstr;\n\n      int\n        state,\n        next;\n\n      unsigned char\n        recnum = 0,\n        dataset = 0;\n\n      int\n        inputlen = BUFFER_SZ;\n\n      line = (char *) malloc(inputlen);     \n      token = (char *)NULL;\n      while((line = super_fgets(line,&inputlen,ifile))!=NULL)\n        {\n          state=0;\n          next=0;\n\n          token = (char *) malloc(inputlen);     \n          newstr = (char *) malloc(inputlen);     \n          while(tokenizer(0, token, inputlen, line, \"\", \"=\", \"\\\"\", 0,\n                          &brkused,&next,&quoted)==0)\n            {\n              if (state == 0)\n                {                  \n                  int\n                    state,\n                    next;\n\n                  char\n                    brkused,\n                    quoted;\n\n                  state=0;\n                  next=0;\n                  while(tokenizer(0, newstr, inputlen, token, \"\", \"#\", \"\", 0,\n                                  &brkused, &next, &quoted)==0)\n                    {\n                      if (state == 0)\n                        dataset = (unsigned char) atoi(newstr);\n                      else\n                        if (state == 1)\n                          recnum = (unsigned char) atoi(newstr);\n                      state++;\n                    }\n                }\n              else\n                if (state == 1)\n                  {\n                    int\n                      next;\n\n                    unsigned long\n                      len;\n\n                    char\n                      brkused,\n                      quoted;\n\n                    next=0;\n                    len = strlen(token);\n                    while(tokenizer(0, newstr, inputlen, token, \"\", \"&\", \"\", 0,\n                                    &brkused, &next, &quoted)==0)\n                      {\n                        if (brkused && next > 0)\n                          {\n                            char\n                              *s = &token[next-1];\n\n                            len -= convertHTMLcodes(s, strlen(s));\n                          }\n                      }\n\n                    fputc(0x1c, ofile);\n                    fputc(dataset, ofile);\n                    fputc(recnum, ofile);\n                    if (len < 0x10000)\n                      {\n                        fputc((len >> 8) & 255, ofile);\n                        fputc(len & 255, ofile);\n                      }\n                    else\n                      {\n                        fputc(((len >> 24) & 255) | 0x80, ofile);\n                        fputc((len >> 16) & 255, ofile);\n                        fputc((len >> 8) & 255, ofile);\n                        fputc(len & 255, ofile);\n                      }\n                    next=0;\n                    while (len--)\n                      fputc(token[next++], ofile);\n                  }\n              state++;\n            }\n          free(token);\n          token = (char *)NULL;\n          free(newstr);\n          newstr = (char *)NULL;\n        }\n      free(line);\n\n      fclose( ifile );\n      fclose( ofile );\n    }\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              376,
              0
            ],
            [
              580,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int sindex(char ch,char *string)\n{\n  char *cp;\n  for(cp=string;*cp;++cp)\n    if(ch==*cp)\n      return (int)(cp-string);\t/* return position of character */\n  return -1;\t\t\t/* eol ... no match found */\n}",
          "fn_code_pos": [
            [
              779,
              0
            ],
            [
              786,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "sindex",
            "parameters": {
              "ch": "char",
              "string": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void chstore(char *string,int max,char ch)\n{\n  char c;\n  if(_p_tokpos>=0&&_p_tokpos<max-1)\n    {\n      if(_p_state==IN_QUOTE)\n        c=ch;\n      else\n        switch(_p_flag&3)\n          {\n          case 1: \t    /* convert to upper */\n            c=toupper((int) ch);\n            break;\n\n          case 2: \t    /* convert to lower */\n            c=tolower((int) ch);\n            break;\n\n          default:\t    /* use as is */\n            c=ch;\n            break;\n          }\n      string[_p_tokpos++]=c;\n    }\n  return;\n}",
          "fn_code_pos": [
            [
              790,
              0
            ],
            [
              815,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "chstore",
            "parameters": {
              "string": "char",
              "max": "int",
              "ch": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int tokenizer(unsigned inflag,char *token,int tokmax,char *line,\n              char *white,char *brkchar,char *quote,char eschar,char *brkused,\n              int *next,char *quoted)\n{\n  int qp;\n  char c,nc;\n\n  *brkused=0;\t\t/* initialize to null */\n  *quoted=0;\t\t/* assume not quoted  */\n\n  if(!line[*next])\t/* if we're at end of line, indicate such */\n    return 1;\n\n  _p_state=IN_WHITE;   /* initialize state */\n  _p_curquote=0;\t   /* initialize previous quote char */\n  _p_flag=inflag;\t   /* set option flag */\n\n  for(_p_tokpos=0;(c=line[*next]);++(*next))\t/* main loop */\n    {\n      if((qp=sindex(c,brkchar))>=0)  /* break */\n        {\n          switch(_p_state)\n            {\n\t    case IN_WHITE:\t\t/* these are the same here ...\t*/\n\t    case IN_TOKEN:\t\t/* ... just get out\t\t*/\n\t    case IN_OZONE:\t\t/* ditto\t\t\t*/\n\t      ++(*next);\n\t      *brkused=brkchar[qp];\n\t      goto byebye;\n\n\t    case IN_QUOTE:\t\t /* just keep going */\n\t      chstore(token,tokmax,c);\n\t      break;\n            }\n        }\n      else if((qp=sindex(c,quote))>=0)  /* quote */\n        {\n          switch(_p_state)\n            {\n\t    case IN_WHITE:\t /* these are identical, */\n\t      _p_state=IN_QUOTE; /* change states   */\n\t      _p_curquote=quote[qp]; /* save quote char */\n\t      *quoted=1;\t/* set to true as long as something is in quotes */\n\t      break;\n\n\t    case IN_QUOTE:\n\t      if(quote[qp]==_p_curquote) /* same as the beginning quote? */\n                {\n                  _p_state=IN_OZONE;\n                  _p_curquote=0;\n                }\n\t      else\n\t        chstore(token,tokmax,c); /* treat as regular char */\n\t      break;\n\n\t    case IN_TOKEN:\n\t    case IN_OZONE:\n\t      *brkused=c; /* uses quote as break char */\n\t      goto byebye;\n            }\n        }\n      else if((qp=sindex(c,white))>=0) /* white */\n        {\n          switch(_p_state)\n            {\n\t    case IN_WHITE:\n\t    case IN_OZONE:\n\t      break;\t\t/* keep going */\n\n\t    case IN_TOKEN:\n\t      _p_state=IN_OZONE;\n\t      break;\n\n\t    case IN_QUOTE:\n\t      chstore(token,tokmax,c); /* it's valid here */\n\t      break;\n            }\n        }\n      else if(c==eschar)  /* escape */\n        {\n          nc=line[(*next)+1];\n          if(nc==0) \t\t/* end of line */\n            {\n              *brkused=0;\n              chstore(token,tokmax,c);\n              ++(*next);\n              goto byebye;\n            }\n          switch(_p_state)\n            {\n\t    case IN_WHITE:\n\t      --(*next);\n\t      _p_state=IN_TOKEN;\n\t      break;\n\n\t    case IN_TOKEN:\n\t    case IN_QUOTE:\n\t      ++(*next);\n\t      chstore(token,tokmax,nc);\n\t      break;\n\n\t    case IN_OZONE:\n\t      goto byebye;\n            }\n        }\n      else\t/* anything else is just a real character */\n        {\n          switch(_p_state)\n            {\n\t    case IN_WHITE:\n\t      _p_state=IN_TOKEN; /* switch states */\n          /* Fall through */\n\n\t    case IN_TOKEN:\t\t /* these 2 are     */\n\t    case IN_QUOTE:\t\t /*  identical here */\n\t      chstore(token,tokmax,c);\n\t      break;\n\n\t    case IN_OZONE:\n\t      goto byebye;\n            }\n        }\n    }\t\t/* end of main loop */\n\n byebye:\n  token[_p_tokpos]=0;\t/* make sure token ends with EOS */\n\n  return 0;\n}",
          "fn_code_pos": [
            [
              817,
              0
            ],
            [
              945,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tokenizer",
            "parameters": {
              "inflag": "unsigned",
              "token": "char",
              "tokmax": "int",
              "line": "char",
              "white": "char",
              "brkchar": "char",
              "quote": "char",
              "eschar": "char",
              "brkused": "char",
              "next": "int",
              "quoted": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "tokenizer(unsigned inflag,char *token,int tokmax,char *line,\nchar *white,char *brkchar,char *quote,char eschar,char *brkused,\nint *next,char *quoted)",
          "fn_dec_pos": [
            [
              326,
              4
            ],
            [
              328,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tokenizer",
            "parameters": {
              "inflag": "unsigned",
              "token": "char",
              "tokmax": "int",
              "line": "char",
              "white": "char",
              "brkchar": "char",
              "quote": "char",
              "eschar": "char",
              "brkused": "char",
              "next": "int",
              "quoted": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "super_fgets(char *b, int *blen, FILE *file)",
          "fn_dec_pos": [
            [
              330,
              6
            ],
            [
              330,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "super_fgets",
            "parameters": {
              "b": "char",
              "blen": "int",
              "file": "FILE"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct _tag_spec\n{\n  short\n    id;\n\n  char\n    *name;\n} tag_spec;",
          {
            "id": "short",
            "*name": "char"
          },
          "tag_spec",
          [
            25,
            0
          ],
          [
            32,
            11
          ]
        ],
        [
          "typedef struct _html_code\n{\n  short\n    len;\n  const char\n   *code,\n    val;\n} html_code;",
          {
            "len": "short",
            "char": "const"
          },
          "html_code",
          [
            124,
            0
          ],
          [
            131,
            12
          ]
        ],
        [
          "typedef struct _tag_spec\n{\n  short\n    id;\n\n  char\n    *name;\n} tag_spec;",
          {
            "id": "short",
            "*name": "char"
          },
          "tag_spec",
          [
            25,
            0
          ],
          [
            32,
            11
          ]
        ],
        [
          "typedef struct _html_code\n{\n  short\n    len;\n  const char\n   *code,\n    val;\n} html_code;",
          {
            "len": "short",
            "char": "const"
          },
          "html_code",
          [
            124,
            0
          ],
          [
            131,
            12
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            3,
            0
          ],
          [
            4,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            4,
            0
          ],
          [
            5,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ],
        [
          "# include <strings.h>\n",
          [
            8,
            0
          ],
          [
            9,
            0
          ]
        ],
        [
          "# include <io.h>\n",
          [
            12,
            0
          ],
          [
            13,
            0
          ]
        ],
        [
          "# include <fcntl.h>\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/dbs/tiff-palette.c": {
      "fn_def_list": [
        {
          "fn_code": "int main(int argc, char **argv)\n{\n    int             bits_per_pixel = 8, cmsize, i, j, k,\n                    cmap_index, chunk_size = 32, nchunks = 16;\n    unsigned char * scan_line;\n    uint16          *red, *green, *blue;\n    TIFF *          tif;\n\n    programName = argv[0];\n\n    if (argc != 4)\n        Usage();\n\n    if (!strcmp(argv[1], \"-depth\"))\n         bits_per_pixel = atoi(argv[2]);\n    else\n         Usage();\n\n    switch (bits_per_pixel) {\n        case 8:\n            nchunks = 16;\n            chunk_size = 32;\n            break;\n        case 4:\n            nchunks = 4;\n            chunk_size = 128;\n            break;\n        case 2:\n            nchunks = 2;\n            chunk_size = 256;\n            break;\n\tcase 1:\n\t    nchunks = 2;\n\t    chunk_size = 256;\n\t    break;\n        default:\n            Usage();\n    }\n\n    if (bits_per_pixel != 1) {\n\tcmsize = nchunks * nchunks;\n    } else {\n\tcmsize = 2;\n    }\n    red = (uint16 *) malloc(cmsize * sizeof(uint16));\n    green = (uint16 *) malloc(cmsize * sizeof(uint16));\n    blue = (uint16 *) malloc(cmsize * sizeof(uint16));\n\n    switch (bits_per_pixel) {\n    case 8:\n        for (i = 0; i < cmsize; i++) {\n            if (i < 32)\n                red[i] = 0;\n            else if (i < 64)\n                red[i] = SCALE(36);\n            else if (i < 96)\n                red[i] = SCALE(73);\n            else if (i < 128)\n                red[i] = SCALE(109);\n            else if (i < 160)\n                red[i] = SCALE(146);\n            else if (i < 192)\n                red[i] = SCALE(182);\n            else if (i < 224)\n                red[i] = SCALE(219);\n            else if (i < 256)\n                red[i] = SCALE(255);\n\n            if ((i % 32) < 4)\n                green[i] = 0;\n            else if (i < 8)\n                green[i] = SCALE(36);\n            else if ((i % 32) < 12)\n                green[i] = SCALE(73);\n            else if ((i % 32) < 16)\n                green[i] = SCALE(109);\n            else if ((i % 32) < 20)\n                green[i] = SCALE(146);\n            else if ((i % 32) < 24)\n                green[i] = SCALE(182);\n            else if ((i % 32) < 28)\n                green[i] = SCALE(219);\n            else if ((i % 32) < 32)\n                green[i] = SCALE(255);\n\n            if ((i % 4) == 0)\n                blue[i] = SCALE(0);\n            else if ((i % 4) == 1)\n                blue[i] = SCALE(85);\n            else if ((i % 4) == 2)\n                blue[i] = SCALE(170);\n            else if ((i % 4) == 3)\n                blue[i] = SCALE(255);\n        }\n        break;\n    case 4:\n        red[0] = SCALE(255);\n        green[0] = 0;\n        blue[0] = 0;\n\n        red[1] = 0;\n        green[1] = SCALE(255);\n        blue[1] = 0;\n\n        red[2] = 0;\n        green[2] = 0;\n        blue[2] = SCALE(255);\n\n        red[3] = SCALE(255);\n        green[3] = SCALE(255);\n        blue[3] = SCALE(255);\n\n        red[4] = 0;\n        green[4] = SCALE(255);\n        blue[4] = SCALE(255);\n\n        red[5] = SCALE(255);\n        green[5] = 0;\n        blue[5] = SCALE(255);\n\n        red[6] = SCALE(255);\n        green[6] = SCALE(255);\n        blue[6] = 0;\n\n        red[7] = 0;\n        green[7] = 0;\n        blue[7] = 0;\n\n        red[8] = SCALE(176);\n        green[8] = SCALE(224);\n        blue[8] = SCALE(230);\n        red[9] = SCALE(100);\n        green[9] = SCALE(149);\n        blue[9] = SCALE(237);\n        red[10] = SCALE(46);\n        green[10] = SCALE(139);\n        blue[10] = SCALE(87);\n        red[11] = SCALE(160);\n        green[11] = SCALE(82);\n        blue[11] = SCALE(45);\n        red[12] = SCALE(238);\n        green[12] = SCALE(130);\n        blue[12] = SCALE(238);\n        red[13] = SCALE(176);\n        green[13] = SCALE(48);\n        blue[13] = SCALE(96);\n        red[14] = SCALE(50);\n        green[14] = SCALE(205);\n        blue[14] = SCALE(50);\n        red[15] = SCALE(240);\n        green[15] = SCALE(152);\n        blue[15] = SCALE(35);\n        break;\n    case 2:\n        red[0] = SCALE(255);\n        green[0] = 0;\n        blue[0] = 0;\n\n        red[1] = 0;\n        green[1] = SCALE(255);\n        blue[1] = 0;\n\n        red[2] = 0;\n        green[2] = 0;\n        blue[2] = SCALE(255);\n        red[3] = SCALE(255);\n        green[3] = SCALE(255);\n        blue[3] = SCALE(255);\n        break;\n    case 1:\n        red[0] = 0;\n        green[0] = 0;\n        blue[0] = 0;\n\n        red[1] = SCALE(255);\n        green[1] = SCALE(255);\n        blue[1] = SCALE(255);\n        break;\n    }\n\n    if ((tif = TIFFOpen(argv[3], \"w\")) == NULL) {\n        fprintf(stderr, \"can't open %s as a TIFF file\\n\", argv[3]);\n\t\tfree(red);free(green);free(blue);\n        return 0;\n    }\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, WIDTH);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, HEIGHT);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bits_per_pixel);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_PALETTE);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_NONE);\n    TIFFSetField(tif, TIFFTAG_COLORMAP, red, green, blue);\n\n    scan_line = (unsigned char *) malloc(WIDTH / (8 / bits_per_pixel));\n\n    for (i = 0; i < HEIGHT; i++) {\n        for (j = 0, k = 0; j < WIDTH;) {\n            cmap_index = (j / chunk_size) + ((i / chunk_size) * nchunks);\n\n            switch (bits_per_pixel) {\n            case 8:\n                scan_line[k++] = cmap_index;\n                j++;\n                break;\n            case 4:\n                scan_line[k++] = (cmap_index << 4) + cmap_index;\n                j += 2;\n                break;\n            case 2:\n                scan_line[k++] = (cmap_index << 6) + (cmap_index << 4)\n                    + (cmap_index << 2) + cmap_index;\n                j += 4;\n                break;\n\t    case 1:\n\t\tscan_line[k++] =\n\t\t\t((j / chunk_size) == (i / chunk_size)) ? 0x00 : 0xff;\n\t\tj += 8;\n\t\tbreak;\n            }\n        }\n        TIFFWriteScanline(tif, scan_line, i, 0);\n    }\n\n    free(scan_line);\n    TIFFClose(tif);\n    return 0;\n}",
          "fn_code_pos": [
            [
              37,
              0
            ],
            [
              267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\nUsage()\n{\n    fprintf(stderr, \"Usage: %s -depth (8 | 4 | 2 | 1) tiff-image\\n\", programName);\n    exit(0);\n}",
          "fn_code_pos": [
            [
              269,
              0
            ],
            [
              274,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "Usage()",
          "fn_dec_pos": [
            [
              35,
              20
            ],
            [
              35,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/dbs/tiff-grayscale.c": {
      "fn_def_list": [
        {
          "fn_code": "int main(int argc, char **argv)\n{\n    int             bits_per_pixel = 8, cmsize, i, j, k,\n                    gray_index, chunk_size = 32, nchunks = 16;\n    unsigned char * scan_line;\n    uint16 *        gray;\n    float           refblackwhite[2*1];\n    TIFF *          tif;\n\n    programName = argv[0];\n\n    if (argc != 4)\n        Usage();\n\n    if (!strcmp(argv[1], \"-depth\"))\n         bits_per_pixel = atoi(argv[2]);\n    else\n         Usage();\n\n    switch (bits_per_pixel) {\n        case 8:\n            nchunks = 16;\n            chunk_size = 32;\n            break;\n        case 4:\n            nchunks = 4;\n            chunk_size = 128;\n            break;\n        case 2:\n            nchunks = 2;\n            chunk_size = 256;\n            break;\n        default:\n            Usage();\n    }\n\n    cmsize = nchunks * nchunks;\n    gray = (uint16 *) malloc(cmsize * sizeof(uint16));\n\n    gray[0] = 3000;\n    for (i = 1; i < cmsize; i++)\n        gray[i] = (uint16) (-log10((double) i / (cmsize - 1)) * 1000);\n\n    refblackwhite[0] = 0.0;\n    refblackwhite[1] = (float)((1L<<bits_per_pixel) - 1);\n\n    if ((tif = TIFFOpen(argv[3], \"w\")) == NULL) {\n        fprintf(stderr, \"can't open %s as a TIFF file\\n\", argv[3]);\n\t\tfree(gray);\n        return 0;\n    }\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, WIDTH);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, HEIGHT);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bits_per_pixel);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE, refblackwhite);\n    TIFFSetField(tif, TIFFTAG_TRANSFERFUNCTION, gray);\n    TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_NONE);\n\n    scan_line = (unsigned char *) malloc(WIDTH / (8 / bits_per_pixel));\n\n    for (i = 0; i < HEIGHT; i++) {\n        for (j = 0, k = 0; j < WIDTH;) {\n            gray_index = (j / chunk_size) + ((i / chunk_size) * nchunks);\n\n            switch (bits_per_pixel) {\n            case 8:\n                scan_line[k++] = gray_index;\n                j++;\n                break;\n            case 4:\n                scan_line[k++] = (gray_index << 4) + gray_index;\n                j += 2;\n                break;\n            case 2:\n                scan_line[k++] = (gray_index << 6) + (gray_index << 4)\n                    + (gray_index << 2) + gray_index;\n                j += 4;\n                break;\n            }\n        }\n        TIFFWriteScanline(tif, scan_line, i, 0);\n    }\n\n    free(scan_line);\n    TIFFClose(tif);\n    return 0;\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              130,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\nUsage()\n{\n    fprintf(stderr, \"Usage: %s -depth (8 | 4 | 2) tiff-image\\n\", programName);\n    exit(0);\n}",
          "fn_code_pos": [
            [
              132,
              0
            ],
            [
              137,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "Usage()",
          "fn_dec_pos": [
            [
              36,
              20
            ],
            [
              36,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/dbs/tiff-bi.c": {
      "fn_def_list": [
        {
          "fn_code": "int main(int argc, char **argv)\n{\n    int             i;\n    unsigned char * scan_line;\n    TIFF *          tif;\n\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s tiff-image\\n\", argv[0]);\n        return 0;\n    }\n\n    if ((tif = TIFFOpen(argv[1], \"w\")) == NULL) {\n        fprintf(stderr, \"can't open %s as a TIFF file\\n\", argv[1]);\n        return 0;\n    }\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, WIDTH);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, HEIGHT);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 1);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_NONE);\n\n    scan_line = (unsigned char *) malloc(WIDTH / 8);\n\n    for (i = 0; i < (WIDTH / 8) / 2; i++)\n        scan_line[i] = 0;\n\n    for (i = (WIDTH / 8) / 2; i < (WIDTH / 8); i++)\n        scan_line[i] = 255;\n\n    for (i = 0; i < HEIGHT / 2; i++)\n        TIFFWriteScanline(tif, scan_line, i, 0);\n\n    for (i = 0; i < (WIDTH / 8) / 2; i++)\n        scan_line[i] = 255;\n\n    for (i = (WIDTH / 8) / 2; i < (WIDTH / 8); i++)\n        scan_line[i] = 0;\n\n    for (i = HEIGHT / 2; i < HEIGHT; i++)\n        TIFFWriteScanline(tif, scan_line, i, 0);\n\n    free(scan_line);\n    TIFFClose(tif);\n    return 0;\n}",
          "fn_code_pos": [
            [
              32,
              0
            ],
            [
              81,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/dbs/tiff-rgb.c": {
      "fn_def_list": [
        {
          "fn_code": "int main(int argc, char **argv)\n{\n    char *          input_file = NULL;\n    double          image_gamma = TIFF_GAMMA;\n    int             i, j;\n    TIFF *          tif;\n    unsigned char * scan_line;\n    uint16          red[CMSIZE], green[CMSIZE], blue[CMSIZE];\n    float\t    refblackwhite[2*3];\n\n    programName = argv[0];\n\n    switch (argc) {\n    case 2:\n        image_gamma = TIFF_GAMMA;\n        input_file = argv[1];\n        break;\n    case 4:\n        if (!strcmp(argv[1], \"-gamma\")) {\n            image_gamma = atof(argv[2]);\n            input_file = argv[3];\n        } else\n            Usage();\n        break;\n    default:\n        Usage();\n    }\n\n    for (i = 0; i < CMSIZE; i++) {\n        if (i == 0)\n            red[i] = green[i] = blue[i] = 0;\n        else {\n            red[i] = ROUND((pow(i / 255.0, 1.0 / image_gamma) * 65535.0));\n            green[i] = ROUND((pow(i / 255.0, 1.0 / image_gamma) * 65535.0));\n            blue[i] = ROUND((pow(i / 255.0, 1.0 / image_gamma) * 65535.0));\n        }\n    }\n    refblackwhite[0] = 0.0; refblackwhite[1] = 255.0;\n    refblackwhite[2] = 0.0; refblackwhite[3] = 255.0;\n    refblackwhite[4] = 0.0; refblackwhite[5] = 255.0;\n\n    if ((tif = TIFFOpen(input_file, \"w\")) == NULL) {\n        fprintf(stderr, \"can't open %s as a TIFF file\\n\", input_file);\n        exit(0);\n    }\n\n    TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, WIDTH);\n    TIFFSetField(tif, TIFFTAG_IMAGELENGTH, HEIGHT);\n    TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8);\n    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n    TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);\n    TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);\n    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(tif, TIFFTAG_RESOLUTIONUNIT, RESUNIT_NONE);\n#ifdef notdef\n    TIFFSetField(tif, TIFFTAG_WHITEPOINT, whitex, whitey);\n    TIFFSetField(tif, TIFFTAG_PRIMARYCHROMATICITIES, primaries);\n#endif\n    TIFFSetField(tif, TIFFTAG_REFERENCEBLACKWHITE, refblackwhite);\n    TIFFSetField(tif, TIFFTAG_TRANSFERFUNCTION, red, green, blue);\n\n    scan_line = (unsigned char *) malloc(WIDTH * 3);\n\n    for (i = 0; i < 255; i++) {\n        for (j = 0; j < 75; j++) {\n             scan_line[j * 3] = 255;\n             scan_line[(j * 3) + 1] = 255 - i;\n             scan_line[(j * 3) + 2] = 255 - i;\n        }\n        for (j = 75; j < 150; j++) {\n             scan_line[j * 3] = 255 - i;\n             scan_line[(j * 3) + 1] = 255;\n             scan_line[(j * 3) + 2] = 255 - i;\n        }\n        for (j = 150; j < 225; j++) {\n             scan_line[j * 3] = 255 - i;\n             scan_line[(j * 3) + 1] = 255 - i;\n             scan_line[(j * 3) + 2] = 255;\n        }\n        for (j = 225; j < 300; j++) {\n             scan_line[j * 3] = (i - 1) / 2;\n             scan_line[(j * 3) + 1] = (i - 1) / 2;\n             scan_line[(j * 3) + 2] = (i - 1) / 2;\n        }\n        for (j = 300; j < 375; j++) {\n             scan_line[j * 3] = 255 - i;\n             scan_line[(j * 3) + 1] = 255;\n             scan_line[(j * 3) + 2] = 255;\n        }\n        for (j = 375; j < 450; j++) {\n             scan_line[j * 3] = 255;\n             scan_line[(j * 3) + 1] = 255 - i;\n             scan_line[(j * 3) + 2] = 255;\n        }\n        for (j = 450; j < 525; j++) {\n             scan_line[j * 3] = 255;\n             scan_line[(j * 3) + 1] = 255;\n             scan_line[(j * 3) + 2] = 255 - i;\n        }\n        TIFFWriteScanline(tif, scan_line, i, 0);\n    }\n    for (i = 255; i < 512; i++) {\n        for (j = 0; j < 75; j++) {\n             scan_line[j * 3] = i;\n             scan_line[(j * 3) + 1] = 0;\n             scan_line[(j * 3) + 2] = 0;\n        }\n        for (j = 75; j < 150; j++) {\n             scan_line[j * 3] = 0;\n             scan_line[(j * 3) + 1] = i;\n             scan_line[(j * 3) + 2] = 0;\n        }\n        for (j = 150; j < 225; j++) {\n             scan_line[j * 3] = 0;\n             scan_line[(j * 3) + 1] = 0;\n             scan_line[(j * 3) + 2] = i;\n        }\n        for (j = 225; j < 300; j++) {\n             scan_line[j * 3] = (i - 1) / 2;\n             scan_line[(j * 3) + 1] = (i - 1) / 2;\n             scan_line[(j * 3) + 2] = (i - 1) / 2;\n        }\n        for (j = 300; j < 375; j++) {\n             scan_line[j * 3] = 0;\n             scan_line[(j * 3) + 1] = i;\n             scan_line[(j * 3) + 2] = i;\n        }\n        for (j = 375; j < 450; j++) {\n             scan_line[j * 3] = i;\n             scan_line[(j * 3) + 1] = 0;\n             scan_line[(j * 3) + 2] = i;\n        }\n        for (j = 450; j < 525; j++) {\n             scan_line[j * 3] = i;\n             scan_line[(j * 3) + 1] = i;\n             scan_line[(j * 3) + 2] = 0;\n        }\n        TIFFWriteScanline(tif, scan_line, i, 0);\n    }\n\n    free(scan_line);\n    TIFFClose(tif);\n    exit(0);\n}",
          "fn_code_pos": [
            [
              40,
              0
            ],
            [
              184,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\nUsage()\n{\n    fprintf(stderr, \"Usage: %s -gamma gamma tiff-image\\n\", programName);\n    exit(0);\n}",
          "fn_code_pos": [
            [
              186,
              0
            ],
            [
              191,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "Usage()",
          "fn_dec_pos": [
            [
              37,
              20
            ],
            [
              37,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/dbs/xtiff/xtiff.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char **argv)\n{\n    XSetWindowAttributes window_attributes;\n    Widget widget_list[3];\n    Arg args[5];\n\n    setbuf(stdout, NULL); setbuf(stderr, NULL);\n\n    shellWidget = XtInitialize(argv[0], \"XTiff\", shellOptions,\n        XtNumber(shellOptions), &argc, argv);\n\n    XSetErrorHandler(XTiffErrorHandler);\n\n    XtGetApplicationResources(shellWidget, &appData,\n        (XtResourceList) clientResources, (Cardinal) XtNumber(clientResources),\n        (ArgList) NULL, (Cardinal) 0);\n\n    if ((argc <= 1) || (argc > 2) || appData.help)\n        Usage();\n\n    if (appData.verbose == False) {\n        TIFFSetErrorHandler(0);\n        TIFFSetWarningHandler(0);\n    }\n\n    fileName = argv[1];\n\n    xDisplay = XtDisplay(shellWidget);\n    xScreen = DefaultScreen(xDisplay);\n\n    OpenTIFFFile();\n    GetTIFFHeader();\n    SimpleGammaCorrection();\n    GetVisual();\n    GetTIFFImage();\n\n    /*\n     * Send visual, colormap, depth and iconPixmap to shellWidget.\n     * Sending the visual to the shell is only possible with the advent of R4.\n     */\n    XtSetArg(args[0], XtNvisual, xVisual);\n    XtSetArg(args[1], XtNcolormap, xColormap);\n    XtSetArg(args[2], XtNdepth,\n        xImageDepth == 1 ? DefaultDepth(xDisplay, xScreen) : xImageDepth);\n    XtSetArg(args[3], XtNiconPixmap,\n        XCreateBitmapFromData(xDisplay, RootWindow(xDisplay, xScreen),\n            xtifficon_bits, xtifficon_width, xtifficon_height));\n    XtSetArg(args[4], XtNallowShellResize, True);\n    XtSetValues(shellWidget, args, 5);\n\n    /*\n     * widget instance hierarchy\n     */\n    formWidget = XtCreateManagedWidget(\"form\", formWidgetClass,\n        shellWidget, formArgs, XtNumber(formArgs));\n\n        widget_list[0] = listWidget = XtCreateWidget(\"list\",\n            listWidgetClass, formWidget, listArgs, XtNumber(listArgs));\n\n        widget_list[1] = labelWidget = XtCreateWidget(\"label\",\n            labelWidgetClass, formWidget, labelArgs, XtNumber(labelArgs));\n\n        widget_list[2] = imageWidget = XtCreateWidget(\"image\",\n            widgetClass, formWidget, imageArgs, XtNumber(imageArgs));\n\n    XtManageChildren(widget_list, XtNumber(widget_list));\n\n    /*\n     * initial widget sizes - for small images let xtiff size itself\n     */\n    if (tfImageWidth >= appData.viewportWidth) {\n        XtSetArg(args[0], XtNwidth, appData.viewportWidth);\n        XtSetValues(shellWidget, args, 1);\n    }\n    if (tfImageHeight >= appData.viewportHeight) {\n        XtSetArg(args[0], XtNheight, appData.viewportHeight);\n        XtSetValues(shellWidget, args, 1);\n    }\n\n    XtSetArg(args[0], XtNwidth, tfImageWidth);\n    XtSetArg(args[1], XtNheight, tfImageHeight);\n    XtSetValues(imageWidget, args, 2);\n\n    /*\n     * formWidget uses these constraints but they are stored in the children.\n     */\n    XtSetArg(args[0], XtNfromVert, listWidget);\n    XtSetValues(imageWidget, args, 1);\n    XtSetArg(args[0], XtNfromHoriz, listWidget);\n    XtSetValues(labelWidget, args, 1);\n\n    SetNameLabel();\n\n    XtAddCallback(listWidget, XtNcallback, (XtCallbackProc) SelectProc,\n        (XtPointer) NULL);\n\n    XtAddActions(actionsTable, XtNumber(actionsTable));\n    XtSetArg(args[0], XtNtranslations,\n        XtParseTranslationTable(translationsTable));\n    XtSetValues(formWidget, &args[0], 1);\n    XtSetValues(imageWidget, &args[0], 1);\n\n    /*\n     * This is intended to be a little faster than going through\n     * the translation manager.\n     */\n    XtAddEventHandler(imageWidget, ExposureMask | ButtonPressMask\n        | ButtonReleaseMask | Button1MotionMask | KeyPressMask,\n        False, EventProc, NULL);\n\n    XtRealizeWidget(shellWidget);\n\n    window_attributes.cursor = XCreateFontCursor(xDisplay, XC_fleur);\n    XChangeWindowAttributes(xDisplay, XtWindow(imageWidget),\n        CWCursor, &window_attributes);\n\n    CreateXImage();\n\n    XtMainLoop();\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              260,
              0
            ],
            [
              382,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\nOpenTIFFFile()\n{\n    if (tfFile != NULL)\n        TIFFClose(tfFile);\n\n    if ((tfFile = TIFFOpen(fileName, \"r\")) == NULL) {\n\tfprintf(appData.verbose ? stderr : stdout,\n\t    \"xtiff: can't open %s as a TIFF file\\n\", fileName);\n        exit(0);\n    }\n\n    tfMultiPage = (TIFFLastDirectory(tfFile) ? False : True);\n}",
          "fn_code_pos": [
            [
              384,
              0
            ],
            [
              397,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "OpenTIFFFile",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nGetTIFFHeader()\n{\n    register int i;\n\n    if (!TIFFSetDirectory(tfFile, tfDirectory)) {\n        fprintf(stderr, \"xtiff: can't seek to directory %d in %s\\n\",\n            tfDirectory, fileName);\n        exit(0);\n    }\n\n    TIFFGetField(tfFile, TIFFTAG_IMAGEWIDTH, &tfImageWidth);\n    TIFFGetField(tfFile, TIFFTAG_IMAGELENGTH, &tfImageHeight);\n\n    /*\n     * If the following tags aren't present then use the TIFF defaults.\n     */\n    TIFFGetFieldDefaulted(tfFile, TIFFTAG_BITSPERSAMPLE, &tfBitsPerSample);\n    TIFFGetFieldDefaulted(tfFile, TIFFTAG_SAMPLESPERPIXEL, &tfSamplesPerPixel);\n    TIFFGetFieldDefaulted(tfFile, TIFFTAG_PLANARCONFIG, &tfPlanarConfiguration);\n    TIFFGetFieldDefaulted(tfFile, TIFFTAG_GRAYRESPONSEUNIT, &tfGrayResponseUnit);\n\n    tfUnitMap = tfGrayResponseUnitMap[tfGrayResponseUnit];\n    colormapSize = 1 << tfBitsPerSample;\n    tfImageDepth = tfBitsPerSample * tfSamplesPerPixel;\n\n    dRed = (double *) malloc(colormapSize * sizeof(double));\n    dGreen = (double *) malloc(colormapSize * sizeof(double));\n    dBlue = (double *) malloc(colormapSize * sizeof(double));\n    MCHECK(dRed); MCHECK(dGreen); MCHECK(dBlue);\n\n    /*\n     * If TIFFTAG_PHOTOMETRIC is not present then assign a reasonable default.\n     * The TIFF 5.0 specification doesn't give a default.\n     */\n    if (!TIFFGetField(tfFile, TIFFTAG_PHOTOMETRIC,\n            &tfPhotometricInterpretation)) {\n        if (tfSamplesPerPixel != 1)\n            tfPhotometricInterpretation = PHOTOMETRIC_RGB;\n        else if (tfBitsPerSample == 1)\n            tfPhotometricInterpretation = PHOTOMETRIC_MINISBLACK;\n        else if (TIFFGetField(tfFile, TIFFTAG_COLORMAP,\n                &redMap, &greenMap, &blueMap)) {\n            tfPhotometricInterpretation = PHOTOMETRIC_PALETTE;\n            redMap = greenMap = blueMap = NULL;\n        } else\n            tfPhotometricInterpretation = PHOTOMETRIC_MINISBLACK;\n    }\n\n    /*\n     * Given TIFFTAG_PHOTOMETRIC extract or create the response curves.\n     */\n    switch (tfPhotometricInterpretation) {\n    case PHOTOMETRIC_RGB:\n\tredMap = (uint16 *) malloc(colormapSize * sizeof(uint16));\n\tgreenMap = (uint16 *) malloc(colormapSize * sizeof(uint16));\n\tblueMap = (uint16 *) malloc(colormapSize * sizeof(uint16));\n\tMCHECK(redMap); MCHECK(greenMap); MCHECK(blueMap);\n\tfor (i = 0; i < colormapSize; i++)\n\t    dRed[i] = dGreen[i] = dBlue[i]\n\t\t= (double) SCALE(i, colormapSize - 1);\n        break;\n    case PHOTOMETRIC_PALETTE:\n        if (!TIFFGetField(tfFile, TIFFTAG_COLORMAP,\n                &redMap, &greenMap, &blueMap)) {\n            redMap = (uint16 *) malloc(colormapSize * sizeof(uint16));\n            greenMap = (uint16 *) malloc(colormapSize * sizeof(uint16));\n            blueMap = (uint16 *) malloc(colormapSize * sizeof(uint16));\n            MCHECK(redMap); MCHECK(greenMap); MCHECK(blueMap);\n            for (i = 0; i < colormapSize; i++)\n                dRed[i] = dGreen[i] = dBlue[i]\n                    = (double) SCALE(i, colormapSize - 1);\n        } else {\n            CheckAndCorrectColormap();\n            for (i = 0; i < colormapSize; i++) {\n                dRed[i] = (double) redMap[i];\n                dGreen[i] = (double) greenMap[i];\n                dBlue[i] = (double) blueMap[i];\n            }\n        }\n        break;\n    case PHOTOMETRIC_MINISWHITE:\n        redMap = (uint16 *) malloc(colormapSize * sizeof(uint16));\n        greenMap = (uint16 *) malloc(colormapSize * sizeof(uint16));\n        blueMap = (uint16 *) malloc(colormapSize * sizeof(uint16));\n        MCHECK(redMap); MCHECK(greenMap); MCHECK(blueMap);\n\tfor (i = 0; i < colormapSize; i++)\n\t    dRed[i] = dGreen[i] = dBlue[i] = (double)\n\t\t SCALE(colormapSize-1-i, colormapSize-1);\n        break;\n    case PHOTOMETRIC_MINISBLACK:\n        redMap = (uint16 *) malloc(colormapSize * sizeof(uint16));\n        greenMap = (uint16 *) malloc(colormapSize * sizeof(uint16));\n        blueMap = (uint16 *) malloc(colormapSize * sizeof(uint16));\n        MCHECK(redMap); MCHECK(greenMap); MCHECK(blueMap);\n\tfor (i = 0; i < colormapSize; i++)\n\t    dRed[i] = dGreen[i] = dBlue[i] = (double) SCALE(i, colormapSize-1);\n        break;\n    default:\n        fprintf(stderr,\n            \"xtiff: can't display photometric interpretation type %d\\n\",\n            tfPhotometricInterpretation);\n        exit(0);\n    }\n}",
          "fn_code_pos": [
            [
              399,
              0
            ],
            [
              503,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetTIFFHeader",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nSetNameLabel()\n{\n    char buffer[BUFSIZ];\n    Arg args[1];\n\n    if (tfMultiPage)\n        snprintf(buffer, sizeof(buffer), \"%s - page %d\", fileName, tfDirectory);\n    else\n        snprintf(buffer, sizeof(buffer), \"%s\", fileName);\n    XtSetArg(args[0], XtNlabel, buffer);\n    XtSetValues(labelWidget, args, 1);\n}",
          "fn_code_pos": [
            [
              505,
              0
            ],
            [
              517,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SetNameLabel",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nCheckAndCorrectColormap()\n{\n    register int i;\n\n    for (i = 0; i < colormapSize; i++)\n        if ((redMap[i] > 255) || (greenMap[i] > 255) || (blueMap[i] > 255))\n            return;\n\n    for (i = 0; i < colormapSize; i++) {\n        redMap[i] = SCALE(redMap[i], 255);\n        greenMap[i] = SCALE(greenMap[i], 255);\n        blueMap[i] = SCALE(blueMap[i], 255);\n    }\n    TIFFWarning(fileName, \"Assuming 8-bit colormap\");\n}",
          "fn_code_pos": [
            [
              523,
              0
            ],
            [
              538,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckAndCorrectColormap",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nSimpleGammaCorrection()\n{\n    register int i;\n    register double i_gamma = 1.0 / appData.gamma;\n\n    for (i = 0; i < colormapSize; i++) {\n        if (((tfPhotometricInterpretation == PHOTOMETRIC_MINISWHITE)\n            && (i == colormapSize - 1))\n            || ((tfPhotometricInterpretation == PHOTOMETRIC_MINISBLACK)\n            && (i == 0)))\n            redMap[i] = greenMap[i] = blueMap[i] = 0;\n        else {\n            redMap[i] = ROUND((pow(dRed[i] / 65535.0, i_gamma) * 65535.0));\n            greenMap[i] = ROUND((pow(dGreen[i] / 65535.0, i_gamma) * 65535.0));\n            blueMap[i] = ROUND((pow(dBlue[i] / 65535.0, i_gamma) * 65535.0));\n        }\n    }\n\n    free(dRed); free(dGreen); free(dBlue);\n}",
          "fn_code_pos": [
            [
              540,
              0
            ],
            [
              560,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SimpleGammaCorrection",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nGetVisual()\n{\n    XColor *colors = NULL;\n    unsigned long *pixels = NULL;\n    unsigned long i;\n\n    switch (tfImageDepth) {\n    /*\n     * X really wants a 32-bit image with the fourth channel unused,\n     * but the visual structure thinks it's 24-bit.  bitmap_unit is 32.\n     */\n    case 32:\n    case 24:\n        if (SearchVisualList(24, DirectColor, &xVisual) == False) {\n            fprintf(stderr, \"xtiff: 24-bit DirectColor visual not available\\n\");\n            exit(0);\n        }\n\n        colors = (XColor *) malloc(3 * colormapSize * sizeof(XColor));\n        MCHECK(colors);\n\n        for (i = 0; i < colormapSize; i++) {\n            colors[i].pixel = (i << 16) + (i << 8) + i;\n            colors[i].red = redMap[i];\n            colors[i].green = greenMap[i];\n            colors[i].blue = blueMap[i];\n            colors[i].flags = DoRed | DoGreen | DoBlue;\n        }\n\n        xColormap = XCreateColormap(xDisplay, RootWindow(xDisplay, xScreen),\n            xVisual, AllocAll);\n        XStoreColors(xDisplay, xColormap, colors, colormapSize);\n        break;\n    case 8:\n    case 4:\n    case 2:\n        /*\n         * We assume that systems with 24-bit visuals also have 8-bit visuals.\n         * We don't promote from 8-bit PseudoColor to 24/32 bit DirectColor.\n         */\n        switch (tfPhotometricInterpretation) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n            if (SearchVisualList((int) tfImageDepth, GrayScale, &xVisual) == True)\n                break;\n        case PHOTOMETRIC_PALETTE:\n            if (SearchVisualList((int) tfImageDepth, PseudoColor, &xVisual) == True)\n                break;\n        default:\n            fprintf(stderr, \"xtiff: Unsupported TIFF/X configuration\\n\");\n            exit(0);\n        }\n\n        colors = (XColor *) malloc(colormapSize * sizeof(XColor));\n        MCHECK(colors);\n\n        for (i = 0; i < colormapSize; i++) {\n            colors[i].pixel = i;\n            colors[i].red = redMap[i];\n            colors[i].green = greenMap[i];\n            colors[i].blue = blueMap[i];\n            colors[i].flags = DoRed | DoGreen | DoBlue;\n        }\n\n        /*\n         * xtiff's colormap allocation is private.  It does not attempt\n         * to detect whether any existing colormap entries are suitable\n         * for its use.  This will cause colormap flashing.  Furthermore,\n         * background and foreground are taken from the environment.\n         * For example, the foreground color may be red when the visual\n         * is GrayScale.  If the colormap is completely populated,\n         * Xt will not be able to allocate fg and bg.\n         */\n        if (tfImageDepth == 8)\n            xColormap = XCreateColormap(xDisplay, RootWindow(xDisplay, xScreen),\n                xVisual, AllocAll);\n        else {\n            xColormap = XCreateColormap(xDisplay, RootWindow(xDisplay, xScreen),\n                xVisual, AllocNone);\n            pixels = (unsigned long *)\n                malloc(colormapSize * sizeof(unsigned long));\n            MCHECK(pixels);\n            (void) XAllocColorCells(xDisplay, xColormap, True,\n                NULL, 0, pixels, colormapSize);\n            basePixel = (unsigned char) pixels[0];\n            free(pixels);\n        }\n        XStoreColors(xDisplay, xColormap, colors, colormapSize);\n        break;\n    case 1:\n        xImageDepth = 1;\n        xVisual = DefaultVisual(xDisplay, xScreen);\n        xColormap = DefaultColormap(xDisplay, xScreen);\n        break;\n    default:\n        fprintf(stderr, \"xtiff: unsupported image depth %d\\n\", tfImageDepth);\n        exit(0);\n    }\n\n    if (appData.verbose == True)\n\tfprintf(stderr, \"%s: Using %d-bit %s visual.\\n\",\n\t    fileName, xImageDepth, classNames[xVisual->class]);\n\n    if (colors != NULL)\n        free(colors);\n    if (grayMap != NULL)\n        free(grayMap);\n    if (redMap != NULL)\n        free(redMap);\n    if (greenMap != NULL)\n        free(greenMap);\n    if (blueMap != NULL)\n        free(blueMap);\n\n    colors = NULL; grayMap = redMap = greenMap = blueMap = NULL;\n}",
          "fn_code_pos": [
            [
              575,
              0
            ],
            [
              691,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetVisual",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nGetTIFFImage()\n{\n    int pixel_map[3], red_shift, green_shift, blue_shift;\n    char *scan_line, *output_p, *input_p;\n    uint32 i, j;\n    uint16 s;\n\n    scan_line = (char *) malloc(tfBytesPerRow = TIFFScanlineSize(tfFile));\n    MCHECK(scan_line);\n\n    if ((tfImageDepth == 32) || (tfImageDepth == 24)) {\n        output_p = imageMemory = (char *)\n            malloc(tfImageWidth * tfImageHeight * 4);\n        MCHECK(imageMemory);\n\n        /*\n         * Handle different color masks for different frame buffers.\n         */\n        if (ImageByteOrder(xDisplay) == LSBFirst) { /* DECstation 5000 */\n            red_shift = pixel_map[0] = xRedMask == 0xFF000000 ? 3\n                : (xRedMask == 0xFF0000 ? 2 : (xRedMask == 0xFF00 ? 1 : 0));\n            green_shift = pixel_map[1] = xGreenMask == 0xFF000000 ? 3\n                : (xGreenMask == 0xFF0000 ? 2 : (xGreenMask == 0xFF00 ? 1 : 0));\n            blue_shift = pixel_map[2] = xBlueMask == 0xFF000000 ? 3\n                : (xBlueMask == 0xFF0000 ? 2 : (xBlueMask == 0xFF00 ? 1 : 0));\n        } else { /* Ardent */\n            red_shift = pixel_map[0] = xRedMask == 0xFF000000 ? 0\n                : (xRedMask == 0xFF0000 ? 1 : (xRedMask == 0xFF00 ? 2 : 3));\n            green_shift = pixel_map[0] = xGreenMask == 0xFF000000 ? 0\n                : (xGreenMask == 0xFF0000 ? 1 : (xGreenMask == 0xFF00 ? 2 : 3));\n            blue_shift = pixel_map[0] = xBlueMask == 0xFF000000 ? 0\n                : (xBlueMask == 0xFF0000 ? 1 : (xBlueMask == 0xFF00 ? 2 : 3));\n        }\n\n        if (tfPlanarConfiguration == PLANARCONFIG_CONTIG) {\n            for (i = 0; i < tfImageHeight; i++) {\n                if (TIFFReadScanline(tfFile, scan_line, i, 0) < 0)\n                    break;\n                for (input_p = scan_line, j = 0; j < tfImageWidth; j++) {\n                    *(output_p + red_shift) = *input_p++;\n                    *(output_p + green_shift) = *input_p++;\n                    *(output_p + blue_shift) = *input_p++;\n                    output_p += 4;\n                    if (tfSamplesPerPixel == 4) /* skip the fourth channel */\n                        input_p++;\n                }\n            }\n        } else {\n            for (s = 0; s < tfSamplesPerPixel; s++) {\n                if (s == 3)             /* skip the fourth channel */\n                    continue;\n                for (i = 0; i < tfImageHeight; i++) {\n                    if (TIFFReadScanline(tfFile, scan_line, i, s) < 0)\n                        break;\n                    input_p = scan_line;\n                    output_p = imageMemory + (i*tfImageWidth*4) + pixel_map[s];\n                    for (j = 0; j < tfImageWidth; j++, output_p += 4)\n                        *output_p = *input_p++;\n                }\n            }\n        }\n    } else {\n        if (xImageDepth == tfImageDepth) {\n            output_p = imageMemory = (char *)\n                malloc(tfBytesPerRow * tfImageHeight);\n            MCHECK(imageMemory);\n\n            for (i = 0; i < tfImageHeight; i++, output_p += tfBytesPerRow)\n                if (TIFFReadScanline(tfFile, output_p, i, 0) < 0)\n                    break;\n        } else if ((xImageDepth == 8) && (tfImageDepth == 4)) {\n            output_p = imageMemory = (char *)\n                malloc(tfBytesPerRow * 2 * tfImageHeight + 2);\n            MCHECK(imageMemory);\n\n            /*\n             * If a scanline is of odd size the inner loop below will overshoot.\n             * This is handled very simply by recalculating the start point at\n             * each scanline and padding imageMemory a little at the end.\n             */\n            for (i = 0; i < tfImageHeight; i++) {\n                if (TIFFReadScanline(tfFile, scan_line, i, 0) < 0)\n                    break;\n                output_p = &imageMemory[i * tfImageWidth];\n                input_p = scan_line;\n                for (j = 0; j < tfImageWidth; j += 2, input_p++) {\n                    *output_p++ = (*input_p >> 4) + basePixel;\n                    *output_p++ = (*input_p & 0xf) + basePixel;\n                }\n            }\n        } else if ((xImageDepth == 8) && (tfImageDepth == 2)) {\n            output_p = imageMemory = (char *)\n                malloc(tfBytesPerRow * 4 * tfImageHeight + 4);\n            MCHECK(imageMemory);\n\n            for (i = 0; i < tfImageHeight; i++) {\n                if (TIFFReadScanline(tfFile, scan_line, i, 0) < 0)\n                    break;\n                output_p = &imageMemory[i * tfImageWidth];\n                input_p = scan_line;\n                for (j = 0; j < tfImageWidth; j += 4, input_p++) {\n                    *output_p++ = (*input_p >> 6) + basePixel;\n                    *output_p++ = ((*input_p >> 4) & 3) + basePixel;\n                    *output_p++ = ((*input_p >> 2) & 3) + basePixel;\n                    *output_p++ = (*input_p & 3) + basePixel;\n                }\n            }\n        } else if ((xImageDepth == 4) && (tfImageDepth == 2)) {\n            output_p = imageMemory = (char *)\n                malloc(tfBytesPerRow * 2 * tfImageHeight + 2);\n            MCHECK(imageMemory);\n\n            for (i = 0; i < tfImageHeight; i++) {\n                if (TIFFReadScanline(tfFile, scan_line, i, 0) < 0)\n                    break;\n                output_p = &imageMemory[i * tfBytesPerRow * 2];\n                input_p = scan_line;\n                for (j = 0; j < tfImageWidth; j += 4, input_p++) {\n                    *output_p++ = (((*input_p>>6) << 4)\n                        | ((*input_p >> 4) & 3)) + basePixel;\n                    *output_p++ = ((((*input_p>>2) & 3) << 4)\n                        | (*input_p & 3)) + basePixel;\n                }\n            }\n        } else {\n            fprintf(stderr,\n                \"xtiff: can't handle %d-bit TIFF file on an %d-bit display\\n\",\n                tfImageDepth, xImageDepth);\n            exit(0);\n        }\n    }\n\n    free(scan_line);\n}",
          "fn_code_pos": [
            [
              733,
              0
            ],
            [
              867,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetTIFFImage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nCreateXImage()\n{\n    XGCValues gc_values;\n    GC bitmap_gc;\n\n    xOffset = yOffset = 0;\n    grabX = grabY = -1;\n\n    xImage = XCreateImage(xDisplay, xVisual, xImageDepth,\n        xImageDepth == 1 ? XYBitmap : ZPixmap, /* offset */ 0,\n        (char *) imageMemory, tfImageWidth, tfImageHeight,\n        /* bitmap_pad */ 8, /* bytes_per_line */ 0);\n\n    /*\n     * libtiff converts LSB data into MSB but doesn't change the FillOrder tag.\n     */\n    if (xImageDepth == 1)\n        xImage->bitmap_bit_order = MSBFirst;\n    if (xImageDepth <= 8)\n        xImage->byte_order = MSBFirst;\n\n    /*\n     * create an appropriate GC\n     */\n    gc_values.function = GXcopy;\n    gc_values.plane_mask = AllPlanes;\n    if (tfPhotometricInterpretation == PHOTOMETRIC_MINISBLACK) {\n        gc_values.foreground = XWhitePixel(xDisplay, xScreen);\n        gc_values.background = XBlackPixel(xDisplay, xScreen);\n    } else {\n        gc_values.foreground = XBlackPixel(xDisplay, xScreen);\n        gc_values.background = XWhitePixel(xDisplay, xScreen);\n    }\n    xWinGc = XCreateGC(xDisplay, XtWindow(shellWidget),\n        GCFunction | GCPlaneMask | GCForeground | GCBackground, &gc_values);\n\n    /*\n     * create the pixmap and load the image\n     */\n    if (appData.usePixmap == True) {\n        xImagePixmap = XCreatePixmap(xDisplay, RootWindow(xDisplay, xScreen),\n            xImage->width, xImage->height, xImageDepth);\n\n        /*\n         * According to the O'Reilly X Protocol Reference Manual, page 53,\n         * \"A pixmap depth of one is always supported and listed, but windows\n         * of depth one might not be supported.\"  Therefore we create a pixmap\n         * of depth one and use XCopyPlane().  This is idiomatic.\n         */\n        if (xImageDepth == 1) {         /* just pass the bits through */\n            gc_values.foreground = 1;   /* foreground describes set bits */\n            gc_values.background = 0;   /* background describes clear bits */\n            bitmap_gc = XCreateGC(xDisplay, xImagePixmap,\n                GCForeground | GCBackground, &gc_values);\n            XPutImage(xDisplay, xImagePixmap, bitmap_gc, xImage,\n                0, 0, 0, 0, xImage->width, xImage->height);\n        } else\n            XPutImage(xDisplay, xImagePixmap, xWinGc, xImage,\n                0, 0, 0, 0, xImage->width, xImage->height);\n        XDestroyImage(xImage);\n        free(imageMemory);\n    }\n}",
          "fn_code_pos": [
            [
              869,
              0
            ],
            [
              932,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateXImage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nQuitProc(void)\n{\n    exit(0);\n}",
          "fn_code_pos": [
            [
              961,
              0
            ],
            [
              965,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "QuitProc",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nNextProc()\n{\n    PageProc(ButtonNextPage);\n}",
          "fn_code_pos": [
            [
              967,
              0
            ],
            [
              971,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "NextProc",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nPreviousProc()\n{\n    PageProc(ButtonPreviousPage);\n}",
          "fn_code_pos": [
            [
              973,
              0
            ],
            [
              977,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PreviousProc",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nResizeProc()\n{\n    Dimension w_width, w_height;\n    int xo, yo, ww, wh;\n    XEvent fake_event;\n    Arg args[2];\n\n    if ((xOffset == 0) && (yOffset == 0))\n        return;\n\n    XtSetArg(args[0], XtNwidth, &w_width);\n    XtSetArg(args[1], XtNheight, &w_height);\n    XtGetValues(shellWidget, args, 2);\n    ww = w_width;\n    wh = w_height;\n    XtGetValues(listWidget, args, 2);\n    wh -= w_height;\n\n    xo = xOffset; yo = yOffset;\n\n    if ((xOffset + ww) >= tfImageWidth)\n        xOffset = MAX((int) tfImageWidth - ww, 0);\n    if ((yOffset + wh) >= tfImageHeight)\n        yOffset = MAX((int) tfImageHeight - wh, 0);\n\n    /*\n     * Send an ExposeEvent if the origin changed.\n     * We have to do this because of the use and semantics of bit gravity.\n     */\n    if ((xo != xOffset) || (yo != yOffset)) {\n        fake_event.type = Expose;\n        fake_event.xexpose.x = fake_event.xexpose.y = 0;\n        fake_event.xexpose.width = tfImageWidth;\n        fake_event.xexpose.height = tfImageHeight;\n        EventProc(imageWidget, NULL, &fake_event);\n    }\n}",
          "fn_code_pos": [
            [
              1204,
              0
            ],
            [
              1241,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ResizeProc",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nUsage()\n{\n    fprintf(stderr, \"Usage xtiff: [options] tiff-file\\n\");\n    fprintf(stderr, \"\\tstandard Xt options\\n\");\n    fprintf(stderr, \"\\t[-help]\\n\");\n    fprintf(stderr, \"\\t[-gamma gamma]\\n\");\n    fprintf(stderr, \"\\t[-usePixmap (True | False)]\\n\");\n    fprintf(stderr, \"\\t[-viewportWidth pixels]\\n\");\n    fprintf(stderr, \"\\t[-viewportHeight pixels]\\n\");\n    fprintf(stderr, \"\\t[-translate pixels]\\n\");\n    fprintf(stderr, \"\\t[-verbose (True | False)]\\n\");\n    exit(0);\n}",
          "fn_code_pos": [
            [
              1264,
              0
            ],
            [
              1277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n    Boolean help;\n    float gamma;\n    Boolean usePixmap;\n    uint32 viewportWidth;\n    uint32 viewportHeight;\n    int translate;\n    Boolean verbose;\n} AppData, *AppDataPtr;",
          {
            "help": "Boolean",
            "gamma": "float",
            "usePixmap": "Boolean",
            "viewportWidth": "uint32",
            "viewportHeight": "uint32",
            "translate": "int",
            "verbose": "Boolean"
          },
          "AppData",
          [
            129,
            0
          ],
          [
            137,
            23
          ]
        ],
        [
          "typedef struct {\n    Boolean help;\n    float gamma;\n    Boolean usePixmap;\n    uint32 viewportWidth;\n    uint32 viewportHeight;\n    int translate;\n    Boolean verbose;\n} AppData, *AppDataPtr;",
          {
            "help": "Boolean",
            "gamma": "float",
            "usePixmap": "Boolean",
            "viewportWidth": "uint32",
            "viewportHeight": "uint32",
            "translate": "int",
            "verbose": "Boolean"
          },
          "AppDataPtr",
          [
            129,
            0
          ],
          [
            137,
            23
          ]
        ],
        [
          "typedef struct {\n    Boolean help;\n    float gamma;\n    Boolean usePixmap;\n    uint32 viewportWidth;\n    uint32 viewportHeight;\n    int translate;\n    Boolean verbose;\n} AppData, *AppDataPtr;",
          {
            "help": "Boolean",
            "gamma": "float",
            "usePixmap": "Boolean",
            "viewportWidth": "uint32",
            "viewportHeight": "uint32",
            "translate": "int",
            "verbose": "Boolean"
          },
          "AppData",
          [
            129,
            0
          ],
          [
            137,
            23
          ]
        ],
        [
          "typedef struct {\n    Boolean help;\n    float gamma;\n    Boolean usePixmap;\n    uint32 viewportWidth;\n    uint32 viewportHeight;\n    int translate;\n    Boolean verbose;\n} AppData, *AppDataPtr;",
          {
            "help": "Boolean",
            "gamma": "float",
            "usePixmap": "Boolean",
            "viewportWidth": "uint32",
            "viewportHeight": "uint32",
            "translate": "int",
            "verbose": "Boolean"
          },
          "AppDataPtr",
          [
            129,
            0
          ],
          [
            137,
            23
          ]
        ]
      ],
      "include_list": [
        [
          "#include <math.h>\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include <tiffio.h>\n",
          [
            57,
            0
          ],
          [
            58,
            0
          ]
        ],
        [
          "#include <X11/Xatom.h>\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include <X11/Intrinsic.h>\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ],
        [
          "#include <X11/StringDefs.h>\n",
          [
            60,
            0
          ],
          [
            61,
            0
          ]
        ],
        [
          "#include <X11/Xproto.h>\n",
          [
            61,
            0
          ],
          [
            62,
            0
          ]
        ],
        [
          "#include <X11/Shell.h>\n",
          [
            62,
            0
          ],
          [
            63,
            0
          ]
        ],
        [
          "#include <X11/Xaw/Form.h>\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include <X11/Xaw/List.h>\n",
          [
            64,
            0
          ],
          [
            65,
            0
          ]
        ],
        [
          "#include <X11/Xaw/Label.h>\n",
          [
            65,
            0
          ],
          [
            66,
            0
          ]
        ],
        [
          "#include <X11/cursorfont.h>\n",
          [
            66,
            0
          ],
          [
            67,
            0
          ]
        ],
        [
          "#include <X11/keysymdef.h>\n",
          [
            68,
            0
          ],
          [
            69,
            0
          ]
        ],
        [
          "#include \"xtifficon.h\"\n",
          [
            69,
            0
          ],
          [
            70,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "enum { ButtonQuit = 0, ButtonPreviousPage = 1, ButtonNextPage = 2 }",
          {
            "ButtonQuit": "",
            "ButtonPreviousPage": "",
            "ButtonNextPage": ""
          },
          "",
          [
            115,
            0
          ],
          [
            115,
            67
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/ras/tif2ras.c": {
      "fn_def_list": [
        {
          "fn_code": "void\nusage()\n{\n    error(\"usage: %s -[vq] TIFFfile [rasterfile]\\n\", NULL);\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <pixrect/pixrect_hs.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/ras/ras2tif.c": {
      "fn_def_list": [
        {
          "fn_code": "void\nusage()\n{\n    error(\"usage: %s -[vq] [-|rasterfile] TIFFfile\\n\", NULL);\n}",
          "fn_code_pos": [
            [
              68,
              0
            ],
            [
              72,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct tm",
          {},
          "",
          [
            91,
            4
          ],
          [
            91,
            13
          ]
        ],
        [
          "struct timeval",
          {},
          "",
          [
            92,
            4
          ],
          [
            92,
            18
          ]
        ],
        [
          "struct timezone",
          {},
          "",
          [
            104,
            23
          ],
          [
            104,
            38
          ]
        ]
      ],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include <sys/time.h>\n",
          [
            46,
            0
          ],
          [
            47,
            0
          ]
        ],
        [
          "#include <pixrect/pixrect_hs.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/win_dib/tiff2dib.c": {
      "fn_def_list": [
        {
          "fn_code": "HDIB LoadTIFFinDIB(LPSTR lpFileName)    \n{\n    TIFF          *tif;\n    unsigned long imageLength; \n    unsigned long imageWidth; \n    unsigned int  BitsPerSample;\n    unsigned long LineSize;\n    unsigned int  SamplePerPixel;\n    unsigned long RowsPerStrip;  \n    int           PhotometricInterpretation;\n    long          nrow;\n\tunsigned long row;\n    char          *buf;          \n    LPBITMAPINFOHEADER lpDIB; \n    HDIB          hDIB;\n    char          *lpBits;\n    HGLOBAL       hStrip;\n    int           i,l;\n    int           Align; \n    \n    tif = TIFFOpen(lpFileName, \"r\");\n    \n    if (!tif)\n        goto TiffOpenError;\n    \n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &imageLength);  \n    TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);  \n    TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);   \n    TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n           \n    LineSize = TIFFScanlineSize(tif); //Number of byte in ine line\n\n    SamplePerPixel = (int) (LineSize/imageWidth);\n\n    //Align = Number of byte to add at the end of each line of the DIB\n    Align = 4 - (LineSize % 4);\n    if (Align == 4)\tAlign = 0;\n\n    \n    //Create a new DIB\n    hDIB = CreateDIB((DWORD) imageWidth, (DWORD) imageLength, (WORD)\n(BitsPerSample*SamplePerPixel));\n    lpDIB  = (LPBITMAPINFOHEADER) GlobalLock(hDIB);\n    if (!lpDIB)\n          goto OutOfDIBMemory;\n          \n    if (lpDIB)\n       lpBits = FindDIBBits((LPSTR) lpDIB);\n\n    //In the tiff file the lines are save from up to down \n\t//In a DIB the lines must be save from down to up\n    if (lpBits)\n      {\n        lpBits = FindDIBBits((LPSTR) lpDIB);\n        lpBits+=((imageWidth*SamplePerPixel)+Align)*(imageLength-1);\n\t\t//now lpBits pointe on the bottom line\n        \n        hStrip = GlobalAlloc(GHND,TIFFStripSize(tif));\n        buf = GlobalLock(hStrip);           \n        \n        if (!buf)\n           goto OutOfBufMemory;\n        \n        //PhotometricInterpretation = 2 image is RGB\n        //PhotometricInterpretation = 3 image have a color palette              \n        if (PhotometricInterpretation == 3)\n        {\n          uint16* red;\n          uint16* green;\n          uint16* blue;\n          int16 i;\n          LPBITMAPINFO lpbmi;   \n          int   Palette16Bits;          \n           \n          TIFFGetField(tif, TIFFTAG_COLORMAP, &red, &green, &blue); \n\n\t\t  //Is the palette 16 or 8 bits ?\n          if (checkcmap(1<<BitsPerSample, red, green, blue) == 16) \n             Palette16Bits = TRUE;\n          else\n             Palette16Bits = FALSE;\n             \n          lpbmi = (LPBITMAPINFO)lpDIB;                      \n                \n          //load the palette in the DIB\n          for (i = (1<<BitsPerSample)-1; i >= 0; i--) \n            {             \n             if (Palette16Bits)\n                {\n                  lpbmi->bmiColors[i].rgbRed =(BYTE) CVT(red[i]);\n                  lpbmi->bmiColors[i].rgbGreen = (BYTE) CVT(green[i]);\n                  lpbmi->bmiColors[i].rgbBlue = (BYTE) CVT(blue[i]);           \n                }\n             else\n                {\n                  lpbmi->bmiColors[i].rgbRed = (BYTE) red[i];\n                  lpbmi->bmiColors[i].rgbGreen = (BYTE) green[i];\n                  lpbmi->bmiColors[i].rgbBlue = (BYTE) blue[i];        \n                }\n            }  \n                 \n        }\n        \n        //read the tiff lines and save them in the DIB\n\t\t//with RGB mode, we have to change the order of the 3 samples RGB\n<=> BGR\n        for (row = 0; row < imageLength; row += RowsPerStrip) \n          {     \n            nrow = (row + RowsPerStrip > imageLength ? imageLength - row :\nRowsPerStrip);\n            if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, row, 0),\n                buf, nrow*LineSize)==-1)\n                  {\n                     goto TiffReadError;\n                  } \n            else\n                  {  \n                    for (l = 0; l < nrow; l++) \n                      {\n                         if (SamplePerPixel  == 3)\n                           for (i=0;i< (int) (imageWidth);i++)\n                              {\n                               lpBits[i*SamplePerPixel+0]=buf[l*LineSize+i*Sample\nPerPixel+2]; \n                               lpBits[i*SamplePerPixel+1]=buf[l*LineSize+i*Sample\nPerPixel+1];\n                               lpBits[i*SamplePerPixel+2]=buf[l*LineSize+i*Sample\nPerPixel+0];\n                              }\n                         else\n                           memcpy(lpBits, &buf[(int) (l*LineSize)], (int)\nimageWidth*SamplePerPixel); \n                          \n                         lpBits-=imageWidth*SamplePerPixel+Align;\n\n                      }\n                 }\n          }\n        GlobalUnlock(hStrip);\n        GlobalFree(hStrip);\n        GlobalUnlock(hDIB); \n        TIFFClose(tif);\n      }\n      \n    return hDIB;\n    \n    OutOfBufMemory:\n       \n    TiffReadError:\n       GlobalUnlock(hDIB); \n       GlobalFree(hStrip);\n    OutOfDIBMemory:\n       TIFFClose(tif);\n    TiffOpenError:\n       return (HANDLE) 0;\n       \n         \n}",
          "fn_code_pos": [
            [
              58,
              0
            ],
            [
              217,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LoadTIFFinDIB",
            "parameters": {
              "lpFileName": "LPSTR"
            },
            "return_type": "HDIB"
          }
        },
        {
          "fn_code": "static int checkcmap(int n, uint16* r, uint16* g, uint16* b)\n{\n    while (n-- > 0)\n        if (*r++ >= 256 || *g++ >= 256 || *b++ >= 256)\n        return (16);\n    \n    return (8);\n}",
          "fn_code_pos": [
            [
              220,
              0
            ],
            [
              227,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "checkcmap",
            "parameters": {
              "n": "int",
              "r": "uint16",
              "g": "uint16",
              "b": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "HDIB CreateDIB(DWORD dwWidth, DWORD dwHeight, WORD wBitCount)\n{\n   BITMAPINFOHEADER bi;         // bitmap header\n   LPBITMAPINFOHEADER lpbi;     // pointer to BITMAPINFOHEADER\n   DWORD dwLen;                 // size of memory block\n   HDIB hDIB;\n   DWORD dwBytesPerLine;        // Number of bytes per scanline\n\n\n   // Make sure bits per pixel is valid\n   if (wBitCount <= 1)\n      wBitCount = 1;\n   else if (wBitCount <= 4)\n      wBitCount = 4;\n   else if (wBitCount <= 8)\n      wBitCount = 8;\n   else if (wBitCount <= 24)\n      wBitCount = 24;\n   else\n      wBitCount = 4;  // set default value to 4 if parameter is bogus\n\n   // initialize BITMAPINFOHEADER\n   bi.biSize = sizeof(BITMAPINFOHEADER);\n   bi.biWidth = dwWidth;         // fill in width from parameter\n   bi.biHeight = dwHeight;       // fill in height from parameter\n   bi.biPlanes = 1;              // must be 1\n   bi.biBitCount = wBitCount;    // from parameter\n   bi.biCompression = BI_RGB;    \n   bi.biSizeImage = (dwWidth*dwHeight*wBitCount)/8; //0;           // 0's here\nmean \"default\"\n   bi.biXPelsPerMeter = 2834; //0;\n   bi.biYPelsPerMeter = 2834; //0;\n   bi.biClrUsed = 0;\n   bi.biClrImportant = 0;\n\n   // calculate size of memory block required to store the DIB.  This\n   // block should be big enough to hold the BITMAPINFOHEADER, the color\n   // table, and the bits\n\n   dwBytesPerLine =   (((wBitCount * dwWidth) + 31) / 32 * 4);\n   dwLen = bi.biSize + PaletteSize((LPSTR)&bi) + (dwBytesPerLine * dwHeight);\n\n   // alloc memory block to store our bitmap\n   hDIB = GlobalAlloc(GHND, dwLen);\n\n   // major bummer if we couldn't get memory block\n   if (!hDIB)\n   {\n      return NULL;\n   }\n\n   // lock memory and get pointer to it\n   lpbi = (VOID FAR *)GlobalLock(hDIB);\n\n   // use our bitmap info structure to fill in first part of\n   // our DIB with the BITMAPINFOHEADER\n   *lpbi = bi;\n\n   // Since we don't know what the colortable and bits should contain,\n   // just leave these blank.  Unlock the DIB and return the HDIB.\n\n   GlobalUnlock(hDIB);\n\n   /* return handle to the DIB */\n   return hDIB;\n}",
          "fn_code_pos": [
            [
              245,
              0
            ],
            [
              310,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateDIB",
            "parameters": {
              "dwWidth": "DWORD",
              "dwHeight": "DWORD",
              "wBitCount": "WORD"
            },
            "return_type": "HDIB"
          }
        },
        {
          "fn_code": "LPSTR FAR FindDIBBits(LPSTR lpDIB)\n{\n   return (lpDIB + *(LPDWORD)lpDIB + PaletteSize(lpDIB));\n}",
          "fn_code_pos": [
            [
              313,
              0
            ],
            [
              316,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FindDIBBits",
            "parameters": {
              "lpDIB": "LPSTR"
            },
            "return_type": "LPSTR"
          }
        },
        {
          "fn_code": "WORD FAR PaletteSize(LPSTR lpDIB)\n{\n   /* calculate the size required by the palette */\n   if (IS_WIN30_DIB (lpDIB))\n      return (DIBNumColors(lpDIB) * sizeof(RGBQUAD));\n   else\n      return (DIBNumColors(lpDIB) * sizeof(RGBTRIPLE));\n}",
          "fn_code_pos": [
            [
              319,
              0
            ],
            [
              326,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PaletteSize",
            "parameters": {
              "lpDIB": "LPSTR"
            },
            "return_type": "WORD"
          }
        },
        {
          "fn_code": "WORD DIBNumColors(LPSTR lpDIB)\n{\n   WORD wBitCount;  // DIB bit count\n\n   /*  If this is a Windows-style DIB, the number of colors in the\n    *  color table can be less than the number of bits per pixel\n    *  allows for (i.e. lpbi->biClrUsed can be set to some value).\n    *  If this is the case, return the appropriate value.\n    */\n\n   if (IS_WIN30_DIB(lpDIB))\n   {\n      DWORD dwClrUsed;\n\n      dwClrUsed = ((LPBITMAPINFOHEADER)lpDIB)->biClrUsed;\n      if (dwClrUsed)\n     return (WORD)dwClrUsed;\n   }\n\n   /*  Calculate the number of colors in the color table based on\n    *  the number of bits per pixel for the DIB.\n    */\n   if (IS_WIN30_DIB(lpDIB))\n      wBitCount = ((LPBITMAPINFOHEADER)lpDIB)->biBitCount;\n   else\n      wBitCount = ((LPBITMAPCOREHEADER)lpDIB)->bcBitCount;\n\n   /* return number of colors based on bits per pixel */\n   switch (wBitCount)\n      {\n   case 1:\n      return 2;\n\n   case 4:\n      return 16;\n\n   case 8:\n      return 256;\n\n   default:\n      return 0;\n      }\n}",
          "fn_code_pos": [
            [
              329,
              0
            ],
            [
              371,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DIBNumColors",
            "parameters": {
              "lpDIB": "LPSTR"
            },
            "return_type": "WORD"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "CreateDIB(DWORD dwWidth, DWORD dwHeight, WORD wBitCount)",
          "fn_dec_pos": [
            [
              28,
              12
            ],
            [
              28,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CreateDIB",
            "parameters": {
              "dwWidth": "DWORD",
              "dwHeight": "DWORD",
              "wBitCount": "WORD"
            },
            "return_type": "HDIB"
          }
        },
        {
          "fn_code": "FindDIBBits(LPSTR lpDIB)",
          "fn_dec_pos": [
            [
              29,
              13
            ],
            [
              29,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "FindDIBBits",
            "parameters": {
              "lpDIB": "LPSTR"
            },
            "return_type": "LPSTR"
          }
        },
        {
          "fn_code": "PaletteSize(LPSTR lpDIB)",
          "fn_dec_pos": [
            [
              30,
              12
            ],
            [
              30,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PaletteSize",
            "parameters": {
              "lpDIB": "LPSTR"
            },
            "return_type": "WORD"
          }
        },
        {
          "fn_code": "DIBNumColors(LPSTR lpDIB)",
          "fn_dec_pos": [
            [
              31,
              12
            ],
            [
              31,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DIBNumColors",
            "parameters": {
              "lpDIB": "LPSTR"
            },
            "return_type": "WORD"
          }
        },
        {
          "fn_code": "checkcmap(int n, uint16* r, uint16* g, uint16* b)",
          "fn_dec_pos": [
            [
              32,
              11
            ],
            [
              32,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "checkcmap",
            "parameters": {
              "n": "int",
              "r": "uint16",
              "g": "uint16",
              "b": "uint16"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffio.h\"",
          [
            22,
            0
          ],
          [
            22,
            19
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/win_dib/Tiffile.cpp": {
      "fn_def_list": [
        {
          "fn_code": "static void\nMyWarningHandler(const char* module, const char* fmt, va_list ap)\n{\n    // ignore all warnings (unused tags, etc)\n    return;\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              49,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyWarningHandler",
            "parameters": {
              "module": "char",
              "fmt": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nMyErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n    return;\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "MyErrorHandler",
            "parameters": {
              "module": "char",
              "fmt": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int ChkTIFF ( LPCTSTR lpszPath )\n{\n    int rtn = 0;\n\n    TIFFErrorHandler  eh;\n    TIFFErrorHandler  wh;\n\n    eh = TIFFSetErrorHandler(NULL);\n    wh = TIFFSetWarningHandler(NULL);\n\n    TIFF* tif = TIFFOpen(lpszPath, \"r\");\n    if (tif) {\n        rtn = 1;\n        TIFFClose(tif);\n    }\n\n    TIFFSetErrorHandler(eh);\n    TIFFSetWarningHandler(wh);\n\n    return rtn;\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              79,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ChkTIFF",
            "parameters": {
              "lpszPath": "LPCTSTR"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "PVOID ReadTIFF ( LPCTSTR lpszPath )\n{\n    void*             pDIB = 0;\n    TIFFErrorHandler  wh;\n\n    wh = TIFFSetWarningHandler(MyWarningHandler);\n\n    if (ChkTIFF(lpszPath)) {\n        TIFF* tif = TIFFOpen(lpszPath, \"r\");\n        if (tif) {\n            char emsg[1024];\n\n            if (TIFFRGBAImageOK(tif, emsg)) {\n                TIFFDibImage img;\n                char emsg[1024];\n\n                if (TIFFRGBAImageBegin(&img.tif, tif, -1, emsg)) {\n                    size_t npixels;\n                    uint32* raster;\n\n                    DibInstallHack(&img);\n\n                    npixels = img.tif.width * img.tif.height;\n                    raster = (uint32*) _TIFFmalloc(npixels * sizeof (uint32));\n                    if (raster != NULL) {\n                        if (TIFFRGBAImageGet(&img.tif, raster, img.tif.width, img.tif.height)) {\n                            pDIB = TIFFRGBA2DIB(&img, raster);\n                        }\n                    }\n                    _TIFFfree(raster);\n                }\n                TIFFRGBAImageEnd(&img.tif);\n            }\n            else {\n                TRACE(\"Unable to open image(%s): %s\\n\", lpszPath, emsg );\n            }\n            TIFFClose(tif);\n        }\n    }\n\n    TIFFSetWarningHandler(wh);\n\n    return pDIB;\n}",
          "fn_code_pos": [
            [
              83,
              0
            ],
            [
              126,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadTIFF",
            "parameters": {
              "lpszPath": "LPCTSTR"
            },
            "return_type": "PVOID"
          }
        },
        {
          "fn_code": "HANDLE TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)\n{\n    void*   pDIB = 0;\n    TIFFRGBAImage* img = &dib->tif;\n\n    uint32 imageLength;\n    uint32 imageWidth;\n    uint16 BitsPerSample;\n    uint16 SamplePerPixel;\n    uint32 RowsPerStrip;\n    uint16 PhotometricInterpretation;\n\n    BITMAPINFOHEADER   bi;\n    int                dwDIBSize ;\n\n    TIFFGetField(img->tif, TIFFTAG_IMAGEWIDTH, &imageWidth);\n    TIFFGetField(img->tif, TIFFTAG_IMAGELENGTH, &imageLength);\n    TIFFGetField(img->tif, TIFFTAG_BITSPERSAMPLE, &BitsPerSample);\n    TIFFGetField(img->tif, TIFFTAG_ROWSPERSTRIP, &RowsPerStrip);\n    TIFFGetField(img->tif, TIFFTAG_SAMPLESPERPIXEL, &SamplePerPixel);\n    TIFFGetField(img->tif, TIFFTAG_PHOTOMETRIC, &PhotometricInterpretation);\n\n    if ( BitsPerSample == 1 && SamplePerPixel == 1 && dib->dibinstalled ) {   // bilevel\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 1;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        pRgbq[0].rgbRed      = 0;\n        pRgbq[0].rgbBlue     = 0;\n        pRgbq[0].rgbGreen    = 0;\n        pRgbq[0].rgbReserved = 0;\n        pRgbq[1].rgbRed      = 255;\n        pRgbq[1].rgbBlue     = 255;\n        pRgbq[1].rgbGreen    = 255;\n        pRgbq[1].rgbReserved = 255;\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = GetDIBImagePtr((BITMAPINFOHEADER*)pDIB);  //(LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        _TIFFmemcpy(pbiBits, raster, bi.biSizeImage);\n    }\n\n        //  For now just always default to the RGB 32 bit form.                                                       // save as 32 bit for simplicity\n    else if ( true /*BitsPerSample == 8 && SamplePerPixel == 3*/ ) {   // 24 bit color\n\n        bi.biSize           = sizeof(BITMAPINFOHEADER);\n        bi.biWidth          = imageWidth;\n        bi.biHeight         = imageLength;\n        bi.biPlanes         = 1;  // always\n        bi.biBitCount       = 32;\n        bi.biCompression    = BI_RGB;\n        bi.biSizeImage      = WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;\n        bi.biXPelsPerMeter  = 0;\n        bi.biYPelsPerMeter  = 0;\n        bi.biClrUsed        = 0;  //  must be zero for RGB compression (none)\n        bi.biClrImportant   = 0;  // always\n\n        // Get the size of the DIB\n        dwDIBSize = GetDIBSize( &bi );\n\n        // Allocate for the BITMAPINFO structure and the color table.\n        pDIB = GlobalAllocPtr( GHND, dwDIBSize );\n        if (pDIB == 0) {\n            return( NULL );\n        }\n\n        // Copy the header info\n        *((BITMAPINFOHEADER*)pDIB) = bi;\n\n        // Get a pointer to the color table\n        RGBQUAD   *pRgbq = (RGBQUAD   *)((LPSTR)pDIB + sizeof(BITMAPINFOHEADER));\n\n        // Pointers to the bits\n        //PVOID pbiBits = (LPSTR)pRgbq + bi.biClrUsed * sizeof(RGBQUAD);\n        //\n        // In the BITMAPINFOHEADER documentation, it appears that\n        // there should be no color table for 32 bit images, but\n        // experience shows that the image is off by 3 words if it\n        // is not included.  So here it is.\n        PVOID pbiBits = (LPSTR)pRgbq + 3 * sizeof(RGBQUAD);\n\n        int       sizeWords = bi.biSizeImage/4;\n        RGBQUAD*  rgbDib = (RGBQUAD*)pbiBits;\n        long*     rgbTif = (long*)raster;\n\n        // Swap the byte order while copying\n        for ( int i = 0 ; i < sizeWords ; ++i )\n        {\n            rgbDib[i].rgbRed   = TIFFGetR(rgbTif[i]);\n            rgbDib[i].rgbBlue  = TIFFGetB(rgbTif[i]);\n            rgbDib[i].rgbGreen = TIFFGetG(rgbTif[i]);\n            rgbDib[i].rgbReserved = 0;\n        }\n    }\n\n    return pDIB;\n}",
          "fn_code_pos": [
            [
              130,
              0
            ],
            [
              259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRGBA2DIB",
            "parameters": {
              "dib": "TIFFDibImage",
              "raster": "uint32"
            },
            "return_type": "HANDLE"
          }
        },
        {
          "fn_code": "void DibInstallHack(TIFFDibImage* dib) {\n    TIFFRGBAImage* img = &dib->tif;\n    dib->dibinstalled = false;\n    switch (img->photometric) {\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n        switch (img->bitspersample) {\n            case 1:\n                img->put.contig = putContig1bitTile;\n                img->get = getStripContig1Bit;\n                dib->dibinstalled = true;\n                break;\n        }\n        break;\n    }\n}",
          "fn_code_pos": [
            [
              300,
              0
            ],
            [
              315,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DibInstallHack",
            "parameters": {
              "dib": "TIFFDibImage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "DECLAREContigPutFunc(putContig1bitTile)\n{\n    int samplesperpixel = img->samplesperpixel;\n\n    (void) y;\n    fromskew *= samplesperpixel;\n    int wb = WIDTHBYTES(w);\n    u_char*  ucp = (u_char*)cp;\n\n    /* Conver 'w' to bytes from pixels (rounded up) */\n    w = (w+7)/8;\n\n    while (h-- > 0) {\n        _TIFFmemcpy(ucp, pp, w);\n        /*\n        for (x = wb; x-- > 0;) {\n            *cp++ = rgbi(Map[pp[0]], Map[pp[1]], Map[pp[2]]);\n            pp += samplesperpixel;\n        }\n        */\n        ucp += (wb + toskew);\n        pp += (w + fromskew);\n    }\n}",
          "fn_code_pos": [
            [
              322,
              0
            ],
            [
              345,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREContigPutFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static uint32\nsetorientation(TIFFRGBAImage* img, uint32 h)\n{\n    TIFF* tif = img->tif;\n    uint32 y;\n\n    switch (img->orientation) {\n    case ORIENTATION_BOTRIGHT:\n    case ORIENTATION_RIGHTBOT:  /* XXX */\n    case ORIENTATION_LEFTBOT:   /* XXX */\n    TIFFWarning(TIFFFileName(tif), \"using bottom-left orientation\");\n    img->orientation = ORIENTATION_BOTLEFT;\n    /* fall through... */\n    case ORIENTATION_BOTLEFT:\n    y = 0;\n    break;\n    case ORIENTATION_TOPRIGHT:\n    case ORIENTATION_RIGHTTOP:  /* XXX */\n    case ORIENTATION_LEFTTOP:   /* XXX */\n    default:\n    TIFFWarning(TIFFFileName(tif), \"using top-left orientation\");\n    img->orientation = ORIENTATION_TOPLEFT;\n    /* fall through... */\n    case ORIENTATION_TOPLEFT:\n    y = h-1;\n    break;\n    }\n    return (y);\n}",
          "fn_code_pos": [
            [
              350,
              0
            ],
            [
              378,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setorientation",
            "parameters": {
              "img": "TIFFRGBAImage",
              "h": "uint32"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "static int\ngetStripContig1Bit(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)\n{\n    TIFF* tif = img->tif;\n    tileContigRoutine put = img->put.contig;\n    uint16 orientation;\n    uint32 row, y, nrow, rowstoread;\n    uint32 pos;\n    u_char* buf;\n    uint32 rowsperstrip;\n    uint32 imagewidth = img->width;\n    tsize_t scanline;\n    int32 fromskew, toskew;\n    tstrip_t strip;\n    tsize_t  stripsize;\n    u_char* braster = (u_char*)raster; // byte wide raster\n    uint32  wb = WIDTHBYTES(w);\n    int ret = 1;\n\n    buf = (u_char*) _TIFFmalloc(TIFFStripSize(tif));\n    if (buf == 0) {\n        TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"No space for strip buffer\");\n        return (0);\n    }\n    y = setorientation(img, h);\n    orientation = img->orientation;\n    toskew = -(int32) (orientation == ORIENTATION_TOPLEFT ? wb+wb : wb-wb);\n    TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    scanline = TIFFScanlineSize(tif);\n    fromskew = (w < imagewidth ? imagewidth - w : 0)/8;\n    for (row = 0; row < h; row += nrow)\n    {\n        rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;\n        nrow = (row + rowstoread > h ? h - row : rowstoread);\n        strip = TIFFComputeStrip(tif,row+img->row_offset, 0);\n        stripsize = ((row + img->row_offset)%rowsperstrip + nrow) * scanline;\n        if (TIFFReadEncodedStrip(tif, strip, buf, stripsize ) < 0\n            && img->stoponerr)\n        {\n            ret = 0;\n            break;\n        }\n\n        pos = ((row + img->row_offset) % rowsperstrip) * scanline;\n        (*put)(img, (uint32*)(braster+y*wb), 0, y, w, nrow, fromskew, toskew, buf + pos);\n        y += (orientation == ORIENTATION_TOPLEFT ?-(int32) nrow : (int32) nrow);\n    }\n    _TIFFfree(buf);\n    return (ret);\n}",
          "fn_code_pos": [
            [
              391,
              0
            ],
            [
              440,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getStripContig1Bit",
            "parameters": {
              "img": "TIFFRGBAImage",
              "raster": "uint32",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "LoadTIFFinDIB(LPCTSTR lpFileName)",
          "fn_dec_pos": [
            [
              41,
              7
            ],
            [
              41,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LoadTIFFinDIB",
            "parameters": {
              "lpFileName": "LPCTSTR"
            },
            "return_type": "HANDLE"
          }
        },
        {
          "fn_code": "TIFFRGBA2DIB(TIFFDibImage* dib, uint32* raster)",
          "fn_dec_pos": [
            [
              42,
              7
            ],
            [
              42,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRGBA2DIB",
            "parameters": {
              "dib": "TIFFDibImage",
              "raster": "uint32"
            },
            "return_type": "HANDLE"
          }
        },
        {
          "fn_code": "DibInstallHack(TIFFDibImage* img)",
          "fn_dec_pos": [
            [
              81,
              5
            ],
            [
              81,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DibInstallHack",
            "parameters": {
              "img": "TIFFDibImage"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "getStripContig1Bit(TIFFRGBAImage* img, uint32* uraster, uint32 w, uint32 h)",
          "fn_dec_pos": [
            [
              293,
              11
            ],
            [
              293,
              86
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getStripContig1Bit",
            "parameters": {
              "img": "TIFFRGBAImage",
              "uraster": "uint32",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n}",
          {
            "tif": "TIFFRGBAImage",
            "dibinstalled": "int"
          },
          "TIFFDibImage",
          [
            35,
            0
          ],
          [
            38,
            1
          ]
        ],
        [
          "struct TIFFDibImage {\n    TIFFRGBAImage tif;\n    int  dibinstalled;\n}",
          {
            "tif": "TIFFRGBAImage",
            "dibinstalled": "int"
          },
          "TIFFDibImage",
          [
            35,
            0
          ],
          [
            38,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"StdAfx.h\"\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ],
        [
          "#include <windows.h>\n",
          [
            3,
            0
          ],
          [
            4,
            0
          ]
        ],
        [
          "#include <windowsx.h>\n",
          [
            4,
            0
          ],
          [
            5,
            0
          ]
        ],
        [
          "#include <commdlg.h>\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ],
        [
          "#include <stdlib.h>                     // MAX_ constants\n",
          [
            6,
            0
          ],
          [
            7,
            0
          ]
        ],
        [
          "#include \"diblib.h\"\n",
          [
            7,
            0
          ],
          [
            8,
            0
          ]
        ],
        [
          "#include \"TiffLib/tiff.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"TiffLib/tiffio.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/stream/tiffstream.cpp": {
      "fn_def_list": [
        {
          "fn_code": "TiffStream::TiffStream()\n{\n    m_tif = NULL;\n\n\n    m_inStream = NULL;\n\tm_outStream = NULL;\n\tm_ioStream = NULL;\n\n\tm_streamLength = 0;\n\n\tm_this = reinterpret_cast<thandle_t>(this);\n}",
          "fn_code_pos": [
            [
              6,
              0
            ],
            [
              18,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::TiffStream",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TiffStream::~TiffStream()\n{\n    if(m_tif != NULL) TIFFClose(m_tif);\n}",
          "fn_code_pos": [
            [
              20,
              0
            ],
            [
              23,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::~TiffStream",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFF*\nTiffStream::makeFileStream(istream* str)\n{\n    m_inStream = str;\n\tm_outStream = NULL;\n\tm_ioStream = NULL;\n    m_streamLength = getSize(m_this);\n\n    m_tif =  TIFFClientOpen(m_name, \n                           \"r\",\n\t\t\t\t\t\t   m_this,\n\t\t\t\t\t\t   read,\n\t\t\t\t\t\t   write,\n\t\t\t\t\t\t   seek,\n\t\t\t\t\t\t   close,\n\t\t\t\t\t\t   size,\n\t\t\t\t\t\t   map,\n\t\t\t\t\t\t   unmap);\n    return m_tif;\n}",
          "fn_code_pos": [
            [
              25,
              0
            ],
            [
              44,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::makeFileStream",
            "parameters": {
              "str": "istream"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "TIFF*\nTiffStream::makeFileStream(ostream* str)\n{\n\tm_inStream = NULL;\n    m_outStream = str;\n\tm_ioStream = NULL;\n\tm_streamLength = getSize(m_this);\n\n\tm_tif =  TIFFClientOpen(m_name, \n                           \"w\",\n\t\t\t\t\t\t   m_this,\n\t\t\t\t\t\t   read,\n\t\t\t\t\t\t   write,\n\t\t\t\t\t\t   seek,\n\t\t\t\t\t\t   close,\n\t\t\t\t\t\t   size,\n\t\t\t\t\t\t   map,\n\t\t\t\t\t\t   unmap);\n    return m_tif;\n}",
          "fn_code_pos": [
            [
              46,
              0
            ],
            [
              65,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::makeFileStream",
            "parameters": {
              "str": "ostream"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "TIFF*\nTiffStream::makeFileStream(iostream* str)\n{\n\tm_inStream = NULL;\n\tm_outStream = NULL;\n    m_ioStream = str;\n\tm_streamLength = getSize(m_this);\n\n    m_tif =  TIFFClientOpen(m_name, \n\t                       \"r+w\",\n\t\t\t\t\t\t   m_this,\n\t\t\t\t\t\t   read,\n\t\t\t\t\t\t   write,\n\t\t\t\t\t\t   seek,\n\t\t\t\t\t\t   close,\n\t\t\t\t\t\t   size,\n\t\t\t\t\t\t   map,\n\t\t\t\t\t\t   unmap);\n    return m_tif;\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::makeFileStream",
            "parameters": {
              "str": "iostream"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "tsize_t\nTiffStream::read(thandle_t fd, tdata_t buf, tsize_t size)\n{\n\tistream* istr;\n\tTiffStream* ts = reinterpret_cast<TiffStream*>(fd);\n    if(ts->m_inStream != NULL) {\n\t    istr = ts->m_inStream;\n\t} else if(ts->m_ioStream != NULL) {\n\t    istr = ts->m_ioStream;\n\t}\n\n\tint remain = ts->m_streamLength - ts->tell(fd);\n\tint actual = remain < size ? remain : size;\n\tistr->read(reinterpret_cast<char*>(buf), actual);\n    return istr->gcount();\n}",
          "fn_code_pos": [
            [
              88,
              0
            ],
            [
              103,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::read",
            "parameters": {
              "fd": "thandle_t",
              "buf": "tdata_t",
              "size": "tsize_t"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t\nTiffStream::write(thandle_t fd, tdata_t buf, tsize_t size)\n{\n\tTiffStream* ts = reinterpret_cast<TiffStream*>(fd);\n\tostream* ostr;\n\tif(ts->m_outStream != NULL) {\n\t    ostr = ts->m_outStream;\n\t} else if(ts->m_ioStream != NULL) {\n\t    ostr = ts->m_ioStream;\n\t}\n\n\tstreampos start = ostr->tellp();\n\tostr->write(reinterpret_cast<const char*>(buf), size);\n\treturn ostr->tellp() - start;\n}",
          "fn_code_pos": [
            [
              105,
              0
            ],
            [
              119,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::write",
            "parameters": {
              "fd": "thandle_t",
              "buf": "tdata_t",
              "size": "tsize_t"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "toff_t\nTiffStream::seek(thandle_t fd, toff_t offset, int origin)\n{\n    TiffStream* ts = reinterpret_cast<TiffStream*>(fd);\n    if(ts->seekInt(fd, offset, origin) == true) return offset;\n\telse return -1;\n}",
          "fn_code_pos": [
            [
              121,
              0
            ],
            [
              127,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::seek",
            "parameters": {
              "fd": "thandle_t",
              "offset": "toff_t",
              "origin": "int"
            },
            "return_type": "toff_t"
          }
        },
        {
          "fn_code": "int\nTiffStream::close(thandle_t fd)\n{\n    TiffStream* ts = reinterpret_cast<TiffStream*>(fd);\n\tif(ts->m_inStream != NULL) {\n\t\tts->m_inStream = NULL;\n\t\treturn 0;\n\t} else if(ts->m_outStream != NULL) {\n\t\tts->m_outStream = NULL;\n\t\treturn 0;\n\t} else if(ts->m_ioStream != NULL) {\n\t\tts->m_ioStream = NULL;\n\t\treturn 0;\n\t}\n    return -1;\n}",
          "fn_code_pos": [
            [
              129,
              0
            ],
            [
              144,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::close",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "toff_t\nTiffStream::size(thandle_t fd)\n{\n    TiffStream* ts = reinterpret_cast<TiffStream*>(fd);\n    return ts->getSize(fd);\n}",
          "fn_code_pos": [
            [
              146,
              0
            ],
            [
              151,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::size",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "toff_t"
          }
        },
        {
          "fn_code": "int \nTiffStream::map(thandle_t fd, tdata_t* phase, toff_t* psize)\n{\n    return 0;\n}",
          "fn_code_pos": [
            [
              153,
              0
            ],
            [
              157,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::map",
            "parameters": {
              "fd": "thandle_t",
              "phase": "tdata_t",
              "psize": "toff_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\nTiffStream::unmap(thandle_t fd, tdata_t base, tsize_t size)\n{\n}",
          "fn_code_pos": [
            [
              159,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::unmap",
            "parameters": {
              "fd": "thandle_t",
              "base": "tdata_t",
              "size": "tsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "unsigned int\nTiffStream::getSize(thandle_t fd)\n{\n\tif(!isOpen(fd)) return 0;\n\n    unsigned int pos = tell(fd);\n\tseekInt(fd, 0, end);\n\tunsigned int size = tell(fd);\n\tseekInt(fd, pos, beg);\n\n\treturn size;\n}",
          "fn_code_pos": [
            [
              164,
              0
            ],
            [
              175,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::getSize",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "unsigned int\nTiffStream::tell(thandle_t fd)\n{\n    TiffStream* ts = reinterpret_cast<TiffStream*>(fd);\n    if(ts->m_inStream != NULL) {\n\t    return ts->m_inStream->tellg();\n\t} else if(ts->m_outStream != NULL) {\n\t    return ts->m_outStream->tellp();\n\t} else if(ts->m_ioStream != NULL) {\n\t\treturn ts->m_ioStream->tellg();\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              177,
              0
            ],
            [
              189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::tell",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "bool\nTiffStream::seekInt(thandle_t fd, unsigned int offset, int origin)\n{\n\tif(!isOpen(fd)) return false;\n\n\tios::seek_dir org;\n\tswitch(origin) {\n\tcase beg: \n\t\torg = ios::beg;\n\t\tbreak;\n\tcase cur: \n\t\torg = ios::cur;\n\t\tbreak;\n\tcase end: \n\t\torg = ios::end;\n\t\tbreak;\n\t}\n\n\tTiffStream* ts = reinterpret_cast<TiffStream*>(fd);\n    if(ts->m_inStream != NULL) {\n\t    ts->m_inStream->seekg(offset, org);\n\t\treturn true;\n\t} else if(ts->m_outStream != NULL) {\n\t    ts->m_outStream->seekp(offset, org);\n\t\treturn true;\n\t} else if(ts->m_ioStream != NULL) {\n\t    ts->m_ioStream->seekg(offset, org);\n\t\tts->m_ioStream->seekp(offset, org);\n\t\treturn true;\n\t}\n    return false;\n}",
          "fn_code_pos": [
            [
              191,
              0
            ],
            [
              222,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::seekInt",
            "parameters": {
              "fd": "thandle_t",
              "offset": "unsigned int",
              "origin": "int"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "bool\nTiffStream::isOpen(thandle_t fd)\n{\n\tTiffStream* ts = reinterpret_cast<TiffStream*>(fd);\n\treturn (ts->m_inStream != NULL ||\n\t\t   ts->m_outStream != NULL ||\n\t\t   ts->m_ioStream != NULL);\n}",
          "fn_code_pos": [
            [
              224,
              0
            ],
            [
              231,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::isOpen",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "bool"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TiffStream::makeFileStream(istream* str)",
          "fn_dec_pos": [
            [
              26,
              0
            ],
            [
              26,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::makeFileStream",
            "parameters": {
              "str": "istream"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TiffStream::makeFileStream(ostream* str)",
          "fn_dec_pos": [
            [
              47,
              0
            ],
            [
              47,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::makeFileStream",
            "parameters": {
              "str": "ostream"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TiffStream::makeFileStream(iostream* str)",
          "fn_dec_pos": [
            [
              68,
              0
            ],
            [
              68,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TiffStream::makeFileStream",
            "parameters": {
              "str": "iostream"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffstream.h\"\n",
          [
            2,
            0
          ],
          [
            3,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/fax2ps.c": {
      "fn_def_list": [
        {
          "fn_code": "static void\nprintruns(unsigned char* buf, uint32* runs, uint32* erun, uint32 lastx)\n{\n    static struct {\n\tchar white, black;\n\tunsigned short width;\n    } WBarr[] = {\n\t{ 'd', 'n', 512 }, { 'e', 'o', 256 }, { 'f', 'p', 128 },\n\t{ 'g', 'q',  64 }, { 'h', 'r',  32 }, { 'i', 's',  16 },\n\t{ 'j', 't',   8 }, { 'k', 'u',   4 }, { 'l', 'v',   2 },\n\t{ 'm', 'w',   1 }\n    };\n    static char* svalue =\n\t\" !\\\"#$&'*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abc\";\n    int colormode = 1;\t\t/* 0 for white, 1 for black */\n    uint32 runlength = 0;\n    int n = maxline;\n    uint32 x = 0;\n    int l;\n\n    (void) buf;\n    printf(\"%d m(\", row++);\n    while (runs < erun) {\n\tif (runlength <= 0) {\n\t    colormode ^= 1;\n\t    runlength = *runs++;\n\t    if (x+runlength > lastx)\n\t\trunlength = runs[-1] = lastx-x;\n\t    x += runlength;\n\t    if (!colormode && runs == erun)\t\n\t\tbreak;\t\t/* don't bother printing the final white run */\n\t}\n\t/*\n\t * If a runlength is greater than 6 pixels, then spit out\n\t * black or white characters until the runlength drops to\n\t * 6 or less.  Once a runlength is <= 6, then combine black\n\t * and white runlengths until a 6-pixel pattern is obtained.\n\t * Then write out the special character.  Six-pixel patterns\n\t * were selected since 64 patterns is the largest power of\n\t * two less than the 92 \"easily printable\" PostScript\n\t * characters (i.e., no escape codes or octal chars).\n\t */\n\tl = 0;\n\twhile (runlength > 6) {\t/* Run is greater than six... */\n\t    if (runlength >= WBarr[l].width) {\n\t\tif (n == 0) {\n\t\t    putchar('\\n');\n\t\t    n = maxline;\n\t\t}\n\t\tputchar(colormode ? WBarr[l].black : WBarr[l].white), n--;\n\t\trunlength -= WBarr[l].width;\n\t    } else\n\t\tl++;\n\t}\n\twhile (runlength > 0 && runlength <= 6) {\n\t    uint32 bitsleft = 6;\n\t    int t = 0;\n\t    while (bitsleft) {\n\t\tif (runlength <= bitsleft) {\n\t\t    if (colormode)\n\t\t\tt |= ((1 << runlength)-1) << (bitsleft-runlength);\n\t\t    bitsleft -= runlength;\n\t\t    runlength = 0;\n\t\t    if (bitsleft) {\n\t\t\tif (runs >= erun)\n\t\t\t    break;\n\t\t\tcolormode ^= 1;\n\t\t\trunlength = *runs++;\n\t\t\tif (x+runlength > lastx)\n\t\t\t    runlength = runs[-1] = lastx-x;\n\t\t\tx += runlength;\n\t\t    }\n\t\t} else {\t\t/* runlength exceeds bits left */\n\t\t    if (colormode)\n\t\t\tt |= ((1 << bitsleft)-1);\n\t\t    runlength -= bitsleft;\n\t\t    bitsleft = 0;\n\t\t}\n\t    }\n\t    if (n == 0) {\n\t\tputchar('\\n');\n\t\tn = maxline;\n\t    }\n\t    putchar(svalue[t]), n--;\n\t}\n    }\n    printf(\")s\\n\");\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              156,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "printruns",
            "parameters": {
              "buf": "unsigned char",
              "runs": "uint32",
              "erun": "uint32",
              "lastx": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nemitFont(FILE* fd)\n{\n    static const char* fontPrologue[] = {\n\t\"/newfont 10 dict def newfont begin /FontType 3 def /FontMatrix [1\",\n\t\"0 0 1 0 0] def /FontBBox [0 0 512 1] def /Encoding 256 array def\",\n\t\"0 1 31{Encoding exch /255 put}for 120 1 255{Encoding exch /255\",\n\t\"put}for Encoding 37 /255 put Encoding 40 /255 put Encoding 41 /255\",\n\t\"put Encoding 92 /255 put /count 0 def /ls{Encoding exch count 3\",\n\t\"string cvs cvn put /count count 1 add def}def 32 1 36{ls}for\",\n\t\"38 1 39{ls}for 42 1 91{ls}for 93 1 99{ls}for /count 100\",\n\t\"def 100 1 119{ls}for /CharDict 5 dict def CharDict begin /white\",\n\t\"{dup 255 eq{pop}{1 dict begin 100 sub neg 512 exch bitshift\",\n\t\"/cw exch def cw 0 0 0 cw 1 setcachedevice end}ifelse}def /black\",\n\t\"{dup 255 eq{pop}{1 dict begin 110 sub neg 512 exch bitshift\",\n\t\"/cw exch def cw 0 0 0 cw 1 setcachedevice 0 0 moveto cw 0 rlineto\",\n\t\"0 1 rlineto cw neg 0 rlineto closepath fill end}ifelse}def /numbuild\",\n\t\"{dup 255 eq{pop}{6 0 0 0 6 1 setcachedevice 0 1 5{0 moveto\",\n\t\"dup 32 and 32 eq{1 0 rlineto 0 1 rlineto -1 0 rlineto closepath\",\n\t\"fill newpath}if 1 bitshift}for pop}ifelse}def /.notdef {}\",\n\t\"def /255 {}def end /BuildChar{exch begin dup 110 ge{Encoding\",\n\t\"exch get 3 string cvs cvi CharDict /black get}{dup 100 ge {Encoding\",\n\t\"exch get 3 string cvs cvi CharDict /white get}{Encoding exch get\",\n\t\"3 string cvs cvi CharDict /numbuild get}ifelse}ifelse exec end\",\n\t\"}def end /Bitfont newfont definefont 1 scalefont setfont\",\n\tNULL\n    };\n    int i;\n    for (i = 0; fontPrologue[i] != NULL; i++)\n\tfprintf(fd, \"%s\\n\", fontPrologue[i]);\n}",
          "fn_code_pos": [
            [
              163,
              0
            ],
            [
              193,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "emitFont",
            "parameters": {
              "fd": "FILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nprintTIF(TIFF* tif, uint16 pageNumber)\n{\n    uint32 w, h;\n    uint16 unit, compression;\n    float xres, yres, scale = 1.0;\n    tstrip_t s, ns;\n    time_t creation_time;\n\n    TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n    TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n    if (!TIFFGetField(tif, TIFFTAG_COMPRESSION, &compression)\n\t|| compression < COMPRESSION_CCITTRLE\n\t|| compression > COMPRESSION_CCITT_T6)\n\treturn;\n    if (!TIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres) || !xres) {\n\tTIFFWarning(TIFFFileName(tif),\n\t    \"No x-resolution, assuming %g dpi\", defxres);\n\txres = defxres;\n    }\n    if (!TIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres) || !yres) {\n\tTIFFWarning(TIFFFileName(tif),\n\t    \"No y-resolution, assuming %g lpi\", defyres);\n\tyres = defyres;\t\t\t\t\t/* XXX */\n    }\n    if (TIFFGetField(tif, TIFFTAG_RESOLUTIONUNIT, &unit) &&\n      unit == RESUNIT_CENTIMETER) {\n\txres *= 2.54F;\n\tyres *= 2.54F;\n    }\n    if (pageWidth == 0)\n\tpageWidth = w / xres;\n    if (pageHeight == 0)\n\tpageHeight = h / yres;\n\n    printf(\"%%!PS-Adobe-3.0\\n\");\n    printf(\"%%%%Creator: fax2ps\\n\");\n#ifdef notdef\n    printf(\"%%%%Title: %s\\n\", file);\n#endif\n    creation_time = time(0);\n    printf(\"%%%%CreationDate: %s\", ctime(&creation_time));\n    printf(\"%%%%Origin: 0 0\\n\");\n    printf(\"%%%%BoundingBox: 0 0 %u %u\\n\",\n\t(int)(pageWidth * points), (int)(pageHeight * points));\t/* XXX */\n    printf(\"%%%%Pages: (atend)\\n\");\n    printf(\"%%%%EndComments\\n\");\n    printf(\"%%%%BeginProlog\\n\");\n    emitFont(stdout);\n    printf(\"/d{bind def}def\\n\"); /* bind and def proc */\n    printf(\"/m{0 exch moveto}d\\n\");\n    printf(\"/s{show}d\\n\");\n    printf(\"/p{showpage}d \\n\");\t/* end page */\n    printf(\"%%%%EndProlog\\n\");\n    printf(\"%%%%Page: \\\"%u\\\" %u\\n\", pageNumber, pageNumber);\n    printf(\"/$pageTop save def gsave\\n\");\n    if (scaleToPage)\n        scale = pageHeight / (h/yres) < pageWidth / (w/xres) ?\n            pageHeight / (h/yres) : pageWidth / (w/xres);\n    printf(\"%g %g translate\\n\",\n           points * (pageWidth - scale*w/xres) * half,\n           points * (scale*h/yres + (pageHeight - scale*h/yres) * half));\n    printf(\"%g %g scale\\n\", points/xres*scale, -points/yres*scale);\n    printf(\"0 setgray\\n\");\n    TIFFSetField(tif, TIFFTAG_FAXFILLFUNC, printruns);\n    ns = TIFFNumberOfStrips(tif);\n    row = 0;\n    for (s = 0; s < ns; s++)\n\t(void) TIFFReadEncodedStrip(tif, s, (tdata_t) NULL, (tsize_t) -1);\n    printf(\"p\\n\");\n    printf(\"grestore $pageTop restore\\n\");\n    totalPages++;\n}",
          "fn_code_pos": [
            [
              195,
              0
            ],
            [
              267,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "printTIF",
            "parameters": {
              "tif": "TIFF",
              "pageNumber": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\nfindPage(TIFF* tif, uint16 pageNumber)\n{\n    uint16 pn = (uint16) -1;\n    uint16 ptotal = (uint16) -1;\n    if (GetPageNumber(tif)) {\n\twhile (pn != (pageNumber-1) && TIFFReadDirectory(tif) && GetPageNumber(tif))\n\t    ;\n\treturn (pn == (pageNumber-1));\n    } else\n\treturn (TIFFSetDirectory(tif, (tdir_t)(pageNumber-1)));\n}",
          "fn_code_pos": [
            [
              272,
              0
            ],
            [
              283,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "findPage",
            "parameters": {
              "tif": "TIFF",
              "pageNumber": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\nfax2ps(TIFF* tif, uint16 npages, uint16* pages, char* filename)\n{\n    if (npages > 0) {\n\tuint16 pn, ptotal;\n\tint i;\n\n\tif (!GetPageNumber(tif))\n\t    fprintf(stderr, \"%s: No page numbers, counting directories.\\n\",\n\t\tfilename);\n\tfor (i = 0; i < npages; i++) {\n\t    if (findPage(tif, pages[i]))\n\t\tprintTIF(tif, pages[i]);\n\t    else\n\t\tfprintf(stderr, \"%s: No page number %d\\n\", filename, pages[i]);\n\t}\n    } else {\n\tuint16 pageNumber = 0;\n\tdo\n\t    printTIF(tif, pageNumber++);\n\twhile (TIFFReadDirectory(tif));\n    }\n}",
          "fn_code_pos": [
            [
              285,
              0
            ],
            [
              307,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fax2ps",
            "parameters": {
              "tif": "TIFF",
              "npages": "uint16",
              "pages": "uint16",
              "filename": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\npcompar(const void* va, const void* vb)\n{\n    const int* pa = (const int*) va;\n    const int* pb = (const int*) vb;\n    return (*pa - *pb);\n}",
          "fn_code_pos": [
            [
              311,
              0
            ],
            [
              317,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pcompar",
            "parameters": {
              "va": "void",
              "vb": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char** argv)\n{\n#if !HAVE_DECL_OPTARG\n    extern int optind;\n    extern char* optarg;\n#endif\n    uint16 *pages = NULL, npages = 0, pageNumber;\n    int c, dowarnings = 0;\t\t/* if 1, enable library warnings */\n    TIFF* tif;\n\n    while ((c = getopt(argc, argv, \"l:p:x:y:W:H:wS\")) != -1)\n\tswitch (c) {\n\tcase 'H':\t\t/* page height */\n\t    pageHeight = (float)atof(optarg);\n\t    break;\n\tcase 'S':\t\t/* scale to page */\n\t    scaleToPage = 1;\n\t    break;\n\tcase 'W':\t\t/* page width */\n\t    pageWidth = (float)atof(optarg);\n\t    break;\n\tcase 'p':\t\t/* print specific page */\n\t    pageNumber = (uint16)atoi(optarg);\n\t    if (pages)\n\t\tpages = (uint16*) realloc(pages, (npages+1)*sizeof(uint16));\n\t    else\n\t\tpages = (uint16*) malloc(sizeof(uint16));\n\t    if( pages == NULL )\n\t    {\n\t\tfprintf(stderr, \"Out of memory\\n\");\n\t\texit(-1);\n\t    }\n\t    pages[npages++] = pageNumber;\n\t    break;\n\tcase 'w':\n\t    dowarnings = 1;\n\t    break;\n\tcase 'x':\n\t    defxres = (float)atof(optarg);\n\t    break;\n\tcase 'y':\n\t    defyres = (float)atof(optarg);\n\t    break;\n\tcase 'l':\n\t    maxline = atoi(optarg);\n\t    break;\n\tcase '?':\n\t    usage(-1);\n\t}\n    if (npages > 0)\n\tqsort(pages, npages, sizeof(uint16), pcompar);\n    if (!dowarnings)\n\tTIFFSetWarningHandler(0);\n    if (optind < argc) {\n\tdo {\n\t    tif = TIFFOpen(argv[optind], \"r\");\n\t    if (tif) {\n\t\tfax2ps(tif, npages, pages, argv[optind]);\n\t\tTIFFClose(tif);\n\t    } else\n\t\tfprintf(stderr, \"%s: Can not open, or not a TIFF file.\\n\",\n\t\t    argv[optind]);\n\t} while (++optind < argc);\n    } else {\n\tint n;\n\tFILE* fd;\n\tchar buf[16*1024];\n\n\tfd = tmpfile();\n\tif (fd == NULL) {\n\t    fprintf(stderr, \"Could not obtain temporary file.\\n\");\n\t    exit(-2);\n\t}\n#if defined(HAVE_SETMODE) && defined(O_BINARY)\n\tsetmode(fileno(stdin), O_BINARY);\n#endif\n\twhile ((n = read(fileno(stdin), buf, sizeof (buf))) > 0) {\n                if (write(fileno(fd), buf, n) != n) {\n                        fclose(fd);\n                        fprintf(stderr,\n                                \"Could not copy stdin to temporary file.\\n\");\n                        exit(-2);  \n                }\n        }\n\t_TIFF_lseek_f(fileno(fd), 0, SEEK_SET);\n#if defined(_WIN32) && defined(USE_WIN32_FILEIO)\n\ttif = TIFFFdOpen(_get_osfhandle(fileno(fd)), \"temp\", \"r\");\n#else\n\ttif = TIFFFdOpen(fileno(fd), \"temp\", \"r\");\n#endif\n\tif (tif) {\n\t    fax2ps(tif, npages, pages, \"<stdin>\");\n\t    TIFFClose(tif);\n\t} else\n\t    fprintf(stderr, \"Can not open, or not a TIFF file.\\n\");\n\tfclose(fd);\n    }\n    printf(\"%%%%Trailer\\n\");\n    printf(\"%%%%Pages: %u\\n\", totalPages);\n    printf(\"%%%%EOF\\n\");\n\n    return (0);\n}",
          "fn_code_pos": [
            [
              321,
              0
            ],
            [
              424,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(int code)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(code);\n}",
          "fn_code_pos": [
            [
              440,
              0
            ],
            [
              451,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {
              "code": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "usage(int code)",
          "fn_dec_pos": [
            [
              319,
              12
            ],
            [
              319,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {
              "code": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct {\n\tchar white, black;\n\tunsigned short width;\n    }",
          {
            "white": "char",
            "width": "unsigned short"
          },
          "",
          [
            72,
            11
          ],
          [
            75,
            5
          ]
        ],
        [
          "struct {\n\tchar white, black;\n\tunsigned short width;\n    }",
          {
            "white": "char",
            "width": "unsigned short"
          },
          "",
          [
            72,
            11
          ],
          [
            75,
            5
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            23,
            0
          ],
          [
            24,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <time.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "# include <fcntl.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "# include <io.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"tiffiop.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/tiffcrop.c": {
      "fn_def_list": [
        {
          "fn_code": "static int readContigTilesIntoBuffer (TIFF* in, uint8* buf, \n                                      uint32 imagelength, \n                                      uint32 imagewidth, \n                                      uint32 tw, uint32 tl,\n                                      tsample_t spp, uint16 bps)\n  {\n  int status = 1;\n  tsample_t sample = 0;\n  tsample_t count = spp; \n  uint32 row, col, trow;\n  uint32 nrow, ncol;\n  uint32 dst_rowsize, shift_width;\n  uint32 bytes_per_sample, bytes_per_pixel;\n  uint32 trailing_bits, prev_trailing_bits;\n  uint32 tile_rowsize  = TIFFTileRowSize(in);\n  uint32 src_offset, dst_offset;\n  uint32 row_offset, col_offset;\n  uint8 *bufp = (uint8*) buf;\n  unsigned char *src = NULL;\n  unsigned char *dst = NULL;\n  tsize_t tbytes = 0, tile_buffsize = 0;\n  tsize_t tilesize = TIFFTileSize(in);\n  unsigned char *tilebuf = NULL;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n\n  if ((bps % 8) == 0)\n    shift_width = 0;\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n\n  tile_buffsize = tilesize;\n  if (tilesize == 0 || tile_rowsize == 0)\n  {\n     TIFFError(\"readContigTilesIntoBuffer\", \"Tile size or tile rowsize is zero\");\n     exit(-1);\n  }\n\n  if (tilesize < (tsize_t)(tl * tile_rowsize))\n    {\n#ifdef DEBUG2\n    TIFFError(\"readContigTilesIntoBuffer\",\n\t      \"Tilesize %lu is too small, using alternate calculation %u\",\n              tilesize, tl * tile_rowsize);\n#endif\n    tile_buffsize = tl * tile_rowsize;\n    if (tl != (tile_buffsize / tile_rowsize))\n    {\n    \tTIFFError(\"readContigTilesIntoBuffer\", \"Integer overflow when calculating buffer size.\");\n        exit(-1);\n    }\n    }\n\n  /* Add 3 padding bytes for extractContigSamplesShifted32bits */\n  if( (size_t) tile_buffsize > 0xFFFFFFFFU - 3U )\n  {\n      TIFFError(\"readContigTilesIntoBuffer\", \"Integer overflow when calculating buffer size.\");\n      exit(-1);\n  }\n  tilebuf = _TIFFmalloc(tile_buffsize + 3);\n  if (tilebuf == 0)\n    return 0;\n  tilebuf[tile_buffsize] = 0;\n  tilebuf[tile_buffsize+1] = 0;\n  tilebuf[tile_buffsize+2] = 0;\n\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;  \n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      tbytes = TIFFReadTile(in, tilebuf, col, row, 0, 0);\n      if (tbytes < tilesize  && !ignore)\n        {\n\tTIFFError(TIFFFileName(in),\n\t\t  \"Error, can't read tile at row %lu col %lu, Read %lu bytes of %lu\",\n\t\t  (unsigned long) col, (unsigned long) row, (unsigned long)tbytes,\n                  (unsigned long)tilesize);\n\t\t  status = 0;\n                  _TIFFfree(tilebuf);\n\t\t  return status;\n\t}\n      \n      row_offset = row * dst_rowsize;\n      col_offset = ((col * bps * spp) + 7)/ 8;\n      bufp = buf + row_offset + col_offset;\n\n      if (col + tw > imagewidth)\n\tncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      /* Each tile scanline will start on a byte boundary but it\n       * has to be merged into the scanline for the entire\n       * image buffer and the previous segment may not have\n       * ended on a byte boundary\n       */\n      /* Optimization for common bit depths, all samples */\n      if (((bps % 8) == 0) && (count == spp))\n        {\n\tfor (trow = 0; trow < nrow; trow++)\n          {\n\t  src_offset = trow * tile_rowsize;\n\t  _TIFFmemcpy (bufp, tilebuf + src_offset, (ncol * spp * bps) / 8);\n          bufp += (imagewidth * bps * spp) / 8;\n\t  }\n        }\n      else\n        {\n\t/* Bit depths not a multiple of 8 and/or extract fewer than spp samples */\n        prev_trailing_bits = trailing_bits = 0;\n        trailing_bits = (ncol * bps * spp) % 8;\n\n\t/*\tfor (trow = 0; tl < nrow; trow++) */\n\tfor (trow = 0; trow < nrow; trow++)\n          {\n\t  src_offset = trow * tile_rowsize;\n          src = tilebuf + src_offset;\n\t  dst_offset = (row + trow) * dst_rowsize;\n          dst = buf + dst_offset + col_offset;\n          switch (shift_width)\n            {\n            case 0: if (extractContigSamplesBytes (src, dst, ncol, sample,\n                                                   spp, bps, count, 0, ncol))\n                      {\n\t\t      TIFFError(\"readContigTilesIntoBuffer\",\n                                \"Unable to extract row %d from tile %lu\", \n\t\t\t\trow, (unsigned long)TIFFCurrentTile(in));\n\t\t      return 1;\n\t\t      }\n\t\t    break;\n            case 1: if (bps == 1)\n                      { \n                      if (extractContigSamplesShifted8bits (src, dst, ncol,\n                                                            sample, spp,\n                                                            bps, count,\n                                                            0, ncol,\n                                                            prev_trailing_bits))\n                        {\n\t\t        TIFFError(\"readContigTilesIntoBuffer\",\n                                  \"Unable to extract row %d from tile %lu\", \n\t\t\t\t  row, (unsigned long)TIFFCurrentTile(in));\n\t\t        return 1;\n\t\t        }\n\t\t      break;\n\t\t      }\n                    else\n                      if (extractContigSamplesShifted16bits (src, dst, ncol,\n                                                             sample, spp,\n                                                             bps, count,\n                                                             0, ncol,\n                                                             prev_trailing_bits))\n                        {\n\t\t        TIFFError(\"readContigTilesIntoBuffer\",\n                                  \"Unable to extract row %d from tile %lu\", \n\t\t\t  \t  row, (unsigned long)TIFFCurrentTile(in));\n\t\t        return 1;\n\t\t        }\n\t            break;\n            case 2: if (extractContigSamplesShifted24bits (src, dst, ncol,\n                                                           sample, spp,\n                                                           bps, count,\n                                                           0, ncol,\n                                                           prev_trailing_bits))\n                      {\n\t\t      TIFFError(\"readContigTilesIntoBuffer\",\n                                \"Unable to extract row %d from tile %lu\", \n\t\t  \t        row, (unsigned long)TIFFCurrentTile(in));\n\t\t      return 1;\n\t\t      }\n\t\t    break;\n            case 3:\n            case 4:\n            case 5: if (extractContigSamplesShifted32bits (src, dst, ncol,\n                                                           sample, spp,\n                                                           bps, count,\n                                                           0, ncol,\n                                                           prev_trailing_bits))\n                      {\n\t\t      TIFFError(\"readContigTilesIntoBuffer\",\n                                \"Unable to extract row %d from tile %lu\", \n\t\t\t        row, (unsigned long)TIFFCurrentTile(in));\n\t\t      return 1;\n\t\t      }\n\t\t    break;\n            default: TIFFError(\"readContigTilesIntoBuffer\", \"Unsupported bit depth %d\", bps);\n\t\t     return 1;\n\t    }\n          }\n        prev_trailing_bits += trailing_bits;\n        /* if (prev_trailing_bits > 7) */\n\t/*   prev_trailing_bits-= 8; */\n\t}\n      }\n    }\n\n  _TIFFfree(tilebuf);\n  return status;\n  }",
          "fn_code_pos": [
            [
              759,
              0
            ],
            [
              964,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readContigTilesIntoBuffer",
            "parameters": {
              "in": "TIFF",
              "buf": "uint8",
              "imagelength": "uint32",
              "imagewidth": "uint32",
              "tw": "uint32",
              "tl": "uint32",
              "spp": "tsample_t",
              "bps": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf, \n\t\t\t\t\t uint32 imagelength, uint32 imagewidth, \n                                         uint32 tw, uint32 tl,\n                                         uint16 spp, uint16 bps)\n  {\n  int     i, status = 1, sample;\n  int     shift_width, bytes_per_pixel;\n  uint16  bytes_per_sample;\n  uint32  row, col;     /* Current row and col of image */\n  uint32  nrow, ncol;   /* Number of rows and cols in current tile */\n  uint32  row_offset, col_offset; /* Output buffer offsets */\n  tsize_t tbytes = 0, tilesize = TIFFTileSize(in);\n  tsample_t s;\n  uint8*  bufp = (uint8*)obuf;\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *tbuff = NULL;\n\n  bytes_per_sample = (bps + 7) / 8;\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    srcbuffs[sample] = NULL;\n    tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);\n    if (!tbuff)\n      {\n      TIFFError (\"readSeparateTilesIntoBuffer\", \n                 \"Unable to allocate tile read buffer for sample %d\", sample);\n      for (i = 0; i < sample; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    srcbuffs[sample] = tbuff;\n    } \n  /* Each tile contains only the data for a single plane\n   * arranged in scanlines of tw * bytes_per_sample bytes.\n   */\n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      for (s = 0; s < spp && s < MAX_SAMPLES; s++)\n        {  /* Read each plane of a tile set into srcbuffs[s] */\n\ttbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);\n        if (tbytes < 0  && !ignore)\n          {\n\t  TIFFError(TIFFFileName(in),\n                 \"Error, can't read tile for row %lu col %lu, \"\n\t\t \"sample %lu\",\n\t\t (unsigned long) col, (unsigned long) row,\n\t\t (unsigned long) s);\n\t\t status = 0;\n          for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n            {\n            tbuff = srcbuffs[sample];\n            if (tbuff != NULL)\n              _TIFFfree(tbuff);\n            }\n          return status;\n\t  }\n\t}\n     /* Tiles on the right edge may be padded out to tw \n      * which must be a multiple of 16.\n      * Ncol represents the visible (non padding) portion.  \n      */\n      if (col + tw > imagewidth)\n        ncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      row_offset = row * (((imagewidth * spp * bps) + 7) / 8);\n      col_offset = ((col * spp * bps) + 7) / 8;\n      bufp = obuf + row_offset + col_offset;\n\n      if ((bps % 8) == 0)\n        {\n        if (combineSeparateTileSamplesBytes(srcbuffs, bufp, ncol, nrow, imagewidth,\n\t\t\t\t\t    tw, spp, bps, NULL, 0, 0))\n\t  {\n          status = 0;\n          break;\n      \t  }\n\t}\n      else\n        {\n        bytes_per_pixel  = ((bps * spp) + 7) / 8;\n        if (bytes_per_pixel < (bytes_per_sample + 1))\n          shift_width = bytes_per_pixel;\n        else\n          shift_width = bytes_per_sample + 1;\n\n        switch (shift_width)\n          {\n          case 1: if (combineSeparateTileSamples8bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n      \t            }\n\t          break;\n          case 2: if (combineSeparateTileSamples16bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n\t\t    }\n\t          break;\n          case 3: if (combineSeparateTileSamples24bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n       \t            }\n                  break;\n          case 4: \n          case 5:\n          case 6:\n          case 7:\n          case 8: if (combineSeparateTileSamples32bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps, \n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n\t\t    }\n\t          break;\n          default: TIFFError (\"readSeparateTilesIntoBuffer\", \"Unsupported bit depth: %d\", bps);\n                  status = 0;\n                  break;\n          }\n        }\n      }\n    }\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    tbuff = srcbuffs[sample];\n    if (tbuff != NULL)\n      _TIFFfree(tbuff);\n    }\n \n  return status;\n  }",
          "fn_code_pos": [
            [
              966,
              0
            ],
            [
              1111,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readSeparateTilesIntoBuffer",
            "parameters": {
              "in": "TIFF",
              "obuf": "uint8",
              "imagelength": "uint32",
              "imagewidth": "uint32",
              "tw": "uint32",
              "tl": "uint32",
              "spp": "uint16",
              "bps": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength)\n  {\n  uint32 row, nrows, rowsperstrip;\n  tstrip_t strip = 0;\n  tsize_t stripsize;\n\n  TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n  for (row = 0; row < imagelength; row += rowsperstrip)\n    {\n    nrows = (row + rowsperstrip > imagelength) ?\n\t     imagelength - row : rowsperstrip;\n    stripsize = TIFFVStripSize(out, nrows);\n    if (TIFFWriteEncodedStrip(out, strip++, buf, stripsize) < 0)\n      {\n      TIFFError(TIFFFileName(out), \"Error, can't write strip %u\", strip - 1);\n      return 1;\n      }\n    buf += stripsize;\n    }\n\n  return 0;\n  }",
          "fn_code_pos": [
            [
              1113,
              0
            ],
            [
              1134,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "writeBufferToContigStrips",
            "parameters": {
              "out": "TIFF",
              "buf": "uint8",
              "imagelength": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int \nwriteBufferToSeparateStrips (TIFF* out, uint8* buf, \n\t\t\t     uint32 length, uint32 width, uint16 spp,\n\t\t\t     struct dump_opts *dump)\n  {\n  uint8   *src;\n  uint16   bps;\n  uint32   row, nrows, rowsize, rowsperstrip;\n  uint32   bytes_per_sample;\n  tsample_t s;\n  tstrip_t strip = 0;\n  tsize_t  stripsize = TIFFStripSize(out);\n  tsize_t  rowstripsize,  scanlinesize = TIFFScanlineSize(out);\n  tsize_t  total_bytes = 0;\n  tdata_t  obuf;\n\n  (void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n  (void) TIFFGetFieldDefaulted(out, TIFFTAG_BITSPERSAMPLE, &bps);\n  bytes_per_sample = (bps + 7) / 8;\n  if( width == 0 ||\n      (uint32)bps * (uint32)spp > TIFF_UINT32_MAX / width ||\n      bps * spp * width > TIFF_UINT32_MAX - 7U )\n  {\n      TIFFError(TIFFFileName(out),\n            \"Error, uint32 overflow when computing (bps * spp * width) + 7\");\n      return 1;\n  }\n  rowsize = ((bps * spp * width) + 7U) / 8; /* source has interleaved samples */\n  if( bytes_per_sample == 0 ||\n      rowsperstrip > TIFF_UINT32_MAX / bytes_per_sample ||\n      rowsperstrip * bytes_per_sample > TIFF_UINT32_MAX / (width + 1) )\n  {\n      TIFFError(TIFFFileName(out),\n                \"Error, uint32 overflow when computing rowsperstrip * \"\n                \"bytes_per_sample * (width + 1)\");\n      return 1;\n  }\n  rowstripsize = rowsperstrip * bytes_per_sample * (width + 1); \n\n  obuf = _TIFFmalloc (rowstripsize);\n  if (obuf == NULL)\n    return 1;\n  \n  for (s = 0; s < spp; s++)\n    {\n    for (row = 0; row < length; row += rowsperstrip)\n      {\n      nrows = (row + rowsperstrip > length) ? length - row : rowsperstrip;\n\n      stripsize = TIFFVStripSize(out, nrows);\n      src = buf + (row * rowsize);\n      total_bytes += stripsize;\n      memset (obuf, '\\0', rowstripsize);\n      if (extractContigSamplesToBuffer(obuf, src, nrows, width, s, spp, bps, dump))\n        {\n        _TIFFfree(obuf);\n        return 1;\n\t}\n      if ((dump->outfile != NULL) && (dump->level == 1))\n        {\n        dump_info(dump->outfile, dump->format,\"\", \n                  \"Sample %2d, Strip: %2d, bytes: %4d, Row %4d, bytes: %4d, Input offset: %6d\", \n                  s + 1, strip + 1, stripsize, row + 1, scanlinesize, src - buf);\n        dump_buffer(dump->outfile, dump->format, nrows, scanlinesize, row, obuf);\n\t}\n\n      if (TIFFWriteEncodedStrip(out, strip++, obuf, stripsize) < 0)\n        {\n\tTIFFError(TIFFFileName(out), \"Error, can't write strip %u\", strip - 1);\n\t_TIFFfree(obuf);\n\treturn 1;\n\t}\n      }\n    }      \n\n  _TIFFfree(obuf);\n  return 0;\n}",
          "fn_code_pos": [
            [
              1144,
              0
            ],
            [
              1221,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "writeBufferToSeparateStrips",
            "parameters": {
              "out": "TIFF",
              "buf": "uint8",
              "length": "uint32",
              "width": "uint32",
              "spp": "uint16",
              "dump": "struct dump_opts"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,\n\t\t\t\t       uint32 imagewidth, tsample_t spp, \n                                       struct dump_opts* dump)\n  {\n  uint16 bps;\n  uint32 tl, tw;\n  uint32 row, col, nrow, ncol;\n  uint32 src_rowsize, col_offset;\n  uint32 tile_rowsize  = TIFFTileRowSize(out);\n  uint8* bufp = (uint8*) buf;\n  tsize_t tile_buffsize = 0;\n  tsize_t tilesize = TIFFTileSize(out);\n  unsigned char *tilebuf = NULL;\n\n  if( !TIFFGetField(out, TIFFTAG_TILELENGTH, &tl) ||\n      !TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw) ||\n      !TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps) )\n      return 1;\n\n  if (tilesize == 0 || tile_rowsize == 0 || tl == 0 || tw == 0)\n  {\n    TIFFError(\"writeBufferToContigTiles\", \"Tile size, tile row size, tile width, or tile length is zero\");\n    exit(-1);\n  }\n  \n  tile_buffsize = tilesize;\n  if (tilesize < (tsize_t)(tl * tile_rowsize))\n    {\n#ifdef DEBUG2\n    TIFFError(\"writeBufferToContigTiles\",\n\t      \"Tilesize %lu is too small, using alternate calculation %u\",\n              tilesize, tl * tile_rowsize);\n#endif\n    tile_buffsize = tl * tile_rowsize;\n    if (tl != tile_buffsize / tile_rowsize)\n    {\n\tTIFFError(\"writeBufferToContigTiles\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n    }\n\n  if( imagewidth == 0 ||\n      (uint32)bps * (uint32)spp > TIFF_UINT32_MAX / imagewidth ||\n      bps * spp * imagewidth > TIFF_UINT32_MAX - 7U )\n  {\n      TIFFError(TIFFFileName(out),\n            \"Error, uint32 overflow when computing (imagewidth * bps * spp) + 7\");\n      return 1;\n  }\n  src_rowsize = ((imagewidth * spp * bps) + 7U) / 8;\n\n  tilebuf = _TIFFmalloc(tile_buffsize);\n  if (tilebuf == 0)\n    return 1;\n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      /* Calculate visible portion of tile. */\n      if (col + tw > imagewidth)\n\tncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      col_offset = (((col * bps * spp) + 7) / 8);\n      bufp = buf + (row * src_rowsize) + col_offset;\n      if (extractContigSamplesToTileBuffer(tilebuf, bufp, nrow, ncol, imagewidth,\n\t\t\t\t\t   tw, 0, spp, spp, bps, dump) > 0)\n        {\n\tTIFFError(\"writeBufferToContigTiles\", \n                  \"Unable to extract data to tile for row %lu, col %lu\",\n                  (unsigned long) row, (unsigned long)col);\n\t_TIFFfree(tilebuf);\n\treturn 1;\n        }\n\n      if (TIFFWriteTile(out, tilebuf, col, row, 0, 0) < 0)\n        {\n\tTIFFError(\"writeBufferToContigTiles\",\n\t          \"Cannot write tile at %lu %lu\",\n\t          (unsigned long) col, (unsigned long) row);\n\t _TIFFfree(tilebuf);\n\treturn 1;\n\t}\n      }\n    }\n  _TIFFfree(tilebuf);\n\n  return 0;\n  }",
          "fn_code_pos": [
            [
              1226,
              0
            ],
            [
              1316,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "writeBufferToContigTiles",
            "parameters": {
              "out": "TIFF",
              "buf": "uint8",
              "imagelength": "uint32",
              "imagewidth": "uint32",
              "spp": "tsample_t",
              "dump": "struct dump_opts"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int writeBufferToSeparateTiles (TIFF* out, uint8* buf, uint32 imagelength,\n\t\t\t\t       uint32 imagewidth, tsample_t spp, \n                                       struct dump_opts * dump)\n  {\n  tdata_t obuf = _TIFFmalloc(TIFFTileSize(out));\n  uint32 tl, tw;\n  uint32 row, col, nrow, ncol;\n  uint32 src_rowsize, col_offset;\n  uint16 bps;\n  tsample_t s;\n  uint8* bufp = (uint8*) buf;\n\n  if (obuf == NULL)\n    return 1;\n\n  TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n  TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n  TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);\n\n  if( imagewidth == 0 ||\n      (uint32)bps * (uint32)spp > TIFF_UINT32_MAX / imagewidth ||\n      bps * spp * imagewidth > TIFF_UINT32_MAX - 7 )\n  {\n      TIFFError(TIFFFileName(out),\n            \"Error, uint32 overflow when computing (imagewidth * bps * spp) + 7\");\n      _TIFFfree(obuf);\n      return 1;\n  }\n  src_rowsize = ((imagewidth * spp * bps) + 7U) / 8;\n         \n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      /* Calculate visible portion of tile. */\n      if (col + tw > imagewidth)\n\tncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      col_offset = (((col * bps * spp) + 7) / 8);\n      bufp = buf + (row * src_rowsize) + col_offset;\n\n      for (s = 0; s < spp; s++)\n        {\n\tif (extractContigSamplesToTileBuffer(obuf, bufp, nrow, ncol, imagewidth,\n\t\t\t\t\t     tw, s, 1, spp, bps, dump) > 0)\n          {\n\t  TIFFError(\"writeBufferToSeparateTiles\", \n                    \"Unable to extract data to tile for row %lu, col %lu sample %d\",\n                    (unsigned long) row, (unsigned long)col, (int)s);\n\t  _TIFFfree(obuf);\n\t  return 1;\n          }\n\n\tif (TIFFWriteTile(out, obuf, col, row, 0, s) < 0)\n          {\n\t   TIFFError(\"writeBufferToseparateTiles\",\n\t             \"Cannot write tile at %lu %lu sample %lu\",\n\t             (unsigned long) col, (unsigned long) row,\n\t             (unsigned long) s);\n\t   _TIFFfree(obuf);\n\t   return 1;\n\t  }\n\t}\n      }\n    }\n  _TIFFfree(obuf);\n\n  return 0;\n  }",
          "fn_code_pos": [
            [
              1321,
              0
            ],
            [
              1392,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "writeBufferToSeparateTiles",
            "parameters": {
              "out": "TIFF",
              "buf": "uint8",
              "imagelength": "uint32",
              "imagewidth": "uint32",
              "spp": "tsample_t",
              "dump": "struct dump_opts"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nprocessG3Options(char* cp)\n{\n\tif( (cp = strchr(cp, ':')) ) {\n\t\tif (defg3opts == (uint32) -1)\n\t\t\tdefg3opts = 0;\n\t\tdo {\n\t\t\tcp++;\n\t\t\tif (strneq(cp, \"1d\", 2))\n\t\t\t\tdefg3opts &= ~GROUP3OPT_2DENCODING;\n\t\t\telse if (strneq(cp, \"2d\", 2))\n\t\t\t\tdefg3opts |= GROUP3OPT_2DENCODING;\n\t\t\telse if (strneq(cp, \"fill\", 4))\n\t\t\t\tdefg3opts |= GROUP3OPT_FILLBITS;\n\t\t\telse\n\t\t\t\tusage();\n\t\t} while( (cp = strchr(cp, ':')) );\n\t}\n}",
          "fn_code_pos": [
            [
              1394,
              0
            ],
            [
              1412,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processG3Options",
            "parameters": {
              "cp": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nprocessCompressOptions(char* opt)\n  {\n  char* cp = NULL;\n\n  if (strneq(opt, \"none\",4))\n    {\n    defcompression = COMPRESSION_NONE;\n    }\n  else if (streq(opt, \"packbits\"))\n    {\n    defcompression = COMPRESSION_PACKBITS;\n    }\n  else if (strneq(opt, \"jpeg\", 4))\n    {\n    cp = strchr(opt, ':');\n    defcompression = COMPRESSION_JPEG;\n\n    while (cp)\n      {\n      if (isdigit((int)cp[1]))\n\tquality = atoi(cp + 1);\n      else if (strneq(cp + 1, \"raw\", 3 ))\n\tjpegcolormode = JPEGCOLORMODE_RAW;\n      else if (strneq(cp + 1, \"rgb\", 3 ))\n\tjpegcolormode = JPEGCOLORMODE_RGB;\n      else\n\tusage();\n      cp = strchr(cp + 1, ':');\n      }\n    }\n  else if (strneq(opt, \"g3\", 2))\n    {\n    processG3Options(opt);\n    defcompression = COMPRESSION_CCITTFAX3;\n    }\n  else if (streq(opt, \"g4\"))\n    {\n    defcompression = COMPRESSION_CCITTFAX4;\n    }\n  else if (strneq(opt, \"lzw\", 3))\n    {\n    cp = strchr(opt, ':');\n    if (cp)\n      defpredictor = atoi(cp+1);\n    defcompression = COMPRESSION_LZW;\n    }\n  else if (strneq(opt, \"zip\", 3))\n    {\n    cp = strchr(opt, ':');\n    if (cp)\n      defpredictor = atoi(cp+1);\n    defcompression = COMPRESSION_ADOBE_DEFLATE;\n   }\n  else\n    return (0);\n\n  return (1);\n  }",
          "fn_code_pos": [
            [
              1414,
              0
            ],
            [
              1472,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {
              "opt": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n  {\n  int i;\n\n  fprintf(stderr, \"\\n%s\\n\", TIFFGetVersion());\n  for (i = 0; usage_info[i] != NULL; i++)\n    fprintf(stderr, \"%s\\n\", usage_info[i]);\n  exit(-1);\n  }",
          "fn_code_pos": [
            [
              1474,
              0
            ],
            [
              1483,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ncpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type)\n{\n\tswitch (type) {\n\tcase TIFF_SHORT:\n\t\tif (count == 1) {\n\t\t\tuint16 shortv;\n\t\t\tCopyField(tag, shortv);\n\t\t} else if (count == 2) {\n\t\t\tuint16 shortv1, shortv2;\n\t\t\tCopyField2(tag, shortv1, shortv2);\n\t\t} else if (count == 4) {\n\t\t\tuint16 *tr, *tg, *tb, *ta;\n\t\t\tCopyField4(tag, tr, tg, tb, ta);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tuint16 shortv1;\n\t\t\tuint16* shortav;\n\t\t\tCopyField2(tag, shortv1, shortav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_LONG:\n\t\t{ uint32 longv;\n\t\t  CopyField(tag, longv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_RATIONAL:\n\t\tif (count == 1) {\n\t\t\tfloat floatv;\n\t\t\tCopyField(tag, floatv);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tfloat* floatav;\n\t\t\tCopyField(tag, floatav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_ASCII:\n\t\t{ char* stringv;\n\t\t  CopyField(tag, stringv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_DOUBLE:\n\t\tif (count == 1) {\n\t\t\tdouble doublev;\n\t\t\tCopyField(tag, doublev);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tdouble* doubleav;\n\t\t\tCopyField(tag, doubleav);\n\t\t}\n\t\tbreak;\n          default:\n                TIFFError(TIFFFileName(in),\n                          \"Data type %d is not supported, tag %d skipped\",\n                          tag, type);\n\t}\n}",
          "fn_code_pos": [
            [
              1494,
              0
            ],
            [
              1547,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpTag",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF",
              "tag": "uint16",
              "count": "uint16",
              "type": "TIFFDataType"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32 *dirnum,\n\t                    uint16 *defconfig, uint16 *deffillorder, uint32 *deftilewidth,\n                            uint32 *deftilelength, uint32 *defrowsperstrip,\n\t\t            struct crop_mask *crop_data, struct pagedef *page, \n                            struct dump_opts *dump,\n                            unsigned int     *imagelist, unsigned int   *image_count )\n    {\n    int   c, good_args = 0;\n    char *opt_offset   = NULL;    /* Position in string of value sought */\n    char *opt_ptr      = NULL;    /* Pointer to next token in option set */\n    char *sep          = NULL;    /* Pointer to a token separator */\n    unsigned int  i, j, start, end;\n#if !HAVE_DECL_OPTARG\n    extern int   optind;\n    extern char* optarg;\n#endif\n\n    *mp++ = 'w';\n    *mp = '\\0';\n    while ((c = getopt(argc, argv,\n       \"ac:d:e:f:hil:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:\")) != -1)\n      {\n    good_args++;\n    switch (c) {\n      case 'a': mode[0] = 'a';\t/* append to output */\n\t\tbreak;\n      case 'c':\tif (!processCompressOptions(optarg)) /* compression scheme */\n\t\t  {\n\t\t  TIFFError (\"Unknown compression option\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);\n                  }\n\t\tbreak;\n      case 'd':\tstart = strtoul(optarg, NULL, 0); /* initial IFD offset */\n\t        if (start == 0)\n                  {\n\t\t  TIFFError (\"\",\"Directory offset must be greater than zero\");\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);\n\t\t  }\n\t        *dirnum = start - 1;\n\t\tbreak;\n      case 'e': switch (tolower((int) optarg[0])) /* image export modes*/\n                  {\n\t\t  case 'c': crop_data->exp_mode = ONE_FILE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Composite */\n\t\t  case 'd': crop_data->exp_mode = ONE_FILE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Divided */\n\t\t  case 'i': crop_data->exp_mode = FILE_PER_IMAGE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Image */\n\t\t  case 'm': crop_data->exp_mode = FILE_PER_IMAGE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Multiple */\n\t\t  case 's': crop_data->exp_mode = FILE_PER_SELECTION;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Sections */\n\t\t  default:  TIFFError (\"Unknown export mode\",\"%s\", optarg);\n                            TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (-1);\n                  }\n\t        break;\n      case 'f':\tif (streq(optarg, \"lsb2msb\"))\t   /* fill order */\n\t\t  *deffillorder = FILLORDER_LSB2MSB;\n\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t  *deffillorder = FILLORDER_MSB2LSB;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown fill order\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);\n                  }\n\t\tbreak;\n      case 'h':\tusage();\n\t\tbreak;\n      case 'i':\tignore = TRUE;\t\t/* ignore errors */\n\t\tbreak;\n      case 'l':\touttiled = TRUE;\t /* tile length */\n\t\t*deftilelength = atoi(optarg);\n\t\tbreak;\n      case 'p': /* planar configuration */\n\t\tif (streq(optarg, \"separate\"))\n\t\t  *defconfig = PLANARCONFIG_SEPARATE;\n\t\telse if (streq(optarg, \"contig\"))\n\t\t  *defconfig = PLANARCONFIG_CONTIG;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown planar configuration\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);\n                  }\n\t\tbreak;\n      case 'r':\t/* rows/strip */\n\t\t*defrowsperstrip = atol(optarg);\n\t\tbreak;\n      case 's':\t/* generate stripped output */\n\t\touttiled = FALSE;\n\t\tbreak;\n      case 't':\t/* generate tiled output */\n\t\touttiled = TRUE;\n\t\tbreak;\n      case 'v': TIFFError(\"Library Release\", \"%s\", TIFFGetVersion());\n                TIFFError (\"Tiffcrop version\", \"%s, last updated: %s\", \n\t\t\t   tiffcrop_version_id, tiffcrop_rev_date);\n \t        TIFFError (\"Tiffcp code\", \"Copyright (c) 1988-1997 Sam Leffler\");\n\t\tTIFFError (\"           \", \"Copyright (c) 1991-1997 Silicon Graphics, Inc\");\n                TIFFError (\"Tiffcrop additions\", \"Copyright (c) 2007-2010 Richard Nolde\");\n\t        exit (0);\n\t\tbreak;\n      case 'w':\t/* tile width */\n\t\touttiled = TRUE;\n\t\t*deftilewidth = atoi(optarg);\n\t\tbreak;\n      case 'z': /* regions of an image specified as x1,y1,x2,y2:x3,y3,x4,y4 etc */\n\t        crop_data->crop_mode |= CROP_REGIONS;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \":\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \":\")), i++)\n                    {\n\t\t    crop_data->regions++;\n                    if (sscanf(opt_ptr, \"%lf,%lf,%lf,%lf\",\n\t\t\t       &crop_data->corners[i].X1, &crop_data->corners[i].Y1,\n\t\t\t       &crop_data->corners[i].X2, &crop_data->corners[i].Y2) != 4)\n                      {\n                      TIFFError (\"Unable to parse coordinates for region\", \"%d %s\", i, optarg);\n\t\t      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (-1);\n\t\t      }\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError (\"Region list exceeds limit of\", \"%d regions %s\", MAX_REGIONS, optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);;\n                  }\n\t\tbreak;\n      /* options for file open modes */\n      case 'B': *mp++ = 'b'; *mp = '\\0';\n\t\tbreak;\n      case 'L': *mp++ = 'l'; *mp = '\\0';\n\t\tbreak;\n      case 'M': *mp++ = 'm'; *mp = '\\0';\n\t\tbreak;\n      case 'C': *mp++ = 'c'; *mp = '\\0';\n\t\tbreak;\n      /* options for Debugging / data dump */\n      case 'D': for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    (opt_ptr != NULL);\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    opt_offset = strpbrk(opt_ptr, \":=\");\n                    if (opt_offset == NULL)\n                      {\n                      TIFFError(\"Invalid dump option\", \"%s\", optarg);\n                      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (-1);\n\t\t      }\n                      \n                    *opt_offset = '\\0';\n                    /* convert option to lowercase */\n                    end = strlen (opt_ptr);\n                    for (i = 0; i < end; i++)\n                      *(opt_ptr + i) = tolower((int) *(opt_ptr + i));\n                    /* Look for dump format specification */\n                    if (strncmp(opt_ptr, \"for\", 3) == 0)\n                      {\n\t\t      /* convert value to lowercase */\n                      end = strlen (opt_offset + 1);\n                      for (i = 1; i <= end; i++)\n                        *(opt_offset + i) = tolower((int) *(opt_offset + i));\n                      /* check dump format value */\n\t\t      if (strncmp (opt_offset + 1, \"txt\", 3) == 0)\n                        {\n                        dump->format = DUMP_TEXT;\n                        strcpy (dump->mode, \"w\");\n                        }\n                      else\n                        {\n\t\t        if (strncmp(opt_offset + 1, \"raw\", 3) == 0)\n                          {\n                          dump->format = DUMP_RAW;\n                          strcpy (dump->mode, \"wb\");\n                          }\n                        else\n                          {\n                          TIFFError(\"parse_command_opts\", \"Unknown dump format %s\", opt_offset + 1);\n                          TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                          exit (-1);\n\t\t          }\n\t\t\t}\n                      }\n\t\t    else\n                      { /* Look for dump level specification */\n                      if (strncmp (opt_ptr, \"lev\", 3) == 0)\n                        dump->level = atoi(opt_offset + 1);\n                        /* Look for input data dump file name */\n                      if (strncmp (opt_ptr, \"in\", 2) == 0)\n\t\t        {\n                        strncpy (dump->infilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->infilename[PATH_MAX - 20] = '\\0';\n                        }\n                        /* Look for output data dump file name */\n                      if (strncmp (opt_ptr, \"out\", 3) == 0)\n\t\t\t{\n                        strncpy (dump->outfilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->outfilename[PATH_MAX - 20] = '\\0';\n                        }\n                      if (strncmp (opt_ptr, \"deb\", 3) == 0)\n\t\t\tdump->debug = atoi(opt_offset + 1);\n\t\t      }\n                    }\n\t        if ((strlen(dump->infilename)) || (strlen(dump->outfilename)))\n                  {\n\t\t  if (dump->level == 1)\n                    TIFFError(\"\",\"Defaulting to dump level 1, no data.\");\n\t          if (dump->format == DUMP_NONE)\n                    {\n\t\t    TIFFError(\"\", \"You must specify a dump format for dump files\");\n\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n\t\t    exit (-1);\n\t\t    }\n                  }\n\t        break;\n\n      /* image manipulation routine options */\n      case 'm': /* margins to exclude from selection, uppercase M was already used */\n\t\t/* order of values must be TOP, LEFT, BOTTOM, RIGHT */\n\t\tcrop_data->crop_mode |= CROP_MARGINS;\n                for (i = 0, opt_ptr = strtok (optarg, \",:\");\n                    ((opt_ptr != NULL) &&  (i < 4));\n                     (opt_ptr = strtok (NULL, \",:\")), i++)\n                    {\n\t\t    crop_data->margins[i] = atof(opt_ptr);\n                    }\n\t\tbreak;\n      case 'E':\t/* edge reference */\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case 't': crop_data->edge_ref = EDGE_TOP;\n                            break;\n                  case 'b': crop_data->edge_ref = EDGE_BOTTOM;\n                             break;\n                  case 'l': crop_data->edge_ref = EDGE_LEFT;\n                            break;\n                  case 'r': crop_data->edge_ref = EDGE_RIGHT;\n                            break;\n\t\t  default:  TIFFError (\"Edge reference must be top, bottom, left, or right\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (-1);\n\t\t  }\n\t\tbreak;\n      case 'F': /* flip eg mirror image or cropped segment, M was already used */\n\t\tcrop_data->crop_mode |= CROP_MIRROR;\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'h': crop_data->mirror = MIRROR_HORIZ;\n                             break;\n                  case  'v': crop_data->mirror = MIRROR_VERT;\n                             break;\n                  case  'b': crop_data->mirror = MIRROR_BOTH;\n                             break;\n\t\t  default:   TIFFError (\"Flip mode must be horiz, vert, or both\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (-1);\n\t\t  }\n\t\tbreak;\n      case 'H': /* set horizontal resolution to new value */\n\t\tpage->hres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'I': /* invert the color space, eg black to white */\n\t\tcrop_data->crop_mode |= CROP_INVERT;\n                /* The PHOTOMETIC_INTERPRETATION tag may be updated */\n                if (streq(optarg, \"black\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISBLACK;\n\t\t  continue;\n                  }\n                if (streq(optarg, \"white\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISWHITE;\n                  continue;\n                  }\n                if (streq(optarg, \"data\")) \n                  {\n\t\t  crop_data->photometric = INVERT_DATA_ONLY;\n                  continue;\n                  }\n                if (streq(optarg, \"both\"))\n                  {\n\t\t  crop_data->photometric = INVERT_DATA_AND_TAG;\n                  continue;\n                  }\n\n\t\tTIFFError(\"Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION\", \"%s\", optarg);\n\t\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (-1);\n\t\tbreak;\n      case 'J': /* horizontal margin for sectioned ouput pages */ \n\t\tpage->hmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'K': /* vertical margin for sectioned ouput pages*/ \n                page->vmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'N':\t/* list of images to process */\n                for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    ((opt_ptr != NULL) &&  (i < MAX_IMAGES));\n                     (opt_ptr = strtok (NULL, \",\")))\n                     { /* We do not know how many images are in file yet \n\t\t\t* so we build a list to include the maximum allowed\n                        * and follow it until we hit the end of the file.\n                        * Image count is not accurate for odd, even, last\n                        * so page numbers won't be valid either.\n                        */\n\t\t     if (streq(opt_ptr, \"odd\"))\n                       {\n\t\t       for (j = 1; j <= MAX_IMAGES; j += 2)\n\t\t\t imagelist[i++] = j;\n                       *image_count = (MAX_IMAGES - 1) / 2;\n                       break;\n\t\t       }\n\t\t     else\n                       {\n\t\t       if (streq(opt_ptr, \"even\"))\n                         {\n\t\t\t for (j = 2; j <= MAX_IMAGES; j += 2)\n\t\t\t   imagelist[i++] = j;\n                         *image_count = MAX_IMAGES / 2;\n                         break;\n\t\t\t }\n\t\t       else\n                         {\n\t\t\t if (streq(opt_ptr, \"last\"))\n\t\t\t   imagelist[i++] = MAX_IMAGES;\n\t\t\t else  /* single value between commas */\n\t\t\t   {\n\t\t\t   sep = strpbrk(opt_ptr, \":-\");\n\t\t\t   if (!sep)\n\t\t\t     imagelist[i++] = atoi(opt_ptr);\n                           else\n                             {\n\t\t\t     *sep = '\\0';\n                             start = atoi (opt_ptr);\n                             if (!strcmp((sep + 1), \"last\"))\n\t\t\t       end = MAX_IMAGES;\n                             else\n                               end = atoi (sep + 1);\n                             for (j = start; j <= end && j - start + i < MAX_IMAGES; j++)\n\t\t\t       imagelist[i++] = j;\n\t\t\t     }\n\t\t\t   }\n\t\t\t }\n\t\t      }\n\t\t    }\n                *image_count = i;\n\t\tbreak;\n      case 'O': /* page orientation */ \n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'a': page->orient = ORIENTATION_AUTO;\n                             break;\n\t\t  case  'p': page->orient = ORIENTATION_PORTRAIT;\n                             break;\n\t\t  case  'l': page->orient = ORIENTATION_LANDSCAPE;\n                             break;\n\t\t  default:  TIFFError (\"Orientation must be portrait, landscape, or auto.\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (-1);\n\t\t  }\n\t\tbreak;\n      case 'P': /* page size selection */ \n\t        if (sscanf(optarg, \"%lfx%lf\", &page->width, &page->length) == 2)\n                  {\n                  strcpy (page->name, \"Custom\"); \n                  page->mode |= PAGE_MODE_PAPERSIZE;\n                  break;\n                  }\n                if (get_page_geometry (optarg, page))\n                  {\n\t\t  if (!strcmp(optarg, \"list\"))\n                    {\n\t\t    TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                    for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                      TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t    exit (-1);                   \n                    }\n     \n\t\t  TIFFError (\"Invalid paper size\", \"%s\", optarg);\n                  TIFFError (\"\", \"Select one of:\");\n\t\t  TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                  for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                    TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t  exit (-1);\n\t\t  }\n\t\telse\n                  {\n                  page->mode |= PAGE_MODE_PAPERSIZE;\n\t\t  }\n\t\tbreak;\n      case 'R': /* rotate image or cropped segment */\n\t\tcrop_data->crop_mode |= CROP_ROTATE;\n\t\tswitch (strtoul(optarg, NULL, 0))\n                  {\n\t\t  case  90:  crop_data->rotation = (uint16)90;\n                             break;\n                  case  180: crop_data->rotation = (uint16)180;\n                             break;\n                  case  270: crop_data->rotation = (uint16)270;\n                             break;\n\t\t  default:   TIFFError (\"Rotation must be 90, 180, or 270 degrees clockwise\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (-1);\n\t\t  }\n\t\tbreak;\n      case 'S':\t/* subdivide into Cols:Rows sections, eg 3:2 would be 3 across and 2 down */\n\t\tsep = strpbrk(optarg, \",:\");\n\t\tif (sep)\n                  {\n                  *sep = '\\0';\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(sep +1);\n\t\t  }\n                else\n                  {\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(optarg);\n\t\t  }\n                if ((page->cols * page->rows) > MAX_SECTIONS)\n                  {\n\t\t  TIFFError (\"Limit for subdivisions, ie rows x columns, exceeded\", \"%d\", MAX_SECTIONS);\n\t\t  exit (-1);\n                  }\n                page->mode |= PAGE_MODE_ROWSCOLS;\n\t\tbreak;\n      case 'U':\t/* units for measurements and offsets */\n\t\tif (streq(optarg, \"in\"))\n                  {\n\t\t  crop_data->res_unit = RESUNIT_INCH;\n\t\t  page->res_unit = RESUNIT_INCH;\n\t\t  }\n\t\telse if (streq(optarg, \"cm\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_CENTIMETER;\n\t\t  page->res_unit = RESUNIT_CENTIMETER;\n\t\t  }\n\t\telse if (streq(optarg, \"px\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_NONE;\n\t\t  page->res_unit = RESUNIT_NONE;\n\t\t  }\n\t\telse\n                  {\n\t\t  TIFFError (\"Illegal unit of measure\",\"%s\", optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (-1);\n\t\t  }\n\t\tbreak;\n      case 'V': /* set vertical resolution to new value */\n\t\tpage->vres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'X':\t/* selection width */\n\t\tcrop_data->crop_mode |= CROP_WIDTH;\n\t\tcrop_data->width = atof(optarg);\n\t\tbreak;\n      case 'Y':\t/* selection length */\n\t\tcrop_data->crop_mode |= CROP_LENGTH;\n\t\tcrop_data->length = atof(optarg);\n\t\tbreak;\n      case 'Z': /* zones of an image X:Y read as zone X of Y */\n\t\tcrop_data->crop_mode |= CROP_ZONES;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \",\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    crop_data->zones++;\n\t\t    opt_offset = strchr(opt_ptr, ':');\n\t\t    if (!opt_offset) {\n\t\t\tTIFFError(\"Wrong parameter syntax for -Z\", \"tiffcrop -h\");\n\t\t\texit(-1);\n\t\t    }\n                    *opt_offset = '\\0';\n                    crop_data->zonelist[i].position = atoi(opt_ptr);\n                    crop_data->zonelist[i].total    = atoi(opt_offset + 1);\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError(\"Zone list exceeds region limit\", \"%d\",  MAX_REGIONS);\n\t\t  exit (-1);\n                  }\n\t\tbreak;\n    case '?':\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (-1);\n\t\t/*NOTREACHED*/\n      }\n    }\n  }",
          "fn_code_pos": [
            [
              1593,
              0
            ],
            [
              2099,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_command_opts",
            "parameters": {
              "argc": "int",
              "argv": "char",
              "mp": "char",
              "mode": "char",
              "dirnum": "uint32",
              "defconfig": "uint16",
              "deffillorder": "uint16",
              "deftilewidth": "uint32",
              "deftilelength": "uint32",
              "defrowsperstrip": "uint32",
              "crop_data": "struct crop_mask",
              "page": "struct pagedef",
              "dump": "struct dump_opts",
              "imagelist": "unsigned int",
              "image_count": "unsigned int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nupdate_output_file (TIFF **tiffout, char *mode, int autoindex,\n                    char *outname, unsigned int *page)\n  {\n  static int findex = 0;    /* file sequence indicator */\n  size_t basename_len;\n  char  *sep;\n  char   export_ext[16];\n  char   exportname[PATH_MAX];\n\n  if (autoindex && (*tiffout != NULL))\n    {\n    /* Close any export file that was previously opened */\n    TIFFClose (*tiffout);\n    *tiffout = NULL;\n    }\n\n  memcpy (export_ext, \".tiff\", 6);\n  memset (exportname, '\\0', sizeof(exportname));\n\n  /* Leave room for page number portion of the new filename :\n   * hyphen + 6 digits + dot + 4 extension characters + null terminator */\n  #define FILENUM_MAX_LENGTH (1+6+1+4+1)\n  strncpy (exportname, outname, sizeof(exportname) - FILENUM_MAX_LENGTH);\n  if (*tiffout == NULL)   /* This is a new export file */\n    {\n    if (autoindex)\n      { /* create a new filename for each export */\n      findex++;\n      if ((sep = strstr(exportname, \".tif\")) || (sep = strstr(exportname, \".TIF\")))\n        {\n        strncpy (export_ext, sep, 5);\n        *sep = '\\0';\n        }\n      else\n        memcpy (export_ext, \".tiff\", 5);\n      export_ext[5] = '\\0';\n      basename_len = strlen(exportname);\n\n      /* MAX_EXPORT_PAGES limited to 6 digits to prevent string overflow of pathname */\n      if (findex > MAX_EXPORT_PAGES)\n        {\n        TIFFError(\"update_output_file\", \"Maximum of %d pages per file exceeded\", MAX_EXPORT_PAGES);\n        return 1;\n        }\n\n      /* We previously assured that there will be space left */\n      snprintf(exportname + basename_len, sizeof(exportname) - basename_len, \"-%03d%.5s\", findex, export_ext);\n      }\n    exportname[sizeof(exportname) - 1] = '\\0';\n\n    *tiffout = TIFFOpen(exportname, mode);\n    if (*tiffout == NULL)\n      {\n      TIFFError(\"update_output_file\", \"Unable to open output file %s\", exportname);\n      return 1;\n      }\n    *page = 0;\n\n    return 0;\n    }\n  else\n    (*page)++;\n\n  return 0;\n  }",
          "fn_code_pos": [
            [
              2105,
              0
            ],
            [
              2170,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "update_output_file",
            "parameters": {
              "tiffout": "TIFF",
              "mode": "char",
              "autoindex": "int",
              "outname": "char",
              "page": "unsigned int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n  {\n\n#if !HAVE_DECL_OPTARG\n  extern int optind;\n#endif\n  uint16 defconfig = (uint16) -1;\n  uint16 deffillorder = 0;\n  uint32 deftilewidth = (uint32) 0;\n  uint32 deftilelength = (uint32) 0;\n  uint32 defrowsperstrip = (uint32) 0;\n  uint32 dirnum = 0;\n\n  TIFF *in = NULL;\n  TIFF *out = NULL;\n  char  mode[10];\n  char *mp = mode;\n\n  /** RJN additions **/\n  struct image_data image;     /* Image parameters for one image */\n  struct crop_mask  crop;      /* Cropping parameters for all images */\n  struct pagedef    page;      /* Page definition for output pages */\n  struct pageseg    sections[MAX_SECTIONS];  /* Sections of one output page */\n  struct buffinfo   seg_buffs[MAX_SECTIONS]; /* Segment buffer sizes and pointers */\n  struct dump_opts  dump;                  /* Data dump options */\n  unsigned char *read_buff    = NULL;      /* Input image data buffer */\n  unsigned char *crop_buff    = NULL;      /* Crop area buffer */\n  unsigned char *sect_buff    = NULL;      /* Image section buffer */\n  unsigned char *sect_src     = NULL;      /* Image section buffer pointer */\n  unsigned int  imagelist[MAX_IMAGES + 1]; /* individually specified images */\n  unsigned int  image_count  = 0;\n  unsigned int  dump_images  = 0;\n  unsigned int  next_image   = 0;\n  unsigned int  next_page    = 0;\n  unsigned int  total_pages  = 0;\n  unsigned int  total_images = 0;\n  unsigned int  end_of_input = FALSE;\n  int    seg;\n  size_t length;\n  char   temp_filename[PATH_MAX + 16]; /* Extra space keeps the compiler from complaining */\n\n  little_endian = *((unsigned char *)&little_endian) & '1';\n\n  initImageData(&image);\n  initCropMasks(&crop);\n  initPageSetup(&page, sections, seg_buffs);\n  initDumpOptions(&dump);\n\n  process_command_opts (argc, argv, mp, mode, &dirnum, &defconfig, \n                        &deffillorder, &deftilewidth, &deftilelength, &defrowsperstrip,\n\t                &crop, &page, &dump, imagelist, &image_count);\n\n  if (argc - optind < 2)\n    usage();\n\n  if ((argc - optind) == 2)\n    pageNum = -1;\n  else\n    total_images = 0;\n  /* Read multiple input files and write to output file(s) */\n  while (optind < argc - 1)\n    {\n    in = TIFFOpen (argv[optind], \"r\");\n    if (in == NULL)\n      return (-3);\n\n    /* If only one input file is specified, we can use directory count */\n    total_images = TIFFNumberOfDirectories(in);\n    if (total_images > TIFF_DIR_MAX)\n      {\n      TIFFError (TIFFFileName(in), \"File contains too many directories\");\n      if (out != NULL)\n        (void) TIFFClose(out);\n      return (1);\n      }\n    if (image_count == 0)\n      {\n      dirnum = 0;\n      total_pages = total_images; /* Only valid with single input file */\n      }\n    else\n      {\n      dirnum = (tdir_t)(imagelist[next_image] - 1);\n      next_image++;\n\n      /* Total pages only valid for enumerated list of pages not derived\n       * using odd, even, or last keywords.\n       */\n      if (image_count >  total_images)\n\timage_count = total_images;\n      \n      total_pages = image_count;\n      }\n\n    /* MAX_IMAGES is used for special case \"last\" in selection list */\n    if (dirnum == (MAX_IMAGES - 1))\n      dirnum = total_images - 1;\n\n    if (dirnum > (total_images))\n      {\n      TIFFError (TIFFFileName(in), \n      \"Invalid image number %d, File contains only %d images\", \n\t\t (int)dirnum + 1, total_images);\n      if (out != NULL)\n        (void) TIFFClose(out);\n      return (1);\n      }\n\n    if (dirnum != 0 && !TIFFSetDirectory(in, (tdir_t)dirnum))\n      {\n      TIFFError(TIFFFileName(in),\"Error, setting subdirectory at %d\", dirnum);\n      if (out != NULL)\n        (void) TIFFClose(out);\n      return (1);\n      }\n\n    end_of_input = FALSE;\n    while (end_of_input == FALSE)\n      {\n      config = defconfig;\n      compression = defcompression;\n      predictor = defpredictor;\n      fillorder = deffillorder;\n      rowsperstrip = defrowsperstrip;\n      tilewidth = deftilewidth;\n      tilelength = deftilelength;\n      g3opts = defg3opts;\n\n      if (dump.format != DUMP_NONE)\n        {\n        /* manage input and/or output dump files here */\n\tdump_images++;\n        length = strlen(dump.infilename);\n        if (length > 0)\n          {\n          if (dump.infile != NULL)\n            fclose (dump.infile);\n\n          /* dump.infilename is guaranteed to be NUL terminated and have 20 bytes\n             fewer than PATH_MAX */\n          snprintf(temp_filename, sizeof(temp_filename), \"%s-read-%03d.%s\",\n\t\t   dump.infilename, dump_images,\n                  (dump.format == DUMP_TEXT) ? \"txt\" : \"raw\");\n          if ((dump.infile = fopen(temp_filename, dump.mode)) == NULL)\n            {\n\t    TIFFError (\"Unable to open dump file for writing\", \"%s\", temp_filename);\n\t    exit (-1);\n            }\n          dump_info(dump.infile, dump.format, \"Reading image\",\"%d from %s\", \n                    dump_images, TIFFFileName(in));\n          } \n        length = strlen(dump.outfilename);\n        if (length > 0)\n          {\n          if (dump.outfile != NULL)\n            fclose (dump.outfile);\n\n          /* dump.outfilename is guaranteed to be NUL terminated and have 20 bytes\n             fewer than PATH_MAX */ \n          snprintf(temp_filename, sizeof(temp_filename), \"%s-write-%03d.%s\",\n\t\t   dump.outfilename, dump_images,\n                  (dump.format == DUMP_TEXT) ? \"txt\" : \"raw\");\n          if ((dump.outfile = fopen(temp_filename, dump.mode)) == NULL)\n            {\n\t      TIFFError (\"Unable to open dump file for writing\", \"%s\", temp_filename);\n\t    exit (-1);\n            }\n          dump_info(dump.outfile, dump.format, \"Writing image\",\"%d from %s\", \n                    dump_images, TIFFFileName(in));\n          } \n        }\n\n      if (dump.debug)\n         TIFFError(\"main\", \"Reading image %4d of %4d total pages.\", dirnum + 1, total_pages);\n\n      if (loadImage(in, &image, &dump, &read_buff))\n        {\n        TIFFError(\"main\", \"Unable to load source image\");\n        exit (-1);\n        }\n\n      /* Correct the image orientation if it was not ORIENTATION_TOPLEFT.\n       */\n      if (image.adjustments != 0)\n        {\n\tif (correct_orientation(&image, &read_buff))\n\t    TIFFError(\"main\", \"Unable to correct image orientation\");\n        }\n\n      if (getCropOffsets(&image, &crop, &dump))\n        {\n        TIFFError(\"main\", \"Unable to define crop regions\");\n        exit (-1);\n\t}\n\n      if (crop.selections > 0)\n        {\n        if (processCropSelections(&image, &crop, &read_buff, seg_buffs))\n          {\n          TIFFError(\"main\", \"Unable to process image selections\");\n          exit (-1);\n\t  }\n\t}\n      else  /* Single image segment without zones or regions */\n        {\n        if (createCroppedImage(&image, &crop, &read_buff, &crop_buff))\n          {\n          TIFFError(\"main\", \"Unable to create output image\");\n          exit (-1);\n\t  }\n\t}\n      if (page.mode == PAGE_MODE_NONE)\n        {  /* Whole image or sections not based on output page size */\n        if (crop.selections > 0)\n          {\n\t  writeSelections(in, &out, &crop, &image, &dump, seg_buffs,\n                          mp, argv[argc - 1], &next_page, total_pages);\n          }\n\telse  /* One file all images and sections */\n          {\n\t  if (update_output_file (&out, mp, crop.exp_mode, argv[argc - 1],\n                                  &next_page))\n             exit (1);\n          if (writeCroppedImage(in, out, &image, &dump,crop.combined_width, \n                                crop.combined_length, crop_buff, next_page, total_pages))\n            {\n             TIFFError(\"main\", \"Unable to write new image\");\n             exit (-1);\n\t    }\n          }\n\t}\n      else\n        {\n\t/* If we used a crop buffer, our data is there, otherwise it is\n         * in the read_buffer\n         */\n\tif (crop_buff != NULL)  \n\t  sect_src = crop_buff;\n        else\n          sect_src = read_buff;\n        /* Break input image into pages or rows and columns */\n        if (computeOutputPixelOffsets(&crop, &image, &page, sections, &dump))\n          {\n          TIFFError(\"main\", \"Unable to compute output section data\");\n          exit (-1);\n\t  }\n        /* If there are multiple files on the command line, the final one is assumed \n         * to be the output filename into which the images are written.\n         */\n\tif (update_output_file (&out, mp, crop.exp_mode, argv[argc - 1], &next_page))\n          exit (1);\n\n\tif (writeImageSections(in, out, &image, &page, sections, &dump, sect_src, &sect_buff))\n          {\n          TIFFError(\"main\", \"Unable to write image sections\");\n          exit (-1);\n\t  }\n        }\n\n      /* No image list specified, just read the next image */\n      if (image_count == 0)\n        dirnum++;\n      else\n        {\n\tdirnum = (tdir_t)(imagelist[next_image] - 1);\n        next_image++;\n        }\n\n      if (dirnum == MAX_IMAGES - 1)\n        dirnum = TIFFNumberOfDirectories(in) - 1;\n\n      if (!TIFFSetDirectory(in, (tdir_t)dirnum))\n        end_of_input = TRUE;\n      }\n    TIFFClose(in);\n    optind++;\n    }\n\n  /* If we did not use the read buffer as the crop buffer */\n  if (read_buff)\n    _TIFFfree(read_buff);\n\n  if (crop_buff)\n    _TIFFfree(crop_buff);\n\n  if (sect_buff)\n    _TIFFfree(sect_buff);\n\n   /* Clean up any segment buffers used for zones or regions */\n  for (seg = 0; seg < crop.selections; seg++)\n    _TIFFfree (seg_buffs[seg].buffer);\n\n  if (dump.format != DUMP_NONE)\n    {\n    if (dump.infile != NULL)\n     fclose (dump.infile);\n\n    if (dump.outfile != NULL)\n      {\n      dump_info (dump.outfile, dump.format, \"\", \"Completed run for %s\", TIFFFileName(out));\n      fclose (dump.outfile);\n      }\n    }\n\n  TIFFClose(out);\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              2173,
              0
            ],
            [
              2481,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int dump_data (FILE *dumpfile, int format, char *dump_tag, unsigned char *data, uint32 count)\n  {\n  int j, k;\n  uint32 i;\n  char  dump_array[10];\n  unsigned char bitset;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  if (format == DUMP_TEXT)\n    {\n    fprintf (dumpfile,\" %s  \", dump_tag);\n    for (i = 0; i < count; i++)\n      {\n      for (j = 0, k = 7; j < 8; j++, k--)\n        {\n\tbitset = (*(data + i)) & (((unsigned char)1 << k)) ? 1 : 0;\n        sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");\n        }\n      dump_array[8] = '\\0';\n      fprintf (dumpfile,\" %s\", dump_array);\n      }\n    fprintf (dumpfile,\"\\n\");\n    }\n  else\n    {\n    if ((fwrite (data, 1, count, dumpfile)) != count)\n      {\n      TIFFError (\"\", \"Unable to write binary data to dump file\");\n      return (1);\n      }\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              2485,
              0
            ],
            [
              2523,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_data",
            "parameters": {
              "dumpfile": "FILE",
              "format": "int",
              "dump_tag": "char",
              "data": "unsigned char",
              "count": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int dump_byte (FILE *dumpfile, int format, char *dump_tag, unsigned char data)\n  {\n  int j, k;\n  char  dump_array[10];\n  unsigned char bitset;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  if (format == DUMP_TEXT)\n    {\n    fprintf (dumpfile,\" %s  \", dump_tag);\n    for (j = 0, k = 7; j < 8; j++, k--)\n      {\n      bitset = data & (((unsigned char)1 << k)) ? 1 : 0;\n      sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");\n      }\n    dump_array[8] = '\\0';\n    fprintf (dumpfile,\" %s\\n\", dump_array);\n    }\n  else\n    {\n    if ((fwrite (&data, 1, 1, dumpfile)) != 1)\n      {\n      TIFFError (\"\", \"Unable to write binary data to dump file\");\n      return (1);\n      }\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              2525,
              0
            ],
            [
              2558,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_byte",
            "parameters": {
              "dumpfile": "FILE",
              "format": "int",
              "dump_tag": "char",
              "data": "unsigned char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int dump_short (FILE *dumpfile, int format, char *dump_tag, uint16 data)\n  {\n  int j, k;\n  char  dump_array[20];\n  unsigned char bitset;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  if (format == DUMP_TEXT)\n    {\n    fprintf (dumpfile,\" %s  \", dump_tag);\n    for (j = 0, k = 15; k >= 0; j++, k--)\n      {\n      bitset = data & (((unsigned char)1 << k)) ? 1 : 0;\n      sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");\n      if ((k % 8) == 0)\n          sprintf(&dump_array[++j], \" \");\n      }\n    dump_array[17] = '\\0';\n    fprintf (dumpfile,\" %s\\n\", dump_array);\n    }\n  else\n    {\n    if ((fwrite (&data, 2, 1, dumpfile)) != 2)\n      {\n      TIFFError (\"\", \"Unable to write binary data to dump file\");\n      return (1);\n      }\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              2560,
              0
            ],
            [
              2595,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_short",
            "parameters": {
              "dumpfile": "FILE",
              "format": "int",
              "dump_tag": "char",
              "data": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int dump_long (FILE *dumpfile, int format, char *dump_tag, uint32 data)\n  {\n  int j, k;\n  char  dump_array[40];\n  unsigned char bitset;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  if (format == DUMP_TEXT)\n    {\n    fprintf (dumpfile,\" %s  \", dump_tag);\n    for (j = 0, k = 31; k >= 0; j++, k--)\n      {\n      bitset = data & (((uint32)1 << k)) ? 1 : 0;\n      sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");\n      if ((k % 8) == 0)\n          sprintf(&dump_array[++j], \" \");\n      }\n    dump_array[35] = '\\0';\n    fprintf (dumpfile,\" %s\\n\", dump_array);\n    }\n  else\n    {\n    if ((fwrite (&data, 4, 1, dumpfile)) != 4)\n      {\n      TIFFError (\"\", \"Unable to write binary data to dump file\");\n      return (1);\n      }\n    }\n  return (0);\n  }",
          "fn_code_pos": [
            [
              2597,
              0
            ],
            [
              2631,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_long",
            "parameters": {
              "dumpfile": "FILE",
              "format": "int",
              "dump_tag": "char",
              "data": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int dump_wide (FILE *dumpfile, int format, char *dump_tag, uint64 data)\n  {\n  int j, k;\n  char  dump_array[80];\n  unsigned char bitset;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  if (format == DUMP_TEXT)\n    {\n    fprintf (dumpfile,\" %s  \", dump_tag);\n    for (j = 0, k = 63; k >= 0; j++, k--)\n      {\n      bitset = data & (((uint64)1 << k)) ? 1 : 0;\n      sprintf(&dump_array[j], (bitset) ? \"1\" : \"0\");\n      if ((k % 8) == 0)\n          sprintf(&dump_array[++j], \" \");\n      }\n    dump_array[71] = '\\0';\n    fprintf (dumpfile,\" %s\\n\", dump_array);\n    }\n  else\n    {\n    if ((fwrite (&data, 8, 1, dumpfile)) != 8)\n      {\n      TIFFError (\"\", \"Unable to write binary data to dump file\");\n      return (1);\n      }\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              2633,
              0
            ],
            [
              2668,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_wide",
            "parameters": {
              "dumpfile": "FILE",
              "format": "int",
              "dump_tag": "char",
              "data": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void dump_info(FILE *dumpfile, int format, char *prefix, char *msg, ...)\n  {\n  if (format == DUMP_TEXT)\n    {\n    va_list ap;\n    va_start(ap, msg);\n    fprintf(dumpfile, \"%s \", prefix);\n    vfprintf(dumpfile, msg, ap);\n    fprintf(dumpfile, \"\\n\");\n    va_end(ap);\n    }\n  }",
          "fn_code_pos": [
            [
              2670,
              0
            ],
            [
              2681,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_info",
            "parameters": {
              "dumpfile": "FILE",
              "format": "int",
              "prefix": "char",
              "msg": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int dump_buffer (FILE* dumpfile, int format, uint32 rows, uint32 width, \n                 uint32 row, unsigned char *buff)\n  {\n  int j, k;\n  uint32 i;\n  unsigned char * dump_ptr;\n\n  if (dumpfile == NULL)\n    {\n    TIFFError (\"\", \"Invalid FILE pointer for dump file\");\n    return (1);\n    }\n\n  for (i = 0; i < rows; i++)\n    {\n    dump_ptr = buff + (i * width);\n    if (format == DUMP_TEXT)\n      dump_info (dumpfile, format, \"\", \n                 \"Row %4d, %d bytes at offset %d\",\n\t         row + i + 1, width, row * width);\n     \n    for (j = 0, k = width; k >= 10; j += 10, k -= 10, dump_ptr += 10)\n      dump_data (dumpfile, format, \"\", dump_ptr, 10);\n    if (k > 0)\n      dump_data (dumpfile, format, \"\", dump_ptr, k);\n    }\n  return (0);\n  }",
          "fn_code_pos": [
            [
              2683,
              0
            ],
            [
              2710,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_buffer",
            "parameters": {
              "dumpfile": "FILE",
              "format": "int",
              "rows": "uint32",
              "width": "uint32",
              "row": "uint32",
              "buff": "unsigned char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int \nextractContigSamplesBytes (uint8 *in, uint8 *out, uint32 cols, \n                           tsample_t sample, uint16 spp, uint16 bps, \n                           tsample_t count, uint32 start, uint32 end)\n  {\n  int i, bytes_per_sample, sindex;\n  uint32 col, dst_rowsize, bit_offset;\n  uint32 src_byte /*, src_bit */;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"extractContigSamplesBytes\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamplesBytes\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamplesBytes\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  dst_rowsize = (bps * (end - start) * count) / 8;\n\n  bytes_per_sample = (bps + 7) / 8; \n  /* Optimize case for copying all samples */\n  if (count == spp)\n    {\n    src = in + (start * spp * bytes_per_sample);\n    _TIFFmemcpy (dst, src, dst_rowsize);\n    }\n  else\n    {\n    for (col = start; col < end; col++)\n      {\n      for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n        {\n        bit_offset = col * bps * spp;\n        if (sindex == 0)\n          {\n          src_byte = bit_offset / 8;\n          /* src_bit  = bit_offset % 8; */\n          }\n        else\n          {\n          src_byte = (bit_offset + (sindex * bps)) / 8;\n          /* src_bit  = (bit_offset + (sindex * bps)) % 8; */\n          }\n        src = in + src_byte;\n        for (i = 0; i < bytes_per_sample; i++)\n            *dst++ = *src++;\n        }\n      }\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              2718,
              0
            ],
            [
              2782,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamplesBytes",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "sample": "tsample_t",
              "spp": "uint16",
              "bps": "uint16",
              "count": "tsample_t",
              "start": "uint32",
              "end": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nextractContigSamples8bits (uint8 *in, uint8 *out, uint32 cols,\n                           tsample_t sample, uint16 spp, uint16 bps, \n                           tsample_t count, uint32 start, uint32 end)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint8  maskbits = 0, matchbits = 0;\n  uint8  buff1 = 0, buff2 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"extractContigSamples8bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamples8bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamples8bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n  \n  ready_bits = 0;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n  buff1 = buff2 = 0;\n  for (col = start; col < end; col++)\n    {    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (8 - src_bit - bps); \n      buff1 = ((*src) & matchbits) << (src_bit);\n\n      /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 8)\n        {\n        *dst++ = buff2;\n        buff2 = buff1;\n        ready_bits -= 8;\n        }\n      else\n        buff2 = (buff2 | (buff1 >> ready_bits));\n      ready_bits += bps;\n      }\n    }\n\n  while (ready_bits > 0)\n    {\n    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n    *dst++ = buff1;\n    ready_bits -= 8;\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              2784,
              0
            ],
            [
              2859,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamples8bits",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "sample": "tsample_t",
              "spp": "uint16",
              "bps": "uint16",
              "count": "tsample_t",
              "start": "uint32",
              "end": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nextractContigSamples16bits (uint8 *in, uint8 *out, uint32 cols, \n                            tsample_t sample, uint16 spp, uint16 bps, \n                            tsample_t count, uint32 start, uint32 end)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint16 maskbits = 0, matchbits = 0;\n  uint16 buff1 = 0, buff2 = 0;\n  uint8  bytebuff = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"extractContigSamples16bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamples16bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamples16bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  ready_bits = 0;\n  maskbits = (uint16)-1 >> (16 - bps);\n\n  for (col = start; col < end; col++)\n    {    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (16 - src_bit - bps); \n\n      if (little_endian)\n        buff1 = (src[0] << 8) | src[1];\n      else\n        buff1 = (src[1] << 8) | src[0];\n\n      buff1 = (buff1 & matchbits) << (src_bit);\n      if (ready_bits < 8) /* add another bps bits to the buffer */\n        { \n        bytebuff = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff = (buff2 >> 8);\n        *dst++ = bytebuff;\n        ready_bits -= 8;\n        /* shift in new bits */\n        buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff = (buff2 >> 8);\n    *dst++ = bytebuff;\n    ready_bits -= 8;\n    }\n  \n  return (0);\n  }",
          "fn_code_pos": [
            [
              2861,
              0
            ],
            [
              2947,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamples16bits",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "sample": "tsample_t",
              "spp": "uint16",
              "bps": "uint16",
              "count": "tsample_t",
              "start": "uint32",
              "end": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nextractContigSamples24bits (uint8 *in, uint8 *out, uint32 cols,\n \t                    tsample_t sample, uint16 spp, uint16 bps, \n                            tsample_t count, uint32 start, uint32 end)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint32 maskbits = 0, matchbits = 0;\n  uint32 buff1 = 0, buff2 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((in == NULL) || (out == NULL))\n    {\n    TIFFError(\"extractContigSamples24bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamples24bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamples24bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  ready_bits = 0;\n  maskbits =  (uint32)-1 >> ( 32 - bps);\n  for (col = start; col < end; col++)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (32 - src_bit - bps); \n      if (little_endian)\n\tbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n      else\n\tbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n      buff1 = (buff1 & matchbits) << (src_bit);\n\n      if (ready_bits < 16) /* add another bps bits to the buffer */\n        {\n        bytebuff1 = bytebuff2 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 24);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 16);\n        *dst++ = bytebuff2;\n        ready_bits -= 16;\n\n        /* shift in new bits */\n        buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 24);\n    *dst++ = bytebuff1;\n\n    buff2 = (buff2 << 8);\n    bytebuff2 = bytebuff1;\n    ready_bits -= 8;\n    } \n  \n  return (0);\n  }",
          "fn_code_pos": [
            [
              2950,
              0
            ],
            [
              3041,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamples24bits",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "sample": "tsample_t",
              "spp": "uint16",
              "bps": "uint16",
              "count": "tsample_t",
              "start": "uint32",
              "end": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nextractContigSamples32bits (uint8 *in, uint8 *out, uint32 cols,\n                            tsample_t sample, uint16 spp, uint16 bps, \n \t\t\t    tsample_t count, uint32 start, uint32 end)\n  {\n  int    ready_bits = 0, sindex = 0 /*, shift_width = 0 */;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 maskbits = 0, matchbits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((in == NULL) || (out == NULL))\n    {\n    TIFFError(\"extractContigSamples32bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamples32bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamples32bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  /* shift_width = ((bps + 7) / 8) + 1; */ \n  ready_bits = 0;\n  maskbits =  (uint64)-1 >> ( 64 - bps);\n  for (col = start; col < end; col++)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (64 - src_bit - bps); \n      if (little_endian)\n        {\n\tlongbuff1 = (src[0] << 24) | (src[1] << 16)  | (src[2] << 8) | src[3];\n\tlongbuff2 = longbuff1;\n        }\n      else\n        {\n\tlongbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n\tlongbuff2 = longbuff1;\n\t}\n\n      buff3 = ((uint64)longbuff1 << 32) | longbuff2;\n      buff1 = (buff3 & matchbits) << (src_bit);\n\n      /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 32)\n        {\n        bytebuff1 = (buff2 >> 56);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 48);\n        *dst++ = bytebuff2;\n        bytebuff3 = (buff2 >> 40);\n        *dst++ = bytebuff3;\n        bytebuff4 = (buff2 >> 32);\n        *dst++ = bytebuff4;\n        ready_bits -= 32;\n                    \n        /* shift in new bits */\n        buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n        }\n      else\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 56);\n    *dst++ = bytebuff1;\n    buff2 = (buff2 << 8);\n    ready_bits -= 8;\n    }\n  \n  return (0);\n  }",
          "fn_code_pos": [
            [
              3043,
              0
            ],
            [
              3146,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamples32bits",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "sample": "tsample_t",
              "spp": "uint16",
              "bps": "uint16",
              "count": "tsample_t",
              "start": "uint32",
              "end": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nextractContigSamplesShifted8bits (uint8 *in, uint8 *out, uint32 cols,\n                                  tsample_t sample, uint16 spp, uint16 bps, \n\t\t\t          tsample_t count, uint32 start, uint32 end,\n \t                          int shift)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint8  maskbits = 0, matchbits = 0;\n  uint8  buff1 = 0, buff2 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"extractContigSamplesShifted8bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted8bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted8bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  ready_bits = shift;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n  buff1 = buff2 = 0;\n  for (col = start; col < end; col++)\n    {    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (8 - src_bit - bps); \n      buff1 = ((*src) & matchbits) << (src_bit);\n      if ((col == start) && (sindex == sample))\n        buff2 = *src & ((uint8)-1) << (shift);\n\n      /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 8)\n        {\n        *dst++ |= buff2;\n        buff2 = buff1;\n        ready_bits -= 8;\n        }\n      else\n\tbuff2 = buff2 | (buff1 >> ready_bits);\n      ready_bits += bps;\n      }\n    }\n\n  while (ready_bits > 0)\n    {\n    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n    *dst++ = buff1;\n    ready_bits -= 8;\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              3148,
              0
            ],
            [
              3226,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamplesShifted8bits",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "sample": "tsample_t",
              "spp": "uint16",
              "bps": "uint16",
              "count": "tsample_t",
              "start": "uint32",
              "end": "uint32",
              "shift": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nextractContigSamplesShifted16bits (uint8 *in, uint8 *out, uint32 cols, \n                                   tsample_t sample, uint16 spp, uint16 bps, \n  \t\t\t           tsample_t count, uint32 start, uint32 end,\n \t                           int shift)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint16 maskbits = 0, matchbits = 0;\n  uint16 buff1 = 0, buff2 = 0;\n  uint8  bytebuff = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n  \n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"extractContigSamplesShifted16bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted16bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted16bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  ready_bits = shift;\n  maskbits = (uint16)-1 >> (16 - bps);\n  for (col = start; col < end; col++)\n    {    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (16 - src_bit - bps); \n      if (little_endian)\n        buff1 = (src[0] << 8) | src[1];\n      else\n        buff1 = (src[1] << 8) | src[0];\n\n      if ((col == start) && (sindex == sample))\n        buff2 = buff1 & ((uint16)-1) << (8 - shift);\n\n      buff1 = (buff1 & matchbits) << (src_bit);\n\n      if (ready_bits < 8) /* add another bps bits to the buffer */\n        buff2 = buff2 | (buff1 >> ready_bits);\n      else  /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff = (buff2 >> 8);\n        *dst++ = bytebuff;\n        ready_bits -= 8;\n        /* shift in new bits */\n        buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n        }\n\n      ready_bits += bps;\n      }\n    }\n\n  /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff = (buff2 >> 8);\n    *dst++ = bytebuff;\n    ready_bits -= 8;\n    }\n  \n  return (0);\n  }",
          "fn_code_pos": [
            [
              3228,
              0
            ],
            [
              3315,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamplesShifted16bits",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "sample": "tsample_t",
              "spp": "uint16",
              "bps": "uint16",
              "count": "tsample_t",
              "start": "uint32",
              "end": "uint32",
              "shift": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nextractContigSamplesShifted24bits (uint8 *in, uint8 *out, uint32 cols,\n \t                           tsample_t sample, uint16 spp, uint16 bps, \n                                   tsample_t count, uint32 start, uint32 end,\n\t                           int shift)\n  {\n  int    ready_bits = 0, sindex = 0;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint32 maskbits = 0, matchbits = 0;\n  uint32 buff1 = 0, buff2 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((in == NULL) || (out == NULL))\n    {\n    TIFFError(\"extractContigSamplesShifted24bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted24bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted24bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  ready_bits = shift;\n  maskbits =  (uint32)-1 >> ( 32 - bps);\n  for (col = start; col < end; col++)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (32 - src_bit - bps); \n      if (little_endian)\n\tbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n      else\n\tbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n\n      if ((col == start) && (sindex == sample))\n        buff2 = buff1 & ((uint32)-1) << (16 - shift);\n\n      buff1 = (buff1 & matchbits) << (src_bit);\n\n      if (ready_bits < 16)  /* add another bps bits to the buffer */\n        {\n        bytebuff1 = bytebuff2 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 24);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 16);\n        *dst++ = bytebuff2;\n        ready_bits -= 16;\n\n        /* shift in new bits */\n        buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 24);\n    *dst++ = bytebuff1;\n\n    buff2 = (buff2 << 8);\n    bytebuff2 = bytebuff1;\n    ready_bits -= 8;\n    }\n   \n  return (0);\n  }",
          "fn_code_pos": [
            [
              3318,
              0
            ],
            [
              3414,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamplesShifted24bits",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "sample": "tsample_t",
              "spp": "uint16",
              "bps": "uint16",
              "count": "tsample_t",
              "start": "uint32",
              "end": "uint32",
              "shift": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nextractContigSamplesShifted32bits (uint8 *in, uint8 *out, uint32 cols,\n                                   tsample_t sample, uint16 spp, uint16 bps, \n \t\t\t           tsample_t count, uint32 start, uint32 end,\n\t                           int shift)\n  {\n  int    ready_bits = 0, sindex = 0 /*, shift_width = 0 */;\n  uint32 col, src_byte, src_bit, bit_offset;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 maskbits = 0, matchbits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  uint8 *src = in;\n  uint8 *dst = out;\n\n  if ((in == NULL) || (out == NULL))\n    {\n    TIFFError(\"extractContigSamplesShifted32bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n\n  if ((start > end) || (start > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted32bits\", \n               \"Invalid start column value %d ignored\", start);\n    start = 0;\n    }\n  if ((end == 0) || (end > cols))\n    {\n    TIFFError (\"extractContigSamplesShifted32bits\", \n               \"Invalid end column value %d ignored\", end);\n    end = cols;\n    }\n\n  /* shift_width = ((bps + 7) / 8) + 1; */ \n  ready_bits = shift;\n  maskbits =  (uint64)-1 >> ( 64 - bps);\n  for (col = start; col < end; col++)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = col * bps * spp;\n    for (sindex = sample; (sindex < spp) && (sindex < (sample + count)); sindex++)\n      {\n      if (sindex == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sindex * bps)) / 8;\n        src_bit  = (bit_offset + (sindex * bps)) % 8;\n        }\n\n      src = in + src_byte;\n      matchbits = maskbits << (64 - src_bit - bps); \n      if (little_endian)\n        {\n\tlongbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n\tlongbuff2 = longbuff1;\n        }\n      else\n        {\n\tlongbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n\tlongbuff2 = longbuff1;\n\t}\n\n      buff3 = ((uint64)longbuff1 << 32) | longbuff2;\n      if ((col == start) && (sindex == sample))\n        buff2 = buff3 & ((uint64)-1) << (32 - shift);\n\n      buff1 = (buff3 & matchbits) << (src_bit);\n\n      if (ready_bits < 32)\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else  /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 56);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 48);\n        *dst++ = bytebuff2;\n        bytebuff3 = (buff2 >> 40);\n        *dst++ = bytebuff3;\n        bytebuff4 = (buff2 >> 32);\n        *dst++ = bytebuff4;\n        ready_bits -= 32;\n                    \n        /* shift in new bits */\n        buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 56);\n    *dst++ = bytebuff1;\n    buff2 = (buff2 << 8);\n    ready_bits -= 8;\n    }\n  \n  return (0);\n  }",
          "fn_code_pos": [
            [
              3416,
              0
            ],
            [
              3522,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamplesShifted32bits",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "sample": "tsample_t",
              "spp": "uint16",
              "bps": "uint16",
              "count": "tsample_t",
              "start": "uint32",
              "end": "uint32",
              "shift": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nextractContigSamplesToBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,\n  \t                     tsample_t sample, uint16 spp, uint16 bps, \n                             struct dump_opts *dump)\n  {\n  int    shift_width, bytes_per_sample, bytes_per_pixel;\n  uint32 src_rowsize, src_offset, row, first_col = 0;\n  uint32 dst_rowsize, dst_offset;\n  tsample_t count = 1;\n  uint8 *src, *dst;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if ((bps % 8) == 0)\n    shift_width = 0;\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n  src_rowsize = ((bps * spp * cols) + 7) / 8;\n  dst_rowsize = ((bps * cols) + 7) / 8;\n\n  if ((dump->outfile != NULL) && (dump->level == 4))\n    {\n    dump_info  (dump->outfile, dump->format, \"extractContigSamplesToBuffer\", \n                \"Sample %d, %d rows\", sample + 1, rows + 1);\n    }\n  for (row = 0; row < rows; row++)\n    {\n    src_offset = row * src_rowsize;\n    dst_offset = row * dst_rowsize;\n    src = in + src_offset;\n    dst = out + dst_offset;\n\n    /* pack the data into the scanline */\n    switch (shift_width)\n      {  \n      case 0: if (extractContigSamplesBytes (src, dst, cols, sample,\n                                             spp, bps,  count, first_col, cols))  \n                return (1);\n \t      break;\n      case 1: if (bps == 1)\n                {\n                if (extractContigSamples8bits (src, dst, cols, sample,\n                                               spp, bps, count, first_col, cols))\n\t          return (1);\n\t        break;\n\t\t}\n\t      else\n                 if (extractContigSamples16bits (src, dst, cols, sample,\n                                                 spp, bps, count, first_col, cols))\n\t         return (1);\n\t      break;\n      case 2: if (extractContigSamples24bits (src, dst, cols, sample,\n                                              spp, bps,  count, first_col, cols))\n\t         return (1);\n\t      break;\n      case 3:\n      case 4: \n      case 5: if (extractContigSamples32bits (src, dst, cols, sample,\n                                              spp, bps,  count, first_col, cols))\n\t         return (1);\n\t      break;\n      default: TIFFError (\"extractContigSamplesToBuffer\", \"Unsupported bit depth: %d\", bps);\n\t       return (1);\n      }\n    if ((dump->outfile != NULL) && (dump->level == 4))\n      dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst);\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              3524,
              0
            ],
            [
              3598,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamplesToBuffer",
            "parameters": {
              "out": "uint8",
              "in": "uint8",
              "rows": "uint32",
              "cols": "uint32",
              "sample": "tsample_t",
              "spp": "uint16",
              "bps": "uint16",
              "dump": "struct dump_opts"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nextractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,\n  \t                         uint32 imagewidth, uint32 tilewidth, tsample_t sample,\n\t\t\t\t uint16 count, uint16 spp, uint16 bps, struct dump_opts *dump)\n  {\n  int    shift_width, bytes_per_sample, bytes_per_pixel;\n  uint32 src_rowsize, src_offset, row;\n  uint32 dst_rowsize, dst_offset;\n  uint8 *src, *dst;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if ((bps % 8) == 0)\n    shift_width = 0;\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n\n  if ((dump->outfile != NULL) && (dump->level == 4))\n    {\n    dump_info  (dump->outfile, dump->format, \"extractContigSamplesToTileBuffer\", \n                \"Sample %d, %d rows\", sample + 1, rows + 1);\n    }\n\n  src_rowsize = ((bps * spp * imagewidth) + 7) / 8;\n  dst_rowsize = ((bps * tilewidth * count) + 7) / 8;\n\n  for (row = 0; row < rows; row++)\n    {\n    src_offset = row * src_rowsize;\n    dst_offset = row * dst_rowsize;\n    src = in + src_offset;\n    dst = out + dst_offset;\n\n    /* pack the data into the scanline */\n    switch (shift_width)\n      {  \n      case 0: if (extractContigSamplesBytes (src, dst, cols, sample,\n                                             spp, bps,  count, 0, cols))  \n                return (1);\n \t      break;\n      case 1: if (bps == 1)\n                {\n                if (extractContigSamples8bits (src, dst, cols, sample,\n                                               spp, bps, count, 0, cols))\n\t          return (1);\n\t        break;\n\t\t}\n\t      else\n                 if (extractContigSamples16bits (src, dst, cols, sample,\n                                                 spp, bps, count, 0, cols))\n\t         return (1);\n\t      break;\n      case 2: if (extractContigSamples24bits (src, dst, cols, sample,\n                                              spp, bps,  count, 0, cols))\n\t         return (1);\n\t      break;\n      case 3:\n      case 4: \n      case 5: if (extractContigSamples32bits (src, dst, cols, sample,\n                                              spp, bps,  count, 0, cols))\n\t         return (1);\n\t      break;\n      default: TIFFError (\"extractContigSamplesToTileBuffer\", \"Unsupported bit depth: %d\", bps);\n\t       return (1);\n      }\n    if ((dump->outfile != NULL) && (dump->level == 4))\n      dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst);\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              3600,
              0
            ],
            [
              3675,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamplesToTileBuffer",
            "parameters": {
              "out": "uint8",
              "in": "uint8",
              "rows": "uint32",
              "cols": "uint32",
              "imagewidth": "uint32",
              "tilewidth": "uint32",
              "sample": "tsample_t",
              "count": "uint16",
              "spp": "uint16",
              "bps": "uint16",
              "dump": "struct dump_opts"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += stripsize;\n        }\n\n        return 1;\n}",
          "fn_code_pos": [
            [
              3677,
              0
            ],
            [
              3709,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readContigStripsIntoBuffer",
            "parameters": {
              "in": "TIFF",
              "buf": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int \ncombineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,\n                             uint32 cols, uint32 rows, uint16 spp, uint16 bps,\n                             FILE *dumpfile, int format, int level)\n  {\n  int i, bytes_per_sample;\n  uint32 row, col, col_offset, src_rowsize, dst_rowsize, row_offset;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t s;\n\n  src = srcbuffs[0];\n  dst = out;\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateSamplesBytes\",\"Invalid buffer address\");\n    return (1);\n    }\n\n  bytes_per_sample = (bps + 7) / 8; \n\n  src_rowsize = ((bps * cols) + 7) / 8;\n  dst_rowsize = ((bps * spp * cols) + 7) / 8;\n  for (row = 0; row < rows; row++)\n    {\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      for (s = 0; s < spp; s++)\n        {\n        dump_info (dumpfile, format, \"combineSeparateSamplesBytes\",\"Input data, Sample %d\", s);\n        dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));\n        }\n      }\n    dst = out + (row * dst_rowsize);\n    row_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      col_offset = row_offset + (col * (bps / 8)); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n        src = srcbuffs[s] + col_offset; \n        for (i = 0; i < bytes_per_sample; i++)\n          *(dst + i) = *(src + i);\n        src += bytes_per_sample;\n        dst += bytes_per_sample;\n        }   \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateSamplesBytes\",\"Output data, combined samples\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              3711,
              0
            ],
            [
              3767,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateSamplesBytes",
            "parameters": {
              "srcbuffs": "unsigned char",
              "out": "unsigned char",
              "cols": "uint32",
              "rows": "uint32",
              "spp": "uint16",
              "bps": "uint16",
              "dumpfile": "FILE",
              "format": "int",
              "level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncombineSeparateSamples8bits (uint8 *in[], uint8 *out, uint32 cols,\n                            uint32 rows, uint16 spp, uint16 bps, \n \t                    FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0;\n  /* int    bytes_per_sample = 0; */\n  uint32 src_rowsize, dst_rowsize, src_offset; \n  uint32 bit_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint8  maskbits = 0, matchbits = 0;\n  uint8  buff1 = 0, buff2 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[32];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateSamples8bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  /* bytes_per_sample = (bps + 7) / 8; */ \n  src_rowsize = ((bps * cols) + 7) / 8;\n  dst_rowsize = ((bps * cols * spp) + 7) / 8;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (8 - src_bit - bps); \n      /* load up next sample from each plane */\n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        buff1 = ((*src) & matchbits) << (src_bit);\n\n        /* If we have a full buffer's worth, write it out */\n        if (ready_bits >= 8)\n          {\n          *dst++ = buff2;\n          buff2 = buff1;\n          ready_bits -= 8;\n          strcpy (action, \"Flush\");\n          }\n        else\n          {\n          buff2 = (buff2 | (buff1 >> ready_bits));\n          strcpy (action, \"Update\");\n          }\n        ready_bits += bps;\n \n        if ((dumpfile != NULL) && (level == 3))\n          {\n          dump_info (dumpfile, format, \"\",\n                   \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);\n          dump_byte (dumpfile, format, \"Match bits\", matchbits);\n          dump_byte (dumpfile, format, \"Src   bits\", *src);\n          dump_byte (dumpfile, format, \"Buff1 bits\", buff1);\n          dump_byte (dumpfile, format, \"Buff2 bits\", buff2);\n          dump_info (dumpfile, format, \"\",\"%s\", action); \n\t  }\n        }\n      }\n\n    if (ready_bits > 0)\n      {\n      buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n      *dst++ = buff1;\n      if ((dumpfile != NULL) && (level == 3))\n        {\n        dump_info (dumpfile, format, \"\",\n\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t         row + 1, col + 1, src_byte, src_bit, dst - out);\n                 dump_byte (dumpfile, format, \"Final bits\", buff1);\n        }\n      }\n\n    if ((dumpfile != NULL) && (level >= 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateSamples8bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              3769,
              0
            ],
            [
              3867,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateSamples8bits",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "rows": "uint32",
              "spp": "uint16",
              "bps": "uint16",
              "dumpfile": "FILE",
              "format": "int",
              "level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncombineSeparateSamples16bits (uint8 *in[], uint8 *out, uint32 cols,\n                              uint32 rows, uint16 spp, uint16 bps, \n \t                      FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0 /*, bytes_per_sample = 0 */;\n  uint32 src_rowsize, dst_rowsize; \n  uint32 bit_offset, src_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint16 maskbits = 0, matchbits = 0;\n  uint16 buff1 = 0, buff2 = 0;\n  uint8  bytebuff = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateSamples16bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  /* bytes_per_sample = (bps + 7) / 8; */ \n  src_rowsize = ((bps * cols) + 7) / 8;\n  dst_rowsize = ((bps * cols * spp) + 7) / 8;\n  maskbits = (uint16)-1 >> (16 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (16 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        if (little_endian)\n          buff1 = (src[0] << 8) | src[1];\n        else\n          buff1 = (src[1] << 8) | src[0];\n\n\tbuff1 = (buff1 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 8)\n\t  {\n\t    bytebuff = (buff2 >> 8);\n\t    *dst++ = bytebuff;\n\t    ready_bits -= 8;\n\t    /* shift in new bits */\n\t    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n\t    strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t    bytebuff = 0;\n\t    buff2 = (buff2 | (buff1 >> ready_bits));\n\t    strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  {\n\t  dump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\n\t  dump_short (dumpfile, format, \"Match bits\", matchbits);\n\t  dump_data  (dumpfile, format, \"Src   bits\", src, 2);\n\t  dump_short (dumpfile, format, \"Buff1 bits\", buff1);\n\t  dump_short (dumpfile, format, \"Buff2 bits\", buff2);\n\t  dump_byte  (dumpfile, format, \"Write byte\", bytebuff);\n\t  dump_info  (dumpfile, format, \"\",\"Ready bits:  %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n\n    /* catch any trailing bits at the end of the line */\n    if (ready_bits > 0)\n      {\n      bytebuff = (buff2 >> 8);\n      *dst++ = bytebuff;\n      if ((dumpfile != NULL) && (level == 3))\n\t{\n\tdump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, src_byte, src_bit, dst - out);\n\tdump_byte (dumpfile, format, \"Final bits\", bytebuff);\n\t}\n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateSamples16bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              3869,
              0
            ],
            [
              3977,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateSamples16bits",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "rows": "uint32",
              "spp": "uint16",
              "bps": "uint16",
              "dumpfile": "FILE",
              "format": "int",
              "level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncombineSeparateSamples24bits (uint8 *in[], uint8 *out, uint32 cols,\n                              uint32 rows, uint16 spp, uint16 bps, \n\t                      FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0 /*, bytes_per_sample = 0 */;\n  uint32 src_rowsize, dst_rowsize; \n  uint32 bit_offset, src_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint32 maskbits = 0, matchbits = 0;\n  uint32 buff1 = 0, buff2 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateSamples24bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  /* bytes_per_sample = (bps + 7) / 8; */ \n  src_rowsize = ((bps * cols) + 7) / 8;\n  dst_rowsize = ((bps * cols * spp) + 7) / 8;\n  maskbits =  (uint32)-1 >> ( 32 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (32 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        if (little_endian)\n\t  buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n        else\n\t  buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n\tbuff1 = (buff1 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 16)\n\t  {\n\t    bytebuff1 = (buff2 >> 24);\n\t    *dst++ = bytebuff1;\n\t    bytebuff2 = (buff2 >> 16);\n\t    *dst++ = bytebuff2;\n\t    ready_bits -= 16;\n\n\t    /* shift in new bits */\n\t    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n\t    strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t    bytebuff1 = bytebuff2 = 0;\n\t    buff2 = (buff2 | (buff1 >> ready_bits));\n\t    strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  {\n\t  dump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\t  dump_long (dumpfile, format, \"Match bits \", matchbits);\n\t  dump_data (dumpfile, format, \"Src   bits \", src, 4);\n\t  dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n\t  dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n\t  dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n\t  dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n\t  dump_info (dumpfile, format, \"\",\"Ready bits:   %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n\n    /* catch any trailing bits at the end of the line */\n    while (ready_bits > 0)\n      {\n\tbytebuff1 = (buff2 >> 24);\n\t*dst++ = bytebuff1;\n\n\tbuff2 = (buff2 << 8);\n\tbytebuff2 = bytebuff1;\n\tready_bits -= 8;\n      }\n \n    if ((dumpfile != NULL) && (level == 3))\n      {\n      dump_info (dumpfile, format, \"\",\n\t\t   \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t   row + 1, col + 1, src_byte, src_bit, dst - out);\n\n      dump_long (dumpfile, format, \"Match bits \", matchbits);\n      dump_data (dumpfile, format, \"Src   bits \", src, 4);\n      dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n      dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits); \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateSamples24bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n  \n  return (0);\n  }",
          "fn_code_pos": [
            [
              3979,
              0
            ],
            [
              4101,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateSamples24bits",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "rows": "uint32",
              "spp": "uint16",
              "bps": "uint16",
              "dumpfile": "FILE",
              "format": "int",
              "level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncombineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 cols,\n                              uint32 rows, uint16 spp, uint16 bps, \n\t                      FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0 /*, bytes_per_sample = 0, shift_width = 0 */;\n  uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;\n  uint32 src_byte = 0, src_bit = 0;\n  uint32 row, col;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 maskbits = 0, matchbits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateSamples32bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  /* bytes_per_sample = (bps + 7) / 8; */ \n  src_rowsize = ((bps * cols) + 7) / 8;\n  dst_rowsize = ((bps * cols * spp) + 7) / 8;\n  maskbits =  (uint64)-1 >> ( 64 - bps);\n  /* shift_width = ((bps + 7) / 8) + 1; */ \n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (64 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n\t{\n\tsrc = in[s] + src_offset + src_byte;\n\tif (little_endian)\n\t  {\n\t  longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n          longbuff2 = longbuff1;\n\t  }\n\telse\n\t  {\n\t  longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n          longbuff2 = longbuff1;\n\t  }\n\tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;\n\tbuff1 = (buff3 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 32)\n\t  {\n\t  bytebuff1 = (buff2 >> 56);\n\t  *dst++ = bytebuff1;\n\t  bytebuff2 = (buff2 >> 48);\n\t  *dst++ = bytebuff2;\n\t  bytebuff3 = (buff2 >> 40);\n\t  *dst++ = bytebuff3;\n\t  bytebuff4 = (buff2 >> 32);\n\t  *dst++ = bytebuff4;\n\t  ready_bits -= 32;\n                    \n\t  /* shift in new bits */\n\t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n\t  strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n\t  buff2 = (buff2 | (buff1 >> ready_bits));\n\t  strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  { \n\t  dump_info (dumpfile, format, \"\",\n\t\t     \"Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\t  dump_wide (dumpfile, format, \"Match bits \", matchbits);\n\t  dump_data (dumpfile, format, \"Src   bits \", src, 8);\n\t  dump_wide (dumpfile, format, \"Buff1 bits \", buff1);\n\t  dump_wide (dumpfile, format, \"Buff2 bits \", buff2);\n\t  dump_info (dumpfile, format, \"\", \"Ready bits:   %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n    while (ready_bits > 0)\n      {\n      bytebuff1 = (buff2 >> 56);\n      *dst++ = bytebuff1;\n      buff2 = (buff2 << 8);\n      ready_bits -= 8;\n      }\n\n    if ((dumpfile != NULL) && (level == 3))\n      {\n      dump_info (dumpfile, format, \"\",\n\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t row + 1, col + 1, src_byte, src_bit, dst - out);\n\n      dump_long (dumpfile, format, \"Match bits \", matchbits);\n      dump_data (dumpfile, format, \"Src   bits \", src, 4);\n      dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n      dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits); \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateSamples32bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);\n      }\n    }\n  \n  return (0);\n  }",
          "fn_code_pos": [
            [
              4103,
              0
            ],
            [
              4232,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateSamples32bits",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "rows": "uint32",
              "spp": "uint16",
              "bps": "uint16",
              "dumpfile": "FILE",
              "format": "int",
              "level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int \ncombineSeparateTileSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,\n                                 uint32 cols, uint32 rows, uint32 imagewidth,\n                                 uint32 tw, uint16 spp, uint16 bps,\n                                 FILE *dumpfile, int format, int level)\n  {\n  int i, bytes_per_sample;\n  uint32 row, col, col_offset, src_rowsize, dst_rowsize, src_offset;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t s;\n\n  src = srcbuffs[0];\n  dst = out;\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamplesBytes\",\"Invalid buffer address\");\n    return (1);\n    }\n\n  bytes_per_sample = (bps + 7) / 8; \n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = imagewidth * bytes_per_sample * spp;\n  for (row = 0; row < rows; row++)\n    {\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      for (s = 0; s < spp; s++)\n        {\n        dump_info (dumpfile, format, \"combineSeparateTileSamplesBytes\",\"Input data, Sample %d\", s);\n        dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));\n        }\n      }\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n#ifdef DEVELMODE\n    TIFFError(\"\",\"Tile row %4d, Src offset %6d   Dst offset %6d\", \n              row, src_offset, dst - out);\n#endif\n    for (col = 0; col < cols; col++)\n      {\n      col_offset = src_offset + (col * (bps / 8)); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n        src = srcbuffs[s] + col_offset; \n        for (i = 0; i < bytes_per_sample; i++)\n          *(dst + i) = *(src + i);\n        dst += bytes_per_sample;\n        }   \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamplesBytes\",\"Output data, combined samples\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              4234,
              0
            ],
            [
              4293,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateTileSamplesBytes",
            "parameters": {
              "srcbuffs": "unsigned char",
              "out": "unsigned char",
              "cols": "uint32",
              "rows": "uint32",
              "imagewidth": "uint32",
              "tw": "uint32",
              "spp": "uint16",
              "bps": "uint16",
              "dumpfile": "FILE",
              "format": "int",
              "level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncombineSeparateTileSamples8bits (uint8 *in[], uint8 *out, uint32 cols,\n                                 uint32 rows, uint32 imagewidth, \n                                 uint32 tw, uint16 spp, uint16 bps, \n \t                         FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0;\n  uint32 src_rowsize, dst_rowsize, src_offset; \n  uint32 bit_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint8  maskbits = 0, matchbits = 0;\n  uint8  buff1 = 0, buff2 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[32];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamples8bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (8 - src_bit - bps); \n      /* load up next sample from each plane */\n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        buff1 = ((*src) & matchbits) << (src_bit);\n\n        /* If we have a full buffer's worth, write it out */\n        if (ready_bits >= 8)\n          {\n          *dst++ = buff2;\n          buff2 = buff1;\n          ready_bits -= 8;\n          strcpy (action, \"Flush\");\n          }\n        else\n          {\n          buff2 = (buff2 | (buff1 >> ready_bits));\n          strcpy (action, \"Update\");\n          }\n        ready_bits += bps;\n \n        if ((dumpfile != NULL) && (level == 3))\n          {\n          dump_info (dumpfile, format, \"\",\n                   \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);\n          dump_byte (dumpfile, format, \"Match bits\", matchbits);\n          dump_byte (dumpfile, format, \"Src   bits\", *src);\n          dump_byte (dumpfile, format, \"Buff1 bits\", buff1);\n          dump_byte (dumpfile, format, \"Buff2 bits\", buff2);\n          dump_info (dumpfile, format, \"\",\"%s\", action); \n\t  }\n        }\n      }\n\n    if (ready_bits > 0)\n      {\n      buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n      *dst++ = buff1;\n      if ((dumpfile != NULL) && (level == 3))\n        {\n        dump_info (dumpfile, format, \"\",\n\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t         row + 1, col + 1, src_byte, src_bit, dst - out);\n                 dump_byte (dumpfile, format, \"Final bits\", buff1);\n        }\n      }\n\n    if ((dumpfile != NULL) && (level >= 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamples8bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              4295,
              0
            ],
            [
              4392,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateTileSamples8bits",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "rows": "uint32",
              "imagewidth": "uint32",
              "tw": "uint32",
              "spp": "uint16",
              "bps": "uint16",
              "dumpfile": "FILE",
              "format": "int",
              "level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncombineSeparateTileSamples16bits (uint8 *in[], uint8 *out, uint32 cols,\n                                  uint32 rows, uint32 imagewidth, \n                                  uint32 tw, uint16 spp, uint16 bps, \n \t                          FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0;\n  uint32 src_rowsize, dst_rowsize; \n  uint32 bit_offset, src_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint16 maskbits = 0, matchbits = 0;\n  uint16 buff1 = 0, buff2 = 0;\n  uint8  bytebuff = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamples16bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n  maskbits = (uint16)-1 >> (16 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (16 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        if (little_endian)\n          buff1 = (src[0] << 8) | src[1];\n        else\n          buff1 = (src[1] << 8) | src[0];\n\tbuff1 = (buff1 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 8)\n\t  {\n\t    bytebuff = (buff2 >> 8);\n\t    *dst++ = bytebuff;\n\t    ready_bits -= 8;\n\t    /* shift in new bits */\n\t    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n\t    strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t    bytebuff = 0;\n\t    buff2 = (buff2 | (buff1 >> ready_bits));\n\t    strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  {\n\t  dump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\n\t  dump_short (dumpfile, format, \"Match bits\", matchbits);\n\t  dump_data  (dumpfile, format, \"Src   bits\", src, 2);\n\t  dump_short (dumpfile, format, \"Buff1 bits\", buff1);\n\t  dump_short (dumpfile, format, \"Buff2 bits\", buff2);\n\t  dump_byte  (dumpfile, format, \"Write byte\", bytebuff);\n\t  dump_info  (dumpfile, format, \"\",\"Ready bits:  %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n\n    /* catch any trailing bits at the end of the line */\n    if (ready_bits > 0)\n      {\n      bytebuff = (buff2 >> 8);\n      *dst++ = bytebuff;\n      if ((dumpfile != NULL) && (level == 3))\n\t{\n\tdump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, src_byte, src_bit, dst - out);\n\tdump_byte (dumpfile, format, \"Final bits\", bytebuff);\n\t}\n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamples16bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              4394,
              0
            ],
            [
              4501,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateTileSamples16bits",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "rows": "uint32",
              "imagewidth": "uint32",
              "tw": "uint32",
              "spp": "uint16",
              "bps": "uint16",
              "dumpfile": "FILE",
              "format": "int",
              "level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncombineSeparateTileSamples24bits (uint8 *in[], uint8 *out, uint32 cols,\n                                  uint32 rows, uint32 imagewidth, \n                                  uint32 tw, uint16 spp, uint16 bps, \n \t                          FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0;\n  uint32 src_rowsize, dst_rowsize; \n  uint32 bit_offset, src_offset;\n  uint32 row, col, src_byte = 0, src_bit = 0;\n  uint32 maskbits = 0, matchbits = 0;\n  uint32 buff1 = 0, buff2 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamples24bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n  maskbits =  (uint32)-1 >> ( 32 - bps);\n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (32 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n        {\n\tsrc = in[s] + src_offset + src_byte;\n        if (little_endian)\n\t  buff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n        else\n\t  buff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n\tbuff1 = (buff1 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 16)\n\t  {\n\t    bytebuff1 = (buff2 >> 24);\n\t    *dst++ = bytebuff1;\n\t    bytebuff2 = (buff2 >> 16);\n\t    *dst++ = bytebuff2;\n\t    ready_bits -= 16;\n\n\t    /* shift in new bits */\n\t    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n\t    strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t    bytebuff1 = bytebuff2 = 0;\n\t    buff2 = (buff2 | (buff1 >> ready_bits));\n\t    strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  {\n\t  dump_info (dumpfile, format, \"\",\n\t\t       \"Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\t  dump_long (dumpfile, format, \"Match bits \", matchbits);\n\t  dump_data (dumpfile, format, \"Src   bits \", src, 4);\n\t  dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n\t  dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n\t  dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n\t  dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n\t  dump_info (dumpfile, format, \"\",\"Ready bits:   %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n\n    /* catch any trailing bits at the end of the line */\n    while (ready_bits > 0)\n      {\n\tbytebuff1 = (buff2 >> 24);\n\t*dst++ = bytebuff1;\n\n\tbuff2 = (buff2 << 8);\n\tbytebuff2 = bytebuff1;\n\tready_bits -= 8;\n      }\n \n    if ((dumpfile != NULL) && (level == 3))\n      {\n      dump_info (dumpfile, format, \"\",\n\t\t   \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t   row + 1, col + 1, src_byte, src_bit, dst - out);\n\n      dump_long (dumpfile, format, \"Match bits \", matchbits);\n      dump_data (dumpfile, format, \"Src   bits \", src, 4);\n      dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n      dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits); \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamples24bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n      }\n    }\n  \n  return (0);\n  }",
          "fn_code_pos": [
            [
              4503,
              0
            ],
            [
              4625,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateTileSamples24bits",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "rows": "uint32",
              "imagewidth": "uint32",
              "tw": "uint32",
              "spp": "uint16",
              "bps": "uint16",
              "dumpfile": "FILE",
              "format": "int",
              "level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncombineSeparateTileSamples32bits (uint8 *in[], uint8 *out, uint32 cols,\n                                  uint32 rows, uint32 imagewidth, \n                                  uint32 tw, uint16 spp, uint16 bps, \n \t                          FILE *dumpfile, int format, int level)\n  {\n  int    ready_bits = 0 /*, shift_width = 0 */;\n  uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;\n  uint32 src_byte = 0, src_bit = 0;\n  uint32 row, col;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 maskbits = 0, matchbits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  tsample_t s;\n  unsigned char *src = in[0];\n  unsigned char *dst = out;\n  char           action[8];\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"combineSeparateTileSamples32bits\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  src_rowsize = ((bps * tw) + 7) / 8;\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n  maskbits =  (uint64)-1 >> ( 64 - bps);\n  /* shift_width = ((bps + 7) / 8) + 1; */ \n\n  for (row = 0; row < rows; row++)\n    {\n    ready_bits = 0;\n    buff1 = buff2 = 0;\n    dst = out + (row * dst_rowsize);\n    src_offset = row * src_rowsize;\n    for (col = 0; col < cols; col++)\n      {\n      /* Compute src byte(s) and bits within byte(s) */\n      bit_offset = col * bps;\n      src_byte = bit_offset / 8;\n      src_bit  = bit_offset % 8;\n\n      matchbits = maskbits << (64 - src_bit - bps); \n      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n\t{\n\tsrc = in[s] + src_offset + src_byte;\n\tif (little_endian)\n\t  {\n\t  longbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n\t  longbuff2 = longbuff1;\n\t  }\n\telse\n\t  {\n\t  longbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n          longbuff2 = longbuff1;\n\t  }\n\n\tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;\n\tbuff1 = (buff3 & matchbits) << (src_bit);\n\n\t/* If we have a full buffer's worth, write it out */\n\tif (ready_bits >= 32)\n\t  {\n\t  bytebuff1 = (buff2 >> 56);\n\t  *dst++ = bytebuff1;\n\t  bytebuff2 = (buff2 >> 48);\n\t  *dst++ = bytebuff2;\n\t  bytebuff3 = (buff2 >> 40);\n\t  *dst++ = bytebuff3;\n\t  bytebuff4 = (buff2 >> 32);\n\t  *dst++ = bytebuff4;\n\t  ready_bits -= 32;\n                    \n\t  /* shift in new bits */\n\t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n\t  strcpy (action, \"Flush\");\n\t  }\n\telse\n\t  { /* add another bps bits to the buffer */\n\t  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n\t  buff2 = (buff2 | (buff1 >> ready_bits));\n\t  strcpy (action, \"Update\");\n\t  }\n\tready_bits += bps;\n\n\tif ((dumpfile != NULL) && (level == 3))\n\t  { \n\t  dump_info (dumpfile, format, \"\",\n\t\t     \"Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);\n\t  dump_wide (dumpfile, format, \"Match bits \", matchbits);\n\t  dump_data (dumpfile, format, \"Src   bits \", src, 8);\n\t  dump_wide (dumpfile, format, \"Buff1 bits \", buff1);\n\t  dump_wide (dumpfile, format, \"Buff2 bits \", buff2);\n\t  dump_info (dumpfile, format, \"\", \"Ready bits:   %d, %s\", ready_bits, action); \n\t  }\n\t}\n      }\n    while (ready_bits > 0)\n      {\n      bytebuff1 = (buff2 >> 56);\n      *dst++ = bytebuff1;\n      buff2 = (buff2 << 8);\n      ready_bits -= 8;\n      }\n\n    if ((dumpfile != NULL) && (level == 3))\n      {\n      dump_info (dumpfile, format, \"\",\n\t         \"Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d\",\n\t\t row + 1, col + 1, src_byte, src_bit, dst - out);\n\n      dump_long (dumpfile, format, \"Match bits \", matchbits);\n      dump_data (dumpfile, format, \"Src   bits \", src, 4);\n      dump_long (dumpfile, format, \"Buff1 bits \", buff1);\n      dump_long (dumpfile, format, \"Buff2 bits \", buff2);\n      dump_byte (dumpfile, format, \"Write bits1\", bytebuff1);\n      dump_byte (dumpfile, format, \"Write bits2\", bytebuff2);\n      dump_info (dumpfile, format, \"\", \"Ready bits:  %2d\", ready_bits); \n      }\n\n    if ((dumpfile != NULL) && (level == 2))\n      {\n      dump_info (dumpfile, format, \"combineSeparateTileSamples32bits\",\"Output data\");\n      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);\n      }\n    }\n  \n  return (0);\n  }",
          "fn_code_pos": [
            [
              4627,
              0
            ],
            [
              4757,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateTileSamples32bits",
            "parameters": {
              "in": "uint8",
              "out": "uint8",
              "cols": "uint32",
              "rows": "uint32",
              "imagewidth": "uint32",
              "tw": "uint32",
              "spp": "uint16",
              "bps": "uint16",
              "dumpfile": "FILE",
              "format": "int",
              "level": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, \n                                         uint32 width, uint16 spp,\n                                         struct dump_opts *dump)\n  {\n  int i, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;\n  uint32 j;\n  int32  bytes_read = 0;\n  uint16 bps = 0, planar;\n  uint32 nstrips;\n  uint32 strips_per_sample;\n  uint32 src_rowsize, dst_rowsize, rows_processed, rps;\n  uint32 rows_this_strip = 0;\n  tsample_t s;\n  tstrip_t  strip;\n  tsize_t scanlinesize = TIFFScanlineSize(in);\n  tsize_t stripsize    = TIFFStripSize(in);\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *buff = NULL;\n  unsigned char *dst = NULL;\n\n  if (obuf == NULL)\n    {\n    TIFFError(\"readSeparateStripsIntoBuffer\",\"Invalid buffer argument\");\n    return (0);\n    }\n\n  memset (srcbuffs, '\\0', sizeof(srcbuffs));\n  TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n  if (rps > length)\n    rps = length;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if (bytes_per_pixel < (bytes_per_sample + 1))\n    shift_width = bytes_per_pixel;\n  else\n    shift_width = bytes_per_sample + 1;\n\n  src_rowsize = ((bps * width) + 7) / 8;\n  dst_rowsize = ((bps * width * spp) + 7) / 8;\n  dst = obuf;\n\n  if ((dump->infile != NULL) && (dump->level == 3))\n    {\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Image width %d, length %d, Scanline size, %4d bytes\",\n                width, length,  scanlinesize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d, Shift width %d\",\n\t\tbps, spp, shift_width);\n    }\n\n  /* Libtiff seems to assume/require that data for separate planes are \n   * written one complete plane after another and not interleaved in any way.\n   * Multiple scanlines and possibly strips of the same plane must be \n   * written before data for any other plane.\n   */\n  nstrips = TIFFNumberOfStrips(in);\n  strips_per_sample = nstrips /spp;\n\n  /* Add 3 padding bytes for combineSeparateSamples32bits */\n  if( (size_t) stripsize > 0xFFFFFFFFU - 3U )\n  {\n      TIFFError(\"readSeparateStripsIntoBuffer\", \"Integer overflow when calculating buffer size.\");\n      exit(-1);\n  }\n\n  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n    {\n    srcbuffs[s] = NULL;\n    buff = _TIFFmalloc(stripsize + 3);\n    if (!buff)\n      {\n      TIFFError (\"readSeparateStripsIntoBuffer\", \n                 \"Unable to allocate strip read buffer for sample %d\", s);\n      for (i = 0; i < s; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    buff[stripsize] = 0;\n    buff[stripsize+1] = 0;\n    buff[stripsize+2] = 0;\n    srcbuffs[s] = buff;\n    }\n\n  rows_processed = 0;\n  for (j = 0; (j < strips_per_sample) && (result == 1); j++)\n    {\n    for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n      {\n      buff = srcbuffs[s];\n      strip = (s * strips_per_sample) + j; \n      bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);\n      rows_this_strip = bytes_read / src_rowsize;\n      if (bytes_read < 0 && !ignore)\n        {\n        TIFFError(TIFFFileName(in),\n\t          \"Error, can't read strip %lu for sample %d\",\n         \t   (unsigned long) strip, s + 1);\n        result = 0;\n        break;\n        }\n#ifdef DEVELMODE\n      TIFFError(\"\", \"Strip %2d, read %5d bytes for %4d scanlines, shift width %d\", \n\t\tstrip, bytes_read, rows_this_strip, shift_width);\n#endif\n      }\n\n    if (rps > rows_this_strip)\n      rps = rows_this_strip;\n    dst = obuf + (dst_rowsize * rows_processed);\n    if ((bps % 8) == 0)\n      {\n      if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,\n                                       spp, bps, dump->infile, \n                                       dump->format, dump->level))\n        {\n        result = 0;\n        break;\n\t}\n      }\n    else\n      {\n      switch (shift_width)\n        {\n        case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,\n                                                 spp, bps, dump->infile,\n                                                 dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n      \t          }\n\t        break;\n        case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n\t\t  }\n\t        break;\n        case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n       \t          }\n                break;\n        case 4: \n        case 5:\n        case 6:\n        case 7:\n        case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n\t          {\n                  result = 0;\n                  break;\n\t\t  }\n\t        break;\n        default: TIFFError (\"readSeparateStripsIntoBuffer\", \"Unsupported bit depth: %d\", bps);\n                  result = 0;\n                  break;\n        }\n      }\n \n    if ((rows_processed + rps) > length)\n      {\n      rows_processed = length;\n      rps = length - rows_processed;\n      }\n    else\n      rows_processed += rps;\n    }\n\n  /* free any buffers allocated for each plane or scanline and \n   * any temporary buffers \n   */\n  for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n    {\n    buff = srcbuffs[s];\n    if (buff != NULL)\n      _TIFFfree(buff);\n    }\n\n  return (result);\n  }",
          "fn_code_pos": [
            [
              4760,
              0
            ],
            [
              4949,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readSeparateStripsIntoBuffer",
            "parameters": {
              "in": "TIFF",
              "obuf": "uint8",
              "length": "uint32",
              "width": "uint32",
              "spp": "uint16",
              "dump": "struct dump_opts"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nget_page_geometry (char *name, struct pagedef *page)\n    {\n    char *ptr;\n    int n; \n\n    for (ptr = name; *ptr; ptr++)\n      *ptr = (char)tolower((int)*ptr);\n\n    for (n = 0; n < MAX_PAPERNAMES; n++)\n      {\n      if (strcmp(name, PaperTable[n].name) == 0)\n        {\n\tpage->width = PaperTable[n].width;\n\tpage->length = PaperTable[n].length;\n        strncpy (page->name, PaperTable[n].name, 15);\n        page->name[15] = '\\0';\n        return (0);\n        }\n      }\n\n  return (1);\n  }",
          "fn_code_pos": [
            [
              4951,
              0
            ],
            [
              4973,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_page_geometry",
            "parameters": {
              "name": "char",
              "page": "struct pagedef"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ninitPageSetup (struct pagedef *page, struct pageseg *pagelist, \n               struct buffinfo seg_buffs[])\n   {\n   int i; \n\n   strcpy (page->name, \"\");\n   page->mode = PAGE_MODE_NONE;\n   page->res_unit = RESUNIT_NONE;\n   page->hres = 0.0;\n   page->vres = 0.0;\n   page->width = 0.0;\n   page->length = 0.0;\n   page->hmargin = 0.0;\n   page->vmargin = 0.0;\n   page->rows = 0;\n   page->cols = 0;\n   page->orient = ORIENTATION_NONE;\n\n   for (i = 0; i < MAX_SECTIONS; i++)\n     {\n     pagelist[i].x1 = (uint32)0;\n     pagelist[i].x2 = (uint32)0;\n     pagelist[i].y1 = (uint32)0;\n     pagelist[i].y2 = (uint32)0;\n     pagelist[i].buffsize = (uint32)0;\n     pagelist[i].position = 0;\n     pagelist[i].total = 0;\n     }\n\n   for (i = 0; i < MAX_OUTBUFFS; i++)\n     {\n     seg_buffs[i].size = 0;\n     seg_buffs[i].buffer = NULL;\n     }\n   }",
          "fn_code_pos": [
            [
              4976,
              0
            ],
            [
              5011,
              4
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initPageSetup",
            "parameters": {
              "page": "struct pagedef",
              "pagelist": "struct pageseg",
              "seg_buffs": "struct buffinfo"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ninitImageData (struct image_data *image)\n  {\n  image->xres = 0.0;\n  image->yres = 0.0;\n  image->width = 0;\n  image->length = 0;\n  image->res_unit = RESUNIT_NONE;\n  image->bps = 0;\n  image->spp = 0;\n  image->planar = 0;\n  image->photometric = 0;\n  image->orientation = 0;\n  image->compression = COMPRESSION_NONE;\n  image->adjustments = 0;\n  }",
          "fn_code_pos": [
            [
              5013,
              0
            ],
            [
              5028,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initImageData",
            "parameters": {
              "image": "struct image_data"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ninitCropMasks (struct crop_mask *cps)\n   {\n   int i;\n\n   cps->crop_mode = CROP_NONE;\n   cps->res_unit  = RESUNIT_NONE;\n   cps->edge_ref  = EDGE_TOP;\n   cps->width = 0;\n   cps->length = 0;\n   for (i = 0; i < 4; i++)\n     cps->margins[i] = 0.0;\n   cps->bufftotal = (uint32)0;\n   cps->combined_width = (uint32)0;\n   cps->combined_length = (uint32)0;\n   cps->rotation = (uint16)0;\n   cps->photometric = INVERT_DATA_AND_TAG;\n   cps->mirror   = (uint16)0;\n   cps->invert   = (uint16)0;\n   cps->zones    = (uint32)0;\n   cps->regions  = (uint32)0;\n   for (i = 0; i < MAX_REGIONS; i++)\n     {\n     cps->corners[i].X1 = 0.0;\n     cps->corners[i].X2 = 0.0;\n     cps->corners[i].Y1 = 0.0;\n     cps->corners[i].Y2 = 0.0;\n     cps->regionlist[i].x1 = 0;\n     cps->regionlist[i].x2 = 0;\n     cps->regionlist[i].y1 = 0;\n     cps->regionlist[i].y2 = 0;\n     cps->regionlist[i].width = 0;\n     cps->regionlist[i].length = 0;\n     cps->regionlist[i].buffsize = 0;\n     cps->regionlist[i].buffptr = NULL;\n     cps->zonelist[i].position = 0;\n     cps->zonelist[i].total = 0;\n     }\n   cps->exp_mode = ONE_FILE_COMPOSITE;\n   cps->img_mode = COMPOSITE_IMAGES;\n   }",
          "fn_code_pos": [
            [
              5030,
              0
            ],
            [
              5070,
              4
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initCropMasks",
            "parameters": {
              "cps": "struct crop_mask"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void initDumpOptions(struct dump_opts *dump)\n  {\n  dump->debug  = 0;\n  dump->format = DUMP_NONE;\n  dump->level  = 1;\n  sprintf (dump->mode, \"w\");\n  memset (dump->infilename, '\\0', PATH_MAX + 1);\n  memset (dump->outfilename, '\\0',PATH_MAX + 1);\n  dump->infile = NULL;\n  dump->outfile = NULL;\n  }",
          "fn_code_pos": [
            [
              5072,
              0
            ],
            [
              5082,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initDumpOptions",
            "parameters": {
              "dump": "struct dump_opts"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ncomputeInputPixelOffsets(struct crop_mask *crop, struct image_data *image,\n                         struct offset *off)\n  {\n  double scale;\n  float xres, yres;\n  /* Values for these offsets are in pixels from start of image, not bytes,\n   * and are indexed from zero to width - 1 or length - 1 */\n  uint32 tmargin, bmargin, lmargin, rmargin;\n  uint32 startx, endx;   /* offsets of first and last columns to extract */\n  uint32 starty, endy;   /* offsets of first and last row to extract */\n  uint32 width, length, crop_width, crop_length; \n  uint32 i, max_width, max_length, zwidth, zlength, buffsize;\n  uint32 x1, x2, y1, y2;\n\n  if (image->res_unit != RESUNIT_INCH && image->res_unit != RESUNIT_CENTIMETER)\n    {\n    xres = 1.0;\n    yres = 1.0;\n    }\n  else\n    {\n    if (((image->xres == 0) || (image->yres == 0)) && \n         (crop->res_unit != RESUNIT_NONE) &&\n\t((crop->crop_mode & CROP_REGIONS) || (crop->crop_mode & CROP_MARGINS) ||\n \t (crop->crop_mode & CROP_LENGTH)  || (crop->crop_mode & CROP_WIDTH)))\n      {\n      TIFFError(\"computeInputPixelOffsets\", \"Cannot compute margins or fixed size sections without image resolution\");\n      TIFFError(\"computeInputPixelOffsets\", \"Specify units in pixels and try again\");\n      return (-1);\n      }\n    xres = image->xres;\n    yres = image->yres;\n    }\n\n  /* Translate user units to image units */\n  scale = 1.0;\n  switch (crop->res_unit) {\n    case RESUNIT_CENTIMETER:\n         if (image->res_unit == RESUNIT_INCH)\n\t   scale = 1.0/2.54;\n\t break;\n    case RESUNIT_INCH:\n\t if (image->res_unit == RESUNIT_CENTIMETER)\n\t     scale = 2.54;\n\t break;\n    case RESUNIT_NONE: /* Dimensions in pixels */\n    default:\n    break;\n    }\n\n  if (crop->crop_mode & CROP_REGIONS)\n    {\n    max_width = max_length = 0;\n    for (i = 0; i < crop->regions; i++)\n      {\n      if ((crop->res_unit == RESUNIT_INCH) || (crop->res_unit == RESUNIT_CENTIMETER))\n        {\n\tx1 = (uint32) (crop->corners[i].X1 * scale * xres);\n\tx2 = (uint32) (crop->corners[i].X2 * scale * xres);\n\ty1 = (uint32) (crop->corners[i].Y1 * scale * yres);\n\ty2 = (uint32) (crop->corners[i].Y2 * scale * yres);\n        }\n      else\n        {\n\tx1 = (uint32) (crop->corners[i].X1);\n\tx2 = (uint32) (crop->corners[i].X2);\n\ty1 = (uint32) (crop->corners[i].Y1);\n\ty2 = (uint32) (crop->corners[i].Y2);       \n\t}\n      if (x1 < 1)\n        crop->regionlist[i].x1 = 0;\n      else\n        crop->regionlist[i].x1 = (uint32) (x1 - 1);\n\n      if (x2 > image->width - 1)\n        crop->regionlist[i].x2 = image->width - 1;\n      else\n        crop->regionlist[i].x2 = (uint32) (x2 - 1);\n      zwidth  = crop->regionlist[i].x2 - crop->regionlist[i].x1 + 1; \n\n      if (y1 < 1)\n        crop->regionlist[i].y1 = 0;\n      else\n        crop->regionlist[i].y1 = (uint32) (y1 - 1);\n\n      if (y2 > image->length - 1)\n        crop->regionlist[i].y2 = image->length - 1;\n      else\n        crop->regionlist[i].y2 = (uint32) (y2 - 1);\n\n      zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1; \n\n      if (zwidth > max_width)\n        max_width = zwidth;\n      if (zlength > max_length)\n        max_length = zlength;\n\n      buffsize = (uint32)\n          (((zwidth * image->bps * image->spp + 7 ) / 8) * (zlength + 1));\n\n      crop->regionlist[i].buffsize = buffsize;\n      crop->bufftotal += buffsize;\n      if (crop->img_mode == COMPOSITE_IMAGES)\n        {\n        switch (crop->edge_ref)\n          {\n          case EDGE_LEFT:\n          case EDGE_RIGHT:\n               crop->combined_length = zlength;\n               crop->combined_width += zwidth;\n               break;\n          case EDGE_BOTTOM:\n          case EDGE_TOP:  /* width from left, length from top */\n          default:\n               crop->combined_width = zwidth;\n               crop->combined_length += zlength;\n\t       break;\n          }\n\t}\n      }\n    return (0);\n    }\n  \n  /* Convert crop margins into offsets into image\n   * Margins are expressed as pixel rows and columns, not bytes\n   */\n  if (crop->crop_mode & CROP_MARGINS)\n    {\n    if (crop->res_unit != RESUNIT_INCH && crop->res_unit != RESUNIT_CENTIMETER)\n      { /* User has specified pixels as reference unit */\n      tmargin = (uint32)(crop->margins[0]);\n      lmargin = (uint32)(crop->margins[1]);\n      bmargin = (uint32)(crop->margins[2]);\n      rmargin = (uint32)(crop->margins[3]);\n      }\n    else\n      { /* inches or centimeters specified */\n      tmargin = (uint32)(crop->margins[0] * scale * yres);\n      lmargin = (uint32)(crop->margins[1] * scale * xres);\n      bmargin = (uint32)(crop->margins[2] * scale * yres);\n      rmargin = (uint32)(crop->margins[3] * scale * xres);\n      }\n\n    if ((lmargin + rmargin) > image->width)\n      {\n      TIFFError(\"computeInputPixelOffsets\", \"Combined left and right margins exceed image width\");\n      lmargin = (uint32) 0;\n      rmargin = (uint32) 0;\n      return (-1);\n      }\n    if ((tmargin + bmargin) > image->length)\n      {\n      TIFFError(\"computeInputPixelOffsets\", \"Combined top and bottom margins exceed image length\"); \n      tmargin = (uint32) 0; \n      bmargin = (uint32) 0;\n      return (-1);\n      }\n    }\n  else\n    { /* no margins requested */\n    tmargin = (uint32) 0;\n    lmargin = (uint32) 0;\n    bmargin = (uint32) 0;\n    rmargin = (uint32) 0;\n    }\n\n  /* Width, height, and margins are expressed as pixel offsets into image */\n  if (crop->res_unit != RESUNIT_INCH && crop->res_unit != RESUNIT_CENTIMETER)\n    {\n    if (crop->crop_mode & CROP_WIDTH)\n      width = (uint32)crop->width;\n    else\n      width = image->width - lmargin - rmargin;\n\n    if (crop->crop_mode & CROP_LENGTH)\n      length  = (uint32)crop->length;\n    else\n      length = image->length - tmargin - bmargin;\n    }\n  else\n    {\n    if (crop->crop_mode & CROP_WIDTH)\n      width = (uint32)(crop->width * scale * image->xres);\n    else\n      width = image->width - lmargin - rmargin;\n\n    if (crop->crop_mode & CROP_LENGTH)\n      length  = (uint32)(crop->length * scale * image->yres);\n    else\n      length = image->length - tmargin - bmargin;\n    }\n\n  off->tmargin = tmargin;\n  off->bmargin = bmargin;\n  off->lmargin = lmargin;\n  off->rmargin = rmargin;\n\n  /* Calculate regions defined by margins, width, and length. \n   * Coordinates expressed as 0 to imagewidth - 1, imagelength - 1,\n   * since they are used to compute offsets into buffers */\n  switch (crop->edge_ref) {\n    case EDGE_BOTTOM:\n         startx = lmargin;\n         if ((startx + width) >= (image->width - rmargin))\n           endx = image->width - rmargin - 1;\n         else\n           endx = startx + width - 1;\n\n         endy = image->length - bmargin - 1;\n         if ((endy - length) <= tmargin)\n           starty = tmargin;\n         else\n           starty = endy - length + 1;\n         break;\n    case EDGE_RIGHT:\n         endx = image->width - rmargin - 1;\n         if ((endx - width) <= lmargin)\n           startx = lmargin;\n         else\n           startx = endx - width + 1;\n\n         starty = tmargin;\n         if ((starty + length) >= (image->length - bmargin))\n           endy = image->length - bmargin - 1;\n         else\n           endy = starty + length - 1;\n         break;\n    case EDGE_TOP:  /* width from left, length from top */\n    case EDGE_LEFT:\n    default:\n         startx = lmargin;\n         if ((startx + width) >= (image->width - rmargin))\n           endx = image->width - rmargin - 1;\n         else\n           endx = startx + width - 1;\n\n         starty = tmargin;\n         if ((starty + length) >= (image->length - bmargin))\n           endy = image->length - bmargin - 1;\n         else\n           endy = starty + length - 1;\n         break;\n    }\n  off->startx = startx;\n  off->starty = starty;\n  off->endx   = endx;\n  off->endy   = endy;\n\n  crop_width  = endx - startx + 1;\n  crop_length = endy - starty + 1;\n\n  if (crop_width <= 0)\n    {\n    TIFFError(\"computeInputPixelOffsets\", \n               \"Invalid left/right margins and /or image crop width requested\");\n    return (-1);\n    }\n  if (crop_width > image->width)\n    crop_width = image->width;\n\n  if (crop_length <= 0)\n    {\n    TIFFError(\"computeInputPixelOffsets\", \n              \"Invalid top/bottom margins and /or image crop length requested\");\n    return (-1);\n    }\n  if (crop_length > image->length)\n    crop_length = image->length;\n\n  off->crop_width = crop_width;\n  off->crop_length = crop_length;\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              5085,
              0
            ],
            [
              5359,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "computeInputPixelOffsets",
            "parameters": {
              "crop": "struct crop_mask",
              "image": "struct image_data",
              "off": "struct offset"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ngetCropOffsets(struct image_data *image, struct crop_mask *crop, struct dump_opts *dump)\n  {\n  struct offset offsets;\n  int    i;\n  int32  test;\n  uint32 seg, total, need_buff = 0;\n  uint32 buffsize;\n  uint32 zwidth, zlength;\n\n  memset(&offsets, '\\0', sizeof(struct offset));\n  crop->bufftotal = 0;\n  crop->combined_width  = (uint32)0;\n  crop->combined_length = (uint32)0;\n  crop->selections = 0;\n\n  /* Compute pixel offsets if margins or fixed width or length specified */\n  if ((crop->crop_mode & CROP_MARGINS) ||\n      (crop->crop_mode & CROP_REGIONS) ||\n      (crop->crop_mode & CROP_LENGTH)  || \n      (crop->crop_mode & CROP_WIDTH))\n    {\n    if (computeInputPixelOffsets(crop, image, &offsets))\n      {\n      TIFFError (\"getCropOffsets\", \"Unable to compute crop margins\");\n      return (-1);\n      }\n    need_buff = TRUE;\n    crop->selections = crop->regions;\n    /* Regions are only calculated from top and left edges with no margins */\n    if (crop->crop_mode & CROP_REGIONS)\n      return (0);\n    }\n  else\n    { /* cropped area is the full image */\n    offsets.tmargin = 0;\n    offsets.lmargin = 0;\n    offsets.bmargin = 0;\n    offsets.rmargin = 0;\n    offsets.crop_width = image->width;\n    offsets.crop_length = image->length;\n    offsets.startx = 0;\n    offsets.endx = image->width - 1;\n    offsets.starty = 0;\n    offsets.endy = image->length - 1;\n    need_buff = FALSE;\n    }\n\n  if (dump->outfile != NULL)\n    {\n    dump_info (dump->outfile, dump->format, \"\", \"Margins: Top: %d  Left: %d  Bottom: %d  Right: %d\", \n           offsets.tmargin, offsets.lmargin, offsets.bmargin, offsets.rmargin); \n    dump_info (dump->outfile, dump->format, \"\", \"Crop region within margins: Adjusted Width:  %6d  Length: %6d\", \n           offsets.crop_width, offsets.crop_length);\n    }\n\n  if (!(crop->crop_mode & CROP_ZONES)) /* no crop zones requested */\n    {\n    if (need_buff == FALSE)  /* No margins or fixed width or length areas */\n      {\n      crop->selections = 0;\n      crop->combined_width  = image->width;\n      crop->combined_length = image->length;\n      return (0);\n      }\n    else \n      {\n      /* Use one region for margins and fixed width or length areas\n       * even though it was not formally declared as a region.\n       */\n      crop->selections = 1;\n      crop->zones = 1;\n      crop->zonelist[0].total = 1;\n      crop->zonelist[0].position = 1;\n      }\n    }     \n  else\n    crop->selections = crop->zones;\n\n  for (i = 0; i < crop->zones; i++)\n    {\n    seg = crop->zonelist[i].position;\n    total = crop->zonelist[i].total;\n\n    switch (crop->edge_ref) \n      {\n      case EDGE_LEFT: /* zones from left to right, length from top */\n           zlength = offsets.crop_length;\n\t   crop->regionlist[i].y1 = offsets.starty;\n           crop->regionlist[i].y2 = offsets.endy;\n\n           crop->regionlist[i].x1 = offsets.startx + \n                                  (uint32)(offsets.crop_width * 1.0 * (seg - 1) / total);\n           test = (int32)offsets.startx + \n                  (int32)(offsets.crop_width * 1.0 * seg / total);\n           if (test < 1 )\n             crop->regionlist[i].x2 = 0;\n           else\n\t     {\n\t     if (test > (int32)(image->width - 1))\n               crop->regionlist[i].x2 = image->width - 1;\n             else\n\t       crop->regionlist[i].x2 = test - 1;\n             }\n           zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1  + 1;\n\n\t   /* This is passed to extractCropZone or extractCompositeZones */\n           crop->combined_length = (uint32)zlength;\n           if (crop->exp_mode == COMPOSITE_IMAGES)\n             crop->combined_width += (uint32)zwidth;\n           else\n             crop->combined_width = (uint32)zwidth;\n           break;\n      case EDGE_BOTTOM: /* width from left, zones from bottom to top */\n           zwidth = offsets.crop_width;\n\t   crop->regionlist[i].x1 = offsets.startx;\n           crop->regionlist[i].x2 = offsets.endx;\n\n           test = offsets.endy - (uint32)(offsets.crop_length * 1.0 * seg / total);\n           if (test < 1 )\n\t     crop->regionlist[i].y1 = 0;\n           else\n\t     crop->regionlist[i].y1 = test + 1;\n\n           test = offsets.endy - (offsets.crop_length * 1.0 * (seg - 1) / total);\n           if (test < 1 )\n             crop->regionlist[i].y2 = 0;\n           else\n\t     {\n             if (test > (int32)(image->length - 1))\n               crop->regionlist[i].y2 = image->length - 1;\n             else \n               crop->regionlist[i].y2 = test;\n\t     }\n           zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;\n\n\t   /* This is passed to extractCropZone or extractCompositeZones */\n           if (crop->exp_mode == COMPOSITE_IMAGES)\n             crop->combined_length += (uint32)zlength;\n           else\n             crop->combined_length = (uint32)zlength;\n           crop->combined_width = (uint32)zwidth;\n           break;\n      case EDGE_RIGHT: /* zones from right to left, length from top */\n           zlength = offsets.crop_length;\n\t   crop->regionlist[i].y1 = offsets.starty;\n           crop->regionlist[i].y2 = offsets.endy;\n\n           crop->regionlist[i].x1 = offsets.startx +\n                                  (uint32)(offsets.crop_width  * (total - seg) * 1.0 / total);\n           test = offsets.startx + \n\t          (offsets.crop_width * (total - seg + 1) * 1.0 / total);\n           if (test < 1 )\n             crop->regionlist[i].x2 = 0;\n           else\n\t     {\n\t     if (test > (int32)(image->width - 1))\n               crop->regionlist[i].x2 = image->width - 1;\n             else\n               crop->regionlist[i].x2 = test - 1;\n             }\n           zwidth = crop->regionlist[i].x2 - crop->regionlist[i].x1  + 1;\n\n\t   /* This is passed to extractCropZone or extractCompositeZones */\n           crop->combined_length = (uint32)zlength;\n           if (crop->exp_mode == COMPOSITE_IMAGES)\n             crop->combined_width += (uint32)zwidth;\n           else\n             crop->combined_width = (uint32)zwidth;\n           break;\n      case EDGE_TOP: /* width from left, zones from top to bottom */\n      default:\n           zwidth = offsets.crop_width;\n\t   crop->regionlist[i].x1 = offsets.startx;\n           crop->regionlist[i].x2 = offsets.endx;\n\n           crop->regionlist[i].y1 = offsets.starty + (uint32)(offsets.crop_length * 1.0 * (seg - 1) / total);\n           test = offsets.starty + (uint32)(offsets.crop_length * 1.0 * seg / total);\n           if (test < 1 )\n             crop->regionlist[i].y2 = 0;\n           else\n\t     {\n\t     if (test > (int32)(image->length - 1))\n\t       crop->regionlist[i].y2 = image->length - 1;\n             else\n\t       crop->regionlist[i].y2 = test - 1;\n\t     }\n           zlength = crop->regionlist[i].y2 - crop->regionlist[i].y1 + 1;\n\n\t   /* This is passed to extractCropZone or extractCompositeZones */\n           if (crop->exp_mode == COMPOSITE_IMAGES)\n             crop->combined_length += (uint32)zlength;\n           else\n             crop->combined_length = (uint32)zlength;\n           crop->combined_width = (uint32)zwidth;\n           break;\n      } /* end switch statement */\n\n    buffsize = (uint32)\n          ((((zwidth * image->bps * image->spp) + 7 ) / 8) * (zlength + 1));\n    crop->regionlist[i].width = (uint32) zwidth;\n    crop->regionlist[i].length = (uint32) zlength;\n    crop->regionlist[i].buffsize = buffsize;\n    crop->bufftotal += buffsize;\n\n\n  if (dump->outfile != NULL)\n    dump_info (dump->outfile, dump->format, \"\",  \"Zone %d, width: %4d, length: %4d, x1: %4d  x2: %4d  y1: %4d  y2: %4d\",\n                    i + 1, (uint32)zwidth, (uint32)zlength,\n\t\t    crop->regionlist[i].x1, crop->regionlist[i].x2, \n                    crop->regionlist[i].y1, crop->regionlist[i].y2);\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              5372,
              0
            ],
            [
              5586,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getCropOffsets",
            "parameters": {
              "image": "struct image_data",
              "crop": "struct crop_mask",
              "dump": "struct dump_opts"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncomputeOutputPixelOffsets (struct crop_mask *crop, struct image_data *image,\n                           struct pagedef *page, struct pageseg *sections,\n                           struct dump_opts* dump)\n  {\n  double scale;\n  double pwidth, plength;          /* Output page width and length in user units*/\n  uint32 iwidth, ilength;          /* Input image width and length in pixels*/\n  uint32 owidth, olength;          /* Output image width and length in pixels*/\n  uint32 orows, ocols;             /* rows and cols for output */\n  uint32 hmargin, vmargin;         /* Horizontal and vertical margins */\n  uint32 x1, x2, y1, y2, line_bytes;\n  /* unsigned int orientation; */\n  uint32 i, j, k;\n \n  scale = 1.0;\n  if (page->res_unit == RESUNIT_NONE)\n    page->res_unit = image->res_unit;\n\n  switch (image->res_unit) {\n    case RESUNIT_CENTIMETER:\n         if (page->res_unit == RESUNIT_INCH)\n\t   scale = 1.0/2.54;\n\t break;\n    case RESUNIT_INCH:\n\t if (page->res_unit == RESUNIT_CENTIMETER)\n\t     scale = 2.54;\n\t break;\n    case RESUNIT_NONE: /* Dimensions in pixels */\n    default:\n    break;\n    }\n\n  /* get width, height, resolutions of input image selection */\n  if (crop->combined_width > 0)\n    iwidth = crop->combined_width;\n  else\n    iwidth = image->width;\n  if (crop->combined_length > 0)\n    ilength = crop->combined_length;\n  else\n    ilength = image->length;\n\n  if (page->hres <= 1.0)\n    page->hres = image->xres;\n  if (page->vres <= 1.0)\n    page->vres = image->yres;\n\n  if ((page->hres < 1.0) || (page->vres < 1.0))\n    {\n    TIFFError(\"computeOutputPixelOffsets\",\n    \"Invalid horizontal or vertical resolution specified or read from input image\");\n    return (1);\n    }\n\n  /* If no page sizes are being specified, we just use the input image size to\n   * calculate maximum margins that can be taken from image.\n   */\n  if (page->width <= 0)\n    pwidth = iwidth;\n  else\n    pwidth = page->width;\n\n  if (page->length <= 0)\n    plength = ilength;\n  else\n    plength = page->length;\n\n  if (dump->debug)\n    {\n    TIFFError(\"\", \"Page size: %s, Vres: %3.2f, Hres: %3.2f, \"\n                   \"Hmargin: %3.2f, Vmargin: %3.2f\",\n\t     page->name, page->vres, page->hres,\n             page->hmargin, page->vmargin);\n    TIFFError(\"\", \"Res_unit: %d, Scale: %3.2f, Page width: %3.2f, length: %3.2f\", \n           page->res_unit, scale, pwidth, plength);\n    }\n\n  /* compute margins at specified unit and resolution */\n  if (page->mode & PAGE_MODE_MARGINS)\n    {\n    if (page->res_unit == RESUNIT_INCH || page->res_unit == RESUNIT_CENTIMETER)\n      { /* inches or centimeters specified */\n      hmargin = (uint32)(page->hmargin * scale * page->hres * ((image->bps + 7)/ 8));\n      vmargin = (uint32)(page->vmargin * scale * page->vres * ((image->bps + 7)/ 8));\n      }\n    else\n      { /* Otherwise user has specified pixels as reference unit */\n      hmargin = (uint32)(page->hmargin * scale * ((image->bps + 7)/ 8));\n      vmargin = (uint32)(page->vmargin * scale * ((image->bps + 7)/ 8));\n      }\n\n    if ((hmargin * 2.0) > (pwidth * page->hres))\n      {\n      TIFFError(\"computeOutputPixelOffsets\", \n                \"Combined left and right margins exceed page width\");\n      hmargin = (uint32) 0;\n      return (-1);\n      }\n    if ((vmargin * 2.0) > (plength * page->vres))\n      {\n      TIFFError(\"computeOutputPixelOffsets\", \n                \"Combined top and bottom margins exceed page length\"); \n      vmargin = (uint32) 0; \n      return (-1);\n      }\n    }\n  else\n    {\n    hmargin = 0;\n    vmargin = 0;\n    }\n\n  if (page->mode & PAGE_MODE_ROWSCOLS )\n    {\n    /* Maybe someday but not for now */\n    if (page->mode & PAGE_MODE_MARGINS)\n      TIFFError(\"computeOutputPixelOffsets\", \n      \"Output margins cannot be specified with rows and columns\"); \n\n    owidth  = TIFFhowmany(iwidth, page->cols);\n    olength = TIFFhowmany(ilength, page->rows);\n    }\n  else\n    {\n    if (page->mode & PAGE_MODE_PAPERSIZE )\n      {\n      owidth  = (uint32)((pwidth * page->hres) - (hmargin * 2));\n      olength = (uint32)((plength * page->vres) - (vmargin * 2));\n      }\n    else\n      {\n      owidth = (uint32)(iwidth - (hmargin * 2 * page->hres));\n      olength = (uint32)(ilength - (vmargin * 2 * page->vres));\n      }\n    }\n\n  if (owidth > iwidth)\n    owidth = iwidth;\n  if (olength > ilength)\n    olength = ilength;\n\n  /* Compute the number of pages required for Portrait or Landscape */\n  switch (page->orient)\n    {\n    case ORIENTATION_NONE:\n    case ORIENTATION_PORTRAIT:\n         ocols = TIFFhowmany(iwidth, owidth);\n         orows = TIFFhowmany(ilength, olength);\n         /* orientation = ORIENTATION_PORTRAIT; */\n         break;\n\n    case ORIENTATION_LANDSCAPE:\n         ocols = TIFFhowmany(iwidth, olength);\n         orows = TIFFhowmany(ilength, owidth);\n         x1 = olength;\n         olength = owidth;\n         owidth = x1;\n         /* orientation = ORIENTATION_LANDSCAPE; */\n         break;\n\n    case ORIENTATION_AUTO:\n    default:\n         x1 = TIFFhowmany(iwidth, owidth);\n         x2 = TIFFhowmany(ilength, olength); \n         y1 = TIFFhowmany(iwidth, olength);\n         y2 = TIFFhowmany(ilength, owidth); \n\n         if ( (x1 * x2) < (y1 * y2))\n           { /* Portrait */\n           ocols = x1;\n           orows = x2;\n           /* orientation = ORIENTATION_PORTRAIT; */\n\t   }\n         else\n           { /* Landscape */\n           ocols = y1;\n           orows = y2;\n           x1 = olength;\n           olength = owidth;\n           owidth = x1;\n           /* orientation = ORIENTATION_LANDSCAPE; */\n           }\n    }\n\n  if (ocols < 1)\n    ocols = 1;\n  if (orows < 1)\n    orows = 1;\n\n  /* If user did not specify rows and cols, set them from calcuation */\n  if (page->rows < 1)\n    page->rows = orows;\n  if (page->cols < 1)\n    page->cols = ocols;\n\n  line_bytes = TIFFhowmany8(owidth * image->bps) * image->spp;\n\n  if ((page->rows * page->cols) > MAX_SECTIONS)\n   {\n   TIFFError(\"computeOutputPixelOffsets\",\n\t     \"Rows and Columns exceed maximum sections\\nIncrease resolution or reduce sections\");\n   return (-1);\n   }\n\n  /* build the list of offsets for each output section */\n  for (k = 0, i = 0 && k <= MAX_SECTIONS; i < orows; i++)\n    {\n    y1 = (uint32)(olength * i);\n    y2 = (uint32)(olength * (i +  1) - 1);\n    if (y2 >= ilength)\n      y2 = ilength - 1;\n    for (j = 0; j < ocols; j++, k++)\n      {\n      x1 = (uint32)(owidth * j); \n      x2 = (uint32)(owidth * (j + 1) - 1);\n      if (x2 >= iwidth)\n        x2 = iwidth - 1;\n      sections[k].x1 = x1;\n      sections[k].x2 = x2;\n      sections[k].y1 = y1;\n      sections[k].y2 = y2;\n      sections[k].buffsize = line_bytes * olength;\n      sections[k].position = k + 1;\n      sections[k].total = orows * ocols;\n      } \n    } \n  return (0);\n  } /* end computeOutputPixelOffsets */\n\nstatic int\nloadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)\n  {\n  uint32   i;\n  float    xres = 0.0, yres = 0.0;\n  uint32   nstrips = 0, ntiles = 0;\n  uint16   planar = 0;\n  uint16   bps = 0, spp = 0, res_unit = 0;\n  uint16   orientation = 0;\n  uint16   input_compression = 0, input_photometric = 0;\n  uint16   subsampling_horiz, subsampling_vert;\n  uint32   width = 0, length = 0;\n  uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;\n  uint32   tw = 0, tl = 0;       /* Tile width and length */\n  uint32   tile_rowsize = 0;\n  unsigned char *read_buff = NULL;\n  unsigned char *new_buff  = NULL;\n  int      readunit = 0;\n  static   uint32  prev_readsize = 0;\n\n  TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);\n  TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n  TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n  if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))\n    TIFFError(\"loadImage\",\"Image lacks Photometric interpreation tag\");\n  if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))\n    TIFFError(\"loadimage\",\"Image lacks image width tag\");\n  if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))\n    TIFFError(\"loadimage\",\"Image lacks image length tag\");\n  TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);\n  TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);\n  if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))\n    res_unit = RESUNIT_INCH;\n  if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))\n    input_compression = COMPRESSION_NONE;\n\n#ifdef DEBUG2\n  char compressionid[16];\n\n  switch (input_compression)\n    {\n    case COMPRESSION_NONE:\t/* 1  dump mode */\n\t strcpy (compressionid, \"None/dump\");\n         break;         \n    case COMPRESSION_CCITTRLE:\t  /* 2 CCITT modified Huffman RLE */\n\t strcpy (compressionid, \"Huffman RLE\");\n         break;         \n    case COMPRESSION_CCITTFAX3:\t  /* 3 CCITT Group 3 fax encoding */\n\t strcpy (compressionid, \"Group3 Fax\");\n         break;         \n    case COMPRESSION_CCITTFAX4:\t  /* 4 CCITT Group 4 fax encoding */\n\t strcpy (compressionid, \"Group4 Fax\");\n         break;         \n    case COMPRESSION_LZW:\t  /* 5 Lempel-Ziv  & Welch */\n\t strcpy (compressionid, \"LZW\");\n         break;         \n    case COMPRESSION_OJPEG:\t  /* 6 !6.0 JPEG */\n\t strcpy (compressionid, \"Old Jpeg\");\n         break;         \n    case COMPRESSION_JPEG:\t  /* 7 %JPEG DCT compression */\n\t strcpy (compressionid, \"New Jpeg\");\n         break;         \n    case COMPRESSION_NEXT:\t  /* 32766 NeXT 2-bit RLE */\n\t strcpy (compressionid, \"Next RLE\");\n         break;         \n    case COMPRESSION_CCITTRLEW:   /* 32771 #1 w/ word alignment */\n\t strcpy (compressionid, \"CITTRLEW\");\n         break;         \n    case COMPRESSION_PACKBITS:\t  /* 32773 Macintosh RLE */\n\t strcpy (compressionid, \"Mac Packbits\");\n         break;         \n    case COMPRESSION_THUNDERSCAN: /* 32809 ThunderScan RLE */\n\t strcpy (compressionid, \"Thunderscan\");\n         break;         \n    case COMPRESSION_IT8CTPAD:\t  /* 32895 IT8 CT w/padding */\n\t strcpy (compressionid, \"IT8 padded\");\n         break;         \n    case COMPRESSION_IT8LW:\t  /* 32896 IT8 Linework RLE */\n\t strcpy (compressionid, \"IT8 RLE\");\n         break;         \n    case COMPRESSION_IT8MP:\t  /* 32897 IT8 Monochrome picture */\n\t strcpy (compressionid, \"IT8 mono\");\n         break;         \n    case COMPRESSION_IT8BL:\t  /* 32898 IT8 Binary line art */\n\t strcpy (compressionid, \"IT8 lineart\");\n         break;         \n    case COMPRESSION_PIXARFILM:\t  /* 32908 Pixar companded 10bit LZW */\n\t strcpy (compressionid, \"Pixar 10 bit\");\n         break;         \n    case COMPRESSION_PIXARLOG:\t  /* 32909 Pixar companded 11bit ZIP */\n\t strcpy (compressionid, \"Pixar 11bit\");\n         break;         \n    case COMPRESSION_DEFLATE:\t  /* 32946 Deflate compression */\n\t strcpy (compressionid, \"Deflate\");\n         break;         \n    case COMPRESSION_ADOBE_DEFLATE: /* 8 Deflate compression */\n\t strcpy (compressionid, \"Adobe deflate\");\n         break;         \n    default:\n\t strcpy (compressionid, \"None/unknown\");\n         break;         \n    }\n  TIFFError(\"loadImage\", \"Input compression %s\", compressionid);\n#endif\n\n  scanlinesize = TIFFScanlineSize(in);\n  image->bps = bps;\n  image->spp = spp;\n  image->planar = planar;\n  image->width = width;\n  image->length = length;\n  image->xres = xres;\n  image->yres = yres;\n  image->res_unit = res_unit;\n  image->compression = input_compression;\n  image->photometric = input_photometric;\n#ifdef DEBUG2\n  char photometricid[12];\n\n  switch (input_photometric)\n    {\n    case PHOTOMETRIC_MINISWHITE:\n         strcpy (photometricid, \"MinIsWhite\");\n         break;\n    case PHOTOMETRIC_MINISBLACK:\n         strcpy (photometricid, \"MinIsBlack\");\n         break;\n    case PHOTOMETRIC_RGB:\n         strcpy (photometricid, \"RGB\");\n         break;\n    case PHOTOMETRIC_PALETTE:\n         strcpy (photometricid, \"Palette\");\n         break;\n    case PHOTOMETRIC_MASK:\n         strcpy (photometricid, \"Mask\");\n         break;\n    case PHOTOMETRIC_SEPARATED:\n         strcpy (photometricid, \"Separated\");\n         break;\n    case PHOTOMETRIC_YCBCR:\n         strcpy (photometricid, \"YCBCR\");\n         break;\n    case PHOTOMETRIC_CIELAB:\n         strcpy (photometricid, \"CIELab\");\n         break;\n    case PHOTOMETRIC_ICCLAB:\n         strcpy (photometricid, \"ICCLab\");\n         break;\n    case PHOTOMETRIC_ITULAB:\n         strcpy (photometricid, \"ITULab\");\n         break;\n    case PHOTOMETRIC_LOGL:\n         strcpy (photometricid, \"LogL\");\n         break;\n    case PHOTOMETRIC_LOGLUV:\n         strcpy (photometricid, \"LOGLuv\");\n         break;\n    default:\n         strcpy (photometricid, \"Unknown\");\n         break;\n    }\n  TIFFError(\"loadImage\", \"Input photometric interpretation %s\", photometricid);\n\n#endif\n  image->orientation = orientation;\n  switch (orientation)\n    {\n    case 0:\n    case ORIENTATION_TOPLEFT:\n         image->adjustments = 0;\n\t break;\n    case ORIENTATION_TOPRIGHT:\n         image->adjustments = MIRROR_HORIZ;\n\t break;\n    case ORIENTATION_BOTRIGHT:\n         image->adjustments = ROTATECW_180;\n\t break;\n    case ORIENTATION_BOTLEFT:\n         image->adjustments = MIRROR_VERT; \n\t break;\n    case ORIENTATION_LEFTTOP:\n         image->adjustments = MIRROR_VERT | ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTTOP:\n         image->adjustments = ROTATECW_90;\n\t break;\n    case ORIENTATION_RIGHTBOT:\n         image->adjustments = MIRROR_VERT | ROTATECW_270;\n\t break; \n    case ORIENTATION_LEFTBOT:\n         image->adjustments = ROTATECW_270;\n\t break;\n    default:\n         image->adjustments = 0;\n         image->orientation = ORIENTATION_TOPLEFT;\n   }\n\n  if ((bps == 0) || (spp == 0))\n    {\n    TIFFError(\"loadImage\", \"Invalid samples per pixel (%d) or bits per sample (%d)\",\n\t       spp, bps);\n    return (-1);\n    }\n\n  if (TIFFIsTiled(in))\n    {\n    readunit = TILE;\n    tlsize = TIFFTileSize(in);\n    ntiles = TIFFNumberOfTiles(in);\n    TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n    TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\n    tile_rowsize  = TIFFTileRowSize(in);      \n    if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be tiled, but the number of tiles, tile size, or tile rowsize is zero.\");\n\texit(-1);\n    }\n    buffsize = tlsize * ntiles;\n    if (tlsize != (buffsize / ntiles))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n\n    if (buffsize < (uint32)(ntiles * tl * tile_rowsize))\n      {\n      buffsize = ntiles * tl * tile_rowsize;\n      if (ntiles != (buffsize / tl / tile_rowsize))\n      {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n      }\n      \n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu\",\n                tlsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\", \n                 \"Tilesize: %u, Number of Tiles: %u, Tile row size: %u\",\n                 tlsize, ntiles, tile_rowsize);\n    }\n  else\n    {\n    uint32 buffsize_check;\n    readunit = STRIP;\n    TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n    stsize = TIFFStripSize(in);\n    nstrips = TIFFNumberOfStrips(in);\n    if (nstrips == 0 || stsize == 0)\n    {\n\tTIFFError(\"loadImage\", \"File appears to be striped, but the number of stipes or stripe size is zero.\");\n\texit(-1);\n    }\n\n    buffsize = stsize * nstrips;\n    if (stsize != (buffsize / nstrips))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow when calculating buffer size\");\n\texit(-1);\n    }\n    buffsize_check = ((length * width * spp * bps) + 7);\n    if (length != ((buffsize_check - 7) / width / spp / bps))\n    {\n\tTIFFError(\"loadImage\", \"Integer overflow detected.\");\n\texit(-1);\n    }\n    if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))\n      {\n      buffsize =  ((length * width * spp * bps) + 7) / 8;\n#ifdef DEBUG2\n      TIFFError(\"loadImage\",\n\t        \"Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu\",\n                stsize, (unsigned long)buffsize);\n#endif\n      }\n    \n    if (dump->infile != NULL)\n      dump_info (dump->infile, dump->format, \"\",\n                 \"Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u\",\n\t\t stsize, nstrips, rowsperstrip, scanlinesize);\n    }\n  \n  if (input_compression == COMPRESSION_JPEG)\n    {  /* Force conversion to RGB */\n    jpegcolormode = JPEGCOLORMODE_RGB;\n    TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n  /* The clause up to the read statement is taken from Tom Lane's tiffcp patch */\n  else \n    {   /* Otherwise, can't handle subsampled input */\n    if (input_photometric == PHOTOMETRIC_YCBCR)\n      {\n      TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n \t\t           &subsampling_horiz, &subsampling_vert);\n      if (subsampling_horiz != 1 || subsampling_vert != 1)\n        {\n\tTIFFError(\"loadImage\", \n\t\t\"Can't copy/convert subsampled image with subsampling %d horiz %d vert\",\n                subsampling_horiz, subsampling_vert);\n        return (-1);\n        }\n\t}\n    }\n \n  read_buff = *read_ptr;\n  /* +3 : add a few guard bytes since reverseSamples16bits() can read a bit */\n  /* outside buffer */\n  if (!read_buff)\n  {\n    if( buffsize > 0xFFFFFFFFU - 3 )\n    {\n        TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n        return (-1);\n    }\n    read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n  }\n  else\n    {\n    if (prev_readsize < buffsize)\n    {\n      if( buffsize > 0xFFFFFFFFU - 3 )\n      {\n          TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n          return (-1);\n      }\n      new_buff = _TIFFrealloc(read_buff, buffsize+3);\n      if (!new_buff)\n        {\n\tfree (read_buff);\n        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);\n        }\n      else\n        read_buff = new_buff;\n      }\n    }\n  if (!read_buff)\n    {\n    TIFFError(\"loadImage\", \"Unable to allocate/reallocate read buffer\");\n    return (-1);\n    }\n\n  read_buff[buffsize] = 0;\n  read_buff[buffsize+1] = 0;\n  read_buff[buffsize+2] = 0;\n\n  prev_readsize = buffsize;\n  *read_ptr = read_buff;\n\n  /* N.B. The read functions used copy separate plane data into a buffer as interleaved\n   * samples rather than separate planes so the same logic works to extract regions\n   * regardless of the way the data are organized in the input file.\n   */\n  switch (readunit) {\n    case STRIP:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t     if (!(readContigStripsIntoBuffer(in, read_buff)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous strips into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate strips into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n\n    case TILE:\n         if (planar == PLANARCONFIG_CONTIG)\n           {\n\t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read contiguous tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         else\n           {\n\t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n\t     {\n\t     TIFFError(\"loadImage\", \"Unable to read separate tiles into buffer\");\n\t     return (-1);\n             }\n           }\n         break;\n    default: TIFFError(\"loadImage\", \"Unsupported image file format\");\n          return (-1);\n          break;\n    }\n  if ((dump->infile != NULL) && (dump->level == 2))\n    {\n    dump_info  (dump->infile, dump->format, \"loadImage\", \n                \"Image width %d, length %d, Raw image data, %4d bytes\",\n                width, length,  buffsize);\n    dump_info  (dump->infile, dump->format, \"\", \n                \"Bits per sample %d, Samples per pixel %d\", bps, spp);\n\n    for (i = 0; i < length; i++)\n      dump_buffer(dump->infile, dump->format, 1, scanlinesize, \n                  i, read_buff + (i * scanlinesize));\n    }\n  return (0);\n  }   /* end loadImage */\n\nstatic int  correct_orientation(struct image_data *image, unsigned char **work_buff_ptr)\n  {\n  uint16 mirror, rotation;\n  unsigned char *work_buff;\n\n  work_buff = *work_buff_ptr;\n  if ((image == NULL) || (work_buff == NULL))\n    {\n    TIFFError (\"correct_orientatin\", \"Invalid image or buffer pointer\");\n    return (-1);\n    }\n\n  if ((image->adjustments & MIRROR_HORIZ) || (image->adjustments & MIRROR_VERT))\n    {\n    mirror = (uint16)(image->adjustments & MIRROR_BOTH);\n    if (mirrorImage(image->spp, image->bps, mirror, \n        image->width, image->length, work_buff))\n      {\n      TIFFError (\"correct_orientation\", \"Unable to mirror image\");\n      return (-1);\n      }\n    }\n\n  if (image->adjustments & ROTATE_ANY)\n    {\n    if (image->adjustments & ROTATECW_90)\n      rotation = (uint16) 90;\n    else\n    if (image->adjustments & ROTATECW_180)\n      rotation = (uint16) 180;\n    else\n    if (image->adjustments & ROTATECW_270)\n      rotation = (uint16) 270;\n    else\n      {\n      TIFFError (\"correct_orientation\", \"Invalid rotation value: %d\", \n                  image->adjustments & ROTATE_ANY);\n      return (-1);\n      }\n \n    if (rotateImage(rotation, image, &image->width, &image->length, work_buff_ptr))\n      {\n      TIFFError (\"correct_orientation\", \"Unable to rotate image\");\n      return (-1);\n      }\n    image->orientation = ORIENTATION_TOPLEFT;\n    }\n\n  return (0);\n  } /* end correct_orientation */\n\n\n/* Extract multiple zones from an image and combine into a single composite image */\nstatic int\nextractCompositeRegions(struct image_data *image,  struct crop_mask *crop, \n                        unsigned char *read_buff, unsigned char *crop_buff)\n  {\n  int       shift_width, bytes_per_sample, bytes_per_pixel;\n  uint32    i, trailing_bits, prev_trailing_bits;\n  uint32    row, first_row, last_row, first_col, last_col;\n  uint32    src_rowsize, dst_rowsize, src_offset, dst_offset;\n  uint32    crop_width, crop_length, img_width /*, img_length */;\n  uint32    prev_length, prev_width, composite_width;\n  uint16    bps, spp;\n  uint8    *src, *dst;\n  tsample_t count, sample = 0;   /* Update to extract one or more samples */\n\n  img_width = image->width;\n  /* img_length = image->length; */\n  bps = image->bps;\n  spp = image->spp;\n  count = spp;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if ((bps % 8) == 0)\n    shift_width = 0;\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n  src = read_buff;\n  dst = crop_buff;\n\n  /* These are setup for adding additional sections */\n  prev_width = prev_length = 0;\n  prev_trailing_bits = trailing_bits = 0;\n  composite_width = crop->combined_width;\n  crop->combined_width = 0;\n  crop->combined_length = 0;\n\n  for (i = 0; i < crop->selections; i++)\n    {\n    /* rows, columns, width, length are expressed in pixels */\n    first_row = crop->regionlist[i].y1;\n    last_row  = crop->regionlist[i].y2;\n    first_col = crop->regionlist[i].x1;\n    last_col  = crop->regionlist[i].x2;\n\n    crop_width = last_col - first_col + 1;\n    crop_length = last_row - first_row + 1;\n\n    /* These should not be needed for composite images */\n    crop->regionlist[i].width = crop_width;\n    crop->regionlist[i].length = crop_length;\n    crop->regionlist[i].buffptr = crop_buff;\n\n    src_rowsize = ((img_width * bps * spp) + 7) / 8;\n    dst_rowsize = (((crop_width * bps * count) + 7) / 8);\n\n    switch (crop->edge_ref)\n      {\n      default:\n      case EDGE_TOP:\n      case EDGE_BOTTOM:\n\t   if ((i > 0) && (crop_width != crop->regionlist[i - 1].width))\n             {\n\t     TIFFError (\"extractCompositeRegions\", \n                          \"Only equal width regions can be combined for -E top or bottom\");\n\t     return (1);\n             }\n\n           crop->combined_width = crop_width;\n           crop->combined_length += crop_length;\n\n           for (row = first_row; row <= last_row; row++)\n             {\n\t     src_offset = row * src_rowsize;\n\t     dst_offset = (row - first_row) * dst_rowsize;\n             src = read_buff + src_offset;\n             dst = crop_buff + dst_offset + (prev_length * dst_rowsize);\n             switch (shift_width)\n               {\n               case 0: if (extractContigSamplesBytes (src, dst, img_width, sample,\n                                                      spp, bps, count, first_col,\n                                                      last_col + 1))\n                         {\n\t\t         TIFFError(\"extractCompositeRegions\",\n                                   \"Unable to extract row %d\", row);\n\t\t         return (1);\n\t\t         }\n\t\t       break;\n               case 1: if (bps == 1)\n                         { \n                         if (extractContigSamplesShifted8bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                           {\n\t\t           TIFFError(\"extractCompositeRegions\",\n                                     \"Unable to extract row %d\", row);\n\t\t           return (1);\n\t\t           }\n\t\t         break;\n\t\t\t }\n                       else\n                         if (extractContigSamplesShifted16bits (src, dst, img_width,\n                                                                sample, spp, bps, count, \n                                                                first_col, last_col + 1,\n                                                                prev_trailing_bits))\n                           {\n\t\t           TIFFError(\"extractCompositeRegions\",\n                                     \"Unable to extract row %d\", row);\n\t\t           return (1);\n\t\t           }\n\t\t        break;\n               case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                          {\n\t\t          TIFFError(\"extractCompositeRegions\",\n                                    \"Unable to extract row %d\", row);\n\t\t          return (1);\n\t\t          }\n\t\t        break;\n               case 3:\n               case 4:\n               case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                          {\n\t\t          TIFFError(\"extractCompositeRegions\",\n                                    \"Unable to extract row %d\", row);\n\t\t          return (1);\n\t\t          }\n\t\t        break;\n               default: TIFFError(\"extractCompositeRegions\", \"Unsupported bit depth %d\", bps);\n\t\t        return (1);\n\t       }\n             }\n           prev_length += crop_length;\n\t   break;\n      case EDGE_LEFT:  /* splice the pieces of each row together, side by side */\n      case EDGE_RIGHT:\n\t   if ((i > 0) && (crop_length != crop->regionlist[i - 1].length))\n             {\n\t     TIFFError (\"extractCompositeRegions\", \n                          \"Only equal length regions can be combined for -E left or right\");\n\t     return (1);\n             }\n           crop->combined_width += crop_width;\n           crop->combined_length = crop_length;\n           dst_rowsize = (((composite_width * bps * count) + 7) / 8);\n           trailing_bits = (crop_width * bps * count) % 8;\n           for (row = first_row; row <= last_row; row++)\n             {\n\t     src_offset = row * src_rowsize;\n\t     dst_offset = (row - first_row) * dst_rowsize;\n             src = read_buff + src_offset;\n             dst = crop_buff + dst_offset + prev_width;\n\n             switch (shift_width)\n               {\n               case 0: if (extractContigSamplesBytes (src, dst, img_width,\n                                                      sample, spp, bps, count,\n                                                      first_col, last_col + 1))\n                         {\n\t\t         TIFFError(\"extractCompositeRegions\",\n                                   \"Unable to extract row %d\", row);\n\t\t         return (1);\n\t\t         }\n\t\t       break;\n               case 1: if (bps == 1)\n                         { \n                         if (extractContigSamplesShifted8bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                           {\n\t\t           TIFFError(\"extractCompositeRegions\",\n                                     \"Unable to extract row %d\", row);\n\t\t           return (1);\n\t\t           }\n\t\t         break;\n\t\t\t }\n                       else\n                         if (extractContigSamplesShifted16bits (src, dst, img_width,\n                                                                sample, spp, bps, count, \n                                                                first_col, last_col + 1,\n                                                                prev_trailing_bits))\n                           {\n\t\t           TIFFError(\"extractCompositeRegions\",\n                                     \"Unable to extract row %d\", row);\n\t\t           return (1);\n\t\t           }\n\t\t        break;\n              case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                          {\n\t\t          TIFFError(\"extractCompositeRegions\",\n                                    \"Unable to extract row %d\", row);\n\t\t          return (1);\n\t\t          }\n\t\t        break;\n               case 3:\n               case 4:\n               case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,\n                                                               sample, spp, bps, count, \n                                                               first_col, last_col + 1,\n                                                               prev_trailing_bits))\n                          {\n\t\t          TIFFError(\"extractCompositeRegions\",\n                                    \"Unable to extract row %d\", row);\n\t\t          return (1);\n\t\t          }\n\t\t        break;\n               default: TIFFError(\"extractCompositeRegions\", \"Unsupported bit depth %d\", bps);\n\t\t        return (1);\n\t       }\n\t     }\n\t   prev_width += (crop_width * bps * count) / 8;\n           prev_trailing_bits += trailing_bits;\n           if (prev_trailing_bits > 7)\n\t     prev_trailing_bits-= 8;\n\t   break;\n      }\n    }\n  if (crop->combined_width != composite_width)\n    TIFFError(\"combineSeparateRegions\",\"Combined width does not match composite width\");\n      \n  return (0);\n  }  /* end extractCompositeRegions */\n\n/* Copy a single region of input buffer to an output buffer. \n * The read functions used copy separate plane data into a buffer \n * as interleaved samples rather than separate planes so the same\n * logic works to extract regions regardless of the way the data \n * are organized in the input file. This function can be used to\n * extract one or more samples from the input image by updating the \n * parameters for starting sample and number of samples to copy in the\n * fifth and eighth arguments of the call to extractContigSamples.\n * They would be passed as new elements of the crop_mask struct.\n */\n\nstatic int\nextractSeparateRegion(struct image_data *image,  struct crop_mask *crop,\n                      unsigned char *read_buff, unsigned char *crop_buff,\n                      int region)\n  {\n  int     shift_width, prev_trailing_bits = 0;\n  uint32  bytes_per_sample, bytes_per_pixel;\n  uint32  src_rowsize, dst_rowsize;\n  uint32  row, first_row, last_row, first_col, last_col;\n  uint32  src_offset, dst_offset;\n  uint32  crop_width, crop_length, img_width /*, img_length */;\n  uint16  bps, spp;\n  uint8  *src, *dst;\n  tsample_t count, sample = 0;   /* Update to extract more or more samples */\n\n  img_width = image->width;\n  /* img_length = image->length; */\n  bps = image->bps;\n  spp = image->spp;\n  count = spp;\n\n  bytes_per_sample = (bps + 7) / 8; \n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if ((bps % 8) == 0)\n    shift_width = 0; /* Byte aligned data only */\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n\n  /* rows, columns, width, length are expressed in pixels */\n  first_row = crop->regionlist[region].y1;\n  last_row  = crop->regionlist[region].y2;\n  first_col = crop->regionlist[region].x1;\n  last_col  = crop->regionlist[region].x2;\n\n  crop_width = last_col - first_col + 1;\n  crop_length = last_row - first_row + 1;\n\n  crop->regionlist[region].width = crop_width;\n  crop->regionlist[region].length = crop_length;\n  crop->regionlist[region].buffptr = crop_buff;\n\n  src = read_buff;\n  dst = crop_buff;\n  src_rowsize = ((img_width * bps * spp) + 7) / 8;\n  dst_rowsize = (((crop_width * bps * spp) + 7) / 8);\n\n  for (row = first_row; row <= last_row; row++)\n    {\n    src_offset = row * src_rowsize;\n    dst_offset = (row  - first_row) * dst_rowsize;\n    src = read_buff + src_offset;\n    dst = crop_buff + dst_offset;\n\n    switch (shift_width)\n      {\n      case 0: if (extractContigSamplesBytes (src, dst, img_width, sample,\n                                             spp, bps, count, first_col,\n                                             last_col + 1))\n                {\n\t        TIFFError(\"extractSeparateRegion\",\n                          \"Unable to extract row %d\", row);\n\t        return (1);\n\t        }\n\t      break;\n      case 1: if (bps == 1)\n                { \n                if (extractContigSamplesShifted8bits (src, dst, img_width,\n                                                      sample, spp, bps, count, \n                                                      first_col, last_col + 1,\n                                                      prev_trailing_bits))\n                  {\n\t\t  TIFFError(\"extractSeparateRegion\",\n                            \"Unable to extract row %d\", row);\n\t\t  return (1);\n\t\t  }\n\t\t  break;\n\t\t}\n              else\n                if (extractContigSamplesShifted16bits (src, dst, img_width,\n                                                       sample, spp, bps, count, \n                                                       first_col, last_col + 1,\n                                                       prev_trailing_bits))\n                  {\n\t\t  TIFFError(\"extractSeparateRegion\",\n                            \"Unable to extract row %d\", row);\n\t\t  return (1);\n\t\t  }\n\t      break;\n      case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,\n                                                     sample, spp, bps, count, \n                                                     first_col, last_col + 1,\n                                                     prev_trailing_bits))\n                {\n\t\tTIFFError(\"extractSeparateRegion\",\n                          \"Unable to extract row %d\", row);\n\t\treturn (1);\n\t\t}\n\t      break;\n      case 3:\n      case 4:\n      case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,\n                                                     sample, spp, bps, count, \n                                                     first_col, last_col + 1,\n                                                     prev_trailing_bits))\n                {\n\t\tTIFFError(\"extractSeparateRegion\",\n                          \"Unable to extract row %d\", row);\n\t\treturn (1);\n\t\t}\n\t      break;\n      default: TIFFError(\"extractSeparateRegion\", \"Unsupported bit depth %d\", bps);\n\t       return (1);\n      }\n    }\n          \n  return (0);\n  }  /* end extractSeparateRegion */\n\nstatic int\nextractImageSection(struct image_data *image, struct pageseg *section, \n                    unsigned char *src_buff, unsigned char *sect_buff)\n  {\n  unsigned  char  bytebuff1, bytebuff2;\n#ifdef DEVELMODE\n  /* unsigned  char *src, *dst; */\n#endif\n\n  uint32    img_width, img_rowsize;\n#ifdef DEVELMODE\n  uint32    img_length;\n#endif\n  uint32    j, shift1, shift2, trailing_bits;\n  uint32    row, first_row, last_row, first_col, last_col;\n  uint32    src_offset, dst_offset, row_offset, col_offset;\n  uint32    offset1, offset2, full_bytes;\n  uint32    sect_width;\n#ifdef DEVELMODE\n  uint32    sect_length;\n#endif\n  uint16    bps, spp;\n\n#ifdef DEVELMODE\n  int      k;\n  unsigned char bitset;\n  static char *bitarray = NULL;\n#endif\n\n  img_width = image->width;\n#ifdef DEVELMODE\n  img_length = image->length;\n#endif\n  bps = image->bps;\n  spp = image->spp;\n\n#ifdef DEVELMODE\n  /* src = src_buff; */\n  /* dst = sect_buff; */\n#endif\n  src_offset = 0;\n  dst_offset = 0;\n\n#ifdef DEVELMODE\n  if (bitarray == NULL)\n    {\n    if ((bitarray = (char *)malloc(img_width)) == NULL)\n      {\n      TIFFError (\"\", \"DEBUG: Unable to allocate debugging bitarray\");\n      return (-1);\n      }\n    }\n#endif\n\n  /* rows, columns, width, length are expressed in pixels */\n  first_row = section->y1;\n  last_row  = section->y2;\n  first_col = section->x1;\n  last_col  = section->x2;\n\n  sect_width = last_col - first_col + 1;\n#ifdef DEVELMODE\n  sect_length = last_row - first_row + 1;\n#endif\n  img_rowsize = ((img_width * bps + 7) / 8) * spp;\n  full_bytes = (sect_width * spp * bps) / 8;   /* number of COMPLETE bytes per row in section */\n  trailing_bits = (sect_width * bps) % 8;\n\n#ifdef DEVELMODE\n    TIFFError (\"\", \"First row: %d, last row: %d, First col: %d, last col: %d\\n\",\n           first_row, last_row, first_col, last_col);\n    TIFFError (\"\", \"Image width: %d, Image length: %d, bps: %d, spp: %d\\n\",\n\t   img_width, img_length, bps, spp);\n    TIFFError (\"\", \"Sect  width: %d,  Sect length: %d, full bytes: %d trailing bits %d\\n\", \n           sect_width, sect_length, full_bytes, trailing_bits);\n#endif\n\n  if ((bps % 8) == 0)\n    {\n    col_offset = first_col * spp * bps / 8;\n    for (row = first_row; row <= last_row; row++)\n      {\n      /* row_offset = row * img_width * spp * bps / 8; */\n      row_offset = row * img_rowsize;\n      src_offset = row_offset + col_offset;\n\n#ifdef DEVELMODE\n        TIFFError (\"\", \"Src offset: %8d, Dst offset: %8d\", src_offset, dst_offset); \n#endif\n      _TIFFmemcpy (sect_buff + dst_offset, src_buff + src_offset, full_bytes);\n      dst_offset += full_bytes;\n      }        \n    }\n  else\n    { /* bps != 8 */\n    shift1  = spp * ((first_col * bps) % 8);\n    shift2  = spp * ((last_col * bps) % 8);\n    for (row = first_row; row <= last_row; row++)\n      {\n      /* pull out the first byte */\n      row_offset = row * img_rowsize;\n      offset1 = row_offset + (first_col * bps / 8);\n      offset2 = row_offset + (last_col * bps / 8);\n\n#ifdef DEVELMODE\n      for (j = 0, k = 7; j < 8; j++, k--)\n        {\n        bitset = *(src_buff + offset1) & (((unsigned char)1 << k)) ? 1 : 0;\n        sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n        }\n      sprintf(&bitarray[8], \" \");\n      sprintf(&bitarray[9], \" \");\n      for (j = 10, k = 7; j < 18; j++, k--)\n        {\n        bitset = *(src_buff + offset2) & (((unsigned char)1 << k)) ? 1 : 0;\n        sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n        }\n      bitarray[18] = '\\0';\n      TIFFError (\"\", \"Row: %3d Offset1: %d,  Shift1: %d,    Offset2: %d,  Shift2:  %d\\n\", \n                 row, offset1, shift1, offset2, shift2); \n#endif\n\n      bytebuff1 = bytebuff2 = 0;\n      if (shift1 == 0) /* the region is byte and sample aligned */\n        {\n\t_TIFFmemcpy (sect_buff + dst_offset, src_buff + offset1, full_bytes);\n\n#ifdef DEVELMODE\n\tTIFFError (\"\", \"        Aligned data src offset1: %8d, Dst offset: %8d\\n\", offset1, dst_offset); \n\tsprintf(&bitarray[18], \"\\n\");\n\tsprintf(&bitarray[19], \"\\t\");\n        for (j = 20, k = 7; j < 28; j++, k--)\n          {\n          bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n          sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n          }\n        bitarray[28] = ' ';\n        bitarray[29] = ' ';\n#endif\n        dst_offset += full_bytes;\n\n        if (trailing_bits != 0)\n          {\n\t  bytebuff2 = src_buff[offset2] & ((unsigned char)255 << (7 - shift2));\n          sect_buff[dst_offset] = bytebuff2;\n#ifdef DEVELMODE\n\t  TIFFError (\"\", \"        Trailing bits src offset:  %8d, Dst offset: %8d\\n\", \n                              offset2, dst_offset); \n          for (j = 30, k = 7; j < 38; j++, k--)\n            {\n            bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n            sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n            }\n          bitarray[38] = '\\0';\n          TIFFError (\"\", \"\\tFirst and last bytes before and after masking:\\n\\t%s\\n\\n\", bitarray);\n#endif\n          dst_offset++;\n          }\n        }\n      else   /* each destination byte will have to be built from two source bytes*/\n        {\n#ifdef DEVELMODE\n\t  TIFFError (\"\", \"        Unalligned data src offset: %8d, Dst offset: %8d\\n\", offset1 , dst_offset); \n#endif\n        for (j = 0; j <= full_bytes; j++) \n          {\n\t  bytebuff1 = src_buff[offset1 + j] & ((unsigned char)255 >> shift1);\n\t  bytebuff2 = src_buff[offset1 + j + 1] & ((unsigned char)255 << (7 - shift1));\n          sect_buff[dst_offset + j] = (bytebuff1 << shift1) | (bytebuff2 >> (8 - shift1));\n          }\n#ifdef DEVELMODE\n\tsprintf(&bitarray[18], \"\\n\");\n\tsprintf(&bitarray[19], \"\\t\");\n        for (j = 20, k = 7; j < 28; j++, k--)\n          {\n          bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n          sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n          }\n        bitarray[28] = ' ';\n        bitarray[29] = ' ';\n#endif\n        dst_offset += full_bytes;\n\n        if (trailing_bits != 0)\n          {\n#ifdef DEVELMODE\n\t    TIFFError (\"\", \"        Trailing bits   src offset: %8d, Dst offset: %8d\\n\", offset1 + full_bytes, dst_offset); \n#endif\n\t  if (shift2 > shift1)\n            {\n\t    bytebuff1 = src_buff[offset1 + full_bytes] & ((unsigned char)255 << (7 - shift2));\n            bytebuff2 = bytebuff1 & ((unsigned char)255 << shift1);\n            sect_buff[dst_offset] = bytebuff2;\n#ifdef DEVELMODE\n\t    TIFFError (\"\", \"        Shift2 > Shift1\\n\"); \n#endif\n            }\n          else\n            {\n\t    if (shift2 < shift1)\n              {\n              bytebuff2 = ((unsigned char)255 << (shift1 - shift2 - 1));\n\t      sect_buff[dst_offset] &= bytebuff2;\n#ifdef DEVELMODE\n\t      TIFFError (\"\", \"        Shift2 < Shift1\\n\"); \n#endif\n              }\n#ifdef DEVELMODE\n            else\n\t      TIFFError (\"\", \"        Shift2 == Shift1\\n\"); \n#endif\n            }\n\t  }\n#ifdef DEVELMODE\n\t  sprintf(&bitarray[28], \" \");\n\t  sprintf(&bitarray[29], \" \");\n          for (j = 30, k = 7; j < 38; j++, k--)\n            {\n            bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n            sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n            }\n          bitarray[38] = '\\0';\n          TIFFError (\"\", \"\\tFirst and last bytes before and after masking:\\n\\t%s\\n\\n\", bitarray);\n#endif\n        dst_offset++;\n        }\n      }\n    }\n\n  return (0);\n  } /* end extractImageSection */\n\nstatic int \nwriteSelections(TIFF *in, TIFF **out, struct crop_mask *crop, \n                struct image_data *image, struct dump_opts *dump,\n                struct buffinfo seg_buffs[], char *mp, char *filename, \n                unsigned int *page, unsigned int total_pages)\n  {\n  int i, page_count;\n  int autoindex = 0;\n  unsigned char *crop_buff = NULL;\n\n  /* Where we open a new file depends on the export mode */  \n  switch (crop->exp_mode)\n    {\n    case ONE_FILE_COMPOSITE: /* Regions combined into single image */\n         autoindex = 0;\n         crop_buff = seg_buffs[0].buffer;\n         if (update_output_file (out, mp, autoindex, filename, page))\n           return (1);\n         page_count = total_pages;\n         if (writeCroppedImage(in, *out, image, dump,\n                               crop->combined_width, \n                               crop->combined_length,\n                               crop_buff, *page, total_pages))\n            {\n             TIFFError(\"writeRegions\", \"Unable to write new image\");\n             return (-1);\n             }\n\t break;\n    case ONE_FILE_SEPARATED: /* Regions as separated images */\n         autoindex = 0;\n         if (update_output_file (out, mp, autoindex, filename, page))\n           return (1);\n         page_count = crop->selections * total_pages;\n         for (i = 0; i < crop->selections; i++)\n           {\n           crop_buff = seg_buffs[i].buffer;\n           if (writeCroppedImage(in, *out, image, dump,\n                                 crop->regionlist[i].width, \n                                 crop->regionlist[i].length, \n                                 crop_buff, *page, page_count))\n             {\n             TIFFError(\"writeRegions\", \"Unable to write new image\");\n             return (-1);\n             }\n\t   }\n         break;\n    case FILE_PER_IMAGE_COMPOSITE: /* Regions as composite image */\n         autoindex = 1;\n         if (update_output_file (out, mp, autoindex, filename, page))\n           return (1);\n\n         crop_buff = seg_buffs[0].buffer;\n         if (writeCroppedImage(in, *out, image, dump,\n                               crop->combined_width, \n                               crop->combined_length, \n                               crop_buff, *page, total_pages))\n           {\n           TIFFError(\"writeRegions\", \"Unable to write new image\");\n           return (-1);\n           }\n         break;\n    case FILE_PER_IMAGE_SEPARATED: /* Regions as separated images */\n         autoindex = 1;\n         page_count = crop->selections;\n         if (update_output_file (out, mp, autoindex, filename, page))\n           return (1);\n                \n         for (i = 0; i < crop->selections; i++)\n           {\n           crop_buff = seg_buffs[i].buffer;\n           /* Write the current region to the current file */\n           if (writeCroppedImage(in, *out, image, dump,\n                                 crop->regionlist[i].width, \n                                 crop->regionlist[i].length, \n                                 crop_buff, *page, page_count))\n             {\n             TIFFError(\"writeRegions\", \"Unable to write new image\");\n             return (-1);\n             }\n           }\n         break;\n    case FILE_PER_SELECTION:\n         autoindex = 1;\n\t page_count = 1;\n         for (i = 0; i < crop->selections; i++)\n           {\n           if (update_output_file (out, mp, autoindex, filename, page))\n             return (1);\n\n           crop_buff = seg_buffs[i].buffer;\n           /* Write the current region to the current file */\n           if (writeCroppedImage(in, *out, image, dump,\n                                 crop->regionlist[i].width, \n                                 crop->regionlist[i].length, \n                                 crop_buff, *page, page_count))\n             {\n             TIFFError(\"writeRegions\", \"Unable to write new image\");\n             return (-1);\n             }\n           }\n\t break;\n    default: return (1);\n    }\n\n  return (0);\n  } /* end writeRegions */\n\nstatic int\nwriteImageSections(TIFF *in, TIFF *out, struct image_data *image,\n\t\t   struct pagedef *page, struct pageseg *sections,\n\t\t   struct dump_opts * dump, unsigned char *src_buff,\n                   unsigned char **sect_buff_ptr)\n  {\n  double  hres, vres;\n  uint32  i, k, width, length, sectsize;\n  unsigned char *sect_buff = *sect_buff_ptr;\n\n  hres = page->hres;\n  vres = page->vres;\n\n  k = page->cols * page->rows;\n  if ((k < 1) || (k > MAX_SECTIONS))\n   {\n   TIFFError(\"writeImageSections\",\n\t     \"%d Rows and Columns exceed maximum sections\\nIncrease resolution or reduce sections\", k);\n   return (-1);\n   }\n\n  for (i = 0; i < k; i++)\n    {\n    width  = sections[i].x2 - sections[i].x1 + 1;\n    length = sections[i].y2 - sections[i].y1 + 1;\n    sectsize = (uint32)\n\t    ceil((width * image->bps + 7) / (double)8) * image->spp * length;\n    /* allocate a buffer if we don't have one already */\n    if (createImageSection(sectsize, sect_buff_ptr))\n      {\n      TIFFError(\"writeImageSections\", \"Unable to allocate section buffer\");\n      exit (-1);\n      }\n    sect_buff = *sect_buff_ptr;\n\n    if (extractImageSection (image, &sections[i], src_buff, sect_buff))\n      {\n      TIFFError(\"writeImageSections\", \"Unable to extract image sections\");\n      exit (-1);\n      }\n\n  /* call the write routine here instead of outside the loop */\n    if (writeSingleSection(in, out, image, dump, width, length, hres, vres, sect_buff))\n      {\n      TIFFError(\"writeImageSections\", \"Unable to write image section\");\n      exit (-1);\n      }\n    }\n\n  return (0);\n  } /* end writeImageSections */\n\n/* Code in this function is heavily indebted to code in tiffcp\n * with modifications by Richard Nolde to handle orientation correctly.\n * It will have to be updated significantly if support is added to\n * extract one or more samples from original image since the \n * original code assumes we are always copying all samples.\n */\nstatic int  \nwriteSingleSection(TIFF *in, TIFF *out, struct image_data *image,\n                   struct dump_opts *dump, uint32 width, uint32 length,\n                   double hres, double vres,\n                   unsigned char *sect_buff)\n  {\n  uint16 bps, spp;\n  uint16 input_compression, input_photometric;\n  uint16 input_planar;\n  struct cpTag* p;\n\n  /*  Calling this seems to reset the compression mode on the TIFF *in file.\n  TIFFGetField(in, TIFFTAG_JPEGCOLORMODE, &input_jpeg_colormode);\n  */\n  input_compression = image->compression;\n  input_photometric = image->photometric;\n\n  spp = image->spp;\n  bps = image->bps;\n  TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(out, TIFFTAG_IMAGELENGTH, length);\n  TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bps);\n  TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp);\n\n#ifdef DEBUG2\n  TIFFError(\"writeSingleSection\", \"Input compression: %s\",\n\t    (input_compression == COMPRESSION_OJPEG) ? \"Old Jpeg\" :\n\t    ((input_compression == COMPRESSION_JPEG) ?  \"New Jpeg\" : \"Non Jpeg\"));\n#endif\n  /* This is the global variable compression which is set \n   * if the user has specified a command line option for \n   * a compression option.  Should be passed around in one\n   * of the parameters instead of as a global. If no user\n   * option specified it will still be (uint16) -1. */\n  if (compression != (uint16)-1)\n    TIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n  else\n    { /* OJPEG is no longer supported for writing so upgrade to JPEG */\n    if (input_compression == COMPRESSION_OJPEG)\n      {\n      compression = COMPRESSION_JPEG;\n      jpegcolormode = JPEGCOLORMODE_RAW;\n      TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n      }\n    else /* Use the compression from the input file */\n      CopyField(TIFFTAG_COMPRESSION, compression);\n    }\n\n  if (compression == COMPRESSION_JPEG)\n    {\n    if ((input_photometric == PHOTOMETRIC_PALETTE) ||  /* color map indexed */\n        (input_photometric == PHOTOMETRIC_MASK))       /* holdout mask */\n      {\n      TIFFError (\"writeSingleSection\",\n                 \"JPEG compression cannot be used with %s image data\",\n\t\t (input_photometric == PHOTOMETRIC_PALETTE) ?\n                 \"palette\" : \"mask\");\n      return (-1);\n      }\n    if ((input_photometric == PHOTOMETRIC_RGB) &&\n\t(jpegcolormode == JPEGCOLORMODE_RGB))\n      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n    else\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n    }\n  else\n    {\n    if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24)\n      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?\n\t\t\tPHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);\n    else\n      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, image->photometric);\n    }\n\n#ifdef DEBUG2\n  TIFFError(\"writeSingleSection\", \"Input photometric: %s\",\n\t    (input_photometric == PHOTOMETRIC_RGB) ? \"RGB\" :\n\t    ((input_photometric == PHOTOMETRIC_YCBCR) ?  \"YCbCr\" : \"Not RGB or YCbCr\"));\n#endif\n\n  if (((input_photometric == PHOTOMETRIC_LOGL) ||\n       (input_photometric ==  PHOTOMETRIC_LOGLUV)) &&\n      ((compression != COMPRESSION_SGILOG) && \n       (compression != COMPRESSION_SGILOG24)))\n    {\n    TIFFError(\"writeSingleSection\",\n              \"LogL and LogLuv source data require SGI_LOG or SGI_LOG24 compression\");\n    return (-1);\n    }\n\n  if (fillorder != 0)\n    TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n  else\n    CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);\n\n  /* The loadimage function reads input orientation and sets\n   * image->orientation. The correct_image_orientation function\n   * applies the required rotation and mirror operations to \n   * present the data in TOPLEFT orientation and updates \n   * image->orientation if any transforms are performed, \n   * as per EXIF standard.\n   */\n  TIFFSetField(out, TIFFTAG_ORIENTATION, image->orientation);\n\n  /*\n   * Choose tiles/strip for the output image according to\n   * the command line arguments (-tiles, -strips) and the\n   * structure of the input image.\n   */\n  if (outtiled == -1)\n    outtiled = TIFFIsTiled(in);\n  if (outtiled) {\n    /*\n     * Setup output file's tile width&height.  If either\n     * is not specified, use either the value from the\n     * input image or, if nothing is defined, use the\n     * library default.\n     */\n    if (tilewidth == (uint32) 0)\n      TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\n    if (tilelength == (uint32) 0)\n      TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\n\n    if (tilewidth == 0 || tilelength == 0)\n      TIFFDefaultTileSize(out, &tilewidth, &tilelength);\n    TIFFDefaultTileSize(out, &tilewidth, &tilelength);\n    TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\n    TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\n    } else {\n       /*\n\t* RowsPerStrip is left unspecified: use either the\n\t* value from the input image or, if nothing is defined,\n\t* use the library default.\n\t*/\n\tif (rowsperstrip == (uint32) 0)\n          {\n\t  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))\n\t    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n          if (compression != COMPRESSION_JPEG)\n            {\n  \t    if (rowsperstrip > length)\n\t      rowsperstrip = length;\n\t    }\n\t  }\n\telse \n          if (rowsperstrip == (uint32) -1)\n\t    rowsperstrip = length;\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\t}\n\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);\n  if (config != (uint16) -1)\n    TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n  else\n    CopyField(TIFFTAG_PLANARCONFIG, config);\n  if (spp <= 4)\n    CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);\n  CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);\n\n/* SMinSampleValue & SMaxSampleValue */\n  switch (compression) {\n    /* These are references to GLOBAL variables set by defaults\n     * and /or the compression flag\n     */\n    case COMPRESSION_JPEG:\n         if (((bps % 8) == 0) || ((bps % 12) == 0))\n\t   {\n           TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n           }\n         else\n           {\n\t   TIFFError(\"writeSingleSection\",\n                     \"JPEG compression requires 8 or 12 bits per sample\");\n           return (-1);\n           }\n\t break;\n   case COMPRESSION_LZW:\n   case COMPRESSION_ADOBE_DEFLATE:\n   case COMPRESSION_DEFLATE:\n\tif (predictor != (uint16)-1)\n          TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\telse\n\t  CopyField(TIFFTAG_PREDICTOR, predictor);\n\tbreak;\n   case COMPRESSION_CCITTFAX3:\n   case COMPRESSION_CCITTFAX4:\n\tif (compression == COMPRESSION_CCITTFAX3) {\n          if (g3opts != (uint32) -1)\n\t    TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);\n\t  else\n\t    CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\n\t} else {\n\t    CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);\n        }\n        CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n\tbreak;\n   }\n   { uint32 len32;\n     void** data;\n     if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))\n       TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);\n   }\n   { uint16 ninks;\n     const char* inknames;\n     if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {\n       TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\n       if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {\n\t int inknameslen = strlen(inknames) + 1;\n\t const char* cp = inknames;\n\t while (ninks > 1) {\n\t   cp = strchr(cp, '\\0');\n\t   if (cp) {\n\t     cp++;\n\t     inknameslen += (strlen(cp) + 1);\n\t   }\n\t   ninks--;\n         }\n\t TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);\n       }\n     }\n   }\n   {\n   unsigned short pg0, pg1;\n   if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {\n     if (pageNum < 0) /* only one input file */\n\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n     else \n\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n     }\n   }\n\n  for (p = tags; p < &tags[NTAGS]; p++)\n\t\tCopyTag(p->tag, p->count, p->type);\n\n  /* Update these since they are overwritten from input res by loop above */\n  TIFFSetField(out, TIFFTAG_XRESOLUTION, (float)hres);\n  TIFFSetField(out, TIFFTAG_YRESOLUTION, (float)vres);\n\n  /* Compute the tile or strip dimensions and write to disk */\n  if (outtiled)\n    {\n    if (config == PLANARCONFIG_CONTIG)\n      writeBufferToContigTiles (out, sect_buff, length, width, spp, dump);\n    else\n      writeBufferToSeparateTiles (out, sect_buff, length, width, spp, dump);\n    }\n  else\n    {\n    if (config == PLANARCONFIG_CONTIG)\n      writeBufferToContigStrips (out, sect_buff, length);\n    else\n      writeBufferToSeparateStrips(out, sect_buff, length, width, spp, dump);\n    }\n\n  if (!TIFFWriteDirectory(out))\n    {\n    TIFFClose(out);\n    return (-1);\n    }\n\n  return (0);\n  } /* end writeSingleSection */\n\n\n/* Create a buffer to write one section at a time */\nstatic int\ncreateImageSection(uint32 sectsize, unsigned char **sect_buff_ptr)\n  {\n  unsigned  char *sect_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    uint32  prev_sectsize = 0;\n  \n  sect_buff = *sect_buff_ptr;\n\n  if (!sect_buff)\n    {\n    sect_buff = (unsigned char *)_TIFFmalloc(sectsize);\n    *sect_buff_ptr = sect_buff;\n    _TIFFmemset(sect_buff, 0, sectsize);\n    }\n  else\n    {\n    if (prev_sectsize < sectsize)\n      {\n      new_buff = _TIFFrealloc(sect_buff, sectsize);\n      if (!new_buff)\n        {\n\tfree (sect_buff);\n        sect_buff = (unsigned char *)_TIFFmalloc(sectsize);\n        }\n      else\n        sect_buff = new_buff;\n\n      _TIFFmemset(sect_buff, 0, sectsize);\n      }\n    }\n\n  if (!sect_buff)\n    {\n    TIFFError(\"createImageSection\", \"Unable to allocate/reallocate section buffer\");\n    return (-1);\n    }\n  prev_sectsize = sectsize;\n  *sect_buff_ptr = sect_buff;\n\n  return (0);\n  }  /* end createImageSection */\n\n\n/* Process selections defined by regions, zones, margins, or fixed sized areas */\nstatic int\nprocessCropSelections(struct image_data *image, struct crop_mask *crop, \n                      unsigned char **read_buff_ptr, struct buffinfo seg_buffs[])\n  {\n  int       i;\n  uint32    width, length, total_width, total_length;\n  tsize_t   cropsize;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *next_buff = NULL;\n  tsize_t   prev_cropsize = 0;\n\n  read_buff = *read_buff_ptr;\n\n  if (crop->img_mode == COMPOSITE_IMAGES)\n    {\n    cropsize = crop->bufftotal;\n    crop_buff = seg_buffs[0].buffer; \n    if (!crop_buff)\n      crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n    else\n      {\n      prev_cropsize = seg_buffs[0].size;\n      if (prev_cropsize < cropsize)\n        {\n        next_buff = _TIFFrealloc(crop_buff, cropsize);\n        if (! next_buff)\n          {\n          _TIFFfree (crop_buff);\n          crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n          }\n        else\n          crop_buff = next_buff;\n        }\n      }\n\n    if (!crop_buff)\n      {\n      TIFFError(\"processCropSelections\", \"Unable to allocate/reallocate crop buffer\");\n      return (-1);\n      }\n \n    _TIFFmemset(crop_buff, 0, cropsize);\n    seg_buffs[0].buffer = crop_buff;\n    seg_buffs[0].size = cropsize;\n\n    /* Checks for matching width or length as required */\n    if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0)\n      return (1);\n\n    if (crop->crop_mode & CROP_INVERT)\n      {\n      switch (crop->photometric)\n        {\n        /* Just change the interpretation */\n        case PHOTOMETRIC_MINISWHITE:\n        case PHOTOMETRIC_MINISBLACK:\n\t     image->photometric = crop->photometric;\n\t     break;\n        case INVERT_DATA_ONLY:\n        case INVERT_DATA_AND_TAG:\n             if (invertImage(image->photometric, image->spp, image->bps, \n                             crop->combined_width, crop->combined_length, crop_buff))\n               {\n               TIFFError(\"processCropSelections\", \n                         \"Failed to invert colorspace for composite regions\");\n               return (-1);\n               }\n             if (crop->photometric == INVERT_DATA_AND_TAG)\n               {\n               switch (image->photometric)\n                 {\n                 case PHOTOMETRIC_MINISWHITE:\n \t              image->photometric = PHOTOMETRIC_MINISBLACK;\n\t              break;\n                 case PHOTOMETRIC_MINISBLACK:\n \t              image->photometric = PHOTOMETRIC_MINISWHITE;\n\t              break;\n                 default:\n\t              break;\n\t         }\n\t       }\n             break;\n        default: break;\n        }\n      }\n\n    /* Mirror and Rotate will not work with multiple regions unless they are the same width */\n    if (crop->crop_mode & CROP_MIRROR)\n      {\n      if (mirrorImage(image->spp, image->bps, crop->mirror, \n                      crop->combined_width, crop->combined_length, crop_buff))\n        {\n        TIFFError(\"processCropSelections\", \"Failed to mirror composite regions %s\", \n\t         (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n        return (-1);\n        }\n      }\n\n    if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n      {\n      if (rotateImage(crop->rotation, image, &crop->combined_width, \n                      &crop->combined_length, &crop_buff))\n        {\n        TIFFError(\"processCropSelections\", \n                  \"Failed to rotate composite regions by %d degrees\", crop->rotation);\n        return (-1);\n        }\n      seg_buffs[0].buffer = crop_buff;\n      seg_buffs[0].size = (((crop->combined_width * image->bps + 7 ) / 8)\n                            * image->spp) * crop->combined_length; \n      }\n    }\n  else  /* Separated Images */\n    {\n    total_width = total_length = 0;\n    for (i = 0; i < crop->selections; i++)\n      {\n      cropsize = crop->bufftotal;\n      crop_buff = seg_buffs[i].buffer; \n      if (!crop_buff)\n        crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n      else\n        {\n        prev_cropsize = seg_buffs[0].size;\n        if (prev_cropsize < cropsize)\n          {\n          next_buff = _TIFFrealloc(crop_buff, cropsize);\n          if (! next_buff)\n            {\n            _TIFFfree (crop_buff);\n            crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n            }\n          else\n            crop_buff = next_buff;\n          }\n        }\n\n      if (!crop_buff)\n        {\n        TIFFError(\"processCropSelections\", \"Unable to allocate/reallocate crop buffer\");\n        return (-1);\n        }\n \n      _TIFFmemset(crop_buff, 0, cropsize);\n      seg_buffs[i].buffer = crop_buff;\n      seg_buffs[i].size = cropsize;\n\n      if (extractSeparateRegion(image, crop, read_buff, crop_buff, i))\n        {\n\tTIFFError(\"processCropSelections\", \"Unable to extract cropped region %d from image\", i);\n        return (-1);\n        }\n    \n      width  = crop->regionlist[i].width;\n      length = crop->regionlist[i].length;\n\n      if (crop->crop_mode & CROP_INVERT)\n        {\n        switch (crop->photometric)\n          {\n          /* Just change the interpretation */\n          case PHOTOMETRIC_MINISWHITE:\n          case PHOTOMETRIC_MINISBLACK:\n\t       image->photometric = crop->photometric;\n\t       break;\n          case INVERT_DATA_ONLY:\n          case INVERT_DATA_AND_TAG:\n               if (invertImage(image->photometric, image->spp, image->bps, \n                               width, length, crop_buff))\n                 {\n                 TIFFError(\"processCropSelections\", \n                           \"Failed to invert colorspace for region\");\n                 return (-1);\n                 }\n               if (crop->photometric == INVERT_DATA_AND_TAG)\n                 {\n                 switch (image->photometric)\n                   {\n                   case PHOTOMETRIC_MINISWHITE:\n \t                image->photometric = PHOTOMETRIC_MINISBLACK;\n\t                break;\n                   case PHOTOMETRIC_MINISBLACK:\n \t                image->photometric = PHOTOMETRIC_MINISWHITE;\n\t                break;\n                   default:\n\t                break;\n\t           }\n\t         }\n               break;\n          default: break;\n          }\n        }\n\n      if (crop->crop_mode & CROP_MIRROR)\n        {\n        if (mirrorImage(image->spp, image->bps, crop->mirror, \n                        width, length, crop_buff))\n          {\n          TIFFError(\"processCropSelections\", \"Failed to mirror crop region %s\", \n\t           (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n          return (-1);\n          }\n        }\n\n      if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n        {\n\tif (rotateImage(crop->rotation, image, &crop->regionlist[i].width, \n\t\t\t&crop->regionlist[i].length, &crop_buff))\n          {\n          TIFFError(\"processCropSelections\", \n                    \"Failed to rotate crop region by %d degrees\", crop->rotation);\n          return (-1);\n          }\n        total_width  += crop->regionlist[i].width;\n        total_length += crop->regionlist[i].length;\n        crop->combined_width = total_width;\n        crop->combined_length = total_length;\n        seg_buffs[i].buffer = crop_buff;\n        seg_buffs[i].size = (((crop->regionlist[i].width * image->bps + 7 ) / 8)\n                               * image->spp) * crop->regionlist[i].length; \n        }\n      }\n    }\n  return (0);\n  } /* end processCropSelections */\n\n/* Copy the crop section of the data from the current image into a buffer\n * and adjust the IFD values to reflect the new size. If no cropping is\n * required, use the origial read buffer as the crop buffer.\n *\n * There is quite a bit of redundancy between this routine and the more\n * specialized processCropSelections, but this provides\n * the most optimized path when no Zones or Regions are required.\n */\nstatic int\ncreateCroppedImage(struct image_data *image, struct crop_mask *crop, \n                   unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr)\n  {\n  tsize_t   cropsize;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    tsize_t  prev_cropsize = 0;\n\n  read_buff = *read_buff_ptr;\n\n  /* process full image, no crop buffer needed */\n  crop_buff = read_buff;\n  *crop_buff_ptr = read_buff;\n  crop->combined_width = image->width;\n  crop->combined_length = image->length;\n\n  cropsize = crop->bufftotal;\n  crop_buff = *crop_buff_ptr;\n  if (!crop_buff)\n    {\n    crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n    *crop_buff_ptr = crop_buff;\n    _TIFFmemset(crop_buff, 0, cropsize);\n    prev_cropsize = cropsize;\n    }\n  else\n    {\n    if (prev_cropsize < cropsize)\n      {\n      new_buff = _TIFFrealloc(crop_buff, cropsize);\n      if (!new_buff)\n        {\n\tfree (crop_buff);\n        crop_buff = (unsigned char *)_TIFFmalloc(cropsize);\n        }\n      else\n        crop_buff = new_buff;\n      _TIFFmemset(crop_buff, 0, cropsize);\n      }\n    }\n\n  if (!crop_buff)\n    {\n    TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n    return (-1);\n    }\n  *crop_buff_ptr = crop_buff;\n\n  if (crop->crop_mode & CROP_INVERT)\n    {\n    switch (crop->photometric)\n      {\n      /* Just change the interpretation */\n      case PHOTOMETRIC_MINISWHITE:\n      case PHOTOMETRIC_MINISBLACK:\n\t   image->photometric = crop->photometric;\n\t   break;\n      case INVERT_DATA_ONLY:\n      case INVERT_DATA_AND_TAG:\n           if (invertImage(image->photometric, image->spp, image->bps, \n                           crop->combined_width, crop->combined_length, crop_buff))\n             {\n             TIFFError(\"createCroppedImage\", \n                       \"Failed to invert colorspace for image or cropped selection\");\n             return (-1);\n             }\n           if (crop->photometric == INVERT_DATA_AND_TAG)\n             {\n             switch (image->photometric)\n               {\n               case PHOTOMETRIC_MINISWHITE:\n \t            image->photometric = PHOTOMETRIC_MINISBLACK;\n\t            break;\n               case PHOTOMETRIC_MINISBLACK:\n \t            image->photometric = PHOTOMETRIC_MINISWHITE;\n\t            break;\n               default:\n\t            break;\n\t       }\n\t     }\n           break;\n      default: break;\n      }\n    }\n\n  if (crop->crop_mode & CROP_MIRROR)\n    {\n    if (mirrorImage(image->spp, image->bps, crop->mirror, \n                    crop->combined_width, crop->combined_length, crop_buff))\n      {\n      TIFFError(\"createCroppedImage\", \"Failed to mirror image or cropped selection %s\", \n\t       (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n      return (-1);\n      }\n    }\n\n  if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n    {\n    if (rotateImage(crop->rotation, image, &crop->combined_width, \n                    &crop->combined_length, crop_buff_ptr))\n      {\n      TIFFError(\"createCroppedImage\", \n                \"Failed to rotate image or cropped selection by %d degrees\", crop->rotation);\n      return (-1);\n      }\n    }\n\n  if (crop_buff == read_buff) /* we used the read buffer for the crop buffer */\n    *read_buff_ptr = NULL;    /* so we don't try to free it later */\n\n  return (0);\n  } /* end createCroppedImage */\n\n\n/* Code in this function is heavily indebted to code in tiffcp\n * with modifications by Richard Nolde to handle orientation correctly.\n * It will have to be updated significantly if support is added to\n * extract one or more samples from original image since the \n * original code assumes we are always copying all samples.\n * Use of global variables for config, compression and others\n * should be replaced by addition to the crop_mask struct (which\n * will be renamed to proc_opts indicating that is controls\n * user supplied processing options, not just cropping) and \n * then passed in as an argument.\n */\nstatic int  \nwriteCroppedImage(TIFF *in, TIFF *out, struct image_data *image, \n                  struct dump_opts *dump, uint32 width, uint32 length, \n                  unsigned char *crop_buff, int pagenum, int total_pages)\n  {\n  uint16 bps, spp;\n  uint16 input_compression, input_photometric;\n  uint16 input_planar;\n  struct cpTag* p;\n\n  input_compression = image->compression;\n  input_photometric = image->photometric;\n  spp = image->spp;\n  bps = image->bps;\n\n  TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n  TIFFSetField(out, TIFFTAG_IMAGELENGTH, length);\n  TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bps);\n  TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp);\n\n#ifdef DEBUG2\n  TIFFError(\"writeCroppedImage\", \"Input compression: %s\",\n\t    (input_compression == COMPRESSION_OJPEG) ? \"Old Jpeg\" :\n\t    ((input_compression == COMPRESSION_JPEG) ?  \"New Jpeg\" : \"Non Jpeg\"));\n#endif\n\n  if (compression != (uint16)-1)\n    TIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n  else\n    {\n    if (input_compression == COMPRESSION_OJPEG)\n      {\n      compression = COMPRESSION_JPEG;\n      jpegcolormode = JPEGCOLORMODE_RAW;\n      TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n      }\n    else\n      CopyField(TIFFTAG_COMPRESSION, compression);\n    }\n\n  if (compression == COMPRESSION_JPEG)\n    {\n    if ((input_photometric == PHOTOMETRIC_PALETTE) ||  /* color map indexed */\n        (input_photometric == PHOTOMETRIC_MASK))       /* $holdout mask */\n      {\n      TIFFError (\"writeCroppedImage\",\n                 \"JPEG compression cannot be used with %s image data\",\n      \t        (input_photometric == PHOTOMETRIC_PALETTE) ?\n                 \"palette\" : \"mask\");\n      return (-1);\n      }\n    if ((input_photometric == PHOTOMETRIC_RGB) &&\n\t(jpegcolormode == JPEGCOLORMODE_RGB))\n      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n    else\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n    }\n  else\n    {\n    if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24)\n      {\n      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?\n\t\t\tPHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);\n      }\n    else\n      {\n      if (input_compression == COMPRESSION_SGILOG ||\n          input_compression == COMPRESSION_SGILOG24)\n        {\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?\n\t\t\t  PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);\n        }\n      else\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, image->photometric);\n      }\n    }\n\n  if (((input_photometric == PHOTOMETRIC_LOGL) ||\n       (input_photometric ==  PHOTOMETRIC_LOGLUV)) &&\n      ((compression != COMPRESSION_SGILOG) && \n       (compression != COMPRESSION_SGILOG24)))\n    {\n    TIFFError(\"writeCroppedImage\",\n              \"LogL and LogLuv source data require SGI_LOG or SGI_LOG24 compression\");\n    return (-1);\n    }\n\n  if (fillorder != 0)\n    TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n  else\n    CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);\n\n  /* The loadimage function reads input orientation and sets\n   * image->orientation. The correct_image_orientation function\n   * applies the required rotation and mirror operations to \n   * present the data in TOPLEFT orientation and updates \n   * image->orientation if any transforms are performed, \n   * as per EXIF standard. \n   */\n  TIFFSetField(out, TIFFTAG_ORIENTATION, image->orientation);\n\t\n  /*\n   * Choose tiles/strip for the output image according to\n   * the command line arguments (-tiles, -strips) and the\n   * structure of the input image.\n   */\n  if (outtiled == -1)\n    outtiled = TIFFIsTiled(in);\n  if (outtiled) {\n    /*\n     * Setup output file's tile width&height.  If either\n     * is not specified, use either the value from the\n     * input image or, if nothing is defined, use the\n     * library default.\n     */\n    if (tilewidth == (uint32) 0)\n      TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\n    if (tilelength == (uint32) 0)\n      TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\n\n    if (tilewidth == 0 || tilelength == 0)\n      TIFFDefaultTileSize(out, &tilewidth, &tilelength);\n    TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\n    TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\n    } else {\n       /*\n\t* RowsPerStrip is left unspecified: use either the\n\t* value from the input image or, if nothing is defined,\n\t* use the library default.\n\t*/\n\tif (rowsperstrip == (uint32) 0)\n          {\n\t  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))\n\t    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n          if (compression != COMPRESSION_JPEG)\n            {\n  \t    if (rowsperstrip > length)\n\t      rowsperstrip = length;\n\t    }\n\t  }\n\telse \n          if (rowsperstrip == (uint32) -1)\n\t    rowsperstrip = length;\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\t}\n\n  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);\n  if (config != (uint16) -1)\n    TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n  else\n    CopyField(TIFFTAG_PLANARCONFIG, config);\n  if (spp <= 4)\n    CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);\n  CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);\n\n/* SMinSampleValue & SMaxSampleValue */\n  switch (compression) {\n    case COMPRESSION_JPEG:\n         if (((bps % 8) == 0) || ((bps % 12) == 0))\n\t   {\n           TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n           }\n         else\n           {\n\t   TIFFError(\"writeCroppedImage\",\n                     \"JPEG compression requires 8 or 12 bits per sample\");\n           return (-1);\n           }\n\t break;\n   case COMPRESSION_LZW:\n   case COMPRESSION_ADOBE_DEFLATE:\n   case COMPRESSION_DEFLATE:\n\tif (predictor != (uint16)-1)\n          TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\telse\n\t  CopyField(TIFFTAG_PREDICTOR, predictor);\n\tbreak;\n   case COMPRESSION_CCITTFAX3:\n   case COMPRESSION_CCITTFAX4:\n        if (bps != 1)\n          {\n\t  TIFFError(\"writeCroppedImage\",\n            \"Group 3/4 compression is not usable with bps > 1\");\n          return (-1);\n\t  }\n\tif (compression == COMPRESSION_CCITTFAX3) {\n          if (g3opts != (uint32) -1)\n\t    TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);\n\t  else\n\t    CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\n\t} else {\n\t    CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);\n        }\n        CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n        CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n        break;\n    case COMPRESSION_NONE:\n         break;\n    default: break;\n   }\n   { uint32 len32;\n     void** data;\n     if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))\n       TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);\n   }\n   { uint16 ninks;\n     const char* inknames;\n     if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {\n       TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\n       if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {\n\t int inknameslen = strlen(inknames) + 1;\n\t const char* cp = inknames;\n\t while (ninks > 1) {\n\t   cp = strchr(cp, '\\0');\n\t   if (cp) {\n\t     cp++;\n\t     inknameslen += (strlen(cp) + 1);\n\t   }\n\t   ninks--;\n         }\n\t TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);\n       }\n     }\n   }\n   {\n   unsigned short pg0, pg1;\n   if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {\n     TIFFSetField(out, TIFFTAG_PAGENUMBER, pagenum, total_pages);\n     }\n   }\n\n  for (p = tags; p < &tags[NTAGS]; p++)\n\t\tCopyTag(p->tag, p->count, p->type);\n\n  /* Compute the tile or strip dimensions and write to disk */\n  if (outtiled)\n    {\n    if (config == PLANARCONFIG_CONTIG)\n      {\n      if (writeBufferToContigTiles (out, crop_buff, length, width, spp, dump))\n        TIFFError(\"\",\"Unable to write contiguous tile data for page %d\", pagenum);\n      }\n    else\n      {\n      if (writeBufferToSeparateTiles (out, crop_buff, length, width, spp, dump))\n        TIFFError(\"\",\"Unable to write separate tile data for page %d\", pagenum);\n      }\n    }\n  else\n    {\n    if (config == PLANARCONFIG_CONTIG)\n      {\n      if (writeBufferToContigStrips (out, crop_buff, length))\n        TIFFError(\"\",\"Unable to write contiguous strip data for page %d\", pagenum);\n      }\n    else\n      {\n      if (writeBufferToSeparateStrips(out, crop_buff, length, width, spp, dump))\n        TIFFError(\"\",\"Unable to write separate strip data for page %d\", pagenum);\n      }\n    }\n\n  if (!TIFFWriteDirectory(out))\n    {\n    TIFFError(\"\",\"Failed to write IFD for page number %d\", pagenum);\n    return (-1);\n    }\n\n  return (0);\n  } /* end writeCroppedImage */\n\nstatic int\nrotateContigSamples8bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width, \n                         uint32 length,   uint32 col, uint8 *src, uint8 *dst)\n  {\n  int      ready_bits = 0;\n  uint32   src_byte = 0, src_bit = 0;\n  uint32   row, rowsize = 0, bit_offset = 0;\n  uint8    matchbits = 0, maskbits = 0;\n  uint8    buff1 = 0, buff2 = 0;\n  uint8   *next;\n  tsample_t sample;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"rotateContigSamples8bits\",\"Invalid src or destination buffer\");\n    return (1);\n    }\n\n  rowsize = ((bps * spp * width) + 7) / 8;\n  ready_bits = 0;\n  maskbits =  (uint8)-1 >> ( 8 - bps);\n  buff1 = buff2 = 0;\n\n  for (row = 0; row < length ; row++)\n    {\n    bit_offset = col * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        src_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      switch (rotation)\n\t{\n        case  90: next = src + src_byte - (row * rowsize);\n                  break;\n        case 270: next = src + src_byte + (row * rowsize);\n\t          break;\n\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);\n                  return (1);\n        }\n      matchbits = maskbits << (8 - src_bit - bps); \n      buff1 = ((*next) & matchbits) << (src_bit);\n\n       /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 8)\n        {\n        *dst++ = buff2;\n        buff2 = buff1;\n        ready_bits -= 8;\n        }\n      else\n        {\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  if (ready_bits > 0)\n    {\n    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n    *dst++ = buff1;\n    }\n\n  return (0);\n  }  /* end rotateContigSamples8bits */\n\n\nstatic int\nrotateContigSamples16bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width, \n                         uint32 length,   uint32 col, uint8 *src, uint8 *dst)\n  {\n  int      ready_bits = 0;\n  uint32   row, rowsize, bit_offset;\n  uint32   src_byte = 0, src_bit = 0;\n  uint16   matchbits = 0, maskbits = 0;\n  uint16   buff1 = 0, buff2 = 0;\n  uint8    bytebuff = 0;\n  uint8   *next;\n  tsample_t sample;\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"rotateContigSamples16bits\",\"Invalid src or destination buffer\");\n    return (1);\n    }\n\n  rowsize = ((bps * spp * width) + 7) / 8;\n  ready_bits = 0;\n  maskbits =  (uint16)-1 >> (16 - bps);\n  buff1 = buff2 = 0;\n  for (row = 0; row < length; row++)\n    {\n    bit_offset = col * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        src_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      switch (rotation)\n\t{\n        case  90: next = src + src_byte - (row * rowsize);\n                  break;\n        case 270: next = src + src_byte + (row * rowsize);\n\t          break;\n\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);\n                  return (1);\n        }\n      matchbits = maskbits << (16 - src_bit - bps); \n      if (little_endian)\n        buff1 = (next[0] << 8) | next[1];\n      else\n        buff1 = (next[1] << 8) | next[0];\n\n      buff1 = (buff1 & matchbits) << (src_bit);\n\n      /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 8)\n        {\n        bytebuff = (buff2 >> 8);\n        *dst++ = bytebuff;\n        ready_bits -= 8;\n        /* shift in new bits */\n        buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n        }\n      else\n        { /* add another bps bits to the buffer */\n        bytebuff = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  if (ready_bits > 0)\n    {\n    bytebuff = (buff2 >> 8);\n    *dst++ = bytebuff;\n    }\n\n  return (0);\n  }  /* end rotateContigSamples16bits */\n\nstatic int\nrotateContigSamples24bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width, \n                          uint32 length,   uint32 col, uint8 *src, uint8 *dst)\n  {\n  int      ready_bits = 0;\n  uint32   row, rowsize, bit_offset;\n  uint32   src_byte = 0, src_bit = 0;\n  uint32   matchbits = 0, maskbits = 0;\n  uint32   buff1 = 0, buff2 = 0;\n  uint8    bytebuff1 = 0, bytebuff2 = 0;\n  uint8   *next;\n  tsample_t sample;\n\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"rotateContigSamples24bits\",\"Invalid src or destination buffer\");\n    return (1);\n    }\n\n  rowsize = ((bps * spp * width) + 7) / 8;\n  ready_bits = 0;\n  maskbits =  (uint32)-1 >> (32 - bps);\n  buff1 = buff2 = 0;\n  for (row = 0; row < length; row++)\n    {\n    bit_offset = col * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        src_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      switch (rotation)\n\t{\n        case  90: next = src + src_byte - (row * rowsize);\n                  break;\n        case 270: next = src + src_byte + (row * rowsize);\n\t          break;\n\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);\n                  return (1);\n        }\n      matchbits = maskbits << (32 - src_bit - bps); \n      if (little_endian)\n\tbuff1 = (next[0] << 24) | (next[1] << 16) | (next[2] << 8) | next[3];\n      else\n\tbuff1 = (next[3] << 24) | (next[2] << 16) | (next[1] << 8) | next[0];\n      buff1 = (buff1 & matchbits) << (src_bit);\n\n      /* If we have a full buffer's worth, write it out */\n      if (ready_bits >= 16)\n        {\n        bytebuff1 = (buff2 >> 24);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 16);\n        *dst++ = bytebuff2;\n        ready_bits -= 16;\n\n        /* shift in new bits */\n        buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n        }\n      else\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 24);\n    *dst++ = bytebuff1;\n\n    buff2 = (buff2 << 8);\n    bytebuff2 = bytebuff1;\n    ready_bits -= 8;\n    }\n \n  return (0);\n  }  /* end rotateContigSamples24bits */\n\nstatic int\nrotateContigSamples32bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width, \n                          uint32 length,   uint32 col, uint8 *src, uint8 *dst)\n  {\n  int    ready_bits = 0 /*, shift_width = 0 */;\n  /* int    bytes_per_sample, bytes_per_pixel; */\n  uint32 row, rowsize, bit_offset;\n  uint32 src_byte, src_bit;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 maskbits = 0, matchbits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  uint8   *next;\n  tsample_t sample;\n\n\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"rotateContigSamples24bits\",\"Invalid src or destination buffer\");\n    return (1);\n    }\n\n  /* bytes_per_sample = (bps + 7) / 8; */\n  /* bytes_per_pixel  = ((bps * spp) + 7) / 8; */\n  /* if (bytes_per_pixel < (bytes_per_sample + 1)) */\n  /*   shift_width = bytes_per_pixel; */\n  /* else */\n  /*   shift_width = bytes_per_sample + 1; */\n\n  rowsize = ((bps * spp * width) + 7) / 8;\n  ready_bits = 0;\n  maskbits =  (uint64)-1 >> (64 - bps);\n  buff1 = buff2 = 0;\n  for (row = 0; row < length; row++)\n    {\n    bit_offset = col * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        src_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      switch (rotation)\n\t{\n        case  90: next = src + src_byte - (row * rowsize);\n                  break;\n        case 270: next = src + src_byte + (row * rowsize);\n\t          break;\n\tdefault:  TIFFError(\"rotateContigSamples8bits\", \"Invalid rotation %d\", rotation);\n                  return (1);\n        }\n      matchbits = maskbits << (64 - src_bit - bps); \n      if (little_endian)\n        {\n\tlongbuff1 = (next[0] << 24) | (next[1] << 16) | (next[2] << 8) | next[3];\n        longbuff2 = longbuff1;\n        }\n      else\n        {\n\tlongbuff1 = (next[3] << 24) | (next[2] << 16) | (next[1] << 8) | next[0];\n        longbuff2 = longbuff1;\n\t}\n\n      buff3 = ((uint64)longbuff1 << 32) | longbuff2;\n      buff1 = (buff3 & matchbits) << (src_bit);\n\n      if (ready_bits < 32)\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 56);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 48);\n        *dst++ = bytebuff2;\n        bytebuff3 = (buff2 >> 40);\n        *dst++ = bytebuff3;\n        bytebuff4 = (buff2 >> 32);\n        *dst++ = bytebuff4;\n        ready_bits -= 32;\n                    \n        /* shift in new bits */\n        buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 56);\n    *dst++ = bytebuff1;\n    buff2 = (buff2 << 8);\n    ready_bits -= 8;\n    }\n\n  return (0);\n  } /* end rotateContigSamples32bits */\n\n\n/* Rotate an image by a multiple of 90 degrees clockwise */\nstatic int\nrotateImage(uint16 rotation, struct image_data *image, uint32 *img_width, \n            uint32 *img_length, unsigned char **ibuff_ptr)\n  {\n  int      shift_width;\n  uint32   bytes_per_pixel, bytes_per_sample;\n  uint32   row, rowsize, src_offset, dst_offset;\n  uint32   i, col, width, length;\n  uint32   colsize, buffsize, col_offset, pix_offset;\n  unsigned char *ibuff;\n  unsigned char *src;\n  unsigned char *dst;\n  uint16   spp, bps;\n  float    res_temp;\n  unsigned char *rbuff = NULL;\n\n  width  = *img_width;\n  length = *img_length;\n  spp = image->spp;\n  bps = image->bps;\n\n  rowsize = ((bps * spp * width) + 7) / 8;\n  colsize = ((bps * spp * length) + 7) / 8;\n  if ((colsize * width) > (rowsize * length))\n    buffsize = (colsize + 1) * width;\n  else\n    buffsize = (rowsize + 1) * length;\n\n  bytes_per_sample = (bps + 7) / 8;\n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if (bytes_per_pixel < (bytes_per_sample + 1))\n    shift_width = bytes_per_pixel;\n  else\n    shift_width = bytes_per_sample + 1;\n\n  switch (rotation)\n    {\n    case 0:\n    case 360: return (0);\n    case 90:\n    case 180:\n    case 270: break;\n    default:  TIFFError(\"rotateImage\", \"Invalid rotation angle %d\", rotation);\n              return (-1);\n    }\n\n  if (!(rbuff = (unsigned char *)_TIFFmalloc(buffsize)))\n    {\n    TIFFError(\"rotateImage\", \"Unable to allocate rotation buffer of %1u bytes\", buffsize);\n    return (-1);\n    }\n  _TIFFmemset(rbuff, '\\0', buffsize);\n\n  ibuff = *ibuff_ptr;\n  switch (rotation)\n    {\n    case 180: if ((bps % 8) == 0) /* byte aligned data */\n                { \n                src = ibuff;\n                pix_offset = (spp * bps) / 8;\n                for (row = 0; row < length; row++)\n                   {\n\t\t   dst_offset = (length - row - 1) * rowsize;\n                   for (col = 0; col < width; col++)\n                     { \n\t\t     col_offset = (width - col - 1) * pix_offset;\n                     dst = rbuff + dst_offset + col_offset;\n\n\t\t     for (i = 0; i  < bytes_per_pixel; i++)\n\t\t       *dst++ = *src++;\n                     }\n                   }\n                }\n\t      else\n                { /* non 8 bit per sample data */ \n                for (row = 0; row < length; row++)\n                  {\n\t\t  src_offset = row * rowsize;\n\t\t  dst_offset = (length - row - 1) * rowsize;\n\t\t  src = ibuff + src_offset;\n                  dst = rbuff + dst_offset;\n                  switch (shift_width)\n                    {\n                    case 1: if (bps == 1)\n\t\t\t      {\n                              if (reverseSamples8bits(spp, bps, width, src, dst))\n                                {\n\t\t                _TIFFfree(rbuff);\n                                return (-1);\n                                }\n                              break;\n                              }\n                            if (reverseSamples16bits(spp, bps, width, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    case 2: if (reverseSamples24bits(spp, bps, width, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    case 3: \n                    case 4: \n                    case 5: if (reverseSamples32bits(spp, bps, width, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    default: TIFFError(\"rotateImage\",\"Unsupported bit depth %d\", bps);\n\t\t             _TIFFfree(rbuff);\n                             return (-1);      \n                    }\n\t\t  }\n\t\t}\n              _TIFFfree(ibuff);\n              *(ibuff_ptr) = rbuff;\n              break;\n\n    case 90:  if ((bps % 8) == 0) /* byte aligned data */\n                {\n                for (col = 0; col < width; col++)\n                  {\n\t\t  src_offset = ((length - 1) * rowsize) + (col * bytes_per_pixel);\n                  dst_offset = col * colsize;\n\t\t  src = ibuff + src_offset;\n\t\t  dst = rbuff + dst_offset;\n                  for (row = length; row > 0; row--)\n                    {\n                    for (i = 0; i < bytes_per_pixel; i++)\n                      *dst++ = *(src + i);\n\t\t    src -= rowsize;\n                    }\n\t\t  }\n\t\t}\n              else\n                { /* non 8 bit per sample data */ \n                for (col = 0; col < width; col++)\n                  {\n\t\t  src_offset = (length - 1) * rowsize;\n                  dst_offset = col * colsize;\n\t\t  src = ibuff + src_offset;\n\t\t  dst = rbuff + dst_offset;\n                  switch (shift_width)\n                    {\n                    case 1: if (bps == 1)\n\t\t\t      {\n                              if (rotateContigSamples8bits(rotation, spp, bps, width, \n\t\t\t\t   \t                 length, col, src, dst))\n                                {\n\t\t                _TIFFfree(rbuff);\n                                return (-1);\n                                }\n                              break;\n                              }\n                            if (rotateContigSamples16bits(rotation, spp, bps, width, \n\t\t\t\t   \t                 length, col, src, dst))\n                              {\n\t                      _TIFFfree(rbuff);\n                              return (-1);\n\t\t              }\n\t\t            break;\n                    case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, \n\t\t\t\t\t                  length, col, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    case 3: \n                    case 4: \n                    case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, \n\t\t\t\t\t                  length, col, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    default: TIFFError(\"rotateImage\",\"Unsupported bit depth %d\", bps);\n\t\t             _TIFFfree(rbuff);\n                             return (-1);      \n\t\t    }\n\t\t  }\n\t\t}\n              _TIFFfree(ibuff);\n              *(ibuff_ptr) = rbuff;\n\n              *img_width = length;\n              *img_length = width;\n              image->width = length;\n              image->length = width;\n              res_temp = image->xres;\n              image->xres = image->yres;\n              image->yres = res_temp;\n\t      break;\n\n    case 270: if ((bps % 8) == 0) /* byte aligned data */\n                {\n                for (col = 0; col < width; col++)\n                  {\n\t\t  src_offset = col * bytes_per_pixel;\n                  dst_offset = (width - col - 1) * colsize;\n\t\t  src = ibuff + src_offset;\n\t\t  dst = rbuff + dst_offset;\n                  for (row = length; row > 0; row--)\n                    {\n                    for (i = 0; i < bytes_per_pixel; i++)\n                      *dst++ = *(src + i);\n\t\t    src += rowsize;\n                    }\n\t\t  }\n\t\t}\n              else\n                { /* non 8 bit per sample data */ \n                for (col = 0; col < width; col++)\n                  {\n\t\t  src_offset = 0;\n                  dst_offset = (width - col - 1) * colsize;\n\t\t  src = ibuff + src_offset;\n\t\t  dst = rbuff + dst_offset;\n                  switch (shift_width)\n                    {\n                    case 1: if (bps == 1)\n\t\t\t      {\n                              if (rotateContigSamples8bits(rotation, spp, bps, width, \n\t\t\t\t   \t                 length, col, src, dst))\n                                {\n\t\t                _TIFFfree(rbuff);\n                                return (-1);\n                                }\n                              break;\n                              }\n                            if (rotateContigSamples16bits(rotation, spp, bps, width, \n\t\t\t\t   \t                 length, col, src, dst))\n                              {\n\t                      _TIFFfree(rbuff);\n                              return (-1);\n\t\t              }\n\t\t            break;\n                    case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, \n\t\t\t\t\t                  length, col, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    case 3: \n                    case 4: \n                    case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, \n\t\t\t\t\t                  length, col, src, dst))\n                              {\n\t\t              _TIFFfree(rbuff);\n                              return (-1);\n                              }\n                             break;\n                    default: TIFFError(\"rotateImage\",\"Unsupported bit depth %d\", bps);\n\t\t             _TIFFfree(rbuff);\n                             return (-1);      \n\t\t    }\n\t\t  }\n\t\t}\n              _TIFFfree(ibuff);\n              *(ibuff_ptr) = rbuff;\n\n              *img_width = length;\n              *img_length = width;\n              image->width = length;\n              image->length = width;\n              res_temp = image->xres;\n              image->xres = image->yres;\n              image->yres = res_temp;\n              break;\n    default:\n              break;\n    }\n\n  return (0);\n  } /* end rotateImage */\n\nstatic int\nreverseSamples8bits (uint16 spp, uint16 bps, uint32 width, \n                     uint8 *ibuff, uint8 *obuff)\n  {\n  int      ready_bits = 0;\n  uint32   col;\n  uint32   src_byte, src_bit;\n  uint32   bit_offset = 0;\n  uint8    match_bits = 0, mask_bits = 0;\n  uint8    buff1 = 0, buff2 = 0;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t sample;\n\n  if ((ibuff == NULL) || (obuff == NULL))\n    {\n    TIFFError(\"reverseSamples8bits\",\"Invalid image or work buffer\");\n    return (1);\n    }\n\n  ready_bits = 0;\n  mask_bits =  (uint8)-1 >> ( 8 - bps);\n  dst = obuff;\n  for (col = width; col > 0; col--)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = (col - 1) * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        src_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        src_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      src = ibuff + src_byte;\n      match_bits = mask_bits << (8 - src_bit - bps); \n      buff1 = ((*src) & match_bits) << (src_bit);\n\n      if (ready_bits < 8)\n        buff2 = (buff2 | (buff1 >> ready_bits));\n      else  /* If we have a full buffer's worth, write it out */\n        {\n        *dst++ = buff2;\n        buff2 = buff1;\n        ready_bits -= 8;\n        }\n      ready_bits += bps;\n      }\n    }\n  if (ready_bits > 0)\n    {\n    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n    *dst++ = buff1;\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              5589,
              0
            ],
            [
              8712,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "computeOutputPixelOffsets",
            "parameters": {
              "crop": "struct crop_mask",
              "image": "struct image_data",
              "page": "struct pagedef",
              "sections": "struct pageseg",
              "dump": "struct dump_opts"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nreverseSamples16bits (uint16 spp, uint16 bps, uint32 width, \n                      uint8 *ibuff, uint8 *obuff)\n  {\n  int      ready_bits = 0;\n  uint32   col;\n  uint32   src_byte = 0, high_bit = 0;\n  uint32   bit_offset = 0;\n  uint16   match_bits = 0, mask_bits = 0;\n  uint16   buff1 = 0, buff2 = 0;\n  uint8    bytebuff = 0;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t sample;\n\n  if ((ibuff == NULL) || (obuff == NULL))\n    {\n    TIFFError(\"reverseSample16bits\",\"Invalid image or work buffer\");\n    return (1);\n    }\n\n  ready_bits = 0;\n  mask_bits =  (uint16)-1 >> (16 - bps);\n  dst = obuff;\n  for (col = width; col > 0; col--)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = (col - 1) * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        high_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        high_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      src = ibuff + src_byte;\n      match_bits = mask_bits << (16 - high_bit - bps); \n      if (little_endian)\n        buff1 = (src[0] << 8) | src[1];\n      else\n        buff1 = (src[1] << 8) | src[0];\n      buff1 = (buff1 & match_bits) << (high_bit);\n      \n      if (ready_bits < 8)\n        { /* add another bps bits to the buffer */\n        bytebuff = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff = (buff2 >> 8);\n        *dst++ = bytebuff;\n        ready_bits -= 8;\n        /* shift in new bits */\n        buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n  if (ready_bits > 0)\n    {\n    bytebuff = (buff2 >> 8);\n    *dst++ = bytebuff;\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              8715,
              0
            ],
            [
              8788,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reverseSamples16bits",
            "parameters": {
              "spp": "uint16",
              "bps": "uint16",
              "width": "uint32",
              "ibuff": "uint8",
              "obuff": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nreverseSamples24bits (uint16 spp, uint16 bps, uint32 width, \n                      uint8 *ibuff, uint8 *obuff)\n  {\n  int      ready_bits = 0;\n  uint32   col;\n  uint32   src_byte = 0, high_bit = 0;\n  uint32   bit_offset = 0;\n  uint32   match_bits = 0, mask_bits = 0;\n  uint32   buff1 = 0, buff2 = 0;\n  uint8    bytebuff1 = 0, bytebuff2 = 0;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t sample;\n\n  if ((ibuff == NULL) || (obuff == NULL))\n    {\n    TIFFError(\"reverseSamples24bits\",\"Invalid image or work buffer\");\n    return (1);\n    }\n\n  ready_bits = 0;\n  mask_bits =  (uint32)-1 >> (32 - bps);\n  dst = obuff;\n  for (col = width; col > 0; col--)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = (col - 1) * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        high_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        high_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      src = ibuff + src_byte;\n      match_bits = mask_bits << (32 - high_bit - bps); \n      if (little_endian)\n\tbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n      else\n\tbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n      buff1 = (buff1 & match_bits) << (high_bit);\n\n      if (ready_bits < 16)\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 24);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 16);\n        *dst++ = bytebuff2;\n        ready_bits -= 16;\n\n        /* shift in new bits */\n        buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n\n /* catch any trailing bits at the end of the line */\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 24);\n    *dst++ = bytebuff1;\n\n    buff2 = (buff2 << 8);\n    bytebuff2 = bytebuff1;\n    ready_bits -= 8;\n    }\n \n  return (0);\n  }",
          "fn_code_pos": [
            [
              8790,
              0
            ],
            [
              8871,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reverseSamples24bits",
            "parameters": {
              "spp": "uint16",
              "bps": "uint16",
              "width": "uint32",
              "ibuff": "uint8",
              "obuff": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nreverseSamples32bits (uint16 spp, uint16 bps, uint32 width, \n                      uint8 *ibuff, uint8 *obuff)\n  {\n  int    ready_bits = 0 /*, shift_width = 0 */;\n  /* int    bytes_per_sample, bytes_per_pixel; */\n  uint32 bit_offset;\n  uint32 src_byte = 0, high_bit = 0;\n  uint32 col;\n  uint32 longbuff1 = 0, longbuff2 = 0;\n  uint64 mask_bits = 0, match_bits = 0;\n  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n  unsigned char *src;\n  unsigned char *dst;\n  tsample_t sample;\n\n  if ((ibuff == NULL) || (obuff == NULL))\n    {\n    TIFFError(\"reverseSamples32bits\",\"Invalid image or work buffer\");\n    return (1);\n    }\n\n  ready_bits = 0;\n  mask_bits =  (uint64)-1 >> (64 - bps);\n  dst = obuff;\n\n  /* bytes_per_sample = (bps + 7) / 8; */\n  /* bytes_per_pixel  = ((bps * spp) + 7) / 8; */\n  /* if (bytes_per_pixel < (bytes_per_sample + 1)) */\n  /*   shift_width = bytes_per_pixel; */\n  /* else */\n  /*   shift_width = bytes_per_sample + 1; */\n\n  for (col = width; col > 0; col--)\n    {\n    /* Compute src byte(s) and bits within byte(s) */\n    bit_offset = (col - 1) * bps * spp;\n    for (sample = 0; sample < spp; sample++)\n      {\n      if (sample == 0)\n        {\n        src_byte = bit_offset / 8;\n        high_bit  = bit_offset % 8;\n        }\n      else\n        {\n        src_byte = (bit_offset + (sample * bps)) / 8;\n        high_bit  = (bit_offset + (sample * bps)) % 8;\n        }\n\n      src = ibuff + src_byte;\n      match_bits = mask_bits << (64 - high_bit - bps); \n      if (little_endian)\n        {\n\tlongbuff1 = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n        longbuff2 = longbuff1;\n        }\n      else\n        {\n\tlongbuff1 = (src[3] << 24) | (src[2] << 16) | (src[1] << 8) | src[0];\n        longbuff2 = longbuff1;\n\t}\n      buff3 = ((uint64)longbuff1 << 32) | longbuff2;\n      buff1 = (buff3 & match_bits) << (high_bit);\n\n      if (ready_bits < 32)\n        { /* add another bps bits to the buffer */\n        bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n        buff2 = (buff2 | (buff1 >> ready_bits));\n        }\n      else /* If we have a full buffer's worth, write it out */\n        {\n        bytebuff1 = (buff2 >> 56);\n        *dst++ = bytebuff1;\n        bytebuff2 = (buff2 >> 48);\n        *dst++ = bytebuff2;\n        bytebuff3 = (buff2 >> 40);\n        *dst++ = bytebuff3;\n        bytebuff4 = (buff2 >> 32);\n        *dst++ = bytebuff4;\n        ready_bits -= 32;\n                    \n        /* shift in new bits */\n        buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n        }\n      ready_bits += bps;\n      }\n    }\n  while (ready_bits > 0)\n    {\n    bytebuff1 = (buff2 >> 56);\n    *dst++ = bytebuff1;\n    buff2 = (buff2 << 8);\n    ready_bits -= 8;\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              8874,
              0
            ],
            [
              8972,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reverseSamples32bits",
            "parameters": {
              "spp": "uint16",
              "bps": "uint16",
              "width": "uint32",
              "ibuff": "uint8",
              "obuff": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nreverseSamplesBytes (uint16 spp, uint16 bps, uint32 width, \n                     uint8 *src, uint8 *dst)\n  {\n  int i;\n  uint32  col, bytes_per_pixel, col_offset;\n  uint8   bytebuff1;\n  unsigned char swapbuff[32];\n  \n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"reverseSamplesBytes\",\"Invalid input or output buffer\");\n    return (1);\n    }\n\n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if( bytes_per_pixel > sizeof(swapbuff) )\n  {\n    TIFFError(\"reverseSamplesBytes\",\"bytes_per_pixel too large\");\n    return (1);\n  }\n  switch (bps / 8)\n     {\n     case 8:  /* Use memcpy for multiple bytes per sample data */\n     case 4:\n     case 3:\n     case 2: for (col = 0; col < (width / 2); col++)\n               {\n\t       col_offset = col * bytes_per_pixel;                     \n\t       _TIFFmemcpy (swapbuff, src + col_offset, bytes_per_pixel);\n\t       _TIFFmemcpy (src + col_offset, dst - col_offset - bytes_per_pixel, bytes_per_pixel);\n\t       _TIFFmemcpy (dst - col_offset - bytes_per_pixel, swapbuff, bytes_per_pixel);\n               }\n\t     break;\n     case 1: /* Use byte copy only for single byte per sample data */\n             for (col = 0; col < (width / 2); col++)\n               { \n\t       for (i = 0; i < spp; i++)\n                  {\n\t\t  bytebuff1 = *src;\n\t\t  *src++ = *(dst - spp + i);\n                  *(dst - spp + i) = bytebuff1;\n\t\t  }\n\t\tdst -= spp;\n                }\n\t     break;\n     default: TIFFError(\"reverseSamplesBytes\",\"Unsupported bit depth %d\", bps);\n       return (1);\n     }\n  return (0);\n  }",
          "fn_code_pos": [
            [
              8974,
              0
            ],
            [
              9024,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reverseSamplesBytes",
            "parameters": {
              "spp": "uint16",
              "bps": "uint16",
              "width": "uint32",
              "src": "uint8",
              "dst": "uint8"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nmirrorImage(uint16 spp, uint16 bps, uint16 mirror, uint32 width, uint32 length, unsigned char *ibuff)\n  {\n  int      shift_width;\n  uint32   bytes_per_pixel, bytes_per_sample;\n  uint32   row, rowsize, row_offset;\n  unsigned char *line_buff = NULL;\n  unsigned char *src;\n  unsigned char *dst;\n\n  src = ibuff;\n  rowsize = ((width * bps * spp) + 7) / 8;\n  switch (mirror)\n    {\n    case MIRROR_BOTH:\n    case MIRROR_VERT: \n             line_buff = (unsigned char *)_TIFFmalloc(rowsize);\n             if (line_buff == NULL)\n               {\n\t       TIFFError (\"mirrorImage\", \"Unable to allocate mirror line buffer of %1u bytes\", rowsize);\n               return (-1);\n               }\n\n             dst = ibuff + (rowsize * (length - 1));\n             for (row = 0; row < length / 2; row++)\n               {\n\t      _TIFFmemcpy(line_buff, src, rowsize);\n\t      _TIFFmemcpy(src, dst,  rowsize);\n\t      _TIFFmemcpy(dst, line_buff, rowsize);\n               src += (rowsize);\n               dst -= (rowsize);                                 \n               }\n             if (line_buff)\n               _TIFFfree(line_buff);\n             if (mirror == MIRROR_VERT)\n               break;\n             /* Fall through */\n    case MIRROR_HORIZ :\n              if ((bps % 8) == 0) /* byte aligned data */\n                { \n                for (row = 0; row < length; row++)\n                  {\n\t\t  row_offset = row * rowsize;\n                  src = ibuff + row_offset;\n                  dst = ibuff + row_offset + rowsize;\n                  if (reverseSamplesBytes(spp, bps, width, src, dst))\n                    {\n\t\t    return (-1);\n                    }\n\t\t  }\n\t\t}\n\t      else\n                { /* non 8 bit per sample  data */\n                if (!(line_buff = (unsigned char *)_TIFFmalloc(rowsize + 1)))\n                  {\n                  TIFFError(\"mirrorImage\", \"Unable to allocate mirror line buffer\");\n                  return (-1);\n                  }\n                bytes_per_sample = (bps + 7) / 8;\n                bytes_per_pixel  = ((bps * spp) + 7) / 8;\n                if (bytes_per_pixel < (bytes_per_sample + 1))\n                  shift_width = bytes_per_pixel;\n                else\n                  shift_width = bytes_per_sample + 1;\n\n                for (row = 0; row < length; row++)\n                  {\n\t\t  row_offset = row * rowsize;\n                  src = ibuff + row_offset;\n                  _TIFFmemset (line_buff, '\\0', rowsize);\n                  switch (shift_width)\n                    {\n                    case 1: if (reverseSamples16bits(spp, bps, width, src, line_buff))\n                              {\n\t\t              _TIFFfree(line_buff);\n                              return (-1);\n                              }\n                             _TIFFmemcpy (src, line_buff, rowsize);\n                             break;\n                    case 2: if (reverseSamples24bits(spp, bps, width, src, line_buff))\n                              {\n\t\t              _TIFFfree(line_buff);\n                              return (-1);\n                              }\n                             _TIFFmemcpy (src, line_buff, rowsize);\n                             break;\n                    case 3: \n                    case 4: \n                    case 5: if (reverseSamples32bits(spp, bps, width, src, line_buff))\n                              {\n\t\t              _TIFFfree(line_buff);\n                              return (-1);\n                              }\n                             _TIFFmemcpy (src, line_buff, rowsize);\n                             break;\n                    default: TIFFError(\"mirrorImage\",\"Unsupported bit depth %d\", bps);\n\t\t             _TIFFfree(line_buff);\n                             return (-1);      \n                    }\n\t\t  }\n                if (line_buff)\n                  _TIFFfree(line_buff);\n\t\t}\n             break;\n\n    default: TIFFError (\"mirrorImage\", \"Invalid mirror axis %d\", mirror);\n             return (-1);\n             break;\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              9028,
              0
            ],
            [
              9139,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mirrorImage",
            "parameters": {
              "spp": "uint16",
              "bps": "uint16",
              "mirror": "uint16",
              "width": "uint32",
              "length": "uint32",
              "ibuff": "unsigned char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ninvertImage(uint16 photometric, uint16 spp, uint16 bps, uint32 width, uint32 length, unsigned char *work_buff)\n  {\n  uint32   row, col;\n  unsigned char *src;\n  uint16        *src_uint16;\n  uint32        *src_uint32;\n\n  if (spp != 1)\n    {\n    TIFFError(\"invertImage\", \"Image inversion not supported for more than one sample per pixel\");\n    return (-1);\n    }\n\n  if (photometric !=  PHOTOMETRIC_MINISWHITE && photometric !=  PHOTOMETRIC_MINISBLACK)\n    {\n    TIFFError(\"invertImage\", \"Only black and white and grayscale images can be inverted\");\n    return (-1);\n    }\n\n  src = work_buff;\n  if (src == NULL)\n    {\n    TIFFError (\"invertImage\", \"Invalid crop buffer passed to invertImage\");\n    return (-1);\n    }\n\n  switch (bps)\n    {\n    case 32: src_uint32 = (uint32 *)src;\n             for (row = 0; row < length; row++)\n               for (col = 0; col < width; col++)\n                 {\n\t\t *src_uint32 = ~(*src_uint32);\n                  src_uint32++;\n                 }\n            break;\n    case 16: src_uint16 = (uint16 *)src;\n             for (row = 0; row < length; row++)\n               for (col = 0; col < width; col++)\n                 {\n\t\t *src_uint16 = ~(*src_uint16);\n                  src_uint16++;\n                 }\n            break;\n    case 8:\n    case 4:\n    case 2:\n    case 1: for (row = 0; row < length; row++)\n              for (col = 0; col < width; col += 8 / bps)\n                {\n                *src = ~(*src);\n                src++;\n                }\n            break;\n    default: TIFFError(\"invertImage\", \"Unsupported bit depth %d\", bps);\n      return (-1);\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              9142,
              0
            ],
            [
              9202,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "invertImage",
            "parameters": {
              "photometric": "uint16",
              "spp": "uint16",
              "bps": "uint16",
              "width": "uint32",
              "length": "uint32",
              "work_buff": "unsigned char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "getopt(int argc, char * const argv[], const char *optstring)",
          "fn_dec_pos": [
            [
              131,
              11
            ],
            [
              131,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {
              "argc": "int",
              "argv": "char",
              "optstring": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "readContigStripsIntoBuffer   (TIFF*, uint8*)",
          "fn_dec_pos": [
            [
              452,
              12
            ],
            [
              452,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readContigStripsIntoBuffer",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "readSeparateStripsIntoBuffer (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *)",
          "fn_dec_pos": [
            [
              453,
              12
            ],
            [
              453,
              103
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readSeparateStripsIntoBuffer",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "readContigTilesIntoBuffer    (TIFF*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16)",
          "fn_dec_pos": [
            [
              454,
              12
            ],
            [
              454,
              107
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readContigTilesIntoBuffer",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "readSeparateTilesIntoBuffer  (TIFF*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16)",
          "fn_dec_pos": [
            [
              455,
              12
            ],
            [
              455,
              107
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "readSeparateTilesIntoBuffer",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "writeBufferToContigStrips    (TIFF*, uint8*, uint32)",
          "fn_dec_pos": [
            [
              456,
              12
            ],
            [
              456,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "writeBufferToContigStrips",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "writeBufferToContigTiles     (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *)",
          "fn_dec_pos": [
            [
              457,
              12
            ],
            [
              457,
              103
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "writeBufferToContigTiles",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "writeBufferToSeparateStrips  (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *)",
          "fn_dec_pos": [
            [
              458,
              12
            ],
            [
              458,
              103
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "writeBufferToSeparateStrips",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "writeBufferToSeparateTiles   (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *)",
          "fn_dec_pos": [
            [
              459,
              12
            ],
            [
              459,
              103
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "writeBufferToSeparateTiles",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "extractContigSamplesToBuffer (uint8 *, uint8 *, uint32, uint32, tsample_t, \n                                         uint16, uint16, struct dump_opts *)",
          "fn_dec_pos": [
            [
              460,
              12
            ],
            [
              461,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamplesToBuffer",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "processCompressOptions(char*)",
          "fn_dec_pos": [
            [
              462,
              11
            ],
            [
              462,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              463,
              12
            ],
            [
              463,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "initImageData (struct image_data *)",
          "fn_dec_pos": [
            [
              466,
              12
            ],
            [
              466,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initImageData",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "initCropMasks (struct crop_mask *)",
          "fn_dec_pos": [
            [
              467,
              12
            ],
            [
              467,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initCropMasks",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "initPageSetup (struct pagedef *, struct pageseg *, struct buffinfo [])",
          "fn_dec_pos": [
            [
              468,
              12
            ],
            [
              468,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initPageSetup",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "initDumpOptions(struct dump_opts *)",
          "fn_dec_pos": [
            [
              469,
              12
            ],
            [
              469,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initDumpOptions",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "process_command_opts (int, char *[], char *, char *, uint32 *,\n\t                    uint16 *, uint16 *, uint32 *, uint32 *, uint32 *,\n\t\t            struct crop_mask *, struct pagedef *, \n                            struct dump_opts *, \n                            unsigned int *, unsigned int *)",
          "fn_dec_pos": [
            [
              472,
              6
            ],
            [
              476,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "process_command_opts",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "update_output_file (TIFF **, char *, int, char *, unsigned int *)",
          "fn_dec_pos": [
            [
              477,
              12
            ],
            [
              477,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "update_output_file",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "get_page_geometry (char *, struct pagedef*)",
          "fn_dec_pos": [
            [
              481,
              12
            ],
            [
              481,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_page_geometry",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "computeInputPixelOffsets(struct crop_mask *, struct image_data *, \n                                     struct offset *)",
          "fn_dec_pos": [
            [
              482,
              12
            ],
            [
              483,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "computeInputPixelOffsets",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "computeOutputPixelOffsets (struct crop_mask *, struct image_data *,\n\t\t\t\t       struct pagedef *, struct pageseg *,\n                                       struct dump_opts *)",
          "fn_dec_pos": [
            [
              484,
              12
            ],
            [
              486,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "computeOutputPixelOffsets",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "loadImage(TIFF *, struct image_data *, struct dump_opts *, unsigned char **)",
          "fn_dec_pos": [
            [
              487,
              12
            ],
            [
              487,
              88
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "loadImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "correct_orientation(struct image_data *, unsigned char **)",
          "fn_dec_pos": [
            [
              488,
              12
            ],
            [
              488,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "correct_orientation",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "getCropOffsets(struct image_data *, struct crop_mask *, struct dump_opts *)",
          "fn_dec_pos": [
            [
              489,
              12
            ],
            [
              489,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getCropOffsets",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "processCropSelections(struct image_data *, struct crop_mask *, \n                                  unsigned char **, struct buffinfo [])",
          "fn_dec_pos": [
            [
              490,
              12
            ],
            [
              491,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCropSelections",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "writeSelections(TIFF *, TIFF **, struct crop_mask *, struct image_data *,\n                            struct dump_opts *, struct buffinfo [],\n                            char *, char *, unsigned int*, unsigned int)",
          "fn_dec_pos": [
            [
              492,
              12
            ],
            [
              494,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "writeSelections",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "createImageSection(uint32, unsigned char **)",
          "fn_dec_pos": [
            [
              497,
              12
            ],
            [
              497,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "createImageSection",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "extractImageSection(struct image_data *, struct pageseg *, \n                                unsigned char *, unsigned char *)",
          "fn_dec_pos": [
            [
              498,
              12
            ],
            [
              499,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractImageSection",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "writeSingleSection(TIFF *, TIFF *, struct image_data *,\n                               struct dump_opts *, uint32, uint32,\n\t\t\t       double, double, unsigned char *)",
          "fn_dec_pos": [
            [
              500,
              12
            ],
            [
              502,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "writeSingleSection",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "writeImageSections(TIFF *, TIFF *, struct image_data *,\n                               struct pagedef *, struct pageseg *, \n                               struct dump_opts *, unsigned char *, \n                               unsigned char **)",
          "fn_dec_pos": [
            [
              503,
              12
            ],
            [
              506,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "writeImageSections",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "createCroppedImage(struct image_data *, struct crop_mask *, \n                               unsigned char **, unsigned char **)",
          "fn_dec_pos": [
            [
              508,
              12
            ],
            [
              509,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "createCroppedImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "writeCroppedImage(TIFF *, TIFF *, struct image_data *image,\n                              struct dump_opts * dump,\n                              uint32, uint32, unsigned char *, int, int)",
          "fn_dec_pos": [
            [
              510,
              12
            ],
            [
              512,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "writeCroppedImage",
            "parameters": {
              "image": "struct image_data",
              "dump": "struct dump_opts"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "rotateContigSamples8bits(uint16, uint16, uint16, uint32, \n                                    uint32,   uint32, uint8 *, uint8 *)",
          "fn_dec_pos": [
            [
              515,
              11
            ],
            [
              516,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rotateContigSamples8bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "rotateContigSamples16bits(uint16, uint16, uint16, uint32, \n                                     uint32,   uint32, uint8 *, uint8 *)",
          "fn_dec_pos": [
            [
              517,
              11
            ],
            [
              518,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rotateContigSamples16bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "rotateContigSamples24bits(uint16, uint16, uint16, uint32, \n                                     uint32,   uint32, uint8 *, uint8 *)",
          "fn_dec_pos": [
            [
              519,
              11
            ],
            [
              520,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rotateContigSamples24bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "rotateContigSamples32bits(uint16, uint16, uint16, uint32, \n                                     uint32,   uint32, uint8 *, uint8 *)",
          "fn_dec_pos": [
            [
              521,
              11
            ],
            [
              522,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rotateContigSamples32bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "rotateImage(uint16, struct image_data *, uint32 *, uint32 *,\n \t\t       unsigned char **)",
          "fn_dec_pos": [
            [
              523,
              11
            ],
            [
              524,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rotateImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "mirrorImage(uint16, uint16, uint16, uint32, uint32,\n\t\t       unsigned char *)",
          "fn_dec_pos": [
            [
              525,
              11
            ],
            [
              526,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "mirrorImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "invertImage(uint16, uint16, uint16, uint32, uint32,\n\t\t       unsigned char *)",
          "fn_dec_pos": [
            [
              527,
              11
            ],
            [
              528,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "invertImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "reverseSamples8bits  (uint16, uint16, uint32, uint8 *, uint8 *)",
          "fn_dec_pos": [
            [
              531,
              11
            ],
            [
              531,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reverseSamples8bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "reverseSamples16bits (uint16, uint16, uint32, uint8 *, uint8 *)",
          "fn_dec_pos": [
            [
              532,
              11
            ],
            [
              532,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reverseSamples16bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "reverseSamples24bits (uint16, uint16, uint32, uint8 *, uint8 *)",
          "fn_dec_pos": [
            [
              533,
              11
            ],
            [
              533,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reverseSamples24bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "reverseSamples32bits (uint16, uint16, uint32, uint8 *, uint8 *)",
          "fn_dec_pos": [
            [
              534,
              11
            ],
            [
              534,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reverseSamples32bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "reverseSamplesBytes  (uint16, uint16, uint32, uint8 *, uint8 *)",
          "fn_dec_pos": [
            [
              535,
              11
            ],
            [
              535,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "reverseSamplesBytes",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "extractSeparateRegion(struct image_data *, struct crop_mask *,\n\t\t \t\t unsigned char *, unsigned char *, int)",
          "fn_dec_pos": [
            [
              538,
              11
            ],
            [
              539,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractSeparateRegion",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "extractCompositeRegions(struct image_data *,  struct crop_mask *,\n\t\t\t\t   unsigned char *, unsigned char *)",
          "fn_dec_pos": [
            [
              540,
              11
            ],
            [
              541,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractCompositeRegions",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "extractContigSamples8bits (uint8 *, uint8 *, uint32,\n \t                             tsample_t, uint16, uint16, \n                                     tsample_t, uint32, uint32)",
          "fn_dec_pos": [
            [
              542,
              11
            ],
            [
              544,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamples8bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "extractContigSamples16bits (uint8 *, uint8 *, uint32,\n \t                              tsample_t, uint16, uint16, \n                                      tsample_t, uint32, uint32)",
          "fn_dec_pos": [
            [
              545,
              11
            ],
            [
              547,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamples16bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "extractContigSamples24bits (uint8 *, uint8 *, uint32,\n \t                              tsample_t, uint16, uint16, \n                                      tsample_t, uint32, uint32)",
          "fn_dec_pos": [
            [
              548,
              11
            ],
            [
              550,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamples24bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "extractContigSamples32bits (uint8 *, uint8 *, uint32,\n\t                              tsample_t, uint16, uint16, \n                                      tsample_t, uint32, uint32)",
          "fn_dec_pos": [
            [
              551,
              11
            ],
            [
              553,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamples32bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "extractContigSamplesBytes (uint8 *, uint8 *, uint32, \n                                      tsample_t, uint16, uint16, \n\t\t\t\t      tsample_t, uint32, uint32)",
          "fn_dec_pos": [
            [
              554,
              11
            ],
            [
              556,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamplesBytes",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "extractContigSamplesShifted8bits (uint8 *, uint8 *, uint32,\n \t                                     tsample_t, uint16, uint16,\n                                             tsample_t, uint32, uint32,\n                                             int)",
          "fn_dec_pos": [
            [
              557,
              11
            ],
            [
              560,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamplesShifted8bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "extractContigSamplesShifted16bits (uint8 *, uint8 *, uint32,\n \t                                      tsample_t, uint16, uint16, \n\t\t\t\t              tsample_t, uint32, uint32,\n                                              int)",
          "fn_dec_pos": [
            [
              561,
              11
            ],
            [
              564,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamplesShifted16bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "extractContigSamplesShifted24bits (uint8 *, uint8 *, uint32,\n \t                                      tsample_t, uint16, uint16, \n\t\t\t\t              tsample_t, uint32, uint32,\n                                              int)",
          "fn_dec_pos": [
            [
              565,
              11
            ],
            [
              568,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamplesShifted24bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "extractContigSamplesShifted32bits (uint8 *, uint8 *, uint32,\n\t                                      tsample_t, uint16, uint16, \n\t\t\t\t              tsample_t, uint32, uint32,\n                                              int)",
          "fn_dec_pos": [
            [
              569,
              11
            ],
            [
              572,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamplesShifted32bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "extractContigSamplesToTileBuffer(uint8 *, uint8 *, uint32, uint32,\n  \t                                    uint32, uint32, tsample_t, uint16,\n\t\t\t\t\t    uint16, uint16, struct dump_opts *)",
          "fn_dec_pos": [
            [
              573,
              11
            ],
            [
              575,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "extractContigSamplesToTileBuffer",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "combineSeparateSamples8bits (uint8 *[], uint8 *, uint32, uint32,\n                                        uint16, uint16, FILE *, int, int)",
          "fn_dec_pos": [
            [
              578,
              11
            ],
            [
              579,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateSamples8bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "combineSeparateSamples16bits (uint8 *[], uint8 *, uint32, uint32,\n                                         uint16, uint16, FILE *, int, int)",
          "fn_dec_pos": [
            [
              580,
              11
            ],
            [
              581,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateSamples16bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "combineSeparateSamples24bits (uint8 *[], uint8 *, uint32, uint32,\n                                         uint16, uint16, FILE *, int, int)",
          "fn_dec_pos": [
            [
              582,
              11
            ],
            [
              583,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateSamples24bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "combineSeparateSamples32bits (uint8 *[], uint8 *, uint32, uint32,\n                                         uint16, uint16, FILE *, int, int)",
          "fn_dec_pos": [
            [
              584,
              11
            ],
            [
              585,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateSamples32bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "combineSeparateSamplesBytes (unsigned char *[], unsigned char *,\n\t\t\t\t\tuint32, uint32, tsample_t, uint16,\n                                        FILE *, int, int)",
          "fn_dec_pos": [
            [
              586,
              11
            ],
            [
              588,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateSamplesBytes",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "combineSeparateTileSamples8bits (uint8 *[], uint8 *, uint32, uint32,\n                                            uint32, uint32, uint16, uint16, \n                                            FILE *, int, int)",
          "fn_dec_pos": [
            [
              590,
              11
            ],
            [
              592,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateTileSamples8bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "combineSeparateTileSamples16bits (uint8 *[], uint8 *, uint32, uint32,\n                                             uint32, uint32, uint16, uint16,\n                                             FILE *, int, int)",
          "fn_dec_pos": [
            [
              593,
              11
            ],
            [
              595,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateTileSamples16bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "combineSeparateTileSamples24bits (uint8 *[], uint8 *, uint32, uint32,\n                                             uint32, uint32, uint16, uint16,\n                                             FILE *, int, int)",
          "fn_dec_pos": [
            [
              596,
              11
            ],
            [
              598,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateTileSamples24bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "combineSeparateTileSamples32bits (uint8 *[], uint8 *, uint32, uint32,\n                                             uint32, uint32, uint16, uint16,\n                                             FILE *, int, int)",
          "fn_dec_pos": [
            [
              599,
              11
            ],
            [
              601,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateTileSamples32bits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "combineSeparateTileSamplesBytes (unsigned char *[], unsigned char *,\n\t\t\t  \t\t    uint32, uint32, uint32, uint32, \n                                            tsample_t, uint16, FILE *, int, int)",
          "fn_dec_pos": [
            [
              602,
              11
            ],
            [
              604,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "combineSeparateTileSamplesBytes",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dump_info  (FILE *, int, char *, char *, ...)",
          "fn_dec_pos": [
            [
              607,
              12
            ],
            [
              607,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_info",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "dump_data  (FILE *, int, char *, unsigned char *, uint32)",
          "fn_dec_pos": [
            [
              608,
              12
            ],
            [
              608,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_data",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dump_byte  (FILE *, int, char *, unsigned char)",
          "fn_dec_pos": [
            [
              609,
              12
            ],
            [
              609,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_byte",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dump_short (FILE *, int, char *, uint16)",
          "fn_dec_pos": [
            [
              610,
              12
            ],
            [
              610,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_short",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dump_long  (FILE *, int, char *, uint32)",
          "fn_dec_pos": [
            [
              611,
              12
            ],
            [
              611,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_long",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dump_wide  (FILE *, int, char *, uint64)",
          "fn_dec_pos": [
            [
              612,
              12
            ],
            [
              612,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_wide",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dump_buffer (FILE *, int, uint32, uint32, uint32, unsigned char *)",
          "fn_dec_pos": [
            [
              613,
              12
            ],
            [
              613,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump_buffer",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct offset {\n  uint32  tmargin;\n  uint32  lmargin;\n  uint32  bmargin;\n  uint32  rmargin;\n  uint32  crop_width;\n  uint32  crop_length;\n  uint32  startx;\n  uint32  endx;\n  uint32  starty;\n  uint32  endy;\n}",
          {
            "tmargin": "uint32",
            "lmargin": "uint32",
            "bmargin": "uint32",
            "rmargin": "uint32",
            "crop_width": "uint32",
            "crop_length": "uint32",
            "startx": "uint32",
            "endx": "uint32",
            "starty": "uint32",
            "endy": "uint32"
          },
          "offset",
          [
            215,
            0
          ],
          [
            226,
            1
          ]
        ],
        [
          "struct  buffinfo {\n  uint32 size;           /* size of this buffer */\n  unsigned char *buffer; /* address of the allocated buffer */\n}",
          {
            "size": "uint32",
            "*buffer": "unsigned char"
          },
          "buffinfo",
          [
            234,
            0
          ],
          [
            237,
            1
          ]
        ],
        [
          "struct  zone {\n  int   position;  /* ordinal of segment to be extracted */\n  int   total;     /* total equal sized divisions of crop area */\n  }",
          {
            "position": "int",
            "total": "int"
          },
          "zone",
          [
            239,
            0
          ],
          [
            242,
            3
          ]
        ],
        [
          "struct  pageseg {\n  uint32 x1;        /* index of left edge */\n  uint32 x2;        /* index of right edge */\n  uint32 y1;        /* index of top edge */\n  uint32 y2;        /* index of bottom edge */\n  int    position;  /* ordinal of segment to be extracted */\n  int    total;     /* total equal sized divisions of crop area */\n  uint32 buffsize;  /* size of buffer needed to hold the cropped zone */\n}",
          {
            "x1": "uint32",
            "x2": "uint32",
            "y1": "uint32",
            "y2": "uint32",
            "position": "int",
            "total": "int",
            "buffsize": "uint32"
          },
          "pageseg",
          [
            244,
            0
          ],
          [
            252,
            1
          ]
        ],
        [
          "struct  coordpairs {\n  double X1;        /* index of left edge in current units */\n  double X2;        /* index of right edge in current units */\n  double Y1;        /* index of top edge in current units */\n  double Y2;        /* index of bottom edge in current units */\n}",
          {
            "X1": "double",
            "X2": "double",
            "Y1": "double",
            "Y2": "double"
          },
          "coordpairs",
          [
            254,
            0
          ],
          [
            259,
            1
          ]
        ],
        [
          "struct  region {\n  uint32 x1;        /* pixel offset of left edge */\n  uint32 x2;        /* pixel offset of right edge */\n  uint32 y1;        /* pixel offset of top edge */\n  uint32 y2;        /* picel offset of bottom edge */\n  uint32 width;     /* width in pixels */\n  uint32 length;    /* length in pixels */\n  uint32 buffsize;  /* size of buffer needed to hold the cropped region */\n  unsigned char *buffptr; /* address of start of the region */\n}",
          {
            "x1": "uint32",
            "x2": "uint32",
            "y1": "uint32",
            "y2": "uint32",
            "width": "uint32",
            "length": "uint32",
            "buffsize": "uint32",
            "*buffptr": "unsigned char"
          },
          "region",
          [
            261,
            0
          ],
          [
            270,
            1
          ]
        ],
        [
          "struct crop_mask {\n  double width;           /* Selection width for master crop region in requested units */\n  double length;          /* Selection length for master crop region in requesed units */\n  double margins[4];      /* Top, left, bottom, right margins */\n  float  xres;            /* Horizontal resolution read from image*/\n  float  yres;            /* Vertical resolution read from image */\n  uint32 combined_width;  /* Width of combined cropped zones */\n  uint32 combined_length; /* Length of combined cropped zones */\n  uint32 bufftotal;       /* Size of buffer needed to hold all the cropped region */\n  uint16 img_mode;        /* Composite or separate images created from zones or regions */\n  uint16 exp_mode;        /* Export input images or selections to one or more files */\n  uint16 crop_mode;       /* Crop options to be applied */\n  uint16 res_unit;        /* Resolution unit for margins and selections */\n  uint16 edge_ref;        /* Reference edge for sections extraction and combination */\n  uint16 rotation;        /* Clockwise rotation of the extracted region or image */\n  uint16 mirror;          /* Mirror extracted region or image horizontally or vertically */\n  uint16 invert;          /* Invert the color map of image or region */\n  uint16 photometric;     /* Status of photometric interpretation for inverted image */\n  uint16 selections;      /* Number of regions or zones selected */\n  uint16 regions;         /* Number of regions delimited by corner coordinates */\n  struct region regionlist[MAX_REGIONS]; /* Regions within page or master crop region */\n  uint16 zones;           /* Number of zones delimited by Ordinal:Total requested */\n  struct zone zonelist[MAX_REGIONS]; /* Zones indices to define a region */\n  struct coordpairs corners[MAX_REGIONS]; /* Coordinates of upper left and lower right corner */\n}",
          {
            "width": "double",
            "length": "double",
            "margins[4]": "double",
            "xres": "float",
            "yres": "float",
            "combined_width": "uint32",
            "combined_length": "uint32",
            "bufftotal": "uint32",
            "img_mode": "uint16",
            "exp_mode": "uint16",
            "crop_mode": "uint16",
            "res_unit": "uint16",
            "edge_ref": "uint16",
            "rotation": "uint16",
            "mirror": "uint16",
            "invert": "uint16",
            "photometric": "uint16",
            "selections": "uint16",
            "regions": "uint16",
            "regionlist[MAX_REGIONS]": "struct region",
            "zones": "uint16",
            "zonelist[MAX_REGIONS]": "struct zone",
            "corners[MAX_REGIONS]": "struct coordpairs"
          },
          "crop_mask",
          [
            276,
            0
          ],
          [
            300,
            1
          ]
        ],
        [
          "struct paperdef {\n  char   name[MAX_PAPERNAME_LENGTH];\n  double width;\n  double length;\n  double asratio;\n  }",
          {
            "name[MAX_PAPERNAME_LENGTH]": "char",
            "width": "double",
            "length": "double",
            "asratio": "double"
          },
          "paperdef",
          [
            325,
            0
          ],
          [
            330,
            3
          ]
        ],
        [
          "struct image_data {\n  float  xres;\n  float  yres;\n  uint32 width;\n  uint32 length;\n  uint16 res_unit;\n  uint16 bps;\n  uint16 spp;\n  uint16 planar;\n  uint16 photometric;\n  uint16 orientation;\n  uint16 compression;\n  uint16 adjustments;\n}",
          {
            "xres": "float",
            "yres": "float",
            "width": "uint32",
            "length": "uint32",
            "res_unit": "uint16",
            "bps": "uint16",
            "spp": "uint16",
            "planar": "uint16",
            "photometric": "uint16",
            "orientation": "uint16",
            "compression": "uint16",
            "adjustments": "uint16"
          },
          "image_data",
          [
            388,
            0
          ],
          [
            401,
            1
          ]
        ],
        [
          "struct pagedef {\n  char          name[16];\n  double        width;    /* width in pixels */\n  double        length;   /* length in pixels */\n  double        hmargin;  /* margins to subtract from width of sections */\n  double        vmargin;  /* margins to subtract from height of sections */\n  double        hres;     /* horizontal resolution for output */\n  double        vres;     /* vertical resolution for output */\n  uint32        mode;     /* bitmask of modifiers to page format */\n  uint16        res_unit; /* resolution unit for output image */\n  unsigned int  rows;     /* number of section rows */\n  unsigned int  cols;     /* number of section cols */\n  unsigned int  orient;   /* portrait, landscape, seascape, auto */\n}",
          {
            "name[16]": "char",
            "width": "double",
            "length": "double",
            "hmargin": "double",
            "vmargin": "double",
            "hres": "double",
            "vres": "double",
            "mode": "uint32",
            "res_unit": "uint16",
            "rows": "unsigned int",
            "cols": "unsigned int",
            "orient": "unsigned int"
          },
          "pagedef",
          [
            404,
            0
          ],
          [
            417,
            1
          ]
        ],
        [
          "struct dump_opts {\n  int  debug;\n  int  format;\n  int  level;\n  char mode[4];\n  char infilename[PATH_MAX + 1];\n  char outfilename[PATH_MAX + 1];\n  FILE *infile;\n  FILE *outfile;\n  }",
          {
            "debug": "int",
            "format": "int",
            "level": "int",
            "mode[4]": "char",
            "infilename[PATH_MAX + 1]": "char",
            "outfilename[PATH_MAX + 1]": "char",
            "*infile": "FILE",
            "*outfile": "FILE"
          },
          "dump_opts",
          [
            419,
            0
          ],
          [
            428,
            3
          ]
        ],
        [
          "struct cpTag {\n\tuint16\ttag;\n\tuint16\tcount;\n\tTIFFDataType type;\n}",
          {
            "tag": "uint16",
            "count": "uint16",
            "type": "TIFFDataType"
          },
          "cpTag",
          [
            1549,
            7
          ],
          [
            1553,
            1
          ]
        ],
        [
          "struct offset {\n  uint32  tmargin;\n  uint32  lmargin;\n  uint32  bmargin;\n  uint32  rmargin;\n  uint32  crop_width;\n  uint32  crop_length;\n  uint32  startx;\n  uint32  endx;\n  uint32  starty;\n  uint32  endy;\n}",
          {
            "tmargin": "uint32",
            "lmargin": "uint32",
            "bmargin": "uint32",
            "rmargin": "uint32",
            "crop_width": "uint32",
            "crop_length": "uint32",
            "startx": "uint32",
            "endx": "uint32",
            "starty": "uint32",
            "endy": "uint32"
          },
          "offset",
          [
            215,
            0
          ],
          [
            226,
            1
          ]
        ],
        [
          "struct  buffinfo {\n  uint32 size;           /* size of this buffer */\n  unsigned char *buffer; /* address of the allocated buffer */\n}",
          {
            "size": "uint32",
            "*buffer": "unsigned char"
          },
          "buffinfo",
          [
            234,
            0
          ],
          [
            237,
            1
          ]
        ],
        [
          "struct  zone {\n  int   position;  /* ordinal of segment to be extracted */\n  int   total;     /* total equal sized divisions of crop area */\n  }",
          {
            "position": "int",
            "total": "int"
          },
          "zone",
          [
            239,
            0
          ],
          [
            242,
            3
          ]
        ],
        [
          "struct  pageseg {\n  uint32 x1;        /* index of left edge */\n  uint32 x2;        /* index of right edge */\n  uint32 y1;        /* index of top edge */\n  uint32 y2;        /* index of bottom edge */\n  int    position;  /* ordinal of segment to be extracted */\n  int    total;     /* total equal sized divisions of crop area */\n  uint32 buffsize;  /* size of buffer needed to hold the cropped zone */\n}",
          {
            "x1": "uint32",
            "x2": "uint32",
            "y1": "uint32",
            "y2": "uint32",
            "position": "int",
            "total": "int",
            "buffsize": "uint32"
          },
          "pageseg",
          [
            244,
            0
          ],
          [
            252,
            1
          ]
        ],
        [
          "struct  coordpairs {\n  double X1;        /* index of left edge in current units */\n  double X2;        /* index of right edge in current units */\n  double Y1;        /* index of top edge in current units */\n  double Y2;        /* index of bottom edge in current units */\n}",
          {
            "X1": "double",
            "X2": "double",
            "Y1": "double",
            "Y2": "double"
          },
          "coordpairs",
          [
            254,
            0
          ],
          [
            259,
            1
          ]
        ],
        [
          "struct  region {\n  uint32 x1;        /* pixel offset of left edge */\n  uint32 x2;        /* pixel offset of right edge */\n  uint32 y1;        /* pixel offset of top edge */\n  uint32 y2;        /* picel offset of bottom edge */\n  uint32 width;     /* width in pixels */\n  uint32 length;    /* length in pixels */\n  uint32 buffsize;  /* size of buffer needed to hold the cropped region */\n  unsigned char *buffptr; /* address of start of the region */\n}",
          {
            "x1": "uint32",
            "x2": "uint32",
            "y1": "uint32",
            "y2": "uint32",
            "width": "uint32",
            "length": "uint32",
            "buffsize": "uint32",
            "*buffptr": "unsigned char"
          },
          "region",
          [
            261,
            0
          ],
          [
            270,
            1
          ]
        ],
        [
          "struct crop_mask {\n  double width;           /* Selection width for master crop region in requested units */\n  double length;          /* Selection length for master crop region in requesed units */\n  double margins[4];      /* Top, left, bottom, right margins */\n  float  xres;            /* Horizontal resolution read from image*/\n  float  yres;            /* Vertical resolution read from image */\n  uint32 combined_width;  /* Width of combined cropped zones */\n  uint32 combined_length; /* Length of combined cropped zones */\n  uint32 bufftotal;       /* Size of buffer needed to hold all the cropped region */\n  uint16 img_mode;        /* Composite or separate images created from zones or regions */\n  uint16 exp_mode;        /* Export input images or selections to one or more files */\n  uint16 crop_mode;       /* Crop options to be applied */\n  uint16 res_unit;        /* Resolution unit for margins and selections */\n  uint16 edge_ref;        /* Reference edge for sections extraction and combination */\n  uint16 rotation;        /* Clockwise rotation of the extracted region or image */\n  uint16 mirror;          /* Mirror extracted region or image horizontally or vertically */\n  uint16 invert;          /* Invert the color map of image or region */\n  uint16 photometric;     /* Status of photometric interpretation for inverted image */\n  uint16 selections;      /* Number of regions or zones selected */\n  uint16 regions;         /* Number of regions delimited by corner coordinates */\n  struct region regionlist[MAX_REGIONS]; /* Regions within page or master crop region */\n  uint16 zones;           /* Number of zones delimited by Ordinal:Total requested */\n  struct zone zonelist[MAX_REGIONS]; /* Zones indices to define a region */\n  struct coordpairs corners[MAX_REGIONS]; /* Coordinates of upper left and lower right corner */\n}",
          {
            "width": "double",
            "length": "double",
            "margins[4]": "double",
            "xres": "float",
            "yres": "float",
            "combined_width": "uint32",
            "combined_length": "uint32",
            "bufftotal": "uint32",
            "img_mode": "uint16",
            "exp_mode": "uint16",
            "crop_mode": "uint16",
            "res_unit": "uint16",
            "edge_ref": "uint16",
            "rotation": "uint16",
            "mirror": "uint16",
            "invert": "uint16",
            "photometric": "uint16",
            "selections": "uint16",
            "regions": "uint16",
            "regionlist[MAX_REGIONS]": "struct region",
            "zones": "uint16",
            "zonelist[MAX_REGIONS]": "struct zone",
            "corners[MAX_REGIONS]": "struct coordpairs"
          },
          "crop_mask",
          [
            276,
            0
          ],
          [
            300,
            1
          ]
        ],
        [
          "struct region",
          {},
          "",
          [
            296,
            2
          ],
          [
            296,
            15
          ]
        ],
        [
          "struct zone",
          {},
          "",
          [
            298,
            2
          ],
          [
            298,
            13
          ]
        ],
        [
          "struct coordpairs",
          {},
          "",
          [
            299,
            2
          ],
          [
            299,
            19
          ]
        ],
        [
          "struct paperdef {\n  char   name[MAX_PAPERNAME_LENGTH];\n  double width;\n  double length;\n  double asratio;\n  }",
          {
            "name[MAX_PAPERNAME_LENGTH]": "char",
            "width": "double",
            "length": "double",
            "asratio": "double"
          },
          "paperdef",
          [
            325,
            0
          ],
          [
            330,
            3
          ]
        ],
        [
          "struct paperdef",
          {},
          "",
          [
            335,
            0
          ],
          [
            335,
            15
          ]
        ],
        [
          "struct image_data {\n  float  xres;\n  float  yres;\n  uint32 width;\n  uint32 length;\n  uint16 res_unit;\n  uint16 bps;\n  uint16 spp;\n  uint16 planar;\n  uint16 photometric;\n  uint16 orientation;\n  uint16 compression;\n  uint16 adjustments;\n}",
          {
            "xres": "float",
            "yres": "float",
            "width": "uint32",
            "length": "uint32",
            "res_unit": "uint16",
            "bps": "uint16",
            "spp": "uint16",
            "planar": "uint16",
            "photometric": "uint16",
            "orientation": "uint16",
            "compression": "uint16",
            "adjustments": "uint16"
          },
          "image_data",
          [
            388,
            0
          ],
          [
            401,
            1
          ]
        ],
        [
          "struct pagedef {\n  char          name[16];\n  double        width;    /* width in pixels */\n  double        length;   /* length in pixels */\n  double        hmargin;  /* margins to subtract from width of sections */\n  double        vmargin;  /* margins to subtract from height of sections */\n  double        hres;     /* horizontal resolution for output */\n  double        vres;     /* vertical resolution for output */\n  uint32        mode;     /* bitmask of modifiers to page format */\n  uint16        res_unit; /* resolution unit for output image */\n  unsigned int  rows;     /* number of section rows */\n  unsigned int  cols;     /* number of section cols */\n  unsigned int  orient;   /* portrait, landscape, seascape, auto */\n}",
          {
            "name[16]": "char",
            "width": "double",
            "length": "double",
            "hmargin": "double",
            "vmargin": "double",
            "hres": "double",
            "vres": "double",
            "mode": "uint32",
            "res_unit": "uint16",
            "rows": "unsigned int",
            "cols": "unsigned int",
            "orient": "unsigned int"
          },
          "pagedef",
          [
            404,
            0
          ],
          [
            417,
            1
          ]
        ],
        [
          "struct dump_opts {\n  int  debug;\n  int  format;\n  int  level;\n  char mode[4];\n  char infilename[PATH_MAX + 1];\n  char outfilename[PATH_MAX + 1];\n  FILE *infile;\n  FILE *outfile;\n  }",
          {
            "debug": "int",
            "format": "int",
            "level": "int",
            "mode[4]": "char",
            "infilename[PATH_MAX + 1]": "char",
            "outfilename[PATH_MAX + 1]": "char",
            "*infile": "FILE",
            "*outfile": "FILE"
          },
          "dump_opts",
          [
            419,
            0
          ],
          [
            428,
            3
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            453,
            84
          ],
          [
            453,
            100
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            457,
            84
          ],
          [
            457,
            100
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            458,
            84
          ],
          [
            458,
            100
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            459,
            84
          ],
          [
            459,
            100
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            461,
            57
          ],
          [
            461,
            73
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            466,
            27
          ],
          [
            466,
            44
          ]
        ],
        [
          "struct crop_mask",
          {},
          "",
          [
            467,
            27
          ],
          [
            467,
            43
          ]
        ],
        [
          "struct pagedef",
          {},
          "",
          [
            468,
            27
          ],
          [
            468,
            41
          ]
        ],
        [
          "struct pageseg",
          {},
          "",
          [
            468,
            45
          ],
          [
            468,
            59
          ]
        ],
        [
          "struct buffinfo",
          {},
          "",
          [
            468,
            63
          ],
          [
            468,
            78
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            469,
            28
          ],
          [
            469,
            44
          ]
        ],
        [
          "struct crop_mask",
          {},
          "",
          [
            474,
            14
          ],
          [
            474,
            30
          ]
        ],
        [
          "struct pagedef",
          {},
          "",
          [
            474,
            34
          ],
          [
            474,
            48
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            475,
            28
          ],
          [
            475,
            44
          ]
        ],
        [
          "struct pagedef",
          {},
          "",
          [
            481,
            39
          ],
          [
            481,
            53
          ]
        ],
        [
          "struct crop_mask",
          {},
          "",
          [
            482,
            37
          ],
          [
            482,
            53
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            482,
            57
          ],
          [
            482,
            74
          ]
        ],
        [
          "struct offset",
          {},
          "",
          [
            483,
            37
          ],
          [
            483,
            50
          ]
        ],
        [
          "struct crop_mask",
          {},
          "",
          [
            484,
            39
          ],
          [
            484,
            55
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            484,
            59
          ],
          [
            484,
            76
          ]
        ],
        [
          "struct pagedef",
          {},
          "",
          [
            485,
            11
          ],
          [
            485,
            25
          ]
        ],
        [
          "struct pageseg",
          {},
          "",
          [
            485,
            29
          ],
          [
            485,
            43
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            486,
            39
          ],
          [
            486,
            55
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            487,
            30
          ],
          [
            487,
            47
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            487,
            51
          ],
          [
            487,
            67
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            488,
            32
          ],
          [
            488,
            49
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            489,
            27
          ],
          [
            489,
            44
          ]
        ],
        [
          "struct crop_mask",
          {},
          "",
          [
            489,
            48
          ],
          [
            489,
            64
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            489,
            68
          ],
          [
            489,
            84
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            490,
            34
          ],
          [
            490,
            51
          ]
        ],
        [
          "struct crop_mask",
          {},
          "",
          [
            490,
            55
          ],
          [
            490,
            71
          ]
        ],
        [
          "struct buffinfo",
          {},
          "",
          [
            491,
            52
          ],
          [
            491,
            67
          ]
        ],
        [
          "struct crop_mask",
          {},
          "",
          [
            492,
            45
          ],
          [
            492,
            61
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            492,
            65
          ],
          [
            492,
            82
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            493,
            28
          ],
          [
            493,
            44
          ]
        ],
        [
          "struct buffinfo",
          {},
          "",
          [
            493,
            48
          ],
          [
            493,
            63
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            498,
            32
          ],
          [
            498,
            49
          ]
        ],
        [
          "struct pageseg",
          {},
          "",
          [
            498,
            53
          ],
          [
            498,
            67
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            500,
            47
          ],
          [
            500,
            64
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            501,
            31
          ],
          [
            501,
            47
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            503,
            47
          ],
          [
            503,
            64
          ]
        ],
        [
          "struct pagedef",
          {},
          "",
          [
            504,
            31
          ],
          [
            504,
            45
          ]
        ],
        [
          "struct pageseg",
          {},
          "",
          [
            504,
            49
          ],
          [
            504,
            63
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            505,
            31
          ],
          [
            505,
            47
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            508,
            31
          ],
          [
            508,
            48
          ]
        ],
        [
          "struct crop_mask",
          {},
          "",
          [
            508,
            52
          ],
          [
            508,
            68
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            510,
            46
          ],
          [
            510,
            63
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            511,
            30
          ],
          [
            511,
            46
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            523,
            31
          ],
          [
            523,
            48
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            538,
            33
          ],
          [
            538,
            50
          ]
        ],
        [
          "struct crop_mask",
          {},
          "",
          [
            538,
            54
          ],
          [
            538,
            70
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            540,
            35
          ],
          [
            540,
            52
          ]
        ],
        [
          "struct crop_mask",
          {},
          "",
          [
            540,
            57
          ],
          [
            540,
            73
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            575,
            25
          ],
          [
            575,
            41
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            1147,
            8
          ],
          [
            1147,
            24
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            1228,
            39
          ],
          [
            1228,
            55
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            1323,
            39
          ],
          [
            1323,
            55
          ]
        ],
        [
          "struct cpTag {\n\tuint16\ttag;\n\tuint16\tcount;\n\tTIFFDataType type;\n}",
          {
            "tag": "uint16",
            "count": "uint16",
            "type": "TIFFDataType"
          },
          "cpTag",
          [
            1549,
            7
          ],
          [
            1553,
            1
          ]
        ],
        [
          "struct crop_mask",
          {},
          "",
          [
            1596,
            14
          ],
          [
            1596,
            30
          ]
        ],
        [
          "struct pagedef",
          {},
          "",
          [
            1596,
            43
          ],
          [
            1596,
            57
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            1597,
            28
          ],
          [
            1597,
            44
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            2193,
            2
          ],
          [
            2193,
            19
          ]
        ],
        [
          "struct crop_mask",
          {},
          "",
          [
            2194,
            2
          ],
          [
            2194,
            18
          ]
        ],
        [
          "struct pagedef",
          {},
          "",
          [
            2195,
            2
          ],
          [
            2195,
            16
          ]
        ],
        [
          "struct pageseg",
          {},
          "",
          [
            2196,
            2
          ],
          [
            2196,
            16
          ]
        ],
        [
          "struct buffinfo",
          {},
          "",
          [
            2197,
            2
          ],
          [
            2197,
            17
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            2198,
            2
          ],
          [
            2198,
            18
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            3527,
            29
          ],
          [
            3527,
            45
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            3603,
            43
          ],
          [
            3603,
            59
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            4762,
            41
          ],
          [
            4762,
            57
          ]
        ],
        [
          "struct pagedef",
          {},
          "",
          [
            4952,
            31
          ],
          [
            4952,
            45
          ]
        ],
        [
          "struct pagedef",
          {},
          "",
          [
            4977,
            15
          ],
          [
            4977,
            29
          ]
        ],
        [
          "struct pageseg",
          {},
          "",
          [
            4977,
            37
          ],
          [
            4977,
            51
          ]
        ],
        [
          "struct buffinfo",
          {},
          "",
          [
            4978,
            15
          ],
          [
            4978,
            30
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            5014,
            15
          ],
          [
            5014,
            32
          ]
        ],
        [
          "struct crop_mask",
          {},
          "",
          [
            5031,
            15
          ],
          [
            5031,
            31
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            5072,
            28
          ],
          [
            5072,
            44
          ]
        ],
        [
          "struct crop_mask",
          {},
          "",
          [
            5086,
            25
          ],
          [
            5086,
            41
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            5086,
            49
          ],
          [
            5086,
            66
          ]
        ],
        [
          "struct offset",
          {},
          "",
          [
            5087,
            25
          ],
          [
            5087,
            38
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            5373,
            15
          ],
          [
            5373,
            32
          ]
        ],
        [
          "struct crop_mask",
          {},
          "",
          [
            5373,
            41
          ],
          [
            5373,
            57
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            5373,
            65
          ],
          [
            5373,
            81
          ]
        ],
        [
          "struct offset",
          {},
          "",
          [
            5375,
            2
          ],
          [
            5375,
            15
          ]
        ],
        [
          "struct offset",
          {},
          "",
          [
            5382,
            32
          ],
          [
            5382,
            45
          ]
        ],
        [
          "struct crop_mask",
          {},
          "",
          [
            5590,
            27
          ],
          [
            5590,
            43
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            5590,
            51
          ],
          [
            5590,
            68
          ]
        ],
        [
          "struct pagedef",
          {},
          "",
          [
            5591,
            27
          ],
          [
            5591,
            41
          ]
        ],
        [
          "struct pageseg",
          {},
          "",
          [
            5591,
            49
          ],
          [
            5591,
            63
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            5592,
            27
          ],
          [
            5592,
            43
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            5820,
            20
          ],
          [
            5820,
            37
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            5820,
            46
          ],
          [
            5820,
            62
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            6234,
            32
          ],
          [
            6234,
            49
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            6659,
            20
          ],
          [
            6659,
            37
          ]
        ],
        [
          "struct pageseg",
          {},
          "",
          [
            6659,
            46
          ],
          [
            6659,
            60
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            6998,
            40
          ],
          [
            6998,
            57
          ]
        ],
        [
          "struct pagedef",
          {},
          "",
          [
            6999,
            5
          ],
          [
            6999,
            19
          ]
        ],
        [
          "struct pageseg",
          {},
          "",
          [
            6999,
            27
          ],
          [
            6999,
            41
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            7000,
            5
          ],
          [
            7000,
            21
          ]
        ],
        [
          "struct image_data",
          {},
          "",
          [
            7056,
            40
          ],
          [
            7056,
            57
          ]
        ],
        [
          "struct dump_opts",
          {},
          "",
          [
            7057,
            19
          ],
          [
            7057,
            35
          ]
        ],
        [
          "struct cpTag",
          {},
          "",
          [
            7064,
            2
          ],
          [
            7064,
            14
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            110,
            0
          ],
          [
            111,
            0
          ]
        ],
        [
          "#include \"tiffiop.h\"\n",
          [
            111,
            0
          ],
          [
            112,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            113,
            0
          ],
          [
            114,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            114,
            0
          ],
          [
            115,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            115,
            0
          ],
          [
            116,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            116,
            0
          ],
          [
            117,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            117,
            0
          ],
          [
            118,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            118,
            0
          ],
          [
            119,
            0
          ]
        ],
        [
          "#include <sys/stat.h>\n",
          [
            119,
            0
          ],
          [
            120,
            0
          ]
        ],
        [
          "#include <assert.h>\n",
          [
            120,
            0
          ],
          [
            121,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            123,
            0
          ],
          [
            124,
            0
          ]
        ],
        [
          "# include <stdint.h>\n",
          [
            127,
            0
          ],
          [
            128,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            135,
            0
          ],
          [
            136,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            138,
            0
          ],
          [
            139,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/tiffsplit.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tTIFF *in, *out;\n\n\tif (argc < 2) {\n                fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\t\tfprintf(stderr, \"usage: tiffsplit input.tif [prefix]\\n\");\n\t\treturn (-3);\n\t}\n\tif (argc > 2) {\n\t\tstrncpy(fname, argv[2], sizeof(fname));\n\t\tfname[sizeof(fname) - 1] = '\\0';\n\t}\n\tin = TIFFOpen(argv[1], \"r\");\n\tif (in != NULL) {\n\t\tdo {\n\t\t\tsize_t path_len;\n\t\t\tchar *path;\n\t\t\t\n\t\t\tnewfilename();\n\n\t\t\tpath_len = strlen(fname) + sizeof(TIFF_SUFFIX);\n\t\t\tpath = (char *) _TIFFmalloc(path_len);\n\t\t\tstrncpy(path, fname, path_len);\n\t\t\tpath[path_len - 1] = '\\0';\n\t\t\tstrncat(path, TIFF_SUFFIX, path_len - strlen(path) - 1);\n\t\t\tout = TIFFOpen(path, TIFFIsBigEndian(in)?\"wb\":\"wl\");\n\t\t\t_TIFFfree(path);\n\n\t\t\tif (out == NULL)\n\t\t\t\treturn (-2);\n\t\t\tif (!tiffcp(in, out))\n\t\t\t\treturn (-1);\n\t\t\tTIFFClose(out);\n\t\t} while (TIFFReadDirectory(in));\n\t\t(void) TIFFClose(in);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              93,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nnewfilename(void)\n{\n\tstatic int first = 1;\n\tstatic long lastTurn;\n\tstatic long fnum;\n\tstatic short defname;\n\tstatic char *fpnt;\n\n\tif (first) {\n\t\tif (fname[0]) {\n\t\t\tfpnt = fname + strlen(fname);\n\t\t\tdefname = 0;\n\t\t} else {\n\t\t\tfname[0] = 'x';\n\t\t\tfpnt = fname + 1;\n\t\t\tdefname = 1;\n\t\t}\n\t\tfirst = 0;\n\t}\n#define\tMAXFILES\t17576\n\tif (fnum == MAXFILES) {\n\t\tif (!defname || fname[0] == 'z') {\n\t\t\tfprintf(stderr, \"tiffsplit: too many files.\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tfname[0]++;\n\t\tfnum = 0;\n\t}\n\tif (fnum % 676 == 0) {\n\t\tif (fnum != 0) {\n\t\t\t/*\n                         * advance to next letter every 676 pages\n\t\t\t * condition for 'z'++ will be covered above\n                         */\n\t\t\tfpnt[0]++;\n\t\t} else {\n\t\t\t/*\n                         * set to 'a' if we are on the very first file\n                         */\n\t\t\tfpnt[0] = 'a';\n\t\t}\n\t\t/*\n                 * set the value of the last turning point\n                 */\n\t\tlastTurn = fnum;\n\t}\n\t/* \n         * start from 0 every 676 times (provided by lastTurn)\n         * this keeps us within a-z boundaries\n         */\n\tfpnt[1] = (char)((fnum - lastTurn) / 26) + 'a';\n\t/* \n         * cycle last letter every file, from a-z, then repeat\n         */\n\tfpnt[2] = (char)(fnum % 26) + 'a';\n\tfnum++;\n}",
          "fn_code_pos": [
            [
              95,
              0
            ],
            [
              152,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "newfilename",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ntiffcp(TIFF* in, TIFF* out)\n{\n\tuint16 bitspersample, samplesperpixel, compression, shortv, *shortav;\n\tuint32 w, l;\n\tfloat floatv;\n\tchar *stringv;\n\tuint32 longv;\n\n\tCopyField(TIFFTAG_SUBFILETYPE, longv);\n\tCopyField(TIFFTAG_TILEWIDTH, w);\n\tCopyField(TIFFTAG_TILELENGTH, l);\n\tCopyField(TIFFTAG_IMAGEWIDTH, w);\n\tCopyField(TIFFTAG_IMAGELENGTH, l);\n\tCopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);\n\tCopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n\tCopyField(TIFFTAG_COMPRESSION, compression);\n\tif (compression == COMPRESSION_JPEG) {\n\t\tuint32 count = 0;\n\t\tvoid *table = NULL;\n\t\tif (TIFFGetField(in, TIFFTAG_JPEGTABLES, &count, &table)\n\t\t    && count > 0 && table) {\n\t\t    TIFFSetField(out, TIFFTAG_JPEGTABLES, count, table);\n\t\t}\n\t}\n        CopyField(TIFFTAG_PHOTOMETRIC, shortv);\n\tCopyField(TIFFTAG_PREDICTOR, shortv);\n\tCopyField(TIFFTAG_THRESHHOLDING, shortv);\n\tCopyField(TIFFTAG_FILLORDER, shortv);\n\tCopyField(TIFFTAG_ORIENTATION, shortv);\n\tCopyField(TIFFTAG_MINSAMPLEVALUE, shortv);\n\tCopyField(TIFFTAG_MAXSAMPLEVALUE, shortv);\n\tCopyField(TIFFTAG_XRESOLUTION, floatv);\n\tCopyField(TIFFTAG_YRESOLUTION, floatv);\n\tCopyField(TIFFTAG_GROUP3OPTIONS, longv);\n\tCopyField(TIFFTAG_GROUP4OPTIONS, longv);\n\tCopyField(TIFFTAG_RESOLUTIONUNIT, shortv);\n\tCopyField(TIFFTAG_PLANARCONFIG, shortv);\n\tCopyField(TIFFTAG_ROWSPERSTRIP, longv);\n\tCopyField(TIFFTAG_XPOSITION, floatv);\n\tCopyField(TIFFTAG_YPOSITION, floatv);\n\tCopyField(TIFFTAG_IMAGEDEPTH, longv);\n\tCopyField(TIFFTAG_TILEDEPTH, longv);\n\tCopyField(TIFFTAG_SAMPLEFORMAT, shortv);\n\tCopyField2(TIFFTAG_EXTRASAMPLES, shortv, shortav);\n\t{ uint16 *red, *green, *blue;\n\t  CopyField3(TIFFTAG_COLORMAP, red, green, blue);\n\t}\n\t{ uint16 shortv2;\n\t  CopyField2(TIFFTAG_PAGENUMBER, shortv, shortv2);\n\t}\n\tCopyField(TIFFTAG_ARTIST, stringv);\n\tCopyField(TIFFTAG_IMAGEDESCRIPTION, stringv);\n\tCopyField(TIFFTAG_MAKE, stringv);\n\tCopyField(TIFFTAG_MODEL, stringv);\n\tCopyField(TIFFTAG_SOFTWARE, stringv);\n\tCopyField(TIFFTAG_DATETIME, stringv);\n\tCopyField(TIFFTAG_HOSTCOMPUTER, stringv);\n\tCopyField(TIFFTAG_PAGENAME, stringv);\n\tCopyField(TIFFTAG_DOCUMENTNAME, stringv);\n\tCopyField(TIFFTAG_BADFAXLINES, longv);\n\tCopyField(TIFFTAG_CLEANFAXDATA, longv);\n\tCopyField(TIFFTAG_CONSECUTIVEBADFAXLINES, longv);\n\tCopyField(TIFFTAG_FAXRECVPARAMS, longv);\n\tCopyField(TIFFTAG_FAXRECVTIME, longv);\n\tCopyField(TIFFTAG_FAXSUBADDRESS, stringv);\n\tCopyField(TIFFTAG_FAXDCS, stringv);\n\tif (TIFFIsTiled(in))\n\t\treturn (cpTiles(in, out));\n\telse\n\t\treturn (cpStrips(in, out));\n}",
          "fn_code_pos": [
            [
              154,
              0
            ],
            [
              225,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiffcp",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncpStrips(TIFF* in, TIFF* out)\n{\n\ttmsize_t bufsize  = TIFFStripSize(in);\n\tunsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);\n\n\tif (buf) {\n\t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n\t\tuint64 *bytecounts;\n\n\t\tif (!TIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts)) {\n\t\t\tfprintf(stderr, \"tiffsplit: strip byte counts are missing\\n\");\n                        _TIFFfree(buf);\n\t\t\treturn (0);\n\t\t}\n\t\tfor (s = 0; s < ns; s++) {\n\t\t\tif (bytecounts[s] > (uint64)bufsize) {\n\t\t\t\tbuf = (unsigned char *)_TIFFrealloc(buf, (tmsize_t)bytecounts[s]);\n\t\t\t\tif (!buf)\n\t\t\t\t\treturn (0);\n\t\t\t\tbufsize = (tmsize_t)bytecounts[s];\n\t\t\t}\n\t\t\tif (TIFFReadRawStrip(in, s, buf, (tmsize_t)bytecounts[s]) < 0 ||\n\t\t\t    TIFFWriteRawStrip(out, s, buf, (tmsize_t)bytecounts[s]) < 0) {\n\t\t\t\t_TIFFfree(buf);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(buf);\n\t\treturn (1);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              227,
              0
            ],
            [
              259,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpStrips",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncpTiles(TIFF* in, TIFF* out)\n{\n\ttmsize_t bufsize = TIFFTileSize(in);\n\tunsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);\n\n\tif (buf) {\n\t\tttile_t t, nt = TIFFNumberOfTiles(in);\n\t\tuint64 *bytecounts;\n\n\t\tif (!TIFFGetField(in, TIFFTAG_TILEBYTECOUNTS, &bytecounts)) {\n\t\t\tfprintf(stderr, \"tiffsplit: tile byte counts are missing\\n\");\n                        _TIFFfree(buf);\n\t\t\treturn (0);\n\t\t}\n\t\tfor (t = 0; t < nt; t++) {\n\t\t\tif (bytecounts[t] > (uint64) bufsize) {\n\t\t\t\tbuf = (unsigned char *)_TIFFrealloc(buf, (tmsize_t)bytecounts[t]);\n\t\t\t\tif (!buf)\n\t\t\t\t\treturn (0);\n\t\t\t\tbufsize = (tmsize_t)bytecounts[t];\n\t\t\t}\n\t\t\tif (TIFFReadRawTile(in, t, buf, (tmsize_t)bytecounts[t]) < 0 ||\n\t\t\t    TIFFWriteRawTile(out, t, buf, (tmsize_t)bytecounts[t]) < 0) {\n\t\t\t\t_TIFFfree(buf);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(buf);\n\t\treturn (1);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              261,
              0
            ],
            [
              293,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpTiles",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "getopt(int, char**, char*)",
          "fn_dec_pos": [
            [
              33,
              11
            ],
            [
              33,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "tiffcp(TIFF*, TIFF*)",
          "fn_dec_pos": [
            [
              49,
              11
            ],
            [
              49,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiffcp",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "newfilename(void)",
          "fn_dec_pos": [
            [
              50,
              12
            ],
            [
              50,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "newfilename",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "cpStrips(TIFF*, TIFF*)",
          "fn_dec_pos": [
            [
              51,
              11
            ],
            [
              51,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpStrips",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "cpTiles(TIFF*, TIFF*)",
          "fn_dec_pos": [
            [
              52,
              11
            ],
            [
              52,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpTiles",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/tiff2bw.c": {
      "fn_def_list": [
        {
          "fn_code": "static void\ncompresscontig(unsigned char* out, unsigned char* rgb, uint32 n)\n{\n\tregister int v, red = RED, green = GREEN, blue = BLUE;\n\n\twhile (n-- > 0) {\n\t\tv = red*(*rgb++);\n\t\tv += green*(*rgb++);\n\t\tv += blue*(*rgb++);\n\t\t*out++ = v>>8;\n\t}\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              62,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compresscontig",
            "parameters": {
              "out": "unsigned char",
              "rgb": "unsigned char",
              "n": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ncompresssep(unsigned char* out,\n\t    unsigned char* r, unsigned char* g, unsigned char* b, uint32 n)\n{\n\tregister uint32 red = RED, green = GREEN, blue = BLUE;\n\n\twhile (n-- > 0)\n\t\t*out++ = (unsigned char)\n\t\t\t((red*(*r++) + green*(*g++) + blue*(*b++)) >> 8);\n}",
          "fn_code_pos": [
            [
              64,
              0
            ],
            [
              73,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compresssep",
            "parameters": {
              "out": "unsigned char",
              "r": "unsigned char",
              "g": "unsigned char",
              "b": "unsigned char",
              "n": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ncheckcmap(TIFF* tif, int n, uint16* r, uint16* g, uint16* b)\n{\n\twhile (n-- > 0)\n\t\tif (*r++ >= 256 || *g++ >= 256 || *b++ >= 256)\n\t\t\treturn (16);\n\tTIFFWarning(TIFFFileName(tif), \"Assuming 8-bit colormap\");\n\treturn (8);\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              83,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "checkcmap",
            "parameters": {
              "tif": "TIFF",
              "n": "int",
              "r": "uint16",
              "g": "uint16",
              "b": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ncompresspalette(unsigned char* out, unsigned char* data, uint32 n, uint16* rmap, uint16* gmap, uint16* bmap)\n{\n\tregister int v, red = RED, green = GREEN, blue = BLUE;\n\n\twhile (n-- > 0) {\n\t\tunsigned int ix = *data++;\n\t\tv = red*rmap[ix];\n\t\tv += green*gmap[ix];\n\t\tv += blue*bmap[ix];\n\t\t*out++ = v>>8;\n\t}\n}",
          "fn_code_pos": [
            [
              85,
              0
            ],
            [
              97,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "compresspalette",
            "parameters": {
              "out": "unsigned char",
              "data": "unsigned char",
              "n": "uint32",
              "rmap": "uint16",
              "gmap": "uint16",
              "bmap": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tuint32 rowsperstrip = (uint32) -1;\n\tTIFF *in, *out;\n\tuint32 w, h;\n\tuint16 samplesperpixel;\n\tuint16 bitspersample;\n\tuint16 config;\n\tuint16 photometric;\n\tuint16* red;\n\tuint16* green;\n\tuint16* blue;\n\ttsize_t rowsize;\n\tregister uint32 row;\n\tregister tsample_t s;\n\tunsigned char *inbuf, *outbuf;\n\tchar thing[1024];\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char *optarg;\n#endif\n        \n        in = (TIFF *) NULL;\n        out = (TIFF *) NULL;\n        inbuf = (unsigned char *) NULL;\n        outbuf = (unsigned char *) NULL;\n\n\twhile ((c = getopt(argc, argv, \"c:r:R:G:B:\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'c':\t\t/* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* rows/strip */\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tRED = PCT(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\tGREEN = PCT(atoi(optarg));\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tBLUE = PCT(atoi(optarg));\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind < 2)\n\t\tusage();\n\tin = TIFFOpen(argv[optind], \"r\");\n\tif (in == NULL)\n\t\treturn (-1);\n\tphotometric = 0;\n\tTIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric);\n\tif (photometric != PHOTOMETRIC_RGB && photometric != PHOTOMETRIC_PALETTE ) {\n\t\tfprintf(stderr,\n\t    \"%s: Bad photometric; can only handle RGB and Palette images.\\n\",\n\t\t    argv[optind]);\n                goto tiff2bw_error;\n\t}\n\tTIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\tif (samplesperpixel != 1 && samplesperpixel != 3) {\n\t\tfprintf(stderr, \"%s: Bad samples/pixel %u.\\n\",\n\t\t    argv[optind], samplesperpixel);\n                goto tiff2bw_error;\n\t}\n\tif( photometric == PHOTOMETRIC_RGB && samplesperpixel != 3) {\n\t\tfprintf(stderr, \"%s: Bad samples/pixel %u for PHOTOMETRIC_RGB.\\n\",\n\t\t    argv[optind], samplesperpixel);\n                goto tiff2bw_error;\n\t}\n\tTIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\tif (bitspersample != 8) {\n\t\tfprintf(stderr,\n\t\t    \" %s: Sorry, only handle 8-bit samples.\\n\", argv[optind]);\n                goto tiff2bw_error;\n\t}\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &h);\n\tTIFFGetField(in, TIFFTAG_PLANARCONFIG, &config);\n\n\tout = TIFFOpen(argv[optind+1], \"w\");\n\tif (out == NULL)\n\t{\n                goto tiff2bw_error;\n\t}\n\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, w);\n\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, h);\n\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 1);\n\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tcpTags(in, out);\n\tif (compression != (uint16) -1) {\n\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\t\tswitch (compression) {\n\t\tcase COMPRESSION_JPEG:\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\t\tbreak;\n\t\tcase COMPRESSION_LZW:\n\t\tcase COMPRESSION_DEFLATE:\n\t\t\tif (predictor != 0)\n\t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\t\tbreak;\n\t\t}\n\t}\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);\n\tsnprintf(thing, sizeof(thing), \"B&W version of %s\", argv[optind]);\n\tTIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, thing);\n\tTIFFSetField(out, TIFFTAG_SOFTWARE, \"tiff2bw\");\n\toutbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(out));\n        if( !outbuf )\n        {\n            fprintf(stderr, \"Out of memory\\n\");\n            goto tiff2bw_error;\n        }\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\n\t    TIFFDefaultStripSize(out, rowsperstrip));\n\n#define\tpack(a,b)\t((a)<<8 | (b))\n\tswitch (pack(photometric, config)) {\n\tcase pack(PHOTOMETRIC_PALETTE, PLANARCONFIG_CONTIG):\n\tcase pack(PHOTOMETRIC_PALETTE, PLANARCONFIG_SEPARATE):\n\t\tTIFFGetField(in, TIFFTAG_COLORMAP, &red, &green, &blue);\n\t\t/*\n\t\t * Convert 16-bit colormap to 8-bit (unless it looks\n\t\t * like an old-style 8-bit colormap).\n\t\t */\n\t\tif (checkcmap(in, 1<<bitspersample, red, green, blue) == 16) {\n\t\t\tint i;\n#define\tCVT(x)\t\t(((x) * 255L) / ((1L<<16)-1))\n\t\t\tfor (i = (1<<bitspersample)-1; i >= 0; i--) {\n\t\t\t\tred[i] = CVT(red[i]);\n\t\t\t\tgreen[i] = CVT(green[i]);\n\t\t\t\tblue[i] = CVT(blue[i]);\n\t\t\t}\n#undef CVT\n\t\t}\n\t\tinbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n                if( !inbuf )\n                {\n                    fprintf(stderr, \"Out of memory\\n\");\n                    goto tiff2bw_error;\n                }\n\t\tfor (row = 0; row < h; row++) {\n\t\t\tif (TIFFReadScanline(in, inbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t\tcompresspalette(outbuf, inbuf, w, red, green, blue);\n\t\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase pack(PHOTOMETRIC_RGB, PLANARCONFIG_CONTIG):\n\t\tinbuf = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n                if( !inbuf )\n                {\n                    fprintf(stderr, \"Out of memory\\n\");\n                    goto tiff2bw_error;\n                }\n\t\tfor (row = 0; row < h; row++) {\n\t\t\tif (TIFFReadScanline(in, inbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t\tcompresscontig(outbuf, inbuf, w);\n\t\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase pack(PHOTOMETRIC_RGB, PLANARCONFIG_SEPARATE):\n        {\n                tmsize_t inbufsize;\n\t\trowsize = TIFFScanlineSize(in);\n                inbufsize = TIFFSafeMultiply(tmsize_t, 3, rowsize);\n\t\tinbuf = (unsigned char *)_TIFFmalloc(inbufsize);\n                if( !inbuf )\n                {\n                    fprintf(stderr, \"Out of memory\\n\");\n                    goto tiff2bw_error;\n                }\n\t\tfor (row = 0; row < h; row++) {\n\t\t\tfor (s = 0; s < 3; s++)\n\t\t\t\tif (TIFFReadScanline(in,\n\t\t\t\t    inbuf+s*rowsize, row, s) < 0)\n                                        goto tiff2bw_error;\n\t\t\tcompresssep(outbuf,\n\t\t\t    inbuf, inbuf+rowsize, inbuf+2*rowsize, w);\n\t\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n        }\n\t}\n#undef pack\n        if (inbuf)\n                _TIFFfree(inbuf);\n        if (outbuf)\n                _TIFFfree(outbuf);\n        TIFFClose(in);\n\tTIFFClose(out);\n\treturn (0);\n\n tiff2bw_error:\n        if (inbuf)\n                _TIFFfree(inbuf);\n        if (outbuf)\n                _TIFFfree(outbuf);\n        if (out)\n                TIFFClose(out);\n        if (in)\n                TIFFClose(in);\n        return (-1);\n}",
          "fn_code_pos": [
            [
              106,
              0
            ],
            [
              320,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nprocessCompressOptions(char* opt)\n{\n\tif (streq(opt, \"none\"))\n\t\tcompression = COMPRESSION_NONE;\n\telse if (streq(opt, \"packbits\"))\n\t\tcompression = COMPRESSION_PACKBITS;\n\telse if (strneq(opt, \"jpeg\", 4)) {\n\t\tchar* cp = strchr(opt, ':');\n\n                compression = COMPRESSION_JPEG;\n                while( cp )\n                {\n                    if (isdigit((int)cp[1]))\n\t\t\tquality = atoi(cp+1);\n                    else if (cp[1] == 'r' )\n\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;\n                    else\n                        usage();\n\n                    cp = strchr(cp+1,':');\n                }\n\t} else if (strneq(opt, \"lzw\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_LZW;\n\t} else if (strneq(opt, \"zip\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_DEFLATE;\n\t} else\n\t\treturn (0);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              322,
              0
            ],
            [
              357,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {
              "opt": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ncpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type)\n{\n\tswitch (type) {\n\tcase TIFF_SHORT:\n\t\tif (count == 1) {\n\t\t\tuint16 shortv;\n\t\t\tCopyField(tag, shortv);\n\t\t} else if (count == 2) {\n\t\t\tuint16 shortv1, shortv2;\n\t\t\tCopyField2(tag, shortv1, shortv2);\n\t\t} else if (count == 4) {\n\t\t\tuint16 *tr, *tg, *tb, *ta;\n\t\t\tCopyField4(tag, tr, tg, tb, ta);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tuint16 shortv1;\n\t\t\tuint16* shortav;\n\t\t\tCopyField2(tag, shortv1, shortav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_LONG:\n\t\t{ uint32 longv;\n\t\t  CopyField(tag, longv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_RATIONAL:\n\t\tif (count == 1) {\n\t\t\tfloat floatv;\n\t\t\tCopyField(tag, floatv);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tfloat* floatav;\n\t\t\tCopyField(tag, floatav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_ASCII:\n\t\t{ char* stringv;\n\t\t  CopyField(tag, stringv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_DOUBLE:\n\t\tif (count == 1) {\n\t\t\tdouble doublev;\n\t\t\tCopyField(tag, doublev);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tdouble* doubleav;\n\t\t\tCopyField(tag, doubleav);\n\t\t}\n\t\tbreak;\n          default:\n                TIFFError(TIFFFileName(in),\n                          \"Data type %d is not supported, tag %d skipped.\",\n                          tag, type);\n\t}\n}",
          "fn_code_pos": [
            [
              368,
              0
            ],
            [
              421,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpTag",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF",
              "tag": "uint16",
              "count": "uint16",
              "type": "TIFFDataType"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ncpTags(TIFF* in, TIFF* out)\n{\n    struct cpTag *p;\n    for (p = tags; p < &tags[NTAGS]; p++)\n    {\n        if( p->tag == TIFFTAG_GROUP3OPTIONS )\n        {\n            uint16 compression;\n            if( !TIFFGetField(in, TIFFTAG_COMPRESSION, &compression) ||\n                    compression != COMPRESSION_CCITTFAX3 )\n                continue;\n        }\n        if( p->tag == TIFFTAG_GROUP4OPTIONS )\n        {\n            uint16 compression;\n            if( !TIFFGetField(in, TIFFTAG_COMPRESSION, &compression) ||\n                    compression != COMPRESSION_CCITTFAX4 )\n                continue;\n        }\n        cpTag(in, out, p->tag, p->count, p->type);\n    }\n}",
          "fn_code_pos": [
            [
              469,
              0
            ],
            [
              491,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpTags",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              516,
              0
            ],
            [
              527,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              48,
              12
            ],
            [
              48,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "processCompressOptions(char*)",
          "fn_dec_pos": [
            [
              49,
              11
            ],
            [
              49,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "cpTags(TIFF* in, TIFF* out)",
          "fn_dec_pos": [
            [
              104,
              12
            ],
            [
              104,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpTags",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct cpTag {\n\tuint16\ttag;\n\tuint16\tcount;\n\tTIFFDataType type;\n}",
          {
            "tag": "uint16",
            "count": "uint16",
            "type": "TIFFDataType"
          },
          "cpTag",
          [
            428,
            7
          ],
          [
            432,
            1
          ]
        ],
        [
          "struct cpTag {\n\tuint16\ttag;\n\tuint16\tcount;\n\tTIFFDataType type;\n}",
          {
            "tag": "uint16",
            "count": "uint16",
            "type": "TIFFDataType"
          },
          "cpTag",
          [
            428,
            7
          ],
          [
            432,
            1
          ]
        ],
        [
          "struct cpTag",
          {},
          "",
          [
            472,
            4
          ],
          [
            472,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include \"tiffiop.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/tiff2rgba.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tTIFF *in, *out;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char *optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"c:r:t:bn8\")) != -1)\n\t\tswitch (c) {\n\t\t\tcase 'b':\n\t\t\t\tprocess_by_block = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase 'c':\n\t\t\t\tif (streq(optarg, \"none\"))\n\t\t\t\t\tcompression = COMPRESSION_NONE;\n\t\t\t\telse if (streq(optarg, \"packbits\"))\n\t\t\t\t\tcompression = COMPRESSION_PACKBITS;\n\t\t\t\telse if (streq(optarg, \"lzw\"))\n\t\t\t\t\tcompression = COMPRESSION_LZW;\n\t\t\t\telse if (streq(optarg, \"jpeg\"))\n\t\t\t\t\tcompression = COMPRESSION_JPEG;\n\t\t\t\telse if (streq(optarg, \"zip\"))\n\t\t\t\t\tcompression = COMPRESSION_DEFLATE;\n\t\t\t\telse\n\t\t\t\t\tusage(-1);\n\t\t\t\tbreak;\n\n\t\t\tcase 'r':\n\t\t\t\trowsperstrip = atoi(optarg);\n\t\t\t\tbreak;\n\n\t\t\tcase 't':\n\t\t\t\trowsperstrip = atoi(optarg);\n\t\t\t\tbreak;\n\n\t\t\tcase 'n':\n\t\t\t\tno_alpha = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase '8':\n\t\t\t\tbigtiff_output = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase '?':\n\t\t\t\tusage(0);\n\t\t\t\t/*NOTREACHED*/\n\t\t}\n\n\tif (argc - optind < 2)\n\t\tusage(-1);\n\n\tout = TIFFOpen(argv[argc-1], bigtiff_output?\"w8\":\"w\");\n\tif (out == NULL)\n\t\treturn (-2);\n\n\tfor (; optind < argc-1; optind++) {\n\t\tin = TIFFOpen(argv[optind], \"r\");\n\t\tif (in != NULL) {\n\t\t\tdo {\n\t\t\t\tif (!tiffcvt(in, out) ||\n\t\t\t\t    !TIFFWriteDirectory(out)) {\n\t\t\t\t\t(void) TIFFClose(out);\n\t\t\t\t\t(void) TIFFClose(in);\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\t} while (TIFFReadDirectory(in));\n\t\t\t(void) TIFFClose(in);\n\t\t}\n\t}\n\t(void) TIFFClose(out);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              60,
              0
            ],
            [
              135,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncvt_by_tile( TIFF *in, TIFF *out )\n\n{\n    uint32* raster;\t\t\t/* retrieve RGBA image */\n    uint32  width, height;\t\t/* image width & height */\n    uint32  tile_width, tile_height;\n    uint32  row, col;\n    uint32  *wrk_line;\n    int\t    ok = 1;\n    uint32  rastersize, wrk_linesize;\n\n    TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(in, TIFFTAG_IMAGELENGTH, &height);\n\n    if( !TIFFGetField(in, TIFFTAG_TILEWIDTH, &tile_width)\n        || !TIFFGetField(in, TIFFTAG_TILELENGTH, &tile_height) ) {\n        TIFFError(TIFFFileName(in), \"Source image not tiled\");\n        return (0);\n    }\n    \n    TIFFSetField(out, TIFFTAG_TILEWIDTH, tile_width );\n    TIFFSetField(out, TIFFTAG_TILELENGTH, tile_height );\n\n    /*\n     * Allocate tile buffer\n     */\n    rastersize = tile_width * tile_height * sizeof (uint32);\n    if (tile_width != (rastersize / tile_height) / sizeof( uint32))\n    {\n\tTIFFError(TIFFFileName(in), \"Integer overflow when calculating raster buffer\");\n\texit(-1);\n    }\n    raster = (uint32*)_TIFFmalloc(rastersize);\n    if (raster == 0) {\n        TIFFError(TIFFFileName(in), \"No space for raster buffer\");\n        return (0);\n    }\n\n    /*\n     * Allocate a scanline buffer for swapping during the vertical\n     * mirroring pass.\n     */\n    wrk_linesize = tile_width * sizeof (uint32);\n    if (tile_width != wrk_linesize / sizeof (uint32))\n    {\n        TIFFError(TIFFFileName(in), \"Integer overflow when calculating wrk_line buffer\");\n\texit(-1);\n    }\n    wrk_line = (uint32*)_TIFFmalloc(wrk_linesize);\n    if (!wrk_line) {\n        TIFFError(TIFFFileName(in), \"No space for raster scanline buffer\");\n        ok = 0;\n    }\n    \n    /*\n     * Loop over the tiles.\n     */\n    for( row = 0; ok && row < height; row += tile_height )\n    {\n        for( col = 0; ok && col < width; col += tile_width )\n        {\n            uint32 i_row;\n\n            /* Read the tile into an RGBA array */\n            if (!TIFFReadRGBATile(in, col, row, raster)) {\n                ok = 0;\n                break;\n            }\n\n\n\t    /*\n\t     * XXX: raster array has 4-byte unsigned integer type, that is why\n\t     * we should rearrange it here.\n\t     */\n#if HOST_BIGENDIAN\n\t    TIFFSwabArrayOfLong(raster, tile_width * tile_height);\n#endif\n\n            /*\n             * For some reason the TIFFReadRGBATile() function chooses the\n             * lower left corner as the origin.  Vertically mirror scanlines.\n             */\n            for( i_row = 0; i_row < tile_height / 2; i_row++ )\n            {\n                uint32\t*top_line, *bottom_line;\n\n                top_line = raster + tile_width * i_row;\n                bottom_line = raster + tile_width * (tile_height-i_row-1);\n\n                _TIFFmemcpy(wrk_line, top_line, 4*tile_width);\n                _TIFFmemcpy(top_line, bottom_line, 4*tile_width);\n                _TIFFmemcpy(bottom_line, wrk_line, 4*tile_width);\n            }\n\n            /*\n             * Write out the result in a tile.\n             */\n\n            if( TIFFWriteEncodedTile( out,\n                                      TIFFComputeTile( out, col, row, 0, 0),\n                                      raster,\n                                      4 * tile_width * tile_height ) == -1 )\n            {\n                ok = 0;\n                break;\n            }\n        }\n    }\n\n    _TIFFfree( raster );\n    _TIFFfree( wrk_line );\n\n    return ok;\n}",
          "fn_code_pos": [
            [
              137,
              0
            ],
            [
              251,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cvt_by_tile",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncvt_by_strip( TIFF *in, TIFF *out )\n\n{\n    uint32* raster;\t\t\t/* retrieve RGBA image */\n    uint32  width, height;\t\t/* image width & height */\n    uint32  row;\n    uint32  *wrk_line;\n    int\t    ok = 1;\n    uint32  rastersize, wrk_linesize;\n\n    TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(in, TIFFTAG_IMAGELENGTH, &height);\n\n    if( !TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip) ) {\n        TIFFError(TIFFFileName(in), \"Source image not in strips\");\n        return (0);\n    }\n    \n    TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n    /*\n     * Allocate strip buffer\n     */\n    rastersize = width * rowsperstrip * sizeof (uint32);\n    if (width != (rastersize / rowsperstrip) / sizeof( uint32))\n    {\n\tTIFFError(TIFFFileName(in), \"Integer overflow when calculating raster buffer\");\n\texit(-1);\n    }\n    raster = (uint32*)_TIFFmalloc(rastersize);\n    if (raster == 0) {\n        TIFFError(TIFFFileName(in), \"No space for raster buffer\");\n        return (0);\n    }\n\n    /*\n     * Allocate a scanline buffer for swapping during the vertical\n     * mirroring pass.\n     */\n    wrk_linesize = width * sizeof (uint32);\n    if (width != wrk_linesize / sizeof (uint32))\n    {\n        TIFFError(TIFFFileName(in), \"Integer overflow when calculating wrk_line buffer\");\n\texit(-1);\n    }\n    wrk_line = (uint32*)_TIFFmalloc(wrk_linesize);\n    if (!wrk_line) {\n        TIFFError(TIFFFileName(in), \"No space for raster scanline buffer\");\n        ok = 0;\n    }\n    \n    /*\n     * Loop over the strips.\n     */\n    for( row = 0; ok && row < height; row += rowsperstrip )\n    {\n        int\trows_to_write, i_row;\n\n        /* Read the strip into an RGBA array */\n        if (!TIFFReadRGBAStrip(in, row, raster)) {\n            ok = 0;\n            break;\n        }\n\n\t/*\n\t * XXX: raster array has 4-byte unsigned integer type, that is why\n\t * we should rearrange it here.\n\t */\n#if HOST_BIGENDIAN\n\tTIFFSwabArrayOfLong(raster, width * rowsperstrip);\n#endif\n\n        /*\n         * Figure out the number of scanlines actually in this strip.\n         */\n        if( row + rowsperstrip > height )\n            rows_to_write = height - row;\n        else\n            rows_to_write = rowsperstrip;\n\n        /*\n         * For some reason the TIFFReadRGBAStrip() function chooses the\n         * lower left corner as the origin.  Vertically mirror scanlines.\n         */\n\n        for( i_row = 0; i_row < rows_to_write / 2; i_row++ )\n        {\n            uint32\t*top_line, *bottom_line;\n\n            top_line = raster + width * i_row;\n            bottom_line = raster + width * (rows_to_write-i_row-1);\n\n            _TIFFmemcpy(wrk_line, top_line, 4*width);\n            _TIFFmemcpy(top_line, bottom_line, 4*width);\n            _TIFFmemcpy(bottom_line, wrk_line, 4*width);\n        }\n\n        /*\n         * Write out the result in a strip\n         */\n\n        if( TIFFWriteEncodedStrip( out, row / rowsperstrip, raster,\n                                   4 * rows_to_write * width ) == -1 )\n        {\n            ok = 0;\n            break;\n        }\n    }\n\n    _TIFFfree( raster );\n    _TIFFfree( wrk_line );\n\n    return ok;\n}",
          "fn_code_pos": [
            [
              253,
              0
            ],
            [
              367,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cvt_by_strip",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncvt_whole_image( TIFF *in, TIFF *out )\n\n{\n    uint32* raster;\t\t\t/* retrieve RGBA image */\n    uint32  width, height;\t\t/* image width & height */\n    uint32  row;\n    size_t pixel_count;\n        \n    TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width);\n    TIFFGetField(in, TIFFTAG_IMAGELENGTH, &height);\n    pixel_count = width * height;\n\n    /* XXX: Check the integer overflow. */\n    if (!width || !height || pixel_count / width != height) {\n        TIFFError(TIFFFileName(in),\n\t\t  \"Malformed input file; can't allocate buffer for raster of %lux%lu size\",\n\t\t  (unsigned long)width, (unsigned long)height);\n        return 0;\n    }\n\n    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n    TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n    raster = (uint32*)_TIFFCheckMalloc(in, pixel_count, sizeof(uint32), \"raster buffer\");\n    if (raster == 0) {\n        TIFFError(TIFFFileName(in), \"Failed to allocate buffer (%lu elements of %lu each)\",\n\t\t  (unsigned long)pixel_count, (unsigned long)sizeof(uint32));\n        return (0);\n    }\n\n    /* Read the image in one chunk into an RGBA array */\n    if (!TIFFReadRGBAImageOriented(in, width, height, raster,\n                                   ORIENTATION_TOPLEFT, 0)) {\n        _TIFFfree(raster);\n        return (0);\n    }\n\n    /*\n     * XXX: raster array has 4-byte unsigned integer type, that is why\n     * we should rearrange it here.\n     */\n#if HOST_BIGENDIAN\n    TIFFSwabArrayOfLong(raster, width * height);\n#endif\n\n    /*\n     * Do we want to strip away alpha components?\n     */\n    if (no_alpha)\n    {\n        size_t count = pixel_count;\n        unsigned char *src, *dst;\n\n\tsrc = dst = (unsigned char *) raster;\n        while (count > 0)\n        {\n\t    *(dst++) = *(src++);\n\t    *(dst++) = *(src++);\n\t    *(dst++) = *(src++);\n\t    src++;\n\t    count--;\n        }\n    }\n\n    /*\n     * Write out the result in strips\n     */\n    for (row = 0; row < height; row += rowsperstrip)\n    {\n        unsigned char * raster_strip;\n        int\trows_to_write;\n        int\tbytes_per_pixel;\n\n        if (no_alpha)\n        {\n            raster_strip = ((unsigned char *) raster) + 3 * row * width;\n            bytes_per_pixel = 3;\n        }\n        else\n        {\n            raster_strip = (unsigned char *) (raster + row * width);\n            bytes_per_pixel = 4;\n        }\n\n        if( row + rowsperstrip > height )\n            rows_to_write = height - row;\n        else\n            rows_to_write = rowsperstrip;\n\n        if( TIFFWriteEncodedStrip( out, row / rowsperstrip, raster_strip,\n                             bytes_per_pixel * rows_to_write * width ) == -1 )\n        {\n            _TIFFfree( raster );\n            return 0;\n        }\n    }\n\n    _TIFFfree( raster );\n\n    return 1;\n}",
          "fn_code_pos": [
            [
              377,
              0
            ],
            [
              478,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cvt_whole_image",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ntiffcvt(TIFF* in, TIFF* out)\n{\n\tuint32 width, height;\t\t/* image width & height */\n\tuint16 shortv;\n\tfloat floatv;\n\tchar *stringv;\n\tuint32 longv;\n        uint16 v[1];\n\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &height);\n\n\tCopyField(TIFFTAG_SUBFILETYPE, longv);\n\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, height);\n\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\n\tCopyField(TIFFTAG_FILLORDER, shortv);\n\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\n        if( no_alpha )\n            TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3);\n        else\n            TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 4);\n\n        if( !no_alpha )\n        {\n            v[0] = EXTRASAMPLE_ASSOCALPHA;\n            TIFFSetField(out, TIFFTAG_EXTRASAMPLES, 1, v);\n        }\n\n\tCopyField(TIFFTAG_XRESOLUTION, floatv);\n\tCopyField(TIFFTAG_YRESOLUTION, floatv);\n\tCopyField(TIFFTAG_RESOLUTIONUNIT, shortv);\n\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(out, TIFFTAG_SOFTWARE, TIFFGetVersion());\n\tCopyField(TIFFTAG_DOCUMENTNAME, stringv);\n\n        if( process_by_block && TIFFIsTiled( in ) )\n            return( cvt_by_tile( in, out ) );\n        else if( process_by_block )\n            return( cvt_by_strip( in, out ) );\n        else\n            return( cvt_whole_image( in, out ) );\n}",
          "fn_code_pos": [
            [
              481,
              0
            ],
            [
              528,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiffcvt",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(int code)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(code);\n}",
          "fn_code_pos": [
            [
              546,
              0
            ],
            [
              557,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {
              "code": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "tiffcvt(TIFF* in, TIFF* out)",
          "fn_dec_pos": [
            [
              57,
              11
            ],
            [
              57,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiffcvt",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "usage(int code)",
          "fn_dec_pos": [
            [
              58,
              12
            ],
            [
              58,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {
              "code": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"tiffiop.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/raw2tiff.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tuint32\twidth = 0, length = 0, linebytes, bufsize;\n\tuint32\tnbands = 1;\t\t    /* number of bands in input image*/\n\t_TIFF_off_t hdr_size = 0;\t    /* size of the header to skip */\n\tTIFFDataType dtype = TIFF_BYTE;\n\tint16\tdepth = 1;\t\t    /* bytes per pixel in input image */\n\tint\tswab = 0;\t\t    /* byte swapping flag */\n\tInterleavingType interleaving = 0;  /* interleaving type flag */\n\tuint32  rowsperstrip = (uint32) -1;\n\tuint16\tphotometric = PHOTOMETRIC_MINISBLACK;\n\tuint16\tconfig = PLANARCONFIG_CONTIG;\n\tuint16\tfillorder = FILLORDER_LSB2MSB;\n\tint\tfd;\n\tchar\t*outfilename = NULL;\n\tTIFF\t*out;\n\n\tuint32 row, col, band;\n\tint\tc;\n\tunsigned char *buf = NULL, *buf1 = NULL;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"c:r:H:w:l:b:d:LMp:si:o:h\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'c':\t\t/* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* rows/strip */\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'H':\t\t/* size of input image file header */\n\t\t\thdr_size = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'w':\t\t/* input image width */\n\t\t\twidth = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\t\t/* input image length */\n\t\t\tlength = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'b':\t\t/* number of bands in input image */\n\t\t\tnbands = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'd':\t\t/* type of samples in input image */\n\t\t\tif (strncmp(optarg, \"byte\", 4) == 0)\n\t\t\t\tdtype = TIFF_BYTE;\n\t\t\telse if (strncmp(optarg, \"short\", 5) == 0)\n\t\t\t\tdtype = TIFF_SHORT;\n\t\t\telse if  (strncmp(optarg, \"long\", 4) == 0)\n\t\t\t\tdtype = TIFF_LONG;\n\t\t\telse if  (strncmp(optarg, \"sbyte\", 5) == 0)\n\t\t\t\tdtype = TIFF_SBYTE;\n\t\t\telse if  (strncmp(optarg, \"sshort\", 6) == 0)\n\t\t\t\tdtype = TIFF_SSHORT;\n\t\t\telse if  (strncmp(optarg, \"slong\", 5) == 0)\n\t\t\t\tdtype = TIFF_SLONG;\n\t\t\telse if  (strncmp(optarg, \"float\", 5) == 0)\n\t\t\t\tdtype = TIFF_FLOAT;\n\t\t\telse if  (strncmp(optarg, \"double\", 6) == 0)\n\t\t\t\tdtype = TIFF_DOUBLE;\n\t\t\telse\n\t\t\t\tdtype = TIFF_BYTE;\n\t\t\tdepth = TIFFDataWidth(dtype);\n\t\t\tbreak;\n\t\tcase 'L':\t\t/* input has lsb-to-msb fillorder */\n\t\t\tfillorder = FILLORDER_LSB2MSB;\n\t\t\tbreak;\n\t\tcase 'M':\t\t/* input has msb-to-lsb fillorder */\n\t\t\tfillorder = FILLORDER_MSB2LSB;\n\t\t\tbreak;\n\t\tcase 'p':\t\t/* photometric interpretation */\n\t\t\tif (strncmp(optarg, \"miniswhite\", 10) == 0)\n\t\t\t\tphotometric = PHOTOMETRIC_MINISWHITE;\n\t\t\telse if (strncmp(optarg, \"minisblack\", 10) == 0)\n\t\t\t\tphotometric = PHOTOMETRIC_MINISBLACK;\n\t\t\telse if (strncmp(optarg, \"rgb\", 3) == 0)\n\t\t\t\tphotometric = PHOTOMETRIC_RGB;\n\t\t\telse if (strncmp(optarg, \"cmyk\", 4) == 0)\n\t\t\t\tphotometric = PHOTOMETRIC_SEPARATED;\n\t\t\telse if (strncmp(optarg, \"ycbcr\", 5) == 0)\n\t\t\t\tphotometric = PHOTOMETRIC_YCBCR;\n\t\t\telse if (strncmp(optarg, \"cielab\", 6) == 0)\n\t\t\t\tphotometric = PHOTOMETRIC_CIELAB;\n\t\t\telse if (strncmp(optarg, \"icclab\", 6) == 0)\n\t\t\t\tphotometric = PHOTOMETRIC_ICCLAB;\n\t\t\telse if (strncmp(optarg, \"itulab\", 6) == 0)\n\t\t\t\tphotometric = PHOTOMETRIC_ITULAB;\n\t\t\telse\n\t\t\t\tphotometric = PHOTOMETRIC_MINISBLACK;\n\t\t\tbreak;\n\t\tcase 's':\t\t/* do we need to swap bytes? */\n\t\t\tswab = 1;\n\t\t\tbreak;\n\t\tcase 'i':\t\t/* type of interleaving */\n\t\t\tif (strncmp(optarg, \"pixel\", 4) == 0)\n\t\t\t\tinterleaving = PIXEL;\n\t\t\telse if  (strncmp(optarg, \"band\", 6) == 0)\n\t\t\t\tinterleaving = BAND;\n\t\t\telse\n\t\t\t\tinterleaving = 0;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\toutfilename = optarg;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage();\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n        }\n\n        if (argc - optind < 2)\n\t\tusage();\n\n        fd = open(argv[optind], O_RDONLY|O_BINARY, 0);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"%s: %s: Cannot open input file.\\n\",\n\t\t\targv[0], argv[optind]);\n\t\treturn (-1);\n\t}\n\n\tif (guessSize(fd, dtype, hdr_size, nbands, swab, &width, &length) < 0)\n\t\treturn 1;\n\n\tif (outfilename == NULL)\n\t\toutfilename = argv[optind+1];\n\tout = TIFFOpen(outfilename, \"w\");\n\tif (out == NULL) {\n\t\tfprintf(stderr, \"%s: %s: Cannot open file for output.\\n\",\n\t\t\targv[0], outfilename);\n\t\treturn (-1);\n\t}\n\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, length);\n\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, nbands);\n\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, depth * 8);\n\tTIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\n\tswitch (dtype) {\n\tcase TIFF_BYTE:\n\tcase TIFF_SHORT:\n\tcase TIFF_LONG:\n\t\tTIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n\t\tbreak;\n\tcase TIFF_SBYTE:\n\tcase TIFF_SSHORT:\n\tcase TIFF_SLONG:\n\t\tTIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\n\t\tbreak;\n\tcase TIFF_FLOAT:\n\tcase TIFF_DOUBLE:\n\t\tTIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n\t\tbreak;\n\tdefault:\n\t\tTIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_VOID);\n\t\tbreak;\n\t}\n\tif (compression == (uint16) -1)\n\t\tcompression = COMPRESSION_PACKBITS;\n\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\tswitch (compression) {\n\tcase COMPRESSION_JPEG:\n\t\tif (photometric == PHOTOMETRIC_RGB\n\t\t    && jpegcolormode == JPEGCOLORMODE_RGB)\n\t\t\tphotometric = PHOTOMETRIC_YCBCR;\n\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\tbreak;\n\tcase COMPRESSION_LZW:\n\tcase COMPRESSION_DEFLATE:\n\t\tif (predictor != 0)\n\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\tbreak;\n\t}\n\tswitch(interleaving) {\n\tcase BAND:\t\t\t\t/* band interleaved data */\n\t\tlinebytes = width * depth;\n\t\tbuf = (unsigned char *)_TIFFmalloc(linebytes);\n\t\tbreak;\n\tcase PIXEL:\t\t\t\t/* pixel interleaved data */\n\tdefault:\n\t\tlinebytes = width * nbands * depth;\n\t\tbreak;\n\t}\n\tbufsize = width * nbands * depth;\n\tbuf1 = (unsigned char *)_TIFFmalloc(bufsize);\n\n\trowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n\tif (rowsperstrip > length) {\n\t\trowsperstrip = length;\n\t}\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip );\n\n\t_TIFF_lseek_f(fd, hdr_size, SEEK_SET);\t\t/* Skip the file header */\n\tfor (row = 0; row < length; row++) {\n\t\tswitch(interleaving) {\n\t\tcase BAND:\t\t\t/* band interleaved data */\n\t\t\tfor (band = 0; band < nbands; band++) {\n\t\t\t\tif (_TIFF_lseek_f(fd,\n                                          hdr_size + (length*band+row)*linebytes,\n                                          SEEK_SET) == (_TIFF_off_t)-1) {\n                                        fprintf(stderr,\n                                                \"%s: %s: scanline %lu: seek error.\\n\",\n                                                argv[0], argv[optind],\n                                                (unsigned long) row);\n                                        break;\n                                }\n\t\t\t\tif (read(fd, buf, linebytes) < 0) {\n\t\t\t\t\tfprintf(stderr,\n                                                \"%s: %s: scanline %lu: Read error.\\n\",\n                                                argv[0], argv[optind],\n                                                (unsigned long) row);\n                                        break;\n\t\t\t\t}\n\t\t\t\tif (swab)\t/* Swap bytes if needed */\n\t\t\t\t\tswapBytesInScanline(buf, width, dtype);\n\t\t\t\tfor (col = 0; col < width; col++)\n\t\t\t\t\tmemcpy(buf1 + (col*nbands+band)*depth,\n\t\t\t\t\t       buf + col * depth, depth);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PIXEL:\t\t\t/* pixel interleaved data */\n\t\tdefault:\n\t\t\tif (read(fd, buf1, bufsize) < 0) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"%s: %s: scanline %lu: Read error.\\n\",\n\t\t\t\t\targv[0], argv[optind],\n\t\t\t\t\t(unsigned long) row);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (swab)\t\t/* Swap bytes if needed */\n\t\t\t\tswapBytesInScanline(buf1, width, dtype);\n\t\t\tbreak;\n\t\t}\n\t\t\t\t\n\t\tif (TIFFWriteScanline(out, buf1, row, 0) < 0) {\n\t\t\tfprintf(stderr,\t\"%s: %s: scanline %lu: Write error.\\n\",\n\t\t\t\targv[0], outfilename, (unsigned long) row);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (buf)\n\t\t_TIFFfree(buf);\n\tif (buf1)\n\t\t_TIFFfree(buf1);\n\tTIFFClose(out);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              339,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nswapBytesInScanline(void *buf, uint32 width, TIFFDataType dtype)\n{\n\tswitch (dtype) {\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\tTIFFSwabArrayOfShort((uint16*)buf,\n                                             (unsigned long)width);\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\t\tTIFFSwabArrayOfLong((uint32*)buf,\n                                            (unsigned long)width);\n\t\t\tbreak;\n\t\t/* case TIFF_FLOAT: */\t/* FIXME */\n\t\tcase TIFF_DOUBLE:\n\t\t\tTIFFSwabArrayOfDouble((double*)buf,\n                                              (unsigned long)width);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n}",
          "fn_code_pos": [
            [
              341,
              0
            ],
            [
              363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "swapBytesInScanline",
            "parameters": {
              "buf": "void",
              "width": "uint32",
              "dtype": "TIFFDataType"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nguessSize(int fd, TIFFDataType dtype, _TIFF_off_t hdr_size, uint32 nbands,\n\t  int swab, uint32 *width, uint32 *length)\n{\n\tconst float longt = 40.0;    /* maximum possible height/width ratio */\n\tchar\t    *buf1, *buf2;\n\t_TIFF_stat_s filestat;\n\tuint32\t    w, h, scanlinesize, imagesize;\n\tuint32\t    depth = TIFFDataWidth(dtype);\n\tfloat\t    cor_coef = 0, tmp;\n\n\tif (_TIFF_fstat_f(fd, &filestat) == -1) {\n                fprintf(stderr, \"Failed to obtain file size.\\n\");\n\t\treturn -1;\n        }\n\n\tif (filestat.st_size < hdr_size) {\n\t\tfprintf(stderr, \"Too large header size specified.\\n\");\n\t\treturn -1;\n\t}\n\n\timagesize = (filestat.st_size - hdr_size) / nbands / depth;\n\n\tif (*width != 0 && *length == 0) {\n\t\tfprintf(stderr,\t\"Image height is not specified.\\n\");\n\n\t\t*length = imagesize / *width;\n\t\t\n\t\tfprintf(stderr, \"Height is guessed as %lu.\\n\",\n\t\t\t(unsigned long)*length);\n\n\t\treturn 1;\n\t} else if (*width == 0 && *length != 0) {\n\t\tfprintf(stderr, \"Image width is not specified.\\n\");\n\n\t\t*width = imagesize / *length;\n\t\t\n\t\tfprintf(stderr,\t\"Width is guessed as %lu.\\n\",\n\t\t\t(unsigned long)*width);\n\n\t\treturn 1;\n\t} else if (*width == 0 && *length == 0) {\n                unsigned int fail = 0;\n\t\tfprintf(stderr,\t\"Image width and height are not specified.\\n\");\n                w = (uint32) sqrt(imagesize / longt);\n                if( w == 0 )\n                {\n                    fprintf(stderr, \"Too small image size.\\n\");\n                    return -1;\n                }\n\n\t\tfor (;\n\t\t     w < sqrt(imagesize * longt);\n\t\t     w++) {\n\t\t\tif (imagesize % w == 0) {\n\t\t\t\tscanlinesize = w * depth;\n\t\t\t\tbuf1 = _TIFFmalloc(scanlinesize);\n\t\t\t\tbuf2 = _TIFFmalloc(scanlinesize);\n\t\t\t\th = imagesize / w;\n                                do {\n                                        if (_TIFF_lseek_f(fd, hdr_size + (int)(h/2)*scanlinesize,\n                                                  SEEK_SET) == (_TIFF_off_t)-1) {\n                                                fprintf(stderr, \"seek error.\\n\");\n                                                fail=1;\n                                                break;\n                                        }\n                                        if (read(fd, buf1, scanlinesize) !=\n                                            (long) scanlinesize) {\n                                                fprintf(stderr, \"read error.\\n\");\n                                                fail=1;\n                                                break;\n                                        }\n                                        if (read(fd, buf2, scanlinesize) !=\n                                            (long) scanlinesize) {\n                                                fprintf(stderr, \"read error.\\n\");\n                                                fail=1;\n                                                break;\n                                        }\n                                        if (swab) {\n                                                swapBytesInScanline(buf1, w, dtype);\n                                                swapBytesInScanline(buf2, w, dtype);\n                                        }\n                                        tmp = (float) fabs(correlation(buf1, buf2,\n                                                                       w, dtype));\n                                        if (tmp > cor_coef) {\n                                                cor_coef = tmp;\n                                                *width = w, *length = h;\n                                        }\n                                } while (0);\n\n                                _TIFFfree(buf1);\n\t\t\t\t_TIFFfree(buf2);\n\t\t\t}\n\t\t}\n\n                if (fail) {\n                        return -1;\n                }\n\n\t\tfprintf(stderr,\n\t\t\t\"Width is guessed as %lu, height is guessed as %lu.\\n\",\n\t\t\t(unsigned long)*width, (unsigned long)*length);\n\n\t\treturn 1;\n\t} else {\n\t\tif (filestat.st_size<(_TIFF_off_t)(hdr_size+(*width)*(*length)*nbands*depth)) {\n\t\t\tfprintf(stderr, \"Input file too small.\\n\");\n\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              365,
              0
            ],
            [
              477,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "guessSize",
            "parameters": {
              "fd": "int",
              "dtype": "TIFFDataType",
              "hdr_size": "_TIFF_off_t",
              "nbands": "uint32",
              "swab": "int",
              "width": "uint32",
              "length": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static double\ncorrelation(void *buf1, void *buf2, uint32 n_elem, TIFFDataType dtype)\n{\n\tdouble\tX, Y, M1 = 0.0, M2 = 0.0, D1 = 0.0, D2 = 0.0, K = 0.0;\n\tuint32\ti;\n\n\tswitch (dtype) {\n\t\tcase TIFF_BYTE:\n\t\tdefault:\n                        for (i = 0; i < n_elem; i++) {\n\t\t\t\tX = ((unsigned char *)buf1)[i];\n\t\t\t\tY = ((unsigned char *)buf2)[i];\n\t\t\t\tM1 += X, M2 += Y;\n\t\t\t\tD1 += X * X, D2 += Y * Y;\n\t\t\t\tK += X * Y;\n                        }\n\t\t\tbreak;\n\t\tcase TIFF_SBYTE:\n                        for (i = 0; i < n_elem; i++) {\n\t\t\t\tX = ((signed char *)buf1)[i];\n\t\t\t\tY = ((signed char *)buf2)[i];\n\t\t\t\tM1 += X, M2 += Y;\n\t\t\t\tD1 += X * X, D2 += Y * Y;\n\t\t\t\tK += X * Y;\n                        }\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n                        for (i = 0; i < n_elem; i++) {\n\t\t\t\tX = ((uint16 *)buf1)[i];\n\t\t\t\tY = ((uint16 *)buf2)[i];\n\t\t\t\tM1 += X, M2 += Y;\n\t\t\t\tD1 += X * X, D2 += Y * Y;\n\t\t\t\tK += X * Y;\n                        }\n\t\t\tbreak;\n\t\tcase TIFF_SSHORT:\n                        for (i = 0; i < n_elem; i++) {\n\t\t\t\tX = ((int16 *)buf1)[i];\n\t\t\t\tY = ((int16 *)buf2)[i];\n\t\t\t\tM1 += X, M2 += Y;\n\t\t\t\tD1 += X * X, D2 += Y * Y;\n\t\t\t\tK += X * Y;\n                        }\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n                        for (i = 0; i < n_elem; i++) {\n\t\t\t\tX = ((uint32 *)buf1)[i];\n\t\t\t\tY = ((uint32 *)buf2)[i];\n\t\t\t\tM1 += X, M2 += Y;\n\t\t\t\tD1 += X * X, D2 += Y * Y;\n\t\t\t\tK += X * Y;\n                        }\n\t\t\tbreak;\n\t\tcase TIFF_SLONG:\n                        for (i = 0; i < n_elem; i++) {\n\t\t\t\tX = ((int32 *)buf1)[i];\n\t\t\t\tY = ((int32 *)buf2)[i];\n\t\t\t\tM1 += X, M2 += Y;\n\t\t\t\tD1 += X * X, D2 += Y * Y;\n\t\t\t\tK += X * Y;\n                        }\n\t\t\tbreak;\n\t\tcase TIFF_FLOAT:\n                        for (i = 0; i < n_elem; i++) {\n\t\t\t\tX = ((float *)buf1)[i];\n\t\t\t\tY = ((float *)buf2)[i];\n\t\t\t\tM1 += X, M2 += Y;\n\t\t\t\tD1 += X * X, D2 += Y * Y;\n\t\t\t\tK += X * Y;\n                        }\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n                        for (i = 0; i < n_elem; i++) {\n\t\t\t\tX = ((double *)buf1)[i];\n\t\t\t\tY = ((double *)buf2)[i];\n\t\t\t\tM1 += X, M2 += Y;\n\t\t\t\tD1 += X * X, D2 += Y * Y;\n\t\t\t\tK += X * Y;\n                        }\n\t\t\tbreak;\n\t}\n\n\tM1 /= n_elem;\n\tM2 /= n_elem;\n\tD1 -= M1 * M1 * n_elem;\n\tD2 -= M2 * M2 * n_elem;\n\tK = (K - M1 * M2 * n_elem) / sqrt(D1 * D2);\n\n\treturn K;\n}",
          "fn_code_pos": [
            [
              480,
              0
            ],
            [
              569,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "correlation",
            "parameters": {
              "buf1": "void",
              "buf2": "void",
              "n_elem": "uint32",
              "dtype": "TIFFDataType"
            },
            "return_type": "double"
          }
        },
        {
          "fn_code": "static int\nprocessCompressOptions(char* opt)\n{\n\tif (strcmp(opt, \"none\") == 0)\n\t\tcompression = COMPRESSION_NONE;\n\telse if (strcmp(opt, \"packbits\") == 0)\n\t\tcompression = COMPRESSION_PACKBITS;\n\telse if (strncmp(opt, \"jpeg\", 4) == 0) {\n\t\tchar* cp = strchr(opt, ':');\n\n                compression = COMPRESSION_JPEG;\n                while( cp )\n                {\n                    if (isdigit((int)cp[1]))\n\t\t\tquality = atoi(cp+1);\n                    else if (cp[1] == 'r' )\n\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;\n                    else\n                        usage();\n\n                    cp = strchr(cp+1,':');\n                }\n\t} else if (strncmp(opt, \"lzw\", 3) == 0) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_LZW;\n\t} else if (strncmp(opt, \"zip\", 3) == 0) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_DEFLATE;\n\t} else\n\t\treturn (0);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              571,
              0
            ],
            [
              606,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {
              "opt": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              668,
              0
            ],
            [
              679,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "getopt(int, char**, char*)",
          "fn_dec_pos": [
            [
              62,
              11
            ],
            [
              62,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "swapBytesInScanline(void *, uint32, TIFFDataType)",
          "fn_dec_pos": [
            [
              79,
              12
            ],
            [
              79,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "swapBytesInScanline",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "guessSize(int, TIFFDataType, _TIFF_off_t, uint32, int,\n\t\t     uint32 *, uint32 *)",
          "fn_dec_pos": [
            [
              80,
              11
            ],
            [
              81,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "guessSize",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "correlation(void *, void *, uint32, TIFFDataType)",
          "fn_dec_pos": [
            [
              82,
              14
            ],
            [
              82,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "correlation",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              83,
              12
            ],
            [
              83,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "processCompressOptions(char*)",
          "fn_dec_pos": [
            [
              84,
              11
            ],
            [
              84,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <sys/stat.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <sys/types.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "# include <fcntl.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "# include <sys/types.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "# include <io.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            55,
            0
          ],
          [
            56,
            0
          ]
        ],
        [
          "#include \"tiffiop.h\"\n",
          [
            58,
            0
          ],
          [
            59,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            59,
            0
          ],
          [
            60,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n\tPIXEL,\n\tBAND\n} InterleavingType;",
          {
            "PIXEL": "",
            "BAND": ""
          },
          "InterleavingType",
          [
            69,
            0
          ],
          [
            72,
            19
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/tiffdither.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\nfsdither(TIFF* in, TIFF* out)\n{\n\tunsigned char *outline, *inputline, *inptr;\n\tshort *thisline, *nextline, *tmpptr;\n\tregister unsigned char\t*outptr;\n\tregister short *thisptr, *nextptr;\n\tregister uint32 i, j;\n\tuint32 imax, jmax;\n\tint lastline, lastpixel;\n\tint bit;\n\ttsize_t outlinesize;\n\tint errcode = 0;\n\n\timax = imagelength - 1;\n\tjmax = imagewidth - 1;\n\tinputline = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n\tthisline = (short *)_TIFFmalloc(TIFFSafeMultiply(tmsize_t, imagewidth, sizeof (short)));\n\tnextline = (short *)_TIFFmalloc(TIFFSafeMultiply(tmsize_t, imagewidth, sizeof (short)));\n\toutlinesize = TIFFScanlineSize(out);\n\toutline = (unsigned char *) _TIFFmalloc(outlinesize);\n\tif (! (inputline && thisline && nextline && outline)) {\n\t    fprintf(stderr, \"Out of memory.\\n\");\n\t    goto skip_on_error;\n\t}\n\n\t/*\n\t * Get first line\n\t */\n\tif (TIFFReadScanline(in, inputline, 0, 0) <= 0)\n            goto skip_on_error;\n\n\tinptr = inputline;\n\tnextptr = nextline;\n\tfor (j = 0; j < imagewidth; ++j)\n\t\t*nextptr++ = *inptr++;\n\tfor (i = 1; i < imagelength; ++i) {\n\t\ttmpptr = thisline;\n\t\tthisline = nextline;\n\t\tnextline = tmpptr;\n\t\tlastline = (i == imax);\n\t\tif (TIFFReadScanline(in, inputline, i, 0) <= 0)\n\t\t\tgoto skip_on_error;\n\t\tinptr = inputline;\n\t\tnextptr = nextline;\n\t\tfor (j = 0; j < imagewidth; ++j)\n\t\t\t*nextptr++ = *inptr++;\n\t\tthisptr = thisline;\n\t\tnextptr = nextline;\n\t\t_TIFFmemset(outptr = outline, 0, outlinesize);\n\t\tbit = 0x80;\n\t\tfor (j = 0; j < imagewidth; ++j) {\n\t\t\tregister int v;\n\n\t\t\tlastpixel = (j == jmax);\n\t\t\tv = *thisptr++;\n\t\t\tif (v < 0)\n\t\t\t\tv = 0;\n\t\t\telse if (v > 255)\n\t\t\t\tv = 255;\n\t\t\tif (v > threshold) {\n\t\t\t\t*outptr |= bit;\n\t\t\t\tv -= 255;\n\t\t\t}\n\t\t\tbit >>= 1;\n\t\t\tif (bit == 0) {\n\t\t\t\toutptr++;\n\t\t\t\tbit = 0x80;\n\t\t\t}\n\t\t\tif (!lastpixel)\n\t\t\t\tthisptr[0] += v * 7 / 16;\n\t\t\tif (!lastline) {\n\t\t\t\tif (j != 0)\n\t\t\t\t\tnextptr[-1] += v * 3 / 16;\n\t\t\t\t*nextptr++ += v * 5 / 16;\n\t\t\t\tif (!lastpixel)\n\t\t\t\t\tnextptr[0] += v / 16;\n\t\t\t}\n\t\t}\n\t\tif (TIFFWriteScanline(out, outline, i-1, 0) < 0)\n\t\t\tgoto skip_on_error;\n\t}\n\tgoto exit_label;\n\n  skip_on_error:\n\terrcode = 1;\n  exit_label:\n\t_TIFFfree(inputline);\n\t_TIFFfree(thisline);\n\t_TIFFfree(nextline);\n\t_TIFFfree(outline);\n\treturn errcode;\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              149,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "fsdither",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nprocessG3Options(char* cp)\n{\n\tif ((cp = strchr(cp, ':'))) {\n\t\tdo {\n\t\t\tcp++;\n\t\t\tif (strneq(cp, \"1d\", 2))\n\t\t\t\tgroup3options &= ~GROUP3OPT_2DENCODING;\n\t\t\telse if (strneq(cp, \"2d\", 2))\n\t\t\t\tgroup3options |= GROUP3OPT_2DENCODING;\n\t\t\telse if (strneq(cp, \"fill\", 4))\n\t\t\t\tgroup3options |= GROUP3OPT_FILLBITS;\n\t\t\telse\n\t\t\t\tusage();\n\t\t} while ((cp = strchr(cp, ':')));\n\t}\n}",
          "fn_code_pos": [
            [
              155,
              0
            ],
            [
              171,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processG3Options",
            "parameters": {
              "cp": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nprocessCompressOptions(char* opt)\n{\n\tif (streq(opt, \"none\"))\n\t\tcompression = COMPRESSION_NONE;\n\telse if (streq(opt, \"packbits\"))\n\t\tcompression = COMPRESSION_PACKBITS;\n\telse if (strneq(opt, \"g3\", 2)) {\n\t\tprocessG3Options(opt);\n\t\tcompression = COMPRESSION_CCITTFAX3;\n\t} else if (streq(opt, \"g4\"))\n\t\tcompression = COMPRESSION_CCITTFAX4;\n\telse if (strneq(opt, \"lzw\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_LZW;\n\t} else if (strneq(opt, \"zip\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_DEFLATE;\n\t} else\n\t\treturn (0);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              173,
              0
            ],
            [
              198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {
              "opt": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tTIFF *in, *out;\n\tuint16 samplesperpixel, bitspersample = 1, shortv;\n\tfloat floatv;\n\tchar thing[1024];\n\tuint32 rowsperstrip = (uint32) -1;\n\tuint16 fillorder = 0;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char *optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"c:f:r:t:\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'c':\t\t/* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'f':\t\t/* fill order */\n\t\t\tif (streq(optarg, \"lsb2msb\"))\n\t\t\t\tfillorder = FILLORDER_LSB2MSB;\n\t\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t\t\tfillorder = FILLORDER_MSB2LSB;\n\t\t\telse\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* rows/strip */\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tthreshold = atoi(optarg);\n\t\t\tif (threshold < 0)\n\t\t\t\tthreshold = 0;\n\t\t\telse if (threshold > 255)\n\t\t\t\tthreshold = 255;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind < 2)\n\t\tusage();\n\tin = TIFFOpen(argv[optind], \"r\");\n\tif (in == NULL)\n\t\treturn (-1);\n\tTIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\tif (samplesperpixel != 1) {\n\t\tfprintf(stderr, \"%s: Not a b&w image.\\n\", argv[0]);\n\t\treturn (-1);\n\t}\n\tTIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\tif (bitspersample != 8) {\n\t\tfprintf(stderr,\n\t\t    \" %s: Sorry, only handle 8-bit samples.\\n\", argv[0]);\n\t\treturn (-1);\n\t}\n\tout = TIFFOpen(argv[optind+1], \"w\");\n\tif (out == NULL)\n\t\treturn (-1);\n\tCopyField(TIFFTAG_IMAGEWIDTH, imagewidth);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &imagelength);\n\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, imagelength-1);\n\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 1);\n\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 1);\n\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\tif (fillorder)\n\t\tTIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n\telse\n\t\tCopyField(TIFFTAG_FILLORDER, shortv);\n\tsnprintf(thing, sizeof(thing), \"Dithered B&W version of %s\", argv[optind]);\n\tTIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, thing);\n\tCopyField(TIFFTAG_PHOTOMETRIC, shortv);\n\tCopyField(TIFFTAG_ORIENTATION, shortv);\n\tCopyField(TIFFTAG_XRESOLUTION, floatv);\n\tCopyField(TIFFTAG_YRESOLUTION, floatv);\n\tCopyField(TIFFTAG_RESOLUTIONUNIT, shortv);\n        rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\tswitch (compression) {\n\tcase COMPRESSION_CCITTFAX3:\n\t\tTIFFSetField(out, TIFFTAG_GROUP3OPTIONS, group3options);\n\t\tbreak;\n\tcase COMPRESSION_LZW:\n\tcase COMPRESSION_DEFLATE:\n\t\tif (predictor)\n\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\tbreak;\n\t}\n\tfsdither(in, out);\n\tTIFFClose(in);\n\tTIFFClose(out);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              200,
              0
            ],
            [
              296,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              324,
              0
            ],
            [
              335,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              51,
              12
            ],
            [
              51,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include \"tiffiop.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/tiffgt.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n        int c;\n        int dirnum = -1;\n        uint32 diroff = 0;\n\n        oerror = TIFFSetErrorHandler(NULL);\n        owarning = TIFFSetWarningHandler(NULL);\n        while ((c = getopt(argc, argv, \"d:o:p:eflmsvw?\")) != -1)\n            switch (c) {\n            case 'd':\n                dirnum = atoi(optarg);\n                break;\n            case 'e':\n                oerror = TIFFSetErrorHandler(oerror);\n                break;\n            case 'l':\n                order0 = FILLORDER_LSB2MSB;\n                break;\n            case 'm':\n                order0 = FILLORDER_MSB2LSB;\n                break;\n            case 'o':\n                diroff = strtoul(optarg, NULL, 0);\n                break;\n            case 'p':\n                photo0 = photoArg(optarg);\n                break;\n            case 's':\n                stoponerr = 1;\n                break;\n            case 'w':\n                owarning = TIFFSetWarningHandler(owarning);\n                break;\n            case 'v':\n                verbose = 1;\n                break;\n            case '?':\n                usage();\n                /*NOTREACHED*/\n            }\n        filenum = argc - optind;\n        if ( filenum < 1)\n                usage();\n\n        glutInit(&argc, argv);\n        glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n\n        /*\n         * Get the screen size\n         */\n        xmax = glutGet(GLUT_SCREEN_WIDTH);\n        ymax = glutGet(GLUT_SCREEN_HEIGHT);\n\n        /*\n         * Use 90% of the screen size\n         */\n        xmax = xmax - xmax / 10.0;\n        ymax = ymax - ymax / 10.0;\n\n        filelist = (char **) _TIFFmalloc(filenum * sizeof(char*));\n        if (!filelist) {\n                TIFFError(argv[0], \"Can not allocate space for the file list.\");\n                return 1;\n        }\n        _TIFFmemcpy(filelist, argv + optind, filenum * sizeof(char*));\n        fileindex = -1;\n        if (nextImage() < 0) {\n                _TIFFfree(filelist);\n                return 2;\n        }\n        /*\n         * Set initial directory if user-specified\n         * file was opened successfully.\n         */\n        if (dirnum != -1 && !TIFFSetDirectory(tif, dirnum))\n            TIFFError(argv[0], \"Error, seeking to directory %d\", dirnum);\n        if (diroff != 0 && !TIFFSetSubDirectory(tif, diroff))\n            TIFFError(argv[0], \"Error, setting subdirectory at %#x\", diroff);\n        order = order0;\n        photo = photo0;\n\tif (initImage() < 0){\n                _TIFFfree(filelist);\n                return 3;\n        }\n        /*\n         * Create a new window or reconfigure an existing\n         * one to suit the image to be displayed.\n         */\n        glutInitWindowSize(width, height);\n        snprintf(title, TITLE_LENGTH - 1, \"%s [%u]\", filelist[fileindex],\n                (unsigned int) TIFFCurrentDirectory(tif));\n        glutCreateWindow(title);\n        glutDisplayFunc(raster_draw);\n        glutReshapeFunc(raster_reshape);\n        glutKeyboardFunc(raster_keys);\n        glutSpecialFunc(raster_special);\n        glutMainLoop();\n\n        cleanup_and_exit();\n        return 0;\n}",
          "fn_code_pos": [
            [
              95,
              0
            ],
            [
              197,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void \ncleanup_and_exit(void)\n{\n        TIFFRGBAImageEnd(&img);\n        if (filelist != NULL)\n                _TIFFfree(filelist);\n        if (raster != NULL)\n                _TIFFfree(raster);\n        if (tif != NULL)\n                TIFFClose(tif);\n        exit(0);\n}",
          "fn_code_pos": [
            [
              199,
              0
            ],
            [
              210,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cleanup_and_exit",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ninitImage(void)\n{\n        uint32 w, h;\n\n        if (order)\n                TIFFSetField(tif, TIFFTAG_FILLORDER, order);\n        if (photo != (uint16) -1)\n                TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photo);\n        if (!TIFFRGBAImageBegin(&img, tif, stoponerr, title)) {\n                TIFFError(filelist[fileindex], \"%s\", title);\n                TIFFClose(tif);\n                tif = NULL;\n                return -1;\n        }\n\n        /*\n         * Setup the image raster as required.\n         */\n        h = img.height;\n        w = img.width;\n        if (h > ymax) {\n                w = (int)(w * ((float)ymax / h));\n                h = ymax;\n        }\n        if (w > xmax) {\n                h = (int)(h * ((float)xmax / w));\n                w = xmax;\n        }\n\n\tif (w != width || h != height) {\n\t\tuint32 rastersize =\n\t\t\t_TIFFMultiply32(tif, img.width, img.height, \"allocating raster buffer\");\n\t\tif (raster != NULL)\n\t\t\t_TIFFfree(raster), raster = NULL;\n\t\traster = (uint32*) _TIFFCheckMalloc(tif, rastersize, sizeof (uint32),\n\t\t\t\t\t\t    \"allocating raster buffer\");\n\t\tif (raster == NULL) {\n\t\t\twidth = height = 0;\n\t\t\tTIFFError(filelist[fileindex], \"No space for raster buffer\");\n\t\t\tcleanup_and_exit();\n\t\t}\n\t\twidth = w;\n\t\theight = h;\n\t}\n\tTIFFRGBAImageGet(&img, raster, img.width, img.height);\n#if HOST_BIGENDIAN\n\tTIFFSwabArrayOfLong(raster,img.width*img.height);\n#endif\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              212,
              0
            ],
            [
              262,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nprevImage(void)\n{\n        if (fileindex > 0)\n                fileindex--;\n        else if (tif)\n                return fileindex;\n        if (tif)\n                TIFFClose(tif);\n        tif = TIFFOpen(filelist[fileindex], \"r\");\n        if (tif == NULL)\n                return -1;\n        return fileindex;\n}",
          "fn_code_pos": [
            [
              264,
              0
            ],
            [
              277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "prevImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nnextImage(void)\n{\n        if (fileindex < filenum - 1)\n                fileindex++;\n        else if (tif)\n                return fileindex;\n        if (tif)\n                TIFFClose(tif);\n        tif = TIFFOpen(filelist[fileindex], \"r\");\n        if (tif == NULL)\n                return -1;\n        return fileindex;\n}",
          "fn_code_pos": [
            [
              279,
              0
            ],
            [
              292,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nextImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nsetWindowSize(void)\n{\n        glutReshapeWindow(width, height);\n}",
          "fn_code_pos": [
            [
              294,
              0
            ],
            [
              298,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setWindowSize",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nraster_draw(void)\n{\n  glDrawPixels(img.width, img.height, GL_RGBA, GL_UNSIGNED_BYTE, (const GLvoid *) raster);\n  glFlush();\n}",
          "fn_code_pos": [
            [
              300,
              0
            ],
            [
              305,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "raster_draw",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nraster_reshape(int win_w, int win_h)\n{\n        GLfloat xratio = (GLfloat)win_w/img.width;\n        GLfloat yratio = (GLfloat)win_h/img.height;\n        int     ratio = (int)(((xratio > yratio)?xratio:yratio) * 100);\n\n        glPixelZoom(xratio, yratio);\n        glViewport(0, 0, win_w, win_h);\n        snprintf(title, 1024, \"%s [%u] %d%%\", filelist[fileindex],\n                (unsigned int) TIFFCurrentDirectory(tif), ratio);\n        glutSetWindowTitle(title);\n}",
          "fn_code_pos": [
            [
              307,
              0
            ],
            [
              319,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "raster_reshape",
            "parameters": {
              "win_w": "int",
              "win_h": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nraster_keys(unsigned char key, int x, int y)\n{\n        (void) x;\n        (void) y;\n        switch (key) {\n                case 'b':                       /* photometric MinIsBlack */\n                    photo = PHOTOMETRIC_MINISBLACK;\n                    initImage();\n                    break;\n                case 'l':                       /* lsb-to-msb FillOrder */\n                    order = FILLORDER_LSB2MSB;\n                    initImage();\n                    break;\n                case 'm':                       /* msb-to-lsb FillOrder */\n                    order = FILLORDER_MSB2LSB;\n                    initImage();\n                    break;\n                case 'w':                       /* photometric MinIsWhite */\n                    photo = PHOTOMETRIC_MINISWHITE;\n                    initImage();\n                    break;\n                case 'W':                       /* toggle warnings */\n                    owarning = TIFFSetWarningHandler(owarning);\n                    initImage();\n                    break;\n                case 'E':                       /* toggle errors */\n                    oerror = TIFFSetErrorHandler(oerror);\n                    initImage();\n                    break;\n                case 'z':                       /* reset to defaults */\n                case 'Z':\n                    order = order0;\n                    photo = photo0;\n                    if (owarning == NULL)\n                        owarning = TIFFSetWarningHandler(NULL);\n                    if (oerror == NULL)\n                        oerror = TIFFSetErrorHandler(NULL);\n                    initImage();\n                    break;\n                case 'q':                       /* exit */\n                case '\\033':\n                    cleanup_and_exit();\n        }\n        glutPostRedisplay();\n}",
          "fn_code_pos": [
            [
              321,
              0
            ],
            [
              366,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "raster_keys",
            "parameters": {
              "key": "unsigned char",
              "x": "int",
              "y": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nraster_special(int key, int x, int y)\n{\n        (void) x;\n        (void) y;\n        switch (key) {\n                case GLUT_KEY_PAGE_UP:          /* previous logical image */\n                    if (TIFFCurrentDirectory(tif) > 0) {\n                            if (TIFFSetDirectory(tif,\n                                                 TIFFCurrentDirectory(tif)-1)) {\n                                    initImage();\n                                    setWindowSize();\n                        }\n                    } else {\n                            TIFFRGBAImageEnd(&img);\n                            prevImage();\n                            initImage();\n                            setWindowSize();\n                    }\n                break;\n                case GLUT_KEY_PAGE_DOWN:        /* next logical image */\n                    if (!TIFFLastDirectory(tif)) {\n                            if (TIFFReadDirectory(tif)) {\n                                    initImage();\n                                    setWindowSize();\n                            }\n                    } else {\n                            TIFFRGBAImageEnd(&img);\n                            nextImage();\n                            initImage();\n                            setWindowSize();\n                    }\n                break;\n                case GLUT_KEY_HOME:             /* 1st image in current file */\n                        if (TIFFSetDirectory(tif, 0)) {\n                                TIFFRGBAImageEnd(&img);\n                                initImage();\n                                setWindowSize();\n                        }\n                break;\n                case GLUT_KEY_END:              /* last image in current file */\n                        TIFFRGBAImageEnd(&img);\n                        while (!TIFFLastDirectory(tif))\n                                TIFFReadDirectory(tif);\n                        initImage();\n                        setWindowSize();\n                break;\n        }\n        glutPostRedisplay();\n}",
          "fn_code_pos": [
            [
              368,
              0
            ],
            [
              417,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "raster_special",
            "parameters": {
              "key": "int",
              "x": "int",
              "y": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n        char buf[BUFSIZ];\n        int i;\n\n        setbuf(stderr, buf);\n                fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n        for (i = 0; stuff[i] != NULL; i++)\n                fprintf(stderr, \"%s\\n\", stuff[i]);\n        exit(-1);\n}",
          "fn_code_pos": [
            [
              441,
              0
            ],
            [
              452,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static uint16\nphotoArg(const char* arg)\n{\n        if (strcmp(arg, \"miniswhite\") == 0)\n            return (PHOTOMETRIC_MINISWHITE);\n        else if (strcmp(arg, \"minisblack\") == 0)\n            return (PHOTOMETRIC_MINISBLACK);\n        else if (strcmp(arg, \"rgb\") == 0)\n            return (PHOTOMETRIC_RGB);\n        else if (strcmp(arg, \"palette\") == 0)\n            return (PHOTOMETRIC_PALETTE);\n        else if (strcmp(arg, \"mask\") == 0)\n            return (PHOTOMETRIC_MASK);\n        else if (strcmp(arg, \"separated\") == 0)\n            return (PHOTOMETRIC_SEPARATED);\n        else if (strcmp(arg, \"ycbcr\") == 0)\n            return (PHOTOMETRIC_YCBCR);\n        else if (strcmp(arg, \"cielab\") == 0)\n            return (PHOTOMETRIC_CIELAB);\n        else if (strcmp(arg, \"logl\") == 0)\n            return (PHOTOMETRIC_LOGL);\n        else if (strcmp(arg, \"logluv\") == 0)\n            return (PHOTOMETRIC_LOGLUV);\n        else\n            return ((uint16) -1);\n}",
          "fn_code_pos": [
            [
              454,
              0
            ],
            [
              479,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "photoArg",
            "parameters": {
              "arg": "char"
            },
            "return_type": "uint16"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "getopt(int, char**, char*)",
          "fn_dec_pos": [
            [
              51,
              11
            ],
            [
              51,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "cleanup_and_exit(void)",
          "fn_dec_pos": [
            [
              70,
              12
            ],
            [
              70,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cleanup_and_exit",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "initImage(void)",
          "fn_dec_pos": [
            [
              71,
              11
            ],
            [
              71,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "prevImage(void)",
          "fn_dec_pos": [
            [
              72,
              11
            ],
            [
              72,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "prevImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "nextImage(void)",
          "fn_dec_pos": [
            [
              73,
              11
            ],
            [
              73,
              26
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nextImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "setWindowSize(void)",
          "fn_dec_pos": [
            [
              74,
              12
            ],
            [
              74,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setWindowSize",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              75,
              12
            ],
            [
              75,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "photoArg(const char*)",
          "fn_dec_pos": [
            [
              76,
              14
            ],
            [
              76,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "photoArg",
            "parameters": {},
            "return_type": "uint16"
          }
        },
        {
          "fn_code": "raster_draw(void)",
          "fn_dec_pos": [
            [
              77,
              12
            ],
            [
              77,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "raster_draw",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "raster_reshape(int, int)",
          "fn_dec_pos": [
            [
              78,
              12
            ],
            [
              78,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "raster_reshape",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "raster_keys(unsigned char, int, int)",
          "fn_dec_pos": [
            [
              79,
              12
            ],
            [
              79,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "raster_keys",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "raster_special(int, int, int)",
          "fn_dec_pos": [
            [
              80,
              12
            ],
            [
              80,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "raster_special",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            25,
            0
          ],
          [
            26,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <unistd.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "# include <OpenGL/gl.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#  include <windows.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "# include <GL/gl.h>\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "# include <GLUT/glut.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "# include <GL/glut.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "#include \"tiffiop.h\"\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/thumbnail.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n    TIFF* in;\n    TIFF* out;\n    int c;\n\n    while ((c = getopt(argc, argv, \"w:h:c:\")) != -1) {\n\tswitch (c) {\n\tcase 'w':\ttnw = strtoul(optarg, NULL, 0); break;\n\tcase 'h':\ttnh = strtoul(optarg, NULL, 0); break;\n\tcase 'c':\tcontrast = streq(optarg, \"exp50\") ? EXP50 :\n\t\t\t\t   streq(optarg, \"exp60\") ? EXP60 :\n\t\t\t\t   streq(optarg, \"exp70\") ? EXP70 :\n\t\t\t\t   streq(optarg, \"exp80\") ? EXP80 :\n\t\t\t\t   streq(optarg, \"exp90\") ? EXP90 :\n\t\t\t\t   streq(optarg, \"exp\")   ? EXP :\n\t\t\t\t   streq(optarg, \"linear\")? LINEAR :\n\t\t\t\t\t\t\t    EXP;\n\t\t\tbreak;\n\tdefault:\tusage();\n\t}\n    }\n    if (argc-optind != 2)\n\tusage();\n\n    out = TIFFOpen(argv[optind+1], \"w\");\n    if (out == NULL)\n\treturn 2;\n    in = TIFFOpen(argv[optind], \"r\");\n    if( in == NULL )\n        return 2;\n\n    thumbnail = (uint8*) _TIFFmalloc(tnw * tnh);\n    if (!thumbnail) {\n\t    TIFFError(TIFFFileName(in),\n\t\t      \"Can't allocate space for thumbnail buffer.\");\n\t    return 1;\n    }\n\n    if (in != NULL) {\n\tinitScale();\n\tdo {\n\t    if (!generateThumbnail(in, out))\n\t\tgoto bad;\n\t    if (!cpIFD(in, out) || !TIFFWriteDirectory(out))\n\t\tgoto bad;\n\t} while (TIFFReadDirectory(in));\n\t(void) TIFFClose(in);\n    }\n    (void) TIFFClose(out);\n    return 0;\nbad:\n    (void) TIFFClose(out);\n    return 1;\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              131,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ncpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type)\n{\n\tswitch (type) {\n\tcase TIFF_SHORT:\n\t\tif (count == 1) {\n\t\t\tuint16 shortv;\n\t\t\tCopyField(tag, shortv);\n\t\t} else if (count == 2) {\n\t\t\tuint16 shortv1, shortv2;\n\t\t\tCopyField2(tag, shortv1, shortv2);\n\t\t} else if (count == 4) {\n\t\t\tuint16 *tr, *tg, *tb, *ta;\n\t\t\tCopyField4(tag, tr, tg, tb, ta);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tuint16 shortv1;\n\t\t\tuint16* shortav;\n\t\t\tCopyField2(tag, shortv1, shortav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_LONG:\n\t\t{ uint32 longv;\n\t\t  CopyField(tag, longv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_LONG8:\n\t\t{ uint64 longv8;\n\t\t  CopyField(tag, longv8);\n\t\t}\n\t\tbreak;\n\tcase TIFF_SLONG8:\n\t\t{ int64 longv8;\n\t\t  CopyField(tag, longv8);\n\t\t}\n\t\tbreak;\n\tcase TIFF_RATIONAL:\n\t\tif (count == 1) {\n\t\t\tfloat floatv;\n\t\t\tCopyField(tag, floatv);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tfloat* floatav;\n\t\t\tCopyField(tag, floatav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_ASCII:\n\t\t{ char* stringv;\n\t\t  CopyField(tag, stringv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_DOUBLE:\n\t\tif (count == 1) {\n\t\t\tdouble doublev;\n\t\t\tCopyField(tag, doublev);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tdouble* doubleav;\n\t\t\tCopyField(tag, doubleav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_IFD8:\n\t\t{ toff_t ifd8;\n\t\t  CopyField(tag, ifd8);\n\t\t}\n\t\tbreak;          default:\n                TIFFError(TIFFFileName(in),\n                          \"Data type %d is not supported, tag %d skipped.\",\n                          tag, type);\n\t}\n}",
          "fn_code_pos": [
            [
              142,
              0
            ],
            [
              209,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpTag",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF",
              "tag": "uint16",
              "count": "uint16",
              "type": "TIFFDataType"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ncpTags(TIFF* in, TIFF* out)\n{\n    struct cpTag *p;\n    for (p = tags; p < &tags[NTAGS]; p++)\n\t{\n\t\t/* Horrible: but TIFFGetField() expects 2 arguments to be passed */\n\t\t/* if we request a tag that is defined in a codec, but that codec */\n\t\t/* isn't used */\n\t\tif( p->tag == TIFFTAG_GROUP3OPTIONS )\n\t\t{\n\t\t\tuint16 compression;\n\t\t\tif( !TIFFGetField(in, TIFFTAG_COMPRESSION, &compression) ||\n\t\t\t\tcompression != COMPRESSION_CCITTFAX3 )\n\t\t\t\tcontinue;\n\t\t}\n\t\tif( p->tag == TIFFTAG_GROUP4OPTIONS )\n\t\t{\n\t\t\tuint16 compression;\n\t\t\tif( !TIFFGetField(in, TIFFTAG_COMPRESSION, &compression) ||\n\t\t\t\tcompression != COMPRESSION_CCITTFAX4 )\n\t\t\t\tcontinue;\n\t\t}\n\t\tcpTag(in, out, p->tag, p->count, p->type);\n\t}\n}",
          "fn_code_pos": [
            [
              271,
              0
            ],
            [
              296,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpTags",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ncpStrips(TIFF* in, TIFF* out)\n{\n    tsize_t bufsize  = TIFFStripSize(in);\n    unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);\n\n    if (buf) {\n\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n\tuint64 *bytecounts;\n\n\tTIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);\n\tfor (s = 0; s < ns; s++) {\n\t  if (bytecounts[s] > (uint64) bufsize) {\n\t\tbuf = (unsigned char *)_TIFFrealloc(buf, (tmsize_t)bytecounts[s]);\n\t\tif (!buf)\n\t\t    goto bad;\n\t\tbufsize = (tmsize_t)bytecounts[s];\n\t    }\n\t    if (TIFFReadRawStrip(in, s, buf, (tmsize_t)bytecounts[s]) < 0 ||\n\t\tTIFFWriteRawStrip(out, s, buf, (tmsize_t)bytecounts[s]) < 0) {\n\t\t_TIFFfree(buf);\n\t\treturn 0;\n\t    }\n\t}\n\t_TIFFfree(buf);\n\treturn 1;\n    }\n\nbad:\n\tTIFFError(TIFFFileName(in),\n\t\t  \"Can't allocate space for strip buffer.\");\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              299,
              0
            ],
            [
              331,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpStrips",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncpTiles(TIFF* in, TIFF* out)\n{\n    tsize_t bufsize = TIFFTileSize(in);\n    unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);\n\n    if (buf) {\n\tttile_t t, nt = TIFFNumberOfTiles(in);\n\tuint64 *bytecounts;\n\n\tTIFFGetField(in, TIFFTAG_TILEBYTECOUNTS, &bytecounts);\n\tfor (t = 0; t < nt; t++) {\n\t    if (bytecounts[t] > (uint64) bufsize) {\n\t\tbuf = (unsigned char *)_TIFFrealloc(buf, (tmsize_t)bytecounts[t]);\n\t\tif (!buf)\n\t\t    goto bad;\n\t\tbufsize = (tmsize_t)bytecounts[t];\n\t    }\n\t    if (TIFFReadRawTile(in, t, buf, (tmsize_t)bytecounts[t]) < 0 ||\n\t\tTIFFWriteRawTile(out, t, buf, (tmsize_t)bytecounts[t]) < 0) {\n\t\t_TIFFfree(buf);\n\t\treturn 0;\n\t    }\n\t}\n\t_TIFFfree(buf);\n\treturn 1;\n    }\n\nbad:\n    TIFFError(TIFFFileName(in),\n\t\t  \"Can't allocate space for tile buffer.\");\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              333,
              0
            ],
            [
              365,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpTiles",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncpIFD(TIFF* in, TIFF* out)\n{\n    cpTags(in, out);\n    if (TIFFIsTiled(in)) {\n\tif (!cpTiles(in, out))\n\t    return (0);\n    } else {\n\tif (!cpStrips(in, out))\n\t    return (0);\n    }\n    return (1);\n}",
          "fn_code_pos": [
            [
              367,
              0
            ],
            [
              379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpIFD",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nsetupBitsTables()\n{\n    int i;\n    for (i = 0; i < 256; i++) {\n\tint n = 0;\n\tif (i&0x01) n++;\n\tif (i&0x02) n++;\n\tif (i&0x04) n++;\n\tif (i&0x08) n++;\n\tif (i&0x10) n++;\n\tif (i&0x20) n++;\n\tif (i&0x40) n++;\n\tif (i&0x80) n++;\n\tbits[i] = n;\n    }\n}",
          "fn_code_pos": [
            [
              392,
              0
            ],
            [
              408,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setupBitsTables",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int clamp(float v, int low, int high)\n    { return (v < low ? low : v > high ? high : (int)v); }",
          "fn_code_pos": [
            [
              410,
              0
            ],
            [
              411,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "clamp",
            "parameters": {
              "v": "float",
              "low": "int",
              "high": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nexpFill(float pct[], uint32 p, uint32 n)\n{\n    uint32 i;\n    uint32 c = (p * n) / 100;\n    for (i = 1; i < c; i++)\n\tpct[i] = (float) (1-exp(i/((double)(n-1)))/ M_E);\n    for (; i < n; i++)\n\tpct[i] = 0.;\n}",
          "fn_code_pos": [
            [
              417,
              0
            ],
            [
              426,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "expFill",
            "parameters": {
              "pct": "float",
              "p": "uint32",
              "n": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nsetupCmap()\n{\n    float pct[256];\t\t\t/* known to be large enough */\n    uint32 i;\n    pct[0] = 1;\t\t\t\t/* force white */\n    switch (contrast) {\n    case EXP50: expFill(pct, 50, 256); break;\n    case EXP60:\texpFill(pct, 60, 256); break;\n    case EXP70:\texpFill(pct, 70, 256); break;\n    case EXP80:\texpFill(pct, 80, 256); break;\n    case EXP90:\texpFill(pct, 90, 256); break;\n    case EXP:\texpFill(pct, 100, 256); break;\n    case LINEAR:\n\tfor (i = 1; i < 256; i++)\n\t    pct[i] = 1-((float)i)/(256-1);\n\tbreak;\n    }\n    switch (photometric) {\n    case PHOTOMETRIC_MINISWHITE:\n\tfor (i = 0; i < 256; i++)\n\t    cmap[i] = clamp(255*pct[(256-1)-i], 0, 255);\n\tbreak;\n    case PHOTOMETRIC_MINISBLACK:\n\tfor (i = 0; i < 256; i++)\n\t    cmap[i] = clamp(255*pct[i], 0, 255);\n\tbreak;\n    }\n}",
          "fn_code_pos": [
            [
              428,
              0
            ],
            [
              456,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setupCmap",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ninitScale()\n{\n    src0 = (uint8*) _TIFFmalloc(sizeof (uint8) * tnw);\n    src1 = (uint8*) _TIFFmalloc(sizeof (uint8) * tnw);\n    src2 = (uint8*) _TIFFmalloc(sizeof (uint8) * tnw);\n    rowoff = (uint32*) _TIFFmalloc(sizeof (uint32) * tnw);\n    filterWidth = 0;\n    stepDstWidth = stepSrcWidth = 0;\n    setupBitsTables();\n}",
          "fn_code_pos": [
            [
              458,
              0
            ],
            [
              468,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initScale",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nsetupStepTables(uint32 sw)\n{\n    if (stepSrcWidth != sw || stepDstWidth != tnw) {\n\tint step = sw;\n\tint limit = tnw;\n\tint err = 0;\n\tuint32 sx = 0;\n\tuint32 x;\n\tint fw;\n\tuint8 b;\n\tfor (x = 0; x < tnw; x++) {\n\t    uint32 sx0 = sx;\n\t    err += step;\n\t    while (err >= limit) {\n\t\terr -= limit;\n\t\tsx++;\n\t    }\n\t    rowoff[x] = sx0 >> 3;\n\t    fw = sx - sx0;\t\t/* width */\n\t    b = (fw < 8) ? 0xff<<(8-fw) : 0xff;\n\t    src0[x] = b >> (sx0&7);\n\t    fw -= 8 - (sx0&7);\n\t    if (fw < 0)\n\t\tfw = 0;\n\t    src1[x] = fw >> 3;\n\t    fw -= (fw>>3)<<3;\n\t    src2[x] = 0xff << (8-fw);\n\t}\n\tstepSrcWidth = sw;\n\tstepDstWidth = tnw;\n    }\n}",
          "fn_code_pos": [
            [
              474,
              0
            ],
            [
              506,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setupStepTables",
            "parameters": {
              "sw": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nsetrow(uint8* row, uint32 nrows, const uint8* rows[])\n{\n    uint32 x;\n    uint32 area = nrows * filterWidth;\n    for (x = 0; x < tnw; x++) {\n\tuint32 mask0 = src0[x];\n\tuint32 fw = src1[x];\n\tuint32 mask1 = src1[x];\n\tuint32 off = rowoff[x];\n\tuint32 acc = 0;\n\tuint32 y, i;\n\tfor (y = 0; y < nrows; y++) {\n\t    const uint8* src = rows[y] + off;\n\t    acc += bits[*src++ & mask0];\n\t    switch (fw) {\n\t    default:\n\t\tfor (i = fw; i > 8; i--)\n\t\t    acc += bits[*src++];\n\t\t/* fall through... */\n\t    case 8: acc += bits[*src++]; /* fall through */\n\t    case 7: acc += bits[*src++]; /* fall through */\n\t    case 6: acc += bits[*src++]; /* fall through */\n\t    case 5: acc += bits[*src++]; /* fall through */\n\t    case 4: acc += bits[*src++]; /* fall through */\n\t    case 3: acc += bits[*src++]; /* fall through */\n\t    case 2: acc += bits[*src++]; /* fall through */\n\t    case 1: acc += bits[*src++]; /* fall through */\n\t    case 0: break;\n\t    }\n\t    acc += bits[*src & mask1];\n\t}\n\t*row++ = cmap[(255*acc)/area];\n    }\n}",
          "fn_code_pos": [
            [
              508,
              0
            ],
            [
              542,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setrow",
            "parameters": {
              "row": "uint8",
              "nrows": "uint32",
              "rows": "uint8"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nsetImage1(const uint8* br, uint32 rw, uint32 rh)\n{\n    int step = rh;\n    int limit = tnh;\n    int err = 0;\n    int bpr = TIFFhowmany8(rw);\n    int sy = 0;\n    uint8* row = thumbnail;\n    uint32 dy;\n    for (dy = 0; dy < tnh; dy++) {\n\tconst uint8* rows[256];\n\tuint32 nrows = 1;\n\tfprintf(stderr, \"bpr=%d, sy=%d, bpr*sy=%d\\n\", bpr, sy, bpr*sy);\n\trows[0] = br + bpr*sy;\n\terr += step;\n\twhile (err >= limit) {\n\t    err -= limit;\n\t    sy++;\n\t    if (err >= limit)\n\t\t{\n\t\t\t/* We should perhaps error loudly, but I can't make sense of that */\n\t\t\t/* code... */\n\t\t\tif( nrows == 256 )\n\t\t\t\tbreak;\n\t\t\trows[nrows++] = br + bpr*sy;\n\t\t}\n\t}\n\tsetrow(row, nrows, rows);\n\trow += tnw;\n    }\n}",
          "fn_code_pos": [
            [
              550,
              0
            ],
            [
              581,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setImage1",
            "parameters": {
              "br": "uint8",
              "rw": "uint32",
              "rh": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nsetImage(const uint8* br, uint32 rw, uint32 rh)\n{\n    filterWidth = (uint16) ceil((double) rw / (double) tnw);\n    setupStepTables(rw);\n    setImage1(br, rw, rh);\n}",
          "fn_code_pos": [
            [
              583,
              0
            ],
            [
              589,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setImage",
            "parameters": {
              "br": "uint8",
              "rw": "uint32",
              "rh": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ngenerateThumbnail(TIFF* in, TIFF* out)\n{\n    unsigned char* raster;\n    unsigned char* rp;\n    uint32 sw, sh, rps;\n    uint16 bps, spp;\n    tsize_t rowsize, rastersize;\n    tstrip_t s, ns = TIFFNumberOfStrips(in);\n    toff_t diroff[1];\n\n    TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &sw);\n    TIFFGetField(in, TIFFTAG_IMAGELENGTH, &sh);\n    TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);\n    TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);\n    TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n    if (spp != 1 || bps != 1)\n\treturn 0;\n    rowsize = TIFFScanlineSize(in);\n    rastersize = sh * rowsize;\n    fprintf(stderr, \"rastersize=%u\\n\", (unsigned int)rastersize);\n\t/* +3 : add a few guard bytes since setrow() can read a bit */\n\t/* outside buffer */\n    raster = (unsigned char*)_TIFFmalloc(rastersize+3);\n    if (!raster) {\n\t    TIFFError(TIFFFileName(in),\n\t\t      \"Can't allocate space for raster buffer.\");\n\t    return 0;\n    }\n    raster[rastersize] = 0;\n    raster[rastersize+1] = 0;\n    raster[rastersize+2] = 0;\n    rp = raster;\n    for (s = 0; s < ns; s++) {\n\t(void) TIFFReadEncodedStrip(in, s, rp, -1);\n\trp += rps * rowsize;\n    }\n    TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric);\n    setupCmap();\n    setImage(raster, sw, sh);\n    _TIFFfree(raster);\n\n    TIFFSetField(out, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE);\n    TIFFSetField(out, TIFFTAG_IMAGEWIDTH, (uint32) tnw);\n    TIFFSetField(out, TIFFTAG_IMAGELENGTH, (uint32) tnh);\n    TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, (uint16) 8);\n    TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, (uint16) 1);\n    TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS);\n    TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISWHITE);\n    TIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n    TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    cpTag(in, out, TIFFTAG_SOFTWARE,\t\t(uint16) -1, TIFF_ASCII);\n    cpTag(in, out, TIFFTAG_IMAGEDESCRIPTION,\t(uint16) -1, TIFF_ASCII);\n    cpTag(in, out, TIFFTAG_DATETIME,\t\t(uint16) -1, TIFF_ASCII);\n    cpTag(in, out, TIFFTAG_HOSTCOMPUTER,\t(uint16) -1, TIFF_ASCII);\n    diroff[0] = 0UL;\n    TIFFSetField(out, TIFFTAG_SUBIFD, 1, diroff);\n    return (TIFFWriteEncodedStrip(out, 0, thumbnail, tnw*tnh) != -1 &&\n            TIFFWriteDirectory(out) != -1);\n}",
          "fn_code_pos": [
            [
              591,
              0
            ],
            [
              650,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "generateThumbnail",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              668,
              0
            ],
            [
              679,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "getopt(int, char**, char*)",
          "fn_dec_pos": [
            [
              42,
              11
            ],
            [
              42,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "cpIFD(TIFF*, TIFF*)",
          "fn_dec_pos": [
            [
              66,
              11
            ],
            [
              66,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpIFD",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "generateThumbnail(TIFF*, TIFF*)",
          "fn_dec_pos": [
            [
              67,
              11
            ],
            [
              67,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "generateThumbnail",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "initScale()",
          "fn_dec_pos": [
            [
              68,
              12
            ],
            [
              68,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "initScale",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              69,
              12
            ],
            [
              69,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct cpTag {\n    uint16\ttag;\n    uint16\tcount;\n    TIFFDataType type;\n}",
          {
            "tag": "uint16",
            "count": "uint16",
            "type": "TIFFDataType"
          },
          "cpTag",
          [
            216,
            7
          ],
          [
            220,
            1
          ]
        ],
        [
          "struct cpTag {\n    uint16\ttag;\n    uint16\tcount;\n    TIFFDataType type;\n}",
          {
            "tag": "uint16",
            "count": "uint16",
            "type": "TIFFDataType"
          },
          "cpTag",
          [
            216,
            7
          ],
          [
            220,
            1
          ]
        ],
        [
          "struct cpTag",
          {},
          "",
          [
            274,
            4
          ],
          [
            274,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n    EXP50,\n    EXP60,\n    EXP70,\n    EXP80,\n    EXP90,\n    EXP,\n    LINEAR\n} Contrast;",
          {
            "EXP50": "",
            "EXP60": "",
            "EXP70": "",
            "EXP80": "",
            "EXP90": "",
            "EXP": "",
            "LINEAR": ""
          },
          "Contrast",
          [
            51,
            0
          ],
          [
            59,
            11
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/tiffinfo.c": {
      "fn_def_list": [
        {
          "fn_code": "static void\nPrivateErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n        if (old_error_handler)\n                (*old_error_handler)(module,fmt,ap);\n\tstatus = 1;\n}",
          "fn_code_pos": [
            [
              55,
              0
            ],
            [
              61,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrivateErrorHandler",
            "parameters": {
              "module": "char",
              "fmt": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tint dirnum = -1, multiplefiles, c;\n\tuint16 order = 0;\n\tTIFF* tif;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\tlong flags = 0;\n\tuint64 diroff = 0;\n\tint chopstrips = 0;\t\t/* disable strip chopping */\n\n\twhile ((c = getopt(argc, argv, \"f:o:cdDSjilmrsvwz0123456789\")) != -1)\n\t\tswitch (c) {\n\t\tcase '0': case '1': case '2': case '3':\n\t\tcase '4': case '5': case '6': case '7':\n\t\tcase '8': case '9':\n\t\t\tdirnum = atoi(&argv[optind-1][1]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tshowdata++;\n\t\t\t/* fall through... */\n\t\tcase 'D':\n\t\t\treaddata++;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tflags |= TIFFPRINT_COLORMAP | TIFFPRINT_CURVES;\n\t\t\tbreak;\n\t\tcase 'f':\t\t/* fill order */\n\t\t\tif (streq(optarg, \"lsb2msb\"))\n\t\t\t\torder = FILLORDER_LSB2MSB;\n\t\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t\t\torder = FILLORDER_MSB2LSB;\n\t\t\telse\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tstoponerr = 0;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tdiroff = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tflags |= TIFFPRINT_JPEGQTABLES |\n\t\t\t\t TIFFPRINT_JPEGACTABLES |\n\t\t\t\t TIFFPRINT_JPEGDCTABLES;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trawdata = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tflags |= TIFFPRINT_STRIPS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tshowwords = 1;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tchopstrips = 1;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (optind >= argc)\n\t\tusage();\n\n\told_error_handler = TIFFSetErrorHandler(PrivateErrorHandler);\n\n\tmultiplefiles = (argc - optind > 1);\n\tfor (; optind < argc; optind++) {\n\t\tif (multiplefiles)\n\t\t\tprintf(\"%s:\\n\", argv[optind]);\n\t\ttif = TIFFOpen(argv[optind], chopstrips ? \"rC\" : \"rc\");\n\t\tif (tif != NULL) {\n\t\t\tif (dirnum != -1) {\n\t\t\t\tif (TIFFSetDirectory(tif, (tdir_t) dirnum))\n\t\t\t\t\ttiffinfo(tif, order, flags, 1);\n\t\t\t} else if (diroff != 0) {\n\t\t\t\tif (TIFFSetSubDirectory(tif, diroff))\n\t\t\t\t\ttiffinfo(tif, order, flags, 1);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\ttoff_t offset=0;\n\n\t\t\t\t\ttiffinfo(tif, order, flags, 1);\n\t\t\t\t\tif (TIFFGetField(tif, TIFFTAG_EXIFIFD,\n\t\t\t\t\t\t\t &offset)) {\n\t\t\t\t\t\tif (TIFFReadEXIFDirectory(tif, offset)) {\n\t\t\t\t\t\t\ttiffinfo(tif, order, flags, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (TIFFReadDirectory(tif));\n\t\t\t}\n\t\t\tTIFFClose(tif);\n\t\t}\n\t}\n\treturn (status);\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              183,
              0
            ],
            [
              194,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nShowStrip(tstrip_t strip, unsigned char* pp, uint32 nrow, tsize_t scanline)\n{\n\tregister tsize_t cc;\n\n\tprintf(\"Strip %lu:\\n\", (unsigned long) strip);\n\twhile (nrow-- > 0) {\n\t\tfor (cc = 0; cc < scanline; cc++) {\n\t\t\tprintf(\" %02x\", *pp++);\n\t\t\tif (((cc+1) % 24) == 0)\n\t\t\t\tputchar('\\n');\n\t\t}\n\t\tputchar('\\n');\n\t}\n}",
          "fn_code_pos": [
            [
              196,
              0
            ],
            [
              210,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ShowStrip",
            "parameters": {
              "strip": "tstrip_t",
              "pp": "unsigned char",
              "nrow": "uint32",
              "scanline": "tsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFReadContigStripData(TIFF* tif)\n{\n\tunsigned char *buf;\n\ttsize_t scanline = TIFFScanlineSize(tif);\n\n\tbuf = (unsigned char *)_TIFFmalloc(TIFFStripSize(tif));\n\tif (buf) {\n\t\tuint32 row, h=0;\n\t\tuint32 rowsperstrip = (uint32)-1;\n\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\t\tfor (row = 0; row < h; row += rowsperstrip) {\n\t\t\tuint32 nrow = (row+rowsperstrip > h ?\n\t\t\t    h-row : rowsperstrip);\n\t\t\ttstrip_t strip = TIFFComputeStrip(tif, row, 0);\n\t\t\tif (TIFFReadEncodedStrip(tif, strip, buf, nrow*scanline) < 0) {\n\t\t\t\tif (stoponerr)\n\t\t\t\t\tbreak;\n\t\t\t} else if (showdata)\n\t\t\t\tShowStrip(strip, buf, nrow, scanline);\n\t\t}\n\t\t_TIFFfree(buf);\n\t}\n}",
          "fn_code_pos": [
            [
              212,
              0
            ],
            [
              237,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadContigStripData",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFReadSeparateStripData(TIFF* tif)\n{\n\tunsigned char *buf;\n\ttsize_t scanline = TIFFScanlineSize(tif);\n\n\tbuf = (unsigned char *)_TIFFmalloc(TIFFStripSize(tif));\n\tif (buf) {\n\t\tuint32 row, h=0;\n\t\tuint32 rowsperstrip = (uint32)-1;\n\t\ttsample_t s, samplesperpixel=0;\n\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\t\tfor (row = 0; row < h; row += rowsperstrip) {\n\t\t\tfor (s = 0; s < samplesperpixel; s++) {\n\t\t\t\tuint32 nrow = (row+rowsperstrip > h ?\n\t\t\t\t    h-row : rowsperstrip);\n\t\t\t\ttstrip_t strip = TIFFComputeStrip(tif, row, s);\n\t\t\t\tif (TIFFReadEncodedStrip(tif, strip, buf, nrow*scanline) < 0) {\n\t\t\t\t\tif (stoponerr)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else if (showdata)\n\t\t\t\t\tShowStrip(strip, buf, nrow, scanline);\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(buf);\n\t}\n}",
          "fn_code_pos": [
            [
              239,
              0
            ],
            [
              268,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadSeparateStripData",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nShowTile(uint32 row, uint32 col, tsample_t sample,\n    unsigned char* pp, uint32 nrow, tsize_t rowsize)\n{\n\tuint32 cc;\n\n\tprintf(\"Tile (%lu,%lu\", (unsigned long) row, (unsigned long) col);\n\tif (sample != (tsample_t) -1)\n\t\tprintf(\",%u\", sample);\n\tprintf(\"):\\n\");\n\twhile (nrow-- > 0) {\n\t  for (cc = 0; cc < (uint32) rowsize; cc++) {\n\t\t\tprintf(\" %02x\", *pp++);\n\t\t\tif (((cc+1) % 24) == 0)\n\t\t\t\tputchar('\\n');\n\t\t}\n\t\tputchar('\\n');\n\t}\n}",
          "fn_code_pos": [
            [
              270,
              0
            ],
            [
              288,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ShowTile",
            "parameters": {
              "row": "uint32",
              "col": "uint32",
              "sample": "tsample_t",
              "pp": "unsigned char",
              "nrow": "uint32",
              "rowsize": "tsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFReadContigTileData(TIFF* tif)\n{\n\tunsigned char *buf;\n\ttmsize_t rowsize = TIFFTileRowSize(tif);\n        tmsize_t tilesize = TIFFTileSize(tif);\n\n\tbuf = (unsigned char *)_TIFFmalloc(tilesize);\n\tif (buf) {\n\t\tuint32 tw=0, th=0, w=0, h=0;\n\t\tuint32 row, col;\n\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n                if ( rowsize == 0 || th > (size_t) (tilesize / rowsize) )\n        {\n            fprintf(stderr, \"Cannot display data: th * rowsize > tilesize\\n\");\n            _TIFFfree(buf);\n            return;\n        }\n\t\tfor (row = 0; row < h; row += th) {\n\t\t\tfor (col = 0; col < w; col += tw) {\n\t\t\t\tif (TIFFReadTile(tif, buf, col, row, 0, 0) < 0) {\n\t\t\t\t\tif (stoponerr)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else if (showdata)\n\t\t\t\t\tShowTile(row, col, (tsample_t) -1, buf, th, rowsize);\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(buf);\n\t}\n}",
          "fn_code_pos": [
            [
              290,
              0
            ],
            [
              323,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadContigTileData",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFReadSeparateTileData(TIFF* tif)\n{\n\tunsigned char *buf;\n        tmsize_t rowsize = TIFFTileRowSize(tif);\n        tmsize_t tilesize = TIFFTileSize(tif);\n\n\tbuf = (unsigned char *)_TIFFmalloc(tilesize);\n\tif (buf) {\n\t\tuint32 tw=0, th=0, w=0, h=0;\n\t\tuint32 row, col;\n\t\ttsample_t s, samplesperpixel=0;\n\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n                if ( rowsize == 0 || th > (size_t) (tilesize / rowsize) )\n        {\n            fprintf(stderr, \"Cannot display data: th * rowsize > tilesize\\n\");\n            _TIFFfree(buf);\n            return;\n        }\n\t\tfor (row = 0; row < h; row += th) {\n\t\t\tfor (col = 0; col < w; col += tw) {\n\t\t\t\tfor (s = 0; s < samplesperpixel; s++) {\n\t\t\t\t\tif (TIFFReadTile(tif, buf, col, row, 0, s) < 0) {\n\t\t\t\t\t\tif (stoponerr)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (showdata)\n\t\t\t\t\t\tShowTile(row, col, s, buf, th, rowsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(buf);\n\t}\n}",
          "fn_code_pos": [
            [
              325,
              0
            ],
            [
              362,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadSeparateTileData",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFReadData(TIFF* tif)\n{\n\tuint16 config = PLANARCONFIG_CONTIG;\n\n\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n\tif (TIFFIsTiled(tif)) {\n\t\tif (config == PLANARCONFIG_CONTIG)\n\t\t\tTIFFReadContigTileData(tif);\n\t\telse\n\t\t\tTIFFReadSeparateTileData(tif);\n\t} else {\n\t\tif (config == PLANARCONFIG_CONTIG)\n\t\t\tTIFFReadContigStripData(tif);\n\t\telse\n\t\t\tTIFFReadSeparateStripData(tif);\n\t}\n}",
          "fn_code_pos": [
            [
              364,
              0
            ],
            [
              381,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadData",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nShowRawBytes(unsigned char* pp, uint32 n)\n{\n\tuint32 i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\" %02x\", *pp++);\n\t\tif (((i+1) % 24) == 0)\n\t\t\tprintf(\"\\n \");\n\t}\n\tputchar('\\n');\n}",
          "fn_code_pos": [
            [
              383,
              0
            ],
            [
              394,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ShowRawBytes",
            "parameters": {
              "pp": "unsigned char",
              "n": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nShowRawWords(uint16* pp, uint32 n)\n{\n\tuint32 i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\" %04x\", *pp++);\n\t\tif (((i+1) % 15) == 0)\n\t\t\tprintf(\"\\n \");\n\t}\n\tputchar('\\n');\n}",
          "fn_code_pos": [
            [
              396,
              0
            ],
            [
              407,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ShowRawWords",
            "parameters": {
              "pp": "uint16",
              "n": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFReadRawData(TIFF* tif, int bitrev)\n{\n\ttstrip_t nstrips = TIFFNumberOfStrips(tif);\n\tconst char* what = TIFFIsTiled(tif) ? \"Tile\" : \"Strip\";\n\tuint64* stripbc=NULL;\n\n\tTIFFGetField(tif, TIFFTAG_STRIPBYTECOUNTS, &stripbc);\n\tif (stripbc != NULL && nstrips > 0) {\n\t\tuint32 bufsize = (uint32) stripbc[0];\n\t\ttdata_t buf = _TIFFmalloc(bufsize);\n\t\ttstrip_t s;\n\n\t\tfor (s = 0; s < nstrips; s++) {\n\t\t\tif (stripbc[s] > bufsize) {\n\t\t\t\tbuf = _TIFFrealloc(buf, (tmsize_t)stripbc[s]);\n\t\t\t\tbufsize = (uint32) stripbc[s];\n\t\t\t}\n\t\t\tif (buf == NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t   \"Cannot allocate buffer to read strip %lu\\n\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (TIFFReadRawStrip(tif, s, buf, (tmsize_t) stripbc[s]) < 0) {\n\t\t\t\tfprintf(stderr, \"Error reading strip %lu\\n\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tif (stoponerr)\n\t\t\t\t\tbreak;\n\t\t\t} else if (showdata) {\n\t\t\t\tif (bitrev) {\n\t\t\t\t\tTIFFReverseBits(buf, (tmsize_t)stripbc[s]);\n\t\t\t\t\tprintf(\"%s %lu: (bit reversed)\\n \",\n\t\t\t\t\t    what, (unsigned long) s);\n\t\t\t\t} else\n\t\t\t\t\tprintf(\"%s %lu:\\n \", what,\n\t\t\t\t\t    (unsigned long) s);\n\t\t\t\tif (showwords)\n\t\t\t\t\tShowRawWords((uint16*) buf, (uint32) stripbc[s]>>1);\n\t\t\t\telse\n\t\t\t\t\tShowRawBytes((unsigned char*) buf, (uint32) stripbc[s]);\n\t\t\t}\n\t\t}\n\t\tif (buf != NULL)\n\t\t\t_TIFFfree(buf);\n\t}\n}",
          "fn_code_pos": [
            [
              409,
              0
            ],
            [
              455,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRawData",
            "parameters": {
              "tif": "TIFF",
              "bitrev": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ntiffinfo(TIFF* tif, uint16 order, long flags, int is_image)\n{\n\tTIFFPrintDirectory(tif, stdout, flags);\n\tif (!readdata || !is_image)\n\t\treturn;\n\tif (rawdata) {\n\t\tif (order) {\n\t\t\tuint16 o;\n\t\t\tTIFFGetFieldDefaulted(tif,\n\t\t\t    TIFFTAG_FILLORDER, &o);\n\t\t\tTIFFReadRawData(tif, o != order);\n\t\t} else\n\t\t\tTIFFReadRawData(tif, 0);\n\t} else {\n\t\tif (order)\n\t\t\tTIFFSetField(tif, TIFFTAG_FILLORDER, order);\n\t\tTIFFReadData(tif);\n\t}\n}",
          "fn_code_pos": [
            [
              457,
              0
            ],
            [
              476,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiffinfo",
            "parameters": {
              "tif": "TIFF",
              "order": "uint16",
              "flags": "long",
              "is_image": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              52,
              12
            ],
            [
              52,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "tiffinfo(TIFF*, uint16, long, int)",
          "fn_dec_pos": [
            [
              53,
              12
            ],
            [
              53,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiffinfo",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "# include <strings.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ],
        [
          "#include \"tiffiop.h\"\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/pal2rgb.c": {
      "fn_def_list": [
        {
          "fn_code": "static int\ncheckcmap(int n, uint16* r, uint16* g, uint16* b)\n{\n\twhile (n-- > 0)\n\t    if (*r++ >= 256 || *g++ >= 256 || *b++ >= 256)\n\t\treturn (16);\n\tfprintf(stderr, \"Warning, assuming 8-bit colormap.\\n\");\n\treturn (8);\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "checkcmap",
            "parameters": {
              "n": "int",
              "r": "uint16",
              "g": "uint16",
              "b": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tuint16 bitspersample, shortv;\n\tuint32 imagewidth, imagelength;\n\tuint16 config = PLANARCONFIG_CONTIG;\n\tuint32 rowsperstrip = (uint32) -1;\n\tuint16 photometric = PHOTOMETRIC_RGB;\n\tuint16 *rmap, *gmap, *bmap;\n\tuint32 row;\n\tint cmap = -1;\n\tTIFF *in, *out;\n\tint c;\n\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"C:c:p:r:\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'C':\t\t/* force colormap interpretation */\n\t\t\tcmap = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'c':\t\t/* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'p':\t\t/* planar configuration */\n\t\t\tif (streq(optarg, \"separate\"))\n\t\t\t\tconfig = PLANARCONFIG_SEPARATE;\n\t\t\telse if (streq(optarg, \"contig\"))\n\t\t\t\tconfig = PLANARCONFIG_CONTIG;\n\t\t\telse\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* rows/strip */\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind != 2)\n\t\tusage();\n\tin = TIFFOpen(argv[optind], \"r\");\n\tif (in == NULL)\n\t\treturn (-1);\n\tif (!TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &shortv) ||\n\t    shortv != PHOTOMETRIC_PALETTE) {\n\t\tfprintf(stderr, \"%s: Expecting a palette image.\\n\",\n\t\t    argv[optind]);\n\t\t(void) TIFFClose(in);\n\t\treturn (-1);\n\t}\n\tif (!TIFFGetField(in, TIFFTAG_COLORMAP, &rmap, &gmap, &bmap)) {\n\t\tfprintf(stderr,\n\t\t    \"%s: No colormap (not a valid palette image).\\n\",\n\t\t    argv[optind]);\n\t\t(void) TIFFClose(in);\n\t\treturn (-1);\n\t}\n\tbitspersample = 0;\n\tTIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\tif (bitspersample != 8) {\n\t\tfprintf(stderr, \"%s: Sorry, can only handle 8-bit images.\\n\",\n\t\t    argv[optind]);\n\t\t(void) TIFFClose(in);\n\t\treturn (-1);\n\t}\n\tout = TIFFOpen(argv[optind+1], \"w\");\n\tif (out == NULL) {\n\t\t(void) TIFFClose(in);\n\t\treturn (-2);\n\t}\n\tcpTags(in, out);\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &imagewidth);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &imagelength);\n\tif (compression != (uint16)-1)\n\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\telse\n\t\tTIFFGetField(in, TIFFTAG_COMPRESSION, &compression);\n\tswitch (compression) {\n\tcase COMPRESSION_JPEG:\n\t\tif (jpegcolormode == JPEGCOLORMODE_RGB)\n\t\t\tphotometric = PHOTOMETRIC_YCBCR;\n\t\telse\n\t\t\tphotometric = PHOTOMETRIC_RGB;\n\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\tbreak;\n\tcase COMPRESSION_LZW:\n\tcase COMPRESSION_DEFLATE:\n\t\tif (predictor != 0)\n\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\tbreak;\n\t}\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\n\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3);\n\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\n\t    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip));\n\t(void) TIFFGetField(in, TIFFTAG_PLANARCONFIG, &shortv);\n\tif (cmap == -1)\n\t\tcmap = checkcmap(1<<bitspersample, rmap, gmap, bmap);\n\tif (cmap == 16) {\n\t\t/*\n\t\t * Convert 16-bit colormap to 8-bit.\n\t\t */\n\t\tint i;\n\n\t\tfor (i = (1<<bitspersample)-1; i >= 0; i--) {\n#define\tCVT(x)\t\t(((x) * 255) / ((1L<<16)-1))\n\t\t\trmap[i] = CVT(rmap[i]);\n\t\t\tgmap[i] = CVT(gmap[i]);\n\t\t\tbmap[i] = CVT(bmap[i]);\n\t\t}\n\t}\n\t{ unsigned char *ibuf, *obuf;\n\t  register unsigned char* pp;\n\t  register uint32 x;\n\t  tmsize_t tss_in = TIFFScanlineSize(in);\n\t  tmsize_t tss_out = TIFFScanlineSize(out);\n\t  if (tss_out / tss_in < 3) {\n\t\t/*\n\t\t * BUG 2750: The following code does not know about chroma\n\t\t * subsampling of JPEG data. It assumes that the output buffer is 3x\n\t\t * the length of the input buffer due to exploding the palette into\n\t\t * RGB tuples. If this assumption is incorrect, it could lead to a\n\t\t * buffer overflow. Go ahead and fail now to prevent that.\n\t\t */\n\t\tfprintf(stderr, \"Could not determine correct image size for output. Exiting.\\n\");\n\t\treturn -1;\n      }\n\t  ibuf = (unsigned char*)_TIFFmalloc(tss_in);\n\t  obuf = (unsigned char*)_TIFFmalloc(tss_out);\n\t  switch (config) {\n\t  case PLANARCONFIG_CONTIG:\n\t\tfor (row = 0; row < imagelength; row++) {\n\t\t\tif (!TIFFReadScanline(in, ibuf, row, 0))\n\t\t\t\tgoto done;\n\t\t\tpp = obuf;\n\t\t\tfor (x = 0; x < imagewidth; x++) {\n\t\t\t\t*pp++ = (unsigned char) rmap[ibuf[x]];\n\t\t\t\t*pp++ = (unsigned char) gmap[ibuf[x]];\n\t\t\t\t*pp++ = (unsigned char) bmap[ibuf[x]];\n\t\t\t}\n\t\t\tif (!TIFFWriteScanline(out, obuf, row, 0))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\t  case PLANARCONFIG_SEPARATE:\n\t\tfor (row = 0; row < imagelength; row++) {\n\t\t\tif (!TIFFReadScanline(in, ibuf, row, 0))\n\t\t\t\tgoto done;\n\t\t\tfor (pp = obuf, x = 0; x < imagewidth; x++)\n\t\t\t\t*pp++ = (unsigned char) rmap[ibuf[x]];\n\t\t\tif (!TIFFWriteScanline(out, obuf, row, 0))\n\t\t\t\tgoto done;\n\t\t\tfor (pp = obuf, x = 0; x < imagewidth; x++)\n\t\t\t\t*pp++ = (unsigned char) gmap[ibuf[x]];\n\t\t\tif (!TIFFWriteScanline(out, obuf, row, 0))\n\t\t\t\tgoto done;\n\t\t\tfor (pp = obuf, x = 0; x < imagewidth; x++)\n\t\t\t\t*pp++ = (unsigned char) bmap[ibuf[x]];\n\t\t\tif (!TIFFWriteScanline(out, obuf, row, 0))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\t  }\n\t  _TIFFfree(ibuf);\n\t  _TIFFfree(obuf);\n\t}\ndone:\n\t(void) TIFFClose(in);\n\t(void) TIFFClose(out);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              68,
              0
            ],
            [
              245,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nprocessCompressOptions(char* opt)\n{\n\tif (streq(opt, \"none\"))\n\t\tcompression = COMPRESSION_NONE;\n\telse if (streq(opt, \"packbits\"))\n\t\tcompression = COMPRESSION_PACKBITS;\n\telse if (strneq(opt, \"jpeg\", 4)) {\n\t\tchar* cp = strchr(opt, ':');\n\n                compression = COMPRESSION_JPEG;\n                while( cp )\n                {\n                    if (isdigit((int)cp[1]))\n\t\t\tquality = atoi(cp+1);\n                    else if (cp[1] == 'r' )\n\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;\n                    else\n                        usage();\n\n                    cp = strchr(cp+1,':');\n                }\n\t} else if (strneq(opt, \"lzw\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_LZW;\n\t} else if (strneq(opt, \"zip\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_DEFLATE;\n\t} else\n\t\treturn (0);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              247,
              0
            ],
            [
              282,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {
              "opt": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ncpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type)\n{\n\tswitch (type) {\n\tcase TIFF_SHORT:\n\t\tif (count == 1) {\n\t\t\tuint16 shortv;\n\t\t\tCopyField(tag, shortv);\n\t\t} else if (count == 2) {\n\t\t\tuint16 shortv1, shortv2;\n\t\t\tCopyField2(tag, shortv1, shortv2);\n\t\t} else if (count == 4) {\n\t\t\tuint16 *tr, *tg, *tb, *ta;\n\t\t\tCopyField4(tag, tr, tg, tb, ta);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tuint16 shortv1;\n\t\t\tuint16* shortav;\n\t\t\tCopyField2(tag, shortv1, shortav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_LONG:\n\t\t{ uint32 longv;\n\t\t  CopyField(tag, longv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_RATIONAL:\n\t\tif (count == 1) {\n\t\t\tfloat floatv;\n\t\t\tCopyField(tag, floatv);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tfloat* floatav;\n\t\t\tCopyField(tag, floatav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_ASCII:\n\t\t{ char* stringv;\n\t\t  CopyField(tag, stringv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_DOUBLE:\n\t\tif (count == 1) {\n\t\t\tdouble doublev;\n\t\t\tCopyField(tag, doublev);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tdouble* doubleav;\n\t\t\tCopyField(tag, doubleav);\n\t\t}\n\t\tbreak;\n          default:\n                TIFFError(TIFFFileName(in),\n                          \"Data type %d is not supported, tag %d skipped.\",\n                          tag, type);\n\t}\n}",
          "fn_code_pos": [
            [
              293,
              0
            ],
            [
              346,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpTag",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF",
              "tag": "uint16",
              "count": "uint16",
              "type": "TIFFDataType"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ncpTags(TIFF* in, TIFF* out)\n{\n    struct cpTag *p;\n    for (p = tags; p < &tags[NTAGS]; p++)\n    {\n        if( p->tag == TIFFTAG_GROUP3OPTIONS )\n        {\n            uint16 compression;\n            if( !TIFFGetField(in, TIFFTAG_COMPRESSION, &compression) ||\n                    compression != COMPRESSION_CCITTFAX3 )\n                continue;\n        }\n        if( p->tag == TIFFTAG_GROUP4OPTIONS )\n        {\n            uint16 compression;\n            if( !TIFFGetField(in, TIFFTAG_COMPRESSION, &compression) ||\n                    compression != COMPRESSION_CCITTFAX4 )\n                continue;\n        }\n        cpTag(in, out, p->tag, p->count, p->type);\n    }\n}",
          "fn_code_pos": [
            [
              404,
              0
            ],
            [
              426,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpTags",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              449,
              0
            ],
            [
              460,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              44,
              12
            ],
            [
              44,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "cpTags(TIFF* in, TIFF* out)",
          "fn_dec_pos": [
            [
              45,
              12
            ],
            [
              45,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpTags",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "processCompressOptions(char*)",
          "fn_dec_pos": [
            [
              66,
              11
            ],
            [
              66,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct cpTag {\n    uint16\ttag;\n    uint16\tcount;\n    TIFFDataType type;\n}",
          {
            "tag": "uint16",
            "count": "uint16",
            "type": "TIFFDataType"
          },
          "cpTag",
          [
            353,
            7
          ],
          [
            357,
            1
          ]
        ],
        [
          "struct cpTag {\n    uint16\ttag;\n    uint16\tcount;\n    TIFFDataType type;\n}",
          {
            "tag": "uint16",
            "count": "uint16",
            "type": "TIFFDataType"
          },
          "cpTag",
          [
            353,
            7
          ],
          [
            357,
            1
          ]
        ],
        [
          "struct cpTag",
          {},
          "",
          [
            407,
            4
          ],
          [
            407,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/tiffmedian.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tint i, dither = 0;\n\tuint16 shortv, config, photometric;\n\tColorbox *box_list, *ptr;\n\tfloat floatv;\n\tuint32 longv;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\n\tnum_colors = MAX_CMAP_SIZE;\n\twhile ((c = getopt(argc, argv, \"c:C:r:f\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'c':\t\t/* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'C':\t\t/* set colormap size */\n\t\t\tnum_colors = atoi(optarg);\n\t\t\tif (num_colors > MAX_CMAP_SIZE) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t   \"-c: colormap too big, max %d\\n\",\n\t\t\t\t   MAX_CMAP_SIZE);\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f':\t\t/* dither */\n\t\t\tdither = 1;\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* rows/strip */\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind != 2)\n\t\tusage();\n\tin = TIFFOpen(argv[optind], \"r\");\n\tif (in == NULL)\n\t\treturn (-1);\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &imagewidth);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &imagelength);\n\tTIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\tTIFFGetField(in, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\tif (bitspersample != 8 && bitspersample != 16) {\n\t\tfprintf(stderr, \"%s: Image must have at least 8-bits/sample\\n\",\n\t\t    argv[optind]);\n\t\treturn (-3);\n\t}\n\tif (!TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric) ||\n\t    photometric != PHOTOMETRIC_RGB || samplesperpixel < 3) {\n\t\tfprintf(stderr, \"%s: Image must have RGB data\\n\", argv[optind]);\n\t\treturn (-4);\n\t}\n\tTIFFGetField(in, TIFFTAG_PLANARCONFIG, &config);\n\tif (config != PLANARCONFIG_CONTIG) {\n\t\tfprintf(stderr, \"%s: Can only handle contiguous data packing\\n\",\n\t\t    argv[optind]);\n\t\treturn (-5);\n\t}\n\n\t/*\n\t * STEP 1:  create empty boxes\n\t */\n\tusedboxes = NULL;\n\tbox_list = freeboxes = (Colorbox *)_TIFFmalloc(num_colors*sizeof (Colorbox));\n\tfreeboxes[0].next = &freeboxes[1];\n\tfreeboxes[0].prev = NULL;\n\tfor (i = 1; i < num_colors-1; ++i) {\n\t\tfreeboxes[i].next = &freeboxes[i+1];\n\t\tfreeboxes[i].prev = &freeboxes[i-1];\n\t}\n\tfreeboxes[num_colors-1].next = NULL;\n\tfreeboxes[num_colors-1].prev = &freeboxes[num_colors-2];\n\n\t/*\n\t * STEP 2: get histogram, initialize first box\n\t */\n\tptr = freeboxes;\n\tfreeboxes = ptr->next;\n\tif (freeboxes)\n\t\tfreeboxes->prev = NULL;\n\tptr->next = usedboxes;\n\tusedboxes = ptr;\n\tif (ptr->next)\n\t\tptr->next->prev = ptr;\n\tget_histogram(in, ptr);\n\n\t/*\n\t * STEP 3: continually subdivide boxes until no more free\n\t * boxes remain or until all colors assigned.\n\t */\n\twhile (freeboxes != NULL) {\n\t\tptr = largest_box();\n\t\tif (ptr != NULL)\n\t\t\tsplitbox(ptr);\n\t\telse\n\t\t\tfreeboxes = NULL;\n\t}\n\n\t/*\n\t * STEP 4: assign colors to all boxes\n\t */\n\tfor (i = 0, ptr = usedboxes; ptr != NULL; ++i, ptr = ptr->next) {\n\t\trm[i] = ((ptr->rmin + ptr->rmax) << COLOR_SHIFT) / 2;\n\t\tgm[i] = ((ptr->gmin + ptr->gmax) << COLOR_SHIFT) / 2;\n\t\tbm[i] = ((ptr->bmin + ptr->bmax) << COLOR_SHIFT) / 2;\n\t}\n\n\t/* We're done with the boxes now */\n\t_TIFFfree(box_list);\n\tfreeboxes = usedboxes = NULL;\n\n\t/*\n\t * STEP 5: scan histogram and map all values to closest color\n\t */\n\t/* 5a: create cell list as described in Heckbert[2] */\n\tColorCells = (C_cell **)_TIFFmalloc(C_LEN*C_LEN*C_LEN*sizeof (C_cell*));\n\t_TIFFmemset(ColorCells, 0, C_LEN*C_LEN*C_LEN*sizeof (C_cell*));\n\t/* 5b: create mapping from truncated pixel space to color\n\t   table entries */\n\tmap_colortable();\n\n\t/*\n\t * STEP 6: scan image, match input values to table entries\n\t */\n\tout = TIFFOpen(argv[optind+1], \"w\");\n\tif (out == NULL)\n\t\treturn (-2);\n\n\tCopyField(TIFFTAG_SUBFILETYPE, longv);\n\tCopyField(TIFFTAG_IMAGEWIDTH, longv);\n\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, (short)COLOR_DEPTH);\n\tif (compression != (uint16)-1) {\n\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\t\tswitch (compression) {\n\t\tcase COMPRESSION_LZW:\n\t\tcase COMPRESSION_DEFLATE:\n\t\t\tif (predictor != 0)\n\t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tCopyField(TIFFTAG_COMPRESSION, compression);\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, (short)PHOTOMETRIC_PALETTE);\n\tCopyField(TIFFTAG_ORIENTATION, shortv);\n\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, (short)1);\n\tCopyField(TIFFTAG_PLANARCONFIG, shortv);\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\n\t    TIFFDefaultStripSize(out, rowsperstrip));\n\tCopyField(TIFFTAG_MINSAMPLEVALUE, shortv);\n\tCopyField(TIFFTAG_MAXSAMPLEVALUE, shortv);\n\tCopyField(TIFFTAG_RESOLUTIONUNIT, shortv);\n\tCopyField(TIFFTAG_XRESOLUTION, floatv);\n\tCopyField(TIFFTAG_YRESOLUTION, floatv);\n\tCopyField(TIFFTAG_XPOSITION, floatv);\n\tCopyField(TIFFTAG_YPOSITION, floatv);\n\n\tif (dither)\n\t\tquant_fsdither(in, out);\n\telse\n\t\tquant(in, out);\n\t/*\n\t * Scale colormap to TIFF-required 16-bit values.\n\t */\n#define\tSCALE(x)\t(((x)*((1L<<16)-1))/255)\n\tfor (i = 0; i < MAX_CMAP_SIZE; ++i) {\n\t\trm[i] = SCALE(rm[i]);\n\t\tgm[i] = SCALE(gm[i]);\n\t\tbm[i] = SCALE(bm[i]);\n\t}\n\tTIFFSetField(out, TIFFTAG_COLORMAP, rm, gm, bm);\n\t(void) TIFFClose(out);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              114,
              0
            ],
            [
              293,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nprocessCompressOptions(char* opt)\n{\n\tif (streq(opt, \"none\"))\n\t\tcompression = COMPRESSION_NONE;\n\telse if (streq(opt, \"packbits\"))\n\t\tcompression = COMPRESSION_PACKBITS;\n\telse if (strneq(opt, \"lzw\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_LZW;\n\t} else if (strneq(opt, \"zip\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_DEFLATE;\n\t} else\n\t\treturn (0);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              295,
              0
            ],
            [
              315,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {
              "opt": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              334,
              0
            ],
            [
              345,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nget_histogram(TIFF* in, Colorbox* box)\n{\n\tregister unsigned char *inptr;\n\tregister int red, green, blue;\n\tregister uint32 j, i;\n\tunsigned char *inputline;\n\n\tinputline = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n\tif (inputline == NULL) {\n\t\tfprintf(stderr, \"No space for scanline buffer\\n\");\n\t\texit(-1);\n\t}\n\tbox->rmin = box->gmin = box->bmin = 999;\n\tbox->rmax = box->gmax = box->bmax = -1;\n\tbox->total = imagewidth * imagelength;\n\n\t{ register uint32 *ptr = &histogram[0][0][0];\n\t  for (i = B_LEN*B_LEN*B_LEN; i-- > 0;)\n\t\t*ptr++ = 0;\n\t}\n\tfor (i = 0; i < imagelength; i++) {\n\t\tif (TIFFReadScanline(in, inputline, i, 0) <= 0)\n\t\t\tbreak;\n\t\tinptr = inputline;\n\t\tfor (j = imagewidth; j-- > 0;) {\n\t\t\tred = (*inptr++) & 0xff >> COLOR_SHIFT;\n\t\t\tgreen = (*inptr++) & 0xff >> COLOR_SHIFT;\n\t\t\tblue = (*inptr++) & 0xff >> COLOR_SHIFT;\n                        if ((red | green | blue) >= B_LEN) {\n                                fprintf(stderr,\n                                        \"Logic error. \"\n                                        \"Histogram array overflow!\\n\");\n                                exit(-6);\n                        }\n\t\t\tif (red < box->rmin)\n\t\t\t\tbox->rmin = red;\n\t\t        if (red > box->rmax)\n\t\t\t\tbox->rmax = red;\n\t\t        if (green < box->gmin)\n\t\t\t\tbox->gmin = green;\n\t\t        if (green > box->gmax)\n\t\t\t\tbox->gmax = green;\n\t\t        if (blue < box->bmin)\n\t\t\t\tbox->bmin = blue;\n\t\t        if (blue > box->bmax)\n\t\t\t\tbox->bmax = blue;\n\t\t        histogram[red][green][blue]++;\n\t\t}\n\t}\n\t_TIFFfree(inputline);\n}",
          "fn_code_pos": [
            [
              347,
              0
            ],
            [
              398,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_histogram",
            "parameters": {
              "in": "TIFF",
              "box": "Colorbox"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static Colorbox *\nlargest_box(void)\n{\n\tregister Colorbox *p, *b;\n\tregister uint32 size;\n\n\tb = NULL;\n\tsize = 0;\n\tfor (p = usedboxes; p != NULL; p = p->next)\n\t\tif ((p->rmax > p->rmin || p->gmax > p->gmin ||\n\t\t    p->bmax > p->bmin) &&  p->total > size)\n\t\t        size = (b = p)->total;\n\treturn (b);\n}",
          "fn_code_pos": [
            [
              400,
              0
            ],
            [
              413,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "largest_box",
            "parameters": {},
            "return_type": "Colorbox"
          }
        },
        {
          "fn_code": "static void\nsplitbox(Colorbox* ptr)\n{\n\tuint32\t\thist2[B_LEN];\n\tint\t\tfirst=0, last=0;\n\tregister Colorbox\t*new;\n\tregister uint32\t*iptr, *histp;\n\tregister int\ti, j;\n\tregister int\tir,ig,ib;\n\tregister uint32 sum, sum1, sum2;\n\tenum { RED, GREEN, BLUE } axis;\n\n\t/*\n\t * See which axis is the largest, do a histogram along that\n\t * axis.  Split at median point.  Contract both new boxes to\n\t * fit points and return\n\t */\n\ti = ptr->rmax - ptr->rmin;\n\tif (i >= ptr->gmax - ptr->gmin && i >= ptr->bmax - ptr->bmin)\n\t\taxis = RED;\n\telse if (ptr->gmax - ptr->gmin >= ptr->bmax - ptr->bmin)\n\t\taxis = GREEN;\n\telse\n\t\taxis = BLUE;\n\t/* get histogram along longest axis */\n\tswitch (axis) {\n\tcase RED:\n\t\thistp = &hist2[ptr->rmin];\n\t        for (ir = ptr->rmin; ir <= ptr->rmax; ++ir) {\n\t\t\t*histp = 0;\n\t\t\tfor (ig = ptr->gmin; ig <= ptr->gmax; ++ig) {\n\t\t\t\tiptr = &histogram[ir][ig][ptr->bmin];\n\t\t\t\tfor (ib = ptr->bmin; ib <= ptr->bmax; ++ib)\n\t\t\t\t\t*histp += *iptr++;\n\t\t\t}\n\t\t\thistp++;\n\t        }\n\t        first = ptr->rmin;\n\t\tlast = ptr->rmax;\n\t        break;\n\tcase GREEN:\n\t        histp = &hist2[ptr->gmin];\n\t        for (ig = ptr->gmin; ig <= ptr->gmax; ++ig) {\n\t\t\t*histp = 0;\n\t\t\tfor (ir = ptr->rmin; ir <= ptr->rmax; ++ir) {\n\t\t\t\tiptr = &histogram[ir][ig][ptr->bmin];\n\t\t\t\tfor (ib = ptr->bmin; ib <= ptr->bmax; ++ib)\n\t\t\t\t\t*histp += *iptr++;\n\t\t\t}\n\t\t\thistp++;\n\t        }\n\t        first = ptr->gmin;\n\t\tlast = ptr->gmax;\n\t        break;\n\tcase BLUE:\n\t        histp = &hist2[ptr->bmin];\n\t        for (ib = ptr->bmin; ib <= ptr->bmax; ++ib) {\n\t\t\t*histp = 0;\n\t\t\tfor (ir = ptr->rmin; ir <= ptr->rmax; ++ir) {\n\t\t\t\tiptr = &histogram[ir][ptr->gmin][ib];\n\t\t\t\tfor (ig = ptr->gmin; ig <= ptr->gmax; ++ig) {\n\t\t\t\t\t*histp += *iptr;\n\t\t\t\t\tiptr += B_LEN;\n\t\t\t\t}\n\t\t\t}\n\t\t\thistp++;\n\t        }\n\t        first = ptr->bmin;\n\t\tlast = ptr->bmax;\n\t        break;\n\t}\n\t/* find median point */\n\tsum2 = ptr->total / 2;\n\thistp = &hist2[first];\n\tsum = 0;\n\tfor (i = first; i <= last && (sum += *histp++) < sum2; ++i)\n\t\t;\n\tif (i == first)\n\t\ti++;\n\n\t/* Create new box, re-allocate points */\n\tnew = freeboxes;\n\tfreeboxes = new->next;\n\tif (freeboxes)\n\t\tfreeboxes->prev = NULL;\n\tif (usedboxes)\n\t\tusedboxes->prev = new;\n\tnew->next = usedboxes;\n\tusedboxes = new;\n\n\thistp = &hist2[first];\n\tfor (sum1 = 0, j = first; j < i; j++)\n\t\tsum1 += *histp++;\n\tfor (sum2 = 0, j = i; j <= last; j++)\n\t    sum2 += *histp++;\n\tnew->total = sum1;\n\tptr->total = sum2;\n\n\tnew->rmin = ptr->rmin;\n\tnew->rmax = ptr->rmax;\n\tnew->gmin = ptr->gmin;\n\tnew->gmax = ptr->gmax;\n\tnew->bmin = ptr->bmin;\n\tnew->bmax = ptr->bmax;\n\tswitch (axis) {\n\tcase RED:\n\t\tnew->rmax = i-1;\n\t        ptr->rmin = i;\n\t        break;\n\tcase GREEN:\n\t        new->gmax = i-1;\n\t        ptr->gmin = i;\n\t        break;\n\tcase BLUE:\n\t        new->bmax = i-1;\n\t        ptr->bmin = i;\n\t        break;\n\t}\n\tshrinkbox(new);\n\tshrinkbox(ptr);\n}",
          "fn_code_pos": [
            [
              415,
              0
            ],
            [
              535,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "splitbox",
            "parameters": {
              "ptr": "Colorbox"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nshrinkbox(Colorbox* box)\n{\n\tregister uint32 *histp;\n\tregister int\tir, ig, ib;\n\n\tif (box->rmax > box->rmin) {\n\t\tfor (ir = box->rmin; ir <= box->rmax; ++ir)\n\t\t\tfor (ig = box->gmin; ig <= box->gmax; ++ig) {\n\t\t\t\thistp = &histogram[ir][ig][box->bmin];\n\t\t\t        for (ib = box->bmin; ib <= box->bmax; ++ib)\n\t\t\t\t\tif (*histp++ != 0) {\n\t\t\t\t\t\tbox->rmin = ir;\n\t\t\t\t\t\tgoto have_rmin;\n\t\t\t\t\t}\n\t\t\t}\n\thave_rmin:\n\t\tif (box->rmax > box->rmin)\n\t\t\tfor (ir = box->rmax; ir >= box->rmin; --ir)\n\t\t\t\tfor (ig = box->gmin; ig <= box->gmax; ++ig) {\n\t\t\t\t\thistp = &histogram[ir][ig][box->bmin];\n\t\t\t\t\tib = box->bmin;\n\t\t\t\t\tfor (; ib <= box->bmax; ++ib)\n\t\t\t\t\t\tif (*histp++ != 0) {\n\t\t\t\t\t\t\tbox->rmax = ir;\n\t\t\t\t\t\t\tgoto have_rmax;\n\t\t\t\t\t\t}\n\t\t\t        }\n\t}\nhave_rmax:\n\tif (box->gmax > box->gmin) {\n\t\tfor (ig = box->gmin; ig <= box->gmax; ++ig)\n\t\t\tfor (ir = box->rmin; ir <= box->rmax; ++ir) {\n\t\t\t\thistp = &histogram[ir][ig][box->bmin];\n\t\t\t        for (ib = box->bmin; ib <= box->bmax; ++ib)\n\t\t\t\tif (*histp++ != 0) {\n\t\t\t\t\tbox->gmin = ig;\n\t\t\t\t\tgoto have_gmin;\n\t\t\t\t}\n\t\t\t}\n\thave_gmin:\n\t\tif (box->gmax > box->gmin)\n\t\t\tfor (ig = box->gmax; ig >= box->gmin; --ig)\n\t\t\t\tfor (ir = box->rmin; ir <= box->rmax; ++ir) {\n\t\t\t\t\thistp = &histogram[ir][ig][box->bmin];\n\t\t\t\t\tib = box->bmin;\n\t\t\t\t\tfor (; ib <= box->bmax; ++ib)\n\t\t\t\t\t\tif (*histp++ != 0) {\n\t\t\t\t\t\t\tbox->gmax = ig;\n\t\t\t\t\t\t\tgoto have_gmax;\n\t\t\t\t\t\t}\n\t\t\t        }\n\t}\nhave_gmax:\n\tif (box->bmax > box->bmin) {\n\t\tfor (ib = box->bmin; ib <= box->bmax; ++ib)\n\t\t\tfor (ir = box->rmin; ir <= box->rmax; ++ir) {\n\t\t\t\thistp = &histogram[ir][box->gmin][ib];\n\t\t\t        for (ig = box->gmin; ig <= box->gmax; ++ig) {\n\t\t\t\t\tif (*histp != 0) {\n\t\t\t\t\t\tbox->bmin = ib;\n\t\t\t\t\t\tgoto have_bmin;\n\t\t\t\t\t}\n\t\t\t\t\thistp += B_LEN;\n\t\t\t        }\n\t\t        }\n\thave_bmin:\n\t\tif (box->bmax > box->bmin)\n\t\t\tfor (ib = box->bmax; ib >= box->bmin; --ib)\n\t\t\t\tfor (ir = box->rmin; ir <= box->rmax; ++ir) {\n\t\t\t\t\thistp = &histogram[ir][box->gmin][ib];\n\t\t\t\t\tig = box->gmin;\n\t\t\t\t\tfor (; ig <= box->gmax; ++ig) {\n\t\t\t\t\t\tif (*histp != 0) {\n\t\t\t\t\t\t\tbox->bmax = ib;\n\t\t\t\t\t\t\tgoto have_bmax;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thistp += B_LEN;\n\t\t\t\t\t}\n\t\t\t        }\n\t}\nhave_bmax:\n\t;\n}",
          "fn_code_pos": [
            [
              537,
              0
            ],
            [
              620,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "shrinkbox",
            "parameters": {
              "box": "Colorbox"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static C_cell *\ncreate_colorcell(int red, int green, int blue)\n{\n\tregister int ir, ig, ib, i;\n\tregister C_cell *ptr;\n\tint mindist, next_n;\n\tregister int tmp, dist, n;\n\n\tir = red >> (COLOR_DEPTH-C_DEPTH);\n\tig = green >> (COLOR_DEPTH-C_DEPTH);\n\tib = blue >> (COLOR_DEPTH-C_DEPTH);\n\tptr = (C_cell *)_TIFFmalloc(sizeof (C_cell));\n\t*(ColorCells + ir*C_LEN*C_LEN + ig*C_LEN + ib) = ptr;\n\tptr->num_ents = 0;\n\n\t/*\n\t * Step 1: find all colors inside this cell, while we're at\n\t *\t   it, find distance of centermost point to furthest corner\n\t */\n\tmindist = 99999999;\n\tfor (i = 0; i < num_colors; ++i) {\n\t\tif (rm[i]>>(COLOR_DEPTH-C_DEPTH) != ir  ||\n\t\t    gm[i]>>(COLOR_DEPTH-C_DEPTH) != ig  ||\n\t\t    bm[i]>>(COLOR_DEPTH-C_DEPTH) != ib)\n\t\t\tcontinue;\n\t\tptr->entries[ptr->num_ents][0] = i;\n\t\tptr->entries[ptr->num_ents][1] = 0;\n\t\t++ptr->num_ents;\n\t        tmp = rm[i] - red;\n\t        if (tmp < (MAX_COLOR/C_LEN/2))\n\t\t\ttmp = MAX_COLOR/C_LEN-1 - tmp;\n\t        dist = tmp*tmp;\n\t        tmp = gm[i] - green;\n\t        if (tmp < (MAX_COLOR/C_LEN/2))\n\t\t\ttmp = MAX_COLOR/C_LEN-1 - tmp;\n\t        dist += tmp*tmp;\n\t        tmp = bm[i] - blue;\n\t        if (tmp < (MAX_COLOR/C_LEN/2))\n\t\t\ttmp = MAX_COLOR/C_LEN-1 - tmp;\n\t        dist += tmp*tmp;\n\t        if (dist < mindist)\n\t\t\tmindist = dist;\n\t}\n\n\t/*\n\t * Step 3: find all points within that distance to cell.\n\t */\n\tfor (i = 0; i < num_colors; ++i) {\n\t\tif (rm[i] >> (COLOR_DEPTH-C_DEPTH) == ir  &&\n\t\t    gm[i] >> (COLOR_DEPTH-C_DEPTH) == ig  &&\n\t\t    bm[i] >> (COLOR_DEPTH-C_DEPTH) == ib)\n\t\t\tcontinue;\n\t\tdist = 0;\n\t        if ((tmp = red - rm[i]) > 0 ||\n\t\t    (tmp = rm[i] - (red + MAX_COLOR/C_LEN-1)) > 0 )\n\t\t\tdist += tmp*tmp;\n\t        if ((tmp = green - gm[i]) > 0 ||\n\t\t    (tmp = gm[i] - (green + MAX_COLOR/C_LEN-1)) > 0 )\n\t\t\tdist += tmp*tmp;\n\t        if ((tmp = blue - bm[i]) > 0 ||\n\t\t    (tmp = bm[i] - (blue + MAX_COLOR/C_LEN-1)) > 0 )\n\t\t\tdist += tmp*tmp;\n\t        if (dist < mindist) {\n\t\t\tptr->entries[ptr->num_ents][0] = i;\n\t\t\tptr->entries[ptr->num_ents][1] = dist;\n\t\t\t++ptr->num_ents;\n\t        }\n\t}\n\n\t/*\n\t * Sort color cells by distance, use cheap exchange sort\n\t */\n\tfor (n = ptr->num_ents - 1; n > 0; n = next_n) {\n\t\tnext_n = 0;\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tif (ptr->entries[i][1] > ptr->entries[i+1][1]) {\n\t\t\t\ttmp = ptr->entries[i][0];\n\t\t\t\tptr->entries[i][0] = ptr->entries[i+1][0];\n\t\t\t\tptr->entries[i+1][0] = tmp;\n\t\t\t\ttmp = ptr->entries[i][1];\n\t\t\t\tptr->entries[i][1] = ptr->entries[i+1][1];\n\t\t\t\tptr->entries[i+1][1] = tmp;\n\t\t\t\tnext_n = i;\n\t\t        }\n\t}\n\treturn (ptr);\n}",
          "fn_code_pos": [
            [
              622,
              0
            ],
            [
              708,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "create_colorcell",
            "parameters": {
              "red": "int",
              "green": "int",
              "blue": "int"
            },
            "return_type": "C_cell"
          }
        },
        {
          "fn_code": "static void\nmap_colortable(void)\n{\n\tregister uint32 *histp = &histogram[0][0][0];\n\tregister C_cell *cell;\n\tregister int j, tmp, d2, dist;\n\tint ir, ig, ib, i;\n\n\tfor (ir = 0; ir < B_LEN; ++ir)\n\t\tfor (ig = 0; ig < B_LEN; ++ig)\n\t\t\tfor (ib = 0; ib < B_LEN; ++ib, histp++) {\n\t\t\t\tif (*histp == 0) {\n\t\t\t\t\t*histp = -1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcell = *(ColorCells +\n\t\t\t\t    (((ir>>(B_DEPTH-C_DEPTH)) << C_DEPTH*2) +\n\t\t\t\t    ((ig>>(B_DEPTH-C_DEPTH)) << C_DEPTH) +\n\t\t\t\t    (ib>>(B_DEPTH-C_DEPTH))));\n\t\t\t\tif (cell == NULL )\n\t\t\t\t\tcell = create_colorcell(\n\t\t\t\t\t    ir << COLOR_SHIFT,\n\t\t\t\t\t    ig << COLOR_SHIFT,\n\t\t\t\t\t    ib << COLOR_SHIFT);\n\t\t\t\tdist = 9999999;\n\t\t\t\tfor (i = 0; i < cell->num_ents &&\n\t\t\t\t    dist > cell->entries[i][1]; ++i) {\n\t\t\t\t\tj = cell->entries[i][0];\n\t\t\t\t\td2 = rm[j] - (ir << COLOR_SHIFT);\n\t\t\t\t\td2 *= d2;\n\t\t\t\t\ttmp = gm[j] - (ig << COLOR_SHIFT);\n\t\t\t\t\td2 += tmp*tmp;\n\t\t\t\t\ttmp = bm[j] - (ib << COLOR_SHIFT);\n\t\t\t\t\td2 += tmp*tmp;\n\t\t\t\t\tif (d2 < dist) {\n\t\t\t\t\t\tdist = d2;\n\t\t\t\t\t\t*histp = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n}",
          "fn_code_pos": [
            [
              710,
              0
            ],
            [
              750,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "map_colortable",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nquant(TIFF* in, TIFF* out)\n{\n\tunsigned char\t*outline, *inputline;\n\tregister unsigned char\t*outptr, *inptr;\n\tregister uint32 i, j;\n\tregister int red, green, blue;\n\n\tinputline = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n\toutline = (unsigned char *)_TIFFmalloc(imagewidth);\n\tfor (i = 0; i < imagelength; i++) {\n\t\tif (TIFFReadScanline(in, inputline, i, 0) <= 0)\n\t\t\tbreak;\n\t\tinptr = inputline;\n\t\toutptr = outline;\n\t\tfor (j = 0; j < imagewidth; j++) {\n\t\t\tred = *inptr++ >> COLOR_SHIFT;\n\t\t\tgreen = *inptr++ >> COLOR_SHIFT;\n\t\t\tblue = *inptr++ >> COLOR_SHIFT;\n\t\t\t*outptr++ = (unsigned char)histogram[red][green][blue];\n\t\t}\n\t\tif (TIFFWriteScanline(out, outline, i, 0) < 0)\n\t\t\tbreak;\n\t}\n\t_TIFFfree(inputline);\n\t_TIFFfree(outline);\n}",
          "fn_code_pos": [
            [
              757,
              0
            ],
            [
              783,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "quant",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nquant_fsdither(TIFF* in, TIFF* out)\n{\n\tunsigned char *outline, *inputline, *inptr;\n\tshort *thisline, *nextline;\n\tregister unsigned char\t*outptr;\n\tregister short *thisptr, *nextptr;\n\tregister uint32 i, j;\n\tuint32 imax, jmax;\n\tint lastline, lastpixel;\n\n\timax = imagelength - 1;\n\tjmax = imagewidth - 1;\n\tinputline = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(in));\n\tthisline = (short *)_TIFFmalloc(imagewidth * 3 * sizeof (short));\n\tnextline = (short *)_TIFFmalloc(imagewidth * 3 * sizeof (short));\n\toutline = (unsigned char *) _TIFFmalloc(TIFFScanlineSize(out));\n\n\tGetInputLine(in, 0, goto bad);\t\t/* get first line */\n\tfor (i = 1; i <= imagelength; ++i) {\n\t\tSWAP(short *, thisline, nextline);\n\t\tlastline = (i >= imax);\n\t\tif (i <= imax)\n\t\t\tGetInputLine(in, i, break);\n\t\tthisptr = thisline;\n\t\tnextptr = nextline;\n\t\toutptr = outline;\n\t\tfor (j = 0; j < imagewidth; ++j) {\n\t\t\tint red, green, blue;\n\t\t\tregister int oval, r2, g2, b2;\n\n\t\t\tlastpixel = (j == jmax);\n\t\t\tGetComponent(*thisptr++, r2, red);\n\t\t\tGetComponent(*thisptr++, g2, green);\n\t\t\tGetComponent(*thisptr++, b2, blue);\n\t\t\toval = histogram[r2][g2][b2];\n\t\t\tif (oval == -1) {\n\t\t\t\tint ci;\n\t\t\t\tregister int cj, tmp, d2, dist;\n\t\t\t\tregister C_cell\t*cell;\n\n\t\t\t\tcell = *(ColorCells +\n\t\t\t\t    (((r2>>(B_DEPTH-C_DEPTH)) << C_DEPTH*2) +\n\t\t\t\t    ((g2>>(B_DEPTH-C_DEPTH)) << C_DEPTH ) +\n\t\t\t\t    (b2>>(B_DEPTH-C_DEPTH))));\n\t\t\t\tif (cell == NULL)\n\t\t\t\t\tcell = create_colorcell(red,\n\t\t\t\t\t    green, blue);\n\t\t\t\tdist = 9999999;\n\t\t\t\tfor (ci = 0; ci < cell->num_ents && dist > cell->entries[ci][1]; ++ci) {\n\t\t\t\t\tcj = cell->entries[ci][0];\n\t\t\t\t\td2 = (rm[cj] >> COLOR_SHIFT) - r2;\n\t\t\t\t\td2 *= d2;\n\t\t\t\t\ttmp = (gm[cj] >> COLOR_SHIFT) - g2;\n\t\t\t\t\td2 += tmp*tmp;\n\t\t\t\t\ttmp = (bm[cj] >> COLOR_SHIFT) - b2;\n\t\t\t\t\td2 += tmp*tmp;\n\t\t\t\t\tif (d2 < dist) {\n\t\t\t\t\t\tdist = d2;\n\t\t\t\t\t\toval = cj;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thistogram[r2][g2][b2] = oval;\n\t\t\t}\n\t\t\t*outptr++ = oval;\n\t\t\tred -= rm[oval];\n\t\t\tgreen -= gm[oval];\n\t\t\tblue -= bm[oval];\n\t\t\tif (!lastpixel) {\n\t\t\t\tthisptr[0] += blue * 7 / 16;\n\t\t\t\tthisptr[1] += green * 7 / 16;\n\t\t\t\tthisptr[2] += red * 7 / 16;\n\t\t\t}\n\t\t\tif (!lastline) {\n\t\t\t\tif (j != 0) {\n\t\t\t\t\tnextptr[-3] += blue * 3 / 16;\n\t\t\t\t\tnextptr[-2] += green * 3 / 16;\n\t\t\t\t\tnextptr[-1] += red * 3 / 16;\n\t\t\t\t}\n\t\t\t\tnextptr[0] += blue * 5 / 16;\n\t\t\t\tnextptr[1] += green * 5 / 16;\n\t\t\t\tnextptr[2] += red * 5 / 16;\n\t\t\t\tif (!lastpixel) {\n\t\t\t\t\tnextptr[3] += blue / 16;\n\t\t\t\t        nextptr[4] += green / 16;\n\t\t\t\t        nextptr[5] += red / 16;\n\t\t\t\t}\n\t\t\t\tnextptr += 3;\n\t\t\t}\n\t\t}\n\t\tif (TIFFWriteScanline(out, outline, i-1, 0) < 0)\n\t\t\tbreak;\n\t}\nbad:\n\t_TIFFfree(inputline);\n\t_TIFFfree(thisline);\n\t_TIFFfree(nextline);\n\t_TIFFfree(outline);\n}",
          "fn_code_pos": [
            [
              810,
              0
            ],
            [
              908,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "quant_fsdither",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "get_histogram(TIFF*, Colorbox*)",
          "fn_dec_pos": [
            [
              100,
              12
            ],
            [
              100,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_histogram",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "splitbox(Colorbox*)",
          "fn_dec_pos": [
            [
              101,
              12
            ],
            [
              101,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "splitbox",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "shrinkbox(Colorbox*)",
          "fn_dec_pos": [
            [
              102,
              12
            ],
            [
              102,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "shrinkbox",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "map_colortable(void)",
          "fn_dec_pos": [
            [
              103,
              12
            ],
            [
              103,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "map_colortable",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "quant(TIFF*, TIFF*)",
          "fn_dec_pos": [
            [
              104,
              12
            ],
            [
              104,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "quant",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "quant_fsdither(TIFF*, TIFF*)",
          "fn_dec_pos": [
            [
              105,
              12
            ],
            [
              105,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "quant_fsdither",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "largest_box(void)",
          "fn_dec_pos": [
            [
              106,
              17
            ],
            [
              106,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "largest_box",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              108,
              12
            ],
            [
              108,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "processCompressOptions(char*)",
          "fn_dec_pos": [
            [
              109,
              11
            ],
            [
              109,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "largest_box(void)",
          "fn_dec_pos": [
            [
              401,
              0
            ],
            [
              401,
              17
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "largest_box",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "create_colorcell(int red, int green, int blue)",
          "fn_dec_pos": [
            [
              623,
              0
            ],
            [
              623,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "create_colorcell",
            "parameters": {
              "red": "int",
              "green": "int",
              "blue": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "SWAP(short *, thisline, nextline)",
          "fn_dec_pos": [
            [
              830,
              2
            ],
            [
              830,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SWAP",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef\tstruct colorbox {\n\tstruct\tcolorbox *next, *prev;\n\tint\trmin, rmax;\n\tint\tgmin, gmax;\n\tint\tbmin, bmax;\n\tuint32\ttotal;\n} Colorbox;",
          {
            "*next": "struct\tcolorbox",
            "rmin": "int",
            "gmin": "int",
            "bmin": "int",
            "total": "uint32"
          },
          "Colorbox",
          [
            72,
            0
          ],
          [
            78,
            11
          ]
        ],
        [
          "typedef struct {\n\tint\tnum_ents;\n\tint\tentries[MAX_CMAP_SIZE][2];\n} C_cell;",
          {
            "num_ents": "int",
            "entries[MAX_CMAP_SIZE][2]": "int"
          },
          "C_cell",
          [
            80,
            0
          ],
          [
            83,
            9
          ]
        ],
        [
          "typedef\tstruct colorbox {\n\tstruct\tcolorbox *next, *prev;\n\tint\trmin, rmax;\n\tint\tgmin, gmax;\n\tint\tbmin, bmax;\n\tuint32\ttotal;\n} Colorbox;",
          {
            "*next": "struct\tcolorbox",
            "rmin": "int",
            "gmin": "int",
            "bmin": "int",
            "total": "uint32"
          },
          "Colorbox",
          [
            72,
            0
          ],
          [
            78,
            11
          ]
        ],
        [
          "struct\tcolorbox",
          {},
          "",
          [
            73,
            1
          ],
          [
            73,
            16
          ]
        ],
        [
          "typedef struct {\n\tint\tnum_ents;\n\tint\tentries[MAX_CMAP_SIZE][2];\n} C_cell;",
          {
            "num_ents": "int",
            "entries[MAX_CMAP_SIZE][2]": "int"
          },
          "C_cell",
          [
            80,
            0
          ],
          [
            83,
            9
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            54,
            0
          ],
          [
            55,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "enum { RED, GREEN, BLUE }",
          {
            "RED": "",
            "GREEN": "",
            "BLUE": ""
          },
          "",
          [
            425,
            1
          ],
          [
            425,
            26
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/rgb2ycbcr.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tTIFF *in, *out;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char *optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"c:h:r:v:z\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'c':\n\t\t\tif (streq(optarg, \"none\"))\n\t\t\t    compression = COMPRESSION_NONE;\n\t\t\telse if (streq(optarg, \"packbits\"))\n\t\t\t    compression = COMPRESSION_PACKBITS;\n\t\t\telse if (streq(optarg, \"lzw\"))\n\t\t\t    compression = COMPRESSION_LZW;\n\t\t\telse if (streq(optarg, \"jpeg\"))\n\t\t\t    compression = COMPRESSION_JPEG;\n\t\t\telse if (streq(optarg, \"zip\"))\n\t\t\t    compression = COMPRESSION_ADOBE_DEFLATE;\n\t\t\telse\n\t\t\t    usage(-1);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\thorizSubSampling = atoi(optarg);\n            if( horizSubSampling != 1 && horizSubSampling != 2 && horizSubSampling != 4 )\n                usage(-1);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tvertSubSampling = atoi(optarg);\n            if( vertSubSampling != 1 && vertSubSampling != 2 && vertSubSampling != 4 )\n                usage(-1);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\t/* CCIR Rec 601-1 w/ headroom/footroom */\n\t\t\trefBlackWhite[0] = 16.;\n\t\t\trefBlackWhite[1] = 235.;\n\t\t\trefBlackWhite[2] = 128.;\n\t\t\trefBlackWhite[3] = 240.;\n\t\t\trefBlackWhite[4] = 128.;\n\t\t\trefBlackWhite[5] = 240.;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage(0);\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind < 2)\n\t\tusage(-1);\n\tout = TIFFOpen(argv[argc-1], \"w\");\n\tif (out == NULL)\n\t\treturn (-2);\n\tsetupLumaTables();\n\tfor (; optind < argc-1; optind++) {\n\t\tin = TIFFOpen(argv[optind], \"r\");\n\t\tif (in != NULL) {\n\t\t\tdo {\n\t\t\t\tif (!tiffcvt(in, out) ||\n\t\t\t\t    !TIFFWriteDirectory(out)) {\n\t\t\t\t\t(void) TIFFClose(out);\n\t\t\t\t\treturn (1);\n\t\t\t\t}\n\t\t\t} while (TIFFReadDirectory(in));\n\t\t\t(void) TIFFClose(in);\n\t\t}\n\t}\n\t(void) TIFFClose(out);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              139,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static float*\nsetupLuma(float c)\n{\n\tfloat *v = (float *)_TIFFmalloc(256 * sizeof (float));\n\tint i;\n\tfor (i = 0; i < 256; i++)\n\t\tv[i] = c * i;\n\treturn (v);\n}",
          "fn_code_pos": [
            [
              147,
              0
            ],
            [
              155,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setupLuma",
            "parameters": {
              "c": "float"
            },
            "return_type": "float"
          }
        },
        {
          "fn_code": "static unsigned\nV2Code(float f, float RB, float RW, int CR)\n{\n\tunsigned int c = (unsigned int)((((f)*(RW-RB)/CR)+RB)+.5);\n\treturn (c > 255 ? 255 : c);\n}",
          "fn_code_pos": [
            [
              157,
              0
            ],
            [
              162,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "V2Code",
            "parameters": {
              "f": "float",
              "RB": "float",
              "RW": "float",
              "CR": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "static void\nsetupLumaTables(void)\n{\n\tlumaRed = setupLuma(LumaRed);\n\tlumaGreen = setupLuma(LumaGreen);\n\tlumaBlue = setupLuma(LumaBlue);\n\tD1 = 1.F/(2.F - 2.F*LumaBlue);\n\tD2 = 1.F/(2.F - 2.F*LumaRed);\n\tYzero = V2Code(0, refBlackWhite[0], refBlackWhite[1], 255);\n}",
          "fn_code_pos": [
            [
              164,
              0
            ],
            [
              173,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setupLumaTables",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ncvtClump(unsigned char* op, uint32* raster, uint32 ch, uint32 cw, uint32 w)\n{\n\tfloat Y, Cb = 0, Cr = 0;\n\tuint32 j, k;\n\t/*\n\t * Convert ch-by-cw block of RGB\n\t * to YCbCr and sample accordingly.\n\t */\n\tfor (k = 0; k < ch; k++) {\n\t\tfor (j = 0; j < cw; j++) {\n\t\t\tuint32 RGB = (raster - k*w)[j];\n\t\t\tY = lumaRed[TIFFGetR(RGB)] +\n\t\t\t    lumaGreen[TIFFGetG(RGB)] +\n\t\t\t    lumaBlue[TIFFGetB(RGB)];\n\t\t\t/* accumulate chrominance */\n\t\t\tCb += (TIFFGetB(RGB) - Y) * D1;\n\t\t\tCr += (TIFFGetR(RGB) - Y) * D2;\n\t\t\t/* emit luminence */\n\t\t\t*op++ = V2Code(Y,\n\t\t\t    refBlackWhite[0], refBlackWhite[1], 255);\n\t\t}\n\t\tfor (; j < horizSubSampling; j++)\n\t\t\t*op++ = Yzero;\n\t}\n\tfor (; k < vertSubSampling; k++) {\n\t\tfor (j = 0; j < horizSubSampling; j++)\n\t\t\t*op++ = Yzero;\n\t}\n\t/* emit sampled chrominance values */\n\t*op++ = V2Code(Cb / (ch*cw), refBlackWhite[2], refBlackWhite[3], 127);\n\t*op++ = V2Code(Cr / (ch*cw), refBlackWhite[4], refBlackWhite[5], 127);\n}",
          "fn_code_pos": [
            [
              175,
              0
            ],
            [
              207,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cvtClump",
            "parameters": {
              "op": "unsigned char",
              "raster": "uint32",
              "ch": "uint32",
              "cw": "uint32",
              "w": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ncvtStrip(unsigned char* op, uint32* raster, uint32 nrows, uint32 width)\n{\n\tuint32 x;\n\tint clumpSize = vertSubSampling * horizSubSampling + 2;\n\tuint32 *tp;\n\n\tfor (; nrows >= vertSubSampling; nrows -= vertSubSampling) {\n\t\ttp = raster;\n\t\tfor (x = width; x >= horizSubSampling; x -= horizSubSampling) {\n\t\t\tcvtClump(op, tp,\n\t\t\t    vertSubSampling, horizSubSampling, width);\n\t\t\top += clumpSize;\n\t\t\ttp += horizSubSampling;\n\t\t}\n\t\tif (x > 0) {\n\t\t\tcvtClump(op, tp, vertSubSampling, x, width);\n\t\t\top += clumpSize;\n\t\t}\n\t\traster -= vertSubSampling*width;\n\t}\n\tif (nrows > 0) {\n\t\ttp = raster;\n\t\tfor (x = width; x >= horizSubSampling; x -= horizSubSampling) {\n\t\t\tcvtClump(op, tp, nrows, horizSubSampling, width);\n\t\t\top += clumpSize;\n\t\t\ttp += horizSubSampling;\n\t\t}\n\t\tif (x > 0)\n\t\t\tcvtClump(op, tp, nrows, x, width);\n\t}\n}",
          "fn_code_pos": [
            [
              217,
              0
            ],
            [
              248,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cvtStrip",
            "parameters": {
              "op": "unsigned char",
              "raster": "uint32",
              "nrows": "uint32",
              "width": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ncvtRaster(TIFF* tif, uint32* raster, uint32 width, uint32 height)\n{\n\tuint32 y;\n\ttstrip_t strip = 0;\n\ttsize_t cc, acc;\n\tunsigned char* buf;\n\tuint32 rwidth = roundup(width, horizSubSampling);\n\tuint32 rheight = roundup(height, vertSubSampling);\n\tuint32 nrows = (rowsperstrip > rheight ? rheight : rowsperstrip);\n        uint32 rnrows = roundup(nrows,vertSubSampling);\n\n\tcc = rnrows*rwidth +\n\t    2*((rnrows*rwidth) / (horizSubSampling*vertSubSampling));\n\tbuf = (unsigned char*)_TIFFmalloc(cc);\n\t// FIXME unchecked malloc\n\tfor (y = height; (int32) y > 0; y -= nrows) {\n\t\tuint32 nr = (y > nrows ? nrows : y);\n\t\tcvtStrip(buf, raster + (y-1)*width, nr, width);\n\t\tnr = roundup(nr, vertSubSampling);\n\t\tacc = nr*rwidth +\n\t\t\t2*((nr*rwidth)/(horizSubSampling*vertSubSampling));\n\t\tif (!TIFFWriteEncodedStrip(tif, strip++, buf, acc)) {\n\t\t\t_TIFFfree(buf);\n\t\t\treturn (0);\n\t\t}\n\t}\n\t_TIFFfree(buf);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              250,
              0
            ],
            [
              279,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cvtRaster",
            "parameters": {
              "tif": "TIFF",
              "raster": "uint32",
              "width": "uint32",
              "height": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ntiffcvt(TIFF* in, TIFF* out)\n{\n\tuint32 width, height;\t\t/* image width & height */\n\tuint32* raster;\t\t\t/* retrieve RGBA image */\n\tuint16 shortv;\n\tfloat floatv;\n\tchar *stringv;\n\tuint32 longv;\n\tint result;\n\tsize_t pixel_count;\n\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &height);\n\tpixel_count = width * height;\n\n \t/* XXX: Check the integer overflow. */\n \tif (!width || !height || pixel_count / width != height) {\n \t\tTIFFError(TIFFFileName(in),\n \t\t\t  \"Malformed input file; \"\n \t\t\t  \"can't allocate buffer for raster of %lux%lu size\",\n \t\t\t  (unsigned long)width, (unsigned long)height);\n \t\treturn 0;\n \t}\n \n \traster = (uint32*)_TIFFCheckMalloc(in, pixel_count, sizeof(uint32),\n \t\t\t\t\t   \"raster buffer\");\n  \tif (raster == 0) {\n \t\tTIFFError(TIFFFileName(in),\n \t\t\t  \"Failed to allocate buffer (%lu elements of %lu each)\",\n \t\t\t  (unsigned long)pixel_count,\n \t\t\t  (unsigned long)sizeof(uint32));\n  \t\treturn (0);\n  \t}\n\n\tif (!TIFFReadRGBAImage(in, width, height, raster, 0)) {\n\t\t_TIFFfree(raster);\n\t\treturn (0);\n\t}\n\n\tCopyField(TIFFTAG_SUBFILETYPE, longv);\n\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, height);\n\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 8);\n\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\tif (compression == COMPRESSION_JPEG)\n\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n\tCopyField(TIFFTAG_FILLORDER, shortv);\n\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3);\n\tCopyField(TIFFTAG_XRESOLUTION, floatv);\n\tCopyField(TIFFTAG_YRESOLUTION, floatv);\n\tCopyField(TIFFTAG_RESOLUTIONUNIT, shortv);\n\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t{ char buf[2048];\n\t  char *cp = strrchr(TIFFFileName(in), '/');\n\t  snprintf(buf, sizeof(buf), \"YCbCr conversion of %s\",\n\t\t   cp ? cp+1 : TIFFFileName(in));\n\t  TIFFSetField(out, TIFFTAG_IMAGEDESCRIPTION, buf);\n\t}\n\tTIFFSetField(out, TIFFTAG_SOFTWARE, TIFFGetVersion());\n\tCopyField(TIFFTAG_DOCUMENTNAME, stringv);\n\n\tTIFFSetField(out, TIFFTAG_REFERENCEBLACKWHITE, refBlackWhite);\n\tTIFFSetField(out, TIFFTAG_YCBCRSUBSAMPLING,\n\t    horizSubSampling, vertSubSampling);\n\tTIFFSetField(out, TIFFTAG_YCBCRPOSITIONING, YCBCRPOSITION_CENTERED);\n\tTIFFSetField(out, TIFFTAG_YCBCRCOEFFICIENTS, ycbcrCoeffs);\n\trowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n\tresult = cvtRaster(out, raster, width, height);\n        _TIFFfree(raster);\n        return result;\n}",
          "fn_code_pos": [
            [
              281,
              0
            ],
            [
              356,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiffcvt",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(int code)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n       \n fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(code);\n}",
          "fn_code_pos": [
            [
              373,
              0
            ],
            [
              385,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {
              "code": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "tiffcvt(TIFF* in, TIFF* out)",
          "fn_dec_pos": [
            [
              63,
              11
            ],
            [
              63,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiffcvt",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "usage(int code)",
          "fn_dec_pos": [
            [
              64,
              12
            ],
            [
              64,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {
              "code": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "setupLumaTables(void)",
          "fn_dec_pos": [
            [
              65,
              12
            ],
            [
              65,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setupLumaTables",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "setupLuma(float c)",
          "fn_dec_pos": [
            [
              148,
              0
            ],
            [
              148,
              18
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setupLuma",
            "parameters": {
              "c": "float"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"tiffiop.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/tiffcp.c": {
      "fn_def_list": [
        {
          "fn_code": "static int nextSrcImage (TIFF *tif, char **imageSpec)\n/*\n  seek to the next image specified in *imageSpec\n  returns 1 if success, 0 if no more images to process\n  *imageSpec=NULL if subsequent images should be processed in sequence\n*/\n{\n\tif (**imageSpec == comma) {  /* if not @comma, we've done all images */\n\t\tchar *start = *imageSpec + 1;\n\t\ttdir_t nextImage = (tdir_t)strtol(start, imageSpec, 0);\n\t\tif (start == *imageSpec) nextImage = TIFFCurrentDirectory (tif);\n\t\tif (**imageSpec)\n\t\t{\n\t\t\tif (**imageSpec == comma) {\n\t\t\t\t/* a trailing comma denotes remaining images in sequence */\n\t\t\t\tif ((*imageSpec)[1] == '\\0') *imageSpec = NULL;\n\t\t\t}else{\n\t\t\t\tfprintf (stderr,\n\t\t\t\t    \"Expected a %c separated image # list after %s\\n\",\n\t\t\t\t    comma, TIFFFileName (tif));\n\t\t\t\texit (-4);   /* syntax error */\n\t\t\t}\n\t\t}\n\t\tif (TIFFSetDirectory (tif, nextImage)) return 1;\n\t\tfprintf (stderr, \"%s%c%d not found!\\n\",\n\t\t    TIFFFileName(tif), comma, (int) nextImage);\n\t}\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              96,
              0
            ],
            [
              124,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "nextSrcImage",
            "parameters": {
              "tif": "TIFF",
              "imageSpec": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static TIFF* openSrcImage (char **imageSpec)\n/*\n  imageSpec points to a pointer to a filename followed by optional ,image#'s\n  Open the TIFF file and assign *imageSpec to either NULL if there are\n  no images specified, or a pointer to the next image number text\n*/\n{\n\tTIFF *tif;\n\tchar *fn = *imageSpec;\n\t*imageSpec = strchr (fn, comma);\n\tif (*imageSpec) {  /* there is at least one image number specifier */\n\t\t**imageSpec = '\\0';\n\t\ttif = TIFFOpen (fn, \"r\");\n\t\t/* but, ignore any single trailing comma */\n\t\tif (!(*imageSpec)[1]) {*imageSpec = NULL; return tif;}\n\t\tif (tif) {\n\t\t\t**imageSpec = comma;  /* replace the comma */\n\t\t\tif (!nextSrcImage(tif, imageSpec)) {\n\t\t\t\tTIFFClose (tif);\n\t\t\t\ttif = NULL;\n\t\t\t}\n\t\t}\n\t}else\n\t\ttif = TIFFOpen (fn, \"r\");\n\treturn tif;\n}",
          "fn_code_pos": [
            [
              127,
              0
            ],
            [
              152,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "openSrcImage",
            "parameters": {
              "imageSpec": "char"
            },
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tuint16 defconfig = (uint16) -1;\n\tuint16 deffillorder = 0;\n\tuint32 deftilewidth = (uint32) -1;\n\tuint32 deftilelength = (uint32) -1;\n\tuint32 defrowsperstrip = (uint32) 0;\n\tuint64 diroff = 0;\n\tTIFF* in;\n\tTIFF* out;\n\tchar mode[10];\n\tchar* mp = mode;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\n\t*mp++ = 'w';\n\t*mp = '\\0';\n\twhile ((c = getopt(argc, argv, \",:b:c:f:l:o:p:r:w:aistBLMC8x\")) != -1)\n\t\tswitch (c) {\n\t\tcase ',':\n\t\t\tif (optarg[0] != '=') usage();\n\t\t\tcomma = optarg[1];\n\t\t\tbreak;\n\t\tcase 'b':   /* this file is bias image subtracted from others */\n\t\t\tif (bias) {\n\t\t\t\tfputs (\"Only 1 bias image may be specified\\n\", stderr);\n\t\t\t\texit (-2);\n\t\t\t}\n\t\t\t{\n\t\t\t\tuint16 samples = (uint16) -1;\n\t\t\t\tchar **biasFn = &optarg;\n\t\t\t\tbias = openSrcImage (biasFn);\n\t\t\t\tif (!bias) exit (-5);\n\t\t\t\tif (TIFFIsTiled (bias)) {\n\t\t\t\t\tfputs (\"Bias image must be organized in strips\\n\", stderr);\n\t\t\t\t\texit (-7);\n\t\t\t\t}\n\t\t\t\tTIFFGetField(bias, TIFFTAG_SAMPLESPERPIXEL, &samples);\n\t\t\t\tif (samples != 1) {\n\t\t\t\t\tfputs (\"Bias image must be monochrome\\n\", stderr);\n\t\t\t\t\texit (-7);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a':   /* append to output */\n\t\t\tmode[0] = 'a';\n\t\t\tbreak;\n\t\tcase 'c':   /* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'f':   /* fill order */\n\t\t\tif (streq(optarg, \"lsb2msb\"))\n\t\t\t\tdeffillorder = FILLORDER_LSB2MSB;\n\t\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t\t\tdeffillorder = FILLORDER_MSB2LSB;\n\t\t\telse\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'i':   /* ignore errors */\n\t\t\tignore = TRUE;\n\t\t\tbreak;\n\t\tcase 'l':   /* tile length */\n\t\t\touttiled = TRUE;\n\t\t\tdeftilelength = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'o':   /* initial directory offset */\n\t\t\tdiroff = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'p':   /* planar configuration */\n\t\t\tif (streq(optarg, \"separate\"))\n\t\t\t\tdefconfig = PLANARCONFIG_SEPARATE;\n\t\t\telse if (streq(optarg, \"contig\"))\n\t\t\t\tdefconfig = PLANARCONFIG_CONTIG;\n\t\t\telse\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'r':   /* rows/strip */\n\t\t\tdefrowsperstrip = atol(optarg);\n\t\t\tbreak;\n\t\tcase 's':   /* generate stripped output */\n\t\t\touttiled = FALSE;\n\t\t\tbreak;\n\t\tcase 't':   /* generate tiled output */\n\t\t\touttiled = TRUE;\n\t\t\tbreak;\n\t\tcase 'w':   /* tile width */\n\t\t\touttiled = TRUE;\n\t\t\tdeftilewidth = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\t*mp++ = 'b'; *mp = '\\0';\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\t*mp++ = 'l'; *mp = '\\0';\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\t*mp++ = 'm'; *mp = '\\0';\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\t*mp++ = 'c'; *mp = '\\0';\n\t\t\tbreak;\n\t\tcase '8':\n\t\t\t*mp++ = '8'; *mp = '\\0';\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tpageInSeq = 1;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind < 2)\n\t\tusage();\n\tout = TIFFOpen(argv[argc-1], mode);\n\tif (out == NULL)\n\t\treturn (-2);\n\tif ((argc - optind) == 2)\n\t\tpageNum = -1;\n\tfor (; optind < argc-1 ; optind++) {\n\t\tchar *imageCursor = argv[optind];\n\t\tin = openSrcImage (&imageCursor);\n\t\tif (in == NULL) {\n\t\t\t(void) TIFFClose(out);\n\t\t\treturn (-3);\n\t\t}\n\t\tif (diroff != 0 && !TIFFSetSubDirectory(in, diroff)) {\n\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t    \"Error, setting subdirectory at \" TIFF_UINT64_FORMAT, diroff);\n\t\t\t(void) TIFFClose(in);\n\t\t\t(void) TIFFClose(out);\n\t\t\treturn (1);\n\t\t}\n\t\tfor (;;) {\n\t\t\tconfig = defconfig;\n\t\t\tcompression = defcompression;\n\t\t\tpredictor = defpredictor;\n                        preset = defpreset;\n\t\t\tfillorder = deffillorder;\n\t\t\trowsperstrip = defrowsperstrip;\n\t\t\ttilewidth = deftilewidth;\n\t\t\ttilelength = deftilelength;\n\t\t\tg3opts = defg3opts;\n\t\t\tif (!tiffcp(in, out) || !TIFFWriteDirectory(out)) {\n\t\t\t\t(void) TIFFClose(in);\n\t\t\t\t(void) TIFFClose(out);\n\t\t\t\treturn (1);\n\t\t\t}\n\t\t\tif (imageCursor) { /* seek next image directory */\n\t\t\t\tif (!nextSrcImage(in, &imageCursor)) break;\n\t\t\t}else\n\t\t\t\tif (!TIFFReadDirectory(in)) break;\n\t\t}\n\t\t(void) TIFFClose(in);\n\t}\n\n\t(void) TIFFClose(out);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              154,
              0
            ],
            [
              316,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nprocessZIPOptions(char* cp)\n{\n\tif ( (cp = strchr(cp, ':')) ) {\n\t\tdo {\n\t\t\tcp++;\n\t\t\tif (isdigit((int)*cp))\n\t\t\t\tdefpredictor = atoi(cp);\n\t\t\telse if (*cp == 'p')\n\t\t\t\tdefpreset = atoi(++cp);\n\t\t\telse\n\t\t\t\tusage();\n\t\t} while( (cp = strchr(cp, ':')) );\n\t}\n}",
          "fn_code_pos": [
            [
              318,
              0
            ],
            [
              332,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processZIPOptions",
            "parameters": {
              "cp": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nprocessG3Options(char* cp)\n{\n\tif( (cp = strchr(cp, ':')) ) {\n\t\tif (defg3opts == (uint32) -1)\n\t\t\tdefg3opts = 0;\n\t\tdo {\n\t\t\tcp++;\n\t\t\tif (strneq(cp, \"1d\", 2))\n\t\t\t\tdefg3opts &= ~GROUP3OPT_2DENCODING;\n\t\t\telse if (strneq(cp, \"2d\", 2))\n\t\t\t\tdefg3opts |= GROUP3OPT_2DENCODING;\n\t\t\telse if (strneq(cp, \"fill\", 4))\n\t\t\t\tdefg3opts |= GROUP3OPT_FILLBITS;\n\t\t\telse\n\t\t\t\tusage();\n\t\t} while( (cp = strchr(cp, ':')) );\n\t}\n}",
          "fn_code_pos": [
            [
              334,
              0
            ],
            [
              352,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processG3Options",
            "parameters": {
              "cp": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nprocessCompressOptions(char* opt)\n{\n\tif (streq(opt, \"none\")) {\n\t\tdefcompression = COMPRESSION_NONE;\n\t} else if (streq(opt, \"packbits\")) {\n\t\tdefcompression = COMPRESSION_PACKBITS;\n\t} else if (strneq(opt, \"jpeg\", 4)) {\n\t\tchar* cp = strchr(opt, ':');\n\n\t\tdefcompression = COMPRESSION_JPEG;\n\t\twhile( cp )\n\t\t{\n\t\t\tif (isdigit((int)cp[1]))\n\t\t\t\tquality = atoi(cp+1);\n\t\t\telse if (cp[1] == 'r' )\n\t\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;\n\t\t\telse\n\t\t\t\tusage();\n\n\t\t\tcp = strchr(cp+1,':');\n\t\t}\n\t} else if (strneq(opt, \"g3\", 2)) {\n\t\tprocessG3Options(opt);\n\t\tdefcompression = COMPRESSION_CCITTFAX3;\n\t} else if (streq(opt, \"g4\")) {\n\t\tdefcompression = COMPRESSION_CCITTFAX4;\n\t} else if (strneq(opt, \"lzw\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tdefpredictor = atoi(cp+1);\n\t\tdefcompression = COMPRESSION_LZW;\n\t} else if (strneq(opt, \"zip\", 3)) {\n\t\tprocessZIPOptions(opt);\n\t\tdefcompression = COMPRESSION_ADOBE_DEFLATE;\n\t} else if (strneq(opt, \"lzma\", 4)) {\n\t\tprocessZIPOptions(opt);\n\t\tdefcompression = COMPRESSION_LZMA;\n\t} else if (strneq(opt, \"zstd\", 4)) {\n\t\tprocessZIPOptions(opt);\n\t\tdefcompression = COMPRESSION_ZSTD;\n\t} else if (strneq(opt, \"webp\", 4)) {\n\t\tprocessZIPOptions(opt);\n\t\tdefcompression = COMPRESSION_WEBP;\n\t} else if (strneq(opt, \"jbig\", 4)) {\n\t\tdefcompression = COMPRESSION_JBIG;\n\t} else if (strneq(opt, \"sgilog\", 6)) {\n\t\tdefcompression = COMPRESSION_SGILOG;\n\t} else\n\t\treturn (0);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              354,
              0
            ],
            [
              405,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {
              "opt": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n\tfprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              471,
              0
            ],
            [
              482,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ncpTag(TIFF* in, TIFF* out, uint16 tag, uint16 count, TIFFDataType type)\n{\n\tswitch (type) {\n\tcase TIFF_SHORT:\n\t\tif (count == 1) {\n\t\t\tuint16 shortv;\n\t\t\tCopyField(tag, shortv);\n\t\t} else if (count == 2) {\n\t\t\tuint16 shortv1, shortv2;\n\t\t\tCopyField2(tag, shortv1, shortv2);\n\t\t} else if (count == 4) {\n\t\t\tuint16 *tr, *tg, *tb, *ta;\n\t\t\tCopyField4(tag, tr, tg, tb, ta);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tuint16 shortv1;\n\t\t\tuint16* shortav;\n\t\t\tCopyField2(tag, shortv1, shortav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_LONG:\n\t\t{ uint32 longv;\n\t\t  CopyField(tag, longv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_RATIONAL:\n\t\tif (count == 1) {\n\t\t\tfloat floatv;\n\t\t\tCopyField(tag, floatv);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tfloat* floatav;\n\t\t\tCopyField(tag, floatav);\n\t\t}\n\t\tbreak;\n\tcase TIFF_ASCII:\n\t\t{ char* stringv;\n\t\t  CopyField(tag, stringv);\n\t\t}\n\t\tbreak;\n\tcase TIFF_DOUBLE:\n\t\tif (count == 1) {\n\t\t\tdouble doublev;\n\t\t\tCopyField(tag, doublev);\n\t\t} else if (count == (uint16) -1) {\n\t\t\tdouble* doubleav;\n\t\t\tCopyField(tag, doubleav);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Data type %d is not supported, tag %d skipped.\",\n\t\t    tag, type);\n\t}\n}",
          "fn_code_pos": [
            [
              493,
              0
            ],
            [
              546,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpTag",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF",
              "tag": "uint16",
              "count": "uint16",
              "type": "TIFFDataType"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ntiffcp(TIFF* in, TIFF* out)\n{\n\tuint16 bitspersample = 1, samplesperpixel = 1;\n\tuint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;\n\tcopyFunc cf;\n\tuint32 width, length;\n\tstruct cpTag* p;\n\n\tCopyField(TIFFTAG_IMAGEWIDTH, width);\n\tCopyField(TIFFTAG_IMAGELENGTH, length);\n\tCopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);\n\tCopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n\tif (compression != (uint16)-1)\n\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\telse\n\t\tCopyField(TIFFTAG_COMPRESSION, compression);\n\tTIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);\n\tTIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric);\n\tif (input_compression == COMPRESSION_JPEG) {\n\t\t/* Force conversion to RGB */\n\t\tTIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t} else if (input_photometric == PHOTOMETRIC_YCBCR) {\n\t\t/* Otherwise, can't handle subsampled input */\n\t\tuint16 subsamplinghor,subsamplingver;\n\n\t\tTIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,\n\t\t\t\t      &subsamplinghor, &subsamplingver);\n\t\tif (subsamplinghor!=1 || subsamplingver!=1) {\n\t\t\tfprintf(stderr, \"tiffcp: %s: Can't copy/convert subsampled image.\\n\",\n\t\t\t\tTIFFFileName(in));\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tif (compression == COMPRESSION_JPEG) {\n\t\tif (input_photometric == PHOTOMETRIC_RGB &&\n\t\t    jpegcolormode == JPEGCOLORMODE_RGB)\n\t\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\telse\n\t\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n\t}\n\telse if (compression == COMPRESSION_SGILOG\n\t    || compression == COMPRESSION_SGILOG24)\n\t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC,\n\t\t    samplesperpixel == 1 ?\n\t\t    PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);\n\telse if (input_compression == COMPRESSION_JPEG &&\n\t\t\t samplesperpixel == 3 ) {\n\t\t/* RGB conversion was forced above\n\t\thence the output will be of the same type */\n\t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n\t}\n\telse\n\t\tCopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);\n\tif (fillorder != 0)\n\t\tTIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n\telse\n\t\tCopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);\n\t/*\n\t * Will copy `Orientation' tag from input image\n\t */\n\tTIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n\tswitch (orientation) {\n\t\tcase ORIENTATION_BOTRIGHT:\n\t\tcase ORIENTATION_RIGHTBOT:\t/* XXX */\n\t\t\tTIFFWarning(TIFFFileName(in), \"using bottom-left orientation\");\n\t\t\torientation = ORIENTATION_BOTLEFT;\n\t\t/* fall through... */\n\t\tcase ORIENTATION_LEFTBOT:\t/* XXX */\n\t\tcase ORIENTATION_BOTLEFT:\n\t\t\tbreak;\n\t\tcase ORIENTATION_TOPRIGHT:\n\t\tcase ORIENTATION_RIGHTTOP:\t/* XXX */\n\t\tdefault:\n\t\t\tTIFFWarning(TIFFFileName(in), \"using top-left orientation\");\n\t\t\torientation = ORIENTATION_TOPLEFT;\n\t\t/* fall through... */\n\t\tcase ORIENTATION_LEFTTOP:\t/* XXX */\n\t\tcase ORIENTATION_TOPLEFT:\n\t\t\tbreak;\n\t}\n\tTIFFSetField(out, TIFFTAG_ORIENTATION, orientation);\n\t/*\n\t * Choose tiles/strip for the output image according to\n\t * the command line arguments (-tiles, -strips) and the\n\t * structure of the input image.\n\t */\n\tif (outtiled == -1)\n\t\touttiled = TIFFIsTiled(in);\n\tif (outtiled) {\n\t\t/*\n\t\t * Setup output file's tile width&height.  If either\n\t\t * is not specified, use either the value from the\n\t\t * input image or, if nothing is defined, use the\n\t\t * library default.\n\t\t */\n\t\tif (tilewidth == (uint32) -1)\n\t\t\tTIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\n\t\tif (tilelength == (uint32) -1)\n\t\t\tTIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\n\t\tTIFFDefaultTileSize(out, &tilewidth, &tilelength);\n\t\tTIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\n\t\tTIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\n\t} else {\n\t\t/*\n\t\t * RowsPerStrip is left unspecified: use either the\n\t\t * value from the input image or, if nothing is defined,\n\t\t * use the library default.\n\t\t */\n\t\tif (rowsperstrip == (uint32) 0) {\n\t\t\tif (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP,\n\t\t\t    &rowsperstrip)) {\n\t\t\t\trowsperstrip =\n\t\t\t\t    TIFFDefaultStripSize(out, rowsperstrip);\n\t\t\t}\n\t\t\tif (rowsperstrip > length && rowsperstrip != (uint32)-1)\n\t\t\t\trowsperstrip = length;\n\t\t}\n\t\telse if (rowsperstrip == (uint32) -1)\n\t\t\trowsperstrip = length;\n\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\t}\n\tif (config != (uint16) -1)\n\t\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n\telse\n\t\tCopyField(TIFFTAG_PLANARCONFIG, config);\n\tif (samplesperpixel <= 4)\n\t\tCopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);\n\tCopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);\n/* SMinSampleValue & SMaxSampleValue */\n\tswitch (compression) {\n\t\tcase COMPRESSION_JPEG:\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\t\tbreak;\n\t\tcase COMPRESSION_JBIG:\n\t\t\tCopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n\t\t\tCopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII);\n\t\t\tbreak;\n\t\tcase COMPRESSION_LZW:\n\t\tcase COMPRESSION_ADOBE_DEFLATE:\n\t\tcase COMPRESSION_DEFLATE:\n                case COMPRESSION_LZMA:\n                case COMPRESSION_ZSTD:\n\t\t\t\t\t\t\t\tcase COMPRESSION_WEBP:\n\t\t\tif (predictor != (uint16)-1)\n\t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\t\telse\n\t\t\t\tCopyField(TIFFTAG_PREDICTOR, predictor);\n\t\t\tif (preset != -1) {\n                                if (compression == COMPRESSION_ADOBE_DEFLATE\n                                         || compression == COMPRESSION_DEFLATE)\n                                        TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset);\n\t\t\t\telse if (compression == COMPRESSION_LZMA)\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_LZMAPRESET, preset);\n\t\t\t\telse if (compression == COMPRESSION_ZSTD)\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_ZSTD_LEVEL, preset);\n\t\t\t\telse if (compression == COMPRESSION_WEBP) {\n\t\t\t\t\tif (preset == 100) {\n\t\t\t\t\t\tTIFFSetField(out, TIFFTAG_WEBP_LOSSLESS, TRUE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tTIFFSetField(out, TIFFTAG_WEBP_LEVEL, preset);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n                        }\n\t\t\tbreak;\n\t\tcase COMPRESSION_CCITTFAX3:\n\t\tcase COMPRESSION_CCITTFAX4:\n\t\t\tif (compression == COMPRESSION_CCITTFAX3) {\n\t\t\t\tif (g3opts != (uint32) -1)\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_GROUP3OPTIONS,\n\t\t\t\t\t    g3opts);\n\t\t\t\telse\n\t\t\t\t\tCopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\n\t\t\t} else\n\t\t\t\tCopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n\t\t\tCopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n\t\t\tbreak;\n\t}\n\t{\n\t\tuint32 len32;\n\t\tvoid** data;\n\t\tif (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))\n\t\t\tTIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);\n\t}\n\t{\n\t\tuint16 ninks;\n\t\tconst char* inknames;\n\t\tif (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {\n\t\t\tTIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\n\t\t\tif (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {\n\t\t\t\tint inknameslen = strlen(inknames) + 1;\n\t\t\t\tconst char* cp = inknames;\n\t\t\t\twhile (ninks > 1) {\n\t\t\t\t\tcp = strchr(cp, '\\0');\n                                        cp++;\n                                        inknameslen += (strlen(cp) + 1);\n\t\t\t\t\tninks--;\n\t\t\t\t}\n\t\t\t\tTIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tunsigned short pg0, pg1;\n\n\t\tif (pageInSeq == 1) {\n\t\t\tif (pageNum < 0) /* only one input file */ {\n\t\t\t\tif (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n\t\t\t} else\n\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n\n\t\t} else {\n\t\t\tif (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {\n\t\t\t\tif (pageNum < 0) /* only one input file */\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n\t\t\t\telse\n\t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (p = tags; p < &tags[NTAGS]; p++)\n\t\tCopyTag(p->tag, p->count, p->type);\n\n\tcf = pickCopyFunc(in, out, bitspersample, samplesperpixel);\n\treturn (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE);\n}",
          "fn_code_pos": [
            [
              597,
              0
            ],
            [
              832,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiffcp",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpContig2ContigByRow)\n{\n\ttsize_t scanlinesize = TIFFScanlineSize(in);\n\ttdata_t buf;\n\tuint32 row;\n\n\tbuf = _TIFFmalloc(scanlinesize);\n\tif (!buf)\n\t\treturn 0;\n\t_TIFFmemset(buf, 0, scanlinesize);\n\t(void) imagewidth; (void) spp;\n\tfor (row = 0; row < imagelength; row++) {\n\t\tif (TIFFReadScanline(in, buf, row, 0) < 0 && !ignore) {\n\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t  \"Error, can't read scanline %lu\",\n\t\t\t\t  (unsigned long) row);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (TIFFWriteScanline(out, buf, row, 0) < 0) {\n\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t  \"Error, can't write scanline %lu\",\n\t\t\t\t  (unsigned long) row);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\t_TIFFfree(buf);\n\treturn 1;\nbad:\n\t_TIFFfree(buf);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              854,
              0
            ],
            [
              884,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static biasFn *lineSubtractFn (unsigned bits)\n{\n\tswitch (bits) {\n\t\tcase  8:  return subtract8;\n\t\tcase 16:  return subtract16;\n\t\tcase 32:  return subtract32;\n\t}\n\treturn NULL;\n}",
          "fn_code_pos": [
            [
              904,
              0
            ],
            [
              912,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lineSubtractFn",
            "parameters": {
              "bits": "unsigned"
            },
            "return_type": "biasFn"
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpBiasedContig2Contig)\n{\n\tif (spp == 1) {\n\t\ttsize_t biasSize = TIFFScanlineSize(bias);\n\t\ttsize_t bufSize = TIFFScanlineSize(in);\n\t\ttdata_t buf, biasBuf;\n\t\tuint32 biasWidth = 0, biasLength = 0;\n\t\tTIFFGetField(bias, TIFFTAG_IMAGEWIDTH, &biasWidth);\n\t\tTIFFGetField(bias, TIFFTAG_IMAGELENGTH, &biasLength);\n\t\tif (biasSize == bufSize &&\n\t\t    imagelength == biasLength && imagewidth == biasWidth) {\n\t\t\tuint16 sampleBits = 0;\n\t\t\tbiasFn *subtractLine;\n\t\t\tTIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &sampleBits);\n\t\t\tsubtractLine = lineSubtractFn (sampleBits);\n\t\t\tif (subtractLine) {\n\t\t\t\tuint32 row;\n\t\t\t\tbuf = _TIFFmalloc(bufSize);\n\t\t\t\tbiasBuf = _TIFFmalloc(bufSize);\n\t\t\t\tfor (row = 0; row < imagelength; row++) {\n\t\t\t\t\tif (TIFFReadScanline(in, buf, row, 0) < 0\n\t\t\t\t\t    && !ignore) {\n\t\t\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t\t\t    \"Error, can't read scanline %lu\",\n\t\t\t\t\t\t    (unsigned long) row);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tif (TIFFReadScanline(bias, biasBuf, row, 0) < 0\n\t\t\t\t\t    && !ignore) {\n\t\t\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t\t\t    \"Error, can't read biased scanline %lu\",\n\t\t\t\t\t\t    (unsigned long) row);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tsubtractLine (buf, biasBuf, imagewidth);\n\t\t\t\t\tif (TIFFWriteScanline(out, buf, row, 0) < 0) {\n\t\t\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t\t\t    \"Error, can't write scanline %lu\",\n\t\t\t\t\t\t    (unsigned long) row);\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t_TIFFfree(buf);\n\t\t\t\t_TIFFfree(biasBuf);\n\t\t\t\tTIFFSetDirectory(bias,\n\t\t\t\t    TIFFCurrentDirectory(bias)); /* rewind */\n\t\t\t\treturn 1;\nbad:\n\t\t\t\t_TIFFfree(buf);\n\t\t\t\t_TIFFfree(biasBuf);\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"No support for biasing %d bit pixels\\n\",\n\t\t\t\t    sampleBits);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Bias image %s,%d\\nis not the same size as %s,%d\\n\",\n\t\t    TIFFFileName(bias), TIFFCurrentDirectory(bias),\n\t\t    TIFFFileName(in), TIFFCurrentDirectory(in));\n\t\treturn 0;\n\t} else {\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Can't bias %s,%d as it has >1 Sample/Pixel\\n\",\n\t\t    TIFFFileName(in), TIFFCurrentDirectory(in));\n\t\treturn 0;\n\t}\n\n}",
          "fn_code_pos": [
            [
              917,
              0
            ],
            [
              988,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpDecodedStrips)\n{\n\ttsize_t stripsize  = TIFFStripSize(in);\n\ttdata_t buf = _TIFFmalloc(stripsize);\n\n\t(void) imagewidth; (void) spp;\n\tif (buf) {\n\t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n\t\tuint32 row = 0;\n\t\t_TIFFmemset(buf, 0, stripsize);\n\t\tfor (s = 0; s < ns && row < imagelength; s++) {\n\t\t\ttsize_t cc = (row + rowsperstrip > imagelength) ?\n\t\t\t    TIFFVStripSize(in, imagelength - row) : stripsize;\n\t\t\tif (TIFFReadEncodedStrip(in, s, buf, cc) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFWriteEncodedStrip(out, s, buf, cc) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\trow += rowsperstrip;\n\t\t}\n\t\t_TIFFfree(buf);\n\t\treturn 1;\n\t} else {\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Error, can't allocate memory buffer of size %lu \"\n\t\t    \"to read strips\", (unsigned long) stripsize);\n\t\treturn 0;\n\t}\n\nbad:\n\t_TIFFfree(buf);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              994,
              0
            ],
            [
              1034,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpSeparate2SeparateByRow)\n{\n\ttsize_t scanlinesize = TIFFScanlineSize(in);\n\ttdata_t buf;\n\tuint32 row;\n\ttsample_t s;\n\n\t(void) imagewidth;\n\tbuf = _TIFFmalloc(scanlinesize);\n\tif (!buf)\n\t\treturn 0;\n\t_TIFFmemset(buf, 0, scanlinesize);\n\tfor (s = 0; s < spp; s++) {\n\t\tfor (row = 0; row < imagelength; row++) {\n\t\t\tif (TIFFReadScanline(in, buf, row, s) < 0 && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read scanline %lu\",\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFWriteScanline(out, buf, row, s) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write scanline %lu\",\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\t_TIFFfree(buf);\n\treturn 1;\nbad:\n\t_TIFFfree(buf);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1039,
              0
            ],
            [
              1072,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpContig2SeparateByRow)\n{\n\ttsize_t scanlinesizein = TIFFScanlineSize(in);\n\ttsize_t scanlinesizeout = TIFFScanlineSize(out);\n\ttdata_t inbuf;\n\ttdata_t outbuf;\n\tregister uint8 *inp, *outp;\n\tregister uint32 n;\n\tuint32 row;\n\ttsample_t s;\n        uint16 bps = 0;\n\n        (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n        if( bps != 8 )\n        {\n            TIFFError(TIFFFileName(in),\n                      \"Error, can only handle BitsPerSample=8 in %s\",\n                      \"cpContig2SeparateByRow\");\n            return 0;\n        }\n\n\tinbuf = _TIFFmalloc(scanlinesizein);\n\toutbuf = _TIFFmalloc(scanlinesizeout);\n\tif (!inbuf || !outbuf)\n\t\tgoto bad;\n\t_TIFFmemset(inbuf, 0, scanlinesizein);\n\t_TIFFmemset(outbuf, 0, scanlinesizeout);\n\t/* unpack channels */\n\tfor (s = 0; s < spp; s++) {\n\t\tfor (row = 0; row < imagelength; row++) {\n\t\t\tif (TIFFReadScanline(in, inbuf, row, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read scanline %lu\",\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tinp = ((uint8*)inbuf) + s;\n\t\t\toutp = (uint8*)outbuf;\n\t\t\tfor (n = imagewidth; n-- > 0;) {\n\t\t\t\t*outp++ = *inp;\n\t\t\t\tinp += spp;\n\t\t\t}\n\t\t\tif (TIFFWriteScanline(out, outbuf, row, s) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write scanline %lu\",\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\tif (inbuf) _TIFFfree(inbuf);\n\tif (outbuf) _TIFFfree(outbuf);\n\treturn 1;\nbad:\n\tif (inbuf) _TIFFfree(inbuf);\n\tif (outbuf) _TIFFfree(outbuf);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1077,
              0
            ],
            [
              1135,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpSeparate2ContigByRow)\n{\n\ttsize_t scanlinesizein = TIFFScanlineSize(in);\n\ttsize_t scanlinesizeout = TIFFScanlineSize(out);\n\ttdata_t inbuf;\n\ttdata_t outbuf;\n\tregister uint8 *inp, *outp;\n\tregister uint32 n;\n\tuint32 row;\n\ttsample_t s;\n        uint16 bps = 0;\n\n        (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n        if( bps != 8 )\n        {\n            TIFFError(TIFFFileName(in),\n                      \"Error, can only handle BitsPerSample=8 in %s\",\n                      \"cpSeparate2ContigByRow\");\n            return 0;\n        }\n\n\tinbuf = _TIFFmalloc(scanlinesizein);\n\toutbuf = _TIFFmalloc(scanlinesizeout);\n\tif (!inbuf || !outbuf)\n                goto bad;\n\t_TIFFmemset(inbuf, 0, scanlinesizein);\n\t_TIFFmemset(outbuf, 0, scanlinesizeout);\n\tfor (row = 0; row < imagelength; row++) {\n\t\t/* merge channels */\n\t\tfor (s = 0; s < spp; s++) {\n\t\t\tif (TIFFReadScanline(in, inbuf, row, s) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read scanline %lu\",\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tinp = (uint8*)inbuf;\n\t\t\toutp = ((uint8*)outbuf) + s;\n\t\t\tfor (n = imagewidth; n-- > 0;) {\n\t\t\t\t*outp = *inp++;\n\t\t\t\toutp += spp;\n\t\t\t}\n\t\t}\n\t\tif (TIFFWriteScanline(out, outbuf, row, 0) < 0) {\n\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t    \"Error, can't write scanline %lu\",\n\t\t\t    (unsigned long) row);\n\t\t\tgoto bad;\n\t\t}\n\t}\n\tif (inbuf) _TIFFfree(inbuf);\n\tif (outbuf) _TIFFfree(outbuf);\n\treturn 1;\nbad:\n\tif (inbuf) _TIFFfree(inbuf);\n\tif (outbuf) _TIFFfree(outbuf);\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              1140,
              0
            ],
            [
              1198,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static void\ncpStripToTile(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int64 inskew)\n{\n\twhile (rows-- > 0) {\n\t\tuint32 j = cols;\n\t\twhile (j-- > 0)\n\t\t\t*out++ = *in++;\n\t\tout += outskew;\n\t\tin += inskew;\n\t}\n}",
          "fn_code_pos": [
            [
              1200,
              0
            ],
            [
              1211,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpStripToTile",
            "parameters": {
              "out": "uint8",
              "in": "uint8",
              "rows": "uint32",
              "cols": "uint32",
              "outskew": "int",
              "inskew": "int64"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ncpContigBufToSeparateBuf(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int inskew, tsample_t spp,\n    int bytes_per_sample )\n{\n\twhile (rows-- > 0) {\n\t\tuint32 j = cols;\n\t\twhile (j-- > 0)\n\t\t{\n\t\t\tint n = bytes_per_sample;\n\n\t\t\twhile( n-- ) {\n\t\t\t\t*out++ = *in++;\n\t\t\t}\n\t\t\tin += (spp-1) * bytes_per_sample;\n\t\t}\n\t\tout += outskew;\n\t\tin += inskew;\n\t}\n}",
          "fn_code_pos": [
            [
              1213,
              0
            ],
            [
              1232,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpContigBufToSeparateBuf",
            "parameters": {
              "out": "uint8",
              "in": "uint8",
              "rows": "uint32",
              "cols": "uint32",
              "outskew": "int",
              "inskew": "int",
              "spp": "tsample_t",
              "bytes_per_sample": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ncpSeparateBufToContigBuf(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int inskew, tsample_t spp,\n    int bytes_per_sample)\n{\n\twhile (rows-- > 0) {\n\t\tuint32 j = cols;\n\t\twhile (j-- > 0) {\n\t\t\tint n = bytes_per_sample;\n\n\t\t\twhile( n-- ) {\n\t\t\t\t*out++ = *in++;\n\t\t\t}\n\t\t\tout += (spp-1)*bytes_per_sample;\n\t\t}\n\t\tout += outskew;\n\t\tin += inskew;\n\t}\n}",
          "fn_code_pos": [
            [
              1234,
              0
            ],
            [
              1252,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpSeparateBufToContigBuf",
            "parameters": {
              "out": "uint8",
              "in": "uint8",
              "rows": "uint32",
              "cols": "uint32",
              "outskew": "int",
              "inskew": "int",
              "spp": "tsample_t",
              "bytes_per_sample": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ncpImage(TIFF* in, TIFF* out, readFunc fin, writeFunc fout,\n\tuint32 imagelength, uint32 imagewidth, tsample_t spp)\n{\n\tint status = 0;\n\ttdata_t buf = NULL;\n\ttsize_t scanlinesize = TIFFRasterScanlineSize(in);\n\ttsize_t bytes = scanlinesize * (tsize_t)imagelength;\n\t/*\n\t * XXX: Check for integer overflow.\n\t */\n\tif (scanlinesize\n\t    && imagelength\n\t    && bytes / (tsize_t)imagelength == scanlinesize) {\n\t\tbuf = _TIFFmalloc(bytes);\n\t\tif (buf) {\n\t\t\tif ((*fin)(in, (uint8*)buf, imagelength,\n\t\t\t    imagewidth, spp)) {\n\t\t\t\tstatus = (*fout)(out, (uint8*)buf,\n\t\t\t\t    imagelength, imagewidth, spp);\n\t\t\t}\n\t\t\t_TIFFfree(buf);\n\t\t} else {\n\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t    \"Error, can't allocate space for image buffer\");\n\t\t}\n\t} else {\n\t\tTIFFError(TIFFFileName(in), \"Error, no space for image buffer\");\n\t}\n\n\treturn status;\n}",
          "fn_code_pos": [
            [
              1254,
              0
            ],
            [
              1285,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cpImage",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF",
              "fin": "readFunc",
              "fout": "writeFunc",
              "imagelength": "uint32",
              "imagewidth": "uint32",
              "spp": "tsample_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "DECLAREreadFunc(readContigStripsIntoBuffer)\n{\n\ttsize_t scanlinesize = TIFFScanlineSize(in);\n\tuint8* bufp = buf;\n\tuint32 row;\n\n\t(void) imagewidth; (void) spp;\n\tfor (row = 0; row < imagelength; row++) {\n\t\tif (TIFFReadScanline(in, (tdata_t) bufp, row, 0) < 0\n\t\t    && !ignore) {\n\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t    \"Error, can't read scanline %lu\",\n\t\t\t    (unsigned long) row);\n\t\t\treturn 0;\n\t\t}\n\t\tbufp += scanlinesize;\n\t}\n\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              1287,
              0
            ],
            [
              1306,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREreadFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREreadFunc(readSeparateStripsIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t scanlinesize = TIFFScanlineSize(in);\n\ttdata_t scanline;\n\tif (!scanlinesize)\n\t\treturn 0;\n\n\tscanline = _TIFFmalloc(scanlinesize);\n\tif (!scanline)\n\t\treturn 0;\n\t_TIFFmemset(scanline, 0, scanlinesize);\n\t(void) imagewidth;\n\tif (scanline) {\n\t\tuint8* bufp = (uint8*) buf;\n\t\tuint32 row;\n\t\ttsample_t s;\n\t\tfor (row = 0; row < imagelength; row++) {\n\t\t\t/* merge channels */\n\t\t\tfor (s = 0; s < spp; s++) {\n\t\t\t\tuint8* bp = bufp + s;\n\t\t\t\ttsize_t n = scanlinesize;\n\t\t\t\tuint8* sbuf = scanline;\n\n\t\t\t\tif (TIFFReadScanline(in, scanline, row, s) < 0\n\t\t\t\t    && !ignore) {\n\t\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t\t    \"Error, can't read scanline %lu\",\n\t\t\t\t\t    (unsigned long) row);\n\t\t\t\t\t    status = 0;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\twhile (n-- > 0)\n\t\t\t\t\t*bp = *sbuf++, bp += spp;\n\t\t\t}\n\t\t\tbufp += scanlinesize * spp;\n\t\t}\n\t}\n\ndone:\n\t_TIFFfree(scanline);\n\treturn status;\n}",
          "fn_code_pos": [
            [
              1308,
              0
            ],
            [
              1350,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREreadFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint64 iskew = (int64)imagew - (int64)tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n        \n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb > iskew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}",
          "fn_code_pos": [
            [
              1352,
              0
            ],
            [
              1404,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREreadFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREreadFunc(readSeparateTilesIntoBuffer)\n{\n\tint status = 1;\n\tuint32 imagew = TIFFRasterScanlineSize(in);\n\tuint32 tilew = TIFFTileRowSize(in);\n\tint iskew;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\tuint16 bps = 0, bytes_per_sample;\n\n\tif (spp > (INT_MAX / tilew))\n\t{\n\t\tTIFFError(TIFFFileName(in), \"Error, cannot handle that much samples per tile row (Tile Width * Samples/Pixel)\");\n\t\treturn 0;\n\t}\n\tiskew = imagew - tilew*spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n        if( bps == 0 )\n        {\n            TIFFError(TIFFFileName(in), \"Error, cannot read BitsPerSample\");\n            status = 0;\n            goto done;\n        }\n        if( (bps % 8) != 0 )\n        {\n            TIFFError(TIFFFileName(in), \"Error, cannot handle BitsPerSample that is not a multiple of 8\");\n            status = 0;\n            goto done;\n        }\n\tbytes_per_sample = bps/8;\n\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\ttsample_t s;\n\n\t\t\tfor (s = 0; s < spp; s++) {\n\t\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, s) < 0\n\t\t\t\t    && !ignore) {\n\t\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t\t    \"Error, can't read tile at %lu %lu, \"\n\t\t\t\t\t    \"sample %lu\",\n\t\t\t\t\t    (unsigned long) col,\n\t\t\t\t\t    (unsigned long) row,\n\t\t\t\t\t    (unsigned long) s);\n\t\t\t\t\tstatus = 0;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Tile is clipped horizontally.  Calculate\n\t\t\t\t * visible portion and skewing factors.\n\t\t\t\t */\n\t\t\t\tif (colb + tilew*spp > imagew) {\n\t\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\t\tint oskew = tilew*spp - width;\n\t\t\t\t\tcpSeparateBufToContigBuf(\n\t\t\t\t\t    bufp+colb+s*bytes_per_sample,\n\t\t\t\t\t    tilebuf, nrow,\n\t\t\t\t\t    width/(spp*bytes_per_sample),\n\t\t\t\t\t    oskew + iskew,\n\t\t\t\t\t    oskew/spp, spp,\n\t\t\t\t\t    bytes_per_sample);\n\t\t\t\t} else\n\t\t\t\t\tcpSeparateBufToContigBuf(\n\t\t\t\t\t    bufp+colb+s*bytes_per_sample,\n\t\t\t\t\t    tilebuf, nrow, tw,\n\t\t\t\t\t    iskew, 0, spp,\n\t\t\t\t\t    bytes_per_sample);\n\t\t\t}\n\t\t\tcolb += tilew*spp;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}",
          "fn_code_pos": [
            [
              1406,
              0
            ],
            [
              1494,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREreadFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREwriteFunc(writeBufferToContigStrips)\n{\n\tuint32 row, rowsperstrip;\n\ttstrip_t strip = 0;\n\n\t(void) imagewidth; (void) spp;\n\t(void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\tfor (row = 0; row < imagelength; row += rowsperstrip) {\n\t\tuint32 nrows = (row+rowsperstrip > imagelength) ?\n\t\t    imagelength-row : rowsperstrip;\n\t\ttsize_t stripsize = TIFFVStripSize(out, nrows);\n\t\tif (TIFFWriteEncodedStrip(out, strip++, buf, stripsize) < 0) {\n\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t    \"Error, can't write strip %u\", strip - 1);\n\t\t\treturn 0;\n\t\t}\n\t\tbuf += stripsize;\n\t}\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              1496,
              0
            ],
            [
              1515,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREwriteFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREwriteFunc(writeBufferToSeparateStrips)\n{\n\tuint32 rowsize = imagewidth * spp;\n\tuint32 rowsperstrip;\n\ttsize_t stripsize = TIFFStripSize(out);\n\ttdata_t obuf;\n\ttstrip_t strip = 0;\n\ttsample_t s;\n\n\tobuf = _TIFFmalloc(stripsize);\n\tif (obuf == NULL)\n\t\treturn (0);\n\t_TIFFmemset(obuf, 0, stripsize);\n\t(void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\tfor (s = 0; s < spp; s++) {\n\t\tuint32 row;\n\t\tfor (row = 0; row < imagelength; row += rowsperstrip) {\n\t\t\tuint32 nrows = (row+rowsperstrip > imagelength) ?\n\t\t\t    imagelength-row : rowsperstrip;\n\t\t\ttsize_t stripsize = TIFFVStripSize(out, nrows);\n\n\t\t\tcpContigBufToSeparateBuf(\n\t\t\t    obuf, (uint8*) buf + row*rowsize + s,\n\t\t\t    nrows, imagewidth, 0, 0, spp, 1);\n\t\t\tif (TIFFWriteEncodedStrip(out, strip++, obuf, stripsize) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write strip %u\",\n\t\t\t\t    strip - 1);\n\t\t\t\t_TIFFfree(obuf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t_TIFFfree(obuf);\n\treturn 1;\n\n}",
          "fn_code_pos": [
            [
              1517,
              0
            ],
            [
              1553,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREwriteFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREwriteFunc(writeBufferToContigTiles)\n{\n\tuint32 imagew = TIFFScanlineSize(out);\n\tuint32 tilew  = TIFFTileRowSize(out);\n\tint iskew = imagew - tilew;\n\ttsize_t tilesize = TIFFTileSize(out);\n\ttdata_t obuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tl, tw;\n\tuint32 row;\n\n\t(void) spp;\n\n\tobuf = _TIFFmalloc(TIFFTileSize(out));\n\tif (obuf == NULL)\n\t\treturn 0;\n\t_TIFFmemset(obuf, 0, tilesize);\n\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n\tfor (row = 0; row < imagelength; row += tilelength) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\t/*\n\t\t\t * Tile is clipped horizontally.  Calculate\n\t\t\t * visible portion and skewing factors.\n\t\t\t */\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tint oskew = tilew - width;\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, width,\n\t\t\t\t    oskew, oskew + iskew);\n\t\t\t} else\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, tilew,\n\t\t\t\t    0, iskew);\n\t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\t_TIFFfree(obuf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += nrow * imagew;\n\t}\n\t_TIFFfree(obuf);\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              1555,
              0
            ],
            [
              1606,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREwriteFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREwriteFunc(writeBufferToSeparateTiles)\n{\n\tuint32 imagew = TIFFScanlineSize(out);\n\ttsize_t tilew  = TIFFTileRowSize(out);\n\tuint32 iimagew = TIFFRasterScanlineSize(out);\n\tint iskew = iimagew - tilew*spp;\n\ttsize_t tilesize = TIFFTileSize(out);\n\ttdata_t obuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tl, tw;\n\tuint32 row;\n\tuint16 bps = 0, bytes_per_sample;\n\n\tobuf = _TIFFmalloc(TIFFTileSize(out));\n\tif (obuf == NULL)\n\t\treturn 0;\n\t_TIFFmemset(obuf, 0, tilesize);\n\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);\n        if( bps == 0 )\n        {\n            TIFFError(TIFFFileName(out), \"Error, cannot read BitsPerSample\");\n            _TIFFfree(obuf);\n            return 0;\n        }\n        if( (bps % 8) != 0 )\n        {\n            TIFFError(TIFFFileName(out), \"Error, cannot handle BitsPerSample that is not a multiple of 8\");\n            _TIFFfree(obuf);\n            return 0;\n        }\n\tbytes_per_sample = bps/8;\n\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\ttsample_t s;\n\t\t\tfor (s = 0; s < spp; s++) {\n\t\t\t\t/*\n\t\t\t\t * Tile is clipped horizontally.  Calculate\n\t\t\t\t * visible portion and skewing factors.\n\t\t\t\t */\n\t\t\t\tif (colb + tilew > imagew) {\n\t\t\t\t\tuint32 width = (imagew - colb);\n\t\t\t\t\tint oskew = tilew - width;\n\n\t\t\t\t\tcpContigBufToSeparateBuf(obuf,\n\t\t\t\t\t    bufp + (colb*spp) + s,\n\t\t\t\t\t    nrow, width/bytes_per_sample,\n\t\t\t\t\t    oskew, (oskew*spp)+iskew, spp,\n\t\t\t\t\t    bytes_per_sample);\n\t\t\t\t} else\n\t\t\t\t\tcpContigBufToSeparateBuf(obuf,\n\t\t\t\t\t    bufp + (colb*spp) + s,\n\t\t\t\t\t    nrow, tilewidth,\n\t\t\t\t\t    0, iskew, spp,\n\t\t\t\t\t    bytes_per_sample);\n\t\t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, s) < 0) {\n\t\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t\t    \"Error, can't write tile at %lu %lu \"\n\t\t\t\t\t    \"sample %lu\",\n\t\t\t\t\t    (unsigned long) col,\n\t\t\t\t\t    (unsigned long) row,\n\t\t\t\t\t    (unsigned long) s);\n\t\t\t\t\t_TIFFfree(obuf);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += nrow * iimagew;\n\t}\n\t_TIFFfree(obuf);\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              1608,
              0
            ],
            [
              1686,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREwriteFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpContigStrips2ContigTiles)\n{\n\treturn cpImage(in, out,\n\t    readContigStripsIntoBuffer,\n\t    writeBufferToContigTiles,\n\t    imagelength, imagewidth, spp);\n}",
          "fn_code_pos": [
            [
              1691,
              0
            ],
            [
              1697,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpContigStrips2SeparateTiles)\n{\n\treturn cpImage(in, out,\n\t    readContigStripsIntoBuffer,\n\t    writeBufferToSeparateTiles,\n\t    imagelength, imagewidth, spp);\n}",
          "fn_code_pos": [
            [
              1702,
              0
            ],
            [
              1708,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpSeparateStrips2ContigTiles)\n{\n\treturn cpImage(in, out,\n\t    readSeparateStripsIntoBuffer,\n\t    writeBufferToContigTiles,\n\t    imagelength, imagewidth, spp);\n}",
          "fn_code_pos": [
            [
              1713,
              0
            ],
            [
              1719,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpSeparateStrips2SeparateTiles)\n{\n\treturn cpImage(in, out,\n\t    readSeparateStripsIntoBuffer,\n\t    writeBufferToSeparateTiles,\n\t    imagelength, imagewidth, spp);\n}",
          "fn_code_pos": [
            [
              1724,
              0
            ],
            [
              1730,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpContigTiles2ContigTiles)\n{\n\treturn cpImage(in, out,\n\t    readContigTilesIntoBuffer,\n\t    writeBufferToContigTiles,\n\t    imagelength, imagewidth, spp);\n}",
          "fn_code_pos": [
            [
              1735,
              0
            ],
            [
              1741,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpContigTiles2SeparateTiles)\n{\n\treturn cpImage(in, out,\n\t    readContigTilesIntoBuffer,\n\t    writeBufferToSeparateTiles,\n\t    imagelength, imagewidth, spp);\n}",
          "fn_code_pos": [
            [
              1746,
              0
            ],
            [
              1752,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpSeparateTiles2ContigTiles)\n{\n\treturn cpImage(in, out,\n\t    readSeparateTilesIntoBuffer,\n\t    writeBufferToContigTiles,\n\t    imagelength, imagewidth, spp);\n}",
          "fn_code_pos": [
            [
              1757,
              0
            ],
            [
              1763,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpSeparateTiles2SeparateTiles)\n{\n\treturn cpImage(in, out,\n\t    readSeparateTilesIntoBuffer,\n\t    writeBufferToSeparateTiles,\n\t    imagelength, imagewidth, spp);\n}",
          "fn_code_pos": [
            [
              1768,
              0
            ],
            [
              1774,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpContigTiles2ContigStrips)\n{\n\treturn cpImage(in, out,\n\t    readContigTilesIntoBuffer,\n\t    writeBufferToContigStrips,\n\t    imagelength, imagewidth, spp);\n}",
          "fn_code_pos": [
            [
              1779,
              0
            ],
            [
              1785,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpContigTiles2SeparateStrips)\n{\n\treturn cpImage(in, out,\n\t    readContigTilesIntoBuffer,\n\t    writeBufferToSeparateStrips,\n\t    imagelength, imagewidth, spp);\n}",
          "fn_code_pos": [
            [
              1790,
              0
            ],
            [
              1796,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpSeparateTiles2ContigStrips)\n{\n\treturn cpImage(in, out,\n\t    readSeparateTilesIntoBuffer,\n\t    writeBufferToContigStrips,\n\t    imagelength, imagewidth, spp);\n}",
          "fn_code_pos": [
            [
              1801,
              0
            ],
            [
              1807,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "DECLAREcpFunc(cpSeparateTiles2SeparateStrips)\n{\n\treturn cpImage(in, out,\n\t    readSeparateTilesIntoBuffer,\n\t    writeBufferToSeparateStrips,\n\t    imagelength, imagewidth, spp);\n}",
          "fn_code_pos": [
            [
              1812,
              0
            ],
            [
              1818,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "DECLAREcpFunc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "static copyFunc\npickCopyFunc(TIFF* in, TIFF* out, uint16 bitspersample, uint16 samplesperpixel)\n{\n\tuint16 shortv;\n\tuint32 w, l, tw, tl;\n\tint bychunk;\n\n\t(void) TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &shortv);\n\tif (shortv != config && bitspersample != 8 && samplesperpixel > 1) {\n\t\tfprintf(stderr,\n\t\t    \"%s: Cannot handle different planar configuration w/ bits/sample != 8\\n\",\n\t\t    TIFFFileName(in));\n\t\treturn (NULL);\n\t}\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &l);\n\tif (!(TIFFIsTiled(out) || TIFFIsTiled(in))) {\n\t\tuint32 irps = (uint32) -1L;\n\t\tTIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &irps);\n\t\t/* if biased, force decoded copying to allow image subtraction */\n\t\tbychunk = !bias && (rowsperstrip == irps);\n\t}else{  /* either in or out is tiled */\n\t\tif (bias) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: Cannot handle tiled configuration w/bias image\\n\",\n\t\t\tTIFFFileName(in));\n\t\t\treturn (NULL);\n\t\t}\n\t\tif (TIFFIsTiled(out)) {\n\t\t\tif (!TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw))\n\t\t\t\ttw = w;\n\t\t\tif (!TIFFGetField(in, TIFFTAG_TILELENGTH, &tl))\n\t\t\t\ttl = l;\n\t\t\tbychunk = (tw == tilewidth && tl == tilelength);\n\t\t} else {  /* out's not, so in must be tiled */\n\t\t\tTIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t\t\tTIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\t\t\tbychunk = (tw == w && tl == rowsperstrip);\n\t\t}\n\t}\n#define\tT 1\n#define\tF 0\n#define pack(a,b,c,d,e)\t((long)(((a)<<11)|((b)<<3)|((c)<<2)|((d)<<1)|(e)))\n\tswitch(pack(shortv,config,TIFFIsTiled(in),TIFFIsTiled(out),bychunk)) {\n\t\t/* Strips -> Tiles */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,T,T):\n\t\t\treturn cpContigStrips2ContigTiles;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, F,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, F,T,T):\n\t\t\treturn cpContigStrips2SeparateTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,T,T):\n\t\t\treturn cpSeparateStrips2ContigTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,T,T):\n\t\t\treturn cpSeparateStrips2SeparateTiles;\n\t\t/* Tiles -> Tiles */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,T,T):\n\t\t\treturn cpContigTiles2ContigTiles;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,T,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,T,T):\n\t\t\treturn cpContigTiles2SeparateTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,T,T):\n\t\t\treturn cpSeparateTiles2ContigTiles;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,T,T):\n\t\t\treturn cpSeparateTiles2SeparateTiles;\n\t\t/* Tiles -> Strips */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   T,F,T):\n\t\t\treturn cpContigTiles2ContigStrips;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_SEPARATE, T,F,T):\n\t\t\treturn cpContigTiles2SeparateStrips;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   T,F,T):\n\t\t\treturn cpSeparateTiles2ContigStrips;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, T,F,T):\n\t\t\treturn cpSeparateTiles2SeparateStrips;\n\t\t/* Strips -> Strips */\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,F,F):\n\t\t\treturn bias ? cpBiasedContig2Contig : cpContig2ContigByRow;\n\t\tcase pack(PLANARCONFIG_CONTIG,   PLANARCONFIG_CONTIG,   F,F,T):\n\t\t\treturn cpDecodedStrips;\n\t\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE,   F,F,F):\n\t\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE,   F,F,T):\n\t\t\treturn cpContig2SeparateByRow;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG,   F,F,T):\n\t\t\treturn cpSeparate2ContigByRow;\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,F):\n\t\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE, F,F,T):\n\t\t\treturn cpSeparate2SeparateByRow;\n\t}\n#undef pack\n#undef F\n#undef T\n\tfprintf(stderr, \"tiffcp: %s: Don't know how to copy/convert image.\\n\",\n\t    TIFFFileName(in));\n\treturn (NULL);\n}",
          "fn_code_pos": [
            [
              1823,
              0
            ],
            [
              1927,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pickCopyFunc",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF",
              "bitspersample": "uint16",
              "samplesperpixel": "uint16"
            },
            "return_type": "copyFunc"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "getopt(int, char**, char*)",
          "fn_dec_pos": [
            [
              54,
              11
            ],
            [
              54,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "tiffcp(TIFF*, TIFF*)",
          "fn_dec_pos": [
            [
              87,
              11
            ],
            [
              87,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiffcp",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "processCompressOptions(char*)",
          "fn_dec_pos": [
            [
              88,
              11
            ],
            [
              88,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              89,
              12
            ],
            [
              89,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "openSrcImage (char **imageSpec)",
          "fn_dec_pos": [
            [
              127,
              13
            ],
            [
              127,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "openSrcImage",
            "parameters": {
              "imageSpec": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*copyFunc)\n    (TIFF* in, TIFF* out, uint32 l, uint32 w, uint16 samplesperpixel)",
          "fn_dec_pos": [
            [
              591,
              12
            ],
            [
              592,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "in": "TIFF",
              "out": "TIFF",
              "l": "uint32",
              "w": "uint32",
              "samplesperpixel": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "pickCopyFunc(TIFF*, TIFF*, uint16, uint16)",
          "fn_dec_pos": [
            [
              593,
              16
            ],
            [
              593,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "pickCopyFunc",
            "parameters": {},
            "return_type": "copyFunc"
          }
        },
        {
          "fn_code": "(*readFunc)(TIFF*, uint8*, uint32, uint32, tsample_t)",
          "fn_dec_pos": [
            [
              844,
              12
            ],
            [
              844,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*writeFunc)(TIFF*, uint8*, uint32, uint32, tsample_t)",
          "fn_dec_pos": [
            [
              849,
              12
            ],
            [
              849,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "biasFn (void *image, void *bias, uint32 pixels)",
          "fn_dec_pos": [
            [
              887,
              13
            ],
            [
              887,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "image": "void",
              "bias": "void",
              "pixels": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "lineSubtractFn (unsigned bits)",
          "fn_dec_pos": [
            [
              904,
              15
            ],
            [
              904,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lineSubtractFn",
            "parameters": {
              "bits": "unsigned"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct cpTag {\n\tuint16 tag;\n\tuint16 count;\n\tTIFFDataType type;\n}",
          {
            "tag": "uint16",
            "count": "uint16",
            "type": "TIFFDataType"
          },
          "cpTag",
          [
            548,
            7
          ],
          [
            552,
            1
          ]
        ],
        [
          "struct cpTag {\n\tuint16 tag;\n\tuint16 count;\n\tTIFFDataType type;\n}",
          {
            "tag": "uint16",
            "count": "uint16",
            "type": "TIFFDataType"
          },
          "cpTag",
          [
            548,
            7
          ],
          [
            552,
            1
          ]
        ],
        [
          "struct cpTag",
          {},
          "",
          [
            604,
            1
          ],
          [
            604,
            13
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            42,
            0
          ],
          [
            43,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/tiffdump.c": {
      "fn_def_list": [
        {
          "fn_code": "void\nusage()\n{\n\tfprintf(stderr, \"usage: %s [-h] [-o offset] [-m maxitems] file.tif ...\\n\", appname);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              103,
              0
            ],
            [
              108,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tint one = 1, fd;\n\tint multiplefiles = (argc > 1);\n\tint c;\n\tuint64 diroff = 0;\n\tbigendian = (*(char *)&one == 0);\n\n\tappname = argv[0];\n\twhile ((c = getopt(argc, argv, \"m:o:h\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'h':\t\t\t/* print values in hex */\n\t\t\tshortfmt = \"%s%#x\";\n\t\t\tsshortfmt = \"%s%#x\";\n\t\t\tlongfmt = \"%s%#lx\";\n\t\t\tslongfmt = \"%s%#lx\";\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tdiroff = (uint64) strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tmaxitems = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tif (optind >= argc)\n\t\tusage();\n\tfor (; optind < argc; optind++) {\n\t\tfd = open(argv[optind], O_RDONLY|O_BINARY, 0);\n\t\tif (fd < 0) {\n\t\t\tperror(argv[0]);\n\t\t\treturn (-1);\n\t\t}\n\t\tif (multiplefiles)\n\t\t\tprintf(\"%s:\\n\", argv[optind]);\n\t\tcurfile = argv[optind];\n\t\tswabflag = 0;\n\t\tbigtiff = 0;\n\t\tdump(fd, diroff);\n\t\tclose(fd);\n\t}\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              110,
              0
            ],
            [
              155,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\ndump(int fd, uint64 diroff)\n{\n\tunsigned i, j;\n\tuint64* visited_diroff = NULL;\n\tunsigned int count_visited_dir = 0;\n\n\t_TIFF_lseek_f(fd, (_TIFF_off_t) 0, 0);\n\tif (read(fd, (char*) &hdr, sizeof (TIFFHeaderCommon)) != sizeof (TIFFHeaderCommon))\n\t\tReadError(\"TIFF header\");\n\tif (hdr.common.tiff_magic != TIFF_BIGENDIAN\n\t    && hdr.common.tiff_magic != TIFF_LITTLEENDIAN &&\n#if HOST_BIGENDIAN\n\t    /* MDI is sensitive to the host byte order, unlike TIFF */\n\t    MDI_BIGENDIAN != hdr.common.tiff_magic\n#else\n\t    MDI_LITTLEENDIAN != hdr.common.tiff_magic\n#endif\n\t   ) {\n\t\tFatal(\"Not a TIFF or MDI file, bad magic number %u (%#x)\",\n\t\t    hdr.common.tiff_magic, hdr.common.tiff_magic);\n\t}\n\tif (hdr.common.tiff_magic == TIFF_BIGENDIAN\n\t    || hdr.common.tiff_magic == MDI_BIGENDIAN)\n\t\tswabflag = !bigendian;\n\telse\n\t\tswabflag = bigendian;\n\tif (swabflag)\n\t\tTIFFSwabShort(&hdr.common.tiff_version);\n\tif (hdr.common.tiff_version==42)\n\t{\n\t\tif (read(fd, (char*) &hdr.classic.tiff_diroff, 4) != 4)\n\t\t\tReadError(\"TIFF header\");\n\t\tif (swabflag)\n\t\t\tTIFFSwabLong(&hdr.classic.tiff_diroff);\n\t\tprintf(\"Magic: %#x <%s-endian> Version: %#x <%s>\\n\",\n\t\t    hdr.classic.tiff_magic,\n\t\t    hdr.classic.tiff_magic == TIFF_BIGENDIAN ? \"big\" : \"little\",\n\t\t    42,\"ClassicTIFF\");\n\t\tif (diroff == 0)\n\t\t\tdiroff = hdr.classic.tiff_diroff;\n\t}\n\telse if (hdr.common.tiff_version==43)\n\t{\n\t\tif (read(fd, (char*) &hdr.big.tiff_offsetsize, 12) != 12)\n\t\t\tReadError(\"TIFF header\");\n\t\tif (swabflag)\n\t\t{\n\t\t\tTIFFSwabShort(&hdr.big.tiff_offsetsize);\n\t\t\tTIFFSwabShort(&hdr.big.tiff_unused);\n\t\t\tTIFFSwabLong8(&hdr.big.tiff_diroff);\n\t\t}\n\t\tprintf(\"Magic: %#x <%s-endian> Version: %#x <%s>\\n\",\n\t\t    hdr.big.tiff_magic,\n\t\t    hdr.big.tiff_magic == TIFF_BIGENDIAN ? \"big\" : \"little\",\n\t\t    43,\"BigTIFF\");\n\t\tprintf(\"OffsetSize: %#x Unused: %#x\\n\",\n\t\t    hdr.big.tiff_offsetsize,hdr.big.tiff_unused);\n\t\tif (diroff == 0)\n\t\t\tdiroff = hdr.big.tiff_diroff;\n\t\tbigtiff = 1;\n\t}\n\telse\n\t\tFatal(\"Not a TIFF file, bad version number %u (%#x)\",\n\t\t    hdr.common.tiff_version, hdr.common.tiff_version);\n\tfor (i = 0; diroff != 0; i++) {\n\t\tfor(j=0; j<count_visited_dir; j++)\n\t\t{\n\t\t    if( visited_diroff[j] == diroff )\n\t\t    {\n\t\t\tfree(visited_diroff);\n\t\t\tFatal(\"Cycle detected in chaining of TIFF directories!\");\n\t\t    }\n\t\t}\n                {\n                    size_t alloc_size;\n                    alloc_size=TIFFSafeMultiply(tmsize_t,(count_visited_dir + 1),\n                                                sizeof(uint64));\n                    if (alloc_size == 0)\n                    {\n                        if (visited_diroff)\n                            free(visited_diroff);\n                        visited_diroff = 0;\n                    }\n                    else\n                    {\n                        visited_diroff = (uint64*) realloc(visited_diroff,alloc_size);\n                    }\n                }\n\t\tif( !visited_diroff )\n\t\t    Fatal(\"Out of memory\");\n\t\tvisited_diroff[count_visited_dir] = diroff;\n\t\tcount_visited_dir ++;\n\n\t\tif (i > 0)\n\t\t\tputchar('\\n');\n\t\tdiroff = ReadDirectory(fd, i, diroff);\n\t}\n\tif( visited_diroff )\n\t    free(visited_diroff);\n}",
          "fn_code_pos": [
            [
              164,
              0
            ],
            [
              264,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump",
            "parameters": {
              "fd": "int",
              "diroff": "uint64"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static uint64\nReadDirectory(int fd, unsigned int ix, uint64 off)\n{\n\tuint16 dircount;\n\tuint32 direntrysize;\n\tvoid* dirmem = NULL;\n\tuint64 nextdiroff = 0;\n\tuint32 n;\n\tuint8* dp;\n\n\tif (off == 0)\t\t\t/* no more directories */\n\t\tgoto done;\n\tif (_TIFF_lseek_f(fd, (_TIFF_off_t)off, SEEK_SET) != (_TIFF_off_t)off) {\n\t\tFatal(\"Seek error accessing TIFF directory\");\n\t\tgoto done;\n\t}\n\tif (!bigtiff) {\n\t\tif (read(fd, (char*) &dircount, sizeof (uint16)) != sizeof (uint16)) {\n\t\t\tReadError(\"directory count\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (swabflag)\n\t\t\tTIFFSwabShort(&dircount);\n\t\tdirentrysize = 12;\n\t} else {\n\t\tuint64 dircount64 = 0;\n\t\tif (read(fd, (char*) &dircount64, sizeof (uint64)) != sizeof (uint64)) {\n\t\t\tReadError(\"directory count\");\n\t\t\tgoto done;\n\t\t}\n\t\tif (swabflag)\n\t\t\tTIFFSwabLong8(&dircount64);\n\t\tif (dircount64>0xFFFF) {\n\t\t\tError(\"Sanity check on directory count failed\");\n\t\t\tgoto done;\n\t\t}\n\t\tdircount = (uint16)dircount64;\n\t\tdirentrysize = 20;\n\t}\n\tdirmem = _TIFFmalloc(TIFFSafeMultiply(tmsize_t,dircount,direntrysize));\n\tif (dirmem == NULL) {\n\t\tFatal(\"No space for TIFF directory\");\n\t\tgoto done;\n\t}\n\tn = read(fd, (char*) dirmem, dircount*direntrysize);\n\tif (n != dircount*direntrysize) {\n\t\tn /= direntrysize;\n\t\tError(\n#if defined(__WIN32__) && defined(_MSC_VER)\n\t    \"Could only read %lu of %u entries in directory at offset %#I64x\",\n\t\t      (unsigned long)n, dircount, (unsigned __int64) off);\n#else\n\t    \"Could only read %lu of %u entries in directory at offset %#llx\",\n\t\t      (unsigned long)n, dircount, (unsigned long long) off);\n#endif\n\t\tdircount = n;\n\t\tnextdiroff = 0;\n\t} else {\n\t\tif (!bigtiff) {\n\t\t\tuint32 nextdiroff32;\n\t\t\tif (read(fd, (char*) &nextdiroff32, sizeof (uint32)) != sizeof (uint32))\n\t\t\t\tnextdiroff32 = 0;\n\t\t\tif (swabflag)\n\t\t\t\tTIFFSwabLong(&nextdiroff32);\n\t\t\tnextdiroff = nextdiroff32;\n\t\t} else {\n\t\t\tif (read(fd, (char*) &nextdiroff, sizeof (uint64)) != sizeof (uint64))\n\t\t\t\tnextdiroff = 0;\n\t\t\tif (swabflag)\n\t\t\t\tTIFFSwabLong8(&nextdiroff);\n\t\t}\n\t}\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\tprintf(\"Directory %u: offset %I64u (%#I64x) next %I64u (%#I64x)\\n\", ix,\n\t    (unsigned __int64)off, (unsigned __int64)off,\n\t    (unsigned __int64)nextdiroff, (unsigned __int64)nextdiroff);\n#else\n\tprintf(\"Directory %u: offset %llu (%#llx) next %llu (%#llx)\\n\", ix,\n\t    (unsigned long long)off, (unsigned long long)off,\n\t    (unsigned long long)nextdiroff, (unsigned long long)nextdiroff);\n#endif\n\tfor (dp = (uint8*)dirmem, n = dircount; n > 0; n--) {\n\t\tuint16 tag;\n\t\tuint16 type;\n\t\tuint16 typewidth;\n\t\tuint64 count;\n\t\tuint64 datasize;\n\t\tint datafits;\n\t\tvoid* datamem;\n\t\tuint64 dataoffset;\n\t\tint datatruncated;\n                int datasizeoverflow;\n\n\t\ttag = *(uint16*)dp;\n\t\tif (swabflag)\n\t\t\tTIFFSwabShort(&tag);\n\t\tdp += sizeof(uint16);\n\t\ttype = *(uint16*)dp;\n\t\tdp += sizeof(uint16);\n\t\tif (swabflag)\n\t\t\tTIFFSwabShort(&type);\n\t\tPrintTag(stdout, tag);\n\t\tputchar(' ');\n\t\tPrintType(stdout, type);\n\t\tputchar(' ');\n\t\tif (!bigtiff)\n\t\t{\n\t\t\tuint32 count32;\n\t\t\tcount32 = *(uint32*)dp;\n\t\t\tif (swabflag)\n\t\t\t\tTIFFSwabLong(&count32);\n\t\t\tdp += sizeof(uint32);\n\t\t\tcount = count32;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&count, dp, sizeof(uint64));\n\t\t\tif (swabflag)\n\t\t\t\tTIFFSwabLong8(&count);\n\t\t\tdp += sizeof(uint64);\n\t\t}\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\tprintf(\"%I64u<\", (unsigned __int64)count);\n#else\n\t\tprintf(\"%llu<\", (unsigned long long)count);\n#endif\n\t\tif (type >= NWIDTHS)\n\t\t\ttypewidth = 0;\n\t\telse\n\t\t\ttypewidth = datawidth[type];\n\t\tdatasize = TIFFSafeMultiply(tmsize_t,count,typewidth);\n                datasizeoverflow = (typewidth > 0 && datasize / typewidth != count);\n\t\tdatafits = 1;\n\t\tdatamem = dp;\n\t\tdataoffset = 0;\n\t\tdatatruncated = 0;\n\t\tif (!bigtiff)\n\t\t{\n\t\t\tif (datasizeoverflow || datasize>4)\n\t\t\t{\n\t\t\t\tuint32 dataoffset32;\n\t\t\t\tdatafits = 0;\n\t\t\t\tdatamem = NULL;\n\t\t\t\tdataoffset32 = *(uint32*)dp;\n\t\t\t\tif (swabflag)\n\t\t\t\t\tTIFFSwabLong(&dataoffset32);\n\t\t\t\tdataoffset = dataoffset32;\n\t\t\t}\n\t\t\tdp += sizeof(uint32);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (datasizeoverflow || datasize>8)\n\t\t\t{\n\t\t\t\tdatafits = 0;\n\t\t\t\tdatamem = NULL;\n\t\t\t\tdataoffset = *(uint64*)dp;\n\t\t\t\tif (swabflag)\n\t\t\t\t\tTIFFSwabLong8(&dataoffset);\n\t\t\t}\n\t\t\tdp += sizeof(uint64);\n\t\t}\n\t\tif (datasizeoverflow || datasize>0x10000)\n\t\t{\n\t\t\tdatatruncated = 1;\n\t\t\tcount = 0x10000/typewidth;\n\t\t\tdatasize = TIFFSafeMultiply(tmsize_t,count,typewidth);\n\t\t}\n\t\tif (count>maxitems)\n\t\t{\n\t\t\tdatatruncated = 1;\n\t\t\tcount = maxitems;\n                        datasize = TIFFSafeMultiply(tmsize_t,count,typewidth);\n\t\t}\n\t\tif (!datafits)\n\t\t{\n\t\t\tdatamem = _TIFFmalloc(datasize);\n\t\t\tif (datamem) {\n\t\t\t\tif (_TIFF_lseek_f(fd, (_TIFF_off_t)dataoffset, 0) !=\n\t\t\t\t    (_TIFF_off_t)dataoffset)\n\t\t\t\t{\n\t\t\t\t\tError(\n\t\t\t\t\"Seek error accessing tag %u value\", tag);\n\t\t\t\t\t_TIFFfree(datamem);\n\t\t\t\t\tdatamem = NULL;\n\t\t\t\t}\n\t\t\t\telse if (read(fd, datamem, (size_t)datasize) != (TIFF_SSIZE_T)datasize)\n\t\t\t\t{\n\t\t\t\t\tError(\n\t\t\t\t\"Read error accessing tag %u value\", tag);\n\t\t\t\t\t_TIFFfree(datamem);\n\t\t\t\t\tdatamem = NULL;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tError(\"No space for data for tag %u\",tag);\n\t\t}\n\t\tif (datamem)\n\t\t{\n\t\t\tif (swabflag)\n\t\t\t{\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase TIFF_BYTE:\n\t\t\t\t\tcase TIFF_ASCII:\n\t\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\t\tTIFFSwabArrayOfShort((uint16*)datamem,(tmsize_t)count);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIFF_LONG:\n\t\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\t\tTIFFSwabArrayOfLong((uint32*)datamem,(tmsize_t)count);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\t\t\tTIFFSwabArrayOfLong((uint32*)datamem,(tmsize_t)count*2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\tcase TIFF_LONG8:\n\t\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\t\tTIFFSwabArrayOfLong8((uint64*)datamem,(tmsize_t)count);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPrintData(stdout,type,(uint32)count,datamem);\n\t\t\tif (datatruncated)\n\t\t\t\tprintf(\" ...\");\n\t\t\tif (!datafits)\n                                {\n                                        _TIFFfree(datamem);\n                                        datamem = NULL;\n                                }\n\t\t}\n\t\tprintf(\">\\n\");\n\t}\ndone:\n\tif (dirmem)\n\t\t_TIFFfree((char *)dirmem);\n\treturn (nextdiroff);\n}",
          "fn_code_pos": [
            [
              297,
              0
            ],
            [
              541,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadDirectory",
            "parameters": {
              "fd": "int",
              "ix": "unsigned int",
              "off": "uint64"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "static void\nPrintTag(FILE* fd, uint16 tag)\n{\n\tconst struct tagname *tp;\n\n\tfor (tp = tagnames; tp < &tagnames[NTAGS]; tp++)\n\t\tif (tp->tag == tag) {\n\t\t\tfprintf(fd, \"%s (%u)\", tp->name, tag);\n\t\t\treturn;\n\t\t}\n\tfprintf(fd, \"%u (%#x)\", tag, tag);\n}",
          "fn_code_pos": [
            [
              641,
              0
            ],
            [
              652,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintTag",
            "parameters": {
              "fd": "FILE",
              "tag": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nPrintType(FILE* fd, uint16 type)\n{\n\tstatic const char *typenames[] = {\n\t    \"0\",\n\t    \"BYTE\",\n\t    \"ASCII\",\n\t    \"SHORT\",\n\t    \"LONG\",\n\t    \"RATIONAL\",\n\t    \"SBYTE\",\n\t    \"UNDEFINED\",\n\t    \"SSHORT\",\n\t    \"SLONG\",\n\t    \"SRATIONAL\",\n\t    \"FLOAT\",\n\t    \"DOUBLE\",\n\t    \"IFD\",\n\t    \"14\",\n\t    \"15\",\n\t    \"LONG8\",\n\t    \"SLONG8\",\n\t    \"IFD8\"\n\t};\n#define\tNTYPES\t(sizeof (typenames) / sizeof (typenames[0]))\n\n\tif (type < NTYPES)\n\t\tfprintf(fd, \"%s (%u)\", typenames[type], type);\n\telse\n\t\tfprintf(fd, \"%u (%#x)\", type, type);\n}",
          "fn_code_pos": [
            [
              654,
              0
            ],
            [
              684,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintType",
            "parameters": {
              "fd": "FILE",
              "type": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nPrintASCII(FILE* fd, uint32 cc, const unsigned char* cp)\n{\n\tfor (; cc > 0; cc--, cp++) {\n\t\tconst char* tp;\n\n\t\tif (isprint(*cp)) {\n\t\t\tfputc(*cp, fd);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (tp = \"\\tt\\bb\\rr\\nn\\vv\"; *tp; tp++)\n\t\t\tif (*tp++ == *cp)\n\t\t\t\tbreak;\n\t\tif (*tp)\n\t\t\tfprintf(fd, \"\\\\%c\", *tp);\n\t\telse if (*cp)\n\t\t\tfprintf(fd, \"\\\\%03o\", *cp);\n\t\telse\n\t\t\tfprintf(fd, \"\\\\0\");\n\t}\n}",
          "fn_code_pos": [
            [
              689,
              0
            ],
            [
              709,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintASCII",
            "parameters": {
              "fd": "FILE",
              "cc": "uint32",
              "cp": "unsigned char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nPrintData(FILE* fd, uint16 type, uint32 count, unsigned char* data)\n{\n\tchar* sep = \"\";\n\n\tswitch (type) {\n\tcase TIFF_BYTE:\n\t\twhile (count-- > 0)\n\t\t\tfprintf(fd, bytefmt, sep, *data++), sep = \" \";\n\t\tbreak;\n\tcase TIFF_SBYTE:\n\t\twhile (count-- > 0)\n\t\t\tfprintf(fd, sbytefmt, sep, *(char *)data++), sep = \" \";\n\t\tbreak;\n\tcase TIFF_UNDEFINED:\n\t\twhile (count-- > 0)\n\t\t\tfprintf(fd, bytefmt, sep, *data++), sep = \" \";\n\t\tbreak;\n\tcase TIFF_ASCII:\n\t\tPrintASCII(fd, count, data);\n\t\tbreak;\n\tcase TIFF_SHORT: {\n\t\tuint16 *wp = (uint16*)data;\n\t\twhile (count-- > 0)\n\t\t\tfprintf(fd, shortfmt, sep, *wp++), sep = \" \";\n\t\tbreak;\n\t}\n\tcase TIFF_SSHORT: {\n\t\tint16 *wp = (int16*)data;\n\t\twhile (count-- > 0)\n\t\t\tfprintf(fd, sshortfmt, sep, *wp++), sep = \" \";\n\t\tbreak;\n\t}\n\tcase TIFF_LONG: {\n\t\tuint32 *lp = (uint32*)data;\n\t\twhile (count-- > 0) {\n\t\t\tfprintf(fd, longfmt, sep, (unsigned long) *lp++);\n\t\t\tsep = \" \";\n\t\t}\n\t\tbreak;\n\t}\n\tcase TIFF_SLONG: {\n\t\tint32 *lp = (int32*)data;\n\t\twhile (count-- > 0)\n\t\t\tfprintf(fd, slongfmt, sep, (long) *lp++), sep = \" \";\n\t\tbreak;\n\t}\n\tcase TIFF_LONG8: {\n\t\tuint64 *llp = (uint64*)data;\n\t\twhile (count-- > 0) {\n                        uint64 val;\n                        memcpy(&val, llp, sizeof(uint64));\n                        llp ++;\n\t\t\tfprintf(fd, long8fmt, sep, val);\n\t\t\tsep = \" \";\n\t\t}\n\t\tbreak;\n\t}\n\tcase TIFF_SLONG8: {\n\t\tint64 *llp = (int64*)data;\n\t\twhile (count-- > 0) {\n                        int64 val;\n                        memcpy(&val, llp, sizeof(int64));\n                        llp ++;\n                        fprintf(fd, slong8fmt, sep, val);\n                        sep = \" \";\n                }\n\t\tbreak;\n\t}\n\tcase TIFF_RATIONAL: {\n\t\tuint32 *lp = (uint32*)data;\n\t\twhile (count-- > 0) {\n\t\t\tif (lp[1] == 0)\n\t\t\t\tfprintf(fd, \"%sNan (%lu/%lu)\", sep,\n\t\t\t\t    (unsigned long) lp[0],\n\t\t\t\t    (unsigned long) lp[1]);\n\t\t\telse\n\t\t\t\tfprintf(fd, rationalfmt, sep,\n\t\t\t\t    (double)lp[0] / (double)lp[1]);\n\t\t\tsep = \" \";\n\t\t\tlp += 2;\n\t\t}\n\t\tbreak;\n\t}\n\tcase TIFF_SRATIONAL: {\n\t\tint32 *lp = (int32*)data;\n\t\twhile (count-- > 0) {\n\t\t\tif (lp[1] == 0)\n\t\t\t\tfprintf(fd, \"%sNan (%ld/%ld)\", sep,\n\t\t\t\t    (long) lp[0], (long) lp[1]);\n\t\t\telse\n\t\t\t\tfprintf(fd, srationalfmt, sep,\n\t\t\t\t    (double)lp[0] / (double)lp[1]);\n\t\t\tsep = \" \";\n\t\t\tlp += 2;\n\t\t}\n\t\tbreak;\n\t}\n\tcase TIFF_FLOAT: {\n\t\tfloat *fp = (float *)data;\n\t\twhile (count-- > 0)\n\t\t\tfprintf(fd, floatfmt, sep, *fp++), sep = \" \";\n\t\tbreak;\n\t}\n\tcase TIFF_DOUBLE: {\n\t\tdouble *dp = (double *)data;\n\t\twhile (count-- > 0)\n\t\t\tfprintf(fd, doublefmt, sep, *dp++), sep = \" \";\n\t\tbreak;\n\t}\n\tcase TIFF_IFD: {\n\t\tuint32 *lp = (uint32*)data;\n\t\twhile (count-- > 0) {\n\t\t\tfprintf(fd, ifdfmt, sep, (unsigned long) *lp++);\n\t\t\tsep = \" \";\n\t\t}\n\t\tbreak;\n\t}\n\tcase TIFF_IFD8: {\n\t\tuint64 *llp = (uint64*)data;\n\t\twhile (count-- > 0) {\n#if defined(__WIN32__) && defined(_MSC_VER)\n\t\t\tfprintf(fd, ifd8fmt, sep, (unsigned __int64) *llp++);\n#else\n\t\t\tfprintf(fd, ifd8fmt, sep, (unsigned long long) *llp++);\n#endif\n\t\t\tsep = \" \";\n\t\t}\n\t\tbreak;\n\t}\n\t}\n}",
          "fn_code_pos": [
            [
              711,
              0
            ],
            [
              842,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintData",
            "parameters": {
              "fd": "FILE",
              "type": "uint16",
              "count": "uint32",
              "data": "unsigned char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nReadError(char* what)\n{\n\tFatal(\"Error while reading %s\", what);\n}",
          "fn_code_pos": [
            [
              844,
              0
            ],
            [
              848,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadError",
            "parameters": {
              "what": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nvError(FILE* fd, const char* fmt, va_list ap)\n{\n\tfprintf(fd, \"%s: \", curfile);\n\tvfprintf(fd, fmt, ap);\n\tfprintf(fd, \".\\n\");\n}",
          "fn_code_pos": [
            [
              852,
              0
            ],
            [
              858,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "vError",
            "parameters": {
              "fd": "FILE",
              "fmt": "char",
              "ap": "va_list"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nError(const char* fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tvError(stderr, fmt, ap);\n\tva_end(ap);\n}",
          "fn_code_pos": [
            [
              860,
              0
            ],
            [
              867,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Error",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nFatal(const char* fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tvError(stderr, fmt, ap);\n\tva_end(ap);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              869,
              0
            ],
            [
              877,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fatal",
            "parameters": {
              "fmt": "char"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "getopt(int, char**, char*)",
          "fn_dec_pos": [
            [
              53,
              11
            ],
            [
              53,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "dump(int, uint64)",
          "fn_dec_pos": [
            [
              96,
              12
            ],
            [
              96,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "dump",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "ReadDirectory(int, unsigned, uint64)",
          "fn_dec_pos": [
            [
              159,
              14
            ],
            [
              159,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadDirectory",
            "parameters": {},
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "ReadError(char*)",
          "fn_dec_pos": [
            [
              160,
              12
            ],
            [
              160,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ReadError",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "Error(const char*, ...)",
          "fn_dec_pos": [
            [
              161,
              12
            ],
            [
              161,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Error",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "Fatal(const char*, ...)",
          "fn_dec_pos": [
            [
              162,
              12
            ],
            [
              162,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Fatal",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PrintTag(FILE*, uint16)",
          "fn_dec_pos": [
            [
              288,
              12
            ],
            [
              288,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintTag",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PrintType(FILE*, uint16)",
          "fn_dec_pos": [
            [
              289,
              12
            ],
            [
              289,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintType",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PrintData(FILE*, uint16, uint32, unsigned char*)",
          "fn_dec_pos": [
            [
              290,
              12
            ],
            [
              290,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintData",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct tagname {\n\tuint16 tag;\n\tconst char* name;\n}",
          {
            "tag": "uint16",
            "char": "const"
          },
          "tagname",
          [
            543,
            13
          ],
          [
            546,
            1
          ]
        ],
        [
          "struct tagname {\n\tuint16 tag;\n\tconst char* name;\n}",
          {
            "tag": "uint16",
            "char": "const"
          },
          "tagname",
          [
            543,
            13
          ],
          [
            546,
            1
          ]
        ],
        [
          "struct tagname",
          {},
          "",
          [
            644,
            7
          ],
          [
            644,
            21
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"tiffiop.h\"\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "# include <fcntl.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "# include <sys/types.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "# include <io.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            56,
            0
          ],
          [
            57,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            687,
            0
          ],
          [
            688,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            850,
            0
          ],
          [
            851,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/tiffset.c": {
      "fn_def_list": [
        {
          "fn_code": "static void\nusage(void)\n{\n\tint i;\n\tfor (i = 0; usageMsg[i]; i++)\n\t\tfprintf(stderr, \"%s\\n\", usageMsg[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              48,
              0
            ],
            [
              55,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static const TIFFField *\nGetField(TIFF *tiff, const char *tagname)\n{\n    const TIFFField *fip;\n\n    if( atoi(tagname) > 0 )\n        fip = TIFFFieldWithTag(tiff, (ttag_t)atoi(tagname));\n    else\n        fip = TIFFFieldWithName(tiff, tagname);\n\n    if (!fip) {\n        fprintf( stderr, \"Field name \\\"%s\\\" is not recognised.\\n\", tagname );\n        return (TIFFField *)NULL;\n    }\n\n    return fip;\n}",
          "fn_code_pos": [
            [
              57,
              0
            ],
            [
              73,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetField",
            "parameters": {
              "tiff": "TIFF",
              "tagname": "char"
            },
            "return_type": "TIFFField"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n    TIFF *tiff;\n    int  arg_index;\n\n    if (argc < 2)\n        usage();\n\n    tiff = TIFFOpen(argv[argc-1], \"r+\");\n    if (tiff == NULL)\n        return 2;\n\n    for( arg_index = 1; arg_index < argc-1; arg_index++ ) {\n\tif (strcmp(argv[arg_index],\"-d\") == 0 && arg_index < argc-2) {\n\t    arg_index++;\n\t    if( TIFFSetDirectory(tiff, atoi(argv[arg_index]) ) != 1 )\n            {\n               fprintf( stderr, \"Failed to set directory=%s\\n\", argv[arg_index] );\n               return 6;\n            }\n\t    arg_index++;\n\t}\n\tif (strcmp(argv[arg_index],\"-sd\") == 0 && arg_index < argc-2) {\n\t    arg_index++;\n\t    if( TIFFSetSubDirectory(tiff, atoi(argv[arg_index]) ) != 1 )\n            {\n               fprintf( stderr, \"Failed to set sub directory=%s\\n\", argv[arg_index] );\n               return 7;\n            }\n\t    arg_index++;\n\t}\n    /* Add unset option to tiffset -- Zach Baker (niquil@niquil.net) 11/14/2012 */ \n    if (strcmp(argv[arg_index],\"-u\") == 0 && arg_index < argc-2) {\n            const TIFFField *fip;\n            const char *tagname;\n            arg_index++;\n            tagname = argv[arg_index];\n            fip = GetField(tiff, tagname);\n            if (!fip)\n                return 3;\n\n            if (TIFFUnsetField(tiff, TIFFFieldTag(fip)) != 1)\n            {\n                    fprintf(stderr, \"Failed to unset %s\\n\", TIFFFieldName(fip));\n            }\n            arg_index++;\n    } else if (strcmp(argv[arg_index],\"-s\") == 0 && arg_index < argc-3) {\n            const TIFFField *fip;\n            const char *tagname;\n\n            arg_index++;\n            tagname = argv[arg_index];\n            fip = GetField(tiff, tagname);\n\n            if (!fip)\n                return 3;\n\n            arg_index++;\n            if (TIFFFieldDataType(fip) == TIFF_ASCII) {\n                if (TIFFSetField(tiff, TIFFFieldTag(fip), argv[arg_index]) != 1)\n                    fprintf( stderr, \"Failed to set %s=%s\\n\",\n                             TIFFFieldName(fip), argv[arg_index] );\n            } else if (TIFFFieldWriteCount(fip) > 0\n\t\t       || TIFFFieldWriteCount(fip) == TIFF_VARIABLE) {\n                int     ret = 1;\n                short   wc;\n\n                if (TIFFFieldWriteCount(fip) == TIFF_VARIABLE)\n                        wc = atoi(argv[arg_index++]);\n                else\n                        wc = TIFFFieldWriteCount(fip);\n\n                if (argc - arg_index < wc) {\n                    fprintf( stderr,\n                             \"Number of tag values is not enough. \"\n                             \"Expected %d values for %s tag, got %d\\n\",\n                             wc, TIFFFieldName(fip), argc - arg_index);\n                    return 4;\n                }\n                    \n                if (wc > 1 || TIFFFieldWriteCount(fip) == TIFF_VARIABLE) {\n                        int     i, size;\n                        void    *array;\n\n                        switch (TIFFFieldDataType(fip)) {\n                                /*\n                                 * XXX: We can't use TIFFDataWidth()\n                                 * to determine the space needed to store\n                                 * the value. For TIFF_RATIONAL values\n                                 * TIFFDataWidth() returns 8, but we use 4-byte\n                                 * float to represent rationals.\n                                 */\n                                case TIFF_BYTE:\n                                case TIFF_ASCII:\n                                case TIFF_SBYTE:\n                                case TIFF_UNDEFINED:\n\t\t\t\tdefault:\n                                    size = 1;\n                                    break;\n\n                                case TIFF_SHORT:\n                                case TIFF_SSHORT:\n                                    size = 2;\n                                    break;\n\n                                case TIFF_LONG:\n                                case TIFF_SLONG:\n                                case TIFF_FLOAT:\n                                case TIFF_IFD:\n                                case TIFF_RATIONAL:\n                                case TIFF_SRATIONAL:\n                                    size = 4;\n                                    break;\n\n                                case TIFF_LONG8:\n                                case TIFF_SLONG8:\n                                case TIFF_IFD8:\n                                case TIFF_DOUBLE:\n                                    size = 8;\n                                    break;\n                        }\n\n                        array = _TIFFmalloc(wc * size);\n                        if (!array) {\n                                fprintf(stderr, \"No space for %s tag\\n\",\n                                        tagname);\n                                return 4;\n                        }\n\n                        switch (TIFFFieldDataType(fip)) {\n                            case TIFF_BYTE:\n                                for (i = 0; i < wc; i++)\n                                    ((uint8 *)array)[i] = atoi(argv[arg_index+i]);\n                                break;\n                            case TIFF_SHORT:\n                                for (i = 0; i < wc; i++)\n                                    ((uint16 *)array)[i] = atoi(argv[arg_index+i]);\n                                break;\n                            case TIFF_SBYTE:\n                                for (i = 0; i < wc; i++)\n                                    ((int8 *)array)[i] = atoi(argv[arg_index+i]);\n                                break;\n                            case TIFF_SSHORT:\n                                for (i = 0; i < wc; i++)\n                                    ((int16 *)array)[i] = atoi(argv[arg_index+i]);\n                                break;\n                            case TIFF_LONG:\n                                for (i = 0; i < wc; i++)\n                                    ((uint32 *)array)[i] = atol(argv[arg_index+i]);\n                                break;\n                            case TIFF_SLONG:\n                            case TIFF_IFD:\n                                for (i = 0; i < wc; i++)\n                                    ((int32 *)array)[i] = atol(argv[arg_index+i]);\n                                break;\n                            case TIFF_LONG8:\n                                for (i = 0; i < wc; i++)\n                                    ((uint64 *)array)[i] = strtoll(argv[arg_index+i], (char **)NULL, 10);\n                                break;\n                            case TIFF_SLONG8:\n                            case TIFF_IFD8:\n                                for (i = 0; i < wc; i++)\n                                    ((int64 *)array)[i] = strtoll(argv[arg_index+i], (char **)NULL, 10);\n                                break;\n                            case TIFF_DOUBLE:\n                                for (i = 0; i < wc; i++)\n                                    ((double *)array)[i] = atof(argv[arg_index+i]);\n                                break;\n                            case TIFF_RATIONAL:\n                            case TIFF_SRATIONAL:\n                            case TIFF_FLOAT:\n                                for (i = 0; i < wc; i++)\n                                    ((float *)array)[i] = (float)atof(argv[arg_index+i]);\n                                break;\n                            default:\n                                break;\n                        }\n                \n                        if (TIFFFieldPassCount(fip)) {\n                                ret = TIFFSetField(tiff, TIFFFieldTag(fip),\n                                                   wc, array);\n                        } else if (TIFFFieldTag(fip) == TIFFTAG_PAGENUMBER\n\t\t\t\t   || TIFFFieldTag(fip) == TIFFTAG_HALFTONEHINTS\n\t\t\t\t   || TIFFFieldTag(fip) == TIFFTAG_YCBCRSUBSAMPLING\n\t\t\t\t   || TIFFFieldTag(fip) == TIFFTAG_DOTRANGE) {\n       \t\t\t\tif (TIFFFieldDataType(fip) == TIFF_BYTE) {\n\t\t\t\t\tret = TIFFSetField(tiff, TIFFFieldTag(fip),\n\t\t\t\t\t\t((uint8 *)array)[0], ((uint8 *)array)[1]);\n\t\t\t\t} else if (TIFFFieldDataType(fip) == TIFF_SHORT) {\n\t\t\t\t\tret = TIFFSetField(tiff, TIFFFieldTag(fip),\n\t\t\t\t\t\t((uint16 *)array)[0], ((uint16 *)array)[1]);\n\t\t\t\t}\n\t\t\t} else {\n                                ret = TIFFSetField(tiff, TIFFFieldTag(fip),\n                                                   array);\n                        }\n\n                        _TIFFfree(array);\n                } else {\n                        switch (TIFFFieldDataType(fip)) {\n                            case TIFF_BYTE:\n                            case TIFF_SHORT:\n                            case TIFF_SBYTE:\n                            case TIFF_SSHORT:\n                                ret = TIFFSetField(tiff, TIFFFieldTag(fip),\n                                                   atoi(argv[arg_index++]));\n                                break;\n                            case TIFF_LONG:\n                            case TIFF_SLONG:\n                            case TIFF_IFD:\n                                ret = TIFFSetField(tiff, TIFFFieldTag(fip),\n                                                   atol(argv[arg_index++]));\n                                break;\n                            case TIFF_LONG8:\n                            case TIFF_SLONG8:\n                            case TIFF_IFD8:\n                                ret = TIFFSetField(tiff, TIFFFieldTag(fip),\n                                                   strtoll(argv[arg_index++], (char **)NULL, 10));\n                                break;\n                            case TIFF_DOUBLE:\n                                ret = TIFFSetField(tiff, TIFFFieldTag(fip),\n                                                   atof(argv[arg_index++]));\n                                break;\n                            case TIFF_RATIONAL:\n                            case TIFF_SRATIONAL:\n                            case TIFF_FLOAT:\n                                ret = TIFFSetField(tiff, TIFFFieldTag(fip),\n                                                   (float)atof(argv[arg_index++]));\n                                break;\n                            default:\n                                break;\n                        }\n                }\n\n                if (ret != 1)\n                    fprintf(stderr, \"Failed to set %s\\n\", TIFFFieldName(fip));\n                arg_index += wc;\n            }\n        } else if (strcmp(argv[arg_index],\"-sf\") == 0 && arg_index < argc-3) {\n            FILE    *fp;\n            const TIFFField *fip;\n            char    *text;\n            size_t  len;\n\n            arg_index++;\n            fip = GetField(tiff, argv[arg_index]);\n\n            if (!fip)\n                return 3;\n\n            if (TIFFFieldDataType(fip) != TIFF_ASCII) {\n                fprintf( stderr,\n                         \"Only ASCII tags can be set from file. \"\n                         \"%s is not ASCII tag.\\n\", TIFFFieldName(fip) );\n                return 5;\n            }\n\n            arg_index++;\n            fp = fopen( argv[arg_index], \"rt\" );\n            if(fp == NULL) {\n                perror( argv[arg_index] );\n                continue;\n            }\n\n            text = (char *) malloc(1000000);\n            len = fread( text, 1, 999999, fp );\n            text[len] = '\\0';\n\n            fclose( fp );\n\n            if(TIFFSetField( tiff, TIFFFieldTag(fip), text ) != 1) {\n                fprintf(stderr, \"Failed to set %s from file %s\\n\", \n                        TIFFFieldName(fip), argv[arg_index]);\n            }\n\n            _TIFFfree( text );\n            arg_index++;\n        } else {\n            fprintf(stderr, \"Unrecognised option: %s\\n\",\n                    argv[arg_index]);\n            usage();\n        }\n    }\n\n    TIFFRewriteDirectory(tiff);\n    TIFFClose(tiff);\n    return 0;\n}",
          "fn_code_pos": [
            [
              75,
              0
            ],
            [
              363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "GetField(TIFF *tiff, const char *tagname)",
          "fn_dec_pos": [
            [
              58,
              0
            ],
            [
              58,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "GetField",
            "parameters": {
              "tiff": "TIFF",
              "tagname": "char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/tiff2pdf.c": {
      "fn_def_list": [
        {
          "fn_code": "static void\nt2p_disable(TIFF *tif)\n{\n\tT2P *t2p = (T2P*) TIFFClientdata(tif);\n\tt2p->outputdisable = 1;\n}",
          "fn_code_pos": [
            [
              344,
              0
            ],
            [
              349,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_disable",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nt2p_enable(TIFF *tif)\n{\n\tT2P *t2p = (T2P*) TIFFClientdata(tif);\n\tt2p->outputdisable = 0;\n}",
          "fn_code_pos": [
            [
              351,
              0
            ],
            [
              356,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_enable",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static tmsize_t \nt2pReadFile(TIFF *tif, tdata_t data, tmsize_t size)\n{\n\tthandle_t client = TIFFClientdata(tif);\n\tTIFFReadWriteProc proc = TIFFGetReadProc(tif);\n\tif (proc)\n\t\treturn proc(client, data, size);\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              363,
              0
            ],
            [
              371,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2pReadFile",
            "parameters": {
              "tif": "TIFF",
              "data": "tdata_t",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static tmsize_t \nt2pWriteFile(TIFF *tif, tdata_t data, tmsize_t size)\n{\n\tthandle_t client = TIFFClientdata(tif);\n\tTIFFReadWriteProc proc = TIFFGetWriteProc(tif);\n\tif (proc)\n\t\treturn proc(client, data, size);\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              374,
              0
            ],
            [
              382,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2pWriteFile",
            "parameters": {
              "tif": "TIFF",
              "data": "tdata_t",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static uint64\nt2pSeekFile(TIFF *tif, toff_t offset, int whence)\n{\n\tthandle_t client = TIFFClientdata(tif);\n\tTIFFSeekProc proc = TIFFGetSeekProc(tif);\n\tif (proc)\n\t\treturn proc(client, offset, whence);\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              384,
              0
            ],
            [
              392,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2pSeekFile",
            "parameters": {
              "tif": "TIFF",
              "offset": "toff_t",
              "whence": "int"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "static tmsize_t \nt2p_readproc(thandle_t handle, tdata_t data, tmsize_t size) \n{\n\t(void) handle, (void) data, (void) size;\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              394,
              0
            ],
            [
              399,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_readproc",
            "parameters": {
              "handle": "thandle_t",
              "data": "tdata_t",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static tmsize_t \nt2p_writeproc(thandle_t handle, tdata_t data, tmsize_t size) \n{\n\tT2P *t2p = (T2P*) handle;\n\tif (t2p->outputdisable <= 0 && t2p->outputfile) {\n\t\ttsize_t written = fwrite(data, 1, size, t2p->outputfile);\n\t\tt2p->outputwritten += written;\n\t\treturn written;\n\t}\n\treturn size; \n}",
          "fn_code_pos": [
            [
              401,
              0
            ],
            [
              411,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_writeproc",
            "parameters": {
              "handle": "thandle_t",
              "data": "tdata_t",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "static uint64 \nt2p_seekproc(thandle_t handle, uint64 offset, int whence) \n{ \n\tT2P *t2p = (T2P*) handle;\n\tif (t2p->outputdisable <= 0 && t2p->outputfile)\n\t\treturn _TIFF_fseek_f(t2p->outputfile, (_TIFF_off_t) offset, whence);\n\treturn offset;\n}",
          "fn_code_pos": [
            [
              413,
              0
            ],
            [
              420,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_seekproc",
            "parameters": {
              "handle": "thandle_t",
              "offset": "uint64",
              "whence": "int"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "static int \nt2p_closeproc(thandle_t handle)\n{ \n\tT2P *t2p = (T2P*) handle;\n\treturn fclose(t2p->outputfile);\n}",
          "fn_code_pos": [
            [
              422,
              0
            ],
            [
              427,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_closeproc",
            "parameters": {
              "handle": "thandle_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static uint64 \nt2p_sizeproc(thandle_t handle) \n{\n\t(void) handle;\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              429,
              0
            ],
            [
              434,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_sizeproc",
            "parameters": {
              "handle": "thandle_t"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "static int \nt2p_mapproc(thandle_t handle, void **data, toff_t *offset) \n{ \n\t(void) handle, (void) data, (void) offset;\n\treturn -1; \n}",
          "fn_code_pos": [
            [
              436,
              0
            ],
            [
              441,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_mapproc",
            "parameters": {
              "handle": "thandle_t",
              "data": "void",
              "offset": "toff_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void \nt2p_unmapproc(thandle_t handle, void *data, toff_t offset)\n{ \n\t(void) handle, (void) data, (void) offset;\n}",
          "fn_code_pos": [
            [
              443,
              0
            ],
            [
              447,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_unmapproc",
            "parameters": {
              "handle": "thandle_t",
              "data": "void",
              "offset": "toff_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static uint64\ncheckAdd64(uint64 summand1, uint64 summand2, T2P* t2p)\n{\n\tuint64 bytes = summand1 + summand2;\n\n\tif (bytes < summand1) {\n\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\tbytes = 0;\n\t}\n\n\treturn bytes;\n}",
          "fn_code_pos": [
            [
              450,
              0
            ],
            [
              462,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "checkAdd64",
            "parameters": {
              "summand1": "uint64",
              "summand2": "uint64",
              "t2p": "T2P"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "static uint64\ncheckMultiply64(uint64 first, uint64 second, T2P* t2p)\n{\n\tuint64 bytes = first * second;\n\n\tif (second && bytes / second != first) {\n\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\tbytes = 0;\n\t}\n\n\treturn bytes;\n}",
          "fn_code_pos": [
            [
              465,
              0
            ],
            [
              477,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "checkMultiply64",
            "parameters": {
              "first": "uint64",
              "second": "uint64",
              "t2p": "T2P"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "int main(int argc, char** argv){\n#if !HAVE_DECL_OPTARG\n\textern char *optarg;\n\textern int optind;\n#endif\n\tconst char *outfilename = NULL;\n\tT2P *t2p = NULL;\n\tTIFF *input = NULL, *output = NULL;\n\tint c, ret = EXIT_SUCCESS;\n\n\tt2p = t2p_init();\n\n\tif (t2p == NULL){\n\t\tTIFFError(TIFF2PDF_MODULE, \"Can't initialize context\");\n\t\tgoto fail;\n\t}\n\n\twhile (argv &&\n\t       (c = getopt(argc, argv,\n\t\t\t   \"o:q:u:x:y:w:l:r:p:e:c:a:t:s:k:jzndifbhF\")) != -1){\n\t\tswitch (c) {\n\t\t\tcase 'o':\n\t\t\t\toutfilename = optarg;\n\t\t\t\tbreak;\n#ifdef JPEG_SUPPORT\n\t\t\tcase 'j':  \n\t\t\t\tt2p->pdf_defaultcompression=T2P_COMPRESS_JPEG;\n\t\t\t\tbreak;\n#endif\n#ifndef JPEG_SUPPORT\n\t\t\tcase 'j':  \n\t\t\t\tTIFFWarning(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"JPEG support in libtiff required for JPEG compression, ignoring option\");\n\t\t\t\tbreak;\n#endif\n#ifdef ZIP_SUPPORT\n\t\t\tcase 'z':  \n\t\t\t\tt2p->pdf_defaultcompression=T2P_COMPRESS_ZIP;\n\t\t\t\tbreak;\n#endif\n#ifndef ZIP_SUPPORT\n\t\t\tcase 'z':  \n\t\t\t\tTIFFWarning(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"Zip support in libtiff required for Zip compression, ignoring option\");\n\t\t\t\tbreak;\n#endif\n\t\t\tcase 'q': \n\t\t\t\tt2p->pdf_defaultcompressionquality=atoi(optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'n': \n\t\t\t\tt2p->pdf_nopassthrough=1;\n\t\t\t\tbreak;\n\t\t\tcase 'd': \n\t\t\t\tt2p->pdf_defaultcompression=T2P_COMPRESS_NONE;\n\t\t\t\tbreak;\n\t\t\tcase 'u': \n\t\t\t\tif(optarg[0]=='m'){\n\t\t\t\t\tt2p->pdf_centimeters=1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'x': \n\t\t\t\tt2p->pdf_defaultxres = \n\t\t\t\t\t(float)atof(optarg) / (t2p->pdf_centimeters?2.54F:1.0F);\n\t\t\t\tbreak;\n\t\t\tcase 'y': \n\t\t\t\tt2p->pdf_defaultyres = \n\t\t\t\t\t(float)atof(optarg) / (t2p->pdf_centimeters?2.54F:1.0F);\n\t\t\t\tbreak;\n\t\t\tcase 'w': \n\t\t\t\tt2p->pdf_overridepagesize=1;\n\t\t\t\tt2p->pdf_defaultpagewidth = \n\t\t\t\t\t((float)atof(optarg) * PS_UNIT_SIZE) / (t2p->pdf_centimeters?2.54F:1.0F);\n\t\t\t\tbreak;\n\t\t\tcase 'l': \n\t\t\t\tt2p->pdf_overridepagesize=1;\n\t\t\t\tt2p->pdf_defaultpagelength = \n\t\t\t\t\t((float)atof(optarg) * PS_UNIT_SIZE) / (t2p->pdf_centimeters?2.54F:1.0F);\n\t\t\t\tbreak;\n\t\t\tcase 'r': \n\t\t\t\tif(optarg[0]=='o'){\n\t\t\t\t\tt2p->pdf_overrideres=1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'p': \n\t\t\t\tif(tiff2pdf_match_paper_size(\n\t\t\t\t\t&(t2p->pdf_defaultpagewidth), \n\t\t\t\t\t&(t2p->pdf_defaultpagelength), \n\t\t\t\t\toptarg)){\n\t\t\t\t\tt2p->pdf_overridepagesize=1;\n\t\t\t\t} else {\n\t\t\t\t\tTIFFWarning(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Unknown paper size %s, ignoring option\",\n\t\t\t\t\t\toptarg);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tt2p->pdf_colorspace_invert=1;\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\tt2p->pdf_image_fillpage = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'f': \n\t\t\t\tt2p->pdf_fitwindow=1;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tif (strlen(optarg) == 0) {\n\t\t\t\t\tt2p->pdf_datetime[0] = '\\0';\n\t\t\t\t} else {\n\t\t\t\t\tt2p->pdf_datetime[0] = 'D';\n\t\t\t\t\tt2p->pdf_datetime[1] = ':';\n\t\t\t\t\tstrncpy(t2p->pdf_datetime + 2, optarg,\n\t\t\t\t\t\tsizeof(t2p->pdf_datetime) - 3);\n\t\t\t\t\tt2p->pdf_datetime[sizeof(t2p->pdf_datetime) - 1] = '\\0';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'c': \n\t\t\t\tstrncpy(t2p->pdf_creator, optarg, sizeof(t2p->pdf_creator) - 1);\n\t\t\t\tt2p->pdf_creator[sizeof(t2p->pdf_creator) - 1] = '\\0';\n\t\t\t\tbreak;\n\t\t\tcase 'a': \n\t\t\t\tstrncpy(t2p->pdf_author, optarg, sizeof(t2p->pdf_author) - 1);\n\t\t\t\tt2p->pdf_author[sizeof(t2p->pdf_author) - 1] = '\\0';\n\t\t\t\tbreak;\n\t\t\tcase 't': \n\t\t\t\tstrncpy(t2p->pdf_title, optarg, sizeof(t2p->pdf_title) - 1);\n\t\t\t\tt2p->pdf_title[sizeof(t2p->pdf_title) - 1] = '\\0';\n\t\t\t\tbreak;\n\t\t\tcase 's': \n\t\t\t\tstrncpy(t2p->pdf_subject, optarg, sizeof(t2p->pdf_subject) - 1);\n\t\t\t\tt2p->pdf_subject[sizeof(t2p->pdf_subject) - 1] = '\\0';\n\t\t\t\tbreak;\n\t\t\tcase 'k': \n\t\t\t\tstrncpy(t2p->pdf_keywords, optarg, sizeof(t2p->pdf_keywords) - 1);\n\t\t\t\tt2p->pdf_keywords[sizeof(t2p->pdf_keywords) - 1] = '\\0';\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tt2p->pdf_image_interpolate = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'h': \n\t\t\tcase '?': \n\t\t\t\ttiff2pdf_usage();\n\t\t\t\tgoto success;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Input\n\t */\n\tif(argc > optind) {\n\t\tinput = TIFFOpen(argv[optind++], \"r\");\n\t\tif (input==NULL) {\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t  \"Can't open input file %s for reading\", \n\t\t\t\t  argv[optind-1]);\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tTIFFError(TIFF2PDF_MODULE, \"No input file specified\"); \n\t\ttiff2pdf_usage();\n\t\tgoto fail;\n\t}\n\n\tif(argc > optind) {\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t  \"No support for multiple input files\"); \n\t\ttiff2pdf_usage();\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * Output\n\t */\n\tt2p->outputdisable = 1;\n\tif (outfilename) {\n\t\tt2p->outputfile = fopen(outfilename, \"wb\");\n\t\tif (t2p->outputfile == NULL) {\n\t\t\tTIFFError(TIFF2PDF_MODULE,\n\t\t\t\t  \"Can't open output file %s for writing\",\n\t\t\t\t  outfilename);\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\toutfilename = \"-\";\n\t\tt2p->outputfile = stdout;\n\t}\n\n\toutput = TIFFClientOpen(outfilename, \"w\", (thandle_t) t2p,\n\t\t\t\tt2p_readproc, t2p_writeproc, t2p_seekproc, \n\t\t\t\tt2p_closeproc, t2p_sizeproc, \n\t\t\t\tt2p_mapproc, t2p_unmapproc);\n\tt2p->outputdisable = 0;\n\tif (output == NULL) {\n\t\tTIFFError(TIFF2PDF_MODULE,\n\t\t\t  \"Can't initialize output descriptor\");\n\t\tgoto fail;\n\t}\n\t\n\t/*\n\t * Validate\n\t */\n\tt2p_validate(t2p);\n\tt2pSeekFile(output, (toff_t) 0, SEEK_SET);\n\n\t/*\n\t * Write\n\t */\n\tt2p_write_pdf(t2p, input, output);\n\tif (t2p->t2p_error != 0) {\n\t\tTIFFError(TIFF2PDF_MODULE,\n\t\t\t  \"An error occurred creating output PDF file\");\n\t\tgoto fail;\n\t}\n\n\tgoto success;\nfail:\n\tret = EXIT_FAILURE;\nsuccess:\n\tif(input != NULL)\n\t\tTIFFClose(input);\n\tif (output != NULL)\n\t\tTIFFClose(output);\n\tif (t2p != NULL)\n\t\tt2p_free(t2p);\n\treturn ret;\n  \n}",
          "fn_code_pos": [
            [
              600,
              0
            ],
            [
              828,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void tiff2pdf_usage(){\n\tchar* lines[]={\n\t\"usage:  tiff2pdf [options] input.tiff\",\n\t\"options:\",\n\t\" -o: output to file name\",\n#ifdef JPEG_SUPPORT\n\t\" -j: compress with JPEG\", \n#endif\n#ifdef ZIP_SUPPORT\n\t\" -z: compress with Zip/Deflate\",\n#endif\n\t\" -q: compression quality\",\n\t\" -n: no compressed data passthrough\",\n\t\" -d: do not compress (decompress)\",\n\t\" -i: invert colors\",\n\t\" -u: set distance unit, 'i' for inch, 'm' for centimeter\",\n\t\" -x: set x resolution default in dots per unit\",\n\t\" -y: set y resolution default in dots per unit\",\n\t\" -w: width in units\",\n\t\" -l: length in units\",\n\t\" -r: 'd' for resolution default, 'o' for resolution override\",\n\t\" -p: paper size, eg \\\"letter\\\", \\\"legal\\\", \\\"A4\\\"\",\n  \" -F: make the tiff fill the PDF page\",\n\t\" -f: set PDF \\\"Fit Window\\\" user preference\",\n\t\" -e: date, overrides image or current date/time default, YYYYMMDDHHMMSS\",\n\t\" -c: sets document creator, overrides image software default\",\n\t\" -a: sets document author, overrides image artist default\",\n\t\" -t: sets document title, overrides image document name default\",\n\t\" -s: sets document subject, overrides image image description default\",\n\t\" -k: sets document keywords\",\n\t\" -b: set PDF \\\"Interpolate\\\" user preference\",\n\t\" -h: usage\",\n\tNULL\n\t};\n\tint i=0;\n\n\tfprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i=0;lines[i]!=NULL;i++){\n\t\tfprintf(stderr, \"%s\\n\", lines[i]);\n\t}\n\n\treturn;\n}",
          "fn_code_pos": [
            [
              830,
              0
            ],
            [
              872,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiff2pdf_usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "int tiff2pdf_match_paper_size(float* width, float* length, char* papersize){\n\n\tsize_t i, len;\n\tconst char* sizes[]={\n\t\t\"LETTER\", \"A4\", \"LEGAL\",\n\t\t\"EXECUTIVE\", \"LETTER\", \"LEGAL\", \"LEDGER\", \"TABLOID\", \n\t\t\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"J\", \"K\", \n\t\t\"A10\", \"A9\", \"A8\", \"A7\", \"A6\", \"A5\", \"A4\", \"A3\", \"A2\", \"A1\", \"A0\", \n\t\t\"2A0\", \"4A0\", \"2A\", \"4A\", \n\t\t\"B10\", \"B9\", \"B8\", \"B7\", \"B6\", \"B5\", \"B4\", \"B3\", \"B2\", \"B1\", \"B0\", \n\t\t\"JISB10\", \"JISB9\", \"JISB8\", \"JISB7\", \"JISB6\", \"JISB5\", \"JISB4\", \n\t\t\"JISB3\", \"JISB2\", \"JISB1\", \"JISB0\", \n\t\t\"C10\", \"C9\", \"C8\", \"C7\", \"C6\", \"C5\", \"C4\", \"C3\", \"C2\", \"C1\", \"C0\", \n\t\t\"RA2\", \"RA1\", \"RA0\", \"SRA4\", \"SRA3\", \"SRA2\", \"SRA1\", \"SRA0\", \n\t\t\"A3EXTRA\", \"A4EXTRA\", \n\t\t\"STATEMENT\", \"FOLIO\", \"QUARTO\", \n\t\tNULL\n\t} ;\n\tconst int widths[]={\n\t\t612, 595, 612,\n\t\t522, 612,612,792,792,\n\t\t612,792,1224,1584,2448,2016,792,2016,2448,2880,\n\t\t74,105,147,210,298,420,595,842,1191,1684,2384,3370,4768,3370,4768,\n\t\t88,125,176,249,354,499,709,1001,1417,2004,2835,\n\t\t91,128,181,258,363,516,729,1032,1460,2064,2920,\n\t\t79,113,162,230,323,459,649,918,1298,1298,2599,\n\t\t1219,1729,2438,638,907,1276,1814,2551,\n\t\t914,667,\n\t\t396, 612, 609, \n\t\t0\n\t};\n\tconst int lengths[]={\n\t\t792,842,1008,\n\t\t756,792,1008,1224,1224,\n\t\t792,1224,1584,2448,3168,2880,6480,10296,12672,10296,\n\t\t105,147,210,298,420,595,842,1191,1684,2384,3370,4768,6741,4768,6741,\n\t\t125,176,249,354,499,709,1001,1417,2004,2835,4008,\n\t\t128,181,258,363,516,729,1032,1460,2064,2920,4127,\n\t\t113,162,230,323,459,649,918,1298,1837,1837,3677,\n\t\t1729,2438,3458,907,1276,1814,2551,3628,\n\t\t1262,914,\n\t\t612, 936, 780, \n\t\t0\n\t};\n\n\tlen=strlen(papersize);\n\tfor(i=0;i<len;i++){\n\t\tpapersize[i]=toupper((int) papersize[i]);\n\t}\n\tfor(i=0;sizes[i]!=NULL; i++){\n\t\tif (strcmp( (const char*)papersize, sizes[i])==0){\n\t\t\t*width=(float)widths[i];\n\t\t\t*length=(float)lengths[i];\n\t\t\treturn(1);\n\t\t}\n\t}\n\n\treturn(0);\n}",
          "fn_code_pos": [
            [
              874,
              0
            ],
            [
              932,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiff2pdf_match_paper_size",
            "parameters": {
              "width": "float",
              "length": "float",
              "papersize": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "T2P* t2p_init()\n{\n\tT2P* t2p = (T2P*) _TIFFmalloc(sizeof(T2P));\n\tif(t2p==NULL){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"Can't allocate %lu bytes of memory for t2p_init\", \n\t\t\t(unsigned long) sizeof(T2P));\n\t\treturn( (T2P*) NULL );\n\t}\n\t_TIFFmemset(t2p, 0x00, sizeof(T2P));\n\tt2p->pdf_majorversion=1;\n\tt2p->pdf_minorversion=1;\n\tt2p->pdf_defaultxres=300.0;\n\tt2p->pdf_defaultyres=300.0;\n\tt2p->pdf_defaultpagewidth=612.0;\n\tt2p->pdf_defaultpagelength=792.0;\n\tt2p->pdf_xrefcount=3; /* Catalog, Info, Pages */\n\t\n\treturn(t2p);\n}",
          "fn_code_pos": [
            [
              938,
              0
            ],
            [
              958,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_init",
            "parameters": {},
            "return_type": "T2P"
          }
        },
        {
          "fn_code": "void t2p_free(T2P* t2p)\n{\n\tint i = 0;\n\n\tif (t2p != NULL) {\n\t\tif(t2p->pdf_xrefoffsets != NULL){\n\t\t\t_TIFFfree( (tdata_t) t2p->pdf_xrefoffsets);\n\t\t}\n\t\tif(t2p->tiff_pages != NULL){\n\t\t\t_TIFFfree( (tdata_t) t2p->tiff_pages);\n\t\t}\n\t\tfor(i=0;i<t2p->tiff_pagecount;i++){\n\t\t\tif(t2p->tiff_tiles[i].tiles_tiles != NULL){\n\t\t\t\t_TIFFfree( (tdata_t) t2p->tiff_tiles[i].tiles_tiles);\n\t\t\t}\n\t\t}\n\t\tif(t2p->tiff_tiles != NULL){\n\t\t\t_TIFFfree( (tdata_t) t2p->tiff_tiles);\n\t\t}\n\t\tif(t2p->pdf_palette != NULL){\n\t\t\t_TIFFfree( (tdata_t) t2p->pdf_palette);\n\t\t}\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->pdf_ojpegdata != NULL){\n\t\t\t_TIFFfree( (tdata_t) t2p->pdf_ojpegdata);\n\t\t}\n#endif\n\t\t_TIFFfree( (tdata_t) t2p );\n\t}\n\n\treturn;\n}",
          "fn_code_pos": [
            [
              964,
              0
            ],
            [
              995,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_free",
            "parameters": {
              "t2p": "T2P"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void t2p_validate(T2P* t2p){\n\n#ifdef JPEG_SUPPORT\n\tif(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){\n\t\tif(t2p->pdf_defaultcompressionquality>100 ||\n\t\t\tt2p->pdf_defaultcompressionquality<1){\n\t\t\tt2p->pdf_defaultcompressionquality=0;\n\t\t}\n\t}\n#endif\n#ifdef ZIP_SUPPORT\n\tif(t2p->pdf_defaultcompression==T2P_COMPRESS_ZIP){\n \t\tuint16 m=t2p->pdf_defaultcompressionquality%100;\n \t\tif(t2p->pdf_defaultcompressionquality/100 > 9 ||\n \t\t\t(m>1 && m<10) || m>15){\n \t\t\tt2p->pdf_defaultcompressionquality=0;\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality%100 !=0){\n \t\t\tt2p->pdf_defaultcompressionquality/=100;\n \t\t\tt2p->pdf_defaultcompressionquality*=100;\n\t\t\tTIFFError(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"PNG Group predictor differencing not implemented, assuming compression quality %u\", \n\t\t\t\tt2p->pdf_defaultcompressionquality);\n\t\t}\n\t\tt2p->pdf_defaultcompressionquality%=100;\n\t\tif(t2p->pdf_minorversion<2){t2p->pdf_minorversion=2;}\n\t}\n#endif\n\t(void)0;\n\n\treturn;\n}",
          "fn_code_pos": [
            [
              1002,
              0
            ],
            [
              1034,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_validate",
            "parameters": {
              "t2p": "T2P"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void t2p_read_tiff_init(T2P* t2p, TIFF* input){\n\n\ttdir_t directorycount=0;\n\ttdir_t i=0;\n\tuint16 pagen=0;\n\tuint16 paged=0;\n\tuint16 xuint16=0;\n\tuint16 tiff_transferfunctioncount=0;\n\tuint16* tiff_transferfunction[3];\n\n\tdirectorycount=TIFFNumberOfDirectories(input);\n\tif(directorycount > TIFF_DIR_MAX) {\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE,\n\t\t\t\"TIFF contains too many directories, %s\",\n\t\t\tTIFFFileName(input));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn;\n\t}\n\tt2p->tiff_pages = (T2P_PAGE*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,directorycount,sizeof(T2P_PAGE)));\n\tif(t2p->tiff_pages==NULL){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory for tiff_pages array, %s\", \n\t\t\t(TIFF_SIZE_T) directorycount * sizeof(T2P_PAGE), \n\t\t\tTIFFFileName(input));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn;\n\t}\n\t_TIFFmemset( t2p->tiff_pages, 0x00, directorycount * sizeof(T2P_PAGE));\n\tt2p->tiff_tiles = (T2P_TILES*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,directorycount,sizeof(T2P_TILES)));\n\tif(t2p->tiff_tiles==NULL){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory for tiff_tiles array, %s\", \n\t\t\t(TIFF_SIZE_T) directorycount * sizeof(T2P_TILES), \n\t\t\tTIFFFileName(input));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn;\n\t}\n\t_TIFFmemset( t2p->tiff_tiles, 0x00, directorycount * sizeof(T2P_TILES));\n\tfor(i=0;i<directorycount;i++){\n\t\tuint32 subfiletype = 0;\n\t\t\n\t\tif(!TIFFSetDirectory(input, i)){\n\t\t\tTIFFError(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"Can't set directory %u of input file %s\", \n\t\t\t\ti,\n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn;\n\t\t}\n\t\tif(TIFFGetField(input, TIFFTAG_PAGENUMBER, &pagen, &paged)){\n\t\t\tif((pagen>paged) && (paged != 0)){\n\t\t\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_number = \n\t\t\t\t\tpaged;\n\t\t\t} else {\n\t\t\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_number = \n\t\t\t\t\tpagen;\n\t\t\t}\n\t\t\tgoto ispage2;\n\t\t}\n\t\tif(TIFFGetField(input, TIFFTAG_SUBFILETYPE, &subfiletype)){\n\t\t\tif ( ((subfiletype & FILETYPE_PAGE) != 0)\n                             || (subfiletype == 0)){\n\t\t\t\tgoto ispage;\n\t\t\t} else {\n\t\t\t\tgoto isnotpage;\n\t\t\t}\n\t\t}\n\t\tif(TIFFGetField(input, TIFFTAG_OSUBFILETYPE, &subfiletype)){\n\t\t\tif ((subfiletype == OFILETYPE_IMAGE) \n\t\t\t\t|| (subfiletype == OFILETYPE_PAGE)\n\t\t\t\t|| (subfiletype == 0) ){\n\t\t\t\tgoto ispage;\n\t\t\t} else {\n\t\t\t\tgoto isnotpage;\n\t\t\t}\n\t\t}\n\t\tispage:\n\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_number=t2p->tiff_pagecount;\n\t\tispage2:\n\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_directory=i;\n\t\tif(TIFFIsTiled(input)){\n\t\t\tt2p->tiff_pages[t2p->tiff_pagecount].page_tilecount = \n\t\t\t\tTIFFNumberOfTiles(input);\n\t\t}\n\t\tt2p->tiff_pagecount++;\n\t\tisnotpage:\n\t\t(void)0;\n\t}\n\t\n\tqsort((void*) t2p->tiff_pages, t2p->tiff_pagecount,\n              sizeof(T2P_PAGE), t2p_cmp_t2p_page);\n\n\tfor(i=0;i<t2p->tiff_pagecount;i++){\n\t\tt2p->pdf_xrefcount += 5;\n\t\tTIFFSetDirectory(input, t2p->tiff_pages[i].page_directory );\n\t\tif((TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &xuint16)\n                    && (xuint16==PHOTOMETRIC_PALETTE))\n\t\t   || TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)) {\n\t\t\tt2p->tiff_pages[i].page_extra++;\n\t\t\tt2p->pdf_xrefcount++;\n\t\t}\n#ifdef ZIP_SUPPORT\n\t\tif (TIFFGetField(input, TIFFTAG_COMPRESSION, &xuint16)) {\n                        if( (xuint16== COMPRESSION_DEFLATE ||\n                             xuint16== COMPRESSION_ADOBE_DEFLATE) && \n                            ((t2p->tiff_pages[i].page_tilecount != 0) \n                             || TIFFNumberOfStrips(input)==1) &&\n                            (t2p->pdf_nopassthrough==0)\t){\n                                if(t2p->pdf_minorversion<2){t2p->pdf_minorversion=2;}\n                        }\n                }\n#endif\n\t\tif (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,\n                                 &(tiff_transferfunction[0]),\n                                 &(tiff_transferfunction[1]),\n                                 &(tiff_transferfunction[2]))) {\n\n                        if((tiff_transferfunction[1] != (uint16*) NULL) &&\n                           (tiff_transferfunction[2] != (uint16*) NULL)\n                          ) {\n                            tiff_transferfunctioncount=3;\n                        } else {\n                            tiff_transferfunctioncount=1;\n                        }\n                } else {\n\t\t\ttiff_transferfunctioncount=0;\n\t\t}\n\n                if (i > 0){\n                    if (tiff_transferfunctioncount != t2p->tiff_transferfunctioncount){\n                        TIFFError(\n                            TIFF2PDF_MODULE,\n                            \"Different transfer function on page %d\",\n                            i);\n                        t2p->t2p_error = T2P_ERR_ERROR;\n                        return;\n                    }\n                }\n\n                t2p->tiff_transferfunctioncount = tiff_transferfunctioncount;\n                t2p->tiff_transferfunction[0] = tiff_transferfunction[0];\n                t2p->tiff_transferfunction[1] = tiff_transferfunction[1];\n                t2p->tiff_transferfunction[2] = tiff_transferfunction[2];\n                if(tiff_transferfunctioncount == 3){\n                        t2p->tiff_pages[i].page_extra += 4;\n                        t2p->pdf_xrefcount += 4;\n                        if(t2p->pdf_minorversion < 2)\n                                t2p->pdf_minorversion = 2;\n                } else if (tiff_transferfunctioncount == 1){\n                        t2p->tiff_pages[i].page_extra += 2;\n                        t2p->pdf_xrefcount += 2;\n                        if(t2p->pdf_minorversion < 2)\n                                t2p->pdf_minorversion = 2;\n                }\n\n\t\tif( TIFFGetField(\n\t\t\tinput, \n\t\t\tTIFFTAG_ICCPROFILE, \n\t\t\t&(t2p->tiff_iccprofilelength), \n\t\t\t&(t2p->tiff_iccprofile)) != 0){\n\t\t\tt2p->tiff_pages[i].page_extra++;\n\t\t\tt2p->pdf_xrefcount++;\n\t\t\tif(t2p->pdf_minorversion<3){t2p->pdf_minorversion=3;}\n\t\t}\n\t\tt2p->tiff_tiles[i].tiles_tilecount=\n\t\t\tt2p->tiff_pages[i].page_tilecount;\n\t\tif( (TIFFGetField(input, TIFFTAG_PLANARCONFIG, &xuint16) != 0)\n\t\t\t&& (xuint16 == PLANARCONFIG_SEPARATE ) ){\n\t\t\t\tif( !TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &xuint16) )\n\t\t\t\t{\n\t\t\t\t\tTIFFError(\n                        TIFF2PDF_MODULE, \n                        \"Missing SamplesPerPixel, %s\", \n                        TIFFFileName(input));\n                    t2p->t2p_error = T2P_ERR_ERROR;\n                    return;\n\t\t\t\t}\n                if( (t2p->tiff_tiles[i].tiles_tilecount % xuint16) != 0 )\n                {\n                    TIFFError(\n                        TIFF2PDF_MODULE, \n                        \"Invalid tile count, %s\", \n                        TIFFFileName(input));\n                    t2p->t2p_error = T2P_ERR_ERROR;\n                    return;\n                }\n\t\t\t\tt2p->tiff_tiles[i].tiles_tilecount/= xuint16;\n\t\t}\n\t\tif( t2p->tiff_tiles[i].tiles_tilecount > 0){\n\t\t\tt2p->pdf_xrefcount += \n\t\t\t\t(t2p->tiff_tiles[i].tiles_tilecount -1)*2;\n\t\t\tTIFFGetField(input, \n\t\t\t\tTIFFTAG_TILEWIDTH, \n\t\t\t\t&( t2p->tiff_tiles[i].tiles_tilewidth) );\n\t\t\tTIFFGetField(input, \n\t\t\t\tTIFFTAG_TILELENGTH, \n\t\t\t\t&( t2p->tiff_tiles[i].tiles_tilelength) );\n\t\t\tt2p->tiff_tiles[i].tiles_tiles = \n\t\t\t(T2P_TILE*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->tiff_tiles[i].tiles_tilecount,\n                                                                 sizeof(T2P_TILE)) );\n\t\t\tif( t2p->tiff_tiles[i].tiles_tiles == NULL){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory for t2p_read_tiff_init, %s\", \n\t\t\t\t\t(TIFF_SIZE_T) t2p->tiff_tiles[i].tiles_tilecount * sizeof(T2P_TILE), \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n}",
          "fn_code_pos": [
            [
              1044,
              0
            ],
            [
              1261,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_read_tiff_init",
            "parameters": {
              "t2p": "T2P",
              "input": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int t2p_cmp_t2p_page(const void* e1, const void* e2){\n\n\tint d;\n\td = (int32)(((T2P_PAGE*)e1)->page_number) - (int32)(((T2P_PAGE*)e2)->page_number);\n\tif(d == 0){\n\t\td = (int32)(((T2P_PAGE*)e1)->page_directory) - (int32)(((T2P_PAGE*)e2)->page_directory);\n\t}\n\treturn d;\n}",
          "fn_code_pos": [
            [
              1269,
              0
            ],
            [
              1277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_cmp_t2p_page",
            "parameters": {
              "e1": "void",
              "e2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void t2p_read_tiff_data(T2P* t2p, TIFF* input){\n\n\tint i=0;\n\tuint16* r = NULL;\n\tuint16* g = NULL;\n\tuint16* b = NULL;\n\tuint16* a = NULL;\n\tuint16 xuint16;\n\tuint16* xuint16p;\n\tfloat* xfloatp;\n\n\tt2p->pdf_transcode = T2P_TRANSCODE_ENCODE;\n\tt2p->pdf_sample = T2P_SAMPLE_NOTHING;\n        t2p->pdf_switchdecode = t2p->pdf_colorspace_invert;\n        \n\t\n\tTIFFSetDirectory(input, t2p->tiff_pages[t2p->pdf_page].page_directory);\n\n\tTIFFGetField(input, TIFFTAG_IMAGEWIDTH, &(t2p->tiff_width));\n\tif(t2p->tiff_width == 0){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"No support for %s with zero width\", \n\t\t\tTIFFFileName(input)\t);\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn;\n\t}\n\n\tTIFFGetField(input, TIFFTAG_IMAGELENGTH, &(t2p->tiff_length));\n\tif(t2p->tiff_length == 0){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"No support for %s with zero length\", \n\t\t\tTIFFFileName(input)\t);\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn;\n\t}\n\n        if(TIFFGetField(input, TIFFTAG_COMPRESSION, &(t2p->tiff_compression)) == 0){\n                TIFFError(\n                        TIFF2PDF_MODULE, \n                        \"No support for %s with no compression tag\", \n                        TIFFFileName(input)     );\n                t2p->t2p_error = T2P_ERR_ERROR;\n                return;\n\n        }\n        if( TIFFIsCODECConfigured(t2p->tiff_compression) == 0){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"No support for %s with compression type %u:  not configured\", \n\t\t\tTIFFFileName(input), \n\t\t\tt2p->tiff_compression\t\n\t\t\t);\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn;\n\t\n\t}\n\n\tTIFFGetFieldDefaulted(input, TIFFTAG_BITSPERSAMPLE, &(t2p->tiff_bitspersample));\n\tswitch(t2p->tiff_bitspersample){\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\tcase 8:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tTIFFWarning(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"Image %s has 0 bits per sample, assuming 1\",\n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->tiff_bitspersample=1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tTIFFError(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"No support for %s with %u bits per sample\",\n\t\t\t\tTIFFFileName(input),\n\t\t\t\tt2p->tiff_bitspersample);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn;\n\t}\n\n\tTIFFGetFieldDefaulted(input, TIFFTAG_SAMPLESPERPIXEL, &(t2p->tiff_samplesperpixel));\n\tif(t2p->tiff_samplesperpixel>4){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"No support for %s with %u samples per pixel\",\n\t\t\tTIFFFileName(input),\n\t\t\tt2p->tiff_samplesperpixel);\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn;\n\t}\n\tif(t2p->tiff_samplesperpixel==0){\n\t\tTIFFWarning(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"Image %s has 0 samples per pixel, assuming 1\",\n\t\t\tTIFFFileName(input));\n\t\tt2p->tiff_samplesperpixel=1;\n\t}\n\t\n\tif(TIFFGetField(input, TIFFTAG_SAMPLEFORMAT, &xuint16) != 0 ){\n\t\tswitch(xuint16){\n\t\t\tcase 0:\n\t\t\tcase 1:\n\t\t\tcase 4:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for %s with sample format %u\",\n\t\t\t\t\tTIFFFileName(input),\n\t\t\t\t\txuint16);\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tTIFFGetFieldDefaulted(input, TIFFTAG_FILLORDER, &(t2p->tiff_fillorder));\n\t\n        if(TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &(t2p->tiff_photometric)) == 0){\n                TIFFError(\n                        TIFF2PDF_MODULE, \n                        \"No support for %s with no photometric interpretation tag\", \n                        TIFFFileName(input)     );\n                t2p->t2p_error = T2P_ERR_ERROR;\n                return;\n\n        }\n        \n\tswitch(t2p->tiff_photometric){\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\tcase PHOTOMETRIC_MINISBLACK: \n\t\t\tif (t2p->tiff_bitspersample==1){\n\t\t\t\tt2p->pdf_colorspace=T2P_CS_BILEVEL;\n\t\t\t\tif(t2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){\n\t\t\t\t\tt2p->pdf_switchdecode ^= 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt2p->pdf_colorspace=T2P_CS_GRAY;\n\t\t\t\tif(t2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){\n\t\t\t\t\tt2p->pdf_switchdecode ^= 1;\n\t\t\t\t} \n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_RGB: \n\t\t\tt2p->pdf_colorspace=T2P_CS_RGB;\n\t\t\tif(t2p->tiff_samplesperpixel == 3){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)){\n\t\t\t\tif(xuint16==1)\n\t\t\t\t\tgoto photometric_palette;\n\t\t\t}\n\t\t\tif(t2p->tiff_samplesperpixel > 3) {\n\t\t\t\tif(t2p->tiff_samplesperpixel == 4) {\n\t\t\t\t\tt2p->pdf_colorspace = T2P_CS_RGB;\n\t\t\t\t\tif(TIFFGetField(input,\n\t\t\t\t\t\t\tTIFFTAG_EXTRASAMPLES,\n\t\t\t\t\t\t\t&xuint16, &xuint16p)\n\t\t\t\t\t   && xuint16 == 1) {\n\t\t\t\t\t\tif(xuint16p[0] == EXTRASAMPLE_ASSOCALPHA){\n\t\t\t\t\t\t\tif( t2p->tiff_bitspersample != 8 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t    TIFFError(\n\t\t\t\t\t\t\t\t    TIFF2PDF_MODULE, \n\t\t\t\t\t\t\t\t    \"No support for BitsPerSample=%d for RGBA\",\n\t\t\t\t\t\t\t\t    t2p->tiff_bitspersample);\n\t\t\t\t\t\t\t    t2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\t\t\t    return;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tt2p->pdf_sample=T2P_SAMPLE_RGBAA_TO_RGB;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(xuint16p[0] == EXTRASAMPLE_UNASSALPHA){\n\t\t\t\t\t\t\tif( t2p->tiff_bitspersample != 8 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t    TIFFError(\n\t\t\t\t\t\t\t\t    TIFF2PDF_MODULE, \n\t\t\t\t\t\t\t\t    \"No support for BitsPerSample=%d for RGBA\",\n\t\t\t\t\t\t\t\t    t2p->tiff_bitspersample);\n\t\t\t\t\t\t\t    t2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\t\t\t    return;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tt2p->pdf_sample=T2P_SAMPLE_RGBA_TO_RGB;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tTIFFWarning(\n\t\t\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\t\t\"RGB image %s has 4 samples per pixel, assuming RGBA\",\n\t\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tt2p->pdf_colorspace=T2P_CS_CMYK;\n\t\t\t\t\tt2p->pdf_switchdecode ^= 1;\n\t\t\t\t\tTIFFWarning(\n\t\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\t\"RGB image %s has 4 samples per pixel, assuming inverse CMYK\",\n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tTIFFError(\n\t\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\t\"No support for RGB image %s with %u samples per pixel\", \n\t\t\t\t\t\tTIFFFileName(input), \n\t\t\t\t\t\tt2p->tiff_samplesperpixel);\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for RGB image %s with %u samples per pixel\", \n\t\t\t\t\tTIFFFileName(input), \n\t\t\t\t\tt2p->tiff_samplesperpixel);\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase PHOTOMETRIC_PALETTE: \n\t\t\tphotometric_palette:\n\t\t\tif(t2p->tiff_samplesperpixel!=1){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for palettized image %s with not one sample per pixel\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tt2p->pdf_colorspace=T2P_CS_RGB | T2P_CS_PALETTE;\n\t\t\tt2p->pdf_palettesize=0x0001<<t2p->tiff_bitspersample;\n\t\t\tif(!TIFFGetField(input, TIFFTAG_COLORMAP, &r, &g, &b)){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE,\n\t\t\t\t\t\"Palettized image %s has no color map\",\n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(r == NULL || g == NULL || b == NULL){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE,\n\t\t\t\t\t\"Error getting 3 components from color map\");\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(t2p->pdf_palette != NULL){\n\t\t\t\t_TIFFfree(t2p->pdf_palette);\n\t\t\t\tt2p->pdf_palette=NULL;\n\t\t\t}\n\t\t\tt2p->pdf_palette = (unsigned char*)\n\t\t\t\t_TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_palettesize,3));\n\t\t\tif(t2p->pdf_palette==NULL){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %u bytes of memory for t2p_read_tiff_image, %s\", \n\t\t\t\t\tt2p->pdf_palettesize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(i=0;i<t2p->pdf_palettesize;i++){\n\t\t\t\tt2p->pdf_palette[(i*3)]  = (unsigned char) (r[i]>>8);\n\t\t\t\tt2p->pdf_palette[(i*3)+1]= (unsigned char) (g[i]>>8);\n\t\t\t\tt2p->pdf_palette[(i*3)+2]= (unsigned char) (b[i]>>8);\n\t\t\t}\n\t\t\tt2p->pdf_palettesize *= 3;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_SEPARATED:\n\t\t\tif(TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)){\n\t\t\t\tif(xuint16==1){\n\t\t\t\t\t\tgoto photometric_palette_cmyk;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( TIFFGetField(input, TIFFTAG_INKSET, &xuint16) ){\n\t\t\t\tif(xuint16 != INKSET_CMYK){\n\t\t\t\t\tTIFFError(\n\t\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\t\"No support for %s because its inkset is not CMYK\",\n\t\t\t\t\t\tTIFFFileName(input) );\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t2p->tiff_samplesperpixel==4){\n\t\t\t\tt2p->pdf_colorspace=T2P_CS_CMYK;\n\t\t\t} else {\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for %s because it has %u samples per pixel\",\n\t\t\t\t\tTIFFFileName(input), \n\t\t\t\t\tt2p->tiff_samplesperpixel);\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t\tphotometric_palette_cmyk:\n\t\t\tif(t2p->tiff_samplesperpixel!=1){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for palettized CMYK image %s with not one sample per pixel\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tt2p->pdf_colorspace=T2P_CS_CMYK | T2P_CS_PALETTE;\n\t\t\tt2p->pdf_palettesize=0x0001<<t2p->tiff_bitspersample;\n\t\t\tif(!TIFFGetField(input, TIFFTAG_COLORMAP, &r, &g, &b, &a)){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE,\n\t\t\t\t\t\"Palettized image %s has no color map\",\n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(r == NULL || g == NULL || b == NULL || a == NULL){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE,\n\t\t\t\t\t\"Error getting 4 components from color map\");\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(t2p->pdf_palette != NULL){\n\t\t\t\t_TIFFfree(t2p->pdf_palette);\n\t\t\t\tt2p->pdf_palette=NULL;\n\t\t\t}\n\t\t\tt2p->pdf_palette = (unsigned char*) \n\t\t\t\t_TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_palettesize,4));\n\t\t\tif(t2p->pdf_palette==NULL){\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %u bytes of memory for t2p_read_tiff_image, %s\", \n\t\t\t\t\tt2p->pdf_palettesize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(i=0;i<t2p->pdf_palettesize;i++){\n\t\t\t\tt2p->pdf_palette[(i*4)]  = (unsigned char) (r[i]>>8);\n\t\t\t\tt2p->pdf_palette[(i*4)+1]= (unsigned char) (g[i]>>8);\n\t\t\t\tt2p->pdf_palette[(i*4)+2]= (unsigned char) (b[i]>>8);\n\t\t\t\tt2p->pdf_palette[(i*4)+3]= (unsigned char) (a[i]>>8);\n\t\t\t}\n\t\t\tt2p->pdf_palettesize *= 4;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_YCBCR:\n\t\t\tt2p->pdf_colorspace=T2P_CS_RGB;\n\t\t\tif(t2p->tiff_samplesperpixel==1){\n\t\t\t\tt2p->pdf_colorspace=T2P_CS_GRAY;\n\t\t\t\tt2p->tiff_photometric=PHOTOMETRIC_MINISBLACK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt2p->pdf_sample=T2P_SAMPLE_YCBCR_TO_RGB;\n#ifdef JPEG_SUPPORT\n\t\t\tif(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){\n\t\t\t\tt2p->pdf_sample=T2P_SAMPLE_NOTHING;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_CIELAB:\n            if( t2p->tiff_samplesperpixel != 3){\n                TIFFError(\n                    TIFF2PDF_MODULE, \n                    \"Unsupported samplesperpixel = %d for CIELAB\", \n                    t2p->tiff_samplesperpixel);\n                t2p->t2p_error = T2P_ERR_ERROR;\n                return;\n            }\n            if( t2p->tiff_bitspersample != 8){\n                TIFFError(\n                    TIFF2PDF_MODULE, \n                    \"Invalid bitspersample = %d for CIELAB\", \n                    t2p->tiff_bitspersample);\n                t2p->t2p_error = T2P_ERR_ERROR;\n                return;\n            }\n\t\t\tt2p->pdf_labrange[0]= -127;\n\t\t\tt2p->pdf_labrange[1]= 127;\n\t\t\tt2p->pdf_labrange[2]= -127;\n\t\t\tt2p->pdf_labrange[3]= 127;\n\t\t\tt2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;\n\t\t\tt2p->pdf_colorspace=T2P_CS_LAB;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_ICCLAB:\n\t\t\tt2p->pdf_labrange[0]= 0;\n\t\t\tt2p->pdf_labrange[1]= 255;\n\t\t\tt2p->pdf_labrange[2]= 0;\n\t\t\tt2p->pdf_labrange[3]= 255;\n\t\t\tt2p->pdf_colorspace=T2P_CS_LAB;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_ITULAB:\n            if( t2p->tiff_samplesperpixel != 3){\n                TIFFError(\n                    TIFF2PDF_MODULE, \n                    \"Unsupported samplesperpixel = %d for ITULAB\", \n                    t2p->tiff_samplesperpixel);\n                t2p->t2p_error = T2P_ERR_ERROR;\n                return;\n            }\n            if( t2p->tiff_bitspersample != 8){\n                TIFFError(\n                    TIFF2PDF_MODULE, \n                    \"Invalid bitspersample = %d for ITULAB\", \n                    t2p->tiff_bitspersample);\n                t2p->t2p_error = T2P_ERR_ERROR;\n                return;\n            }\n\t\t\tt2p->pdf_labrange[0]=-85;\n\t\t\tt2p->pdf_labrange[1]=85;\n\t\t\tt2p->pdf_labrange[2]=-75;\n\t\t\tt2p->pdf_labrange[3]=124;\n\t\t\tt2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;\n\t\t\tt2p->pdf_colorspace=T2P_CS_LAB;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_LOGL:\n\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\tTIFFError(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"No support for %s with photometric interpretation LogL/LogLuv\", \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn;\n\t\tdefault:\n\t\t\tTIFFError(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"No support for %s with photometric interpretation %u\", \n\t\t\t\tTIFFFileName(input),\n\t\t\t\tt2p->tiff_photometric);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn;\n\t}\n\n\tif(TIFFGetField(input, TIFFTAG_PLANARCONFIG, &(t2p->tiff_planar))){\n\t\tswitch(t2p->tiff_planar){\n\t\t\tcase 0:\n\t\t\t\tTIFFWarning(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"Image %s has planar configuration 0, assuming 1\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->tiff_planar=PLANARCONFIG_CONTIG;\n\t\t\tcase PLANARCONFIG_CONTIG:\n\t\t\t\tbreak;\n\t\t\tcase PLANARCONFIG_SEPARATE:\n\t\t\t\tt2p->pdf_sample=T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG;\n\t\t\t\tif(t2p->tiff_bitspersample!=8){\n\t\t\t\t\tTIFFError(\n\t\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\t\"No support for %s with separated planar configuration and %u bits per sample\", \n\t\t\t\t\t\tTIFFFileName(input),\n\t\t\t\t\t\tt2p->tiff_bitspersample);\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tTIFFError(\n\t\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for %s with planar configuration %u\", \n\t\t\t\t\tTIFFFileName(input),\n\t\t\t\t\tt2p->tiff_planar);\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t}\n\t}\n\n        TIFFGetFieldDefaulted(input, TIFFTAG_ORIENTATION,\n                              &(t2p->tiff_orientation));\n        if(t2p->tiff_orientation>8){\n                TIFFWarning(TIFF2PDF_MODULE,\n                            \"Image %s has orientation %u, assuming 0\",\n                            TIFFFileName(input), t2p->tiff_orientation);\n                t2p->tiff_orientation=0;\n        }\n\n        if(TIFFGetField(input, TIFFTAG_XRESOLUTION, &(t2p->tiff_xres) ) == 0){\n                t2p->tiff_xres=0.0;\n        }\n        if(TIFFGetField(input, TIFFTAG_YRESOLUTION, &(t2p->tiff_yres) ) == 0){\n                t2p->tiff_yres=0.0;\n        }\n\tTIFFGetFieldDefaulted(input, TIFFTAG_RESOLUTIONUNIT,\n\t\t\t      &(t2p->tiff_resunit));\n\tif(t2p->tiff_resunit == RESUNIT_CENTIMETER) {\n\t\tt2p->tiff_xres *= 2.54F;\n\t\tt2p->tiff_yres *= 2.54F;\n\t} else if (t2p->tiff_resunit != RESUNIT_INCH\n\t\t   && t2p->pdf_centimeters != 0) {\n\t\tt2p->tiff_xres *= 2.54F;\n\t\tt2p->tiff_yres *= 2.54F;\n\t}\n\n\tt2p_compose_pdf_page(t2p);\n        if( t2p->t2p_error == T2P_ERR_ERROR )\n\t    return;\n\n\tt2p->pdf_transcode = T2P_TRANSCODE_ENCODE;\n        /* It seems that T2P_TRANSCODE_RAW mode doesn't support separate->contig */\n        /* conversion. At least t2p_read_tiff_size and t2p_read_tiff_size_tile */\n        /* do not take into account the number of samples, and thus */\n        /* that can cause heap buffer overflows such as in */\n        /* http://bugzilla.maptools.org/show_bug.cgi?id=2715 */\n\tif(t2p->pdf_nopassthrough==0 && t2p->tiff_planar!=PLANARCONFIG_SEPARATE){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->tiff_compression==COMPRESSION_CCITTFAX4  \n\t\t\t){\n\t\t\tif(TIFFIsTiled(input) || (TIFFNumberOfStrips(input)==1) ){\n\t\t\t\tt2p->pdf_transcode = T2P_TRANSCODE_RAW;\n\t\t\t\tt2p->pdf_compression=T2P_COMPRESS_G4;\n\t\t\t}\n\t\t}\n#endif\n#ifdef ZIP_SUPPORT\n\t\tif(t2p->tiff_compression== COMPRESSION_ADOBE_DEFLATE \n\t\t\t|| t2p->tiff_compression==COMPRESSION_DEFLATE){\n\t\t\tif(TIFFIsTiled(input) || (TIFFNumberOfStrips(input)==1) ){\n\t\t\t\tt2p->pdf_transcode = T2P_TRANSCODE_RAW;\n\t\t\t\tt2p->pdf_compression=T2P_COMPRESS_ZIP;\n\t\t\t}\n\t\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression==COMPRESSION_OJPEG){\n\t\t\tt2p->pdf_transcode = T2P_TRANSCODE_RAW;\n\t\t\tt2p->pdf_compression=T2P_COMPRESS_JPEG;\n\t\t\tt2p_process_ojpeg_tables(t2p, input);\n\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression==COMPRESSION_JPEG){\n\t\t\tt2p->pdf_transcode = T2P_TRANSCODE_RAW;\n\t\t\tt2p->pdf_compression=T2P_COMPRESS_JPEG;\n\t\t}\n#endif\n\t\t(void)0;\n\t}\n\n\tif(t2p->pdf_transcode!=T2P_TRANSCODE_RAW){\n\t\tt2p->pdf_compression = t2p->pdf_defaultcompression;\n\t}\n\n#ifdef JPEG_SUPPORT\n\tif(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){\n\t\tif(t2p->pdf_colorspace & T2P_CS_PALETTE){\n\t\t\tt2p->pdf_sample|=T2P_SAMPLE_REALIZE_PALETTE;\n\t\t\tt2p->pdf_colorspace ^= T2P_CS_PALETTE;\n\t\t\tt2p->tiff_pages[t2p->pdf_page].page_extra--;\n\t\t}\n\t}\n\tif(t2p->tiff_compression==COMPRESSION_JPEG){\n\t\tif(t2p->tiff_planar==PLANARCONFIG_SEPARATE){\n\t\t\tTIFFError(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"No support for %s with JPEG compression and separated planar configuration\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\tif(t2p->tiff_compression==COMPRESSION_OJPEG){\n\t\tif(t2p->tiff_planar==PLANARCONFIG_SEPARATE){\n\t\t\tTIFFError(\n\t\t\t\tTIFF2PDF_MODULE, \n\t\t\t\t\"No support for %s with OJPEG compression and separated planar configuration\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\tif(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){\n\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\tt2p->tiff_samplesperpixel=4;\n\t\t\tt2p->tiff_photometric=PHOTOMETRIC_SEPARATED;\n\t\t} else {\n\t\t\tt2p->tiff_samplesperpixel=3;\n\t\t\tt2p->tiff_photometric=PHOTOMETRIC_RGB;\n\t\t}\n\t}\n\n\tif (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,\n\t\t\t &(t2p->tiff_transferfunction[0]),\n\t\t\t &(t2p->tiff_transferfunction[1]),\n\t\t\t &(t2p->tiff_transferfunction[2]))) {\n\t\tif((t2p->tiff_transferfunction[1] != (uint16*) NULL) &&\n                   (t2p->tiff_transferfunction[2] != (uint16*) NULL)\n                  ) {\n\t\t\tt2p->tiff_transferfunctioncount=3;\n\t\t} else {\n\t\t\tt2p->tiff_transferfunctioncount=1;\n\t\t}\n\t} else {\n\t\tt2p->tiff_transferfunctioncount=0;\n\t}\n\tif(TIFFGetField(input, TIFFTAG_WHITEPOINT, &xfloatp)!=0){\n\t\tt2p->tiff_whitechromaticities[0]=xfloatp[0];\n\t\tt2p->tiff_whitechromaticities[1]=xfloatp[1];\n\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\tt2p->pdf_colorspace |= T2P_CS_CALGRAY;\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_RGB){\n\t\t\tt2p->pdf_colorspace |= T2P_CS_CALRGB;\n\t\t}\n\t}\n\tif(TIFFGetField(input, TIFFTAG_PRIMARYCHROMATICITIES, &xfloatp)!=0){\n\t\tt2p->tiff_primarychromaticities[0]=xfloatp[0];\n\t\tt2p->tiff_primarychromaticities[1]=xfloatp[1];\n\t\tt2p->tiff_primarychromaticities[2]=xfloatp[2];\n\t\tt2p->tiff_primarychromaticities[3]=xfloatp[3];\n\t\tt2p->tiff_primarychromaticities[4]=xfloatp[4];\n\t\tt2p->tiff_primarychromaticities[5]=xfloatp[5];\n\t\tif(t2p->pdf_colorspace & T2P_CS_RGB){\n\t\t\tt2p->pdf_colorspace |= T2P_CS_CALRGB;\n\t\t}\n\t}\n\tif(t2p->pdf_colorspace & T2P_CS_LAB){\n\t\tif(TIFFGetField(input, TIFFTAG_WHITEPOINT, &xfloatp) != 0){\n\t\t\tt2p->tiff_whitechromaticities[0]=xfloatp[0];\n\t\t\tt2p->tiff_whitechromaticities[1]=xfloatp[1];\n\t\t} else {\n\t\t\tt2p->tiff_whitechromaticities[0]=0.3457F; /* 0.3127F; */\n\t\t\tt2p->tiff_whitechromaticities[1]=0.3585F; /* 0.3290F; */\n\t\t}\n\t}\n\tif(TIFFGetField(input, \n\t\tTIFFTAG_ICCPROFILE, \n\t\t&(t2p->tiff_iccprofilelength), \n\t\t&(t2p->tiff_iccprofile))!=0){\n\t\tt2p->pdf_colorspace |= T2P_CS_ICCBASED;\n\t} else {\n\t\tt2p->tiff_iccprofilelength=0;\n\t\tt2p->tiff_iccprofile=NULL;\n\t}\n\t\n#ifdef CCITT_SUPPORT\n\tif( t2p->tiff_bitspersample==1 &&\n\t\tt2p->tiff_samplesperpixel==1){\n\t\tt2p->pdf_compression = T2P_COMPRESS_G4;\n\t}\n#endif\n\n\n\treturn;\n}",
          "fn_code_pos": [
            [
              1291,
              0
            ],
            [
              1936,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_read_tiff_data",
            "parameters": {
              "t2p": "T2P",
              "input": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void t2p_read_tiff_size(T2P* t2p, TIFF* input){\n\n\tuint64* sbc=NULL;\n#if defined(JPEG_SUPPORT) || defined (OJPEG_SUPPORT)\n\tunsigned char* jpt=NULL;\n\ttstrip_t i=0;\n\ttstrip_t stripcount=0;\n#endif\n        uint64 k = 0;\n\n\tif(t2p->pdf_transcode == T2P_TRANSCODE_RAW){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4 ){\n\t\t\tTIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);\n            if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {\n                TIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\n                t2p->t2p_error = T2P_ERR_ERROR;\n            }\n\t\t\tt2p->tiff_datasize=(tmsize_t)sbc[0];\n\t\t\treturn;\n\t\t}\n#endif\n#ifdef ZIP_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\n\t\t\tTIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);\n            if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {\n                TIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\n                t2p->t2p_error = T2P_ERR_ERROR;\n            }\n\t\t\tt2p->tiff_datasize=(tmsize_t)sbc[0];\n\t\t\treturn;\n\t\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG){\n\t\t\tif(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS\",\n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstripcount=TIFFNumberOfStrips(input);\n\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\tk = checkAdd64(k, sbc[i], t2p);\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGIFOFFSET, &(t2p->tiff_dataoffset))){\n\t\t\t\tif(t2p->tiff_dataoffset != 0){\n\t\t\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGIFBYTECOUNT, &(t2p->tiff_datasize))!=0){\n\t\t\t\t\t\tif((uint64)t2p->tiff_datasize < k) {\n\t\t\t\t\t\t\tTIFFWarning(TIFF2PDF_MODULE, \n\t\t\t\t\t\t\t\t\"Input file %s has short JPEG interchange file byte count\", \n\t\t\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t\tt2p->pdf_ojpegiflength=t2p->tiff_datasize;\n\t\t\t\t\t\t\tk = checkAdd64(k, t2p->tiff_datasize, t2p);\n\t\t\t\t\t\t\tk = checkAdd64(k, 6, t2p);\n\t\t\t\t\t\t\tk = checkAdd64(k, stripcount, t2p);\n\t\t\t\t\t\t\tk = checkAdd64(k, stripcount, t2p);\n\t\t\t\t\t\t\tt2p->tiff_datasize = (tsize_t) k;\n\t\t\t\t\t\t\tif ((uint64) t2p->tiff_datasize != k) {\n\t\t\t\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\n\t\t\t\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\t\t\"Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT\",\n\t\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tk = checkAdd64(k, stripcount, t2p);\n\t\t\tk = checkAdd64(k, stripcount, t2p);\n\t\t\tk = checkAdd64(k, 2048, t2p);\n\t\t\tt2p->tiff_datasize = (tsize_t) k;\n\t\t\tif ((uint64) t2p->tiff_datasize != k) {\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG) {\n\t\t\tuint32 count = 0;\n\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0 ){\n\t\t\t\tif(count > 4){\n\t\t\t\t\tk += count;\n\t\t\t\t\tk -= 2; /* don't use EOI of header */\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tk = 2; /* SOI for first strip */\n\t\t\t}\n\t\t\tstripcount=TIFFNumberOfStrips(input);\n\t\t\tif(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS\",\n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\tk = checkAdd64(k, sbc[i], t2p);\n\t\t\t\tk -=2; /* don't use EOI of strip */\n\t\t\t\tk +=2; /* add space for restart marker */\n\t\t\t}\n\t\t\tk = checkAdd64(k, 2, t2p); /* use EOI of last strip */\n\t\t\tk = checkAdd64(k, 6, t2p); /* for DRI marker of first strip */\n\t\t\tt2p->tiff_datasize = (tsize_t) k;\n\t\t\tif ((uint64) t2p->tiff_datasize != k) {\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n#endif\n\t\t(void) 0;\n\t}\n\tk = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);\n\tif(t2p->tiff_planar==PLANARCONFIG_SEPARATE){\n\t\tk = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);\n\t}\n\tif (k == 0) {\n\t\t/* Assume we had overflow inside TIFFScanlineSize */\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t}\n\n\tt2p->tiff_datasize = (tsize_t) k;\n\tif ((uint64) t2p->tiff_datasize != k) {\n\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t}\n\n\treturn;\n}",
          "fn_code_pos": [
            [
              1943,
              0
            ],
            [
              2081,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_read_tiff_size",
            "parameters": {
              "t2p": "T2P",
              "input": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void t2p_read_tiff_size_tile(T2P* t2p, TIFF* input, ttile_t tile){\n\n\tuint64* tbc = NULL;\n\tuint16 edge=0;\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n#endif\n        uint64 k;\n\n\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\t\n\tif(t2p->pdf_transcode==T2P_TRANSCODE_RAW){\n\t\tif(edge\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n\t\t&& !(t2p->pdf_compression==T2P_COMPRESS_JPEG)\n#endif\n\t\t){\n\t\t\tt2p->tiff_datasize=TIFFTileSize(input);\n\t\t\tif (t2p->tiff_datasize == 0) {\n\t\t\t\t/* Assume we had overflow inside TIFFTileSize */\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tTIFFGetField(input, TIFFTAG_TILEBYTECOUNTS, &tbc);\n\t\t\tk=tbc[tile];\n#ifdef OJPEG_SUPPORT\n\t\t\tif(t2p->tiff_compression==COMPRESSION_OJPEG){\n\t\t\t  \tk = checkAdd64(k, 2048, t2p);\n\t\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\t\tif(t2p->tiff_compression==COMPRESSION_JPEG) {\n\t\t\t\tuint32 count = 0;\n\t\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt)!=0){\n\t\t\t\t\tif(count > 4){\n\t\t\t\t\t\tk = checkAdd64(k, count, t2p);\n\t\t\t\t\t\tk -= 2; /* don't use EOI of header or SOI of tile */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tt2p->tiff_datasize = (tsize_t) k;\n\t\t\tif ((uint64) t2p->tiff_datasize != k) {\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}",
          "fn_code_pos": [
            [
              2088,
              0
            ],
            [
              2138,
              2
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_read_tiff_size_tile",
            "parameters": {
              "t2p": "T2P",
              "input": "TIFF",
              "tile": "ttile_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int t2p_tile_is_right_edge(T2P_TILES tiles, ttile_t tile){\n\n\tif( ((tile+1) % tiles.tiles_tilecountx == 0) \n\t\t&& (tiles.tiles_edgetilewidth != 0) ){\n\t\treturn(1);\n\t} else {\n\t\treturn(0);\n\t}\n}",
          "fn_code_pos": [
            [
              2162,
              0
            ],
            [
              2170,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_tile_is_right_edge",
            "parameters": {
              "tiles": "T2P_TILES",
              "tile": "ttile_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int t2p_tile_is_bottom_edge(T2P_TILES tiles, ttile_t tile){\n\n\tif( ((tile+1) > (tiles.tiles_tilecount-tiles.tiles_tilecountx) )\n\t\t&& (tiles.tiles_edgetilelength != 0) ){\n\t\treturn(1);\n\t} else {\n\t\treturn(0);\n\t}\n}",
          "fn_code_pos": [
            [
              2177,
              0
            ],
            [
              2185,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_tile_is_bottom_edge",
            "parameters": {
              "tiles": "T2P_TILES",
              "tile": "ttile_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int t2p_tile_is_edge(T2P_TILES tiles, ttile_t tile){\n\n\treturn(t2p_tile_is_right_edge(tiles, tile) | t2p_tile_is_bottom_edge(tiles, tile) );\n}",
          "fn_code_pos": [
            [
              2192,
              0
            ],
            [
              2195,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_tile_is_edge",
            "parameters": {
              "tiles": "T2P_TILES",
              "tile": "ttile_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int t2p_tile_is_corner_edge(T2P_TILES tiles, ttile_t tile){\n\n\treturn(t2p_tile_is_right_edge(tiles, tile) & t2p_tile_is_bottom_edge(tiles, tile) );\n}",
          "fn_code_pos": [
            [
              2202,
              0
            ],
            [
              2205,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_tile_is_corner_edge",
            "parameters": {
              "tiles": "T2P_TILES",
              "tile": "ttile_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "tsize_t t2p_readwrite_pdf_image(T2P* t2p, TIFF* input, TIFF* output){\n\n\ttsize_t written=0;\n\tunsigned char* buffer=NULL;\n\tunsigned char* samplebuffer=NULL;\n\ttsize_t bufferoffset=0;\n\ttsize_t samplebufferoffset=0;\n\ttsize_t read=0;\n\ttstrip_t i=0;\n\ttstrip_t j=0;\n\ttstrip_t stripcount=0;\n\ttsize_t stripsize=0;\n\ttsize_t sepstripcount=0;\n\ttsize_t sepstripsize=0;\n#ifdef OJPEG_SUPPORT\n\ttoff_t inputoffset=0;\n\tuint16 h_samp=1;\n\tuint16 v_samp=1;\n\tuint16 ri=1;\n\tuint32 rows=0;\n#endif /* ifdef OJPEG_SUPPORT */\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n\tfloat* xfloatp;\n\tuint64* sbc;\n\tunsigned char* stripbuffer;\n\ttsize_t striplength=0;\n\tuint32 max_striplength=0;\n#endif /* ifdef JPEG_SUPPORT */\n\n\t/* Fail if prior error (in particular, can't trust tiff_datasize) */\n\tif (t2p->t2p_error != T2P_ERR_OK)\n\t\treturn(0);\n\n\tif(t2p->pdf_transcode == T2P_TRANSCODE_RAW){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\n\t\t\tbuffer = (unsigned char*)\n\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif (buffer == NULL) {\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n                                          \"Can't allocate %lu bytes of memory for \"\n                                          \"t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawStrip(input, 0, (tdata_t) buffer,\n\t\t\t\t\t t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\t/*\n\t\t\t\t\t * make sure is lsb-to-msb\n\t\t\t\t\t * bit-endianness fill order\n\t\t\t\t\t */\n\t\t\t\t\tTIFFReverseBits(buffer,\n\t\t\t\t\t\t\tt2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer,\n\t\t\t\t      t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif /* ifdef CCITT_SUPPORT */\n#ifdef ZIP_SUPPORT\n\t\tif (t2p->pdf_compression == T2P_COMPRESS_ZIP) {\n\t\t\tbuffer = (unsigned char*)\n\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer == NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n                        memset(buffer, 0, t2p->tiff_datasize);\n\t\t\tTIFFReadRawStrip(input, 0, (tdata_t) buffer,\n\t\t\t\t\t t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB) {\n\t\t\t\t\tTIFFReverseBits(buffer,\n\t\t\t\t\t\t\tt2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer,\n\t\t\t\t      t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif /* ifdef ZIP_SUPPORT */\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG) {\n\n\t\t\tif(t2p->tiff_dataoffset != 0) {\n\t\t\t\tbuffer = (unsigned char*)\n\t\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\t\tif(buffer == NULL) {\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n                                memset(buffer, 0, t2p->tiff_datasize);\n\t\t\t\tif(t2p->pdf_ojpegiflength==0){\n\t\t\t\t\tinputoffset=t2pSeekFile(input, 0,\n\t\t\t\t\t\t\t\t SEEK_CUR);\n\t\t\t\t\tt2pSeekFile(input,\n\t\t\t\t\t\t     t2p->tiff_dataoffset,\n\t\t\t\t\t\t     SEEK_SET);\n\t\t\t\t\tt2pReadFile(input, (tdata_t) buffer,\n\t\t\t\t\t\t     t2p->tiff_datasize);\n\t\t\t\t\tt2pSeekFile(input, inputoffset,\n\t\t\t\t\t\t     SEEK_SET);\n\t\t\t\t\tt2pWriteFile(output, (tdata_t) buffer,\n\t\t\t\t\t\t      t2p->tiff_datasize);\n\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\treturn(t2p->tiff_datasize);\n\t\t\t\t} else {\n\t\t\t\t\tinputoffset=t2pSeekFile(input, 0,\n\t\t\t\t\t\t\t\t SEEK_CUR);\n\t\t\t\t\tt2pSeekFile(input,\n\t\t\t\t\t\t     t2p->tiff_dataoffset,\n\t\t\t\t\t\t     SEEK_SET);\n\t\t\t\t\tbufferoffset = t2pReadFile(input,\n\t\t\t\t\t\t(tdata_t) buffer,\n\t\t\t\t\t\tt2p->pdf_ojpegiflength);\n\t\t\t\t\tt2p->pdf_ojpegiflength = 0;\n\t\t\t\t\tt2pSeekFile(input, inputoffset,\n\t\t\t\t\t\t     SEEK_SET);\n\t\t\t\t\tTIFFGetField(input,\n\t\t\t\t\t\t     TIFFTAG_YCBCRSUBSAMPLING,\n\t\t\t\t\t\t     &h_samp, &v_samp);\n\t\t\t\t\tbuffer[bufferoffset++]= 0xff;\n\t\t\t\t\tbuffer[bufferoffset++]= 0xdd;\n\t\t\t\t\tbuffer[bufferoffset++]= 0x00;\n\t\t\t\t\tbuffer[bufferoffset++]= 0x04;\n\t\t\t\t\th_samp*=8;\n\t\t\t\t\tv_samp*=8;\n\t\t\t\t\tri=(t2p->tiff_width+h_samp-1) / h_samp;\n\t\t\t\t\tTIFFGetField(input,\n\t\t\t\t\t\t     TIFFTAG_ROWSPERSTRIP,\n\t\t\t\t\t\t     &rows);\n\t\t\t\t\tri*=(rows+v_samp-1)/v_samp;\n\t\t\t\t\tbuffer[bufferoffset++]= (ri>>8) & 0xff;\n\t\t\t\t\tbuffer[bufferoffset++]= ri & 0xff;\n\t\t\t\t\tstripcount=TIFFNumberOfStrips(input);\n\t\t\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\t\t\tif(i != 0 ){ \n\t\t\t\t\t\t\tbuffer[bufferoffset++]=0xff;\n\t\t\t\t\t\t\tbuffer[bufferoffset++]=(0xd0 | ((i-1)%8));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbufferoffset+=TIFFReadRawStrip(input, \n\t\t\t\t\t\t\ti, \n\t\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t\t-1);\n\t\t\t\t\t}\n\t\t\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\treturn(bufferoffset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(! t2p->pdf_ojpegdata){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"No support for OJPEG image %s with bad tables\", \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tbuffer = (unsigned char*)\n\t\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\t\tif(buffer==NULL){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n                                memset(buffer, 0, t2p->tiff_datasize);\n\t\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\n\t\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\n\t\t\t\tstripcount=TIFFNumberOfStrips(input);\n\t\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\t\tif(i != 0){\n\t\t\t\t\t\tbuffer[bufferoffset++]=0xff;\n\t\t\t\t\t\tbuffer[bufferoffset++]=(0xd0 | ((i-1)%8));\n\t\t\t\t\t}\n\t\t\t\t\tbufferoffset+=TIFFReadRawStrip(input, \n\t\t\t\t\t\ti, \n\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t-1);\n\t\t\t\t}\n\t\t\t\tif( ! ( (buffer[bufferoffset-1]==0xd9) && (buffer[bufferoffset-2]==0xff) ) ){\n\t\t\t\t\t\tbuffer[bufferoffset++]=0xff;\n\t\t\t\t\t\tbuffer[bufferoffset++]=0xd9;\n\t\t\t\t}\n\t\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\treturn(bufferoffset);\n#if 0\n                                /*\n                                  This hunk of code removed code is clearly\n                                  mis-placed and we are not sure where it\n                                  should be (if anywhere)\n                                */\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"No support for OJPEG image %s with no JPEG File Interchange offset\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n#endif\n\t\t\t}\n\t\t}\n#endif /* ifdef OJPEG_SUPPORT */\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG) {\n\t\t\tuint32 count = 0;\n\t\t\tbuffer = (unsigned char*)\n\t\t\t\t_TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n                        memset(buffer, 0, t2p->tiff_datasize);\n\t\t\tif (TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n\t\t\t\tif(count > 4) {\n\t\t\t\t\t_TIFFmemcpy(buffer, jpt, count);\n\t\t\t\t\tbufferoffset += count - 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstripcount=TIFFNumberOfStrips(input);\n\t\t\tTIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);\n\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\tif(sbc[i]>max_striplength) max_striplength=sbc[i];\n\t\t\t}\n\t\t\tstripbuffer = (unsigned char*)\n\t\t\t\t_TIFFmalloc(max_striplength);\n\t\t\tif(stripbuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %u bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\tmax_striplength, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\tstriplength=TIFFReadRawStrip(input, i, (tdata_t) stripbuffer, -1);\n\t\t\t\tif(!t2p_process_jpeg_strip(\n\t\t\t\t\tstripbuffer, \n\t\t\t\t\t&striplength, \n\t\t\t\t\tbuffer,\n                    t2p->tiff_datasize,\n\t\t\t\t\t&bufferoffset, \n\t\t\t\t\ti, \n\t\t\t\t\tt2p->tiff_length)){\n\t\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Can't process JPEG data in input file %s\", \n\t\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuffer[bufferoffset++]=0xff; \n\t\t\tbuffer[bufferoffset++]=0xd9;\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(stripbuffer);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif /* ifdef JPEG_SUPPORT */\n\t\t(void)0;\n\t}\n\n\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n                memset(buffer, 0, t2p->tiff_datasize);\n\t\tstripsize=TIFFStripSize(input);\n\t\tstripcount=TIFFNumberOfStrips(input);\n\t\tfor(i=0;i<stripcount;i++){\n\t\t\tread = \n\t\t\t\tTIFFReadEncodedStrip(input, \n\t\t\t\ti, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tTIFFmin(stripsize, t2p->tiff_datasize - bufferoffset));\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding strip %u of %s\", \n\t\t\t\t\ti, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbufferoffset+=read;\n\t\t}\n\t} else {\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\n\t\t\n\t\t\tsepstripsize=TIFFStripSize(input);\n\t\t\tsepstripcount=TIFFNumberOfStrips(input);\n\t\t\n\t\t\tstripsize=sepstripsize*t2p->tiff_samplesperpixel;\n\t\t\tstripcount=sepstripcount/t2p->tiff_samplesperpixel;\n\t\t\t\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n                        memset(buffer, 0, t2p->tiff_datasize);\n\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(stripsize);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n                                _TIFFfree(buffer);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tfor(i=0;i<stripcount;i++){\n\t\t\t\tsamplebufferoffset=0;\n\t\t\t\tfor(j=0;j<t2p->tiff_samplesperpixel;j++){\n\t\t\t\t\tread = \n\t\t\t\t\t\tTIFFReadEncodedStrip(input, \n\t\t\t\t\t\t\ti + j*stripcount, \n\t\t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \n\t\t\t\t\t\t\tTIFFmin(sepstripsize, stripsize - samplebufferoffset));\n\t\t\t\t\tif(read==-1){\n\t\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding strip %u of %s\", \n\t\t\t\t\t\t\ti + j*stripcount, \n\t\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\t}\n\t\t\t\t\tsamplebufferoffset+=read;\n\t\t\t\t}\n\t\t\t\tt2p_sample_planar_separate_to_contig(\n\t\t\t\t\tt2p,\n\t\t\t\t\t&(buffer[bufferoffset]),\n\t\t\t\t\tsamplebuffer, \n\t\t\t\t\tsamplebufferoffset); \n\t\t\t\tbufferoffset+=samplebufferoffset;\n\t\t\t}\n\t\t\t_TIFFfree(samplebuffer);\n\t\t\tgoto dataready;\n\t\t}\n\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n                memset(buffer, 0, t2p->tiff_datasize);\n\t\tstripsize=TIFFStripSize(input);\n\t\tstripcount=TIFFNumberOfStrips(input);\n\t\tfor(i=0;i<stripcount;i++){\n\t\t\tread = \n\t\t\t\tTIFFReadEncodedStrip(input, \n\t\t\t\ti, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tTIFFmin(stripsize, t2p->tiff_datasize - bufferoffset));\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding strip %u of %s\", \n\t\t\t\t\ti, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbufferoffset+=read;\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){\n\t\t\t// FIXME: overflow?\n\t\t\tsamplebuffer=(unsigned char*)_TIFFrealloc( \n\t\t\t\t(tdata_t) buffer, \n\t\t\t\tt2p->tiff_datasize * t2p->tiff_samplesperpixel);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\treturn(0);\n\t\t\t} else {\n\t\t\t\tbuffer=samplebuffer;\n\t\t\t\tt2p->tiff_datasize *= t2p->tiff_samplesperpixel;\n\t\t\t}\n\t\t\tt2p_sample_realize_palette(t2p, buffer);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\n\t\t\tsamplebuffer=(unsigned char*)_TIFFrealloc(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length*4);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\treturn(0);\n\t\t\t} else {\n\t\t\t\tbuffer=samplebuffer;\n\t\t\t}\n\t\t\tif(!TIFFReadRGBAImageOriented(\n\t\t\t\tinput, \n\t\t\t\tt2p->tiff_width, \n\t\t\t\tt2p->tiff_length, \n\t\t\t\t(uint32*)buffer, \n\t\t\t\tORIENTATION_TOPLEFT,\n\t\t\t\t0)){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\"Can't use TIFFReadRGBAImageOriented to extract RGB image from %s\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tt2p->tiff_datasize=t2p_sample_abgr_to_rgb(\n\t\t\t\t(tdata_t) buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length);\n\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\n\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_width*t2p->tiff_length);\n\t\t}\n\t}\n\ndataready:\n\n\tt2p_disable(output);\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\n\tTIFFSetField(output, TIFFTAG_IMAGEWIDTH, t2p->tiff_width);\n\tTIFFSetField(output, TIFFTAG_IMAGELENGTH, t2p->tiff_length);\n\tTIFFSetField(output, TIFFTAG_ROWSPERSTRIP, t2p->tiff_length);\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n\tswitch(t2p->pdf_compression){\n\tcase T2P_COMPRESS_NONE:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tbreak;\n#ifdef CCITT_SUPPORT\n\tcase T2P_COMPRESS_G4:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n\t\tbreak;\n#endif /* ifdef CCITT_SUPPORT */\n#ifdef JPEG_SUPPORT\n\tcase T2P_COMPRESS_JPEG:\n\t\tif(t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\n\t\t\tuint16 hor = 0, ver = 0;\n\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver) !=0 ) {\n\t\t\t\tif(hor != 0 && ver != 0){\n\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\n\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\n\t\t\t}\n\t\t}\n\t\tif(TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG)==0){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\"Unable to use JPEG compression for input %s and output %s\", \n\t\t\t\tTIFFFileName(input),\n\t\t\t\tTIFFFileName(output));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0);\n\n\t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\n\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t} else {\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n\t\t\t}\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_JPEGQUALITY, \n\t\t\t\tt2p->pdf_defaultcompressionquality);\n\t\t}\n\t\n\t\tbreak;\n#endif /* ifdef JPEG_SUPPORT */\n#ifdef ZIP_SUPPORT\n\tcase T2P_COMPRESS_ZIP:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_PREDICTOR, \n\t\t\t\tt2p->pdf_defaultcompressionquality % 100);\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality/100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_ZIPQUALITY, \n\t\t\t\t(t2p->pdf_defaultcompressionquality / 100));\n\t\t}\n\t\tbreak;\n#endif /* ifdef ZIP_SUPPORT */\n\tdefault:\n\t\tbreak;\n\t}\n\n\tt2p_enable(output);\n\tt2p->outputwritten = 0;\n#ifdef JPEG_SUPPORT\n\tif(t2p->pdf_compression == T2P_COMPRESS_JPEG\n\t   && t2p->tiff_photometric == PHOTOMETRIC_YCBCR){\n\t\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,\n\t\t\t\t\t\t     buffer,\n\t\t\t\t\t\t     stripsize * stripcount); \n\t} else\n#endif /* ifdef JPEG_SUPPORT */\n        {\n\t\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,\n\t\t\t\t\t\t     buffer,\n\t\t\t\t\t\t     t2p->tiff_datasize); \n\t}\n\tif (buffer != NULL) {\n\t\t_TIFFfree(buffer);\n\t\tbuffer=NULL;\n\t}\n\n\tif (bufferoffset == (tsize_t)-1) {\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t  \"Error writing encoded strip to output PDF %s\", \n\t\t\t  TIFFFileName(output));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\t\n\twritten = t2p->outputwritten;\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              2214,
              0
            ],
            [
              2804,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_readwrite_pdf_image",
            "parameters": {
              "t2p": "T2P",
              "input": "TIFF",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){\n\n\tuint16 edge=0;\n\ttsize_t written=0;\n\tunsigned char* buffer=NULL;\n\ttsize_t bufferoffset=0;\n\tunsigned char* samplebuffer=NULL;\n\ttsize_t samplebufferoffset=0;\n\ttsize_t read=0;\n\tuint16 i=0;\n\tttile_t tilecount=0;\n\t/* tsize_t tilesize=0; */\n\tttile_t septilecount=0;\n\ttsize_t septilesize=0;\n#ifdef JPEG_SUPPORT\n\tunsigned char* jpt;\n\tfloat* xfloatp;\n\tuint32 xuint32=0;\n#endif\n\n\t/* Fail if prior error (in particular, can't trust tiff_datasize) */\n\tif (t2p->t2p_error != T2P_ERR_OK)\n\t\treturn(0);\n\n\tedge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\tedge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);\n\n\tif( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n\t\t|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)\n#endif\n\t)\n\t){\n#ifdef CCITT_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_G4){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef ZIP_SUPPORT\n\t\tif(t2p->pdf_compression == T2P_COMPRESS_ZIP){\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tTIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\tif (t2p->tiff_fillorder==FILLORDER_LSB2MSB){\n\t\t\t\t\tTIFFReverseBits(buffer, t2p->tiff_datasize);\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(t2p->tiff_datasize);\n\t\t}\n#endif\n#ifdef OJPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_OJPEG){\n\t\t\tif(! t2p->pdf_ojpegdata){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"No support for OJPEG image %s with \"\n                                        \"bad tables\", \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tbuffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\t_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);\n\t\t\tif(edge!=0){\n\t\t\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[7]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;\n\t\t\t\t\tbuffer[8]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;\n\t\t\t\t}\n\t\t\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){\n\t\t\t\t\tbuffer[9]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;\n\t\t\t\t\tbuffer[10]=\n\t\t\t\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbufferoffset=t2p->pdf_ojpegdatalength;\n\t\t\tbufferoffset+=TIFFReadRawTile(input, \n\t\t\t\t\ttile, \n\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t-1);\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xff;\n\t\t\t((unsigned char*)buffer)[bufferoffset++]=0xd9;\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n#ifdef JPEG_SUPPORT\n\t\tif(t2p->tiff_compression == COMPRESSION_JPEG){\n\t\t\tunsigned char table_end[2];\n\t\t\tuint32 count = 0;\n\t\t\tbuffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate \" TIFF_SIZE_FORMAT \" bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n                                          (TIFF_SIZE_T) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n\t\t\t\tif (count > 4) {\n                                        int retTIFFReadRawTile;\n                    /* Ignore EOI marker of JpegTables */\n\t\t\t\t\t_TIFFmemcpy(buffer, jpt, count - 2);\n\t\t\t\t\tbufferoffset += count - 2;\n                    /* Store last 2 bytes of the JpegTables */\n\t\t\t\t\ttable_end[0] = buffer[bufferoffset-2];\n\t\t\t\t\ttable_end[1] = buffer[bufferoffset-1];\n\t\t\t\t\txuint32 = bufferoffset;\n                                        bufferoffset -= 2;\n                                        retTIFFReadRawTile= TIFFReadRawTile(\n\t\t\t\t\t\tinput, \n\t\t\t\t\t\ttile, \n\t\t\t\t\t\t(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), \n\t\t\t\t\t\t-1);\n                                        if( retTIFFReadRawTile < 0 )\n                                        {\n                                            _TIFFfree(buffer);\n                                            t2p->t2p_error = T2P_ERR_ERROR;\n                                            return(0);\n                                        }\n\t\t\t\t\tbufferoffset += retTIFFReadRawTile;\n                    /* Overwrite SOI marker of image scan with previously */\n                    /* saved end of JpegTables */\n\t\t\t\t\tbuffer[xuint32-2]=table_end[0];\n\t\t\t\t\tbuffer[xuint32-1]=table_end[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tt2pWriteFile(output, (tdata_t) buffer, bufferoffset);\n\t\t\t_TIFFfree(buffer);\n\t\t\treturn(bufferoffset);\n\t\t}\n#endif\n\t\t(void)0;\n\t}\n\n\tif(t2p->pdf_sample==T2P_SAMPLE_NOTHING){\n\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\tif(buffer==NULL){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Can't allocate %lu bytes of memory for \"\n                                \"t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tread = TIFFReadEncodedTile(\n\t\t\tinput, \n\t\t\ttile, \n\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\tt2p->tiff_datasize);\n\t\tif(read==-1){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\ttile, \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t} else {\n\n\t\tif(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){\n\t\t\tseptilesize=TIFFTileSize(input);\n\t\t\tseptilecount=TIFFNumberOfTiles(input);\n\t\t\t/* tilesize=septilesize*t2p->tiff_samplesperpixel; */\n\t\t\ttilecount=septilecount/t2p->tiff_samplesperpixel;\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(samplebuffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tsamplebufferoffset=0;\n\t\t\tfor(i=0;i<t2p->tiff_samplesperpixel;i++){\n\t\t\t\tread = \n\t\t\t\t\tTIFFReadEncodedTile(input, \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\t(tdata_t) &(samplebuffer[samplebufferoffset]), \n\t\t\t\t\t\tseptilesize);\n\t\t\t\tif(read==-1){\n\t\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\t\ttile + i*tilecount, \n\t\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t\t\t_TIFFfree(samplebuffer);\n\t\t\t\t\t\t_TIFFfree(buffer);\n\t\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t\tsamplebufferoffset+=read;\n\t\t\t}\n\t\t\tt2p_sample_planar_separate_to_contig(\n\t\t\t\tt2p,\n\t\t\t\t&(buffer[bufferoffset]),\n\t\t\t\tsamplebuffer, \n\t\t\t\tsamplebufferoffset); \n\t\t\tbufferoffset+=samplebufferoffset;\n\t\t\t_TIFFfree(samplebuffer);\n\t\t}\n\n\t\tif(buffer==NULL){\n\t\t\tbuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);\n\t\t\tif(buffer==NULL){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Can't allocate %lu bytes of memory \"\n                                        \"for t2p_readwrite_pdf_image_tile, %s\", \n\t\t\t\t\t(unsigned long) t2p->tiff_datasize, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tread = TIFFReadEncodedTile(\n\t\t\t\tinput, \n\t\t\t\ttile, \n\t\t\t\t(tdata_t) &buffer[bufferoffset], \n\t\t\t\tt2p->tiff_datasize);\n\t\t\tif(read==-1){\n\t\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\t\"Error on decoding tile %u of %s\", \n\t\t\t\t\ttile, \n\t\t\t\t\tTIFFFileName(input));\n\t\t\t\t_TIFFfree(buffer);\n\t\t\t\tt2p->t2p_error=T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgba_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){\n\t\t\tt2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"No support for YCbCr to RGB in tile for %s\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t_TIFFfree(buffer);\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\n\t\tif(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){\n\t\t\tt2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(\n\t\t\t\t(tdata_t)buffer, \n\t\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth\n\t\t\t\t*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\t}\n\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){\n\t\tt2p_tile_collapse_left(\n\t\t\tbuffer, \n\t\t\tTIFFTileRowSize(input),\n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,\n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t}\n\n\n\tt2p_disable(output);\n\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);\n\tTIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);\n\tTIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);\n\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGEWIDTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\n\t}\n\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t} else {\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_IMAGELENGTH, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t\tTIFFSetField(\n\t\t\toutput, \n\t\t\tTIFFTAG_ROWSPERSTRIP, \n\t\t\tt2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t}\n\tTIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);\n\n\tswitch(t2p->pdf_compression){\n\tcase T2P_COMPRESS_NONE:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t\tbreak;\n#ifdef CCITT_SUPPORT\n\tcase T2P_COMPRESS_G4:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);\n\t\tbreak;\n#endif\n#ifdef JPEG_SUPPORT\n\tcase T2P_COMPRESS_JPEG:\n\t\tif (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {\n\t\t\tuint16 hor = 0, ver = 0;\n\t\t\tif (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {\n\t\t\t\tif (hor != 0 && ver != 0) {\n\t\t\t\t\tTIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){\n\t\t\t\tTIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);\n\t\t\t}\n\t\t}\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n\t\tTIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); /* JPEGTABLESMODE_NONE */\n\t\tif(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){\n\t\t\tTIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t} else {\n\t\t\t\tTIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);\n\t\t\t}\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\t(void)0;\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_JPEGQUALITY, \n\t\t\t\tt2p->pdf_defaultcompressionquality);\n\t\t}\n\t\tbreak;\n#endif\n#ifdef ZIP_SUPPORT\n\tcase T2P_COMPRESS_ZIP:\n\t\tTIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);\n\t\tif(t2p->pdf_defaultcompressionquality%100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_PREDICTOR, \n\t\t\t\tt2p->pdf_defaultcompressionquality % 100);\n\t\t}\n\t\tif(t2p->pdf_defaultcompressionquality/100 != 0){\n\t\t\tTIFFSetField(output, \n\t\t\t\tTIFFTAG_ZIPQUALITY, \n\t\t\t\t(t2p->pdf_defaultcompressionquality / 100));\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tt2p_enable(output);\n\tt2p->outputwritten = 0;\n\tbufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,\n\t\t\t\t\t     TIFFStripSize(output)); \n\tif (buffer != NULL) {\n\t\t_TIFFfree(buffer);\n\t\tbuffer = NULL;\n\t}\n\tif (bufferoffset == -1) {\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t  \"Error writing encoded tile to output PDF %s\", \n\t\t\t  TIFFFileName(output));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\t\n\twritten = t2p->outputwritten;\n\t\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              2812,
              0
            ],
            [
              3256,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_readwrite_pdf_image_tile",
            "parameters": {
              "t2p": "T2P",
              "input": "TIFF",
              "output": "TIFF",
              "tile": "ttile_t"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "int t2p_process_ojpeg_tables(T2P* t2p, TIFF* input){\n\tuint16 proc=0;\n\tvoid* q;\n\tuint32 q_length=0;\n\tvoid* dc;\n\tuint32 dc_length=0;\n\tvoid* ac;\n\tuint32 ac_length=0;\n\tuint16* lp;\n\tuint16* pt;\n\tuint16 h_samp=1;\n\tuint16 v_samp=1;\n\tunsigned char* ojpegdata;\n\tuint16 table_count;\n\tuint32 offset_table;\n\tuint32 offset_ms_l;\n\tuint32 code_count;\n\tuint32 i=0;\n\tuint32 dest=0;\n\tuint16 ri=0;\n\tuint32 rows=0;\n\t\n\tif(!TIFFGetField(input, TIFFTAG_JPEGPROC, &proc)){\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\"Missing JPEGProc field in OJPEG image %s\", \n\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\tif(proc!=JPEGPROC_BASELINE && proc!=JPEGPROC_LOSSLESS){\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\"Bad JPEGProc field in OJPEG image %s\", \n\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\tif(!TIFFGetField(input, TIFFTAG_JPEGQTABLES, &q_length, &q)){\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\"Missing JPEGQTables field in OJPEG image %s\", \n\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\tif(q_length < (64U * t2p->tiff_samplesperpixel)){\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\"Bad JPEGQTables field in OJPEG image %s\", \n\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t} \n\tif(!TIFFGetField(input, TIFFTAG_JPEGDCTABLES, &dc_length, &dc)){\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\"Missing JPEGDCTables field in OJPEG image %s\", \n\t\t\tTIFFFileName(input));\n\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\tif(proc==JPEGPROC_BASELINE){\n\t\tif(!TIFFGetField(input, TIFFTAG_JPEGACTABLES, &ac_length, &ac)){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Missing JPEGACTables field in OJPEG image %s\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\t} else {\n\t\tif(!TIFFGetField(input, TIFFTAG_JPEGLOSSLESSPREDICTORS, &lp)){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Missing JPEGLosslessPredictors field in OJPEG image %s\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\t\treturn(0);\n\t\t}\n\t\tif(!TIFFGetField(input, TIFFTAG_JPEGPOINTTRANSFORM, &pt)){\n\t\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\t\"Missing JPEGPointTransform field in OJPEG image %s\", \n\t\t\t\tTIFFFileName(input));\n\t\t\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\t\treturn(0);\n\t\t}\n\t}\n\tif(!TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &h_samp, &v_samp)){\n\t\th_samp=1;\n\t\tv_samp=1;\n\t}\n\tif(t2p->pdf_ojpegdata != NULL){\n\t\t_TIFFfree(t2p->pdf_ojpegdata);\n\t\tt2p->pdf_ojpegdata=NULL;\n\t} \n\tt2p->pdf_ojpegdata = _TIFFmalloc(2048);\n\tif(t2p->pdf_ojpegdata == NULL){\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\"Can't allocate %u bytes of memory for t2p_process_ojpeg_tables, %s\", \n\t\t\t2048, \n\t\t\tTIFFFileName(input));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(0);\n\t}\n\t_TIFFmemset(t2p->pdf_ojpegdata, 0x00, 2048);\n\tt2p->pdf_ojpegdatalength = 0;\n\ttable_count=t2p->tiff_samplesperpixel;\n\tif(proc==JPEGPROC_BASELINE){\n\t\tif(table_count>2) table_count=2;\n\t}\n\tojpegdata=(unsigned char*)t2p->pdf_ojpegdata;\n\tojpegdata[t2p->pdf_ojpegdatalength++]=0xff;\n\tojpegdata[t2p->pdf_ojpegdatalength++]=0xd8;\n\tojpegdata[t2p->pdf_ojpegdatalength++]=0xff;\n\tif(proc==JPEGPROC_BASELINE){\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xc0;\n\t} else {\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xc3;\n\t}\n\tojpegdata[t2p->pdf_ojpegdatalength++]=0x00;\n\tojpegdata[t2p->pdf_ojpegdatalength++]=(8 + 3*t2p->tiff_samplesperpixel);\n\tojpegdata[t2p->pdf_ojpegdatalength++]=(t2p->tiff_bitspersample & 0xff);\n\tif(TIFFIsTiled(input)){\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=\n\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength >> 8) & 0xff;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=\n\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength ) & 0xff;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=\n\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth >> 8) & 0xff;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=\n\t\t\t(t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth ) & 0xff;\n\t} else {\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=\n\t\t\t(t2p->tiff_length >> 8) & 0xff;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=\n\t\t\t(t2p->tiff_length ) & 0xff;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=\n\t\t\t(t2p->tiff_width >> 8) & 0xff;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=\n\t\t\t(t2p->tiff_width ) & 0xff;\n\t}\n\tojpegdata[t2p->pdf_ojpegdatalength++]=(t2p->tiff_samplesperpixel & 0xff);\n\tfor(i=0;i<t2p->tiff_samplesperpixel;i++){\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=i;\n\t\tif(i==0){\n\t\t\tojpegdata[t2p->pdf_ojpegdatalength] |= h_samp<<4 & 0xf0;;\n\t\t\tojpegdata[t2p->pdf_ojpegdatalength++] |= v_samp & 0x0f;\n\t\t} else {\n\t\t\t\tojpegdata[t2p->pdf_ojpegdatalength++]= 0x11;\n\t\t}\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=i;\n\t}\n\tfor(dest=0;dest<t2p->tiff_samplesperpixel;dest++){\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xff;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xdb;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0x00;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0x43;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=dest;\n\t\t_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength++]), \n\t\t\t&(((unsigned char*)q)[64*dest]), 64);\n\t\tt2p->pdf_ojpegdatalength+=64;\n\t}\n\toffset_table=0;\n\tfor(dest=0;dest<table_count;dest++){\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xff;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xc4;\n\t\toffset_ms_l=t2p->pdf_ojpegdatalength;\n\t\tt2p->pdf_ojpegdatalength+=2;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=dest & 0x0f;\n\t\t_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), \n\t\t\t&(((unsigned char*)dc)[offset_table]), 16);\n\t\tcode_count=0;\n\t\toffset_table+=16;\n\t\tfor(i=0;i<16;i++){\n\t\t\tcode_count+=ojpegdata[t2p->pdf_ojpegdatalength++];\n\t\t}\n\t\tojpegdata[offset_ms_l]=((19+code_count)>>8) & 0xff;\n\t\tojpegdata[offset_ms_l+1]=(19+code_count) & 0xff;\n\t\t_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), \n\t\t\t&(((unsigned char*)dc)[offset_table]), code_count);\n\t\toffset_table+=code_count;\n\t\tt2p->pdf_ojpegdatalength+=code_count;\n\t}\n\tif(proc==JPEGPROC_BASELINE){\n\toffset_table=0;\n\t\tfor(dest=0;dest<table_count;dest++){\n\t\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xff;\n\t\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xc4;\n\t\t\toffset_ms_l=t2p->pdf_ojpegdatalength;\n\t\t\tt2p->pdf_ojpegdatalength+=2;\n\t\t\tojpegdata[t2p->pdf_ojpegdatalength] |= 0x10;\n\t\t\tojpegdata[t2p->pdf_ojpegdatalength++] |=dest & 0x0f;\n\t\t\t_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), \n\t\t\t\t&(((unsigned char*)ac)[offset_table]), 16);\n\t\t\tcode_count=0;\n\t\t\toffset_table+=16;\n\t\t\tfor(i=0;i<16;i++){\n\t\t\t\tcode_count+=ojpegdata[t2p->pdf_ojpegdatalength++];\n\t\t\t}\t\n\t\t\tojpegdata[offset_ms_l]=((19+code_count)>>8) & 0xff;\n\t\t\tojpegdata[offset_ms_l+1]=(19+code_count) & 0xff;\n\t\t\t_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), \n\t\t\t\t&(((unsigned char*)ac)[offset_table]), code_count);\n\t\t\toffset_table+=code_count;\n\t\t\tt2p->pdf_ojpegdatalength+=code_count;\n\t\t}\n\t}\n\tif(TIFFNumberOfStrips(input)>1){\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xff;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0xdd;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0x00;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0x04;\n\t\th_samp*=8;\n\t\tv_samp*=8;\n\t\tri=(t2p->tiff_width+h_samp-1) / h_samp;\n\t\tTIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rows);\n\t\tri*=(rows+v_samp-1)/v_samp;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]= (ri>>8) & 0xff;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]= ri & 0xff;\n\t}\n\tojpegdata[t2p->pdf_ojpegdatalength++]=0xff;\n\tojpegdata[t2p->pdf_ojpegdatalength++]=0xda;\n\tojpegdata[t2p->pdf_ojpegdatalength++]=0x00;\n\tojpegdata[t2p->pdf_ojpegdatalength++]=(6 + 2*t2p->tiff_samplesperpixel);\n\tojpegdata[t2p->pdf_ojpegdatalength++]=t2p->tiff_samplesperpixel & 0xff;\n\tfor(i=0;i<t2p->tiff_samplesperpixel;i++){\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]= i & 0xff;\n\t\tif(proc==JPEGPROC_BASELINE){\n\t\t\tojpegdata[t2p->pdf_ojpegdatalength] |= \n\t\t\t\t( ( (i>(table_count-1U)) ? (table_count-1U) : i) << 4U) & 0xf0;\n\t\t\tojpegdata[t2p->pdf_ojpegdatalength++] |= \n\t\t\t\t( (i>(table_count-1U)) ? (table_count-1U) : i) & 0x0f;\n\t\t} else {\n\t\t\tojpegdata[t2p->pdf_ojpegdatalength++] =  (i << 4) & 0xf0;\n\t\t}\n\t}\n\tif(proc==JPEGPROC_BASELINE){\n\t\tt2p->pdf_ojpegdatalength++;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]=0x3f;\n\t\tt2p->pdf_ojpegdatalength++;\n\t} else {\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]= (lp[0] & 0xff);\n\t\tt2p->pdf_ojpegdatalength++;\n\t\tojpegdata[t2p->pdf_ojpegdatalength++]= (pt[0] & 0x0f);\n\t}\n\n\treturn(1);\n}",
          "fn_code_pos": [
            [
              3259,
              0
            ],
            [
              3500,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_process_ojpeg_tables",
            "parameters": {
              "t2p": "T2P",
              "input": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int t2p_process_jpeg_strip(\n\tunsigned char* strip, \n\ttsize_t* striplength, \n\tunsigned char* buffer, \n    tsize_t buffersize,\n\ttsize_t* bufferoffset, \n\ttstrip_t no, \n\tuint32 height){\n\n\ttsize_t i=0;\n\n\twhile (i < *striplength) {\n\t\ttsize_t datalen;\n\t\tuint16 ri;\n\t\tuint16 v_samp;\n\t\tuint16 h_samp;\n\t\tint j;\n\t\tint ncomp;\n\n\t\t/* marker header: one or more FFs */\n\t\tif (strip[i] != 0xff)\n\t\t\treturn(0);\n\t\ti++;\n\t\twhile (i < *striplength && strip[i] == 0xff)\n\t\t\ti++;\n\t\tif (i >= *striplength)\n\t\t\treturn(0);\n\t\t/* SOI is the only pre-SOS marker without a length word */\n\t\tif (strip[i] == 0xd8)\n\t\t\tdatalen = 0;\n\t\telse {\n\t\t\tif ((*striplength - i) <= 2)\n\t\t\t\treturn(0);\n\t\t\tdatalen = (strip[i+1] << 8) | strip[i+2];\n\t\t\tif (datalen < 2 || datalen >= (*striplength - i))\n\t\t\t\treturn(0);\n\t\t}\n\t\tswitch( strip[i] ){\n\t\t\tcase 0xd8:\t/* SOI - start of image */\n                if( *bufferoffset + 2 > buffersize )\n                    return(0);\n\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), 2);\n\t\t\t\t*bufferoffset+=2;\n\t\t\t\tbreak;\n\t\t\tcase 0xc0:\t/* SOF0 */\n\t\t\tcase 0xc1:\t/* SOF1 */\n\t\t\tcase 0xc3:\t/* SOF3 */\n\t\t\tcase 0xc9:\t/* SOF9 */\n\t\t\tcase 0xca:\t/* SOF10 */\n\t\t\t\tif(no==0){\n                    if( *bufferoffset + datalen + 2 + 6 > buffersize )\n                        return(0);\n\t\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\n                    if( *bufferoffset + 9 >= buffersize )\n                        return(0);\n\t\t\t\t\tncomp = buffer[*bufferoffset+9];\n\t\t\t\t\tif (ncomp < 1 || ncomp > 4)\n\t\t\t\t\t\treturn(0);\n\t\t\t\t\tv_samp=1;\n\t\t\t\t\th_samp=1;\n                    if( *bufferoffset + 11 + 3*(ncomp-1) >= buffersize )\n                        return(0);\n\t\t\t\t\tfor(j=0;j<ncomp;j++){\n\t\t\t\t\t\tuint16 samp = buffer[*bufferoffset+11+(3*j)];\n\t\t\t\t\t\tif( (samp>>4) > h_samp) \n\t\t\t\t\t\t\th_samp = (samp>>4);\n\t\t\t\t\t\tif( (samp & 0x0f) > v_samp) \n\t\t\t\t\t\t\tv_samp = (samp & 0x0f);\n\t\t\t\t\t}\n\t\t\t\t\tv_samp*=8;\n\t\t\t\t\th_samp*=8;\n\t\t\t\t\tri=((( ((uint16)(buffer[*bufferoffset+5])<<8) | \n\t\t\t\t\t(uint16)(buffer[*bufferoffset+6]) )+v_samp-1)/ \n\t\t\t\t\tv_samp);\n\t\t\t\t\tri*=((( ((uint16)(buffer[*bufferoffset+7])<<8) | \n\t\t\t\t\t(uint16)(buffer[*bufferoffset+8]) )+h_samp-1)/ \n\t\t\t\t\th_samp);\n\t\t\t\t\tbuffer[*bufferoffset+5]=\n                                          (unsigned char) ((height>>8) & 0xff);\n\t\t\t\t\tbuffer[*bufferoffset+6]=\n                                            (unsigned char) (height & 0xff);\n\t\t\t\t\t*bufferoffset+=datalen+2;\n\t\t\t\t\t/* insert a DRI marker */\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0xff;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0xdd;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0x00;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0x04;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=(ri >> 8) & 0xff;\n\t\t\t\t\tbuffer[(*bufferoffset)++]= ri & 0xff;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 0xc4: /* DHT */\n\t\t\tcase 0xdb: /* DQT */\n                if( *bufferoffset + datalen + 2 > buffersize )\n                    return(0);\n\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\n\t\t\t\t*bufferoffset+=datalen+2;\n\t\t\t\tbreak;\n\t\t\tcase 0xda: /* SOS */\n\t\t\t\tif(no==0){\n                    if( *bufferoffset + datalen + 2 > buffersize )\n                        return(0);\n\t\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);\n\t\t\t\t\t*bufferoffset+=datalen+2;\n\t\t\t\t} else {\n                    if( *bufferoffset + 2 > buffersize )\n                        return(0);\n\t\t\t\t\tbuffer[(*bufferoffset)++]=0xff;\n\t\t\t\t\tbuffer[(*bufferoffset)++]=\n                                            (unsigned char)(0xd0 | ((no-1)%8));\n\t\t\t\t}\n\t\t\t\ti += datalen + 1;\n\t\t\t\t/* copy remainder of strip */\n                if( *bufferoffset + *striplength - i > buffersize )\n                    return(0);\n\t\t\t\t_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i]), *striplength - i);\n\t\t\t\t*bufferoffset+= *striplength - i;\n\t\t\t\treturn(1);\n\t\t\tdefault:\n\t\t\t\t/* ignore any other marker */\n\t\t\t\tbreak;\n\t\t}\n\t\ti += datalen + 1;\n\t}\n\n\t/* failed to find SOS marker */\n\treturn(0);\n}",
          "fn_code_pos": [
            [
              3504,
              0
            ],
            [
              3631,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_process_jpeg_strip",
            "parameters": {
              "strip": "unsigned char",
              "striplength": "tsize_t",
              "buffer": "unsigned char",
              "buffersize": "tsize_t",
              "bufferoffset": "tsize_t",
              "no": "tstrip_t",
              "height": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void t2p_tile_collapse_left(\n\ttdata_t buffer, \n\ttsize_t scanwidth, \n\tuint32 tilewidth, \n\tuint32 edgetilewidth, \n\tuint32 tilelength){\n\t\n\tuint32 i;\n\ttsize_t edgescanwidth=0;\n\t\n\tedgescanwidth = (scanwidth * edgetilewidth + (tilewidth - 1))/ tilewidth;\n\tfor(i=0;i<tilelength;i++){\n                /* We use memmove() since there can be overlaps in src and dst buffers for the first items */\n\t\tmemmove( \n\t\t\t&(((char*)buffer)[edgescanwidth*i]), \n\t\t\t&(((char*)buffer)[scanwidth*i]), \n\t\t\tedgescanwidth);\n\t}\n\t\n\treturn;\n}",
          "fn_code_pos": [
            [
              3638,
              0
            ],
            [
              3658,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_tile_collapse_left",
            "parameters": {
              "buffer": "tdata_t",
              "scanwidth": "tsize_t",
              "tilewidth": "uint32",
              "edgetilewidth": "uint32",
              "tilelength": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nt2p_write_advance_directory(T2P* t2p, TIFF* output)\n{\n\tt2p_disable(output);\n\tif(!TIFFWriteDirectory(output)){\n\t\tTIFFError(TIFF2PDF_MODULE, \n\t\t\t\"Error writing virtual directory to output PDF %s\", \n\t\t\tTIFFFileName(output));\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn;\n\t}\n\tt2p_enable(output);\n\treturn;\n}",
          "fn_code_pos": [
            [
              3667,
              0
            ],
            [
              3680,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_advance_directory",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "tsize_t t2p_sample_planar_separate_to_contig(\n\t\t\t\t\t\t\t\t\t\t\tT2P* t2p, \n\t\t\t\t\t\t\t\t\t\t\tunsigned char* buffer, \n\t\t\t\t\t\t\t\t\t\t\tunsigned char* samplebuffer, \n\t\t\t\t\t\t\t\t\t\t\ttsize_t samplebuffersize){\n\n\ttsize_t stride=0;\n\ttsize_t i=0;\n\ttsize_t j=0;\n\t\n\tstride=samplebuffersize/t2p->tiff_samplesperpixel;\n\tfor(i=0;i<stride;i++){\n\t\tfor(j=0;j<t2p->tiff_samplesperpixel;j++){\n\t\t\tbuffer[i*t2p->tiff_samplesperpixel + j] = samplebuffer[i + j*stride];\n\t\t}\n\t}\n\n\treturn(samplebuffersize);\n}",
          "fn_code_pos": [
            [
              3682,
              0
            ],
            [
              3700,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_sample_planar_separate_to_contig",
            "parameters": {
              "t2p": "T2P",
              "buffer": "unsigned char",
              "samplebuffer": "unsigned char",
              "samplebuffersize": "tsize_t"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_sample_realize_palette(T2P* t2p, unsigned char* buffer){\n\n\tuint32 sample_count=0;\n\tuint16 component_count=0;\n\tuint32 palette_offset=0;\n\tuint32 sample_offset=0;\n\tuint32 i=0;\n\tuint32 j=0;\n        size_t data_size;\n\tsample_count=t2p->tiff_width*t2p->tiff_length;\n\tcomponent_count=t2p->tiff_samplesperpixel;\n        data_size=TIFFSafeMultiply(size_t,sample_count,component_count);\n        if( (data_size == 0U) || (t2p->tiff_datasize < 0) ||\n            (data_size > (size_t) t2p->tiff_datasize) )\n        {\n            TIFFError(TIFF2PDF_MODULE,\n                      \"Error: sample_count * component_count > t2p->tiff_datasize\");\n            t2p->t2p_error = T2P_ERR_ERROR;\n            return 1;\n        }\n\t\n\tfor(i=sample_count;i>0;i--){\n\t\tpalette_offset=buffer[i-1] * component_count;\n\t\tsample_offset= (i-1) * component_count;\n\t\tfor(j=0;j<component_count;j++){\n\t\t\tbuffer[sample_offset+j]=t2p->pdf_palette[palette_offset+j];\n\t\t}\n\t}\n\n\treturn(0);\n}",
          "fn_code_pos": [
            [
              3702,
              0
            ],
            [
              3732,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_sample_realize_palette",
            "parameters": {
              "t2p": "T2P",
              "buffer": "unsigned char"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_sample_abgr_to_rgb(tdata_t data, uint32 samplecount)\n{\n\tuint32 i=0;\n\tuint32 sample=0;\n\t\n\tfor(i=0;i<samplecount;i++){\n\t\tsample=((uint32*)data)[i];\n\t\t((char*)data)[i*3]= (char) (sample & 0xff);\n\t\t((char*)data)[i*3+1]= (char) ((sample>>8) & 0xff);\n\t\t((char*)data)[i*3+2]= (char) ((sample>>16) & 0xff);\n\t}\n\n\treturn(i*3);\n}",
          "fn_code_pos": [
            [
              3739,
              0
            ],
            [
              3752,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_sample_abgr_to_rgb",
            "parameters": {
              "data": "tdata_t",
              "samplecount": "uint32"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t\nt2p_sample_rgbaa_to_rgb(tdata_t data, uint32 samplecount)\n{\n\tuint32 i;\n\n\t/* For the 3 first samples, there is overlap between source and\n\t * destination, so use memmove().\n\t * See http://bugzilla.maptools.org/show_bug.cgi?id=2577\n\t */\n\tfor(i = 0; i < 3 && i < samplecount; i++)\n\t\tmemmove((uint8*)data + i * 3, (uint8*)data + i * 4, 3);\n\tfor(; i < samplecount; i++)\n\t\tmemcpy((uint8*)data + i * 3, (uint8*)data + i * 4, 3);\n\n\treturn(i * 3);\n}",
          "fn_code_pos": [
            [
              3759,
              0
            ],
            [
              3774,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_sample_rgbaa_to_rgb",
            "parameters": {
              "data": "tdata_t",
              "samplecount": "uint32"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t\nt2p_sample_rgba_to_rgb(tdata_t data, uint32 samplecount)\n{\n\tuint32 i = 0;\n\tuint32 sample = 0;\n\tuint8 alpha = 0;\n\n\tfor (i = 0; i < samplecount; i++) {\n\t\tsample=((uint32*)data)[i];\n\t\talpha=(uint8)((255 - ((sample >> 24) & 0xff)));\n\t\t((uint8 *)data)[i * 3] = (uint8) ((sample >> 16) & 0xff) + alpha;\n\t\t((uint8 *)data)[i * 3 + 1] = (uint8) ((sample >> 8) & 0xff) + alpha;\n\t\t((uint8 *)data)[i * 3 + 2] = (uint8) (sample & 0xff) + alpha;\n\t}\n\n\treturn (i * 3);\n}",
          "fn_code_pos": [
            [
              3781,
              0
            ],
            [
              3797,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_sample_rgba_to_rgb",
            "parameters": {
              "data": "tdata_t",
              "samplecount": "uint32"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_sample_lab_signed_to_unsigned(tdata_t buffer, uint32 samplecount){\n\n\tuint32 i=0;\n\n\tfor(i=0;i<samplecount;i++){\n\t\tif( (((unsigned char*)buffer)[(i*3)+1] & 0x80) !=0){\n\t\t\t((unsigned char*)buffer)[(i*3)+1] =\n\t\t\t\t(unsigned char)(0x80 + ((char*)buffer)[(i*3)+1]);\n\t\t} else {\n\t\t\t((unsigned char*)buffer)[(i*3)+1] |= 0x80;\n\t\t}\n\t\tif( (((unsigned char*)buffer)[(i*3)+2] & 0x80) !=0){\n\t\t\t((unsigned char*)buffer)[(i*3)+2] =\n\t\t\t\t(unsigned char)(0x80 + ((char*)buffer)[(i*3)+2]);\n\t\t} else {\n\t\t\t((unsigned char*)buffer)[(i*3)+2] |= 0x80;\n\t\t}\n\t}\n\n\treturn(samplecount*3);\n}",
          "fn_code_pos": [
            [
              3804,
              0
            ],
            [
              3824,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_sample_lab_signed_to_unsigned",
            "parameters": {
              "buffer": "tdata_t",
              "samplecount": "uint32"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_header(T2P* t2p, TIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[16];\n\tint buflen=0;\n\t\n\tbuflen = snprintf(buffer, sizeof(buffer), \"%%PDF-%u.%u \",\n\t\t\t  t2p->pdf_majorversion&0xff,\n\t\t\t  t2p->pdf_minorversion&0xff);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t)\"\\n%\\342\\343\\317\\323\\n\", 7);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              3830,
              0
            ],
            [
              3844,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_header",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_obj_start(uint32 number, TIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[32];\n\tint buflen=0;\n\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)number);\n\tcheck_snprintf_ret((T2P*)NULL, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen );\n\twritten += t2pWriteFile(output, (tdata_t) \" 0 obj\\n\", 7);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              3850,
              0
            ],
            [
              3862,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_obj_start",
            "parameters": {
              "number": "uint32",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_obj_end(TIFF* output){\n\n\ttsize_t written=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) \"endobj\\n\", 7);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              3868,
              0
            ],
            [
              3875,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_obj_end",
            "parameters": {
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_name(unsigned char* name, TIFF* output){\n\n\ttsize_t written=0;\n\tuint32 i=0;\n\tchar buffer[64];\n\tuint16 nextchar=0;\n\tsize_t namelen=0;\n\t\n\tnamelen = strlen((char *)name);\n\tif (namelen>126) {\n\t\tnamelen=126;\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \"/\", 1);\n\tfor (i=0;i<namelen;i++){\n\t\tif ( ((unsigned char)name[i]) < 0x21){\n\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]);\n\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\tnextchar=1;\n\t\t}\n\t\tif ( ((unsigned char)name[i]) > 0x7E){\n\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]);\n\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\tnextchar=1;\n\t\t}\n\t\tif (nextchar==0){\n\t\t\tswitch (name[i]){\n\t\t\t\tcase 0x23:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]);\n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x25:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]);\n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x28:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]);\n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x29:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]); \n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x2F:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]); \n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x3C:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]); \n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x3E:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]);\n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x5B:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]); \n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x5D:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]);\n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x7B:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]); \n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x7D:\n\t\t\t\t\tsnprintf(buffer, sizeof(buffer), \"#%.2X\", name[i]); \n\t\t\t\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 3);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) &name[i], 1);\n\t\t\t}\n\t\t}\n\t\tnextchar=0;\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \" \", 1);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              3881,
              0
            ],
            [
              3973,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_name",
            "parameters": {
              "name": "unsigned char",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_string(char* pdfstr, TIFF* output)\n{\n\ttsize_t written = 0;\n\tuint32 i = 0;\n\tchar buffer[64];\n\tsize_t len = 0;\n\t\n\tlen = strlen(pdfstr);\n\twritten += t2pWriteFile(output, (tdata_t) \"(\", 1);\n\tfor (i=0; i<len; i++) {\n\t\tif((pdfstr[i]&0x80) || (pdfstr[i]==127) || (pdfstr[i]<32)){\n\t\t\tsnprintf(buffer, sizeof(buffer), \"\\\\%.3o\", ((unsigned char)pdfstr[i]));\n\t\t\twritten += t2pWriteFile(output, (tdata_t)buffer, 4);\n\t\t} else {\n\t\t\tswitch (pdfstr[i]){\n\t\t\t\tcase 0x08:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\\\b\", 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x09:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\\\t\", 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x0A:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\\\n\", 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x0C:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\\\f\", 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x0D:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\\\r\", 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x28:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\\\(\", 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x29:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\\\)\", 2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x5C:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\\\\\\\\", 2);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) &pdfstr[i], 1);\n\t\t\t}\n\t\t}\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \") \", 1);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              3979,
              0
            ],
            [
              4026,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_string",
            "parameters": {
              "pdfstr": "char",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_stream(tdata_t buffer, tsize_t len, TIFF* output){\n\n\ttsize_t written=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) buffer, len);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              4033,
              0
            ],
            [
              4040,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_stream",
            "parameters": {
              "buffer": "tdata_t",
              "len": "tsize_t",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_stream_start(TIFF* output){\n\n\ttsize_t written=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) \"stream\\n\", 7);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              4046,
              0
            ],
            [
              4053,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_stream_start",
            "parameters": {
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_stream_end(TIFF* output){\n\n\ttsize_t written=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) \"\\nendstream\\n\", 11);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              4059,
              0
            ],
            [
              4066,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_stream_end",
            "parameters": {
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_stream_dict(tsize_t len, uint32 number, TIFF* output){\n\t\n\ttsize_t written=0;\n\tchar buffer[32];\n\tint buflen=0;\n\t\n\twritten += t2pWriteFile(output, (tdata_t) \"/Length \", 8);\n\tif(len!=0){\n\t\twritten += t2p_write_pdf_stream_length(len, output);\n\t} else {\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)number);\n\t\tcheck_snprintf_ret((T2P*)NULL, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \\n\", 6);\n\t}\n\t\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              4072,
              0
            ],
            [
              4089,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_stream_dict",
            "parameters": {
              "len": "tsize_t",
              "number": "uint32",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_stream_dict_start(TIFF* output){\n\n\ttsize_t written=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) \"<< \\n\", 4);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              4095,
              0
            ],
            [
              4102,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_stream_dict_start",
            "parameters": {
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_stream_dict_end(TIFF* output){\n\n\ttsize_t written=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) \" >>\\n\", 4);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              4108,
              0
            ],
            [
              4115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_stream_dict_end",
            "parameters": {
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_stream_length(tsize_t len, TIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[32];\n\tint buflen=0;\n\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)len);\n\tcheck_snprintf_ret((T2P*)NULL, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              4121,
              0
            ],
            [
              4133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_stream_length",
            "parameters": {
              "len": "tsize_t",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_catalog(T2P* t2p, TIFF* output)\n{\n\ttsize_t written = 0;\n\tchar buffer[32];\n\tint buflen = 0;\n\n\twritten += t2pWriteFile(output, \n\t\t(tdata_t)\"<< \\n/Type /Catalog \\n/Pages \", \n\t\t27);\n\tbuflen = snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)t2p->pdf_pages);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer,\n\t\t\t\tTIFFmin((size_t)buflen, sizeof(buffer) - 1));\n\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \\n\", 6);\n\tif(t2p->pdf_fitwindow){\n\t\twritten += t2pWriteFile(output, \n\t\t\t(tdata_t) \"/ViewerPreferences <</FitWindow true>>\\n\", \n\t\t\t39);\n\t}\n\twritten += t2pWriteFile(output, (tdata_t)\">>\\n\", 3);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              4139,
              0
            ],
            [
              4161,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_catalog",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_info(T2P* t2p, TIFF* input, TIFF* output)\n{\n\ttsize_t written = 0;\n\tchar* info;\n\tchar buffer[512];\n\n\tif(t2p->pdf_datetime[0] == '\\0')\n\t\tt2p_pdf_tifftime(t2p, input);\n\tif (strlen(t2p->pdf_datetime) > 0) {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"<< \\n/CreationDate \", 18);\n\t\twritten += t2p_write_pdf_string(t2p->pdf_datetime, output);\n\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n/ModDate \", 10);\n\t\twritten += t2p_write_pdf_string(t2p->pdf_datetime, output);\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \"\\n/Producer \", 11);\n\tsnprintf(buffer, sizeof(buffer), \"libtiff / tiff2pdf - %d\", TIFFLIB_VERSION);\n\twritten += t2p_write_pdf_string(buffer, output);\n\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\tif (t2p->pdf_creator[0] != '\\0') {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/Creator \", 9);\n\t\twritten += t2p_write_pdf_string(t2p->pdf_creator, output);\n\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t} else {\n\t\tif (TIFFGetField(input, TIFFTAG_SOFTWARE, &info) != 0 && info) {\n\t\t\tif(strlen(info) >= sizeof(t2p->pdf_creator))\n\t\t\t\tinfo[sizeof(t2p->pdf_creator) - 1] = '\\0';\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Creator \", 9);\n\t\t\twritten += t2p_write_pdf_string(info, output);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t\t}\n\t}\n\tif (t2p->pdf_author[0] != '\\0') {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/Author \", 8);\n\t\twritten += t2p_write_pdf_string(t2p->pdf_author, output);\n\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t} else {\n\t\tif ((TIFFGetField(input, TIFFTAG_ARTIST, &info) != 0\n\t\t     || TIFFGetField(input, TIFFTAG_COPYRIGHT, &info) != 0)\n\t\t    && info) {\n\t\t\tif (strlen(info) >= sizeof(t2p->pdf_author))\n\t\t\t\tinfo[sizeof(t2p->pdf_author) - 1] = '\\0';\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Author \", 8);\n\t\t\twritten += t2p_write_pdf_string(info, output);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t\t}\n\t}\n\tif (t2p->pdf_title[0] != '\\0') {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/Title \", 7);\n\t\twritten += t2p_write_pdf_string(t2p->pdf_title, output);\n\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t} else {\n\t\tif (TIFFGetField(input, TIFFTAG_DOCUMENTNAME, &info) != 0){\n\t\t\tif(strlen(info) > 511) {\n\t\t\t\tinfo[512] = '\\0';\n\t\t\t}\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Title \", 7);\n\t\t\twritten += t2p_write_pdf_string(info, output);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t\t}\n\t}\n\tif (t2p->pdf_subject[0] != '\\0') {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/Subject \", 9);\n\t\twritten += t2p_write_pdf_string(t2p->pdf_subject, output);\n\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t} else {\n\t\tif (TIFFGetField(input, TIFFTAG_IMAGEDESCRIPTION, &info) != 0 && info) {\n\t\t\tif (strlen(info) >= sizeof(t2p->pdf_subject))\n\t\t\t\tinfo[sizeof(t2p->pdf_subject) - 1] = '\\0';\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Subject \", 9);\n\t\t\twritten += t2p_write_pdf_string(info, output);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t\t}\n\t}\n\tif (t2p->pdf_keywords[0] != '\\0') {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/Keywords \", 10);\n\t\twritten += t2p_write_pdf_string(t2p->pdf_keywords, output);\n\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \">> \\n\", 4);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              4167,
              0
            ],
            [
              4248,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_info",
            "parameters": {
              "t2p": "T2P",
              "input": "TIFF",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "void t2p_pdf_currenttime(T2P* t2p)\n{\n\tstruct tm* currenttime;\n\ttime_t timenow;\n\n\tif (time(&timenow) == (time_t) -1) {\n\t\tTIFFError(TIFF2PDF_MODULE,\n\t\t\t  \"Can't get the current time: %s\", strerror(errno));\n\t\ttimenow = (time_t) 0;\n\t}\n\n\tcurrenttime = localtime(&timenow);\n\tsnprintf(t2p->pdf_datetime, sizeof(t2p->pdf_datetime),\n\t\t \"D:%.4u%.2u%.2u%.2u%.2u%.2u\",\n\t\t TIFFmin((unsigned) currenttime->tm_year + 1900U,9999U),\n\t\t TIFFmin((unsigned) currenttime->tm_mon + 1U,12U),   /* 0-11 + 1 */\n\t\t TIFFmin((unsigned) currenttime->tm_mday,31U),       /* 1-31 */\n\t\t TIFFmin((unsigned) currenttime->tm_hour,23U),       /* 0-23 */\n\t\t TIFFmin((unsigned) currenttime->tm_min,59U),        /* 0-59 */\n\t\t TIFFmin((unsigned) (currenttime->tm_sec),60U));     /* 0-60 */\n\n\treturn;\n}",
          "fn_code_pos": [
            [
              4255,
              0
            ],
            [
              4277,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_pdf_currenttime",
            "parameters": {
              "t2p": "T2P"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void t2p_pdf_tifftime(T2P* t2p, TIFF* input)\n{\n\tchar* datetime;\n\n\tif (TIFFGetField(input, TIFFTAG_DATETIME, &datetime) != 0\n\t    && (strlen(datetime) >= 19) ){\n\t\tt2p->pdf_datetime[0]='D';\n\t\tt2p->pdf_datetime[1]=':';\n\t\tt2p->pdf_datetime[2]=datetime[0];\n\t\tt2p->pdf_datetime[3]=datetime[1];\n\t\tt2p->pdf_datetime[4]=datetime[2];\n\t\tt2p->pdf_datetime[5]=datetime[3];\n\t\tt2p->pdf_datetime[6]=datetime[5];\n\t\tt2p->pdf_datetime[7]=datetime[6];\n\t\tt2p->pdf_datetime[8]=datetime[8];\n\t\tt2p->pdf_datetime[9]=datetime[9];\n\t\tt2p->pdf_datetime[10]=datetime[11];\n\t\tt2p->pdf_datetime[11]=datetime[12];\n\t\tt2p->pdf_datetime[12]=datetime[14];\n\t\tt2p->pdf_datetime[13]=datetime[15];\n\t\tt2p->pdf_datetime[14]=datetime[17];\n\t\tt2p->pdf_datetime[15]=datetime[18];\n\t\tt2p->pdf_datetime[16] = '\\0';\n\t} else {\n\t\tt2p_pdf_currenttime(t2p);\n\t}\n\n\treturn;\n}",
          "fn_code_pos": [
            [
              4284,
              0
            ],
            [
              4312,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_pdf_tifftime",
            "parameters": {
              "t2p": "T2P",
              "input": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_pages(T2P* t2p, TIFF* output)\n{\n\ttsize_t written=0;\n\ttdir_t i=0;\n\tchar buffer[32];\n\tint buflen=0;\n\n\tint page=0;\n\twritten += t2pWriteFile(output,\n\t\t(tdata_t) \"<< \\n/Type /Pages \\n/Kids [ \", 26);\n\tpage = t2p->pdf_pages+1;\n\tfor (i=0;i<t2p->tiff_pagecount;i++){\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%d\", page);\n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \", 5);\n\t\tif ( ((i+1)%8)==0 ) {\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t\t}\n\t\tpage +=3;\n\t\tpage += t2p->tiff_pages[i].page_extra;\n\t\tif(t2p->tiff_pages[i].page_tilecount>0){\n\t\t\tpage += (2 * t2p->tiff_pages[i].page_tilecount);\n\t\t} else {\n\t\t\tpage +=2;\n\t\t}\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \"] \\n/Count \", 10);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%d\", t2p->tiff_pagecount);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \" \\n>> \\n\", 6);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              4318,
              0
            ],
            [
              4352,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_pages",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_page(uint32 object, T2P* t2p, TIFF* output){\n\n\tunsigned int i=0;\n\ttsize_t written=0;\n\tchar buffer[256];\n\tint buflen=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) \"<<\\n/Type /Page \\n/Parent \", 24);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)t2p->pdf_pages);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \\n\", 6);\n\twritten += t2pWriteFile(output, (tdata_t) \"/MediaBox [\", 11); \n\tbuflen=snprintf(buffer, sizeof(buffer), \"%.4f\",t2p->pdf_mediabox.x1);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \" \", 1); \n\tbuflen=snprintf(buffer, sizeof(buffer), \"%.4f\",t2p->pdf_mediabox.y1);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \" \", 1); \n\tbuflen=snprintf(buffer, sizeof(buffer), \"%.4f\",t2p->pdf_mediabox.x2);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \" \", 1); \n\tbuflen=snprintf(buffer, sizeof(buffer), \"%.4f\",t2p->pdf_mediabox.y2);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \"] \\n\", 3); \n\twritten += t2pWriteFile(output, (tdata_t) \"/Contents \", 10);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)(object + 1));\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \\n\", 6);\n\twritten += t2pWriteFile(output, (tdata_t) \"/Resources << \\n\", 15);\n\tif( t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount != 0 ){\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/XObject <<\\n\", 12);\n\t\tfor(i=0;i<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;i++){\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Im\", 3);\n\t\t\tbuflen = snprintf(buffer, sizeof(buffer), \"%u\", t2p->pdf_page+1);\n\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"_\", 1);\n\t\t\tbuflen = snprintf(buffer, sizeof(buffer), \"%u\", i+1);\n\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \" \", 1);\n\t\t\tbuflen = snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t(unsigned long)(object+3+(2*i)+t2p->tiff_pages[t2p->pdf_page].page_extra)); \n\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \", 5);\n\t\t\tif(i%4==3){\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"\\n\", 1);\n\t\t\t}\n\t\t}\n\t\twritten += t2pWriteFile(output, (tdata_t) \">>\\n\", 3);\n\t} else {\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/XObject <<\\n\", 12);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Im\", 3);\n\t\t\tbuflen = snprintf(buffer, sizeof(buffer), \"%u\", t2p->pdf_page+1);\n\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \" \", 1);\n\t\t\tbuflen = snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t(unsigned long)(object+3+(2*i)+t2p->tiff_pages[t2p->pdf_page].page_extra)); \n\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \", 5);\n\t\twritten += t2pWriteFile(output, (tdata_t) \">>\\n\", 3);\n\t}\n\tif(t2p->tiff_transferfunctioncount != 0) {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/ExtGState <<\", 13);\n\t\tt2pWriteFile(output, (tdata_t) \"/GS1 \", 5);\n\t\tbuflen = snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t(unsigned long)(object + 3)); \n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \", 5);\n\t\twritten += t2pWriteFile(output, (tdata_t) \">> \\n\", 4);\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \"/ProcSet [ \", 11);\n\tif(t2p->pdf_colorspace & T2P_CS_BILEVEL \n\t\t|| t2p->pdf_colorspace & T2P_CS_GRAY\n\t\t){\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/ImageB \", 8);\n\t} else {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/ImageC \", 8);\n\t\tif(t2p->pdf_colorspace & T2P_CS_PALETTE){\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/ImageI \", 8);\n\t\t}\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \"]\\n>>\\n>>\\n\", 8);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              4358,
              0
            ],
            [
              4453,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_page",
            "parameters": {
              "object": "uint32",
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "void t2p_compose_pdf_page(T2P* t2p){\n\n\tuint32 i=0;\n\tuint32 i2=0;\n\tT2P_TILE* tiles=NULL;\n\tT2P_BOX* boxp=NULL;\n\tuint32 tilecountx=0;\n\tuint32 tilecounty=0;\n\tuint32 tilewidth=0;\n\tuint32 tilelength=0;\n\tint istiled=0;\n\tfloat f=0;\n\tfloat width_ratio=0;\n\tfloat length_ratio=0;\n\t\n\tt2p->pdf_xres = t2p->tiff_xres;\n\tt2p->pdf_yres = t2p->tiff_yres;\n\tif(t2p->pdf_overrideres) {\n\t\tt2p->pdf_xres = t2p->pdf_defaultxres;\n\t\tt2p->pdf_yres = t2p->pdf_defaultyres;\n\t}\n\tif(t2p->pdf_xres == 0.0)\n\t\tt2p->pdf_xres = t2p->pdf_defaultxres;\n\tif(t2p->pdf_yres == 0.0)\n\t\tt2p->pdf_yres = t2p->pdf_defaultyres;\n\tif (t2p->pdf_image_fillpage) {\n\t\twidth_ratio = t2p->pdf_defaultpagewidth/t2p->tiff_width;\n\t\tlength_ratio = t2p->pdf_defaultpagelength/t2p->tiff_length;\n\t\tif (width_ratio < length_ratio ) {\n\t\t\tt2p->pdf_imagewidth = t2p->pdf_defaultpagewidth;\n\t\t\tt2p->pdf_imagelength = t2p->tiff_length * width_ratio;\n\t\t} else {\n\t\t\tt2p->pdf_imagewidth = t2p->tiff_width * length_ratio;\n\t\t\tt2p->pdf_imagelength = t2p->pdf_defaultpagelength;\n\t\t}\n\t} else if (t2p->tiff_resunit != RESUNIT_CENTIMETER\t/* RESUNIT_NONE and */\n\t\t&& t2p->tiff_resunit != RESUNIT_INCH) {\t/* other cases */\n\t\tt2p->pdf_imagewidth = ((float)(t2p->tiff_width))/t2p->pdf_xres;\n\t\tt2p->pdf_imagelength = ((float)(t2p->tiff_length))/t2p->pdf_yres;\n\t} else {\n\t\tt2p->pdf_imagewidth = \n\t\t\t((float)(t2p->tiff_width))*PS_UNIT_SIZE/t2p->pdf_xres;\n\t\tt2p->pdf_imagelength = \n\t\t\t((float)(t2p->tiff_length))*PS_UNIT_SIZE/t2p->pdf_yres;\n\t}\n\tif(t2p->pdf_overridepagesize != 0) {\n\t\tt2p->pdf_pagewidth = t2p->pdf_defaultpagewidth;\n\t\tt2p->pdf_pagelength = t2p->pdf_defaultpagelength;\n\t} else {\n\t\tt2p->pdf_pagewidth = t2p->pdf_imagewidth;\n\t\tt2p->pdf_pagelength = t2p->pdf_imagelength;\n\t}\n\tt2p->pdf_mediabox.x1=0.0;\n\tt2p->pdf_mediabox.y1=0.0;\n\tt2p->pdf_mediabox.x2=t2p->pdf_pagewidth;\n\tt2p->pdf_mediabox.y2=t2p->pdf_pagelength;\n\tt2p->pdf_imagebox.x1=0.0;\n\tt2p->pdf_imagebox.y1=0.0;\n\tt2p->pdf_imagebox.x2=t2p->pdf_imagewidth;\n\tt2p->pdf_imagebox.y2=t2p->pdf_imagelength;\n\tif(t2p->pdf_overridepagesize!=0){\n\t\tt2p->pdf_imagebox.x1+=((t2p->pdf_pagewidth-t2p->pdf_imagewidth)/2.0F);\n\t\tt2p->pdf_imagebox.y1+=((t2p->pdf_pagelength-t2p->pdf_imagelength)/2.0F);\n\t\tt2p->pdf_imagebox.x2+=((t2p->pdf_pagewidth-t2p->pdf_imagewidth)/2.0F);\n\t\tt2p->pdf_imagebox.y2+=((t2p->pdf_pagelength-t2p->pdf_imagelength)/2.0F);\n\t}\n\tif(t2p->tiff_orientation > 4){\n\t\tf=t2p->pdf_mediabox.x2;\n\t\tt2p->pdf_mediabox.x2=t2p->pdf_mediabox.y2;\n\t\tt2p->pdf_mediabox.y2=f;\n\t}\n\tistiled=((t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount==0) ? 0 : 1;\n\tif(istiled==0){\n\t\tt2p_compose_pdf_page_orient(&(t2p->pdf_imagebox), t2p->tiff_orientation);\n\t\treturn;\n\t} else {\n\t\ttilewidth=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilewidth;\n\t\ttilelength=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilelength;\n\t\tif( tilewidth > INT_MAX ||\n\t\t    tilelength > INT_MAX ||\n\t\t    t2p->tiff_width > INT_MAX - tilewidth ||\n\t\t    t2p->tiff_length > INT_MAX - tilelength )\n\t\t{\n\t\t    TIFFError(TIFF2PDF_MODULE, \"Integer overflow\");\n\t\t    t2p->t2p_error = T2P_ERR_ERROR;\n\t\t    return;\n\t\t}\n\t\ttilecountx=(t2p->tiff_width + \n\t\t\ttilewidth -1)/ \n\t\t\ttilewidth;\n\t\t(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecountx=tilecountx;\n\t\ttilecounty=(t2p->tiff_length + \n\t\t\ttilelength -1)/ \n\t\t\ttilelength;\n\t\t(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecounty=tilecounty;\n\t\t(t2p->tiff_tiles[t2p->pdf_page]).tiles_edgetilewidth=\n\t\t\tt2p->tiff_width % tilewidth;\n\t\t(t2p->tiff_tiles[t2p->pdf_page]).tiles_edgetilelength=\n\t\t\tt2p->tiff_length % tilelength;\n\t\ttiles=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tiles;\n\t\tfor(i2=0;i2<tilecounty-1;i2++){\n\t\t\tfor(i=0;i<tilecountx-1;i++){\n\t\t\t\tboxp=&(tiles[i2*tilecountx+i].tile_box);\n\t\t\t\tboxp->x1 = \n\t\t\t\t\tt2p->pdf_imagebox.x1 \n\t\t\t\t\t+ ((float)(t2p->pdf_imagewidth * i * tilewidth)\n\t\t\t\t\t/ (float)t2p->tiff_width);\n\t\t\t\tboxp->x2 = \n\t\t\t\t\tt2p->pdf_imagebox.x1 \n\t\t\t\t\t+ ((float)(t2p->pdf_imagewidth * (i+1) * tilewidth)\n\t\t\t\t\t/ (float)t2p->tiff_width);\n\t\t\t\tboxp->y1 = \n\t\t\t\t\tt2p->pdf_imagebox.y2 \n\t\t\t\t\t- ((float)(t2p->pdf_imagelength * (i2+1) * tilelength)\n\t\t\t\t\t/ (float)t2p->tiff_length);\n\t\t\t\tboxp->y2 = \n\t\t\t\t\tt2p->pdf_imagebox.y2 \n\t\t\t\t\t- ((float)(t2p->pdf_imagelength * i2 * tilelength)\n\t\t\t\t\t/ (float)t2p->tiff_length);\n\t\t\t}\n\t\t\tboxp=&(tiles[i2*tilecountx+i].tile_box);\n\t\t\tboxp->x1 = \n\t\t\t\tt2p->pdf_imagebox.x1 \n\t\t\t\t+ ((float)(t2p->pdf_imagewidth * i * tilewidth)\n\t\t\t\t/ (float)t2p->tiff_width);\n\t\t\tboxp->x2 = t2p->pdf_imagebox.x2;\n\t\t\tboxp->y1 = \n\t\t\t\tt2p->pdf_imagebox.y2 \n\t\t\t\t- ((float)(t2p->pdf_imagelength * (i2+1) * tilelength)\n\t\t\t\t/ (float)t2p->tiff_length);\n\t\t\tboxp->y2 = \n\t\t\t\tt2p->pdf_imagebox.y2 \n\t\t\t\t- ((float)(t2p->pdf_imagelength * i2 * tilelength)\n\t\t\t\t/ (float)t2p->tiff_length);\n\t\t}\n\t\tfor(i=0;i<tilecountx-1;i++){\n\t\t\tboxp=&(tiles[i2*tilecountx+i].tile_box);\n\t\t\tboxp->x1 = \n\t\t\t\tt2p->pdf_imagebox.x1 \n\t\t\t\t+ ((float)(t2p->pdf_imagewidth * i * tilewidth)\n\t\t\t\t/ (float)t2p->tiff_width);\n\t\t\tboxp->x2 = \n\t\t\t\tt2p->pdf_imagebox.x1 \n\t\t\t\t+ ((float)(t2p->pdf_imagewidth * (i+1) * tilewidth)\n\t\t\t\t/ (float)t2p->tiff_width);\n\t\t\tboxp->y1 = t2p->pdf_imagebox.y1;\n\t\t\tboxp->y2 = \n\t\t\t\tt2p->pdf_imagebox.y2 \n\t\t\t\t- ((float)(t2p->pdf_imagelength * i2 * tilelength)\n\t\t\t\t/ (float)t2p->tiff_length);\n\t\t}\n\t\tboxp=&(tiles[i2*tilecountx+i].tile_box);\n\t\tboxp->x1 = \n\t\t\tt2p->pdf_imagebox.x1 \n\t\t\t+ ((float)(t2p->pdf_imagewidth * i * tilewidth)\n\t\t\t/ (float)t2p->tiff_width);\n\t\tboxp->x2 = t2p->pdf_imagebox.x2;\n\t\tboxp->y1 = t2p->pdf_imagebox.y1;\n\t\tboxp->y2 = \n\t\t\tt2p->pdf_imagebox.y2 \n\t\t\t- ((float)(t2p->pdf_imagelength * i2 * tilelength)\n\t\t\t/ (float)t2p->tiff_length);\n\t}\n\tif(t2p->tiff_orientation==0 || t2p->tiff_orientation==1){\n\t\tfor(i=0;i<(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount;i++){\n\t\t\tt2p_compose_pdf_page_orient( &(tiles[i].tile_box) , 0);\n\t\t}\n\t\treturn;\n\t}\n\tfor(i=0;i<(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount;i++){\n\t\tboxp=&(tiles[i].tile_box);\n\t\tboxp->x1 -= t2p->pdf_imagebox.x1;\n\t\tboxp->x2 -= t2p->pdf_imagebox.x1;\n\t\tboxp->y1 -= t2p->pdf_imagebox.y1;\n\t\tboxp->y2 -= t2p->pdf_imagebox.y1;\n\t\tif(t2p->tiff_orientation==2 || t2p->tiff_orientation==3){\n\t\t\tboxp->x1 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x1;\n\t\t\tboxp->x2 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x2;\n\t\t}\n\t\tif(t2p->tiff_orientation==3 || t2p->tiff_orientation==4){\n\t\t\tboxp->y1 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y1;\n\t\t\tboxp->y2 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y2;\n\t\t}\n\t\tif(t2p->tiff_orientation==8 || t2p->tiff_orientation==5){\n\t\t\tboxp->y1 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y1;\n\t\t\tboxp->y2 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y2;\n\t\t}\n\t\tif(t2p->tiff_orientation==5 || t2p->tiff_orientation==6){\n\t\t\tboxp->x1 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x1;\n\t\t\tboxp->x2 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x2;\n\t\t}\n\t\tif(t2p->tiff_orientation > 4){\n\t\t\tf=boxp->x1;\n\t\t\tboxp->x1 = boxp->y1;\n\t\t\tboxp->y1 = f;\n\t\t\tf=boxp->x2;\n\t\t\tboxp->x2 = boxp->y2;\n\t\t\tboxp->y2 = f; \n\t\t\tt2p_compose_pdf_page_orient_flip(boxp, t2p->tiff_orientation);\n\t\t} else {\n\t\t\tt2p_compose_pdf_page_orient(boxp, t2p->tiff_orientation);\n\t\t}\n\t\t\n\t}\n\n\treturn;\n}",
          "fn_code_pos": [
            [
              4459,
              0
            ],
            [
              4665,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_compose_pdf_page",
            "parameters": {
              "t2p": "T2P"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void t2p_compose_pdf_page_orient(T2P_BOX* boxp, uint16 orientation){\n\n\tfloat m1[9];\n\tfloat f=0.0;\n\t\n\tif( boxp->x1 > boxp->x2){\n\t\tf=boxp->x1;\n\t\tboxp->x1=boxp->x2;\n\t\tboxp->x2 = f;\n\t}\n\tif( boxp->y1 > boxp->y2){\n\t\tf=boxp->y1;\n\t\tboxp->y1=boxp->y2;\n\t\tboxp->y2 = f;\n\t}\n\tboxp->mat[0]=m1[0]=boxp->x2-boxp->x1;\n\tboxp->mat[1]=m1[1]=0.0;\n\tboxp->mat[2]=m1[2]=0.0;\n\tboxp->mat[3]=m1[3]=0.0;\n\tboxp->mat[4]=m1[4]=boxp->y2-boxp->y1;\n\tboxp->mat[5]=m1[5]=0.0;\n\tboxp->mat[6]=m1[6]=boxp->x1;\n\tboxp->mat[7]=m1[7]=boxp->y1;\n\tboxp->mat[8]=m1[8]=1.0;\n\tswitch(orientation){\n\t\tcase 0:\n\t\tcase 1:\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tboxp->mat[0]=0.0F-m1[0];\n\t\t\tboxp->mat[6]+=m1[0];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tboxp->mat[0]=0.0F-m1[0];\n\t\t\tboxp->mat[4]=0.0F-m1[4];\n\t\t\tboxp->mat[6]+=m1[0];\n\t\t\tboxp->mat[7]+=m1[4];\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tboxp->mat[4]=0.0F-m1[4];\n\t\t\tboxp->mat[7]+=m1[4];\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tboxp->mat[0]=0.0F;\n\t\t\tboxp->mat[1]=0.0F-m1[0];\n\t\t\tboxp->mat[3]=0.0F-m1[4];\n\t\t\tboxp->mat[4]=0.0F;\n\t\t\tboxp->mat[6]+=m1[4];\n\t\t\tboxp->mat[7]+=m1[0];\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tboxp->mat[0]=0.0F;\n\t\t\tboxp->mat[1]=0.0F-m1[0];\n\t\t\tboxp->mat[3]=m1[4];\n\t\t\tboxp->mat[4]=0.0F;\n\t\t\tboxp->mat[7]+=m1[0];\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tboxp->mat[0]=0.0F;\n\t\t\tboxp->mat[1]=m1[0];\n\t\t\tboxp->mat[3]=m1[4];\n\t\t\tboxp->mat[4]=0.0F;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tboxp->mat[0]=0.0F;\n\t\t\tboxp->mat[1]=m1[0];\n\t\t\tboxp->mat[3]=0.0F-m1[4];\n\t\t\tboxp->mat[4]=0.0F;\n\t\t\tboxp->mat[6]+=m1[4];\n\t\t\tbreak;\n\t}\n\n\treturn;\n}",
          "fn_code_pos": [
            [
              4667,
              0
            ],
            [
              4740,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_compose_pdf_page_orient",
            "parameters": {
              "boxp": "T2P_BOX",
              "orientation": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void t2p_compose_pdf_page_orient_flip(T2P_BOX* boxp, uint16 orientation){\n\n\tfloat m1[9];\n\tfloat f=0.0;\n\t\n\tif( boxp->x1 > boxp->x2){\n\t\tf=boxp->x1;\n\t\tboxp->x1=boxp->x2;\n\t\tboxp->x2 = f;\n\t}\n\tif( boxp->y1 > boxp->y2){\n\t\tf=boxp->y1;\n\t\tboxp->y1=boxp->y2;\n\t\tboxp->y2 = f;\n\t}\n\tboxp->mat[0]=m1[0]=boxp->x2-boxp->x1;\n\tboxp->mat[1]=m1[1]=0.0F;\n\tboxp->mat[2]=m1[2]=0.0F;\n\tboxp->mat[3]=m1[3]=0.0F;\n\tboxp->mat[4]=m1[4]=boxp->y2-boxp->y1;\n\tboxp->mat[5]=m1[5]=0.0F;\n\tboxp->mat[6]=m1[6]=boxp->x1;\n\tboxp->mat[7]=m1[7]=boxp->y1;\n\tboxp->mat[8]=m1[8]=1.0F;\n\tswitch(orientation){\n\t\tcase 5:\n\t\t\tboxp->mat[0]=0.0F;\n\t\t\tboxp->mat[1]=0.0F-m1[4];\n\t\t\tboxp->mat[3]=0.0F-m1[0];\n\t\t\tboxp->mat[4]=0.0F;\n\t\t\tboxp->mat[6]+=m1[0];\n\t\t\tboxp->mat[7]+=m1[4];\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tboxp->mat[0]=0.0F;\n\t\t\tboxp->mat[1]=0.0F-m1[4];\n\t\t\tboxp->mat[3]=m1[0];\n\t\t\tboxp->mat[4]=0.0F;\n\t\t\tboxp->mat[7]+=m1[4];\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tboxp->mat[0]=0.0F;\n\t\t\tboxp->mat[1]=m1[4];\n\t\t\tboxp->mat[3]=m1[0];\n\t\t\tboxp->mat[4]=0.0F;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tboxp->mat[0]=0.0F;\n\t\t\tboxp->mat[1]=m1[4];\n\t\t\tboxp->mat[3]=0.0F-m1[0];\n\t\t\tboxp->mat[4]=0.0F;\n\t\t\tboxp->mat[6]+=m1[0];\n\t\t\tbreak;\n\t}\n\n\treturn;\n}",
          "fn_code_pos": [
            [
              4742,
              0
            ],
            [
              4798,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_compose_pdf_page_orient_flip",
            "parameters": {
              "boxp": "T2P_BOX",
              "orientation": "uint16"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_page_content_stream(T2P* t2p, TIFF* output){\n\n\ttsize_t written=0;\n\tttile_t i=0;\n\tchar buffer[512];\n\tint buflen=0;\n\tT2P_BOX box;\n\t\n\tif(t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount>0){ \n\t\tfor(i=0;i<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount; i++){\n\t\t\tbox=t2p->tiff_tiles[t2p->pdf_page].tiles_tiles[i].tile_box;\n\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \n\t\t\t\t\"q %s %.4f %.4f %.4f %.4f %.4f %.4f cm /Im%d_%ld Do Q\\n\", \n\t\t\t\tt2p->tiff_transferfunctioncount?\"/GS1 gs \":\"\",\n\t\t\t\tbox.mat[0],\n\t\t\t\tbox.mat[1],\n\t\t\t\tbox.mat[3],\n\t\t\t\tbox.mat[4],\n\t\t\t\tbox.mat[6],\n\t\t\t\tbox.mat[7],\n\t\t\t\tt2p->pdf_page + 1, \n\t\t\t\t(long)(i + 1));\n\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\twritten += t2p_write_pdf_stream(buffer, buflen, output);\n\t\t}\n\t} else {\n\t\tbox=t2p->pdf_imagebox;\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \n\t\t\t\"q %s %.4f %.4f %.4f %.4f %.4f %.4f cm /Im%d Do Q\\n\", \n\t\t\tt2p->tiff_transferfunctioncount?\"/GS1 gs \":\"\",\n\t\t\tbox.mat[0],\n\t\t\tbox.mat[1],\n\t\t\tbox.mat[3],\n\t\t\tbox.mat[4],\n\t\t\tbox.mat[6],\n\t\t\tbox.mat[7],\n\t\t\tt2p->pdf_page+1);\n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2p_write_pdf_stream(buffer, buflen, output);\n\t}\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              4804,
              0
            ],
            [
              4846,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_page_content_stream",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_xobject_stream_dict(ttile_t tile, \n\t\t\t\t\t\t\t\t\t\t\t\tT2P* t2p, \n\t\t\t\t\t\t\t\t\t\t\t\tTIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[32];\n\tint buflen=0;\n\n\twritten += t2p_write_pdf_stream_dict(0, t2p->pdf_xrefcount+1, output); \n\twritten += t2pWriteFile(output, \n\t\t(tdata_t) \"/Type /XObject \\n/Subtype /Image \\n/Name /Im\", \n\t\t42);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%u\", t2p->pdf_page+1);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\tif(tile != 0){\n\t\twritten += t2pWriteFile(output, (tdata_t) \"_\", 1);\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)tile);\n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \"\\n/Width \", 8);\n\tif(tile==0){\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)t2p->tiff_width);\n\t} else {\n\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)!=0){\n\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\n\t\t} else {\n\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\n\t\t}\n\t}\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \"\\n/Height \", 9);\n\tif(tile==0){\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)t2p->tiff_length);\n\t} else {\n\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)!=0){\n\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t\t} else {\n\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t}\n\t}\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \"\\n/BitsPerComponent \", 19);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%u\", t2p->tiff_bitspersample);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \"\\n/ColorSpace \", 13);\n\twritten += t2p_write_pdf_xobject_cs(t2p, output);\n\tif (t2p->pdf_image_interpolate)\n\t\twritten += t2pWriteFile(output,\n\t\t\t\t\t (tdata_t) \"\\n/Interpolate true\", 18);\n\tif( (t2p->pdf_switchdecode != 0)\n#ifdef CCITT_SUPPORT\n\t\t&& ! (t2p->pdf_colorspace & T2P_CS_BILEVEL \n\t\t&& t2p->pdf_compression == T2P_COMPRESS_G4)\n#endif\n\t\t){\n\t\twritten += t2p_write_pdf_xobject_decode(t2p, output);\n\t}\n\twritten += t2p_write_pdf_xobject_stream_filter(tile, t2p, output);\n\t\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              4852,
              0
            ],
            [
              4921,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_stream_dict",
            "parameters": {
              "tile": "ttile_t",
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_xobject_cs(T2P* t2p, TIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[128];\n\tint buflen=0;\n\n\tfloat X_W=1.0;\n\tfloat Y_W=1.0;\n\tfloat Z_W=1.0;\n\t\n\tif( (t2p->pdf_colorspace & T2P_CS_ICCBASED) != 0){\n\t\twritten += t2p_write_pdf_xobject_icccs(t2p, output);\n\t\treturn(written);\n\t}\n\tif( (t2p->pdf_colorspace & T2P_CS_PALETTE) != 0){\n\t\twritten += t2pWriteFile(output, (tdata_t) \"[ /Indexed \", 11);\n\t\tt2p->pdf_colorspace ^= T2P_CS_PALETTE;\n\t\twritten += t2p_write_pdf_xobject_cs(t2p, output);\n\t\tt2p->pdf_colorspace |= T2P_CS_PALETTE;\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%u\", (0x0001 << t2p->tiff_bitspersample)-1 );\n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \" \", 1);\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)t2p->pdf_palettecs ); \n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R ]\\n\", 7);\n\t\treturn(written);\n\t}\n\tif(t2p->pdf_colorspace & T2P_CS_BILEVEL){\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/DeviceGray \\n\", 13);\n\t}\n\tif(t2p->pdf_colorspace & T2P_CS_GRAY){\n\t\t\tif(t2p->pdf_colorspace & T2P_CS_CALGRAY){\n\t\t\t\twritten += t2p_write_pdf_xobject_calcs(t2p, output);\n\t\t\t} else {\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/DeviceGray \\n\", 13);\n\t\t\t}\n\t}\n\tif(t2p->pdf_colorspace & T2P_CS_RGB){\n\t\t\tif(t2p->pdf_colorspace & T2P_CS_CALRGB){\n\t\t\t\twritten += t2p_write_pdf_xobject_calcs(t2p, output);\n\t\t\t} else {\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/DeviceRGB \\n\", 12);\n\t\t\t}\n\t}\n\tif(t2p->pdf_colorspace & T2P_CS_CMYK){\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/DeviceCMYK \\n\", 13);\n\t}\n\tif(t2p->pdf_colorspace & T2P_CS_LAB){\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"[/Lab << \\n\", 10);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/WhitePoint \", 12);\n\t\t\tX_W = t2p->tiff_whitechromaticities[0];\n\t\t\tY_W = t2p->tiff_whitechromaticities[1];\n\t\t\tZ_W = 1.0F - (X_W + Y_W);\n\t\t\tX_W /= Y_W;\n\t\t\tZ_W /= Y_W;\n\t\t\tY_W = 1.0F;\n\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"[%.4f %.4f %.4f] \\n\", X_W, Y_W, Z_W);\n\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Range \", 7);\n\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"[%d %d %d %d] \\n\", \n\t\t\t\tt2p->pdf_labrange[0], \n\t\t\t\tt2p->pdf_labrange[1], \n\t\t\t\tt2p->pdf_labrange[2], \n\t\t\t\tt2p->pdf_labrange[3]);\n\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \">>] \\n\", 5);\n\t\t\t\n\t}\n\t\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              4928,
              0
            ],
            [
              5002,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_cs",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_transfer(T2P* t2p, TIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[32];\n\tint buflen=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) \"<< /Type /ExtGState \\n/TR \", 25);\n\tif(t2p->tiff_transferfunctioncount == 1){\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t       (unsigned long)(t2p->pdf_xrefcount + 1));\n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \", 5);\n\t} else {\n\t\twritten += t2pWriteFile(output, (tdata_t) \"[ \", 2);\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t       (unsigned long)(t2p->pdf_xrefcount + 1));\n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \", 5);\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t       (unsigned long)(t2p->pdf_xrefcount + 2));\n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \", 5);\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t       (unsigned long)(t2p->pdf_xrefcount + 3));\n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \", 5);\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/Identity ] \", 12);\n\t}\n\n\twritten += t2pWriteFile(output, (tdata_t) \" >> \\n\", 5);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              5004,
              0
            ],
            [
              5040,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_transfer",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_transfer_dict(T2P* t2p, TIFF* output, uint16 i){\n\n\ttsize_t written=0;\n\tchar buffer[32];\n\tint buflen=0;\n\t(void)i; /* XXX */\n\n\twritten += t2pWriteFile(output, (tdata_t) \"/FunctionType 0 \\n\", 17);\n\twritten += t2pWriteFile(output, (tdata_t) \"/Domain [0.0 1.0] \\n\", 19);\n\twritten += t2pWriteFile(output, (tdata_t) \"/Range [0.0 1.0] \\n\", 18);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"/Size [%u] \\n\", (1<<t2p->tiff_bitspersample));\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \"/BitsPerSample 16 \\n\", 19);\n\twritten += t2p_write_pdf_stream_dict(((tsize_t)1)<<(t2p->tiff_bitspersample+1), 0, output);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              5042,
              0
            ],
            [
              5059,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_transfer_dict",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF",
              "i": "uint16"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_transfer_stream(T2P* t2p, TIFF* output, uint16 i){\n\n\ttsize_t written=0;\n\n\twritten += t2p_write_pdf_stream(\n\t\tt2p->tiff_transferfunction[i], \n\t\t(((tsize_t)1)<<(t2p->tiff_bitspersample+1)), \n\t\toutput);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              5061,
              0
            ],
            [
              5071,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_transfer_stream",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF",
              "i": "uint16"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_xobject_calcs(T2P* t2p, TIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[256];\n\tint buflen=0;\n\t\n\tfloat X_W=0.0;\n\tfloat Y_W=0.0;\n\tfloat Z_W=0.0;\n\tfloat X_R=0.0;\n\tfloat Y_R=0.0;\n\tfloat Z_R=0.0;\n\tfloat X_G=0.0;\n\tfloat Y_G=0.0;\n\tfloat Z_G=0.0;\n\tfloat X_B=0.0;\n\tfloat Y_B=0.0;\n\tfloat Z_B=0.0;\n\tfloat x_w=0.0;\n\tfloat y_w=0.0;\n\tfloat z_w=0.0;\n\tfloat x_r=0.0;\n\tfloat y_r=0.0;\n\tfloat x_g=0.0;\n\tfloat y_g=0.0;\n\tfloat x_b=0.0;\n\tfloat y_b=0.0;\n\tfloat R=1.0;\n\tfloat G=1.0;\n\tfloat B=1.0;\n\t\n\twritten += t2pWriteFile(output, (tdata_t) \"[\", 1);\n\tif(t2p->pdf_colorspace & T2P_CS_CALGRAY){\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/CalGray \", 9);\n\t\tX_W = t2p->tiff_whitechromaticities[0];\n\t\tY_W = t2p->tiff_whitechromaticities[1];\n\t\tZ_W = 1.0F - (X_W + Y_W);\n\t\tX_W /= Y_W;\n\t\tZ_W /= Y_W;\n\t\tY_W = 1.0F;\n\t}\n\tif(t2p->pdf_colorspace & T2P_CS_CALRGB){\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/CalRGB \", 8);\n\t\tx_w = t2p->tiff_whitechromaticities[0];\n\t\ty_w = t2p->tiff_whitechromaticities[1];\n\t\tx_r = t2p->tiff_primarychromaticities[0];\n\t\ty_r = t2p->tiff_primarychromaticities[1];\n\t\tx_g = t2p->tiff_primarychromaticities[2];\n\t\ty_g = t2p->tiff_primarychromaticities[3];\n\t\tx_b = t2p->tiff_primarychromaticities[4];\n\t\ty_b = t2p->tiff_primarychromaticities[5];\n\t\tz_w = y_w * ((x_g - x_b)*y_r - (x_r-x_b)*y_g + (x_r-x_g)*y_b);\n\t\tY_R = (y_r/R) * ((x_g-x_b)*y_w - (x_w-x_b)*y_g + (x_w-x_g)*y_b) / z_w;\n\t\tX_R = Y_R * x_r / y_r;\n\t\tZ_R = Y_R * (((1-x_r)/y_r)-1);\n\t\tY_G = ((0.0F-(y_g))/G) * ((x_r-x_b)*y_w - (x_w-x_b)*y_r + (x_w-x_r)*y_b) / z_w;\n\t\tX_G = Y_G * x_g / y_g;\n\t\tZ_G = Y_G * (((1-x_g)/y_g)-1);\n\t\tY_B = (y_b/B) * ((x_r-x_g)*y_w - (x_w-x_g)*y_r + (x_w-x_r)*y_g) / z_w;\n\t\tX_B = Y_B * x_b / y_b;\n\t\tZ_B = Y_B * (((1-x_b)/y_b)-1);\n\t\tX_W = (X_R * R) + (X_G * G) + (X_B * B);\n\t\tY_W = (Y_R * R) + (Y_G * G) + (Y_B * B);\n\t\tZ_W = (Z_R * R) + (Z_G * G) + (Z_B * B);\n\t\tX_W /= Y_W;\n\t\tZ_W /= Y_W;\n\t\tY_W = 1.0;\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \"<< \\n\", 4);\n\tif(t2p->pdf_colorspace & T2P_CS_CALGRAY){\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/WhitePoint \", 12);\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"[%.4f %.4f %.4f] \\n\", X_W, Y_W, Z_W);\n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/Gamma 2.2 \\n\", 12);\n\t}\n\tif(t2p->pdf_colorspace & T2P_CS_CALRGB){\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/WhitePoint \", 12);\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"[%.4f %.4f %.4f] \\n\", X_W, Y_W, Z_W);\n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/Matrix \", 8);\n\t\tbuflen=snprintf(buffer, sizeof(buffer), \"[%.4f %.4f %.4f %.4f %.4f %.4f %.4f %.4f %.4f] \\n\", \n\t\t\tX_R, Y_R, Z_R, \n\t\t\tX_G, Y_G, Z_G, \n\t\t\tX_B, Y_B, Z_B); \n\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\twritten += t2pWriteFile(output, (tdata_t) \"/Gamma [2.2 2.2 2.2] \\n\", 22);\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \">>] \\n\", 5);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              5077,
              0
            ],
            [
              5170,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_calcs",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_xobject_icccs(T2P* t2p, TIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[32];\n\tint buflen=0;\n\t\n\twritten += t2pWriteFile(output, (tdata_t) \"[/ICCBased \", 11);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)t2p->pdf_icccs);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \" 0 R] \\n\", 7);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              5176,
              0
            ],
            [
              5189,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_icccs",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_xobject_icccs_dict(T2P* t2p, TIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[32];\n\tint buflen=0;\n\t\n\twritten += t2pWriteFile(output, (tdata_t) \"/N \", 3);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%u \\n\", t2p->tiff_samplesperpixel);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \"/Alternate \", 11);\n\tt2p->pdf_colorspace ^= T2P_CS_ICCBASED;\n\twritten += t2p_write_pdf_xobject_cs(t2p, output);\n\tt2p->pdf_colorspace |= T2P_CS_ICCBASED;\n\twritten += t2p_write_pdf_stream_dict(t2p->tiff_iccprofilelength, 0, output);\n\t\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              5191,
              0
            ],
            [
              5208,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_icccs_dict",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_xobject_icccs_stream(T2P* t2p, TIFF* output){\n\n\ttsize_t written=0;\n\n\twritten += t2p_write_pdf_stream(\n\t\t\t\t(tdata_t) t2p->tiff_iccprofile, \n\t\t\t\t(tsize_t) t2p->tiff_iccprofilelength, \n\t\t\t\toutput);\n\t\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              5210,
              0
            ],
            [
              5220,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_icccs_stream",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_xobject_palettecs_stream(T2P* t2p, TIFF* output){\n\n\ttsize_t written=0;\n\n\twritten += t2p_write_pdf_stream(\n\t\t\t\t(tdata_t) t2p->pdf_palette, \n\t\t\t\t(tsize_t) t2p->pdf_palettesize, \n\t\t\t\toutput);\n\t\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              5226,
              0
            ],
            [
              5236,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_palettecs_stream",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_xobject_decode(T2P* t2p, TIFF* output){\n\n\ttsize_t written=0;\n\tint i=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) \"/Decode [ \", 10);\n\tfor (i=0;i<t2p->tiff_samplesperpixel;i++){\n\t\twritten += t2pWriteFile(output, (tdata_t) \"1 0 \", 4);\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \"]\\n\", 2);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              5242,
              0
            ],
            [
              5254,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_decode",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_xobject_stream_filter(ttile_t tile, T2P* t2p, TIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[32];\n\tint buflen=0;\n\n\tif(t2p->pdf_compression==T2P_COMPRESS_NONE){\n\t\treturn(written);\n\t}\n\twritten += t2pWriteFile(output, (tdata_t) \"/Filter \", 8);\n\tswitch(t2p->pdf_compression){\n#ifdef CCITT_SUPPORT\n\t\tcase T2P_COMPRESS_G4:\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/CCITTFaxDecode \", 16);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/DecodeParms \", 13);\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"<< /K -1 \", 9);\n\t\t\tif(tile==0){\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Columns \", 9);\n\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t       (unsigned long)t2p->tiff_width);\n\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \" /Rows \", 7);\n\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t       (unsigned long)t2p->tiff_length);\n\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t} else {\n\t\t\t\tif(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)==0){\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Columns \", 9);\n\t\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);\n\t\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\t} else {\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/Columns \", 9);\n\t\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);\n\t\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\t}\n\t\t\t\tif(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)==0){\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \" /Rows \", 7);\n\t\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);\n\t\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\t} else {\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \" /Rows \", 7);\n\t\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);\n\t\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t2p->pdf_switchdecode == 0){\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \" /BlackIs1 true \", 16);\n\t\t\t}\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \">>\\n\", 3);\n\t\t\tbreak;\n#endif\n#ifdef JPEG_SUPPORT\n\t\tcase T2P_COMPRESS_JPEG:\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/DCTDecode \", 11);\n\n\t\t\tif(t2p->tiff_photometric != PHOTOMETRIC_YCBCR) {\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/DecodeParms \", 13);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"<< /ColorTransform 1 >>\\n\", 24);\n\t\t\t}\n\t\t\tbreak;\n#endif\n#ifdef ZIP_SUPPORT\n\t\tcase T2P_COMPRESS_ZIP:\n\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/FlateDecode \", 13);\n\t\t\tif(t2p->pdf_compressionquality%100){\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"/DecodeParms \", 13);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \"<< /Predictor \", 14);\n\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%u\", t2p->pdf_compressionquality%100);\n\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \" /Columns \", 10);\n\t\t\t\tbuflen = snprintf(buffer, sizeof(buffer), \"%lu\",\n\t\t\t\t\t\t (unsigned long)t2p->tiff_width);\n\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \" /Colors \", 9);\n\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%u\", t2p->tiff_samplesperpixel);\n\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \" /BitsPerComponent \", 19);\n\t\t\t\tbuflen=snprintf(buffer, sizeof(buffer), \"%u\", t2p->tiff_bitspersample);\n\t\t\t\tcheck_snprintf_ret(t2p, buflen, buffer);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\t\t\t\twritten += t2pWriteFile(output, (tdata_t) \">>\\n\", 3);\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              5261,
              0
            ],
            [
              5363,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_stream_filter",
            "parameters": {
              "tile": "ttile_t",
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_xreftable(T2P* t2p, TIFF* output){\n\n\ttsize_t written=0;\n\tchar buffer[64];\n\tint buflen=0;\n\tuint32 i=0;\n\n\twritten += t2pWriteFile(output, (tdata_t) \"xref\\n0 \", 7);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)(t2p->pdf_xrefcount + 1));\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \" \\n0000000000 65535 f \\n\", 22);\n\tfor (i=0;i<t2p->pdf_xrefcount;i++){\n\t\tsnprintf(buffer, sizeof(buffer), \"%.10lu 00000 n \\n\",\n\t\t\t(unsigned long)t2p->pdf_xrefoffsets[i]);\n\t\twritten += t2pWriteFile(output, (tdata_t) buffer, 20);\n\t}\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              5369,
              0
            ],
            [
              5388,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xreftable",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf_trailer(T2P* t2p, TIFF* output)\n{\n\n\ttsize_t written = 0;\n\tchar buffer[32];\n\tint buflen = 0;\n\tsize_t i = 0;\n\n\tfor (i = 0; i < sizeof(t2p->pdf_fileid) - 8; i += 8)\n\t\tsnprintf(t2p->pdf_fileid + i, 9, \"%.8X\", rand());\n\n\twritten += t2pWriteFile(output, (tdata_t) \"trailer\\n<<\\n/Size \", 17);\n\tbuflen = snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)(t2p->pdf_xrefcount+1));\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \"\\n/Root \", 7);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)t2p->pdf_catalog);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \\n/Info \", 12);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)t2p->pdf_info);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \" 0 R \\n/ID[<\", 11);\n\twritten += t2pWriteFile(output, (tdata_t) t2p->pdf_fileid,\n\t\t\t\tsizeof(t2p->pdf_fileid) - 1);\n\twritten += t2pWriteFile(output, (tdata_t) \"><\", 2);\n\twritten += t2pWriteFile(output, (tdata_t) t2p->pdf_fileid,\n\t\t\t\tsizeof(t2p->pdf_fileid) - 1);\n\twritten += t2pWriteFile(output, (tdata_t) \">]\\n>>\\nstartxref\\n\", 16);\n\tbuflen=snprintf(buffer, sizeof(buffer), \"%lu\", (unsigned long)t2p->pdf_startxref);\n\tcheck_snprintf_ret(t2p, buflen, buffer);\n\twritten += t2pWriteFile(output, (tdata_t) buffer, buflen);\n\twritten += t2pWriteFile(output, (tdata_t) \"\\n%%EOF\\n\", 7);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              5394,
              0
            ],
            [
              5430,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_trailer",
            "parameters": {
              "t2p": "T2P",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "tsize_t t2p_write_pdf(T2P* t2p, TIFF* input, TIFF* output){\n\n\ttsize_t written=0;\n\tttile_t i2=0;\n\ttsize_t streamlen=0;\n\tuint16 i=0;\n\n\tt2p_read_tiff_init(t2p, input);\n\tif(t2p->t2p_error!=T2P_ERR_OK){return(0);}\n\tt2p->pdf_xrefoffsets= (uint32*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_xrefcount,sizeof(uint32)) );\n\tif(t2p->pdf_xrefoffsets==NULL){\n\t\tTIFFError(\n\t\t\tTIFF2PDF_MODULE, \n\t\t\t\"Can't allocate %u bytes of memory for t2p_write_pdf\", \n\t\t\t(unsigned int) (t2p->pdf_xrefcount * sizeof(uint32)) );\n\t\tt2p->t2p_error = T2P_ERR_ERROR;\n\t\treturn(written);\n\t}\n\tt2p->pdf_xrefcount=0;\n\tt2p->pdf_catalog=1;\n\tt2p->pdf_info=2;\n\tt2p->pdf_pages=3;\n\twritten += t2p_write_pdf_header(t2p, output);\n\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\tt2p->pdf_catalog=t2p->pdf_xrefcount;\n\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\twritten += t2p_write_pdf_catalog(t2p, output);\n\twritten += t2p_write_pdf_obj_end(output);\n\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\tt2p->pdf_info=t2p->pdf_xrefcount;\n\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\twritten += t2p_write_pdf_info(t2p, input, output);\n\twritten += t2p_write_pdf_obj_end(output);\n\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\tt2p->pdf_pages=t2p->pdf_xrefcount;\n\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\twritten += t2p_write_pdf_pages(t2p, output);\n\twritten += t2p_write_pdf_obj_end(output);\n\tfor(t2p->pdf_page=0;t2p->pdf_page<t2p->tiff_pagecount;t2p->pdf_page++){\n\t\tt2p_read_tiff_data(t2p, input);\n\t\tif(t2p->t2p_error!=T2P_ERR_OK){return(0);}\n\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\twritten += t2p_write_pdf_page(t2p->pdf_xrefcount, t2p, output);\n\t\twritten += t2p_write_pdf_obj_end(output);\n\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\twritten += t2p_write_pdf_stream_dict_start(output);\n\t\twritten += t2p_write_pdf_stream_dict(0, t2p->pdf_xrefcount+1, output);\n\t\twritten += t2p_write_pdf_stream_dict_end(output);\n\t\twritten += t2p_write_pdf_stream_start(output);\n\t\tstreamlen=written;\n\t\twritten += t2p_write_pdf_page_content_stream(t2p, output);\n\t\tstreamlen=written-streamlen;\n\t\twritten += t2p_write_pdf_stream_end(output);\n\t\twritten += t2p_write_pdf_obj_end(output);\n\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\twritten += t2p_write_pdf_stream_length(streamlen, output);\n\t\twritten += t2p_write_pdf_obj_end(output);\n\t\tif(t2p->tiff_transferfunctioncount != 0){\n\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\t\twritten += t2p_write_pdf_transfer(t2p, output);\n\t\t\twritten += t2p_write_pdf_obj_end(output);\n\t\t\tfor(i=0; i < t2p->tiff_transferfunctioncount; i++){\n\t\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\n\t\t\t\twritten += t2p_write_pdf_transfer_dict(t2p, output, i);\n\t\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\n\t\t\t\twritten += t2p_write_pdf_stream_start(output);\n\t\t\t\t/* streamlen=written; */ /* value not used */\n\t\t\t\twritten += t2p_write_pdf_transfer_stream(t2p, output, i);\n\t\t\t\t/* streamlen=written-streamlen; */ /* value not used */\n\t\t\t\twritten += t2p_write_pdf_stream_end(output);\n\t\t\t\twritten += t2p_write_pdf_obj_end(output);\n\t\t\t}\n\t\t}\n\t\tif( (t2p->pdf_colorspace & T2P_CS_PALETTE) != 0){\n\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\t\tt2p->pdf_palettecs=t2p->pdf_xrefcount;\n\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\n\t\t\twritten += t2p_write_pdf_stream_dict(t2p->pdf_palettesize, 0, output);\n\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\n\t\t\twritten += t2p_write_pdf_stream_start(output);\n\t\t\t/* streamlen=written; */ /* value not used */\n\t\t\twritten += t2p_write_pdf_xobject_palettecs_stream(t2p, output);\n\t\t\t/* streamlen=written-streamlen; */ /* value not used */\n\t\t\twritten += t2p_write_pdf_stream_end(output);\n\t\t\twritten += t2p_write_pdf_obj_end(output);\n\t\t}\n\t\tif( (t2p->pdf_colorspace & T2P_CS_ICCBASED) != 0){\n\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\t\tt2p->pdf_icccs=t2p->pdf_xrefcount;\n\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\n\t\t\twritten += t2p_write_pdf_xobject_icccs_dict(t2p, output);\n\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\n\t\t\twritten += t2p_write_pdf_stream_start(output);\n\t\t\t/* streamlen=written; */ /* value not used */\n\t\t\twritten += t2p_write_pdf_xobject_icccs_stream(t2p, output);\n\t\t\t/* streamlen=written-streamlen; */ /* value not used */\n\t\t\twritten += t2p_write_pdf_stream_end(output);\n\t\t\twritten += t2p_write_pdf_obj_end(output);\n\t\t}\n\t\tif(t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount !=0){\n\t\t\tfor(i2=0;i2<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;i2++){\n\t\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\n\t\t\t\twritten += t2p_write_pdf_xobject_stream_dict(\n\t\t\t\t\ti2+1, \n\t\t\t\t\tt2p, \n\t\t\t\t\toutput);\n\t\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\n\t\t\t\twritten += t2p_write_pdf_stream_start(output);\n\t\t\t\tstreamlen=written;\n\t\t\t\tt2p_read_tiff_size_tile(t2p, input, i2);\n\t\t\t\twritten += t2p_readwrite_pdf_image_tile(t2p, input, output, i2);\n\t\t\t\tt2p_write_advance_directory(t2p, output);\n\t\t\t\tif(t2p->t2p_error!=T2P_ERR_OK){return(0);}\n\t\t\t\tstreamlen=written-streamlen;\n\t\t\t\twritten += t2p_write_pdf_stream_end(output);\n\t\t\t\twritten += t2p_write_pdf_obj_end(output);\n\t\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\t\t\twritten += t2p_write_pdf_stream_length(streamlen, output);\n\t\t\t\twritten += t2p_write_pdf_obj_end(output);\n\t\t\t}\n\t\t} else {\n\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\t\twritten += t2p_write_pdf_stream_dict_start(output);\n\t\t\twritten += t2p_write_pdf_xobject_stream_dict(\n\t\t\t\t0, \n\t\t\t\tt2p, \n\t\t\t\toutput);\n\t\t\twritten += t2p_write_pdf_stream_dict_end(output);\n\t\t\twritten += t2p_write_pdf_stream_start(output);\n\t\t\tstreamlen=written;\n\t\t\tt2p_read_tiff_size(t2p, input);\n\t\t\twritten += t2p_readwrite_pdf_image(t2p, input, output);\n\t\t\tt2p_write_advance_directory(t2p, output);\n\t\t\tif(t2p->t2p_error!=T2P_ERR_OK){return(0);}\n\t\t\tstreamlen=written-streamlen;\n\t\t\twritten += t2p_write_pdf_stream_end(output);\n\t\t\twritten += t2p_write_pdf_obj_end(output);\n\t\t\tt2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;\n\t\t\twritten += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);\n\t\t\twritten += t2p_write_pdf_stream_length(streamlen, output);\n\t\t\twritten += t2p_write_pdf_obj_end(output);\n\t\t}\n\t}\n\tt2p->pdf_startxref = written;\n\twritten += t2p_write_pdf_xreftable(t2p, output);\n\twritten += t2p_write_pdf_trailer(t2p, output);\n\tt2p_disable(output);\n\n\treturn(written);\n}",
          "fn_code_pos": [
            [
              5472,
              0
            ],
            [
              5633,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf",
            "parameters": {
              "t2p": "T2P",
              "input": "TIFF",
              "output": "TIFF"
            },
            "return_type": "tsize_t"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "getopt(int, char**, char*)",
          "fn_dec_pos": [
            [
              56,
              11
            ],
            [
              56,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "tiff2pdf_usage(void)",
          "fn_dec_pos": [
            [
              257,
              5
            ],
            [
              257,
              25
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiff2pdf_usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "tiff2pdf_match_paper_size(float*, float*, char*)",
          "fn_dec_pos": [
            [
              258,
              4
            ],
            [
              258,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiff2pdf_match_paper_size",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "t2p_init(void)",
          "fn_dec_pos": [
            [
              266,
              5
            ],
            [
              266,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_init",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "t2p_validate(T2P*)",
          "fn_dec_pos": [
            [
              267,
              5
            ],
            [
              267,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_validate",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "t2p_write_pdf(T2P*, TIFF*, TIFF*)",
          "fn_dec_pos": [
            [
              268,
              8
            ],
            [
              268,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_free(T2P*)",
          "fn_dec_pos": [
            [
              269,
              5
            ],
            [
              269,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_free",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "t2p_read_tiff_init(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              275,
              5
            ],
            [
              275,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_read_tiff_init",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "t2p_cmp_t2p_page(const void*, const void*)",
          "fn_dec_pos": [
            [
              276,
              4
            ],
            [
              276,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_cmp_t2p_page",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "t2p_read_tiff_data(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              277,
              5
            ],
            [
              277,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_read_tiff_data",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "t2p_read_tiff_size(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              278,
              5
            ],
            [
              278,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_read_tiff_size",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "t2p_read_tiff_size_tile(T2P*, TIFF*, ttile_t)",
          "fn_dec_pos": [
            [
              279,
              5
            ],
            [
              279,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_read_tiff_size_tile",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "t2p_tile_is_right_edge(T2P_TILES, ttile_t)",
          "fn_dec_pos": [
            [
              280,
              4
            ],
            [
              280,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_tile_is_right_edge",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "t2p_tile_is_bottom_edge(T2P_TILES, ttile_t)",
          "fn_dec_pos": [
            [
              281,
              4
            ],
            [
              281,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_tile_is_bottom_edge",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "t2p_tile_is_edge(T2P_TILES, ttile_t)",
          "fn_dec_pos": [
            [
              282,
              4
            ],
            [
              282,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_tile_is_edge",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "t2p_tile_is_corner_edge(T2P_TILES, ttile_t)",
          "fn_dec_pos": [
            [
              283,
              4
            ],
            [
              283,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_tile_is_corner_edge",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "t2p_readwrite_pdf_image(T2P*, TIFF*, TIFF*)",
          "fn_dec_pos": [
            [
              284,
              8
            ],
            [
              284,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_readwrite_pdf_image",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_readwrite_pdf_image_tile(T2P*, TIFF*, TIFF*, ttile_t)",
          "fn_dec_pos": [
            [
              285,
              8
            ],
            [
              285,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_readwrite_pdf_image_tile",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_process_ojpeg_tables(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              287,
              4
            ],
            [
              287,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_process_ojpeg_tables",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "t2p_process_jpeg_strip(unsigned char*, tsize_t*, unsigned char*, tsize_t, tsize_t*, tstrip_t, uint32)",
          "fn_dec_pos": [
            [
              290,
              4
            ],
            [
              290,
              105
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_process_jpeg_strip",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "t2p_tile_collapse_left(tdata_t, tsize_t, uint32, uint32, uint32)",
          "fn_dec_pos": [
            [
              292,
              5
            ],
            [
              292,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_tile_collapse_left",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "t2p_write_advance_directory(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              293,
              5
            ],
            [
              293,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_advance_directory",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "t2p_sample_planar_separate_to_contig(T2P*, unsigned char*, unsigned char*, tsize_t)",
          "fn_dec_pos": [
            [
              294,
              8
            ],
            [
              294,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_sample_planar_separate_to_contig",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_sample_realize_palette(T2P*, unsigned char*)",
          "fn_dec_pos": [
            [
              295,
              8
            ],
            [
              295,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_sample_realize_palette",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_sample_abgr_to_rgb(tdata_t, uint32)",
          "fn_dec_pos": [
            [
              296,
              8
            ],
            [
              296,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_sample_abgr_to_rgb",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_sample_rgba_to_rgb(tdata_t, uint32)",
          "fn_dec_pos": [
            [
              297,
              8
            ],
            [
              297,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_sample_rgba_to_rgb",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_sample_rgbaa_to_rgb(tdata_t, uint32)",
          "fn_dec_pos": [
            [
              298,
              8
            ],
            [
              298,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_sample_rgbaa_to_rgb",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_sample_lab_signed_to_unsigned(tdata_t, uint32)",
          "fn_dec_pos": [
            [
              299,
              8
            ],
            [
              299,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_sample_lab_signed_to_unsigned",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_header(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              300,
              8
            ],
            [
              300,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_header",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_obj_start(uint32, TIFF*)",
          "fn_dec_pos": [
            [
              301,
              8
            ],
            [
              301,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_obj_start",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_obj_end(TIFF*)",
          "fn_dec_pos": [
            [
              302,
              8
            ],
            [
              302,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_obj_end",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_name(unsigned char*, TIFF*)",
          "fn_dec_pos": [
            [
              303,
              8
            ],
            [
              303,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_name",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_string(char*, TIFF*)",
          "fn_dec_pos": [
            [
              304,
              8
            ],
            [
              304,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_string",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_stream(tdata_t, tsize_t, TIFF*)",
          "fn_dec_pos": [
            [
              305,
              8
            ],
            [
              305,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_stream",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_stream_start(TIFF*)",
          "fn_dec_pos": [
            [
              306,
              8
            ],
            [
              306,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_stream_start",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_stream_end(TIFF*)",
          "fn_dec_pos": [
            [
              307,
              8
            ],
            [
              307,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_stream_end",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_stream_dict(tsize_t, uint32, TIFF*)",
          "fn_dec_pos": [
            [
              308,
              8
            ],
            [
              308,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_stream_dict",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_stream_dict_start(TIFF*)",
          "fn_dec_pos": [
            [
              309,
              8
            ],
            [
              309,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_stream_dict_start",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_stream_dict_end(TIFF*)",
          "fn_dec_pos": [
            [
              310,
              8
            ],
            [
              310,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_stream_dict_end",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_stream_length(tsize_t, TIFF*)",
          "fn_dec_pos": [
            [
              311,
              8
            ],
            [
              311,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_stream_length",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_catalog(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              312,
              8
            ],
            [
              312,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_catalog",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_info(T2P*, TIFF*, TIFF*)",
          "fn_dec_pos": [
            [
              313,
              8
            ],
            [
              313,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_info",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_pdf_currenttime(T2P*)",
          "fn_dec_pos": [
            [
              314,
              5
            ],
            [
              314,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_pdf_currenttime",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "t2p_pdf_tifftime(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              315,
              5
            ],
            [
              315,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_pdf_tifftime",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "t2p_write_pdf_pages(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              316,
              8
            ],
            [
              316,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_pages",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_page(uint32, T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              317,
              8
            ],
            [
              317,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_page",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_compose_pdf_page(T2P*)",
          "fn_dec_pos": [
            [
              318,
              5
            ],
            [
              318,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_compose_pdf_page",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "t2p_compose_pdf_page_orient(T2P_BOX*, uint16)",
          "fn_dec_pos": [
            [
              319,
              5
            ],
            [
              319,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_compose_pdf_page_orient",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "t2p_compose_pdf_page_orient_flip(T2P_BOX*, uint16)",
          "fn_dec_pos": [
            [
              320,
              5
            ],
            [
              320,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_compose_pdf_page_orient_flip",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "t2p_write_pdf_page_content(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              321,
              8
            ],
            [
              321,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_page_content",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_xobject_stream_dict(ttile_t, T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              322,
              8
            ],
            [
              322,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_stream_dict",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_xobject_cs(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              323,
              8
            ],
            [
              323,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_cs",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_transfer(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              324,
              8
            ],
            [
              324,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_transfer",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_transfer_dict(T2P*, TIFF*, uint16)",
          "fn_dec_pos": [
            [
              325,
              8
            ],
            [
              325,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_transfer_dict",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_transfer_stream(T2P*, TIFF*, uint16)",
          "fn_dec_pos": [
            [
              326,
              8
            ],
            [
              326,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_transfer_stream",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_xobject_calcs(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              327,
              8
            ],
            [
              327,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_calcs",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_xobject_icccs(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              328,
              8
            ],
            [
              328,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_icccs",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_xobject_icccs_dict(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              329,
              8
            ],
            [
              329,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_icccs_dict",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_xobject_icccs_stream(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              330,
              8
            ],
            [
              330,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_icccs_stream",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_xobject_cs_stream(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              331,
              8
            ],
            [
              331,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_cs_stream",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_xobject_decode(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              332,
              8
            ],
            [
              332,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_decode",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_xobject_stream_filter(ttile_t, T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              333,
              8
            ],
            [
              333,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xobject_stream_filter",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_xreftable(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              334,
              8
            ],
            [
              334,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_xreftable",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_write_pdf_trailer(T2P*, TIFF*)",
          "fn_dec_pos": [
            [
              335,
              8
            ],
            [
              335,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_write_pdf_trailer",
            "parameters": {},
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "t2p_init()",
          "fn_dec_pos": [
            [
              938,
              5
            ],
            [
              938,
              15
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "t2p_init",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\ttdir_t page_directory;\n\tuint32 page_number;\n\tttile_t page_tilecount;\n\tuint32 page_extra;\n} T2P_PAGE;",
          {
            "page_directory": "tdir_t",
            "page_number": "uint32",
            "page_tilecount": "ttile_t",
            "page_extra": "uint32"
          },
          "T2P_PAGE",
          [
            126,
            0
          ],
          [
            131,
            11
          ]
        ],
        [
          "typedef struct {\n\tfloat x1;\n\tfloat y1;\n\tfloat x2;\n\tfloat y2;\n\tfloat mat[9];\n} T2P_BOX;",
          {
            "x1": "float",
            "y1": "float",
            "x2": "float",
            "y2": "float",
            "mat[9]": "float"
          },
          "T2P_BOX",
          [
            134,
            0
          ],
          [
            140,
            10
          ]
        ],
        [
          "typedef struct {\n\tT2P_BOX tile_box;\n} T2P_TILE;",
          {
            "tile_box": "T2P_BOX"
          },
          "T2P_TILE",
          [
            143,
            0
          ],
          [
            145,
            11
          ]
        ],
        [
          "typedef struct {\n\tttile_t tiles_tilecount;\n\tuint32 tiles_tilewidth;\n\tuint32 tiles_tilelength;\n\tuint32 tiles_tilecountx;\n\tuint32 tiles_tilecounty;\n\tuint32 tiles_edgetilewidth;\n\tuint32 tiles_edgetilelength;\n\tT2P_TILE* tiles_tiles;\n} T2P_TILES;",
          {
            "tiles_tilecount": "ttile_t",
            "tiles_tilewidth": "uint32",
            "tiles_tilelength": "uint32",
            "tiles_tilecountx": "uint32",
            "tiles_tilecounty": "uint32",
            "tiles_edgetilewidth": "uint32",
            "tiles_edgetilelength": "uint32",
            "* tiles_tiles": "T2P_TILE"
          },
          "T2P_TILES",
          [
            148,
            0
          ],
          [
            157,
            12
          ]
        ],
        [
          "typedef struct {\n\tt2p_err_t t2p_error;\n\tT2P_PAGE* tiff_pages;\n\tT2P_TILES* tiff_tiles;\n\ttdir_t tiff_pagecount;\n\tuint16 tiff_compression;\n\tuint16 tiff_photometric;\n\tuint16 tiff_fillorder;\n\tuint16 tiff_bitspersample;\n\tuint16 tiff_samplesperpixel;\n\tuint16 tiff_planar;\n\tuint32 tiff_width;\n\tuint32 tiff_length;\n\tfloat tiff_xres;\n\tfloat tiff_yres;\n\tuint16 tiff_orientation;\n\ttoff_t tiff_dataoffset;\n\ttsize_t tiff_datasize;\n\tuint16 tiff_resunit;\n\tuint16 pdf_centimeters;\n\tuint16 pdf_overrideres;\n\tuint16 pdf_overridepagesize;\n\tfloat pdf_defaultxres;\n\tfloat pdf_defaultyres;\n\tfloat pdf_xres;\n\tfloat pdf_yres;\n\tfloat pdf_defaultpagewidth;\n\tfloat pdf_defaultpagelength;\n\tfloat pdf_pagewidth;\n\tfloat pdf_pagelength;\n\tfloat pdf_imagewidth;\n\tfloat pdf_imagelength;\n\tint pdf_image_fillpage; /* 0 (default: no scaling, 1:scale imagesize to pagesize */\n\tT2P_BOX pdf_mediabox;\n\tT2P_BOX pdf_imagebox;\n\tuint16 pdf_majorversion;\n\tuint16 pdf_minorversion;\n\tuint32 pdf_catalog;\n\tuint32 pdf_pages;\n\tuint32 pdf_info;\n\tuint32 pdf_palettecs;\n\tuint16 pdf_fitwindow;\n\tuint32 pdf_startxref;\n#define TIFF2PDF_FILEID_SIZE 33\n\tchar pdf_fileid[TIFF2PDF_FILEID_SIZE];\n#define TIFF2PDF_DATETIME_SIZE 17\n\tchar pdf_datetime[TIFF2PDF_DATETIME_SIZE];\n#define TIFF2PDF_CREATOR_SIZE 512\n\tchar pdf_creator[TIFF2PDF_CREATOR_SIZE];\n#define TIFF2PDF_AUTHOR_SIZE 512\n\tchar pdf_author[TIFF2PDF_AUTHOR_SIZE];\n#define TIFF2PDF_TITLE_SIZE 512\n\tchar pdf_title[TIFF2PDF_TITLE_SIZE];\n#define TIFF2PDF_SUBJECT_SIZE 512\n\tchar pdf_subject[TIFF2PDF_SUBJECT_SIZE];\n#define TIFF2PDF_KEYWORDS_SIZE 512\n\tchar pdf_keywords[TIFF2PDF_KEYWORDS_SIZE];\n\tt2p_cs_t pdf_colorspace;\n\tuint16 pdf_colorspace_invert;\n\tuint16 pdf_switchdecode;\n\tuint16 pdf_palettesize;\n\tunsigned char* pdf_palette;\n\tint pdf_labrange[4];\n\tt2p_compress_t pdf_defaultcompression;\n\tuint16 pdf_defaultcompressionquality;\n\tt2p_compress_t pdf_compression;\n\tuint16 pdf_compressionquality;\n\tuint16 pdf_nopassthrough;\n\tt2p_transcode_t pdf_transcode;\n\tt2p_sample_t pdf_sample;\n\tuint32* pdf_xrefoffsets;\n\tuint32 pdf_xrefcount;\n\ttdir_t pdf_page;\n#ifdef OJPEG_SUPPORT\n\ttdata_t pdf_ojpegdata;\n\tuint32 pdf_ojpegdatalength;\n\tuint32 pdf_ojpegiflength;\n#endif\n\tfloat tiff_whitechromaticities[2];\n\tfloat tiff_primarychromaticities[6];\n\tfloat tiff_referenceblackwhite[2];\n\tuint16* tiff_transferfunction[3];\n\tint pdf_image_interpolate;\t/* 0 (default) : do not interpolate,\n\t\t\t\t\t   1 : interpolate */\n\tuint16 tiff_transferfunctioncount;\n\tuint32 pdf_icccs;\n\tuint32 tiff_iccprofilelength;\n\ttdata_t tiff_iccprofile;\n\n\t/* fields for custom read/write procedures */\n\tFILE *outputfile;\n\tint outputdisable;\n\ttsize_t outputwritten;\n} T2P;",
          {
            "t2p_error": "t2p_err_t",
            "* tiff_pages": "T2P_PAGE",
            "* tiff_tiles": "T2P_TILES",
            "tiff_pagecount": "tdir_t",
            "tiff_compression": "uint16",
            "tiff_photometric": "uint16",
            "tiff_fillorder": "uint16",
            "tiff_bitspersample": "uint16",
            "tiff_samplesperpixel": "uint16",
            "tiff_planar": "uint16",
            "tiff_width": "uint32",
            "tiff_length": "uint32",
            "tiff_xres": "float",
            "tiff_yres": "float",
            "tiff_orientation": "uint16",
            "tiff_dataoffset": "toff_t",
            "tiff_datasize": "tsize_t",
            "tiff_resunit": "uint16",
            "pdf_centimeters": "uint16",
            "pdf_overrideres": "uint16",
            "pdf_overridepagesize": "uint16",
            "pdf_defaultxres": "float",
            "pdf_defaultyres": "float",
            "pdf_xres": "float",
            "pdf_yres": "float",
            "pdf_defaultpagewidth": "float",
            "pdf_defaultpagelength": "float",
            "pdf_pagewidth": "float",
            "pdf_pagelength": "float",
            "pdf_imagewidth": "float",
            "pdf_imagelength": "float",
            "pdf_image_fillpage": "int",
            "pdf_mediabox": "T2P_BOX",
            "pdf_imagebox": "T2P_BOX",
            "pdf_majorversion": "uint16",
            "pdf_minorversion": "uint16",
            "pdf_catalog": "uint32",
            "pdf_pages": "uint32",
            "pdf_info": "uint32",
            "pdf_palettecs": "uint32",
            "pdf_fitwindow": "uint16",
            "pdf_startxref": "uint32",
            "pdf_fileid[TIFF2PDF_FILEID_SIZE]": "char",
            "pdf_datetime[TIFF2PDF_DATETIME_SIZE]": "char",
            "pdf_creator[TIFF2PDF_CREATOR_SIZE]": "char",
            "pdf_author[TIFF2PDF_AUTHOR_SIZE]": "char",
            "pdf_title[TIFF2PDF_TITLE_SIZE]": "char",
            "pdf_subject[TIFF2PDF_SUBJECT_SIZE]": "char",
            "pdf_keywords[TIFF2PDF_KEYWORDS_SIZE]": "char",
            "pdf_colorspace": "t2p_cs_t",
            "pdf_colorspace_invert": "uint16",
            "pdf_switchdecode": "uint16",
            "pdf_palettesize": "uint16",
            "* pdf_palette": "unsigned char",
            "pdf_labrange[4]": "int",
            "pdf_defaultcompression": "t2p_compress_t",
            "pdf_defaultcompressionquality": "uint16",
            "pdf_compression": "t2p_compress_t",
            "pdf_compressionquality": "uint16",
            "pdf_nopassthrough": "uint16",
            "pdf_transcode": "t2p_transcode_t",
            "pdf_sample": "t2p_sample_t",
            "* pdf_xrefoffsets": "uint32",
            "pdf_xrefcount": "uint32",
            "pdf_page": "tdir_t",
            "pdf_ojpegdata": "tdata_t",
            "pdf_ojpegdatalength": "uint32",
            "pdf_ojpegiflength": "uint32",
            "tiff_whitechromaticities[2]": "float",
            "tiff_primarychromaticities[6]": "float",
            "tiff_referenceblackwhite[2]": "float",
            "* tiff_transferfunction[3]": "uint16",
            "pdf_image_interpolate": "int",
            "tiff_transferfunctioncount": "uint16",
            "pdf_icccs": "uint32",
            "tiff_iccprofilelength": "uint32",
            "tiff_iccprofile": "tdata_t",
            "*outputfile": "FILE",
            "outputdisable": "int",
            "outputwritten": "tsize_t"
          },
          "T2P",
          [
            160,
            0
          ],
          [
            253,
            6
          ]
        ],
        [
          "typedef struct {\n\ttdir_t page_directory;\n\tuint32 page_number;\n\tttile_t page_tilecount;\n\tuint32 page_extra;\n} T2P_PAGE;",
          {
            "page_directory": "tdir_t",
            "page_number": "uint32",
            "page_tilecount": "ttile_t",
            "page_extra": "uint32"
          },
          "T2P_PAGE",
          [
            126,
            0
          ],
          [
            131,
            11
          ]
        ],
        [
          "typedef struct {\n\tfloat x1;\n\tfloat y1;\n\tfloat x2;\n\tfloat y2;\n\tfloat mat[9];\n} T2P_BOX;",
          {
            "x1": "float",
            "y1": "float",
            "x2": "float",
            "y2": "float",
            "mat[9]": "float"
          },
          "T2P_BOX",
          [
            134,
            0
          ],
          [
            140,
            10
          ]
        ],
        [
          "typedef struct {\n\tT2P_BOX tile_box;\n} T2P_TILE;",
          {
            "tile_box": "T2P_BOX"
          },
          "T2P_TILE",
          [
            143,
            0
          ],
          [
            145,
            11
          ]
        ],
        [
          "typedef struct {\n\tttile_t tiles_tilecount;\n\tuint32 tiles_tilewidth;\n\tuint32 tiles_tilelength;\n\tuint32 tiles_tilecountx;\n\tuint32 tiles_tilecounty;\n\tuint32 tiles_edgetilewidth;\n\tuint32 tiles_edgetilelength;\n\tT2P_TILE* tiles_tiles;\n} T2P_TILES;",
          {
            "tiles_tilecount": "ttile_t",
            "tiles_tilewidth": "uint32",
            "tiles_tilelength": "uint32",
            "tiles_tilecountx": "uint32",
            "tiles_tilecounty": "uint32",
            "tiles_edgetilewidth": "uint32",
            "tiles_edgetilelength": "uint32",
            "* tiles_tiles": "T2P_TILE"
          },
          "T2P_TILES",
          [
            148,
            0
          ],
          [
            157,
            12
          ]
        ],
        [
          "typedef struct {\n\tt2p_err_t t2p_error;\n\tT2P_PAGE* tiff_pages;\n\tT2P_TILES* tiff_tiles;\n\ttdir_t tiff_pagecount;\n\tuint16 tiff_compression;\n\tuint16 tiff_photometric;\n\tuint16 tiff_fillorder;\n\tuint16 tiff_bitspersample;\n\tuint16 tiff_samplesperpixel;\n\tuint16 tiff_planar;\n\tuint32 tiff_width;\n\tuint32 tiff_length;\n\tfloat tiff_xres;\n\tfloat tiff_yres;\n\tuint16 tiff_orientation;\n\ttoff_t tiff_dataoffset;\n\ttsize_t tiff_datasize;\n\tuint16 tiff_resunit;\n\tuint16 pdf_centimeters;\n\tuint16 pdf_overrideres;\n\tuint16 pdf_overridepagesize;\n\tfloat pdf_defaultxres;\n\tfloat pdf_defaultyres;\n\tfloat pdf_xres;\n\tfloat pdf_yres;\n\tfloat pdf_defaultpagewidth;\n\tfloat pdf_defaultpagelength;\n\tfloat pdf_pagewidth;\n\tfloat pdf_pagelength;\n\tfloat pdf_imagewidth;\n\tfloat pdf_imagelength;\n\tint pdf_image_fillpage; /* 0 (default: no scaling, 1:scale imagesize to pagesize */\n\tT2P_BOX pdf_mediabox;\n\tT2P_BOX pdf_imagebox;\n\tuint16 pdf_majorversion;\n\tuint16 pdf_minorversion;\n\tuint32 pdf_catalog;\n\tuint32 pdf_pages;\n\tuint32 pdf_info;\n\tuint32 pdf_palettecs;\n\tuint16 pdf_fitwindow;\n\tuint32 pdf_startxref;\n#define TIFF2PDF_FILEID_SIZE 33\n\tchar pdf_fileid[TIFF2PDF_FILEID_SIZE];\n#define TIFF2PDF_DATETIME_SIZE 17\n\tchar pdf_datetime[TIFF2PDF_DATETIME_SIZE];\n#define TIFF2PDF_CREATOR_SIZE 512\n\tchar pdf_creator[TIFF2PDF_CREATOR_SIZE];\n#define TIFF2PDF_AUTHOR_SIZE 512\n\tchar pdf_author[TIFF2PDF_AUTHOR_SIZE];\n#define TIFF2PDF_TITLE_SIZE 512\n\tchar pdf_title[TIFF2PDF_TITLE_SIZE];\n#define TIFF2PDF_SUBJECT_SIZE 512\n\tchar pdf_subject[TIFF2PDF_SUBJECT_SIZE];\n#define TIFF2PDF_KEYWORDS_SIZE 512\n\tchar pdf_keywords[TIFF2PDF_KEYWORDS_SIZE];\n\tt2p_cs_t pdf_colorspace;\n\tuint16 pdf_colorspace_invert;\n\tuint16 pdf_switchdecode;\n\tuint16 pdf_palettesize;\n\tunsigned char* pdf_palette;\n\tint pdf_labrange[4];\n\tt2p_compress_t pdf_defaultcompression;\n\tuint16 pdf_defaultcompressionquality;\n\tt2p_compress_t pdf_compression;\n\tuint16 pdf_compressionquality;\n\tuint16 pdf_nopassthrough;\n\tt2p_transcode_t pdf_transcode;\n\tt2p_sample_t pdf_sample;\n\tuint32* pdf_xrefoffsets;\n\tuint32 pdf_xrefcount;\n\ttdir_t pdf_page;\n#ifdef OJPEG_SUPPORT\n\ttdata_t pdf_ojpegdata;\n\tuint32 pdf_ojpegdatalength;\n\tuint32 pdf_ojpegiflength;\n#endif\n\tfloat tiff_whitechromaticities[2];\n\tfloat tiff_primarychromaticities[6];\n\tfloat tiff_referenceblackwhite[2];\n\tuint16* tiff_transferfunction[3];\n\tint pdf_image_interpolate;\t/* 0 (default) : do not interpolate,\n\t\t\t\t\t   1 : interpolate */\n\tuint16 tiff_transferfunctioncount;\n\tuint32 pdf_icccs;\n\tuint32 tiff_iccprofilelength;\n\ttdata_t tiff_iccprofile;\n\n\t/* fields for custom read/write procedures */\n\tFILE *outputfile;\n\tint outputdisable;\n\ttsize_t outputwritten;\n} T2P;",
          {
            "t2p_error": "t2p_err_t",
            "* tiff_pages": "T2P_PAGE",
            "* tiff_tiles": "T2P_TILES",
            "tiff_pagecount": "tdir_t",
            "tiff_compression": "uint16",
            "tiff_photometric": "uint16",
            "tiff_fillorder": "uint16",
            "tiff_bitspersample": "uint16",
            "tiff_samplesperpixel": "uint16",
            "tiff_planar": "uint16",
            "tiff_width": "uint32",
            "tiff_length": "uint32",
            "tiff_xres": "float",
            "tiff_yres": "float",
            "tiff_orientation": "uint16",
            "tiff_dataoffset": "toff_t",
            "tiff_datasize": "tsize_t",
            "tiff_resunit": "uint16",
            "pdf_centimeters": "uint16",
            "pdf_overrideres": "uint16",
            "pdf_overridepagesize": "uint16",
            "pdf_defaultxres": "float",
            "pdf_defaultyres": "float",
            "pdf_xres": "float",
            "pdf_yres": "float",
            "pdf_defaultpagewidth": "float",
            "pdf_defaultpagelength": "float",
            "pdf_pagewidth": "float",
            "pdf_pagelength": "float",
            "pdf_imagewidth": "float",
            "pdf_imagelength": "float",
            "pdf_image_fillpage": "int",
            "pdf_mediabox": "T2P_BOX",
            "pdf_imagebox": "T2P_BOX",
            "pdf_majorversion": "uint16",
            "pdf_minorversion": "uint16",
            "pdf_catalog": "uint32",
            "pdf_pages": "uint32",
            "pdf_info": "uint32",
            "pdf_palettecs": "uint32",
            "pdf_fitwindow": "uint16",
            "pdf_startxref": "uint32",
            "pdf_fileid[TIFF2PDF_FILEID_SIZE]": "char",
            "pdf_datetime[TIFF2PDF_DATETIME_SIZE]": "char",
            "pdf_creator[TIFF2PDF_CREATOR_SIZE]": "char",
            "pdf_author[TIFF2PDF_AUTHOR_SIZE]": "char",
            "pdf_title[TIFF2PDF_TITLE_SIZE]": "char",
            "pdf_subject[TIFF2PDF_SUBJECT_SIZE]": "char",
            "pdf_keywords[TIFF2PDF_KEYWORDS_SIZE]": "char",
            "pdf_colorspace": "t2p_cs_t",
            "pdf_colorspace_invert": "uint16",
            "pdf_switchdecode": "uint16",
            "pdf_palettesize": "uint16",
            "* pdf_palette": "unsigned char",
            "pdf_labrange[4]": "int",
            "pdf_defaultcompression": "t2p_compress_t",
            "pdf_defaultcompressionquality": "uint16",
            "pdf_compression": "t2p_compress_t",
            "pdf_compressionquality": "uint16",
            "pdf_nopassthrough": "uint16",
            "pdf_transcode": "t2p_transcode_t",
            "pdf_sample": "t2p_sample_t",
            "* pdf_xrefoffsets": "uint32",
            "pdf_xrefcount": "uint32",
            "pdf_page": "tdir_t",
            "pdf_ojpegdata": "tdata_t",
            "pdf_ojpegdatalength": "uint32",
            "pdf_ojpegiflength": "uint32",
            "tiff_whitechromaticities[2]": "float",
            "tiff_primarychromaticities[6]": "float",
            "tiff_referenceblackwhite[2]": "float",
            "* tiff_transferfunction[3]": "uint16",
            "pdf_image_interpolate": "int",
            "tiff_transferfunctioncount": "uint16",
            "pdf_icccs": "uint32",
            "tiff_iccprofilelength": "uint32",
            "tiff_iccprofile": "tdata_t",
            "*outputfile": "FILE",
            "outputdisable": "int",
            "outputwritten": "tsize_t"
          },
          "T2P",
          [
            160,
            0
          ],
          [
            253,
            6
          ]
        ],
        [
          "struct tm",
          {},
          "",
          [
            4257,
            1
          ],
          [
            4257,
            10
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <time.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "# include <fcntl.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "# include <io.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            49,
            0
          ],
          [
            50,
            0
          ]
        ],
        [
          "#include \"tiffiop.h\"\n",
          [
            52,
            0
          ],
          [
            53,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            53,
            0
          ],
          [
            54,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n\tT2P_CS_BILEVEL = 0x01,\t/* Bilevel, black and white */\n\tT2P_CS_GRAY = 0x02,\t/* Single channel */\n\tT2P_CS_RGB = 0x04,\t/* Three channel tristimulus RGB */\n\tT2P_CS_CMYK = 0x08,\t/* Four channel CMYK print inkset */\n\tT2P_CS_LAB = 0x10,\t/* Three channel L*a*b* color space */\n\tT2P_CS_PALETTE = 0x1000,/* One of the above with a color map */\n\tT2P_CS_CALGRAY = 0x20,\t/* Calibrated single channel */\n\tT2P_CS_CALRGB = 0x40,\t/* Calibrated three channel tristimulus RGB */\n\tT2P_CS_ICCBASED = 0x80\t/* ICC profile color specification */\n} t2p_cs_t;",
          {
            "T2P_CS_BILEVEL": "",
            "T2P_CS_GRAY": "",
            "T2P_CS_RGB": "",
            "T2P_CS_CMYK": "",
            "T2P_CS_LAB": "",
            "T2P_CS_PALETTE": "",
            "T2P_CS_CALGRAY": "",
            "T2P_CS_CALRGB": "",
            "T2P_CS_ICCBASED": ""
          },
          "t2p_cs_t",
          [
            73,
            0
          ],
          [
            83,
            11
          ]
        ],
        [
          "typedef enum{\n\tT2P_COMPRESS_NONE=0x00\n#ifdef CCITT_SUPPORT\n\t, T2P_COMPRESS_G4=0x01\n#endif\n#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)\n\t, T2P_COMPRESS_JPEG=0x02\n#endif\n#ifdef ZIP_SUPPORT\n\t, T2P_COMPRESS_ZIP=0x04\n#endif\n} t2p_compress_t;",
          {
            "T2P_COMPRESS_NONE": "",
            "T2P_COMPRESS_G4": "",
            "T2P_COMPRESS_JPEG": "",
            "ZIP_SUPPORT": "",
            "T2P_COMPRESS_ZIP": ""
          },
          "t2p_compress_t",
          [
            86,
            0
          ],
          [
            97,
            17
          ]
        ],
        [
          "typedef enum{\n\tT2P_TRANSCODE_RAW=0x01, /* The raw data from the input can be used without recompressing */\n\tT2P_TRANSCODE_ENCODE=0x02 /* The data from the input is perhaps unencoded and reencoded */\n} t2p_transcode_t;",
          {
            "T2P_TRANSCODE_RAW": "",
            "T2P_TRANSCODE_ENCODE": ""
          },
          "t2p_transcode_t",
          [
            100,
            0
          ],
          [
            103,
            18
          ]
        ],
        [
          "typedef enum{\n\tT2P_SAMPLE_NOTHING=0x0000, /* The unencoded samples are normal for the output colorspace */\n\tT2P_SAMPLE_ABGR_TO_RGB=0x0001, /* The unencoded samples are the result of ReadRGBAImage */\n\tT2P_SAMPLE_RGBA_TO_RGB=0x0002, /* The unencoded samples are contiguous RGBA */\n\tT2P_SAMPLE_RGBAA_TO_RGB=0x0004, /* The unencoded samples are RGBA with premultiplied alpha */\n\tT2P_SAMPLE_YCBCR_TO_RGB=0x0008, \n\tT2P_SAMPLE_YCBCR_TO_LAB=0x0010, \n\tT2P_SAMPLE_REALIZE_PALETTE=0x0020, /* The unencoded samples are indexes into the color map */\n\tT2P_SAMPLE_SIGNED_TO_UNSIGNED=0x0040, /* The unencoded samples are signed instead of unsignd */\n\tT2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED=0x0040, /* The L*a*b* samples have a* and b* signed */\n\tT2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG=0x0100 /* The unencoded samples are separate instead of contiguous */\n} t2p_sample_t;",
          {
            "T2P_SAMPLE_NOTHING": "",
            "T2P_SAMPLE_ABGR_TO_RGB": "",
            "T2P_SAMPLE_RGBA_TO_RGB": "",
            "T2P_SAMPLE_RGBAA_TO_RGB": "",
            "T2P_SAMPLE_YCBCR_TO_RGB": "",
            "T2P_SAMPLE_YCBCR_TO_LAB": "",
            "T2P_SAMPLE_REALIZE_PALETTE": "",
            "T2P_SAMPLE_SIGNED_TO_UNSIGNED": "",
            "T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED": "",
            "T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG": ""
          },
          "t2p_sample_t",
          [
            106,
            0
          ],
          [
            117,
            15
          ]
        ],
        [
          "typedef enum{\n\tT2P_ERR_OK = 0, /* This is the value of t2p->t2p_error when there is no error */\n\tT2P_ERR_ERROR = 1 /* This is the value of t2p->t2p_error when there was an error */\n} t2p_err_t;",
          {
            "T2P_ERR_OK": "",
            "T2P_ERR_ERROR": ""
          },
          "t2p_err_t",
          [
            120,
            0
          ],
          [
            123,
            12
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/fax2tiff.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tFILE *in;\n\tTIFF *out = NULL;\n        FAX_Client_Data client_data;\n\tTIFFErrorHandler whandler = NULL;\n\tint compression_in = COMPRESSION_CCITTFAX3;\n\tint compression_out = COMPRESSION_CCITTFAX3;\n\tint fillorder_in = FILLORDER_LSB2MSB;\n\tint fillorder_out = FILLORDER_LSB2MSB;\n\tuint32 group3options_in = 0;\t/* 1d-encoded */\n\tuint32 group3options_out = 0;\t/* 1d-encoded */\n\tuint32 group4options_in = 0;\t/* compressed */\n\tuint32 group4options_out = 0;\t/* compressed */\n\tuint32 defrowsperstrip = (uint32) 0;\n\tuint32 rowsperstrip;\n\tint photometric_in = PHOTOMETRIC_MINISWHITE;\n\tint photometric_out = PHOTOMETRIC_MINISWHITE;\n\tint mode = FAXMODE_CLASSF;\n\tint rows;\n\tint c;\n\tint pn, npages;\n\tfloat resY = 196.0;\n\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"R:X:o:r:1234ABLMPUW5678abcflmprsuvwz?\")) != -1)\n\t\tswitch (c) {\n\t\t\t/* input-related options */\n\t\tcase '3':\t\t/* input is g3-encoded */\n\t\t\tcompression_in = COMPRESSION_CCITTFAX3;\n\t\t\tbreak;\n\t\tcase '4':\t\t/* input is g4-encoded */\n\t\t\tcompression_in = COMPRESSION_CCITTFAX4;\n\t\t\tbreak;\n\t\tcase 'U':\t\t/* input is uncompressed (g3 and g4) */\n\t\t\tgroup3options_in |= GROUP3OPT_UNCOMPRESSED;\n\t\t\tgroup4options_in |= GROUP4OPT_UNCOMPRESSED;\n\t\t\tbreak;\n\t\tcase '1':\t\t/* input is 1d-encoded (g3 only) */\n\t\t\tgroup3options_in &= ~GROUP3OPT_2DENCODING;\n\t\t\tbreak;\n\t\tcase '2':\t\t/* input is 2d-encoded (g3 only) */\n\t\t\tgroup3options_in |= GROUP3OPT_2DENCODING;\n\t\t\tbreak;\n\t\tcase 'P':\t/* input has not-aligned EOL (g3 only) */\n\t\t\tgroup3options_in &= ~GROUP3OPT_FILLBITS;\n\t\t\tbreak;\n\t\tcase 'A':\t\t/* input has aligned EOL (g3 only) */\n\t\t\tgroup3options_in |= GROUP3OPT_FILLBITS;\n\t\t\tbreak;\n\t\tcase 'W':\t\t/* input has 0 mean white */\n\t\t\tphotometric_in = PHOTOMETRIC_MINISWHITE;\n\t\t\tbreak;\n\t\tcase 'B':\t\t/* input has 0 mean black */\n\t\t\tphotometric_in = PHOTOMETRIC_MINISBLACK;\n\t\t\tbreak;\n\t\tcase 'L':\t\t/* input has lsb-to-msb fillorder */\n\t\t\tfillorder_in = FILLORDER_LSB2MSB;\n\t\t\tbreak;\n\t\tcase 'M':\t\t/* input has msb-to-lsb fillorder */\n\t\t\tfillorder_in = FILLORDER_MSB2LSB;\n\t\t\tbreak;\n\t\tcase 'R':\t\t/* input resolution */\n\t\t\tresY = (float) atof(optarg);\n\t\t\tbreak;\n\t\tcase 'X':\t\t/* input width */\n\t\t\txsize = (uint32) atoi(optarg);\n\t\t\tbreak;\n\n\t\t\t/* output-related options */\n\t\tcase '7':\t\t/* generate g3-encoded output */\n\t\t\tcompression_out = COMPRESSION_CCITTFAX3;\n\t\t\tbreak;\n\t\tcase '8':\t\t/* generate g4-encoded output */\n\t\t\tcompression_out = COMPRESSION_CCITTFAX4;\n\t\t\tbreak;\n\t\tcase 'u':\t/* generate uncompressed output (g3 and g4) */\n\t\t\tgroup3options_out |= GROUP3OPT_UNCOMPRESSED;\n\t\t\tgroup4options_out |= GROUP4OPT_UNCOMPRESSED;\n\t\t\tbreak;\n\t\tcase '5':\t/* generate 1d-encoded output (g3 only) */\n\t\t\tgroup3options_out &= ~GROUP3OPT_2DENCODING;\n\t\t\tbreak;\n\t\tcase '6':\t/* generate 2d-encoded output (g3 only) */\n\t\t\tgroup3options_out |= GROUP3OPT_2DENCODING;\n\t\t\tbreak;\n\t\tcase 'c':\t\t/* generate \"classic\" g3 format */\n\t\t\tmode = FAXMODE_CLASSIC;\n\t\t\tbreak;\n\t\tcase 'f':\t\t/* generate Class F format */\n\t\t\tmode = FAXMODE_CLASSF;\n\t\t\tbreak;\n\t\tcase 'm':\t\t/* output's fillorder is msb-to-lsb */\n\t\t\tfillorder_out = FILLORDER_MSB2LSB;\n\t\t\tbreak;\n\t\tcase 'l':\t\t/* output's fillorder is lsb-to-msb */\n\t\t\tfillorder_out = FILLORDER_LSB2MSB;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tout = TIFFOpen(optarg, \"w\");\n\t\t\tif (out == NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: Can not create or open %s\\n\",\n\t\t\t\t    argv[0], optarg);\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a':\t/* generate EOL-aligned output (g3 only) */\n\t\t\tgroup3options_out |= GROUP3OPT_FILLBITS;\n\t\t\tbreak;\n\t\tcase 'p':\t/* generate not EOL-aligned output (g3 only) */\n\t\t\tgroup3options_out &= ~GROUP3OPT_FILLBITS;\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* rows/strip */\n\t\t\tdefrowsperstrip = atol(optarg);\n\t\t\tbreak;\n\t\tcase 's':\t\t/* stretch image by dup'ng scanlines */\n\t\t\tstretch = 1;\n\t\t\tbreak;\n\t\tcase 'w':\t\t/* undocumented -- for testing */\n\t\t\tphotometric_out = PHOTOMETRIC_MINISWHITE;\n\t\t\tbreak;\n\t\tcase 'b':\t\t/* undocumented -- for testing */\n\t\t\tphotometric_out = PHOTOMETRIC_MINISBLACK;\n\t\t\tbreak;\n\t\tcase 'z':\t\t/* undocumented -- for testing */\n\t\t\tcompression_out = COMPRESSION_LZW;\n\t\t\tbreak;\n\t\tcase 'v':\t\t/* -v for info */\n\t\t\tverbose++;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tnpages = argc - optind;\n\tif (npages < 1)\n\t\tusage();\n\n\trowbuf = _TIFFmalloc(TIFFhowmany8(xsize));\n\trefbuf = _TIFFmalloc(TIFFhowmany8(xsize));\n\tif (rowbuf == NULL || refbuf == NULL) {\n\t\tfprintf(stderr, \"%s: Not enough memory\\n\", argv[0]);\n\t\treturn (EXIT_FAILURE);\n\t}\n\n\tif (out == NULL) {\n\t\tout = TIFFOpen(\"fax.tif\", \"w\");\n\t\tif (out == NULL) {\n\t\t\tfprintf(stderr, \"%s: Can not create fax.tif\\n\",\n\t\t\t    argv[0]);\n\t\t\treturn (EXIT_FAILURE);\n\t\t}\n\t}\n\t\t\n\tfaxTIFF = TIFFClientOpen(\"(FakeInput)\", \"w\",\n\t/* TIFFClientOpen() fails if we don't set existing value here */\n\t\t\t\t TIFFClientdata(out),\n\t\t\t\t TIFFGetReadProc(out), TIFFGetWriteProc(out),\n\t\t\t\t TIFFGetSeekProc(out), TIFFGetCloseProc(out),\n\t\t\t\t TIFFGetSizeProc(out), TIFFGetMapFileProc(out),\n\t\t\t\t TIFFGetUnmapFileProc(out));\n\tif (faxTIFF == NULL) {\n\t\tfprintf(stderr, \"%s: Can not create fake input file\\n\",\n\t\t    argv[0]);\n\t\treturn (EXIT_FAILURE);\n\t}\n\tTIFFSetMode(faxTIFF, O_RDONLY);\n\tTIFFSetField(faxTIFF, TIFFTAG_IMAGEWIDTH,\txsize);\n\tTIFFSetField(faxTIFF, TIFFTAG_SAMPLESPERPIXEL,\t1);\n\tTIFFSetField(faxTIFF, TIFFTAG_BITSPERSAMPLE,\t1);\n\tTIFFSetField(faxTIFF, TIFFTAG_FILLORDER,\tfillorder_in);\n\tTIFFSetField(faxTIFF, TIFFTAG_PLANARCONFIG,\tPLANARCONFIG_CONTIG);\n\tTIFFSetField(faxTIFF, TIFFTAG_PHOTOMETRIC,\tphotometric_in);\n\tTIFFSetField(faxTIFF, TIFFTAG_YRESOLUTION,\tresY);\n\tTIFFSetField(faxTIFF, TIFFTAG_RESOLUTIONUNIT,\tRESUNIT_INCH);\n\t\n\t/* NB: this must be done after directory info is setup */\n\tTIFFSetField(faxTIFF, TIFFTAG_COMPRESSION, compression_in);\n\tif (compression_in == COMPRESSION_CCITTFAX3)\n\t\tTIFFSetField(faxTIFF, TIFFTAG_GROUP3OPTIONS, group3options_in);\n\telse if (compression_in == COMPRESSION_CCITTFAX4)\n\t\tTIFFSetField(faxTIFF, TIFFTAG_GROUP4OPTIONS, group4options_in);\n\tfor (pn = 0; optind < argc; pn++, optind++) {\n\t\tin = fopen(argv[optind], \"rb\");\n\t\tif (in == NULL) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s: %s: Can not open\\n\", argv[0], argv[optind]);\n\t\t\tcontinue;\n\t\t}\n#if defined(_WIN32) && defined(USE_WIN32_FILEIO)\n                client_data.fh = _get_osfhandle(fileno(in));\n#else\n                client_data.fd = fileno(in);\n#endif\n                TIFFSetClientdata(faxTIFF, (thandle_t) &client_data);\n\t\tTIFFSetFileName(faxTIFF, (const char*)argv[optind]);\n\t\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, xsize);\n\t\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, 1);\n\t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression_out);\n\t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric_out);\n\t\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\t\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 1);\n\t\tswitch (compression_out) {\n\t\t\t/* g3 */\n\t\t\tcase COMPRESSION_CCITTFAX3:\n\t\t\tTIFFSetField(out, TIFFTAG_GROUP3OPTIONS,\n\t\t\t\t     group3options_out);\n\t\t\tTIFFSetField(out, TIFFTAG_FAXMODE, mode);\n\t\t\trowsperstrip =\n\t\t\t\t(defrowsperstrip)?defrowsperstrip:(uint32)-1L;\n\t\t\tbreak;\n\n\t\t\t/* g4 */\n\t\t\tcase COMPRESSION_CCITTFAX4:\n\t\t\tTIFFSetField(out, TIFFTAG_GROUP4OPTIONS,\n\t\t\t\t     group4options_out);\n\t\t\tTIFFSetField(out, TIFFTAG_FAXMODE, mode);\n\t\t\trowsperstrip =\n\t\t\t\t(defrowsperstrip)?defrowsperstrip:(uint32)-1L;\n\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\trowsperstrip = (defrowsperstrip) ?\n\t\t\t\tdefrowsperstrip : TIFFDefaultStripSize(out, 0);\n\t\t}\n\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\t\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\t\tTIFFSetField(out, TIFFTAG_FILLORDER, fillorder_out);\n\t\tTIFFSetField(out, TIFFTAG_SOFTWARE, \"fax2tiff\");\n\t\tTIFFSetField(out, TIFFTAG_XRESOLUTION, 204.0);\n\t\tif (!stretch) {\n\t\t\tTIFFGetField(faxTIFF, TIFFTAG_YRESOLUTION, &resY);\n\t\t\tTIFFSetField(out, TIFFTAG_YRESOLUTION, resY);\n\t\t} else\n\t\t\tTIFFSetField(out, TIFFTAG_YRESOLUTION, 196.);\n\t\tTIFFSetField(out, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pn, npages);\n\n\t\tif (!verbose)\n\t\t    whandler = TIFFSetWarningHandler(NULL);\n\t\trows = copyFaxFile(faxTIFF, out);\n\t\tfclose(in);\n\t\tif (!verbose)\n\t\t    (void) TIFFSetWarningHandler(whandler);\n\n\t\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, rows);\n\n\t\tif (verbose) {\n\t\t\tfprintf(stderr, \"%s:\\n\", argv[optind]);\n\t\t\tfprintf(stderr, \"%d rows in input\\n\", rows);\n\t\t\tfprintf(stderr, \"%ld total bad rows\\n\",\n\t\t\t    (long) badfaxlines);\n\t\t\tfprintf(stderr, \"%d max consecutive bad rows\\n\", badfaxrun);\n\t\t}\n\t\tif (compression_out == COMPRESSION_CCITTFAX3 &&\n\t\t    mode == FAXMODE_CLASSF) {\n\t\t\tTIFFSetField(out, TIFFTAG_BADFAXLINES, badfaxlines);\n\t\t\tTIFFSetField(out, TIFFTAG_CLEANFAXDATA, badfaxlines ?\n\t\t\t    CLEANFAXDATA_REGENERATED : CLEANFAXDATA_CLEAN);\n\t\t\tTIFFSetField(out, TIFFTAG_CONSECUTIVEBADFAXLINES, badfaxrun);\n\t\t}\n\t\tTIFFWriteDirectory(out);\n\t}\n\tTIFFClose(out);\n\t_TIFFfree(rowbuf);\n\t_TIFFfree(refbuf);\n\treturn (EXIT_SUCCESS);\n}",
          "fn_code_pos": [
            [
              86,
              0
            ],
            [
              359,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\ncopyFaxFile(TIFF* tifin, TIFF* tifout)\n{\n\tuint32 row;\n\tuint32 linesize = TIFFhowmany8(xsize);\n\tuint16 badrun;\n\tint ok;\n\n\ttifin->tif_rawdatasize = (tmsize_t)TIFFGetFileSize(tifin);\n\tif (tifin->tif_rawdatasize == 0) {\n\t\tTIFFError(tifin->tif_name, \"Empty input file\");\n\t\treturn (0);\n\t}\n\ttifin->tif_rawdata = _TIFFmalloc(tifin->tif_rawdatasize);\n\tif (tifin->tif_rawdata == NULL) {\n\t\tTIFFError(tifin->tif_name, \"Not enough memory\");\n\t\treturn (0);\n\t}\n\tif (!ReadOK(tifin, tifin->tif_rawdata, tifin->tif_rawdatasize)) {\n\t\tTIFFError(tifin->tif_name, \"Read error at scanline 0\");\n\t\treturn (0);\n\t}\n\ttifin->tif_rawcp = tifin->tif_rawdata;\n\ttifin->tif_rawcc = tifin->tif_rawdatasize;\n\n\t(*tifin->tif_setupdecode)(tifin);\n\t(*tifin->tif_predecode)(tifin, (tsample_t) 0);\n\ttifin->tif_row = 0;\n\tbadfaxlines = 0;\n\tbadfaxrun = 0;\n\n\t_TIFFmemset(refbuf, 0, linesize);\n\trow = 0;\n\tbadrun = 0;\t\t/* current run of bad lines */\n\twhile (tifin->tif_rawcc > 0) {\n\t\tok = (*tifin->tif_decoderow)(tifin, (tdata_t) rowbuf, \n\t\t\t\t\t     linesize, 0);\n\t\tif (!ok) {\n\t\t\tbadfaxlines++;\n\t\t\tbadrun++;\n\t\t\t/* regenerate line from previous good line */\n\t\t\t_TIFFmemcpy(rowbuf, refbuf, linesize);\n\t\t} else {\n\t\t\tif (badrun > badfaxrun)\n\t\t\t\tbadfaxrun = badrun;\n\t\t\tbadrun = 0;\n\t\t\t_TIFFmemcpy(refbuf, rowbuf, linesize);\n\t\t}\n\t\ttifin->tif_row++;\n\n\t\tif (TIFFWriteScanline(tifout, rowbuf, row, 0) < 0) {\n\t\t\tfprintf(stderr, \"%s: Write error at row %ld.\\n\",\n\t\t\t    tifout->tif_name, (long) row);\n\t\t\tbreak;\n\t\t}\n\t\trow++;\n\t\tif (stretch) {\n\t\t\tif (TIFFWriteScanline(tifout, rowbuf, row, 0) < 0) {\n\t\t\t\tfprintf(stderr, \"%s: Write error at row %ld.\\n\",\n\t\t\t\t    tifout->tif_name, (long) row);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trow++;\n\t\t}\n\t}\n\tif (badrun > badfaxrun)\n\t\tbadfaxrun = badrun;\n\t_TIFFfree(tifin->tif_rawdata);\n\treturn (row);\n}",
          "fn_code_pos": [
            [
              361,
              0
            ],
            [
              430,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copyFaxFile",
            "parameters": {
              "tifin": "TIFF",
              "tifout": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(EXIT_FAILURE);\n}",
          "fn_code_pos": [
            [
              468,
              0
            ],
            [
              479,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "copyFaxFile(TIFF* tifin, TIFF* tifout)",
          "fn_dec_pos": [
            [
              69,
              4
            ],
            [
              69,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "copyFaxFile",
            "parameters": {
              "tifin": "TIFF",
              "tifout": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              70,
              12
            ],
            [
              70,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct _FAX_Client_Data\n{\n#if defined(_WIN32) && defined(USE_WIN32_FILEIO)\n        intptr_t fh; /* Operating system file handle */\n#else\n        int fd;      /* Integer file descriptor */\n#endif\n\n} FAX_Client_Data;",
          {
            "fh": "intptr_t",
            "fd": "int"
          },
          "FAX_Client_Data",
          [
            76,
            0
          ],
          [
            84,
            18
          ]
        ],
        [
          "typedef struct _FAX_Client_Data\n{\n#if defined(_WIN32) && defined(USE_WIN32_FILEIO)\n        intptr_t fh; /* Operating system file handle */\n#else\n        int fd;      /* Integer file descriptor */\n#endif\n\n} FAX_Client_Data;",
          {
            "fh": "intptr_t",
            "fd": "int"
          },
          "FAX_Client_Data",
          [
            76,
            0
          ],
          [
            84,
            18
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdlib.h>\t\t/* should have atof & getopt */\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "# include <fcntl.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "# include <io.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "#include \"tiffiop.h\"\n",
          [
            48,
            0
          ],
          [
            49,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/tiff2ps.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tint dirnum = -1, c, np = 0;\n\tint centered = 0;\n\tdouble bottommargin = 0;\n\tdouble leftmargin = 0;\n\tdouble pageWidth = 0;\n\tdouble pageHeight = 0;\n\tuint32 diroff = 0;\n#if !HAVE_DECL_OPTARG\n\textern char *optarg;\n\textern int optind;\n#endif\n\tFILE* output = stdout;\n\n        pageOrientation[0] = '\\0';\n\n\twhile ((c = getopt(argc, argv, \"b:d:h:H:W:L:i:w:l:o:O:P:C:r:t:acemxyzps1238DT\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'b':\n\t\t\tbottommargin = atof(optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcentered = 1;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tcreator = optarg;\n\t\t\tbreak;\n\t\tcase 'd': /* without -a, this only processes one image at this IFD */\n\t\t\tdirnum = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tPSduplex = TRUE;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tinterpolate = atoi(optarg) ? TRUE:FALSE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tPStumble = TRUE;\n\t\t\tbreak;\n\t\tcase 'e':\n                        PSavoiddeadzone = FALSE;\n\t\t\tgenerateEPSF = TRUE;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tpageHeight = atof(optarg);\n\t\t\tbreak;\n\t\tcase 'H':\n\t\t\tmaxPageHeight = atof(optarg);\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\tmaxPageWidth = atof(optarg);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\tsplitOverlap = atof(optarg);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tuseImagemask = TRUE;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t        switch (optarg[0])\n                          {\n                          case '0':\n                          case '1':\n                          case '2':\n                          case '3':\n                          case '4':\n                          case '5':\n                          case '6':\n                          case '7':\n                          case '8':\n                          case '9': diroff = (uint32) strtoul(optarg, NULL, 0);\n\t\t\t          break;\n                          default: TIFFError (\"-o\", \"Offset must be a numeric value.\");\n\t\t\t    exit (1);\n\t\t\t  }\n\t\t\tbreak;\n\t\tcase 'O':\t\t/* XXX too bad -o is already taken */\n\t\t\toutput = fopen(optarg, \"w\");\n\t\t\tif (output == NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t    \"%s: %s: Cannot open output file.\\n\",\n\t\t\t\t    argv[0], optarg);\n\t\t\t\texit(-2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n                        switch (optarg[0])\n                          {\n                          case 'l':\n                          case 'L': strcpy (pageOrientation, \"Landscape\");\n\t\t\t            break; \n                          case 'p':\n                          case 'P': strcpy (pageOrientation, \"Portrait\");\n\t\t\t            break; \n                          default: TIFFError (\"-P\", \"Page orientation must be Landscape or Portrait\");\n\t\t\t           exit (-1);\n\t\t\t  }\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tleftmargin = atof(optarg);\n\t\t\tbreak;\n\t\tcase 'a': /* removed fall through to generate warning below, R Nolde 09-01-2010 */\n\t\t\tprintAll = TRUE;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tgenerateEPSF = FALSE;\n\t\t\tbreak;\n\t\tcase 'r':\n                        if (strcmp (optarg, \"auto\") == 0)\n\t\t\t  {\n                          rotation = 0;\n                          auto_rotate = TRUE;\n                          }\n                        else\n\t\t\t  {\n \t\t\t  rotation = atoi(optarg);\n                          auto_rotate = FALSE;\n\t\t\t  }\n                        switch (rotation)\n                          {\n\t\t\t  case   0:\n                          case  90:\n                          case 180:\n                          case 270:\n\t\t\t    break;\n\t\t\t  default:\n                            fprintf (stderr, \"Rotation angle must be 90, 180, 270 (degrees ccw) or auto\\n\");\n\t\t\t    exit (-1);\n\t\t\t  }\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tprintAll = FALSE;\n\t\t\tbreak;\n                case 't':\n                        title = optarg;\n                        break;\n\t\tcase 'w':\n\t\t\tpageWidth = atof(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tPSavoiddeadzone = FALSE;\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tlevel2 = FALSE;\n\t\t\tlevel3 = FALSE;\n\t\t\tascii85 = FALSE;\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tlevel2 = TRUE;\n\t\t\tascii85 = TRUE;\t\t\t/* default to yes */\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tlevel3 = TRUE;\n\t\t\tascii85 = TRUE;\t\t\t/* default to yes */\n\t\t\tbreak;\n\t\tcase '8':\n\t\t\tascii85 = FALSE;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tres_unit = RESUNIT_CENTIMETER;\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tres_unit = RESUNIT_INCH;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage(-1);\n\t\t}\n\n        if (useImagemask == TRUE)\n          {\n\t  if ((level2 == FALSE) && (level3 == FALSE))\n            {\n\t    TIFFError (\"-m \",\" imagemask operator requres Postscript Level2 or Level3\");\n\t    exit (1);\n            }\n          }\n\n        if (pageWidth && (maxPageWidth > pageWidth))\n\t  {\n\t  TIFFError (\"-W\", \"Max viewport width cannot exceed page width\");\n\t  exit (1);\n          }\n\n        /* auto rotate requires a specified page width and height */\n        if (auto_rotate == TRUE)\n          {\n\t    /*\n\t  if ((pageWidth == 0) || (pageHeight == 0))\n\t    TIFFWarning (\"-r auto\", \" requires page height and width specified with -h and -w\");\n\t    */\n          if ((maxPageWidth > 0) || (maxPageHeight > 0))\n            {\n\t    TIFFError (\"-r auto\", \" is incompatible with maximum page width/height specified by -H or -W\");\n            exit (1);\n            }\n          }\n        if ((maxPageWidth > 0) && (maxPageHeight > 0))\n            {\n\t    TIFFError (\"-H and -W\", \" Use only one of -H or -W to define a viewport\");\n            exit (1);\n            }\n\n        if ((generateEPSF == TRUE) && (printAll == TRUE))\n          {\n\t  TIFFError(\" -e and -a\", \"Warning: Cannot generate Encapsulated Postscript for multiple images\");\n\t  generateEPSF = FALSE;\n          }\n\n        if ((generateEPSF == TRUE) && (PSduplex == TRUE))\n          {\n\t  TIFFError(\" -e and -D\", \"Warning: Encapsulated Postscript does not support Duplex option\");\n\t  PSduplex = FALSE;\n          }\n\n        if ((generateEPSF == TRUE) && (PStumble == TRUE))\n          {\n\t  TIFFError(\" -e and -T\", \"Warning: Encapsulated Postscript does not support Top Edge Binding option\");\n\t  PStumble = FALSE;\n          }\n\n        if ((generateEPSF == TRUE) && (PSavoiddeadzone == TRUE))\n\t  PSavoiddeadzone = FALSE;\n\n\tfor (; argc - optind > 0; optind++) {\n\t\tTIFF* tif = TIFFOpen(filename = argv[optind], \"r\");\n\t\tif (tif != NULL) {\n\t\t\tif (dirnum != -1\n                            && !TIFFSetDirectory(tif, (tdir_t)dirnum))\n                        {\n                                TIFFClose(tif);\n\t\t\t\treturn (-1);\n                        }\n\t\t\telse if (diroff != 0 &&\n\t\t\t    !TIFFSetSubDirectory(tif, diroff))\n                        {\n                                TIFFClose(tif);\n\t\t\t\treturn (-1);\n                        }\n\t\t\tnp = TIFF2PS(output, tif, pageWidth, pageHeight,\n\t\t\t\t     leftmargin, bottommargin, centered);\n                        if (np < 0)\n                          {\n\t\t\t  TIFFError(\"Error\", \"Unable to process %s\", filename);\n                          }\n\t\t\tTIFFClose(tif);\n\t\t}\n\t}\n\tif (np)\n\t\tPSTail(output, np);\n\telse\n\t\tusage(-1);\n\tif (output != stdout)\n\t\tfclose(output);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              236,
              0
            ],
            [
              492,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncheckImage(TIFF* tif)\n{\n\tswitch (photometric) {\n\tcase PHOTOMETRIC_YCBCR:\n\t\tif ((compression == COMPRESSION_JPEG || compression == COMPRESSION_OJPEG)\n\t\t\t&& planarconfiguration == PLANARCONFIG_CONTIG) {\n\t\t\t/* can rely on libjpeg to convert to RGB */\n\t\t\tTIFFSetField(tif, TIFFTAG_JPEGCOLORMODE,\n\t\t\t\t     JPEGCOLORMODE_RGB);\n\t\t\tphotometric = PHOTOMETRIC_RGB;\n\t\t} else {\n\t\t\tif (level2 || level3)\n\t\t\t\tbreak;\n\t\t\tTIFFError(filename, \"Can not handle image with %s\",\n\t\t\t    \"PhotometricInterpretation=YCbCr\");\n\t\t\treturn (0);\n\t\t}\n\t\t/* fall through... */\n\tcase PHOTOMETRIC_RGB:\n\t\tif (alpha && bitspersample != 8) {\n\t\t\tTIFFError(filename,\n\t\t\t    \"Can not handle %d-bit/sample RGB image with alpha\",\n\t\t\t    bitspersample);\n\t\t\treturn (0);\n\t\t}\n\t\t/* fall through... */\n\tcase PHOTOMETRIC_SEPARATED:\n\tcase PHOTOMETRIC_PALETTE:\n\tcase PHOTOMETRIC_MINISBLACK:\n\tcase PHOTOMETRIC_MINISWHITE:\n\t\tbreak;\n\tcase PHOTOMETRIC_LOGL:\n\tcase PHOTOMETRIC_LOGLUV:\n\t\tif (compression != COMPRESSION_SGILOG &&\n\t\t    compression != COMPRESSION_SGILOG24) {\n\t\t\tTIFFError(filename,\n\t\t    \"Can not handle %s data with compression other than SGILog\",\n\t\t\t    (photometric == PHOTOMETRIC_LOGL) ?\n\t\t\t\t\"LogL\" : \"LogLuv\"\n\t\t\t);\n\t\t\treturn (0);\n\t\t}\n\t\t/* rely on library to convert to RGB/greyscale */\n\t\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\t\tphotometric = (photometric == PHOTOMETRIC_LOGL) ?\n\t\t    PHOTOMETRIC_MINISBLACK : PHOTOMETRIC_RGB;\n\t\tbitspersample = 8;\n\t\tbreak;\n\tcase PHOTOMETRIC_CIELAB:\n\t\t/* fall through... */\n\tdefault:\n\t\tTIFFError(filename,\n\t\t    \"Can not handle image with PhotometricInterpretation=%d\",\n\t\t    photometric);\n\t\treturn (0);\n\t}\n\tswitch (bitspersample) {\n\tcase 1: case 2:\n\tcase 4: case 8:\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\tTIFFError(filename, \"Can not handle %d-bit/sample image\",\n\t\t    bitspersample);\n\t\treturn (0);\n\t}\n\tif (planarconfiguration == PLANARCONFIG_SEPARATE && extrasamples > 0)\n\t\tTIFFWarning(filename, \"Ignoring extra samples\");\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              502,
              0
            ],
            [
              572,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "checkImage",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nPhotoshopBanner(FILE* fd, uint32 w, uint32 h, int bs, int nc, char* startline)\n{\n\tfprintf(fd, \"%%ImageData: %ld %ld %d %d 0 %d 2 \\\"\",\n\t    (long) w, (long) h, bitspersample, nc, bs);\n\tfprintf(fd, startline, nc);\n\tfprintf(fd, \"\\\"\\n\");\n}",
          "fn_code_pos": [
            [
              606,
              0
            ],
            [
              613,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PhotoshopBanner",
            "parameters": {
              "fd": "FILE",
              "w": "uint32",
              "h": "uint32",
              "bs": "int",
              "nc": "int",
              "startline": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nsetupPageState(TIFF* tif, uint32* pw, uint32* ph, double* pprw, double* pprh)\n{\n\tfloat xres = 0.0F, yres = 0.0F;\n\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, pw);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, ph);\n\tif (res_unit == 0)\t/* Not specified as command line option */\n\t\tif (!TIFFGetFieldDefaulted(tif, TIFFTAG_RESOLUTIONUNIT, &res_unit))\n\t\t\tres_unit = RESUNIT_INCH;\n\t/*\n\t * Calculate printable area.\n\t */\n\tif (!TIFFGetField(tif, TIFFTAG_XRESOLUTION, &xres)\n            || fabs(xres) < 0.0000001)\n\t\txres = PS_UNIT_SIZE;\n\tif (!TIFFGetField(tif, TIFFTAG_YRESOLUTION, &yres)\n            || fabs(yres) < 0.0000001)\n\t\tyres = PS_UNIT_SIZE;\n\tswitch (res_unit) {\n\tcase RESUNIT_CENTIMETER:\n\t\txres *= 2.54F, yres *= 2.54F;\n\t\tbreak;\n\tcase RESUNIT_INCH:\n\t\tbreak;\n\tcase RESUNIT_NONE:\t/* Subsequent code assumes we have converted to inches! */\n\t\tres_unit = RESUNIT_INCH;\n\t\tbreak;\n\tdefault:\t/* Last ditch guess for unspecified RESUNIT case\n\t\t\t * check that the resolution is not inches before scaling it.\n\t\t\t * Moved to end of function with additional check, RJN, 08-31-2010\n\t\t\t * if (xres != PS_UNIT_SIZE || yres != PS_UNIT_SIZE)\n\t\t\t * xres *= PS_UNIT_SIZE, yres *= PS_UNIT_SIZE;\n\t\t\t */\n\t\tbreak;\n\t}\n\t/* This is a hack to deal with images that have no meaningful Resolution Size\n\t * but may have x and/or y resolutions of 1 pixel per undefined unit.\n\t */\n\tif ((xres > 1.0) && (xres != PS_UNIT_SIZE))\n\t\t*pprw = PSUNITS(*pw, xres);\n\telse\n\t\t*pprw = PSUNITS(*pw, PS_UNIT_SIZE);\n\tif ((yres > 1.0) && (yres != PS_UNIT_SIZE))\n\t\t*pprh = PSUNITS(*ph, yres);\n\telse\n\t\t*pprh = PSUNITS(*ph, PS_UNIT_SIZE);\n}",
          "fn_code_pos": [
            [
              622,
              0
            ],
            [
              669,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "setupPageState",
            "parameters": {
              "tif": "TIFF",
              "pw": "uint32",
              "ph": "uint32",
              "pprw": "double",
              "pprh": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nisCCITTCompression(TIFF* tif)\n{\n    uint16 compress;\n    TIFFGetField(tif, TIFFTAG_COMPRESSION, &compress);\n    return (compress == COMPRESSION_CCITTFAX3 ||\n\t    compress == COMPRESSION_CCITTFAX4 ||\n\t    compress == COMPRESSION_CCITTRLE ||\n\t    compress == COMPRESSION_CCITTRLEW);\n}",
          "fn_code_pos": [
            [
              671,
              0
            ],
            [
              680,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "isCCITTCompression",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int get_subimage_count(double pagewidth,  double pageheight,\n\t\t       double imagewidth, double imageheight,\n\t\t       int *ximages, int *yimages,\n\t\t       int rotation, double scale)\n{\n\tint pages = 1;\n\tdouble splitheight = 0;  /* Requested Max Height in points */\n\tdouble splitwidth  = 0;  /* Requested Max Width in points */\n\tdouble overlap     = 0;  /* Repeated edge width in points */\n\n\tsplitheight = maxPageHeight * PS_UNIT_SIZE;\n\tsplitwidth  = maxPageWidth  * PS_UNIT_SIZE;\n\toverlap     = splitOverlap  * PS_UNIT_SIZE;\n\tpagewidth  *= PS_UNIT_SIZE;\n\tpageheight *= PS_UNIT_SIZE;\n\n\tif ((imagewidth < 1.0) || (imageheight < 1.0))\n\t{\n\t\tTIFFError(\"get_subimage_count\", \"Invalid image width or height\");\n\t\treturn (0);\n\t}\n\n  switch (rotation)\n    {\n    case 0:\n    case 180: if (splitheight > 0) /* -H maxPageHeight */\n                {\n               if (imageheight > splitheight) /* More than one vertical image segment */\n                 {\n                 if (pagewidth)\n                   *ximages = (int)ceil((scale * imagewidth)  / (pagewidth - overlap));\n                  else\n                   *ximages = 1;\n                 *yimages = (int)ceil((scale * imageheight) / (splitheight - overlap)); /* Max vert pages needed */\n                 }\n                else\n                 {\n                 if (pagewidth)\n                   *ximages = (int)ceil((scale * imagewidth) / (pagewidth - overlap));    /* Max horz pages needed */\n                  else\n                   *ximages = 1;\n                 *yimages = 1;                                                     /* Max vert pages needed */\n                 }\n               }\n              else\n               {\n                if (splitwidth > 0) /* -W maxPageWidth */\n                 {\n                 if (imagewidth >splitwidth)\n                   {\n                   *ximages = (int)ceil((scale * imagewidth)  / (splitwidth - overlap));   /* Max horz pages needed */\n                    if (pageheight)\n                     *yimages = (int)ceil((scale * imageheight) / (pageheight - overlap)); /* Max vert pages needed */\n                    else\n                     *yimages = 1;\n                   }\n                  else\n                   {\n                   *ximages = 1;                                                     /* Max vert pages needed */\n                    if (pageheight)\n                     *yimages = (int)ceil((scale * imageheight) / (pageheight - overlap)); /* Max vert pages needed */\n                    else\n                     *yimages = 1;\n                   }\n                 }\n                else\n                 {\n                 *ximages = 1;\n                 *yimages = 1;\n                 }\n               }\n             break;\n    case 90:\n    case 270: if (splitheight > 0) /* -H maxPageHeight */\n                {\n               if (imagewidth > splitheight) /* More than one vertical image segment */\n                 {\n                 *yimages = (int)ceil((scale * imagewidth) / (splitheight - overlap)); /* Max vert pages needed */\n                  if (pagewidth)\n                   *ximages = (int)ceil((scale * imageheight) / (pagewidth - overlap));   /* Max horz pages needed */\n                  else\n                   *ximages = 1;\n                 }\n                else\n                 {\n                 *yimages = 1;                                                     /* Max vert pages needed */\n                  if (pagewidth)\n                   *ximages = (int)ceil((scale * imageheight) / (pagewidth - overlap));    /* Max horz pages needed */\n                  else\n                   *ximages = 1;\n                 }\n               }\n              else\n               {\n                if (splitwidth > 0) /* -W maxPageWidth */\n                 {\n                 if (imageheight > splitwidth)\n                   {\n                   if (pageheight)\n                     *yimages = (int)ceil((scale * imagewidth) / (pageheight - overlap)); /* Max vert pages needed */\n                    else\n                     *yimages = 1;\n                   *ximages = (int)ceil((scale * imageheight)  / (splitwidth - overlap));   /* Max horz pages needed */\n                   }\n                  else\n                   {\n                   if (pageheight)\n                     *yimages = (int)ceil((scale * imagewidth) / (pageheight - overlap));  /* Max horz pages needed */\n                    else\n                     *yimages = 1;\n                   *ximages = 1;                                                     /* Max vert pages needed */\n                   }\n                 }\n                else\n                 {\n                 *ximages = 1;\n                 *yimages = 1;\n                 }\n               }\n             break;\n    default:  *ximages = 1;\n             *yimages = 1;\n  }\n  pages = (*ximages) * (*yimages);\n  return (pages);\n  }",
          "fn_code_pos": [
            [
              697,
              0
            ],
            [
              822,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_subimage_count",
            "parameters": {
              "pagewidth": "double",
              "pageheight": "double",
              "imagewidth": "double",
              "imageheight": "double",
              "ximages": "int",
              "yimages": "int",
              "rotation": "int",
              "scale": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int exportMaskedImage(FILE *fp, double pagewidth, double pageheight,\n                     double imagewidth, double imageheight,\n                      int row, int column,\n                      double left_offset, double bott_offset,\n                     double scale, int center, int rotation)\n  {\n  double xtran = 0.0;\n  double ytran = 0.0;\n\n  double xscale = 1.0;\n  double yscale = 1.0;\n\n  double splitheight    = 0;  /* Requested Max Height in points */\n  double splitwidth     = 0;  /* Requested Max Width in points */\n  double overlap        = 0;  /* Repeated edge width in points */\n  double subimage_height = 0.0;\n\n  splitheight = maxPageHeight * PS_UNIT_SIZE;\n  splitwidth  = maxPageWidth  * PS_UNIT_SIZE;\n  overlap     = splitOverlap  * PS_UNIT_SIZE;\n  xscale = scale * imagewidth;\n  yscale = scale * imageheight;\n\n  if ((xscale < 0.0) || (yscale < 0.0))\n    {\n    TIFFError(\"exportMaskedImage\", \"Invalid parameters.\");\n    return (-1);\n    }\n\n  /* If images are cropped to a vewport with -H or -W, the output pages are shifted to\n   * the top of each output page rather than the Postscript default lower edge.\n   */\n  switch (rotation)\n    {\n    case 0:\n    case 180: if (splitheight > 0) /* -H maxPageHeight */\n                {\n               if (splitheight < imageheight) /* More than one vertical image segments */\n                 {\n                 /* Intra2net: Keep correct apspect ratio */\n                 xscale = (imagewidth + overlap) * (pageheight / splitheight) * scale;\n\n                 xtran = -1.0 * column * (pagewidth - overlap);\n                  subimage_height = imageheight - ((splitheight - overlap) * row);\n                 ytran  = pageheight - subimage_height * (pageheight / splitheight);\n                  }\n                else  /* Only one page in vertical direction */\n                 {\n                 xtran = -1.0 * column * (pagewidth - overlap);\n                  ytran = splitheight - imageheight;\n                 }\n               }\n              else\n               {\n                if (splitwidth > 0) /* maxPageWidth */\n                 {\n                 if (splitwidth < imagewidth)\n                   {\n                   xtran = -1.0  * column * splitwidth;\n                   ytran = -1.0 * row * (pageheight - overlap);\n                    }\n                  else /* Only one page in horizontal direction */\n                   {\n                    ytran = -1.0 * row * (pageheight - overlap);\n                    xtran = 0;\n                   }\n                 }\n                else    /* Simple case, no splitting */\n                 {\n                 ytran = pageheight - imageheight;\n                 xtran = 0;\n                  }\n                }\n\n            if (imagewidth <= pagewidth) {\n                /* Intra2net: Crop page at the bottom instead of the top (-> output starts at the top).\n                     Only do this in non-page-split mode */\n                if (imageheight <= splitheight) {\n                    ytran = pageheight - imageheight; /* Note: Will be negative for images longer than page size */\n                }\n            }\n              bott_offset += ytran / (center ? 2 : 1);\n              left_offset += xtran / (center ? 2 : 1);\n              break;\n    case  90:\n    case 270:  if (splitheight > 0) /* -H maxPageHeight */\n                {\n               if (splitheight < imagewidth) /* More than one vertical image segments */\n                 {\n                 xtran = -1.0 * column * (pageheight - overlap);\n                 /* Commented code places image at bottom of page instead of top.\n                     ytran = -1.0 * row * splitheight;\n                   */\n                  if (row == 0)\n                    ytran = -1.0 * (imagewidth - splitheight);\n                  else\n                    ytran = -1.0 * (imagewidth - (splitheight - overlap) * (row + 1));\n                  }\n                else  /* Only one page in vertical direction */\n                 {\n                  xtran = -1.0 * column * (pageheight - overlap);\n                  ytran = splitheight - imagewidth;\n                 }\n\t\t}\n              else\n               {\n                if (splitwidth > 0) /* maxPageWidth */\n                 {\n                 if (splitwidth < imageheight)\n                   {\n                    xtran = -1.0  * column * splitwidth;\n                    ytran = -1.0 * row * (pagewidth - overlap);\n                    }\n                  else /* Only one page in horizontal direction */\n                   {\n                    ytran = -1.0 * row * (pagewidth - overlap);\n                    xtran = 0;\n                   }\n                 }\n                else    /* Simple case, no splitting */\n                 {\n                 ytran = pageheight - imageheight;\n                 xtran = 0; /* pagewidth  - imagewidth; */\n                  }\n                }\n              bott_offset += ytran / (center ? 2 : 1);\n              left_offset += xtran / (center ? 2 : 1);\n              break;\n    default:  xtran = 0;\n             ytran = 0;\n    }\n\n  switch (rotation)\n    {\n    case   0: fprintf(fp, \"%f %f translate\\n\", left_offset, bott_offset);\n              fprintf(fp, \"%f %f scale\\n\", xscale, yscale);\n             break;\n    case 180: fprintf(fp, \"%f %f translate\\n\", left_offset, bott_offset);\n              fprintf(fp, \"%f %f scale\\n1 1 translate 180 rotate\\n\",  xscale, yscale);\n              break;\n    case  90: fprintf(fp, \"%f %f translate\\n\", left_offset, bott_offset);\n              fprintf(fp, \"%f %f scale\\n1 0 translate 90 rotate\\n\", yscale, xscale);\n              break;\n    case 270: fprintf(fp, \"%f %f translate\\n\", left_offset, bott_offset);\n              fprintf(fp, \"%f %f scale\\n0 1 translate 270 rotate\\n\", yscale, xscale);\n              break;\n    default:  TIFFError (\"exportMaskedImage\", \"Unsupported rotation angle %d. No rotation\", rotation);\n             fprintf( fp, \"%f %f scale\\n\", xscale, yscale);\n              break;\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              827,
              0
            ],
            [
              979,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "exportMaskedImage",
            "parameters": {
              "fp": "FILE",
              "pagewidth": "double",
              "pageheight": "double",
              "imagewidth": "double",
              "imageheight": "double",
              "row": "int",
              "column": "int",
              "left_offset": "double",
              "bott_offset": "double",
              "scale": "double",
              "center": "int",
              "rotation": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int  psRotateImage (FILE * fd, int rotation, double pswidth, double psheight,\n                    double left_offset, double bottom_offset)\n  {\n  if ((left_offset != 0.0) || (bottom_offset != 0))\n    fprintf (fd, \"%f %f translate\\n\", left_offset, bottom_offset);\n\n  /* Exchange width and height for 90/270 rotations */\n  switch (rotation)\n    {\n    case   0: fprintf (fd, \"%f %f scale\\n\", pswidth, psheight);\n              break;\n    case  90: fprintf (fd, \"%f %f scale\\n1 0 translate 90 rotate\\n\", psheight, pswidth);\n              break;\n    case 180: fprintf (fd, \"%f %f scale\\n1 1 translate 180 rotate\\n\", pswidth, psheight);\n              break;\n    case 270: fprintf (fd, \"%f %f scale\\n0 1 translate 270 rotate\\n\", psheight, pswidth);\n              break;\n    default:  TIFFError (\"psRotateImage\", \"Unsupported rotation %d.\", rotation);\n             fprintf( fd, \"%f %f scale\\n\", pswidth, psheight);\n              return (1);\n    }\n  return (0);\n  }",
          "fn_code_pos": [
            [
              982,
              0
            ],
            [
              1004,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "psRotateImage",
            "parameters": {
              "fd": "FILE",
              "rotation": "int",
              "pswidth": "double",
              "psheight": "double",
              "left_offset": "double",
              "bottom_offset": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int psScaleImage(FILE * fd, double scale, int rotation, int center,\n                 double reqwidth, double reqheight, double pswidth, double psheight,\n                 double left_offset, double bottom_offset)\n  {\n  double hcenter = 0.0, vcenter = 0.0;\n\n  /* Adjust offsets for centering */\n  if (center)\n    {\n    switch (rotation)\n      {\n      case   90: vcenter = (reqheight - pswidth * scale) / 2;\n                hcenter = (reqwidth - psheight * scale) / 2;\n                 fprintf (fd, \"%f %f translate\\n\", hcenter, vcenter);\n                 fprintf (fd, \"%f %f scale\\n1 0 translate 90 rotate\\n\", psheight * scale, pswidth * scale);\n                 break;\n      case  180: hcenter = (reqwidth - pswidth * scale) / 2;\n                vcenter = (reqheight - psheight * scale) / 2;\n                 fprintf (fd, \"%f %f translate\\n\", hcenter, vcenter);\n                 fprintf (fd, \"%f %f scale\\n1 1 translate 180 rotate\\n\", pswidth * scale, psheight * scale);\n                 break;\n      case  270: vcenter = (reqheight - pswidth * scale) / 2;\n                hcenter = (reqwidth - psheight * scale) / 2;\n                 fprintf (fd, \"%f %f translate\\n\", hcenter, vcenter);\n                 fprintf (fd, \"%f %f scale\\n0 1 translate 270 rotate\\n\", psheight * scale, pswidth * scale);\n                 break;\n      case    0:\n      default:   hcenter = (reqwidth - pswidth * scale) / 2;\n                vcenter = (reqheight - psheight * scale) / 2;\n                 fprintf (fd, \"%f %f translate\\n\", hcenter, vcenter);\n                 fprintf (fd, \"%f %f scale\\n\", pswidth * scale, psheight * scale);\n                 break;\n      }\n    }\n  else  /* Not centered */\n    {\n    switch (rotation)\n      {\n      case 0:   fprintf (fd, \"%f %f translate\\n\", left_offset ? left_offset : 0.0,\n                         bottom_offset ? bottom_offset : reqheight - (psheight * scale));\n                fprintf (fd, \"%f %f scale\\n\", pswidth * scale, psheight * scale);\n                break;\n      case 90:  fprintf (fd, \"%f %f translate\\n\", left_offset ? left_offset : 0.0,\n                         bottom_offset ? bottom_offset : reqheight - (pswidth * scale));\n                fprintf (fd, \"%f %f scale\\n1 0 translate 90 rotate\\n\", psheight * scale, pswidth * scale);\n                break;\n      case 180: fprintf (fd, \"%f %f translate\\n\", left_offset ? left_offset : 0.0,\n                         bottom_offset ? bottom_offset : reqheight - (psheight * scale));\n                fprintf (fd, \"%f %f scale\\n1 1 translate 180 rotate\\n\", pswidth * scale, psheight * scale);\n                break;\n      case 270: fprintf (fd, \"%f %f translate\\n\", left_offset ? left_offset : 0.0,\n                         bottom_offset ? bottom_offset : reqheight - (pswidth * scale));\n                fprintf (fd, \"%f %f scale\\n0 1 translate 270 rotate\\n\", psheight * scale, pswidth * scale);\n                break;\n      default:  TIFFError (\"psScaleImage\", \"Unsupported rotation  %d\", rotation);\n               fprintf (fd, \"%f %f scale\\n\", pswidth * scale, psheight * scale);\n                return (1);\n      }\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              1007,
              0
            ],
            [
              1068,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "psScaleImage",
            "parameters": {
              "fd": "FILE",
              "scale": "double",
              "rotation": "int",
              "center": "int",
              "reqwidth": "double",
              "reqheight": "double",
              "pswidth": "double",
              "psheight": "double",
              "left_offset": "double",
              "bottom_offset": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int psPageSize (FILE * fd, int rotation, double pgwidth, double pgheight,\n                double reqwidth, double reqheight, double pswidth, double psheight)\n  {\n  double xscale = 1.0, yscale = 1.0, scale = 1.0;\n  double splitheight;\n  double splitwidth;\n  double new_width;\n  double new_height;\n\n  splitheight = maxPageHeight * PS_UNIT_SIZE;\n  splitwidth  = maxPageWidth  * PS_UNIT_SIZE;\n\n  switch (rotation)\n    {\n    case   0:\n    case 180: if ((splitheight > 0) || (splitwidth > 0))\n                {\n               if (pgwidth != 0 || pgheight != 0)\n                  {\n                 xscale = reqwidth / (splitwidth ? splitwidth : pswidth);\n                 yscale = reqheight / (splitheight ? splitheight : psheight);\n                  scale = (xscale < yscale) ? xscale : yscale;\n                  }\n                new_width = splitwidth ? splitwidth : scale * pswidth;\n                new_height = splitheight ? splitheight : scale * psheight;\n                if (strlen(pageOrientation))\n                  fprintf (fd, \"%%%%PageOrientation: %s\\n\", pageOrientation);\n                else\n                  fprintf (fd, \"%%%%PageOrientation: %s\\n\", (new_width > new_height) ? \"Landscape\" : \"Portrait\");\n                fprintf (fd, \"%%%%PageBoundingBox: 0 0 %ld %ld\\n\", (long)new_width, (long)new_height);\n                fprintf (fd, \"1 dict begin /PageSize [ %f %f ] def currentdict end setpagedevice\\n\",\n                       new_width, new_height);\n                }\n             else /* No viewport defined with -H or -W */\n                {\n                if ((pgwidth == 0) && (pgheight == 0)) /* Image not scaled */\n                  {\n                  if (strlen(pageOrientation))\n                    fprintf (fd, \"%%%%PageOrientation: %s\\n\", pageOrientation);\n                  else\n                    fprintf (fd, \"%%%%PageOrientation: %s\\n\", (pswidth > psheight) ? \"Landscape\" : \"Portrait\");\n                 fprintf (fd, \"%%%%PageBoundingBox: 0 0 %ld %ld\\n\", (long)pswidth, (long)psheight);\n                  fprintf(fd, \"1 dict begin /PageSize [ %f %f ] def currentdict end setpagedevice\\n\",\n                          pswidth, psheight);\n                  }\n               else /* Image scaled */\n                  {\n                  if (strlen(pageOrientation))\n                    fprintf (fd, \"%%%%PageOrientation: %s\\n\", pageOrientation);\n                  else\n                    fprintf (fd, \"%%%%PageOrientation: %s\\n\", (reqwidth > reqheight) ? \"Landscape\" : \"Portrait\");\n                 fprintf (fd, \"%%%%PageBoundingBox: 0 0 %ld %ld\\n\", (long)reqwidth, (long)reqheight);\n                  fprintf(fd, \"1 dict begin /PageSize [ %f %f ] def currentdict end setpagedevice\\n\",\n                           reqwidth, reqheight);\n                  }\n                }\n             break;\n    case  90:\n    case 270: if ((splitheight > 0) || (splitwidth > 0))\n               {\n               if (pgwidth != 0 || pgheight != 0)\n                  {\n                 xscale = reqwidth / (splitwidth ? splitwidth : pswidth);\n                 yscale = reqheight / (splitheight ? splitheight : psheight);\n                  scale = (xscale < yscale) ? xscale : yscale;\n                  }\n                new_width = splitwidth ? splitwidth : scale * psheight;\n                new_height = splitheight ? splitheight : scale * pswidth;\n\n                if (strlen(pageOrientation))\n                  fprintf (fd, \"%%%%PageOrientation: %s\\n\", pageOrientation);\n                else\n                  fprintf (fd, \"%%%%PageOrientation: %s\\n\", (new_width > new_height) ? \"Landscape\" : \"Portrait\");\n                fprintf (fd, \"%%%%PageBoundingBox: 0 0 %ld %ld\\n\", (long)new_width, (long)new_height);\n                fprintf (fd, \"1 dict begin /PageSize [ %f %f ] def currentdict end setpagedevice\\n\",\n                       new_width, new_height);\n                }\n              else\n                {\n                if ((pgwidth == 0) && (pgheight == 0)) /* Image not scaled */\n                  {\n                  if (strlen(pageOrientation))\n                    fprintf (fd, \"%%%%PageOrientation: %s\\n\", pageOrientation);\n                  else\n                    fprintf (fd, \"%%%%PageOrientation: %s\\n\", (psheight > pswidth) ? \"Landscape\" : \"Portrait\");\n                 fprintf (fd, \"%%%%PageBoundingBox: 0 0 %ld %ld\\n\", (long)psheight, (long)pswidth);\n                  fprintf(fd, \"1 dict begin /PageSize [ %f %f ] def currentdict end setpagedevice\\n\",\n                         psheight, pswidth);\n                  }\n               else /* Image scaled */\n                  {\n                  if (strlen(pageOrientation))\n                    fprintf (fd, \"%%%%PageOrientation: %s\\n\", pageOrientation);\n                  else\n                    fprintf (fd, \"%%%%PageOrientation: %s\\n\", (reqwidth > reqheight) ? \"Landscape\" : \"Portrait\");\n                 fprintf (fd, \"%%%%PageBoundingBox: 0 0 %ld %ld\\n\", (long)reqwidth, (long)reqheight);\n                  fprintf(fd, \"1 dict begin /PageSize [ %f %f ] def currentdict end setpagedevice\\n\",\n                          reqwidth, reqheight);\n                  }\n               }\n             break;\n    default:  TIFFError (\"psPageSize\", \"Invalid rotation %d\", rotation);\n      return (1);\n    }\n  fputs(\"<<\\n  /Policies <<\\n    /PageSize 3\\n  >>\\n>> setpagedevice\\n\", fd);\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              1073,
              0
            ],
            [
              1180,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "psPageSize",
            "parameters": {
              "fd": "FILE",
              "rotation": "int",
              "pgwidth": "double",
              "pgheight": "double",
              "reqwidth": "double",
              "reqheight": "double",
              "pswidth": "double",
              "psheight": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int psMaskImage(FILE *fd, TIFF *tif, int rotation, int center,\n                int *npages, double pixwidth, double pixheight,\n               double left_margin, double bottom_margin,\n                double pgwidth, double pgheight,\n               double pswidth, double psheight, double scale)\n  {\n  int i, j;\n  int ximages = 1, yimages = 1;\n  int pages = *npages;\n  double view_width = 0;\n  double view_height = 0;\n\n  if (get_viewport (pgwidth, pgheight, pswidth, psheight, &view_width, &view_height, rotation))\n    {\n    TIFFError (\"get_viewport\", \"Unable to set image viewport\");\n    return (-1);\n    }\n\n  if (get_subimage_count(pgwidth, pgheight, pswidth, psheight,\n                        &ximages, &yimages, rotation, scale) < 1)\n    {\n    TIFFError(\"get_subimage_count\", \"Invalid image count: %d columns, %d rows\", ximages, yimages);\n    return (-1);\n    }\n\n  for (i = 0; i < yimages; i++)\n    {\n    for (j = 0; j < ximages; j++)\n       {\n       pages++;\n       *npages = pages;\n       fprintf(fd, \"%%%%Page: %d %d\\n\", pages, pages);\n\n       /* Write out the PageSize info for non EPS files */\n       if (!generateEPSF && ( level2 || level3 ))\n         {\n         if (psPageSize(fd, rotation, pgwidth, pgheight,\n                        view_width, view_height, pswidth, psheight))\n           return (-1);\n        }\n       fprintf(fd, \"gsave\\n\");\n       fprintf(fd, \"100 dict begin\\n\");\n       if (exportMaskedImage(fd, view_width, view_height, pswidth, psheight,\n                            i, j, left_margin, bottom_margin,\n                            scale, center, rotation))\n        {\n        TIFFError(\"exportMaskedImage\", \"Invalid image parameters.\");\n        return (-1);\n        }\n       PSpage(fd, tif, pixwidth, pixheight);\n       fprintf(fd, \"end\\n\");\n       fprintf(fd, \"grestore\\n\");\n       fprintf(fd, \"showpage\\n\");\n       }\n    }\n\n  return (pages);\n  }",
          "fn_code_pos": [
            [
              1185,
              0
            ],
            [
              1242,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "psMaskImage",
            "parameters": {
              "fd": "FILE",
              "tif": "TIFF",
              "rotation": "int",
              "center": "int",
              "npages": "int",
              "pixwidth": "double",
              "pixheight": "double",
              "left_margin": "double",
              "bottom_margin": "double",
              "pgwidth": "double",
              "pgheight": "double",
              "pswidth": "double",
              "psheight": "double",
              "scale": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int psStart(FILE *fd, int npages, int auto_rotate, int *rotation, double *scale,\n            double ox, double oy, double pgwidth, double pgheight,\n           double reqwidth, double reqheight, double pswidth, double psheight,\n           double left_offset, double bottom_offset)\n  {\n  double maxsource = 0.0;    /* Used for auto rotations */\n  double maxtarget = 0.0;\n  double xscale = 1.0, yscale = 1.0;\n  double splitheight;\n  double splitwidth;\n  double view_width = 0.0, view_height = 0.0;\n  double page_width = 0.0, page_height = 0.0;\n\n  /* Splitheight and splitwidth are in inches */\n  splitheight = maxPageHeight * PS_UNIT_SIZE;\n  splitwidth  = maxPageWidth * PS_UNIT_SIZE;\n\n  page_width = pgwidth * PS_UNIT_SIZE;\n  page_height = pgheight * PS_UNIT_SIZE;\n\n  /* If user has specified a page width and height and requested the\n   * image to be auto-rotated to fit on that media, we match the\n   * longest dimension of the image to the longest dimension of the\n   * target media but we have to ignore auto rotate if user specified\n   * maxPageHeight since this makes life way too complicated. */\n  if (auto_rotate)\n    {\n    if ((splitheight != 0) || (splitwidth != 0))\n      {\n      TIFFError (\"psStart\", \"Auto-rotate is incompatible with page splitting \");\n      return (1);\n      }\n\n    /* Find longest edges in image and output media */\n    maxsource = (pswidth >= psheight) ? pswidth : psheight;\n    maxtarget = (reqwidth >= reqheight) ? reqwidth : reqheight;\n\n    if (((maxsource == pswidth) && (maxtarget != reqwidth)) ||\n        ((maxsource == psheight) && (maxtarget != reqheight)))\n      {  /* optimal orientaion does not match input orientation */\n      *rotation = 90;\n      xscale = (reqwidth - left_offset)/psheight;\n      yscale = (reqheight - bottom_offset)/pswidth;\n      }\n    else /* optimal orientaion matches input orientation */\n      {\n      xscale = (reqwidth - left_offset)/pswidth;\n      yscale = (reqheight - bottom_offset)/psheight;\n      }\n    *scale = (xscale < yscale) ? xscale : yscale;\n\n    /* Do not scale image beyound original size */\n    if (*scale > 1.0)\n      *scale = 1.0;\n\n    /* Set the size of the displayed image to requested page size\n     * and optimal orientation.\n     */\n    if (!npages)\n      PSHead(fd, reqwidth, reqheight, ox, oy);\n\n    return (0);\n    }\n\n  /* N.B. If pgwidth or pgheight are set from maxPageHeight/Width,\n   * we have a problem with the tests below under splitheight.\n   */\n\n  switch (*rotation)  /* Auto rotate has NOT been specified */\n    {\n    case   0:\n    case 180: if ((splitheight != 0)  || (splitwidth != 0))\n                {  /* Viewport clipped to maxPageHeight or maxPageWidth */\n                if ((page_width != 0) || (page_height != 0)) /* Image scaled */\n                  {\n                 xscale = (reqwidth  - left_offset) / (page_width ? page_width : pswidth);\n                 yscale = (reqheight - bottom_offset) / (page_height ? page_height : psheight);\n                  *scale = (xscale < yscale) ? xscale : yscale;\n                  /*\n                  if (*scale > 1.0)\n                    *scale = 1.0;\n                   */\n                 }\n                else       /* Image clipped but not scaled */\n                 *scale = 1.0;\n\n                view_width = splitwidth ? splitwidth : *scale * pswidth;\n                view_height = splitheight ? splitheight: *scale * psheight;\n               }\n              else   /* Viewport not clipped to maxPageHeight or maxPageWidth */\n                {\n                if ((page_width != 0) || (page_height != 0))\n                  {   /* Image scaled  */\n                  xscale = (reqwidth - left_offset) / pswidth;\n                  yscale = (reqheight - bottom_offset) / psheight;\n\n                  view_width = reqwidth;\n                  view_height = reqheight;\n                 }\n                else\n                  {  /* Image not scaled  */\n                  xscale = (pswidth - left_offset)/pswidth;\n                  yscale = (psheight - bottom_offset)/psheight;\n\n                  view_width = pswidth;\n                  view_height = psheight;\n                 }\n               }\n             break;\n    case  90:\n    case 270: if ((splitheight != 0) || (splitwidth != 0))\n                {  /* Viewport clipped to maxPageHeight or maxPageWidth */\n                if ((page_width != 0) || (page_height != 0)) /* Image scaled */\n                  {\n                 xscale = (reqwidth - left_offset)/ psheight;\n                 yscale = (reqheight - bottom_offset)/ pswidth;\n                  *scale = (xscale < yscale) ? xscale : yscale;\n                  /*\n                  if (*scale > 1.0)\n                    *scale = 1.0;\n                 */\n                 }\n                else  /* Image clipped but not scaled */\n                 *scale = 1.0;\n                view_width = splitwidth ? splitwidth : *scale * psheight;\n                view_height = splitheight ? splitheight : *scale * pswidth;\n               }\n              else /* Viewport not clipped to maxPageHeight or maxPageWidth */\n                {\n                if ((page_width != 0) || (page_height != 0)) /* Image scaled */\n                  {\n                  xscale = (reqwidth - left_offset) / psheight;\n                  yscale = (reqheight - bottom_offset) / pswidth;\n\n                 view_width = reqwidth;\n                 view_height = reqheight;\n                 }\n                else\n                  {\n                  xscale = (pswidth  - left_offset)/ psheight;\n                 yscale = (psheight  - bottom_offset)/ pswidth;\n\n                 view_width = psheight;\n                 view_height = pswidth;\n                  }\n                }\n              break;\n    default:  TIFFError (\"psPageSize\", \"Invalid rotation %d\", *rotation);\n              return (1);\n    }\n\n  if (!npages)\n    PSHead(fd, (page_width ? page_width : view_width), (page_height ? page_height : view_height), ox, oy);\n\n  *scale = (xscale < yscale) ? xscale : yscale;\n  if (*scale > 1.0)\n    *scale = 1.0;\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              1245,
              0
            ],
            [
              1404,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "psStart",
            "parameters": {
              "fd": "FILE",
              "npages": "int",
              "auto_rotate": "int",
              "rotation": "int",
              "scale": "double",
              "ox": "double",
              "oy": "double",
              "pgwidth": "double",
              "pgheight": "double",
              "reqwidth": "double",
              "reqheight": "double",
              "pswidth": "double",
              "psheight": "double",
              "left_offset": "double",
              "bottom_offset": "double"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int get_viewport (double pgwidth, double pgheight, double pswidth, double psheight,\n                  double *view_width, double *view_height, int rotation)\n  {\n  /* Only one of maxPageHeight or maxPageWidth can be specified */\n  if (maxPageHeight != 0)   /* Clip the viewport to maxPageHeight on each page */\n    {\n    if (pgheight != 0 && pgheight < maxPageHeight)\n      *view_height = pgheight * PS_UNIT_SIZE;\n    else\n      *view_height = maxPageHeight * PS_UNIT_SIZE;\n    /*\n     * if (res_unit == RESUNIT_CENTIMETER)\n     * *view_height /= 2.54F;\n     */\n    }\n  else\n    {\n    if (pgheight != 0) /* User has set PageHeight with -h flag */\n      {\n      *view_height = pgheight * PS_UNIT_SIZE; /* Postscript size for Page Height in inches */\n      /* if (res_unit == RESUNIT_CENTIMETER)\n       *  *view_height /= 2.54F;\n       */\n      }\n    else /* If no width or height are specified, use the original size from image */\n      switch (rotation)\n        {\n        default:\n        case   0:\n        case 180: *view_height = psheight;\n                 break;\n        case  90:\n        case 270: *view_height = pswidth;\n                 break;\n       }\n    }\n\n  if (maxPageWidth != 0)   /* Clip the viewport to maxPageWidth on each page */\n    {\n    if (pgwidth != 0 && pgwidth < maxPageWidth)\n      *view_width = pgwidth * PS_UNIT_SIZE;\n    else\n      *view_width = maxPageWidth * PS_UNIT_SIZE;\n    /* if (res_unit == RESUNIT_CENTIMETER)\n     *  *view_width /= 2.54F;\n     */\n    }\n  else\n    {\n    if (pgwidth != 0)  /* User has set PageWidth with -w flag */\n      {\n      *view_width = pgwidth * PS_UNIT_SIZE; /* Postscript size for Page Width in inches */\n      /* if (res_unit == RESUNIT_CENTIMETER)\n       * *view_width /= 2.54F;\n       */\n      }\n    else  /* If no width or height are specified, use the original size from image */\n      switch (rotation)\n        {\n        default:\n        case   0:\n        case 180: *view_width = pswidth;\n                 break;\n        case  90:\n        case 270: *view_width = psheight; /* (*view_height / psheight) * psheight; */\n                 break;\n       }\n    }\n\n  return (0);\n  }",
          "fn_code_pos": [
            [
              1406,
              0
            ],
            [
              1476,
              3
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_viewport",
            "parameters": {
              "pgwidth": "double",
              "pgheight": "double",
              "pswidth": "double",
              "psheight": "double",
              "view_width": "double",
              "view_height": "double",
              "rotation": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int TIFF2PS(FILE* fd, TIFF* tif, double pgwidth, double pgheight, double lm, double bm, int center)\n  {\n  uint32 pixwidth = 0, pixheight = 0;  /* Image width and height in pixels */\n  double ox = 0.0, oy = 0.0;  /* Offset from current Postscript origin */\n  double pswidth, psheight;   /* Original raw image width and height in points */\n  double view_width, view_height; /* Viewport width and height in points */\n  double scale = 1.0;\n  double left_offset = lm * PS_UNIT_SIZE;\n  double bottom_offset = bm * PS_UNIT_SIZE;\n  uint32 subfiletype;\n  uint16* sampleinfo;\n  static int npages = 0;\n\n  if (!TIFFGetField(tif, TIFFTAG_XPOSITION, &ox))\n     ox = 0;\n  if (!TIFFGetField(tif, TIFFTAG_YPOSITION, &oy))\n     oy = 0;\n\n  /* Consolidated all the tag information into one code segment, Richard Nolde */\n  do {\n     tf_numberstrips = TIFFNumberOfStrips(tif);\n     TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &tf_rowsperstrip);\n     TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n     TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n     TIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarconfiguration);\n     TIFFGetField(tif, TIFFTAG_COMPRESSION, &compression);\n     TIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES, &extrasamples, &sampleinfo);\n     alpha = (extrasamples == 1 && sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\n     if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometric))\n       {\n       switch (samplesperpixel - extrasamples)\n             {\n            case 1: if (isCCITTCompression(tif))\n                      photometric = PHOTOMETRIC_MINISWHITE;\n                    else\n                       photometric = PHOTOMETRIC_MINISBLACK;\n                    break;\n            case 3: photometric = PHOTOMETRIC_RGB;\n                    break;\n            case 4: photometric = PHOTOMETRIC_SEPARATED;\n                    break;\n            }\n       }\n\n     /* Read image tags for width and height in pixels pixwidth, pixheight,\n      * and convert to points pswidth, psheight\n      */\n     setupPageState(tif, &pixwidth, &pixheight, &pswidth, &psheight);\n     view_width = pswidth;\n     view_height = psheight;\n\n     if (get_viewport (pgwidth, pgheight, pswidth, psheight, &view_width, &view_height, rotation))\n       {\n       TIFFError(\"get_viewport\", \"Unable to set image viewport\");\n       return (1);\n       }\n\n     /* Write the Postscript file header with Bounding Box and Page Size definitions */\n     if (psStart(fd, npages, auto_rotate, &rotation, &scale, ox, oy,\n                pgwidth, pgheight, view_width, view_height, pswidth, psheight,\n                 left_offset, bottom_offset))\n       return (-1);\n\n     if (checkImage(tif))  /* Aborts if unsupported image parameters */\n       {\n       tf_bytesperrow = TIFFScanlineSize(tif);\n\n       /* Set viewport clipping and scaling options */\n       if ((maxPageHeight) || (maxPageWidth)  || (pgwidth != 0) || (pgheight != 0))\n         {\n        if ((maxPageHeight) || (maxPageWidth)) /* used -H or -W  option */\n           {\n          if (psMaskImage(fd, tif, rotation, center, &npages, pixwidth, pixheight,\n                          left_offset, bottom_offset, pgwidth, pgheight,\n                           pswidth, psheight, scale) < 0)\n            return (-1);\n          }\n         else  /* N.B. Setting maxPageHeight no longer sets pgheight */\n           {\n           if (pgwidth != 0 || pgheight != 0)\n             {\n             /* User did not specify a maxium page height or width using -H or -W flag\n              * but did use -h or -w flag to scale to a specific size page.\n              */\n             npages++;\n             fprintf(fd, \"%%%%Page: %d %d\\n\", npages, npages);\n\n             if (!generateEPSF && ( level2 || level3 ))\n               {\n              /* Write out the PageSize info for non EPS files */\n              if (psPageSize(fd, rotation, pgwidth, pgheight,\n                              view_width, view_height, pswidth, psheight))\n                return (-1);\n               }\n             fprintf(fd, \"gsave\\n\");\n             fprintf(fd, \"100 dict begin\\n\");\n             if (psScaleImage(fd, scale, rotation, center, view_width, view_height,\n                              pswidth, psheight, left_offset, bottom_offset))\n              return (-1);\n\n             PSpage(fd, tif, pixwidth, pixheight);\n             fprintf(fd, \"end\\n\");\n             fprintf(fd, \"grestore\\n\");\n             fprintf(fd, \"showpage\\n\");\n            }\n          }\n        }\n       else  /* Simple rotation: user did not use -H, -W, -h or -w */\n         {\n         npages++;\n         fprintf(fd, \"%%%%Page: %d %d\\n\", npages, npages);\n\n         if (!generateEPSF && ( level2 || level3 ))\n           {\n          /* Write out the PageSize info for non EPS files */\n          if (psPageSize(fd, rotation, pgwidth, pgheight,\n                          view_width, view_height, pswidth, psheight))\n           return (-1);\n         }\n         fprintf(fd, \"gsave\\n\");\n         fprintf(fd, \"100 dict begin\\n\");\n        if (psRotateImage(fd, rotation, pswidth, psheight, left_offset, bottom_offset))\n           return (-1);\n\n         PSpage(fd, tif, pixwidth, pixheight);\n         fprintf(fd, \"end\\n\");\n         fprintf(fd, \"grestore\\n\");\n         fprintf(fd, \"showpage\\n\");\n         }\n       }\n  if (generateEPSF)\n    break;\n  if (auto_rotate)\n    rotation = 0.0;\n  TIFFGetFieldDefaulted(tif, TIFFTAG_SUBFILETYPE, &subfiletype);\n  } while (((subfiletype & FILETYPE_PAGE) || printAll) && TIFFReadDirectory(tif));\n\nreturn(npages);\n}",
          "fn_code_pos": [
            [
              1485,
              0
            ],
            [
              1623,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFF2PS",
            "parameters": {
              "fd": "FILE",
              "tif": "TIFF",
              "pgwidth": "double",
              "pgheight": "double",
              "lm": "double",
              "bm": "double",
              "center": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\nPSHead(FILE *fd, double pagewidth, double pageheight, double xoff, double yoff)\n{\n\ttime_t t;\n\n\tt = time(0);\n\tfprintf(fd, \"%%!PS-Adobe-3.0%s\\n\", generateEPSF ? \" EPSF-3.0\" : \"\");\n\tfprintf(fd, \"%%%%Creator: %s\\n\", creator ? creator : \"tiff2ps\");\n        fprintf(fd, \"%%%%Title: %s\\n\", title ? title : filename);\n\tfprintf(fd, \"%%%%CreationDate: %s\", ctime(&t));\n\tfprintf(fd, \"%%%%DocumentData: Clean7Bit\\n\");\n\t/* NB: should use PageBoundingBox for each page instead of BoundingBox *\n         * PageBoundingBox DSC added in PSPageSize function, R Nolde 09-01-2010\n         */\n\tfprintf(fd, \"%%%%Origin: %ld %ld\\n\", (long) xoff, (long) yoff);\n        fprintf(fd, \"%%%%BoundingBox: 0 0 %ld %ld\\n\",\n\t       (long) ceil(pagewidth), (long) ceil(pageheight));\n\n\tfprintf(fd, \"%%%%LanguageLevel: %d\\n\", (level3 ? 3 : (level2 ? 2 : 1)));\n        if (generateEPSF == TRUE)\n\t  fprintf(fd, \"%%%%Pages: 1 1\\n\");\n        else\n\t  fprintf(fd, \"%%%%Pages: (atend)\\n\");\n\tfprintf(fd, \"%%%%EndComments\\n\");\n        if (generateEPSF == FALSE)\n          {\n  \t  fprintf(fd, \"%%%%BeginSetup\\n\");\n\t  if (PSduplex)\n\t\tfprintf(fd, \"%s\", DuplexPreamble);\n\t  if (PStumble)\n\t\tfprintf(fd, \"%s\", TumblePreamble);\n\t  if (PSavoiddeadzone && (level2 || level3))\n\t\tfprintf(fd, \"%s\", AvoidDeadZonePreamble);\n\t  fprintf(fd, \"%%%%EndSetup\\n\");\n\t  }\n}",
          "fn_code_pos": [
            [
              1657,
              0
            ],
            [
              1692,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSHead",
            "parameters": {
              "fd": "FILE",
              "pagewidth": "double",
              "pageheight": "double",
              "xoff": "double",
              "yoff": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nPSTail(FILE *fd, int npages)\n{\n\tfprintf(fd, \"%%%%Trailer\\n\");\n        if (generateEPSF == FALSE)\n\t  fprintf(fd, \"%%%%Pages: %d\\n\", npages);\n\tfprintf(fd, \"%%%%EOF\\n\");\n}",
          "fn_code_pos": [
            [
              1694,
              0
            ],
            [
              1701,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSTail",
            "parameters": {
              "fd": "FILE",
              "npages": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ncheckcmap(TIFF* tif, int n, uint16* r, uint16* g, uint16* b)\n{\n\t(void) tif;\n\twhile (n-- > 0)\n\t\tif (*r++ >= 256 || *g++ >= 256 || *b++ >= 256)\n\t\t\treturn (16);\n\tTIFFWarning(filename, \"Assuming 8-bit colormap\");\n\treturn (8);\n}",
          "fn_code_pos": [
            [
              1703,
              0
            ],
            [
              1712,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "checkcmap",
            "parameters": {
              "tif": "TIFF",
              "n": "int",
              "r": "uint16",
              "g": "uint16",
              "b": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nPS_Lvl2colorspace(FILE* fd, TIFF* tif)\n{\n\tuint16 *rmap, *gmap, *bmap;\n\tint i, num_colors;\n\tconst char * colorspace_p;\n\n\tswitch ( photometric )\n\t{\n\tcase PHOTOMETRIC_SEPARATED:\n\t\tcolorspace_p = \"CMYK\";\n\t\tbreak;\n\n\tcase PHOTOMETRIC_RGB:\n\t\tcolorspace_p = \"RGB\";\n\t\tbreak;\n\n\tdefault:\n\t\tcolorspace_p = \"Gray\";\n\t}\n\n\t/*\n\t * Set up PostScript Level 2 colorspace according to\n\t * section 4.8 in the PostScript refenence manual.\n\t */\n\tfputs(\"% PostScript Level 2 only.\\n\", fd);\n\tif (photometric != PHOTOMETRIC_PALETTE) {\n\t\tif (photometric == PHOTOMETRIC_YCBCR) {\n\t\t    /* MORE CODE HERE */\n\t\t}\n\t\tfprintf(fd, \"/Device%s setcolorspace\\n\", colorspace_p );\n\t\treturn;\n\t}\n\n\t/*\n\t * Set up an indexed/palette colorspace\n\t */\n\tnum_colors = (1 << bitspersample);\n\tif (!TIFFGetField(tif, TIFFTAG_COLORMAP, &rmap, &gmap, &bmap)) {\n\t\tTIFFError(filename,\n\t\t\t\"Palette image w/o \\\"Colormap\\\" tag\");\n\t\treturn;\n\t}\n\tif (checkcmap(tif, num_colors, rmap, gmap, bmap) == 16) {\n\t\t/*\n\t\t * Convert colormap to 8-bits values.\n\t\t */\n#define\tCVT(x)\t\t(((x) * 255) / ((1L<<16)-1))\n\t\tfor (i = 0; i < num_colors; i++) {\n\t\t\trmap[i] = CVT(rmap[i]);\n\t\t\tgmap[i] = CVT(gmap[i]);\n\t\t\tbmap[i] = CVT(bmap[i]);\n\t\t}\n#undef CVT\n\t}\n\tfprintf(fd, \"[ /Indexed /DeviceRGB %d\", num_colors - 1);\n\tif (ascii85) {\n\t\tAscii85Init();\n\t\tfputs(\"\\n<~\", fd);\n\t\tascii85breaklen -= 2;\n\t} else\n\t\tfputs(\" <\", fd);\n\tfor (i = 0; i < num_colors; i++) {\n\t\tif (ascii85) {\n\t\t\tAscii85Put((unsigned char)rmap[i], fd);\n\t\t\tAscii85Put((unsigned char)gmap[i], fd);\n\t\t\tAscii85Put((unsigned char)bmap[i], fd);\n\t\t} else {\n\t\t\tfputs((i % 8) ? \" \" : \"\\n  \", fd);\n\t\t\tfprintf(fd, \"%02x%02x%02x\",\n\t\t\t    rmap[i], gmap[i], bmap[i]);\n\t\t}\n\t}\n\tif (ascii85)\n\t\tAscii85Flush(fd);\n\telse\n\t\tfputs(\">\\n\", fd);\n\tfputs(\"] setcolorspace\\n\", fd);\n}",
          "fn_code_pos": [
            [
              1714,
              0
            ],
            [
              1792,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PS_Lvl2colorspace",
            "parameters": {
              "fd": "FILE",
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nPS_Lvl2ImageDict(FILE* fd, TIFF* tif, uint32 w, uint32 h)\n{\n\tint use_rawdata;\n\tuint32 tile_width, tile_height;\n\tuint16 predictor, minsamplevalue, maxsamplevalue;\n\tint repeat_count;\n\tchar im_h[64], im_x[64], im_y[64];\n\tchar * imageOp = \"image\";\n\n\tif ( useImagemask && (bitspersample == 1) )\n\t\timageOp = \"imagemask\";\n\n\t(void)strcpy(im_x, \"0\");\n\t(void)snprintf(im_y, sizeof(im_y), \"%lu\", (long) h);\n\t(void)snprintf(im_h, sizeof(im_h), \"%lu\", (long) h);\n\ttile_width = w;\n\ttile_height = h;\n\tif (TIFFIsTiled(tif)) {\n\t\trepeat_count = TIFFNumberOfTiles(tif);\n\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width);\n\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height);\n\t\tif (tile_width > w || tile_height > h ||\n\t\t    (w % tile_width) != 0 || (h % tile_height != 0)) {\n\t\t\t/*\n\t\t\t * The tiles does not fit image width and height.\n\t\t\t * Set up a clip rectangle for the image unit square.\n\t\t\t */\n\t\t\tfputs(\"0 0 1 1 rectclip\\n\", fd);\n\t\t}\n\t\tif (tile_width < w) {\n\t\t\tfputs(\"/im_x 0 def\\n\", fd);\n\t\t\t(void)strcpy(im_x, \"im_x neg\");\n\t\t}\n\t\tif (tile_height < h) {\n\t\t\tfputs(\"/im_y 0 def\\n\", fd);\n\t\t\t(void)snprintf(im_y, sizeof(im_y), \"%lu im_y sub\", (unsigned long) h);\n\t\t}\n\t} else {\n\t\trepeat_count = tf_numberstrips;\n\t\ttile_height = tf_rowsperstrip;\n\t\tif (tile_height > h)\n\t\t\ttile_height = h;\n\t\tif (repeat_count > 1) {\n\t\t\tfputs(\"/im_y 0 def\\n\", fd);\n\t\t\tfprintf(fd, \"/im_h %lu def\\n\",\n\t\t\t    (unsigned long) tile_height);\n\t\t\t(void)strcpy(im_h, \"im_h\");\n\t\t\t(void)snprintf(im_y, sizeof(im_y), \"%lu im_y sub\", (unsigned long) h);\n\t\t}\n\t}\n\n\t/*\n\t * Output start of exec block\n\t */\n\tfputs(\"{ % exec\\n\", fd);\n\n\tif (repeat_count > 1)\n\t\tfprintf(fd, \"%d { %% repeat\\n\", repeat_count);\n\n\t/*\n\t * Output filter options and image dictionary.\n\t */\n\tif (ascii85)\n\t\tfputs(\" /im_stream currentfile /ASCII85Decode filter def\\n\",\n\t\t    fd);\n\tfputs(\" <<\\n\", fd);\n\tfputs(\"  /ImageType 1\\n\", fd);\n\tfprintf(fd, \"  /Width %lu\\n\", (unsigned long) tile_width);\n\t/*\n\t * Workaround for some software that may crash when last strip\n\t * of image contains fewer number of scanlines than specified\n\t * by the `/Height' variable. So for stripped images with multiple\n\t * strips we will set `/Height' as `im_h', because one is \n\t * recalculated for each strip - including the (smaller) final strip.\n\t * For tiled images and images with only one strip `/Height' will\n\t * contain number of scanlines in tile (or image height in case of\n\t * one-stripped image).\n\t */\n\tif (TIFFIsTiled(tif) || tf_numberstrips == 1)\n\t\tfprintf(fd, \"  /Height %lu\\n\", (unsigned long) tile_height);\n\telse\n\t\tfprintf(fd, \"  /Height im_h\\n\");\n\t\n\tif (planarconfiguration == PLANARCONFIG_SEPARATE && samplesperpixel > 1)\n\t\tfputs(\"  /MultipleDataSources true\\n\", fd);\n\tfprintf(fd, \"  /ImageMatrix [ %lu 0 0 %ld %s %s ]\\n\",\n\t    (unsigned long) w, - (long)h, im_x, im_y);\n\tfprintf(fd, \"  /BitsPerComponent %d\\n\", bitspersample);\n\tfprintf(fd, \"  /Interpolate %s\\n\", interpolate ? \"true\" : \"false\");\n\n\tswitch (samplesperpixel - extrasamples) {\n\tcase 1:\n\t\tswitch (photometric) {\n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\t\tfputs(\"  /Decode [0 1]\\n\", fd);\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\t\tswitch (compression) {\n\t\t\tcase COMPRESSION_CCITTRLE:\n\t\t\tcase COMPRESSION_CCITTRLEW:\n\t\t\tcase COMPRESSION_CCITTFAX3:\n\t\t\tcase COMPRESSION_CCITTFAX4:\n\t\t\t\t/*\n\t\t\t\t * Manage inverting with /Blackis1 flag\n\t\t\t\t * since there migth be uncompressed parts\n\t\t\t\t */\n\t\t\t\tfputs(\"  /Decode [0 1]\\n\", fd);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * ERROR...\n\t\t\t\t */\n\t\t\t\tfputs(\"  /Decode [1 0]\\n\", fd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_PALETTE:\n\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_MINSAMPLEVALUE,\n\t\t\t    &minsamplevalue);\n\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_MAXSAMPLEVALUE,\n\t\t\t    &maxsamplevalue);\n\t\t\tfprintf(fd, \"  /Decode [%u %u]\\n\",\n\t\t\t\t    minsamplevalue, maxsamplevalue);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * ERROR ?\n\t\t\t */\n\t\t\tfputs(\"  /Decode [0 1]\\n\", fd);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tswitch (photometric) {\n\t\tcase PHOTOMETRIC_RGB:\n\t\t\tfputs(\"  /Decode [0 1 0 1 0 1]\\n\", fd);\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\tdefault:\n\t\t\t/*\n\t\t\t * ERROR??\n\t\t\t */\n\t\t\tfputs(\"  /Decode [0 1 0 1 0 1]\\n\", fd);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\t/*\n\t\t * ERROR??\n\t\t */\n\t\tfputs(\"  /Decode [0 1 0 1 0 1 0 1]\\n\", fd);\n\t\tbreak;\n\t}\n\tfputs(\"  /DataSource\", fd);\n\tif (planarconfiguration == PLANARCONFIG_SEPARATE &&\n\t    samplesperpixel > 1)\n\t\tfputs(\" [\", fd);\n\tif (ascii85)\n\t\tfputs(\" im_stream\", fd);\n\telse\n\t\tfputs(\" currentfile /ASCIIHexDecode filter\", fd);\n\n\tuse_rawdata = TRUE;\n\tswitch (compression) {\n\tcase COMPRESSION_NONE:\t\t/* 1: uncompressed */\n\t\tbreak;\n\tcase COMPRESSION_CCITTRLE:\t/* 2: CCITT modified Huffman RLE */\n\tcase COMPRESSION_CCITTRLEW:\t/* 32771: #1 w/ word alignment */\n\tcase COMPRESSION_CCITTFAX3:\t/* 3: CCITT Group 3 fax encoding */\n\tcase COMPRESSION_CCITTFAX4:\t/* 4: CCITT Group 4 fax encoding */\n\t\tfputs(\"\\n\\t<<\\n\", fd);\n\t\tif (compression == COMPRESSION_CCITTFAX3) {\n\t\t\tuint32 g3_options;\n\n\t\t\tfputs(\"\\t /EndOfLine true\\n\", fd);\n\t\t\tfputs(\"\\t /EndOfBlock false\\n\", fd);\n\t\t\tif (!TIFFGetField(tif, TIFFTAG_GROUP3OPTIONS,\n\t\t\t\t\t    &g3_options))\n\t\t\t\tg3_options = 0;\n\t\t\tif (g3_options & GROUP3OPT_2DENCODING)\n\t\t\t\tfprintf(fd, \"\\t /K %s\\n\", im_h);\n\t\t\tif (g3_options & GROUP3OPT_UNCOMPRESSED)\n\t\t\t\tfputs(\"\\t /Uncompressed true\\n\", fd);\n\t\t\tif (g3_options & GROUP3OPT_FILLBITS)\n\t\t\t\tfputs(\"\\t /EncodedByteAlign true\\n\", fd);\n\t\t}\n\t\tif (compression == COMPRESSION_CCITTFAX4) {\n\t\t\tuint32 g4_options;\n\n\t\t\tfputs(\"\\t /K -1\\n\", fd);\n\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_GROUP4OPTIONS,\n\t\t\t\t\t       &g4_options);\n\t\t\tif (g4_options & GROUP4OPT_UNCOMPRESSED)\n\t\t\t\tfputs(\"\\t /Uncompressed true\\n\", fd);\n\t\t}\n\t\tif (!(tile_width == w && w == 1728U))\n\t\t\tfprintf(fd, \"\\t /Columns %lu\\n\",\n\t\t\t    (unsigned long) tile_width);\n\t\tfprintf(fd, \"\\t /Rows %s\\n\", im_h);\n\t\tif (compression == COMPRESSION_CCITTRLE ||\n\t\t    compression == COMPRESSION_CCITTRLEW) {\n\t\t\tfputs(\"\\t /EncodedByteAlign true\\n\", fd);\n\t\t\tfputs(\"\\t /EndOfBlock false\\n\", fd);\n\t\t}\n\t\tif (photometric == PHOTOMETRIC_MINISBLACK)\n\t\t\tfputs(\"\\t /BlackIs1 true\\n\", fd);\n\t\tfprintf(fd, \"\\t>> /CCITTFaxDecode filter\");\n\t\tbreak;\n\tcase COMPRESSION_LZW:\t/* 5: Lempel-Ziv & Welch */\n\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_PREDICTOR, &predictor);\n\t\tif (predictor == 2) {\n\t\t\tfputs(\"\\n\\t<<\\n\", fd);\n\t\t\tfprintf(fd, \"\\t /Predictor %u\\n\", predictor);\n\t\t\tfprintf(fd, \"\\t /Columns %lu\\n\",\n\t\t\t    (unsigned long) tile_width);\n\t\t\tfprintf(fd, \"\\t /Colors %u\\n\", samplesperpixel);\n\t\t\tfprintf(fd, \"\\t /BitsPerComponent %u\\n\",\n\t\t\t    bitspersample);\n\t\t\tfputs(\"\\t>>\", fd);\n\t\t}\n\t\tfputs(\" /LZWDecode filter\", fd);\n\t\tbreak;\n\tcase COMPRESSION_DEFLATE:\t/* 5: ZIP */\n\tcase COMPRESSION_ADOBE_DEFLATE:\n\t\tif ( level3 ) {\n\t\t\t TIFFGetFieldDefaulted(tif, TIFFTAG_PREDICTOR, &predictor);\n\t\t\t if (predictor > 1) {\n\t\t\t\tfprintf(fd, \"\\t %% PostScript Level 3 only.\");\n\t\t\t\tfputs(\"\\n\\t<<\\n\", fd);\n\t\t\t\tfprintf(fd, \"\\t /Predictor %u\\n\", predictor);\n\t\t\t\tfprintf(fd, \"\\t /Columns %lu\\n\",\n\t\t\t\t\t(unsigned long) tile_width);\n\t\t\t\tfprintf(fd, \"\\t /Colors %u\\n\", samplesperpixel);\n\t\t\t\t\tfprintf(fd, \"\\t /BitsPerComponent %u\\n\",\n\t\t\t\t\tbitspersample);\n\t\t\t\tfputs(\"\\t>>\", fd);\n\t\t\t }\n\t\t\t fputs(\" /FlateDecode filter\", fd);\n\t\t} else {\n\t\t\tuse_rawdata = FALSE ;\n\t\t}\n\t\tbreak;\n\tcase COMPRESSION_PACKBITS:\t/* 32773: Macintosh RLE */\n\t\tfputs(\" /RunLengthDecode filter\", fd);\n\t\tuse_rawdata = TRUE;\n\t    break;\n\tcase COMPRESSION_OJPEG:\t\t/* 6: !6.0 JPEG */\n\tcase COMPRESSION_JPEG:\t\t/* 7: %JPEG DCT compression */\n#ifdef notdef\n\t\t/*\n\t\t * Code not tested yet\n\t\t */\n\t\tfputs(\" /DCTDecode filter\", fd);\n\t\tuse_rawdata = TRUE;\n#else\n\t\tuse_rawdata = FALSE;\n#endif\n\t\tbreak;\n\tcase COMPRESSION_NEXT:\t\t/* 32766: NeXT 2-bit RLE */\n\tcase COMPRESSION_THUNDERSCAN:\t/* 32809: ThunderScan RLE */\n\tcase COMPRESSION_PIXARFILM:\t/* 32908: Pixar companded 10bit LZW */\n\tcase COMPRESSION_JBIG:\t\t/* 34661: ISO JBIG */\n\t\tuse_rawdata = FALSE;\n\t\tbreak;\n\tcase COMPRESSION_SGILOG:\t/* 34676: SGI LogL or LogLuv */\n\tcase COMPRESSION_SGILOG24:\t/* 34677: SGI 24-bit LogLuv */\n\t\tuse_rawdata = FALSE;\n\t\tbreak;\n\tdefault:\n\t\t/*\n\t\t * ERROR...\n\t\t */\n\t\tuse_rawdata = FALSE;\n\t\tbreak;\n\t}\n\tif (planarconfiguration == PLANARCONFIG_SEPARATE &&\n\t    samplesperpixel > 1) {\n\t\tuint16 i;\n\n\t\t/*\n\t\t * NOTE: This code does not work yet...\n\t\t */\n\t\tfor (i = 1; i < samplesperpixel; i++)\n\t\t\tfputs(\" dup\", fd);\n\t\tfputs(\" ]\", fd);\n\t}\n\n\tfprintf( fd, \"\\n >> %s\\n\", imageOp );\n\tif (ascii85)\n\t\tfputs(\" im_stream status { im_stream flushfile } if\\n\", fd);\n\tif (repeat_count > 1) {\n\t\tif (tile_width < w) {\n\t\t\tfprintf(fd, \" /im_x im_x %lu add def\\n\",\n\t\t\t    (unsigned long) tile_width);\n\t\t\tif (tile_height < h) {\n\t\t\t\tfprintf(fd, \" im_x %lu ge {\\n\",\n\t\t\t\t    (unsigned long) w);\n\t\t\t\tfputs(\"  /im_x 0 def\\n\", fd);\n\t\t\t\tfprintf(fd, \" /im_y im_y %lu add def\\n\",\n\t\t\t\t    (unsigned long) tile_height);\n\t\t\t\tfputs(\" } if\\n\", fd);\n\t\t\t}\n\t\t}\n\t\tif (tile_height < h) {\n\t\t\tif (tile_width >= w) {\n\t\t\t\tfprintf(fd, \" /im_y im_y %lu add def\\n\",\n\t\t\t\t    (unsigned long) tile_height);\n\t\t\t\tif (!TIFFIsTiled(tif)) {\n\t\t\t\t\tfprintf(fd, \" /im_h %lu im_y sub\",\n\t\t\t\t\t    (unsigned long) h);\n\t\t\t\t\tfprintf(fd, \" dup %lu gt { pop\",\n\t\t\t\t\t    (unsigned long) tile_height);\n\t\t\t\t\tfprintf(fd, \" %lu } if def\\n\",\n\t\t\t\t\t    (unsigned long) tile_height);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfputs(\"} repeat\\n\", fd);\n\t}\n\t/*\n\t * End of exec function\n\t */\n\tfputs(\"}\\n\", fd);\n\n\treturn(use_rawdata);\n}",
          "fn_code_pos": [
            [
              1794,
              0
            ],
            [
              2121,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PS_Lvl2ImageDict",
            "parameters": {
              "fd": "FILE",
              "tif": "TIFF",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nPS_FlipBytes(unsigned char* buf, tsize_t count)\n{\n\tint i;\n\tunsigned char temp;\n\n\tif (count <= 0 || bitspersample <= 8) {\n\t\treturn;\n\t}\n\n\tcount--;\n\n\tfor (i = 0; i < count; i += 2) {\n\t\ttemp = buf[i];\n\t\tbuf[i] = buf[i + 1];\n\t\tbuf[i + 1] = temp;\n\t}\n}",
          "fn_code_pos": [
            [
              2124,
              0
            ],
            [
              2141,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PS_FlipBytes",
            "parameters": {
              "buf": "unsigned char",
              "count": "tsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "int\nPS_Lvl2page(FILE* fd, TIFF* tif, uint32 w, uint32 h)\n{\n\tuint16 fillorder;\n\tint use_rawdata, tiled_image, breaklen = MAXLINE;\n\tuint32 chunk_no, num_chunks;\n        uint64 *bc;\n\tunsigned char *buf_data, *cp;\n\ttsize_t chunk_size, byte_count;\n\n#if defined( EXP_ASCII85ENCODER )\n\ttsize_t\t\t\tascii85_l;\t/* Length, in bytes, of ascii85_p[] data */\n\tuint8\t\t*\tascii85_p = 0;\t/* Holds ASCII85 encoded data */\n#endif\n\n\tPS_Lvl2colorspace(fd, tif);\n\tuse_rawdata = PS_Lvl2ImageDict(fd, tif, w, h);\n\n/* See http://bugzilla.remotesensing.org/show_bug.cgi?id=80 */\n#ifdef ENABLE_BROKEN_BEGINENDDATA\n\tfputs(\"%%BeginData:\\n\", fd);\n#endif\n\tfputs(\"exec\\n\", fd);\n\n\ttiled_image = TIFFIsTiled(tif);\n\tif (tiled_image) {\n\t\tnum_chunks = TIFFNumberOfTiles(tif);\n\t\tTIFFGetField(tif, TIFFTAG_TILEBYTECOUNTS, &bc);\n\t} else {\n\t\tnum_chunks = TIFFNumberOfStrips(tif);\n\t\tTIFFGetField(tif, TIFFTAG_STRIPBYTECOUNTS, &bc);\n\t}\n\n\tif (use_rawdata) {\n\t\tchunk_size = (tsize_t) bc[0];\n\t\tfor (chunk_no = 1; chunk_no < num_chunks; chunk_no++)\n\t\t\tif ((tsize_t) bc[chunk_no] > chunk_size)\n\t\t\t\tchunk_size = (tsize_t) bc[chunk_no];\n\t} else {\n\t\tif (tiled_image)\n\t\t\tchunk_size = TIFFTileSize(tif);\n\t\telse\n\t\t\tchunk_size = TIFFStripSize(tif);\n\t}\n\tbuf_data = (unsigned char *)_TIFFmalloc(chunk_size);\n\tif (!buf_data) {\n\t\tTIFFError(filename, \"Can't alloc %lu bytes for %s.\",\n\t\t\t(unsigned long) chunk_size, tiled_image ? \"tiles\" : \"strips\");\n\t\treturn(FALSE);\n\t}\n\n#if defined( EXP_ASCII85ENCODER )\n\tif ( ascii85 ) {\n\t    /*\n\t     * Allocate a buffer to hold the ASCII85 encoded data.  Note\n\t     * that it is allocated with sufficient room to hold the\n\t     * encoded data (5*chunk_size/4) plus the EOD marker (+8)\n\t     * and formatting line breaks.  The line breaks are more\n\t     * than taken care of by using 6*chunk_size/4 rather than\n\t     * 5*chunk_size/4.\n\t     */\n\n\t    ascii85_p = _TIFFmalloc( (chunk_size+(chunk_size/2)) + 8 );\n\n\t    if ( !ascii85_p ) {\n\t\t_TIFFfree( buf_data );\n\n\t\tTIFFError( filename, \"Cannot allocate ASCII85 encoding buffer.\" );\n\t\treturn ( FALSE );\n\t    }\n\t}\n#endif\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_FILLORDER, &fillorder);\n\tfor (chunk_no = 0; chunk_no < num_chunks; chunk_no++) {\n\t\tif (ascii85)\n\t\t\tAscii85Init();\n\t\telse\n\t\t\tbreaklen = MAXLINE;\n\t\tif (use_rawdata) {\n\t\t\tif (tiled_image)\n\t\t\t\tbyte_count = TIFFReadRawTile(tif, chunk_no,\n\t\t\t\t\t\t  buf_data, chunk_size);\n\t\t\telse\n\t\t\t\tbyte_count = TIFFReadRawStrip(tif, chunk_no,\n\t\t\t\t\t\t  buf_data, chunk_size);\n\t\t\tif (fillorder == FILLORDER_LSB2MSB)\n\t\t\t    TIFFReverseBits(buf_data, byte_count);\n\t\t} else {\n\t\t\tif (tiled_image)\n\t\t\t\tbyte_count = TIFFReadEncodedTile(tif,\n\t\t\t\t\t\tchunk_no, buf_data,\n\t\t\t\t\t\tchunk_size);\n\t\t\telse\n\t\t\t\tbyte_count = TIFFReadEncodedStrip(tif,\n\t\t\t\t\t\tchunk_no, buf_data,\n\t\t\t\t\t\tchunk_size);\n\t\t}\n\t\tif (byte_count < 0) {\n\t\t\tTIFFError(filename, \"Can't read %s %d.\",\n\t\t\t\ttiled_image ? \"tile\" : \"strip\", chunk_no);\n\t\t\tif (ascii85)\n\t\t\t\tAscii85Put('\\0', fd);\n\t\t}\n\t\t/*\n\t\t * for 16 bits, the two bytes must be most significant\n\t\t * byte first\n\t\t */\n\t\tif (bitspersample == 16 && !TIFFIsBigEndian(tif)) {\n\t\t\tPS_FlipBytes(buf_data, byte_count);\n\t\t}\n\t\t/*\n\t\t * For images with alpha, matte against a white background;\n\t\t * i.e. Cback * (1 - Aimage) where Cback = 1. We will fill the\n\t\t * lower part of the buffer with the modified values.\n\t\t *\n\t\t * XXX: needs better solution\n\t\t */\n\t\tif (alpha) {\n\t\t\tint adjust, i, j = 0;\n\t\t\tint ncomps = samplesperpixel - extrasamples;\n\t\t\tfor (i = 0; (i + ncomps) < byte_count; i+=samplesperpixel) {\n\t\t\t\tadjust = 255 - buf_data[i + ncomps];\n\t\t\t\tswitch (ncomps) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tbuf_data[j++] = buf_data[i] + adjust;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tbuf_data[j++] = buf_data[i] + adjust;\n\t\t\t\t\t\tbuf_data[j++] = buf_data[i+1] + adjust;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tbuf_data[j++] = buf_data[i] + adjust;\n\t\t\t\t\t\tbuf_data[j++] = buf_data[i+1] + adjust;\n\t\t\t\t\t\tbuf_data[j++] = buf_data[i+2] + adjust;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbyte_count -= j;\n\t\t}\n\n\t\tif (ascii85) {\n#if defined( EXP_ASCII85ENCODER )\n\t\t\tascii85_l = Ascii85EncodeBlock(ascii85_p, 1, buf_data, byte_count );\n\n\t\t\tif ( ascii85_l > 0 )\n\t\t\t\tfwrite( ascii85_p, ascii85_l, 1, fd );\n#else\n\t\t\tfor (cp = buf_data; byte_count > 0; byte_count--)\n\t\t\t\tAscii85Put(*cp++, fd);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (cp = buf_data; byte_count > 0; byte_count--) {\n\t\t\t\tputc(hex[((*cp)>>4)&0xf], fd);\n\t\t\t\tputc(hex[(*cp)&0xf], fd);\n\t\t\t\tcp++;\n\n\t\t\t\tif (--breaklen <= 0) {\n\t\t\t\t\tputc('\\n', fd);\n\t\t\t\t\tbreaklen = MAXLINE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( !ascii85 ) {\n\t\t\tif ( level2 || level3 )\n\t\t\t\tputc( '>', fd );\n\t\t\tputc('\\n', fd);\n\t\t}\n#if !defined( EXP_ASCII85ENCODER )\n\t\telse\n\t\t\tAscii85Flush(fd);\n#endif\n\t}\n\n#if defined( EXP_ASCII85ENCODER )\n\tif ( ascii85_p )\n\t    _TIFFfree( ascii85_p );\n#endif\n       \n\t_TIFFfree(buf_data);\n#ifdef ENABLE_BROKEN_BEGINENDDATA\n\tfputs(\"%%EndData\\n\", fd);\n#endif\n\treturn(TRUE);\n}",
          "fn_code_pos": [
            [
              2145,
              0
            ],
            [
              2332,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PS_Lvl2page",
            "parameters": {
              "fd": "FILE",
              "tif": "TIFF",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "void\nPSpage(FILE* fd, TIFF* tif, uint32 w, uint32 h)\n{\n\tchar\t*\timageOp = \"image\";\n\n\tif ( useImagemask && (bitspersample == 1) )\n\t\timageOp = \"imagemask\";\n\n\tif ((level2 || level3) && PS_Lvl2page(fd, tif, w, h))\n\t\treturn;\n\tps_bytesperrow = tf_bytesperrow - (extrasamples * bitspersample / 8)*w;\n\tswitch (photometric) {\n\tcase PHOTOMETRIC_RGB:\n\t\tif (planarconfiguration == PLANARCONFIG_CONTIG) {\n\t\t\tfprintf(fd, \"%s\", RGBcolorimage);\n\t\t\tPSColorContigPreamble(fd, w, h, 3);\n\t\t\tPSDataColorContig(fd, tif, w, h, 3);\n\t\t} else {\n\t\t\tPSColorSeparatePreamble(fd, w, h, 3);\n\t\t\tPSDataColorSeparate(fd, tif, w, h, 3);\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_SEPARATED:\n\t\t/* XXX should emit CMYKcolorimage */\n\t\tif (planarconfiguration == PLANARCONFIG_CONTIG) {\n\t\t\tPSColorContigPreamble(fd, w, h, 4);\n\t\t\tPSDataColorContig(fd, tif, w, h, 4);\n\t\t} else {\n\t\t\tPSColorSeparatePreamble(fd, w, h, 4);\n\t\t\tPSDataColorSeparate(fd, tif, w, h, 4);\n\t\t}\n\t\tbreak;\n\tcase PHOTOMETRIC_PALETTE:\n\t\tfprintf(fd, \"%s\", RGBcolorimage);\n\t\tPhotoshopBanner(fd, w, h, 1, 3, \"false 3 colorimage\");\n\t\tfprintf(fd, \"/scanLine %ld string def\\n\",\n\t\t    (long) ps_bytesperrow * 3L);\n\t\tfprintf(fd, \"%lu %lu 8\\n\",\n\t\t    (unsigned long) w, (unsigned long) h);\n\t\tfprintf(fd, \"[%lu 0 0 -%lu 0 %lu]\\n\",\n\t\t    (unsigned long) w, (unsigned long) h, (unsigned long) h);\n\t\tfprintf(fd, \"{currentfile scanLine readhexstring pop} bind\\n\");\n\t\tfprintf(fd, \"false 3 colorimage\\n\");\n\t\tPSDataPalette(fd, tif, w, h);\n\t\tbreak;\n\tcase PHOTOMETRIC_MINISBLACK:\n\tcase PHOTOMETRIC_MINISWHITE:\n\t\tPhotoshopBanner(fd, w, h, 1, 1, imageOp);\n\t\tfprintf(fd, \"/scanLine %ld string def\\n\",\n\t\t    (long) ps_bytesperrow);\n\t\tfprintf(fd, \"%lu %lu %d\\n\",\n\t\t    (unsigned long) w, (unsigned long) h, bitspersample);\n\t\tfprintf(fd, \"[%lu 0 0 -%lu 0 %lu]\\n\",\n\t\t    (unsigned long) w, (unsigned long) h, (unsigned long) h);\n\t\tfprintf(fd,\n\t\t    \"{currentfile scanLine readhexstring pop} bind\\n\");\n\t\tfprintf(fd, \"%s\\n\", imageOp);\n\t\tPSDataBW(fd, tif, w, h);\n\t\tbreak;\n\t}\n\tputc('\\n', fd);\n}",
          "fn_code_pos": [
            [
              2334,
              0
            ],
            [
              2395,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSpage",
            "parameters": {
              "fd": "FILE",
              "tif": "TIFF",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nPSColorContigPreamble(FILE* fd, uint32 w, uint32 h, int nc)\n{\n\tps_bytesperrow = nc * (tf_bytesperrow / samplesperpixel);\n\tPhotoshopBanner(fd, w, h, 1, nc, \"false %d colorimage\");\n\tfprintf(fd, \"/line %ld string def\\n\", (long) ps_bytesperrow);\n\tfprintf(fd, \"%lu %lu %d\\n\",\n\t    (unsigned long) w, (unsigned long) h, bitspersample);\n\tfprintf(fd, \"[%lu 0 0 -%lu 0 %lu]\\n\",\n\t    (unsigned long) w, (unsigned long) h, (unsigned long) h);\n\tfprintf(fd, \"{currentfile line readhexstring pop} bind\\n\");\n\tfprintf(fd, \"false %d colorimage\\n\", nc);\n}",
          "fn_code_pos": [
            [
              2397,
              0
            ],
            [
              2409,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSColorContigPreamble",
            "parameters": {
              "fd": "FILE",
              "w": "uint32",
              "h": "uint32",
              "nc": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nPSColorSeparatePreamble(FILE* fd, uint32 w, uint32 h, int nc)\n{\n\tint i;\n\n\tPhotoshopBanner(fd, w, h, ps_bytesperrow, nc, \"true %d colorimage\");\n\tfor (i = 0; i < nc; i++)\n\t\tfprintf(fd, \"/line%d %ld string def\\n\",\n\t\t    i, (long) ps_bytesperrow);\n\tfprintf(fd, \"%lu %lu %d\\n\",\n\t    (unsigned long) w, (unsigned long) h, bitspersample);\n\tfprintf(fd, \"[%lu 0 0 -%lu 0 %lu] \\n\",\n\t    (unsigned long) w, (unsigned long) h, (unsigned long) h);\n\tfor (i = 0; i < nc; i++)\n\t\tfprintf(fd, \"{currentfile line%d readhexstring pop}bind\\n\", i);\n\tfprintf(fd, \"true %d colorimage\\n\", nc);\n}",
          "fn_code_pos": [
            [
              2411,
              0
            ],
            [
              2427,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSColorSeparatePreamble",
            "parameters": {
              "fd": "FILE",
              "w": "uint32",
              "h": "uint32",
              "nc": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nPSDataColorContig(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc)\n{\n\tuint32 row;\n\tint breaklen = MAXLINE, es = samplesperpixel - nc;\n\ttsize_t cc;\n\tunsigned char *tf_buf;\n\tunsigned char *cp, c;\n\n\t(void) w;\n        if( es < 0 )\n        {\n            TIFFError(filename, \"Inconsistent value of es: %d (samplesperpixel=%u, nc=%d)\", es, samplesperpixel, nc);\n            return;\n        }\n\ttf_buf = (unsigned char *) _TIFFmalloc(tf_bytesperrow);\n\tif (tf_buf == NULL) {\n\t\tTIFFError(filename, \"No space for scanline buffer\");\n\t\treturn;\n\t}\n\tfor (row = 0; row < h; row++) {\n\t\tif (TIFFReadScanline(tif, tf_buf, row, 0) < 0)\n\t\t\tbreak;\n\t\tcp = tf_buf;\n\t\t/*\n\t\t * for 16 bits, the two bytes must be most significant\n\t\t * byte first\n\t\t */\n\t\tif (bitspersample == 16 && !HOST_BIGENDIAN) {\n\t\t\tPS_FlipBytes(cp, tf_bytesperrow);\n\t\t}\n\t\tif (alpha) {\n\t\t\tint adjust;\n\t\t\tcc = 0;\n\t\t\tfor (; cc < tf_bytesperrow; cc += samplesperpixel) {\n\t\t\t\tDOBREAK(breaklen, nc, fd);\n\t\t\t\t/*\n\t\t\t\t * For images with alpha, matte against\n\t\t\t\t * a white background; i.e.\n\t\t\t\t *    Cback * (1 - Aimage)\n\t\t\t\t * where Cback = 1.\n\t\t\t\t */\n\t\t\t\tadjust = 255 - cp[nc];\n\t\t\t\tswitch (nc) {\n\t\t\t\tcase 4: c = *cp++ + adjust; PUTHEX(c,fd);\n\t\t\t\tcase 3: c = *cp++ + adjust; PUTHEX(c,fd);\n\t\t\t\tcase 2: c = *cp++ + adjust; PUTHEX(c,fd);\n\t\t\t\tcase 1: c = *cp++ + adjust; PUTHEX(c,fd);\n\t\t\t\t}\n\t\t\t\tcp += es;\n\t\t\t}\n\t\t} else {\n\t\t\tcc = 0;\n\t\t\tfor (; cc < tf_bytesperrow; cc += samplesperpixel) {\n\t\t\t\tDOBREAK(breaklen, nc, fd);\n\t\t\t\tswitch (nc) {\n\t\t\t\tcase 4: c = *cp++; PUTHEX(c,fd);\n\t\t\t\tcase 3: c = *cp++; PUTHEX(c,fd);\n\t\t\t\tcase 2: c = *cp++; PUTHEX(c,fd);\n\t\t\t\tcase 1: c = *cp++; PUTHEX(c,fd);\n\t\t\t\t}\n\t\t\t\tcp += es;\n\t\t\t}\n\t\t}\n\t}\n\t_TIFFfree((char *) tf_buf);\n}",
          "fn_code_pos": [
            [
              2436,
              0
            ],
            [
              2502,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSDataColorContig",
            "parameters": {
              "fd": "FILE",
              "tif": "TIFF",
              "w": "uint32",
              "h": "uint32",
              "nc": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nPSDataColorSeparate(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc)\n{\n\tuint32 row;\n\tint breaklen = MAXLINE;\n\ttsize_t cc;\n\ttsample_t s, maxs;\n\tunsigned char *tf_buf;\n\tunsigned char *cp, c;\n\n\t(void) w;\n\ttf_buf = (unsigned char *) _TIFFmalloc(tf_bytesperrow);\n\tif (tf_buf == NULL) {\n\t\tTIFFError(filename, \"No space for scanline buffer\");\n\t\treturn;\n\t}\n\tmaxs = (samplesperpixel > nc ? nc : samplesperpixel);\n\tfor (row = 0; row < h; row++) {\n\t\tfor (s = 0; s < maxs; s++) {\n\t\t\tif (TIFFReadScanline(tif, tf_buf, row, s) < 0)\n\t\t\t\tbreak;\n\t\t\tfor (cp = tf_buf, cc = 0; cc < tf_bytesperrow; cc++) {\n\t\t\t\tDOBREAK(breaklen, 1, fd);\n\t\t\t\tc = *cp++;\n\t\t\t\tPUTHEX(c,fd);\n\t\t\t}\n\t\t}\n\t}\n\t_TIFFfree((char *) tf_buf);\n}",
          "fn_code_pos": [
            [
              2504,
              0
            ],
            [
              2533,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSDataColorSeparate",
            "parameters": {
              "fd": "FILE",
              "tif": "TIFF",
              "w": "uint32",
              "h": "uint32",
              "nc": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nPSDataPalette(FILE* fd, TIFF* tif, uint32 w, uint32 h)\n{\n\tuint16 *rmap, *gmap, *bmap;\n\tuint32 row;\n\tint breaklen = MAXLINE, nc;\n\ttsize_t cc;\n\tunsigned char *tf_buf;\n\tunsigned char *cp, c;\n\n\t(void) w;\n\tif (!TIFFGetField(tif, TIFFTAG_COLORMAP, &rmap, &gmap, &bmap)) {\n\t\tTIFFError(filename, \"Palette image w/o \\\"Colormap\\\" tag\");\n\t\treturn;\n\t}\n\tswitch (bitspersample) {\n\tcase 8:\tcase 4: case 2: case 1:\n\t\tbreak;\n\tdefault:\n\t\tTIFFError(filename, \"Depth %d not supported\", bitspersample);\n\t\treturn;\n\t}\n\tnc = 3 * (8 / bitspersample);\n\ttf_buf = (unsigned char *) _TIFFmalloc(tf_bytesperrow);\n\tif (tf_buf == NULL) {\n\t\tTIFFError(filename, \"No space for scanline buffer\");\n\t\treturn;\n\t}\n\tif (checkcmap(tif, 1<<bitspersample, rmap, gmap, bmap) == 16) {\n\t\tint i;\n#define\tCVT(x)\t\t((unsigned short) (((x) * 255) / ((1U<<16)-1)))\n\t\tfor (i = (1<<bitspersample)-1; i >= 0; i--) {\n\t\t\trmap[i] = CVT(rmap[i]);\n\t\t\tgmap[i] = CVT(gmap[i]);\n\t\t\tbmap[i] = CVT(bmap[i]);\n\t\t}\n#undef CVT\n\t}\n\tfor (row = 0; row < h; row++) {\n\t\tif (TIFFReadScanline(tif, tf_buf, row, 0) < 0)\n\t\t\tbreak;\n\t\tfor (cp = tf_buf, cc = 0; cc < tf_bytesperrow; cc++) {\n\t\t\tDOBREAK(breaklen, nc, fd);\n\t\t\tswitch (bitspersample) {\n\t\t\tcase 8:\n\t\t\t\tc = *cp++; PUTRGBHEX(c, fd);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tc = *cp++; PUTRGBHEX(c&0xf, fd);\n\t\t\t\tc >>= 4;   PUTRGBHEX(c, fd);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tc = *cp++; PUTRGBHEX(c&0x3, fd);\n\t\t\t\tc >>= 2;   PUTRGBHEX(c&0x3, fd);\n\t\t\t\tc >>= 2;   PUTRGBHEX(c&0x3, fd);\n\t\t\t\tc >>= 2;   PUTRGBHEX(c, fd);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tc = *cp++; PUTRGBHEX(c&0x1, fd);\n\t\t\t\tc >>= 1;   PUTRGBHEX(c&0x1, fd);\n\t\t\t\tc >>= 1;   PUTRGBHEX(c&0x1, fd);\n\t\t\t\tc >>= 1;   PUTRGBHEX(c&0x1, fd);\n\t\t\t\tc >>= 1;   PUTRGBHEX(c&0x1, fd);\n\t\t\t\tc >>= 1;   PUTRGBHEX(c&0x1, fd);\n\t\t\t\tc >>= 1;   PUTRGBHEX(c&0x1, fd);\n\t\t\t\tc >>= 1;   PUTRGBHEX(c, fd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t_TIFFfree((char *) tf_buf);\n}",
          "fn_code_pos": [
            [
              2538,
              0
            ],
            [
              2609,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSDataPalette",
            "parameters": {
              "fd": "FILE",
              "tif": "TIFF",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nPSDataBW(FILE* fd, TIFF* tif, uint32 w, uint32 h)\n{\n\tint breaklen = MAXLINE;\n\tunsigned char* tf_buf;\n\tunsigned char* cp;\n\ttsize_t stripsize = TIFFStripSize(tif);\n\ttstrip_t s;\n\n#if defined( EXP_ASCII85ENCODER )\n\ttsize_t\tascii85_l;\t\t/* Length, in bytes, of ascii85_p[] data */\n\tuint8\t*ascii85_p = 0;\t\t/* Holds ASCII85 encoded data */\n#endif\n\n\t(void) w; (void) h;\n\ttf_buf = (unsigned char *) _TIFFmalloc(stripsize);\n\tif (tf_buf == NULL) {\n\t\tTIFFError(filename, \"No space for scanline buffer\");\n\t\treturn;\n\t}\n\n\t// FIXME\n\tmemset(tf_buf, 0, stripsize);\n\n#if defined( EXP_ASCII85ENCODER )\n\tif ( ascii85 ) {\n\t    /*\n\t     * Allocate a buffer to hold the ASCII85 encoded data.  Note\n\t     * that it is allocated with sufficient room to hold the\n\t     * encoded data (5*stripsize/4) plus the EOD marker (+8)\n\t     * and formatting line breaks.  The line breaks are more\n\t     * than taken care of by using 6*stripsize/4 rather than\n\t     * 5*stripsize/4.\n\t     */\n\n\t    ascii85_p = _TIFFmalloc( (stripsize+(stripsize/2)) + 8 );\n\n\t    if ( !ascii85_p ) {\n\t\t_TIFFfree( tf_buf );\n\n\t\tTIFFError( filename, \"Cannot allocate ASCII85 encoding buffer.\" );\n\t\treturn;\n\t    }\n\t}\n#endif\n\n\tif (ascii85)\n\t\tAscii85Init();\n\n\tfor (s = 0; s < TIFFNumberOfStrips(tif); s++) {\n\t\ttmsize_t cc = TIFFReadEncodedStrip(tif, s, tf_buf, stripsize);\n\t\tif (cc < 0) {\n\t\t\tTIFFError(filename, \"Can't read strip\");\n\t\t\tbreak;\n\t\t}\n\t\tcp = tf_buf;\n\t\tif (photometric == PHOTOMETRIC_MINISWHITE) {\n\t\t\tfor (cp += cc; --cp >= tf_buf;)\n\t\t\t\t*cp = ~*cp;\n\t\t\tcp++;\n\t\t}\n\t\t/*\n\t\t * for 16 bits, the two bytes must be most significant\n\t\t * byte first\n\t\t */\n\t\tif (bitspersample == 16 && !HOST_BIGENDIAN) {\n\t\t\tPS_FlipBytes(cp, cc);\n\t\t}\n\t\tif (ascii85) {\n#if defined( EXP_ASCII85ENCODER )\n\t\t\tif (alpha) {\n\t\t\t\tint adjust, i;\n\t\t\t\tfor (i = 0; i < cc; i+=2) {\n\t\t\t\t\tadjust = 255 - cp[i + 1];\n\t\t\t\t    cp[i / 2] = cp[i] + adjust;\n\t\t\t\t}\n\t\t\t\tcc /= 2;\n\t\t\t}\n\n\t\t\tascii85_l = Ascii85EncodeBlock( ascii85_p, 1, cp, cc );\n\n\t\t\tif ( ascii85_l > 0 )\n\t\t\t    fwrite( ascii85_p, ascii85_l, 1, fd );\n#else\n\t\t\twhile (cc-- > 0)\n\t\t\t\tAscii85Put(*cp++, fd);\n#endif /* EXP_ASCII85_ENCODER */\n\t\t} else {\n\t\t\tunsigned char c;\n\n\t\t\tif (alpha) {\n\t\t\t\tint adjust;\n\t\t\t\twhile (cc-- > 1) {\n\t\t\t\t\tDOBREAK(breaklen, 1, fd);\n\t\t\t\t\t/*\n\t\t\t\t\t * For images with alpha, matte against\n\t\t\t\t\t * a white background; i.e.\n\t\t\t\t\t *    Cback * (1 - Aimage)\n\t\t\t\t\t * where Cback = 1.\n\t\t\t\t\t */\n\t\t\t\t\tadjust = 255 - cp[1];\n\t\t\t\t\tc = *cp++ + adjust; PUTHEX(c,fd);\n\t\t\t\t\tcp++, cc--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (cc-- > 0) {\n\t\t\t\t\tc = *cp++;\n\t\t\t\t\tDOBREAK(breaklen, 1, fd);\n\t\t\t\t\tPUTHEX(c, fd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( !ascii85 )\n\t{\n\t    if ( level2 || level3)\n\t\tfputs(\">\\n\", fd);\n\t}\n#if !defined( EXP_ASCII85ENCODER )\n\telse\n\t    Ascii85Flush(fd);\n#else\n\tif ( ascii85_p )\n\t    _TIFFfree( ascii85_p );\n#endif\n\n\t_TIFFfree(tf_buf);\n}",
          "fn_code_pos": [
            [
              2611,
              0
            ],
            [
              2739,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSDataBW",
            "parameters": {
              "fd": "FILE",
              "tif": "TIFF",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nPSRawDataBW(FILE* fd, TIFF* tif, uint32 w, uint32 h)\n{\n\tuint64 *bc;\n\tuint32 bufsize;\n\tint breaklen = MAXLINE;\n\ttmsize_t cc;\n\tuint16 fillorder;\n\tunsigned char *tf_buf;\n\tunsigned char *cp, c;\n\ttstrip_t s;\n\n#if defined( EXP_ASCII85ENCODER )\n\ttsize_t \t\tascii85_l;\t\t/* Length, in bytes, of ascii85_p[] data */\n\tuint8\t\t*\tascii85_p = 0;\t\t/* Holds ASCII85 encoded data */\n#endif\n\n\t(void) w; (void) h;\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_FILLORDER, &fillorder);\n\tTIFFGetField(tif, TIFFTAG_STRIPBYTECOUNTS, &bc);\n\n\t/*\n\t * Find largest strip:\n\t */\n\n\tbufsize = (uint32) bc[0];\n\n\tfor ( s = 0; ++s < (tstrip_t)tf_numberstrips; ) {\n\t\tif ( bc[s] > bufsize )\n\t\t\tbufsize = (uint32) bc[s];\n\t}\n\n\ttf_buf = (unsigned char*) _TIFFmalloc(bufsize);\n\tif (tf_buf == NULL) {\n\t\tTIFFError(filename, \"No space for strip buffer\");\n\t\treturn;\n\t}\n\n#if defined( EXP_ASCII85ENCODER )\n\tif ( ascii85 ) {\n\t    /*\n\t     * Allocate a buffer to hold the ASCII85 encoded data.  Note\n\t     * that it is allocated with sufficient room to hold the\n\t     * encoded data (5*bufsize/4) plus the EOD marker (+8)\n\t     * and formatting line breaks.  The line breaks are more\n\t     * than taken care of by using 6*bufsize/4 rather than\n\t     * 5*bufsize/4.\n\t     */\n\n\t    ascii85_p = _TIFFmalloc( (bufsize+(bufsize/2)) + 8 );\n\n\t    if ( !ascii85_p ) {\n\t\t_TIFFfree( tf_buf );\n\n\t\tTIFFError( filename, \"Cannot allocate ASCII85 encoding buffer.\" );\n\t\treturn;\n\t    }\n\t}\n#endif\n\n\tfor (s = 0; s < (tstrip_t) tf_numberstrips; s++) {\n\t\tcc = TIFFReadRawStrip(tif, s, tf_buf, (tmsize_t) bc[s]);\n\t\tif (cc < 0) {\n\t\t\tTIFFError(filename, \"Can't read strip\");\n\t\t\tbreak;\n\t\t}\n\t\tif (fillorder == FILLORDER_LSB2MSB)\n\t\t\tTIFFReverseBits(tf_buf, cc);\n\t\tif (!ascii85) {\n\t\t\tfor (cp = tf_buf; cc > 0; cc--) {\n\t\t\t\tDOBREAK(breaklen, 1, fd);\n\t\t\t\tc = *cp++;\n\t\t\t\tPUTHEX(c, fd);\n\t\t\t}\n\t\t\tfputs(\">\\n\", fd);\n\t\t\tbreaklen = MAXLINE;\n\t\t} else {\n\t\t\tAscii85Init();\n#if defined( EXP_ASCII85ENCODER )\n\t\t\tascii85_l = Ascii85EncodeBlock( ascii85_p, 1, tf_buf, cc );\n\n\t\t\tif ( ascii85_l > 0 )\n\t\t\t\tfwrite( ascii85_p, ascii85_l, 1, fd );\n#else\n\t\t\tfor (cp = tf_buf; cc > 0; cc--)\n\t\t\t\tAscii85Put(*cp++, fd);\n\t\t\tAscii85Flush(fd);\n#endif\t/* EXP_ASCII85ENCODER */\n\t\t}\n\t}\n\t_TIFFfree((char *) tf_buf);\n\n#if defined( EXP_ASCII85ENCODER )\n\tif ( ascii85_p )\n\t\t_TIFFfree( ascii85_p );\n#endif\n}",
          "fn_code_pos": [
            [
              2741,
              0
            ],
            [
              2837,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSRawDataBW",
            "parameters": {
              "fd": "FILE",
              "tif": "TIFF",
              "w": "uint32",
              "h": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nAscii85Init(void)\n{\n\tascii85breaklen = 2*MAXLINE;\n\tascii85count = 0;\n}",
          "fn_code_pos": [
            [
              2839,
              0
            ],
            [
              2844,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Ascii85Init",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static char*\nAscii85Encode(unsigned char* raw)\n{\n\tstatic char encoded[6];\n\tuint32 word;\n\n\tword = (((raw[0]<<8)+raw[1])<<16) + (raw[2]<<8) + raw[3];\n\tif (word != 0L) {\n\t\tuint32 q;\n\t\tuint16 w1;\n\n\t\tq = word / (85L*85*85*85);\t/* actually only a byte */\n\t\tencoded[0] = (char) (q + '!');\n\n\t\tword -= q * (85L*85*85*85); q = word / (85L*85*85);\n\t\tencoded[1] = (char) (q + '!');\n\n\t\tword -= q * (85L*85*85); q = word / (85*85);\n\t\tencoded[2] = (char) (q + '!');\n\n\t\tw1 = (uint16) (word - q*(85L*85));\n\t\tencoded[3] = (char) ((w1 / 85) + '!');\n\t\tencoded[4] = (char) ((w1 % 85) + '!');\n\t\tencoded[5] = '\\0';\n\t} else\n\t\tencoded[0] = 'z', encoded[1] = '\\0';\n\treturn (encoded);\n}",
          "fn_code_pos": [
            [
              2846,
              0
            ],
            [
              2873,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Ascii85Encode",
            "parameters": {
              "raw": "unsigned char"
            },
            "return_type": "char"
          }
        },
        {
          "fn_code": "void\nAscii85Put(unsigned char code, FILE* fd)\n{\n\tascii85buf[ascii85count++] = code;\n\tif (ascii85count >= 4) {\n\t\tunsigned char* p;\n\t\tint n;\n\n\t\tfor (n = ascii85count, p = ascii85buf; n >= 4; n -= 4, p += 4) {\n\t\t\tchar* cp;\n\t\t\tfor (cp = Ascii85Encode(p); *cp; cp++) {\n\t\t\t\tputc(*cp, fd);\n\t\t\t\tif (--ascii85breaklen == 0) {\n\t\t\t\t\tputc('\\n', fd);\n\t\t\t\t\tascii85breaklen = 2*MAXLINE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_TIFFmemcpy(ascii85buf, p, n);\n\t\tascii85count = n;\n\t}\n}",
          "fn_code_pos": [
            [
              2875,
              0
            ],
            [
              2896,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Ascii85Put",
            "parameters": {
              "code": "unsigned char",
              "fd": "FILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nAscii85Flush(FILE* fd)\n{\n\tif (ascii85count > 0) {\n\t\tchar* res;\n\t\t_TIFFmemset(&ascii85buf[ascii85count], 0, 3);\n\t\tres = Ascii85Encode(ascii85buf);\n\t\tfwrite(res[0] == 'z' ? \"!!!!\" : res, ascii85count + 1, 1, fd);\n\t}\n\tfputs(\"~>\\n\", fd);\n}",
          "fn_code_pos": [
            [
              2898,
              0
            ],
            [
              2908,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Ascii85Flush",
            "parameters": {
              "fd": "FILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "tsize_t Ascii85EncodeBlock( uint8 * ascii85_p, unsigned f_eod, const uint8 * raw_p, tsize_t raw_l )\n\n{\n    char                        ascii85[5];     /* Encoded 5 tuple */\n    tsize_t                     ascii85_l;      /* Number of bytes written to ascii85_p[] */\n    int                         rc;             /* Return code */\n    uint32                      val32;          /* Unencoded 4 tuple */\n\n    ascii85_l = 0;                              /* Nothing written yet */\n\n    if ( raw_p )\n    {\n        --raw_p;                                /* Prepare for pre-increment fetches */\n\n        for ( ; raw_l > 3; raw_l -= 4 )\n        {\n            val32  = (uint32)*(++raw_p) << 24;\n            val32 += (uint32)*(++raw_p) << 16;\n            val32 += (uint32)*(++raw_p) <<  8;\n            val32 += (uint32)*(++raw_p);\n    \n            if ( val32 == 0 )                   /* Special case */\n            {\n                ascii85_p[ascii85_l] = 'z';\n                rc = 1;\n            }\n    \n            else\n            {\n                ascii85[4] = (char) ((val32 % 85) + 33);\n                val32 /= 85;\n    \n                ascii85[3] = (char) ((val32 % 85) + 33);\n                val32 /= 85;\n    \n                ascii85[2] = (char) ((val32 % 85) + 33);\n                val32 /= 85;\n    \n                ascii85[1] = (char) ((val32 % 85) + 33);\n                ascii85[0] = (char) ((val32 / 85) + 33);\n\n                _TIFFmemcpy( &ascii85_p[ascii85_l], ascii85, sizeof(ascii85) );\n                rc = sizeof(ascii85);\n            }\n    \n            ascii85_l += rc;\n    \n            if ( (A85BREAKCNTR -= rc) <= 0 )\n            {\n                ascii85_p[ascii85_l] = '\\n';\n                ++ascii85_l;\n                A85BREAKCNTR = A85BREAKLEN;\n            }\n        }\n    \n        /*\n         * Output any straggler bytes:\n         */\n    \n        if ( raw_l > 0 )\n        {\n            tsize_t         len;                /* Output this many bytes */\n    \n            len = raw_l + 1;\n            val32 = *++raw_p << 24;             /* Prime the pump */\n    \n            if ( --raw_l > 0 )  val32 += *(++raw_p) << 16;\n            if ( --raw_l > 0 )  val32 += *(++raw_p) <<  8;\n    \n            val32 /= 85;\n    \n            ascii85[3] = (char) ((val32 % 85) + 33);\n            val32 /= 85;\n    \n            ascii85[2] = (char) ((val32 % 85) + 33);\n            val32 /= 85;\n    \n            ascii85[1] = (char) ((val32 % 85) + 33);\n            ascii85[0] = (char) ((val32 / 85) + 33);\n    \n            _TIFFmemcpy( &ascii85_p[ascii85_l], ascii85, len );\n            ascii85_l += len;\n        }\n    }\n\n    /*\n     * If requested add an ASCII85 End Of Data marker:\n     */\n\n    if ( f_eod )\n    {\n        ascii85_p[ascii85_l++] = '~';\n        ascii85_p[ascii85_l++] = '>';\n        ascii85_p[ascii85_l++] = '\\n';\n    }\n\n    return ( ascii85_l );\n\n}",
          "fn_code_pos": [
            [
              2952,
              0
            ],
            [
              3050,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Ascii85EncodeBlock",
            "parameters": {
              "ascii85_p": "uint8",
              "f_eod": "unsigned",
              "raw_p": "uint8",
              "raw_l": "tsize_t"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "static void\nusage(int code)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(code);\n}",
          "fn_code_pos": [
            [
              3091,
              0
            ],
            [
              3102,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {
              "code": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TIFF2PS(FILE*, TIFF*, double, double, double, double, int)",
          "fn_dec_pos": [
            [
              204,
              4
            ],
            [
              204,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFF2PS",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "PSpage(FILE*, TIFF*, uint32, uint32)",
          "fn_dec_pos": [
            [
              205,
              5
            ],
            [
              205,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSpage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PSColorContigPreamble(FILE*, uint32, uint32, int)",
          "fn_dec_pos": [
            [
              206,
              5
            ],
            [
              206,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSColorContigPreamble",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PSColorSeparatePreamble(FILE*, uint32, uint32, int)",
          "fn_dec_pos": [
            [
              207,
              5
            ],
            [
              207,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSColorSeparatePreamble",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PSDataColorContig(FILE*, TIFF*, uint32, uint32, int)",
          "fn_dec_pos": [
            [
              208,
              5
            ],
            [
              208,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSDataColorContig",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PSDataColorSeparate(FILE*, TIFF*, uint32, uint32, int)",
          "fn_dec_pos": [
            [
              209,
              5
            ],
            [
              209,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSDataColorSeparate",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PSDataPalette(FILE*, TIFF*, uint32, uint32)",
          "fn_dec_pos": [
            [
              210,
              5
            ],
            [
              210,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSDataPalette",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PSDataBW(FILE*, TIFF*, uint32, uint32)",
          "fn_dec_pos": [
            [
              211,
              5
            ],
            [
              211,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSDataBW",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PSRawDataBW(FILE*, TIFF*, uint32, uint32)",
          "fn_dec_pos": [
            [
              212,
              5
            ],
            [
              212,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSRawDataBW",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "Ascii85Init(void)",
          "fn_dec_pos": [
            [
              213,
              5
            ],
            [
              213,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Ascii85Init",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "Ascii85Put(unsigned char code, FILE* fd)",
          "fn_dec_pos": [
            [
              214,
              5
            ],
            [
              214,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Ascii85Put",
            "parameters": {
              "code": "unsigned char",
              "fd": "FILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "Ascii85Flush(FILE* fd)",
          "fn_dec_pos": [
            [
              215,
              5
            ],
            [
              215,
              27
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Ascii85Flush",
            "parameters": {
              "fd": "FILE"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "PSHead(FILE*, double, double, double, double)",
          "fn_dec_pos": [
            [
              216,
              8
            ],
            [
              216,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSHead",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PSTail(FILE*, int)",
          "fn_dec_pos": [
            [
              217,
              5
            ],
            [
              217,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PSTail",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "psStart(FILE *, int, int, int *, double *, double, double, double,\n                double, double, double, double, double, double, double)",
          "fn_dec_pos": [
            [
              218,
              8
            ],
            [
              219,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "psStart",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "psPageSize(FILE *, int, double, double, double, double, double, double)",
          "fn_dec_pos": [
            [
              220,
              8
            ],
            [
              220,
              79
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "psPageSize",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "psRotateImage(FILE *, int, double, double, double, double)",
          "fn_dec_pos": [
            [
              221,
              8
            ],
            [
              221,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "psRotateImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "psMaskImage(FILE *, TIFF *, int, int, int *, double, double,\n\t\t    double, double, double, double, double, double, double)",
          "fn_dec_pos": [
            [
              222,
              8
            ],
            [
              223,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "psMaskImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "psScaleImage(FILE *, double, int, int, double, double, double, double,\n                     double, double)",
          "fn_dec_pos": [
            [
              224,
              8
            ],
            [
              225,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "psScaleImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "get_viewport (double, double, double, double, double *, double *, int)",
          "fn_dec_pos": [
            [
              226,
              8
            ],
            [
              226,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "get_viewport",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "exportMaskedImage(FILE *, double, double, double, double, int, int,\n\t\t\t  double, double, double, int, int)",
          "fn_dec_pos": [
            [
              227,
              8
            ],
            [
              228,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "exportMaskedImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "Ascii85EncodeBlock( uint8 * ascii85_p, unsigned f_eod, const uint8 * raw_p, tsize_t raw_l )",
          "fn_dec_pos": [
            [
              231,
              8
            ],
            [
              231,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Ascii85EncodeBlock",
            "parameters": {
              "ascii85_p": "uint8",
              "f_eod": "unsigned",
              "raw_p": "uint8",
              "raw_l": "tsize_t"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "usage(int)",
          "fn_dec_pos": [
            [
              234,
              12
            ],
            [
              234,
              22
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "Ascii85Flush(fd)",
          "fn_dec_pos": [
            [
              2318,
              3
            ],
            [
              2318,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Ascii85Flush",
            "parameters": {},
            "return_type": "else"
          }
        },
        {
          "fn_code": "Ascii85Flush(fd)",
          "fn_dec_pos": [
            [
              2732,
              5
            ],
            [
              2732,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Ascii85Flush",
            "parameters": {},
            "return_type": "else"
          }
        },
        {
          "fn_code": "Ascii85Encode(unsigned char* raw)",
          "fn_dec_pos": [
            [
              2847,
              0
            ],
            [
              2847,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "Ascii85Encode",
            "parameters": {
              "raw": "unsigned char"
            },
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdlib.h>\t\t\t/* for atof */\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <time.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/ppm2tiff.c": {
      "fn_def_list": [
        {
          "fn_code": "static void\nBadPPM(char* file)\n{\n\tfprintf(stderr, \"%s: Not a PPM file.\\n\", file);\n\texit(-2);\n}",
          "fn_code_pos": [
            [
              65,
              0
            ],
            [
              70,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "BadPPM",
            "parameters": {
              "file": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static tmsize_t\nmultiply_ms(tmsize_t m1, tmsize_t m2)\n{\n        if( m1 == 0 || m2 > TIFF_TMSIZE_T_MAX / m1 )\n            return 0;\n        return m1 * m2;\n}",
          "fn_code_pos": [
            [
              76,
              0
            ],
            [
              82,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "multiply_ms",
            "parameters": {
              "m1": "tmsize_t",
              "m2": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tuint16 photometric = 0;\n\tuint32 rowsperstrip = (uint32) -1;\n\tdouble resolution = -1;\n\tunsigned char *buf = NULL;\n\ttmsize_t linebytes = 0;\n\tuint16 spp = 1;\n\tuint16 bpp = 8;\n\tTIFF *out;\n\tFILE *in;\n\tunsigned int w, h, prec, row;\n\tchar *infile;\n\tint c;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\ttmsize_t scanline_size;\n\n\tif (argc < 2) {\n\t    fprintf(stderr, \"%s: Too few arguments\\n\", argv[0]);\n\t    usage();\n\t}\n\twhile ((c = getopt(argc, argv, \"c:r:R:\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'c':\t\t/* compression scheme */\n\t\t\tif (!processCompressOptions(optarg))\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'r':\t\t/* rows/strip */\n\t\t\trowsperstrip = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'R':\t\t/* resolution */\n\t\t\tresolution = atof(optarg);\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\n\tif (optind + 2 < argc) {\n\t    fprintf(stderr, \"%s: Too many arguments\\n\", argv[0]);\n\t    usage();\n\t}\n\n\t/*\n\t * If only one file is specified, read input from\n\t * stdin; otherwise usage is: ppm2tiff input output.\n\t */\n\tif (argc - optind > 1) {\n\t\tinfile = argv[optind++];\n\t\tin = fopen(infile, \"rb\");\n\t\tif (in == NULL) {\n\t\t\tfprintf(stderr, \"%s: Can not open.\\n\", infile);\n\t\t\treturn (-1);\n\t\t}\n\t} else {\n\t\tinfile = \"<stdin>\";\n\t\tin = stdin;\n#if defined(HAVE_SETMODE) && defined(O_BINARY)\n\t\tsetmode(fileno(stdin), O_BINARY);\n#endif\n\t}\n\n\tif (fgetc(in) != 'P')\n\t\tBadPPM(infile);\n\tswitch (fgetc(in)) {\n\t\tcase '4':\t\t\t/* it's a PBM file */\n\t\t\tbpp = 1;\n\t\t\tspp = 1;\n\t\t\tphotometric = PHOTOMETRIC_MINISWHITE;\n\t\t\tbreak;\n\t\tcase '5':\t\t\t/* it's a PGM file */\n\t\t\tbpp = 8;\n\t\t\tspp = 1;\n\t\t\tphotometric = PHOTOMETRIC_MINISBLACK;\n\t\t\tbreak;\n\t\tcase '6':\t\t\t/* it's a PPM file */\n\t\t\tbpp = 8;\n\t\t\tspp = 3;\n\t\t\tphotometric = PHOTOMETRIC_RGB;\n\t\t\tif (compression == COMPRESSION_JPEG &&\n\t\t\t    jpegcolormode == JPEGCOLORMODE_RGB)\n\t\t\t\tphotometric = PHOTOMETRIC_YCBCR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBadPPM(infile);\n\t}\n\n\t/* Parse header */\n\twhile(1) {\n\t\tif (feof(in))\n\t\t\tBadPPM(infile);\n\t\tc = fgetc(in);\n\t\t/* Skip whitespaces (blanks, TABs, CRs, LFs) */\n\t\tif (strchr(\" \\t\\r\\n\", c))\n\t\t\tcontinue;\n\n\t\t/* Check for comment line */\n\t\tif (c == '#') {\n\t\t\tdo {\n\t\t\t    c = fgetc(in);\n\t\t\t} while(!(strchr(\"\\r\\n\", c) || feof(in)));\n\t\t\tcontinue;\n\t\t}\n\n\t\tungetc(c, in);\n\t\tbreak;\n\t}\n\tswitch (bpp) {\n\tcase 1:\n\t\tif (fscanf(in, \" %u %u\", &w, &h) != 2)\n\t\t\tBadPPM(infile);\n\t\tif (fgetc(in) != '\\n')\n\t\t\tBadPPM(infile);\n\t\tbreak;\n\tcase 8:\n\t\tif (fscanf(in, \" %u %u %u\", &w, &h, &prec) != 3)\n\t\t\tBadPPM(infile);\n\t\tif (fgetc(in) != '\\n' || prec != 255)\n\t\t\tBadPPM(infile);\n\t\tbreak;\n\t}\n\tout = TIFFOpen(argv[optind], \"w\");\n\tif (out == NULL)\n\t\treturn (-4);\n\tTIFFSetField(out, TIFFTAG_IMAGEWIDTH, (uint32) w);\n\tTIFFSetField(out, TIFFTAG_IMAGELENGTH, (uint32) h);\n\tTIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n\tTIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, spp);\n\tTIFFSetField(out, TIFFTAG_BITSPERSAMPLE, bpp);\n\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\n\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n\tswitch (compression) {\n\tcase COMPRESSION_JPEG:\n\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n\t\tbreak;\n\tcase COMPRESSION_LZW:\n\tcase COMPRESSION_DEFLATE:\n\t\tif (predictor != 0)\n\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n\t\tbreak;\n        case COMPRESSION_CCITTFAX3:\n\t\tTIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);\n\t\tbreak;\n\t}\n\tswitch (bpp) {\n\t\tcase 1:\n\t\t\t/* if round-up overflows, result will be zero, OK */\n\t\t\tlinebytes = (multiply_ms(spp, w) + (8 - 1)) / 8;\n\t\t\tif (rowsperstrip == (uint32) -1) {\n\t\t\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, h);\n\t\t\t} else {\n\t\t\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\n\t\t\t\t    TIFFDefaultStripSize(out, rowsperstrip));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tlinebytes = multiply_ms(spp, w);\n\t\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP,\n\t\t\t    TIFFDefaultStripSize(out, rowsperstrip));\n\t\t\tbreak;\n\t}\n\tif (linebytes == 0) {\n\t\tfprintf(stderr, \"%s: scanline size overflow\\n\", infile);\n\t\t(void) TIFFClose(out);\n\t\texit(-2);\t\t\t\t\t\n\t}\n\tscanline_size = TIFFScanlineSize(out);\n\tif (scanline_size == 0) {\n\t\t/* overflow - TIFFScanlineSize already printed a message */\n\t\t(void) TIFFClose(out);\n\t\texit(-2);\t\t\t\t\t\n\t}\n\tif (scanline_size < linebytes)\n\t\tbuf = (unsigned char *)_TIFFmalloc(linebytes);\n\telse\n\t\tbuf = (unsigned char *)_TIFFmalloc(scanline_size);\n\tif (buf == NULL) {\n\t\tfprintf(stderr, \"%s: Not enough memory\\n\", infile);\n\t\t(void) TIFFClose(out);\n\t\texit(-2);\n\t}\n\tif (resolution > 0) {\n\t\tTIFFSetField(out, TIFFTAG_XRESOLUTION, resolution);\n\t\tTIFFSetField(out, TIFFTAG_YRESOLUTION, resolution);\n\t\tTIFFSetField(out, TIFFTAG_RESOLUTIONUNIT, RESUNIT_INCH);\n\t}\n\tfor (row = 0; row < h; row++) {\n\t\tif (fread(buf, linebytes, 1, in) != 1) {\n\t\t\tfprintf(stderr, \"%s: scanline %lu: Read error.\\n\",\n\t\t\t    infile, (unsigned long) row);\n\t\t\tbreak;\n\t\t}\n\t\tif (TIFFWriteScanline(out, buf, row, 0) < 0)\n\t\t\tbreak;\n\t}\n\tif (in != stdin)\n\t\tfclose(in);\n\t(void) TIFFClose(out);\n\tif (buf)\n\t\t_TIFFfree(buf);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              84,
              0
            ],
            [
              291,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nprocessG3Options(char* cp)\n{\n\tg3opts = 0;\n        if( (cp = strchr(cp, ':')) ) {\n                do {\n                        cp++;\n                        if (strneq(cp, \"1d\", 2))\n                                g3opts &= ~GROUP3OPT_2DENCODING;\n                        else if (strneq(cp, \"2d\", 2))\n                                g3opts |= GROUP3OPT_2DENCODING;\n                        else if (strneq(cp, \"fill\", 4))\n                                g3opts |= GROUP3OPT_FILLBITS;\n                        else\n                                usage();\n                } while( (cp = strchr(cp, ':')) );\n        }\n}",
          "fn_code_pos": [
            [
              293,
              0
            ],
            [
              310,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processG3Options",
            "parameters": {
              "cp": "char"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nprocessCompressOptions(char* opt)\n{\n\tif (streq(opt, \"none\"))\n\t\tcompression = COMPRESSION_NONE;\n\telse if (streq(opt, \"packbits\"))\n\t\tcompression = COMPRESSION_PACKBITS;\n\telse if (strneq(opt, \"jpeg\", 4)) {\n\t\tchar* cp = strchr(opt, ':');\n\n                compression = COMPRESSION_JPEG;\n                while (cp)\n                {\n                    if (isdigit((int)cp[1]))\n\t\t\tquality = atoi(cp+1);\n                    else if (cp[1] == 'r' )\n\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;\n                    else\n                        usage();\n\n                    cp = strchr(cp+1,':');\n                }\n\t} else if (strneq(opt, \"g3\", 2)) {\n\t\tprocessG3Options(opt);\n\t\tcompression = COMPRESSION_CCITTFAX3;\n\t} else if (streq(opt, \"g4\")) {\n\t\tcompression = COMPRESSION_CCITTFAX4;\n\t} else if (strneq(opt, \"lzw\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_LZW;\n\t} else if (strneq(opt, \"zip\", 3)) {\n\t\tchar* cp = strchr(opt, ':');\n\t\tif (cp)\n\t\t\tpredictor = atoi(cp+1);\n\t\tcompression = COMPRESSION_DEFLATE;\n\t} else\n\t\treturn (0);\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              312,
              0
            ],
            [
              352,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {
              "opt": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              377,
              0
            ],
            [
              388,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "getopt(int, char**, char*)",
          "fn_dec_pos": [
            [
              50,
              11
            ],
            [
              50,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              62,
              12
            ],
            [
              62,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "processCompressOptions(char*)",
          "fn_dec_pos": [
            [
              63,
              11
            ],
            [
              63,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "processCompressOptions",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "# include <fcntl.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "# include <io.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            47,
            0
          ],
          [
            48,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/tiffinfoce.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tint dirnum = -1, multiplefiles, c;\n\tuint16 order = 0;\n\tTIFF* tif;\n\textern int optind;\n\textern char* optarg;\n\tlong flags = 0;\n\tuint32 diroff = 0;\n\tint chopstrips = 0;\t\t/* disable strip chopping */\n\n\twhile ((c = getopt(argc, argv, \"f:o:cdDSjilmrsvwz0123456789\")) != -1)\n\t\tswitch (c) {\n\t\tcase '0': case '1': case '2': case '3':\n\t\tcase '4': case '5': case '6': case '7':\n\t\tcase '8': case '9':\n\t\t\tdirnum = atoi(&argv[optind-1][1]);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tshowdata++;\n\t\t\t/* fall through... */\n\t\tcase 'D':\n\t\t\treaddata++;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tflags |= TIFFPRINT_COLORMAP | TIFFPRINT_CURVES;\n\t\t\tbreak;\n\t\tcase 'f':\t\t/* fill order */\n\t\t\tif (streq(optarg, \"lsb2msb\"))\n\t\t\t\torder = FILLORDER_LSB2MSB;\n\t\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t\t\torder = FILLORDER_MSB2LSB;\n\t\t\telse\n\t\t\t\tusage();\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tstoponerr = 0;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tdiroff = strtoul(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tflags |= TIFFPRINT_JPEGQTABLES |\n\t\t\t\t TIFFPRINT_JPEGACTABLES |\n\t\t\t\t TIFFPRINT_JPEGDCTABLES;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trawdata = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tflags |= TIFFPRINT_STRIPS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tshowwords = 1;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tchopstrips = 1;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (optind >= argc)\n    {\n\t\tusage();\n    }\n\n\tmultiplefiles = (argc - optind > 1);\n\tfor (; optind < argc; optind++)\n    {\n\t\tif (multiplefiles)\n        {\n\t\t\tprintf(\"%s:\\n\", argv[optind]);\n        }\n\n\t\ttif = TIFFOpen(argv[optind], chopstrips ? \"rC\" : \"rc\");\n\t\tif (tif != NULL)\n        {\n\t\t\tif (dirnum != -1)\n            {\n\t\t\t\tif (TIFFSetDirectory(tif, (tdir_t) dirnum))\n\t\t\t\t\ttiffinfo(tif, order, flags);\n\t\t\t} else if (diroff != 0) {\n\t\t\t\tif (TIFFSetSubDirectory(tif, diroff))\n\t\t\t\t\ttiffinfo(tif, order, flags);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\ttoff_t offset;\n\n\t\t\t\t\ttiffinfo(tif, order, flags);\n\t\t\t\t\tif (TIFFGetField(tif, TIFFTAG_EXIFIFD,\n\t\t\t\t\t\t\t &offset)) {\n\t\t\t\t\t\tif (TIFFReadEXIFDirectory(tif, offset))\n\t\t\t\t\t\t\ttiffinfo(tif, order, flags);\n\t\t\t\t\t}\n\t\t\t\t} while (TIFFReadDirectory(tif));\n\t\t\t}\n\t\t\tTIFFClose(tif);\n\t\t}\n\t}\n\n    printf(\"\\n<press any key to exit>\\n\");\n    getc(stdin);\n\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              54,
              0
            ],
            [
              160,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\t/* char buf[BUFSIZ];*/\n\tint i;\n\n\t/* setbuf(stderr, buf); */\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              181,
              0
            ],
            [
              192,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nShowStrip(tstrip_t strip, unsigned char* pp, uint32 nrow, tsize_t scanline)\n{\n\tregister tsize_t cc;\n\n\tprintf(\"Strip %lu:\\n\", (unsigned long) strip);\n\twhile (nrow-- > 0) {\n\t\tfor (cc = 0; cc < scanline; cc++) {\n\t\t\tprintf(\" %02x\", *pp++);\n\t\t\tif (((cc+1) % 24) == 0)\n\t\t\t\tputchar('\\n');\n\t\t}\n\t\tputchar('\\n');\n\t}\n}",
          "fn_code_pos": [
            [
              194,
              0
            ],
            [
              208,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ShowStrip",
            "parameters": {
              "strip": "tstrip_t",
              "pp": "unsigned char",
              "nrow": "uint32",
              "scanline": "tsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFReadContigStripData(TIFF* tif)\n{\n\tunsigned char *buf;\n\ttsize_t scanline = TIFFScanlineSize(tif);\n\n\tbuf = (unsigned char *)_TIFFmalloc(TIFFStripSize(tif));\n\tif (buf) {\n\t\tuint32 row, h;\n\t\tuint32 rowsperstrip = (uint32)-1;\n\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\t\tfor (row = 0; row < h; row += rowsperstrip) {\n\t\t\tuint32 nrow = (row+rowsperstrip > h ?\n\t\t\t    h-row : rowsperstrip);\n\t\t\ttstrip_t strip = TIFFComputeStrip(tif, row, 0);\n\t\t\tif (TIFFReadEncodedStrip(tif, strip, buf, nrow*scanline) < 0) {\n\t\t\t\tif (stoponerr)\n\t\t\t\t\tbreak;\n\t\t\t} else if (showdata)\n\t\t\t\tShowStrip(strip, buf, nrow, scanline);\n\t\t}\n\t\t_TIFFfree(buf);\n\t}\n}",
          "fn_code_pos": [
            [
              210,
              0
            ],
            [
              235,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadContigStripData",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFReadSeparateStripData(TIFF* tif)\n{\n\tunsigned char *buf;\n\ttsize_t scanline = TIFFScanlineSize(tif);\n\n\tbuf = (unsigned char *)_TIFFmalloc(TIFFStripSize(tif));\n\tif (buf) {\n\t\tuint32 row, h;\n\t\tuint32 rowsperstrip = (uint32)-1;\n\t\ttsample_t s, samplesperpixel;\n\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\tTIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\t\tfor (row = 0; row < h; row += rowsperstrip) {\n\t\t\tfor (s = 0; s < samplesperpixel; s++) {\n\t\t\t\tuint32 nrow = (row+rowsperstrip > h ?\n\t\t\t\t    h-row : rowsperstrip);\n\t\t\t\ttstrip_t strip = TIFFComputeStrip(tif, row, s);\n\t\t\t\tif (TIFFReadEncodedStrip(tif, strip, buf, nrow*scanline) < 0) {\n\t\t\t\t\tif (stoponerr)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else if (showdata)\n\t\t\t\t\tShowStrip(strip, buf, nrow, scanline);\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(buf);\n\t}\n}",
          "fn_code_pos": [
            [
              237,
              0
            ],
            [
              266,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadSeparateStripData",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nShowTile(uint32 row, uint32 col, tsample_t sample,\n    unsigned char* pp, uint32 nrow, uint32 rowsize)\n{\n\tuint32 cc;\n\n\tprintf(\"Tile (%lu,%lu\", (unsigned long) row, (unsigned long) col);\n\tif (sample != (tsample_t) -1)\n\t\tprintf(\",%u\", sample);\n\tprintf(\"):\\n\");\n\twhile (nrow-- > 0) {\n\t\tfor (cc = 0; cc < rowsize; cc++) {\n\t\t\tprintf(\" %02x\", *pp++);\n\t\t\tif (((cc+1) % 24) == 0)\n\t\t\t\tputchar('\\n');\n\t\t}\n\t\tputchar('\\n');\n\t}\n}",
          "fn_code_pos": [
            [
              268,
              0
            ],
            [
              286,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ShowTile",
            "parameters": {
              "row": "uint32",
              "col": "uint32",
              "sample": "tsample_t",
              "pp": "unsigned char",
              "nrow": "uint32",
              "rowsize": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFReadContigTileData(TIFF* tif)\n{\n\tunsigned char *buf;\n        tmsize_t rowsize = TIFFTileRowSize(tif);\n        tmsize_t tilesize = TIFFTileSize(tif);\n\n        buf = (unsigned char *)_TIFFmalloc(tilesize);\n\tif (buf) {\n\t\tuint32 tw=0, th=0, w=0, h=0;\n\t\tuint32 row, col;\n\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n                if( rowsize == 0 || th > tilesize / rowsize )\n                {\n                        fprintf(stderr, \"Cannot display data: th * rowsize > tilesize\\n\");\n                        _TIFFfree(buf);\n                        return;\n                }\n\t\tfor (row = 0; row < h; row += th) {\n\t\t\tfor (col = 0; col < w; col += tw) {\n\t\t\t\tif (TIFFReadTile(tif, buf, col, row, 0, 0) < 0) {\n\t\t\t\t\tif (stoponerr)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else if (showdata)\n\t\t\t\t\tShowTile(row, col, (tsample_t) -1, buf, th, rowsize);\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(buf);\n\t}\n}",
          "fn_code_pos": [
            [
              288,
              0
            ],
            [
              321,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadContigTileData",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFReadSeparateTileData(TIFF* tif)\n{\n\tunsigned char *buf;\n\ttmsize_t rowsize = TIFFTileRowSize(tif);\n\ttmsize_t tilesize = TIFFTileSize(tif);\n\n\tbuf = (unsigned char *)_TIFFmalloc(tilesize);\n\tif (buf) {\n\t\tuint32 tw=0, th=0, w=0, h=0;\n\t\tuint32 row, col;\n\t\ttsample_t s, samplesperpixel;\n\n\t\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);\n\t\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);\n\t\tTIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw);\n\t\tTIFFGetField(tif, TIFFTAG_TILELENGTH, &th);\n\t\tTIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\t\tif( rowsize == 0 || th > tilesize / rowsize )\n\t\t{\n\t\t\tfprintf(stderr, \"Cannot display data: th * rowsize > tilesize\\n\");\n\t\t\t_TIFFfree(buf);\n\t\t\treturn;\n\t\t}\n\t\tfor (row = 0; row < h; row += th) {\n\t\t\tfor (col = 0; col < w; col += tw) {\n\t\t\t\tfor (s = 0; s < samplesperpixel; s++) {\n\t\t\t\t\tif (TIFFReadTile(tif, buf, col, row, 0, s) < 0) {\n\t\t\t\t\t\tif (stoponerr)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (showdata)\n\t\t\t\t\t\tShowTile(row, col, s, buf, th, rowsize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_TIFFfree(buf);\n\t}\n}",
          "fn_code_pos": [
            [
              323,
              0
            ],
            [
              360,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadSeparateTileData",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFReadData(TIFF* tif)\n{\n\tuint16 config;\n\n\tTIFFGetField(tif, TIFFTAG_PLANARCONFIG, &config);\n\tif (TIFFIsTiled(tif)) {\n\t\tif (config == PLANARCONFIG_CONTIG)\n\t\t\tTIFFReadContigTileData(tif);\n\t\telse\n\t\t\tTIFFReadSeparateTileData(tif);\n\t} else {\n\t\tif (config == PLANARCONFIG_CONTIG)\n\t\t\tTIFFReadContigStripData(tif);\n\t\telse\n\t\t\tTIFFReadSeparateStripData(tif);\n\t}\n}",
          "fn_code_pos": [
            [
              362,
              0
            ],
            [
              379,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadData",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nShowRawBytes(unsigned char* pp, uint32 n)\n{\n\tuint32 i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\" %02x\", *pp++);\n\t\tif (((i+1) % 24) == 0)\n\t\t\tprintf(\"\\n \");\n\t}\n\tputchar('\\n');\n}",
          "fn_code_pos": [
            [
              381,
              0
            ],
            [
              392,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ShowRawBytes",
            "parameters": {
              "pp": "unsigned char",
              "n": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nShowRawWords(uint16* pp, uint32 n)\n{\n\tuint32 i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\" %04x\", *pp++);\n\t\tif (((i+1) % 15) == 0)\n\t\t\tprintf(\"\\n \");\n\t}\n\tputchar('\\n');\n}",
          "fn_code_pos": [
            [
              394,
              0
            ],
            [
              405,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ShowRawWords",
            "parameters": {
              "pp": "uint16",
              "n": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "void\nTIFFReadRawData(TIFF* tif, int bitrev)\n{\n\ttstrip_t nstrips = TIFFNumberOfStrips(tif);\n\tconst char* what = TIFFIsTiled(tif) ? \"Tile\" : \"Strip\";\n\tuint64* stripbc;\n\n\tTIFFGetField(tif, TIFFTAG_STRIPBYTECOUNTS, &stripbc);\n\tif (nstrips > 0) {\n\t\tuint32 bufsize = stripbc[0];\n\t\ttdata_t buf = _TIFFmalloc(bufsize);\n\t\ttstrip_t s;\n\n\t\tfor (s = 0; s < nstrips; s++) {\n\t\t\tif (stripbc[s] > bufsize) {\n\t\t\t\tbuf = _TIFFrealloc(buf, stripbc[s]);\n\t\t\t\tbufsize = stripbc[s];\n\t\t\t}\n\t\t\tif (buf == NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t   \"Cannot allocate buffer to read strip %lu\\n\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (TIFFReadRawStrip(tif, s, buf, stripbc[s]) < 0) {\n\t\t\t\tfprintf(stderr, \"Error reading strip %lu\\n\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tif (stoponerr)\n\t\t\t\t\tbreak;\n\t\t\t} else if (showdata) {\n\t\t\t\tif (bitrev) {\n\t\t\t\t\tTIFFReverseBits(buf, stripbc[s]);\n\t\t\t\t\tprintf(\"%s %lu: (bit reversed)\\n \",\n\t\t\t\t\t    what, (unsigned long) s);\n\t\t\t\t} else\n\t\t\t\t\tprintf(\"%s %lu:\\n \", what,\n\t\t\t\t\t    (unsigned long) s);\n\t\t\t\tif (showwords)\n\t\t\t\t\tShowRawWords((uint16*) buf, stripbc[s]>>1);\n\t\t\t\telse\n\t\t\t\t\tShowRawBytes((unsigned char*) buf, stripbc[s]);\n\t\t\t}\n\t\t}\n\t\tif (buf != NULL)\n\t\t\t_TIFFfree(buf);\n\t}\n}",
          "fn_code_pos": [
            [
              407,
              0
            ],
            [
              453,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRawData",
            "parameters": {
              "tif": "TIFF",
              "bitrev": "int"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\ntiffinfo(TIFF* tif, uint16 order, long flags)\n{\n\tTIFFPrintDirectory(tif, stdout, flags);\n\tif (!readdata)\n\t\treturn;\n\tif (rawdata) {\n\t\tif (order) {\n\t\t\tuint16 o;\n\t\t\tTIFFGetFieldDefaulted(tif,\n\t\t\t    TIFFTAG_FILLORDER, &o);\n\t\t\tTIFFReadRawData(tif, o != order);\n\t\t} else\n\t\t\tTIFFReadRawData(tif, 0);\n\t} else {\n\t\tif (order)\n\t\t\tTIFFSetField(tif, TIFFTAG_FILLORDER, order);\n\t\tTIFFReadData(tif);\n\t}\n}",
          "fn_code_pos": [
            [
              455,
              0
            ],
            [
              474,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiffinfo",
            "parameters": {
              "tif": "TIFF",
              "order": "uint16",
              "flags": "long"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "getopt(int argc, char * const argv[], const char *optstring)",
          "fn_dec_pos": [
            [
              43,
              4
            ],
            [
              43,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {
              "argc": "int",
              "argv": "char",
              "optstring": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              51,
              12
            ],
            [
              51,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "tiffinfo(TIFF*, uint16, long)",
          "fn_dec_pos": [
            [
              52,
              12
            ],
            [
              52,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiffinfo",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <wce_stdio.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <wce_stat.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/tools/tiffcmp.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char* argv[])\n{\n\tTIFF *tif1, *tif2;\n\tint c, dirnum;\n#if !HAVE_DECL_OPTARG\n\textern int optind;\n\textern char* optarg;\n#endif\n\n\twhile ((c = getopt(argc, argv, \"ltz:\")) != -1)\n\t\tswitch (c) {\n\t\tcase 'l':\n\t\t\tstopondiff = 0;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tstopondiff = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tstoponfirsttag = 0;\n\t\t\tbreak;\n\t\tcase '?':\n\t\t\tusage();\n\t\t\t/*NOTREACHED*/\n\t\t}\n\tif (argc - optind < 2)\n\t\tusage();\n\ttif1 = TIFFOpen(argv[optind], \"r\");\n\tif (tif1 == NULL)\n\t\treturn (-1);\n\ttif2 = TIFFOpen(argv[optind+1], \"r\");\n\tif (tif2 == NULL)\n\t\treturn (-2);\n\tdirnum = 0;\n\twhile (tiffcmp(tif1, tif2)) {\n\t\tif (!TIFFReadDirectory(tif1)) {\n\t\t\tif (!TIFFReadDirectory(tif2))\n\t\t\t\tbreak;\n\t\t\tprintf(\"No more directories for %s\\n\",\n\t\t\t    TIFFFileName(tif1));\n\t\t\treturn (1);\n\t\t} else if (!TIFFReadDirectory(tif2)) {\n\t\t\tprintf(\"No more directories for %s\\n\",\n\t\t\t    TIFFFileName(tif2));\n\t\t\treturn (1);\n\t\t}\n\t\tprintf(\"Directory %d:\\n\", ++dirnum);\n\t}\n\n\tTIFFClose(tif1);\n\tTIFFClose(tif2);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              63,
              0
            ],
            [
              115,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nusage(void)\n{\n\tchar buf[BUFSIZ];\n\tint i;\n\n\tsetbuf(stderr, buf);\n        fprintf(stderr, \"%s\\n\\n\", TIFFGetVersion());\n\tfor (i = 0; stuff[i] != NULL; i++)\n\t\tfprintf(stderr, \"%s\\n\", stuff[i]);\n\texit(-1);\n}",
          "fn_code_pos": [
            [
              126,
              0
            ],
            [
              137,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\ntiffcmp(TIFF* tif1, TIFF* tif2)\n{\n\tuint16 config1, config2;\n\ttsize_t size1;\n\tuint32 row;\n\ttsample_t s;\n\tunsigned char *buf1, *buf2;\n\n\tif (!CheckShortTag(tif1, tif2, TIFFTAG_BITSPERSAMPLE, \"BitsPerSample\"))\n\t\treturn (0);\n\tif (!CheckShortTag(tif1, tif2, TIFFTAG_SAMPLESPERPIXEL, \"SamplesPerPixel\"))\n\t\treturn (0);\n\tif (!CheckLongTag(tif1, tif2, TIFFTAG_IMAGEWIDTH, \"ImageWidth\"))\n\t\treturn (0);\n\tif (!cmptags(tif1, tif2))\n\t\treturn (1);\n\t(void) TIFFGetField(tif1, TIFFTAG_BITSPERSAMPLE, &bitspersample);\n\t(void) TIFFGetField(tif1, TIFFTAG_SAMPLESPERPIXEL, &samplesperpixel);\n\t(void) TIFFGetField(tif1, TIFFTAG_SAMPLEFORMAT, &sampleformat);\n\t(void) TIFFGetField(tif1, TIFFTAG_IMAGEWIDTH, &imagewidth);\n\t(void) TIFFGetField(tif1, TIFFTAG_IMAGELENGTH, &imagelength);\n\t(void) TIFFGetField(tif1, TIFFTAG_PLANARCONFIG, &config1);\n\t(void) TIFFGetField(tif2, TIFFTAG_PLANARCONFIG, &config2);\n\tbuf1 = (unsigned char *)_TIFFmalloc(size1 = TIFFScanlineSize(tif1));\n\tbuf2 = (unsigned char *)_TIFFmalloc(TIFFScanlineSize(tif2));\n\tif (buf1 == NULL || buf2 == NULL) {\n\t\tfprintf(stderr, \"No space for scanline buffers\\n\");\n\t\texit(-1);\n\t}\n\tif (config1 != config2 && bitspersample != 8 && samplesperpixel > 1) {\n\t\tfprintf(stderr,\n\"Can't handle different planar configuration w/ different bits/sample\\n\");\n\t\tgoto bad;\n\t}\n#define\tpack(a,b)\t((a)<<8)|(b)\n\tswitch (pack(config1, config2)) {\n\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_CONTIG):\n\t\tfor (row = 0; row < imagelength; row++) {\n\t\t\tif (TIFFReadScanline(tif2, buf2, row, 0) < 0)\n\t\t\t\tcheckEOF(tif2, row, -1)\n\t\t\tfor (s = 0; s < samplesperpixel; s++) {\n\t\t\t\tif (TIFFReadScanline(tif1, buf1, row, s) < 0)\n\t\t\t\t\tcheckEOF(tif1, row, s)\n\t\t\t\tif (SeparateCompare(1, s, row, buf2, buf1) < 0)\n\t\t\t\t\tgoto bad1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_SEPARATE):\n\t\tfor (row = 0; row < imagelength; row++) {\n\t\t\tif (TIFFReadScanline(tif1, buf1, row, 0) < 0)\n\t\t\t\tcheckEOF(tif1, row, -1)\n\t\t\tfor (s = 0; s < samplesperpixel; s++) {\n\t\t\t\tif (TIFFReadScanline(tif2, buf2, row, s) < 0)\n\t\t\t\t\tcheckEOF(tif2, row, s)\n\t\t\t\tif (SeparateCompare(0, s, row, buf1, buf2) < 0)\n\t\t\t\t\tgoto bad1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase pack(PLANARCONFIG_SEPARATE, PLANARCONFIG_SEPARATE):\n\t\tfor (s = 0; s < samplesperpixel; s++)\n\t\t\tfor (row = 0; row < imagelength; row++) {\n\t\t\t\tif (TIFFReadScanline(tif1, buf1, row, s) < 0)\n\t\t\t\t\tcheckEOF(tif1, row, s)\n\t\t\t\tif (TIFFReadScanline(tif2, buf2, row, s) < 0)\n\t\t\t\t\tcheckEOF(tif2, row, s)\n\t\t\t\tif (ContigCompare(s, row, buf1, buf2, size1) < 0)\n\t\t\t\t\tgoto bad1;\n\t\t\t}\n\t\tbreak;\n\tcase pack(PLANARCONFIG_CONTIG, PLANARCONFIG_CONTIG):\n\t\tfor (row = 0; row < imagelength; row++) {\n\t\t\tif (TIFFReadScanline(tif1, buf1, row, 0) < 0)\n\t\t\t\tcheckEOF(tif1, row, -1)\n\t\t\tif (TIFFReadScanline(tif2, buf2, row, 0) < 0)\n\t\t\t\tcheckEOF(tif2, row, -1)\n\t\t\tif (ContigCompare(-1, row, buf1, buf2, size1) < 0)\n\t\t\t\tgoto bad1;\n\t\t}\n\t\tbreak;\n\t}\n\tif (buf1) _TIFFfree(buf1);\n\tif (buf2) _TIFFfree(buf2);\n\treturn (1);\nbad:\n\tif (stopondiff)\n\t\texit(1);\nbad1:\n\tif (buf1) _TIFFfree(buf1);\n\tif (buf2) _TIFFfree(buf2);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              151,
              0
            ],
            [
              244,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiffcmp",
            "parameters": {
              "tif1": "TIFF",
              "tif2": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncmptags(TIFF* tif1, TIFF* tif2)\n{\n\tuint16 compression1, compression2;\n\tCmpLongField(TIFFTAG_SUBFILETYPE,\t\"SubFileType\");\n\tCmpLongField(TIFFTAG_IMAGEWIDTH,\t\"ImageWidth\");\n\tCmpLongField(TIFFTAG_IMAGELENGTH,\t\"ImageLength\");\n\tCmpShortField(TIFFTAG_BITSPERSAMPLE,\t\"BitsPerSample\");\n\tCmpShortField(TIFFTAG_COMPRESSION,\t\"Compression\");\n\tCmpShortField(TIFFTAG_PREDICTOR,\t\"Predictor\");\n\tCmpShortField(TIFFTAG_PHOTOMETRIC,\t\"PhotometricInterpretation\");\n\tCmpShortField(TIFFTAG_THRESHHOLDING,\t\"Thresholding\");\n\tCmpShortField(TIFFTAG_FILLORDER,\t\"FillOrder\");\n\tCmpShortField(TIFFTAG_ORIENTATION,\t\"Orientation\");\n\tCmpShortField(TIFFTAG_SAMPLESPERPIXEL,\t\"SamplesPerPixel\");\n\tCmpShortField(TIFFTAG_MINSAMPLEVALUE,\t\"MinSampleValue\");\n\tCmpShortField(TIFFTAG_MAXSAMPLEVALUE,\t\"MaxSampleValue\");\n\tCmpShortField(TIFFTAG_SAMPLEFORMAT,\t\"SampleFormat\");\n\tCmpFloatField(TIFFTAG_XRESOLUTION,\t\"XResolution\");\n\tCmpFloatField(TIFFTAG_YRESOLUTION,\t\"YResolution\");\n\tif( TIFFGetField(tif1, TIFFTAG_COMPRESSION, &compression1) &&\n\t\tcompression1 == COMPRESSION_CCITTFAX3 &&\n\t\tTIFFGetField(tif2, TIFFTAG_COMPRESSION, &compression2) &&\n\t\tcompression2 == COMPRESSION_CCITTFAX3 )\n\t{\n\t\tCmpLongField(TIFFTAG_GROUP3OPTIONS,\t\"Group3Options\");\n\t}\n\tif( TIFFGetField(tif1, TIFFTAG_COMPRESSION, &compression1) &&\n\t\tcompression1 == COMPRESSION_CCITTFAX4 &&\n\t\tTIFFGetField(tif2, TIFFTAG_COMPRESSION, &compression2) &&\n\t\tcompression2 == COMPRESSION_CCITTFAX4 )\n\t{\n\t\tCmpLongField(TIFFTAG_GROUP4OPTIONS,\t\"Group4Options\");\n\t}\n\tCmpShortField(TIFFTAG_RESOLUTIONUNIT,\t\"ResolutionUnit\");\n\tCmpShortField(TIFFTAG_PLANARCONFIG,\t\"PlanarConfiguration\");\n\tCmpLongField(TIFFTAG_ROWSPERSTRIP,\t\"RowsPerStrip\");\n\tCmpFloatField(TIFFTAG_XPOSITION,\t\"XPosition\");\n\tCmpFloatField(TIFFTAG_YPOSITION,\t\"YPosition\");\n\tCmpShortField(TIFFTAG_GRAYRESPONSEUNIT, \"GrayResponseUnit\");\n\tCmpShortField(TIFFTAG_COLORRESPONSEUNIT, \"ColorResponseUnit\");\n#ifdef notdef\n\t{ uint16 *graycurve;\n\t  CmpField(TIFFTAG_GRAYRESPONSECURVE, graycurve);\n\t}\n\t{ uint16 *red, *green, *blue;\n\t  CmpField3(TIFFTAG_COLORRESPONSECURVE, red, green, blue);\n\t}\n\t{ uint16 *red, *green, *blue;\n\t  CmpField3(TIFFTAG_COLORMAP, red, green, blue);\n\t}\n#endif\n\tCmpShortField2(TIFFTAG_PAGENUMBER,\t\"PageNumber\");\n\tCmpStringField(TIFFTAG_ARTIST,\t\t\"Artist\");\n\tCmpStringField(TIFFTAG_IMAGEDESCRIPTION,\"ImageDescription\");\n\tCmpStringField(TIFFTAG_MAKE,\t\t\"Make\");\n\tCmpStringField(TIFFTAG_MODEL,\t\t\"Model\");\n\tCmpStringField(TIFFTAG_SOFTWARE,\t\"Software\");\n\tCmpStringField(TIFFTAG_DATETIME,\t\"DateTime\");\n\tCmpStringField(TIFFTAG_HOSTCOMPUTER,\t\"HostComputer\");\n\tCmpStringField(TIFFTAG_PAGENAME,\t\"PageName\");\n\tCmpStringField(TIFFTAG_DOCUMENTNAME,\t\"DocumentName\");\n\tCmpShortField(TIFFTAG_MATTEING,\t\t\"Matteing\");\n\tCmpShortArrayField(TIFFTAG_EXTRASAMPLES,\"ExtraSamples\");\n\treturn (1);\n}",
          "fn_code_pos": [
            [
              259,
              0
            ],
            [
              324,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmptags",
            "parameters": {
              "tif1": "TIFF",
              "tif2": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nContigCompare(int sample, uint32 row,\n\t      unsigned char* p1, unsigned char* p2, tsize_t size)\n{\n    uint32 pix;\n    int ppb = 8 / bitspersample;\n    int\t samples_to_test;\n\n    if (memcmp(p1, p2, size) == 0)\n        return 0;\n\n    samples_to_test = (sample == -1) ? samplesperpixel : 1;\n\n    switch (bitspersample) {\n      case 1: case 2: case 4: case 8: \n      {\n          unsigned char *pix1 = p1, *pix2 = p2;\n\n          for (pix = 0; pix < imagewidth; pix += ppb) {\n              int\t\ts;\n\n              for(s = 0; s < samples_to_test; s++) {\n                  if (*pix1 != *pix2) {\n                      if( sample == -1 )\n                          PrintIntDiff(row, s, pix, *pix1, *pix2);\n                      else\n                          PrintIntDiff(row, sample, pix, *pix1, *pix2);\n                  }\n\n                  pix1++;\n                  pix2++;\n              }\n          }\n          break;\n      }\n      case 16: \n      {\n          uint16 *pix1 = (uint16 *)p1, *pix2 = (uint16 *)p2;\n\n          for (pix = 0; pix < imagewidth; pix++) {\n              int\ts;\n\n              for(s = 0; s < samples_to_test; s++) {\n                  if (*pix1 != *pix2)\n                      PrintIntDiff(row, sample, pix, *pix1, *pix2);\n                        \n                  pix1++;\n                  pix2++;\n              }\n          }\n          break;\n      }\n      case 32: \n\tif (sampleformat == SAMPLEFORMAT_UINT\n\t    || sampleformat == SAMPLEFORMAT_INT) {\n\t\tuint32 *pix1 = (uint32 *)p1, *pix2 = (uint32 *)p2;\n\n\t\tfor (pix = 0; pix < imagewidth; pix++) {\n\t\t\tint\ts;\n\n\t\t\tfor(s = 0; s < samples_to_test; s++) {\n\t\t\t\tif (*pix1 != *pix2) {\n\t\t\t\t\tPrintIntDiff(row, sample, pix,\n\t\t\t\t\t\t     *pix1, *pix2);\n\t\t\t\t}\n                        \n\t\t\t\tpix1++;\n\t\t\t\tpix2++;\n\t\t\t}\n\t\t}\n\t} else if (sampleformat == SAMPLEFORMAT_IEEEFP) {\n\t\tfloat *pix1 = (float *)p1, *pix2 = (float *)p2;\n\n\t\tfor (pix = 0; pix < imagewidth; pix++) {\n\t\t\tint\ts;\n\n\t\t\tfor(s = 0; s < samples_to_test; s++) {\n\t\t\t\tif (fabs(*pix1 - *pix2) < 0.000000000001) {\n\t\t\t\t\tPrintFloatDiff(row, sample, pix,\n\t\t\t\t\t\t       *pix1, *pix2);\n\t\t\t\t}\n                        \n\t\t\t\tpix1++;\n\t\t\t\tpix2++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t  fprintf(stderr, \"Sample format %d is not supported.\\n\",\n\t\t\t  sampleformat);\n\t\t  return -1;\n\t}\n        break;\n      default:\n\tfprintf(stderr, \"Bit depth %d is not supported.\\n\", bitspersample);\n\treturn -1;\n    }\n\n    return 0;\n}",
          "fn_code_pos": [
            [
              326,
              0
            ],
            [
              424,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ContigCompare",
            "parameters": {
              "sample": "int",
              "row": "uint32",
              "p1": "unsigned char",
              "p2": "unsigned char",
              "size": "tsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nPrintIntDiff(uint32 row, int sample, uint32 pix, uint32 w1, uint32 w2)\n{\n\tif (sample < 0)\n\t\tsample = 0;\n\tswitch (bitspersample) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t    {\n\t\tint32 mask1, mask2, s;\n\n        /* mask1 should have the n lowest bits set, where n == bitspersample */\n        mask1 = ((int32)1 << bitspersample) - 1;\n\t\ts = (8 - bitspersample);\n\t\tmask2 = mask1 << s;\n\t\tfor (; mask2 && pix < imagewidth;\n\t\t     mask2 >>= bitspersample, s -= bitspersample, pix++) {\n\t\t\tif ((w1 & mask2) ^ (w2 & mask2)) {\n\t\t\t\tprintf(\n\t\t\t\"Scanline %lu, pixel %lu, sample %d: %01x %01x\\n\",\n\t    \t\t\t\t(unsigned long) row,\n\t\t\t\t\t(unsigned long) pix,\n\t\t\t\t\tsample,\n\t\t\t\t\t(unsigned int)((w1 >> s) & mask1),\n\t\t\t\t\t(unsigned int)((w2 >> s) & mask1));\n\t\t\t\tif (--stopondiff == 0)\n\t\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t    }\n\tcase 8: \n\t\tprintf(\"Scanline %lu, pixel %lu, sample %d: %02x %02x\\n\",\n\t\t       (unsigned long) row, (unsigned long) pix, sample,\n\t\t       (unsigned int) w1, (unsigned int) w2);\n\t\tif (--stopondiff == 0)\n\t\t\texit(1);\n\t\tbreak;\n\tcase 16:\n\t\tprintf(\"Scanline %lu, pixel %lu, sample %d: %04x %04x\\n\",\n\t\t    (unsigned long) row, (unsigned long) pix, sample,\n\t\t    (unsigned int) w1, (unsigned int) w2);\n\t\tif (--stopondiff == 0)\n\t\t\texit(1);\n\t\tbreak;\n\tcase 32:\n\t\tprintf(\"Scanline %lu, pixel %lu, sample %d: %08x %08x\\n\",\n\t\t    (unsigned long) row, (unsigned long) pix, sample,\n\t\t    (unsigned int) w1, (unsigned int) w2);\n\t\tif (--stopondiff == 0)\n\t\t\texit(1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "fn_code_pos": [
            [
              426,
              0
            ],
            [
              482,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintIntDiff",
            "parameters": {
              "row": "uint32",
              "sample": "int",
              "pix": "uint32",
              "w1": "uint32",
              "w2": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static void\nPrintFloatDiff(uint32 row, int sample, uint32 pix, double w1, double w2)\n{\n\tif (sample < 0)\n\t\tsample = 0;\n\tswitch (bitspersample) {\n\tcase 32: \n\t\tprintf(\"Scanline %lu, pixel %lu, sample %d: %g %g\\n\",\n\t\t    (long) row, (long) pix, sample, w1, w2);\n\t\tif (--stopondiff == 0)\n\t\t\texit(1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "fn_code_pos": [
            [
              484,
              0
            ],
            [
              499,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintFloatDiff",
            "parameters": {
              "row": "uint32",
              "sample": "int",
              "pix": "uint32",
              "w1": "double",
              "w2": "double"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "static int\nSeparateCompare(int reversed, int sample, uint32 row,\n\t\tunsigned char* cp1, unsigned char* p2)\n{\n\tuint32 npixels = imagewidth;\n\tint pixel;\n\n\tcp1 += sample;\n\tfor (pixel = 0; npixels-- > 0; pixel++, cp1 += samplesperpixel, p2++) {\n\t\tif (*cp1 != *p2) {\n\t\t\tprintf(\"Scanline %lu, pixel %lu, sample %ld: \",\n\t\t\t    (long) row, (long) pixel, (long) sample);\n\t\t\tif (reversed)\n\t\t\t\tprintf(\"%02x %02x\\n\", *p2, *cp1);\n\t\t\telse\n\t\t\t\tprintf(\"%02x %02x\\n\", *cp1, *p2);\n\t\t\tif (--stopondiff == 0)\n\t\t\t\texit(1);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              501,
              0
            ],
            [
              523,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SeparateCompare",
            "parameters": {
              "reversed": "int",
              "sample": "int",
              "row": "uint32",
              "cp1": "unsigned char",
              "p2": "unsigned char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\ncheckTag(TIFF* tif1, TIFF* tif2, int tag, char* name, void* p1, void* p2)\n{\n\n\tif (TIFFGetField(tif1, tag, p1)) {\n\t\tif (!TIFFGetField(tif2, tag, p2)) {\n\t\t\tprintf(\"%s tag appears only in %s\\n\",\n\t\t\t    name, TIFFFileName(tif1));\n\t\t\treturn (0);\n\t\t}\n\t\treturn (1);\n\t} else if (TIFFGetField(tif2, tag, p2)) {\n\t\tprintf(\"%s tag appears only in %s\\n\", name, TIFFFileName(tif2));\n\t\treturn (0);\n\t}\n\treturn (-1);\n}",
          "fn_code_pos": [
            [
              525,
              0
            ],
            [
              541,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "checkTag",
            "parameters": {
              "tif1": "TIFF",
              "tif2": "TIFF",
              "tag": "int",
              "name": "char",
              "p1": "void",
              "p2": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nCheckShortTag(TIFF* tif1, TIFF* tif2, int tag, char* name)\n{\n\tuint16 v1, v2;\n\tCHECK(v1 == v2, \"%s: %u %u\\n\");\n}",
          "fn_code_pos": [
            [
              552,
              0
            ],
            [
              557,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckShortTag",
            "parameters": {
              "tif1": "TIFF",
              "tif2": "TIFF",
              "tag": "int",
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nCheckShort2Tag(TIFF* tif1, TIFF* tif2, int tag, char* name)\n{\n\tuint16 v11, v12, v21, v22;\n\n\tif (TIFFGetField(tif1, tag, &v11, &v12)) {\n\t\tif (!TIFFGetField(tif2, tag, &v21, &v22)) {\n\t\t\tprintf(\"%s tag appears only in %s\\n\",\n\t\t\t    name, TIFFFileName(tif1));\n\t\t\treturn (0);\n\t\t}\n\t\tif (v11 == v21 && v12 == v22)\n\t\t\treturn (1);\n\t\tprintf(\"%s: <%u,%u> <%u,%u>\\n\", name, v11, v12, v21, v22);\n\t} else if (TIFFGetField(tif2, tag, &v21, &v22))\n\t\tprintf(\"%s tag appears only in %s\\n\", name, TIFFFileName(tif2));\n\telse\n\t\treturn (1);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              559,
              0
            ],
            [
              578,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckShort2Tag",
            "parameters": {
              "tif1": "TIFF",
              "tif2": "TIFF",
              "tag": "int",
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nCheckShortArrayTag(TIFF* tif1, TIFF* tif2, int tag, char* name)\n{\n\tuint16 n1, *a1;\n\tuint16 n2, *a2;\n\n\tif (TIFFGetField(tif1, tag, &n1, &a1)) {\n\t\tif (!TIFFGetField(tif2, tag, &n2, &a2)) {\n\t\t\tprintf(\"%s tag appears only in %s\\n\",\n\t\t\t    name, TIFFFileName(tif1));\n\t\t\treturn (0);\n\t\t}\n\t\tif (n1 == n2) {\n\t\t\tchar* sep;\n\t\t\tuint16 i;\n\n\t\t\tif (memcmp(a1, a2, n1 * sizeof(uint16)) == 0)\n\t\t\t\treturn (1);\n\t\t\tprintf(\"%s: value mismatch, <%u:\", name, n1);\n\t\t\tsep = \"\";\n\t\t\tfor (i = 0; i < n1; i++)\n\t\t\t\tprintf(\"%s%u\", sep, a1[i]), sep = \",\";\n\t\t\tprintf(\"> and <%u: \", n2);\n\t\t\tsep = \"\";\n\t\t\tfor (i = 0; i < n2; i++)\n\t\t\t\tprintf(\"%s%u\", sep, a2[i]), sep = \",\";\n\t\t\tprintf(\">\\n\");\n\t\t} else\n\t\t\tprintf(\"%s: %u items in %s, %u items in %s\", name,\n\t\t\t    n1, TIFFFileName(tif1),\n\t\t\t    n2, TIFFFileName(tif2)\n\t\t\t);\n\t} else if (TIFFGetField(tif2, tag, &n2, &a2))\n\t\tprintf(\"%s tag appears only in %s\\n\", name, TIFFFileName(tif2));\n\telse\n\t\treturn (1);\n\treturn (0);\n}",
          "fn_code_pos": [
            [
              580,
              0
            ],
            [
              617,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckShortArrayTag",
            "parameters": {
              "tif1": "TIFF",
              "tif2": "TIFF",
              "tag": "int",
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nCheckLongTag(TIFF* tif1, TIFF* tif2, int tag, char* name)\n{\n\tuint32 v1, v2;\n\tCHECK(v1 == v2, \"%s: %u %u\\n\");\n}",
          "fn_code_pos": [
            [
              619,
              0
            ],
            [
              624,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLongTag",
            "parameters": {
              "tif1": "TIFF",
              "tif2": "TIFF",
              "tag": "int",
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nCheckFloatTag(TIFF* tif1, TIFF* tif2, int tag, char* name)\n{\n\tfloat v1, v2;\n\tCHECK(v1 == v2, \"%s: %g %g\\n\");\n}",
          "fn_code_pos": [
            [
              626,
              0
            ],
            [
              631,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFloatTag",
            "parameters": {
              "tif1": "TIFF",
              "tif2": "TIFF",
              "tag": "int",
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int\nCheckStringTag(TIFF* tif1, TIFF* tif2, int tag, char* name)\n{\n\tchar *v1, *v2;\n\tCHECK(strcmp(v1, v2) == 0, \"%s: \\\"%s\\\" \\\"%s\\\"\\n\");\n}",
          "fn_code_pos": [
            [
              633,
              0
            ],
            [
              638,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckStringTag",
            "parameters": {
              "tif1": "TIFF",
              "tif2": "TIFF",
              "tag": "int",
              "name": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static void\nleof(const char* name, uint32 row, int s)\n{\n\n\tprintf(\"%s: EOF at scanline %lu\", name, (unsigned long)row);\n\tif (s >= 0)\n\t\tprintf(\", sample %d\", s);\n\tprintf(\"\\n\");\n}",
          "fn_code_pos": [
            [
              640,
              0
            ],
            [
              648,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "leof",
            "parameters": {
              "name": "char",
              "row": "uint32",
              "s": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "getopt(int, char**, char*)",
          "fn_dec_pos": [
            [
              42,
              11
            ],
            [
              42,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "usage(void)",
          "fn_dec_pos": [
            [
              53,
              12
            ],
            [
              53,
              23
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "usage",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "tiffcmp(TIFF*, TIFF*)",
          "fn_dec_pos": [
            [
              54,
              11
            ],
            [
              54,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "tiffcmp",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "cmptags(TIFF*, TIFF*)",
          "fn_dec_pos": [
            [
              55,
              11
            ],
            [
              55,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "cmptags",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "ContigCompare(int, uint32, unsigned char*, unsigned char*, tsize_t)",
          "fn_dec_pos": [
            [
              56,
              11
            ],
            [
              56,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "ContigCompare",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "SeparateCompare(int, int, uint32, unsigned char*, unsigned char*)",
          "fn_dec_pos": [
            [
              57,
              11
            ],
            [
              57,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "SeparateCompare",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "PrintIntDiff(uint32, int, uint32, uint32, uint32)",
          "fn_dec_pos": [
            [
              58,
              12
            ],
            [
              58,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintIntDiff",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "PrintFloatDiff(uint32, int, uint32, double, double)",
          "fn_dec_pos": [
            [
              59,
              12
            ],
            [
              59,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "PrintFloatDiff",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "leof(const char*, uint32, int)",
          "fn_dec_pos": [
            [
              61,
              12
            ],
            [
              61,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "leof",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "CheckShortTag(TIFF*, TIFF*, int, char*)",
          "fn_dec_pos": [
            [
              144,
              11
            ],
            [
              144,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckShortTag",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "CheckShort2Tag(TIFF*, TIFF*, int, char*)",
          "fn_dec_pos": [
            [
              145,
              11
            ],
            [
              145,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckShort2Tag",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "CheckShortArrayTag(TIFF*, TIFF*, int, char*)",
          "fn_dec_pos": [
            [
              146,
              11
            ],
            [
              146,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckShortArrayTag",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "CheckLongTag(TIFF*, TIFF*, int, char*)",
          "fn_dec_pos": [
            [
              147,
              11
            ],
            [
              147,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLongTag",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "CheckFloatTag(TIFF*, TIFF*, int, char*)",
          "fn_dec_pos": [
            [
              148,
              11
            ],
            [
              148,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckFloatTag",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "CheckStringTag(TIFF*, TIFF*, int, char*)",
          "fn_dec_pos": [
            [
              149,
              11
            ],
            [
              149,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckStringTag",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            24,
            0
          ],
          [
            25,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            26,
            0
          ],
          [
            27,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ],
        [
          "#include <math.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "# include <unistd.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "# include \"libport.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/port/getopt.c": {
      "fn_def_list": [
        {
          "fn_code": "int\ngetopt(int argc, char * const argv[], const char *optstring)\n{\n\tstatic char *place = EMSG;\t\t/* option letter processing */\n\tchar *oli;\t\t\t\t/* option letter list index */\n\n\tif (optreset || *place == 0) {\t\t/* update scanning pointer */\n\t\toptreset = 0;\n\t\tplace = argv[optind];\n\t\tif (optind >= argc || *place++ != '-') {\n\t\t\t/* Argument is absent or is not an option */\n\t\t\tplace = EMSG;\n\t\t\treturn (-1);\n\t\t}\n\t\toptopt = *place++;\n\t\tif (optopt == '-' && *place == 0) {\n\t\t\t/* \"--\" => end of options */\n\t\t\t++optind;\n\t\t\tplace = EMSG;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (optopt == 0) {\n\t\t\t/* Solitary '-', treat as a '-' option\n\t\t\t   if the program (eg su) is looking for it. */\n\t\t\tplace = EMSG;\n\t\t\tif (strchr(optstring, '-') == NULL)\n\t\t\t\treturn -1;\n\t\t\toptopt = '-';\n\t\t}\n\t} else\n\t\toptopt = *place++;\n\n\t/* See if option letter is one the caller wanted... */\n\tif (optopt == ':' || (oli = strchr(optstring, optopt)) == NULL) {\n\t\tif (*place == 0)\n\t\t\t++optind;\n\t\tif (opterr && *optstring != ':')\n\t\t\t(void)fprintf(stderr,\n                                      \"unknown option -- %c\\n\", optopt);\n\t\treturn (BADCH);\n\t}\n\n\t/* Does this option need an argument? */\n\tif (oli[1] != ':') {\n\t\t/* don't need argument */\n\t\toptarg = NULL;\n\t\tif (*place == 0)\n\t\t\t++optind;\n\t} else {\n\t\t/* Option-argument is either the rest of this argument or the\n\t\t   entire next argument. */\n\t\tif (*place)\n\t\t\toptarg = place;\n\t\telse if (argc > ++optind)\n\t\t\toptarg = argv[optind];\n\t\telse {\n\t\t\t/* option-argument absent */\n\t\t\tplace = EMSG;\n\t\t\tif (*optstring == ':')\n\t\t\t\treturn (BADARG);\n\t\t\tif (opterr)\n\t\t\t\t(void)fprintf(stderr,\n                                        \"option requires an argument -- %c\\n\",\n                                        optopt);\n\t\t\treturn (BADCH);\n\t\t}\n\t\tplace = EMSG;\n\t\t++optind;\n\t}\n\treturn (optopt);\t\t\t/* return option letter */\n}",
          "fn_code_pos": [
            [
              52,
              0
            ],
            [
              122,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {
              "argc": "int",
              "argv": "char",
              "optstring": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"libport.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/port/dummy.c": {
      "fn_def_list": [
        {
          "fn_code": "void\nlibport_dummy_function()\n{\n        return;\n}",
          "fn_code_pos": [
            [
              4,
              0
            ],
            [
              8,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "libport_dummy_function",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/port/snprintf.c": {
      "fn_def_list": [
        {
          "fn_code": "int _TIFF_vsnprintf_f(char* str, size_t size, const char* format, va_list ap)\n{\n  int count = -1;\n\n  if (size != 0)\n#if _MSC_VER <=\t1310\n    count = _vsnprintf(str, size, format, ap);\n#else\n    count = _vsnprintf_s(str, size, _TRUNCATE, format, ap);\n#endif\n  if (count == -1)\n    count = _vscprintf(format, ap);\n\n  return count;\n}",
          "fn_code_pos": [
            [
              13,
              0
            ],
            [
              27,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFF_vsnprintf_f",
            "parameters": {
              "str": "char",
              "size": "size_t",
              "format": "char",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int _TIFF_snprintf_f(char* str, size_t size, const char* format, ...)\n{\n  int count;\n  va_list ap;\n\n  va_start(ap, format);\n  count = vsnprintf(str, size, format, ap);\n  va_end(ap);\n\n  return count;\n}",
          "fn_code_pos": [
            [
              29,
              0
            ],
            [
              39,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFF_snprintf_f",
            "parameters": {
              "str": "char",
              "size": "size_t",
              "format": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            9,
            0
          ],
          [
            10,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            10,
            0
          ],
          [
            11,
            0
          ]
        ],
        [
          "#include \"libport.h\"\n",
          [
            11,
            0
          ],
          [
            12,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/port/strcasecmp.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nstrcasecmp(const char *s1, const char *s2)\n{\n\tconst unsigned char *us1 = (const unsigned char *)s1,\n\t\t\t*us2 = (const unsigned char *)s2;\n\n\twhile (tolower((int) *us1) == tolower((int) *us2++))\n\t\tif (*us1++ == '\\0')\n\t\t\treturn (0);\n\treturn (tolower((int) *us1) - tolower((int) *--us2));\n}",
          "fn_code_pos": [
            [
              38,
              0
            ],
            [
              48,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strcasecmp",
            "parameters": {
              "s1": "char",
              "s2": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <ctype.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include \"libport.h\"\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/port/strtoull.c": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <assert.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"_strtoul.h\"\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/port/strtoul.c": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <assert.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"_strtoul.h\"\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/port/strtol.c": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <assert.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <limits.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"_strtol.h\"\n",
          [
            44,
            0
          ],
          [
            45,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/port/lfind.c": {
      "fn_def_list": [
        {
          "fn_code": "void *\nlfind(const void *key, const void *base, size_t *nmemb, size_t size,\n      int(*compar)(const void *, const void *))\n{\n\tchar *element, *end;\n\n\tend = (char *)base + *nmemb * size;\n\tfor (element = (char *)base; element < end; element += size)\n\t\tif (!compar(element, key))\t\t/* key found */\n\t\t\treturn element;\n\n\treturn NULL;\n}",
          "fn_code_pos": [
            [
              47,
              0
            ],
            [
              59,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lfind",
            "parameters": {
              "key": "void",
              "base": "void",
              "nmemb": "size_t",
              "size": "size_t",
              "compar": "int"
            },
            "return_type": "void"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "lfind(const void *key, const void *base, size_t *nmemb, size_t size,\n      int(*compar)(const void *, const void *))",
          "fn_dec_pos": [
            [
              48,
              0
            ],
            [
              49,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lfind",
            "parameters": {
              "key": "void",
              "base": "void",
              "nmemb": "size_t",
              "size": "size_t",
              "compar": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*compar)(const void *, const void *)",
          "fn_dec_pos": [
            [
              49,
              9
            ],
            [
              49,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "# include <wce_types.h>\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "# include <sys/types.h>\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/port/strtoll.c": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <assert.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <ctype.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <errno.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            36,
            0
          ],
          [
            37,
            0
          ]
        ],
        [
          "#include \"_strtol.h\"\n",
          [
            43,
            0
          ],
          [
            44,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    }
  },
  "head": {
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tiff.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\tuint16 tiff_magic;      /* magic number (defines byte order) */\n\tuint16 tiff_version;    /* TIFF version number */\n} TIFFHeaderCommon;",
          {
            "tiff_magic": "uint16",
            "tiff_version": "uint16"
          },
          "TIFFHeaderCommon",
          [
            90,
            0
          ],
          [
            93,
            19
          ]
        ],
        [
          "typedef struct {\n\tuint16 tiff_magic;      /* magic number (defines byte order) */\n\tuint16 tiff_version;    /* TIFF version number */\n\tuint32 tiff_diroff;     /* byte offset to first directory */\n} TIFFHeaderClassic;",
          {
            "tiff_magic": "uint16",
            "tiff_version": "uint16",
            "tiff_diroff": "uint32"
          },
          "TIFFHeaderClassic",
          [
            94,
            0
          ],
          [
            98,
            20
          ]
        ],
        [
          "typedef struct {\n\tuint16 tiff_magic;      /* magic number (defines byte order) */\n\tuint16 tiff_version;    /* TIFF version number */\n\tuint16 tiff_offsetsize; /* size of offsets, should be 8 */\n\tuint16 tiff_unused;     /* unused word, should be 0 */\n\tuint64 tiff_diroff;     /* byte offset to first directory */\n} TIFFHeaderBig;",
          {
            "tiff_magic": "uint16",
            "tiff_version": "uint16",
            "tiff_offsetsize": "uint16",
            "tiff_unused": "uint16",
            "tiff_diroff": "uint64"
          },
          "TIFFHeaderBig",
          [
            99,
            0
          ],
          [
            105,
            16
          ]
        ],
        [
          "typedef struct {\n\tuint16 tiff_magic;      /* magic number (defines byte order) */\n\tuint16 tiff_version;    /* TIFF version number */\n} TIFFHeaderCommon;",
          {
            "tiff_magic": "uint16",
            "tiff_version": "uint16"
          },
          "TIFFHeaderCommon",
          [
            90,
            0
          ],
          [
            93,
            19
          ]
        ],
        [
          "typedef struct {\n\tuint16 tiff_magic;      /* magic number (defines byte order) */\n\tuint16 tiff_version;    /* TIFF version number */\n\tuint32 tiff_diroff;     /* byte offset to first directory */\n} TIFFHeaderClassic;",
          {
            "tiff_magic": "uint16",
            "tiff_version": "uint16",
            "tiff_diroff": "uint32"
          },
          "TIFFHeaderClassic",
          [
            94,
            0
          ],
          [
            98,
            20
          ]
        ],
        [
          "typedef struct {\n\tuint16 tiff_magic;      /* magic number (defines byte order) */\n\tuint16 tiff_version;    /* TIFF version number */\n\tuint16 tiff_offsetsize; /* size of offsets, should be 8 */\n\tuint16 tiff_unused;     /* unused word, should be 0 */\n\tuint64 tiff_diroff;     /* byte offset to first directory */\n} TIFFHeaderBig;",
          {
            "tiff_magic": "uint16",
            "tiff_version": "uint16",
            "tiff_offsetsize": "uint16",
            "tiff_unused": "uint16",
            "tiff_diroff": "uint64"
          },
          "TIFFHeaderBig",
          [
            99,
            0
          ],
          [
            105,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffconf.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n\tTIFF_NOTYPE = 0,      /* placeholder */\n\tTIFF_BYTE = 1,        /* 8-bit unsigned integer */\n\tTIFF_ASCII = 2,       /* 8-bit bytes w/ last byte null */\n\tTIFF_SHORT = 3,       /* 16-bit unsigned integer */\n\tTIFF_LONG = 4,        /* 32-bit unsigned integer */\n\tTIFF_RATIONAL = 5,    /* 64-bit unsigned fraction */\n\tTIFF_SBYTE = 6,       /* !8-bit signed integer */\n\tTIFF_UNDEFINED = 7,   /* !8-bit untyped data */\n\tTIFF_SSHORT = 8,      /* !16-bit signed integer */\n\tTIFF_SLONG = 9,       /* !32-bit signed integer */\n\tTIFF_SRATIONAL = 10,  /* !64-bit signed fraction */\n\tTIFF_FLOAT = 11,      /* !32-bit IEEE floating point */\n\tTIFF_DOUBLE = 12,     /* !64-bit IEEE floating point */\n\tTIFF_IFD = 13,        /* %32-bit unsigned integer (offset) */\n\tTIFF_LONG8 = 16,      /* BigTIFF 64-bit unsigned integer */\n\tTIFF_SLONG8 = 17,     /* BigTIFF 64-bit signed integer */\n\tTIFF_IFD8 = 18        /* BigTIFF 64-bit unsigned integer (offset) */\n} TIFFDataType;",
          {
            "TIFF_NOTYPE": "",
            "TIFF_BYTE": "",
            "TIFF_ASCII": "",
            "TIFF_SHORT": "",
            "TIFF_LONG": "",
            "TIFF_RATIONAL": "",
            "TIFF_SBYTE": "",
            "TIFF_UNDEFINED": "",
            "TIFF_SSHORT": "",
            "TIFF_SLONG": "",
            "TIFF_SRATIONAL": "",
            "TIFF_FLOAT": "",
            "TIFF_DOUBLE": "",
            "TIFF_IFD": "",
            "TIFF_LONG8": "",
            "TIFF_SLONG8": "",
            "TIFF_IFD8": ""
          },
          "TIFFDataType",
          [
            122,
            0
          ],
          [
            140,
            15
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tiffconf.vc.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tiffio.hxx": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "TIFFStreamOpen(const char*, std::ostream *)",
          "fn_dec_pos": [
            [
              35,
              13
            ],
            [
              35,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFStreamOpen",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFStreamOpen(const char*, std::istream *)",
          "fn_dec_pos": [
            [
              36,
              13
            ],
            [
              36,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFStreamOpen",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <iostream>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include \"tiff.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_fax3.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*TIFFFaxFillFunc)(unsigned char*, uint32*, uint32*, uint32)",
          "fn_dec_pos": [
            [
              52,
              13
            ],
            [
              52,
              73
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFFax3fillruns(unsigned char*, uint32*, uint32*, uint32)",
          "fn_dec_pos": [
            [
              60,
              12
            ],
            [
              60,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFFax3fillruns",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {                /* state table entry */\n\tunsigned char State;    /* see above */\n\tunsigned char Width;    /* width of code in bits */\n\tuint32 Param;           /* unsigned 32-bit run length in bits (holds on 16 bit actually, but cannot be changed. See above warning) */\n} TIFFFaxTabEnt;",
          {
            "State": "unsigned char",
            "Width": "unsigned char",
            "Param": "uint32"
          },
          "TIFFFaxTabEnt",
          [
            83,
            0
          ],
          [
            87,
            16
          ]
        ],
        [
          "typedef struct {                /* state table entry */\n\tunsigned char State;    /* see above */\n\tunsigned char Width;    /* width of code in bits */\n\tuint32 Param;           /* unsigned 32-bit run length in bits (holds on 16 bit actually, but cannot be changed. See above warning) */\n} TIFFFaxTabEnt;",
          {
            "State": "unsigned char",
            "Width": "unsigned char",
            "Param": "uint32"
          },
          "TIFFFaxTabEnt",
          [
            83,
            0
          ],
          [
            87,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiff.h\"\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_config.wince.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/uvcode.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct {\n\tfloat\tustart;\n\tshort\tnus, ncum;\n}",
          {
            "ustart": "float",
            "nus": "short"
          },
          "",
          [
            5,
            13
          ],
          [
            8,
            1
          ]
        ],
        [
          "struct {\n\tfloat\tustart;\n\tshort\tnus, ncum;\n}",
          {
            "ustart": "float",
            "nus": "short"
          },
          "",
          [
            5,
            13
          ],
          [
            8,
            1
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_predict.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*TIFFEncodeDecodeMethod)(TIFF* tif, uint8* buf, tmsize_t size)",
          "fn_dec_pos": [
            [
              34,
              12
            ],
            [
              34,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "size": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFPredictorInit(TIFF*)",
          "fn_dec_pos": [
            [
              66,
              11
            ],
            [
              66,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFPredictorInit",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFPredictorCleanup(TIFF*)",
          "fn_dec_pos": [
            [
              67,
              11
            ],
            [
              67,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFPredictorCleanup",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\tint             predictor;\t/* predictor tag value */\n\ttmsize_t        stride;\t\t/* sample stride over data */\n\ttmsize_t        rowsize;\t/* tile/strip row size */\n\n\tTIFFCodeMethod  encoderow;\t/* parent codec encode/decode row */\n\tTIFFCodeMethod  encodestrip;\t/* parent codec encode/decode strip */\n\tTIFFCodeMethod  encodetile;\t/* parent codec encode/decode tile */ \n\tTIFFEncodeDecodeMethod  encodepfunc;\t/* horizontal differencer */\n\n\tTIFFCodeMethod  decoderow;\t/* parent codec encode/decode row */\n\tTIFFCodeMethod  decodestrip;\t/* parent codec encode/decode strip */\n\tTIFFCodeMethod  decodetile;\t/* parent codec encode/decode tile */ \n\tTIFFEncodeDecodeMethod  decodepfunc;\t/* horizontal accumulator */\n\n\tTIFFVGetMethod  vgetparent;\t/* super-class method */\n\tTIFFVSetMethod  vsetparent;\t/* super-class method */\n\tTIFFPrintMethod printdir;\t/* super-class method */\n\tTIFFBoolMethod  setupdecode;\t/* super-class method */\n\tTIFFBoolMethod  setupencode;\t/* super-class method */\n} TIFFPredictorState;",
          {
            "predictor": "int",
            "stride": "tmsize_t",
            "rowsize": "tmsize_t",
            "encoderow": "TIFFCodeMethod",
            "encodestrip": "TIFFCodeMethod",
            "encodetile": "TIFFCodeMethod",
            "encodepfunc": "TIFFEncodeDecodeMethod",
            "decoderow": "TIFFCodeMethod",
            "decodestrip": "TIFFCodeMethod",
            "decodetile": "TIFFCodeMethod",
            "decodepfunc": "TIFFEncodeDecodeMethod",
            "vgetparent": "TIFFVGetMethod",
            "vsetparent": "TIFFVSetMethod",
            "printdir": "TIFFPrintMethod",
            "setupdecode": "TIFFBoolMethod",
            "setupencode": "TIFFBoolMethod"
          },
          "TIFFPredictorState",
          [
            41,
            0
          ],
          [
            61,
            21
          ]
        ],
        [
          "typedef struct {\n\tint             predictor;\t/* predictor tag value */\n\ttmsize_t        stride;\t\t/* sample stride over data */\n\ttmsize_t        rowsize;\t/* tile/strip row size */\n\n\tTIFFCodeMethod  encoderow;\t/* parent codec encode/decode row */\n\tTIFFCodeMethod  encodestrip;\t/* parent codec encode/decode strip */\n\tTIFFCodeMethod  encodetile;\t/* parent codec encode/decode tile */ \n\tTIFFEncodeDecodeMethod  encodepfunc;\t/* horizontal differencer */\n\n\tTIFFCodeMethod  decoderow;\t/* parent codec encode/decode row */\n\tTIFFCodeMethod  decodestrip;\t/* parent codec encode/decode strip */\n\tTIFFCodeMethod  decodetile;\t/* parent codec encode/decode tile */ \n\tTIFFEncodeDecodeMethod  decodepfunc;\t/* horizontal accumulator */\n\n\tTIFFVGetMethod  vgetparent;\t/* super-class method */\n\tTIFFVSetMethod  vsetparent;\t/* super-class method */\n\tTIFFPrintMethod printdir;\t/* super-class method */\n\tTIFFBoolMethod  setupdecode;\t/* super-class method */\n\tTIFFBoolMethod  setupencode;\t/* super-class method */\n} TIFFPredictorState;",
          {
            "predictor": "int",
            "stride": "tmsize_t",
            "rowsize": "tmsize_t",
            "encoderow": "TIFFCodeMethod",
            "encodestrip": "TIFFCodeMethod",
            "encodetile": "TIFFCodeMethod",
            "encodepfunc": "TIFFEncodeDecodeMethod",
            "decoderow": "TIFFCodeMethod",
            "decodestrip": "TIFFCodeMethod",
            "decodetile": "TIFFCodeMethod",
            "decodepfunc": "TIFFEncodeDecodeMethod",
            "vgetparent": "TIFFVGetMethod",
            "vsetparent": "TIFFVSetMethod",
            "printdir": "TIFFPrintMethod",
            "setupdecode": "TIFFBoolMethod",
            "setupencode": "TIFFBoolMethod"
          },
          "TIFFPredictorState",
          [
            41,
            0
          ],
          [
            61,
            21
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffio.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"tiffiop.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/t4.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct tableentry {\n    unsigned short length;  /* bit length of g3 code */\n    unsigned short code;    /* g3 code */\n    short runlen;           /* run length in bits */\n} tableentry;",
          {
            "length": "unsigned short",
            "code": "unsigned short",
            "runlen": "short"
          },
          "tableentry",
          [
            32,
            0
          ],
          [
            36,
            13
          ]
        ],
        [
          "typedef struct tableentry {\n    unsigned short length;  /* bit length of g3 code */\n    unsigned short code;    /* g3 code */\n    short runlen;           /* run length in bits */\n} tableentry;",
          {
            "length": "unsigned short",
            "code": "unsigned short",
            "runlen": "short"
          },
          "tableentry",
          [
            32,
            0
          ],
          [
            36,
            13
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_config.vc.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tiffconf.wince.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tiffio.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*tileContigRoutine)\n    (TIFFRGBAImage*, uint32*, uint32, uint32, uint32, uint32, int32, int32,\n\tunsigned char*)",
          "fn_dec_pos": [
            [
              187,
              13
            ],
            [
              189,
              16
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*tileSeparateRoutine)\n    (TIFFRGBAImage*, uint32*, uint32, uint32, uint32, uint32, int32, int32,\n\tunsigned char*, unsigned char*, unsigned char*, unsigned char*)",
          "fn_dec_pos": [
            [
              190,
              13
            ],
            [
              192,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*get)(TIFFRGBAImage*, uint32*, uint32, uint32)",
          "fn_dec_pos": [
            [
              212,
              5
            ],
            [
              212,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*any)(TIFFRGBAImage*)",
          "fn_dec_pos": [
            [
              215,
              10
            ],
            [
              215,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*TIFFInitMethod)(TIFF*, int)",
          "fn_dec_pos": [
            [
              248,
              12
            ],
            [
              248,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*TIFFErrorHandler)(const char*, const char*, va_list)",
          "fn_dec_pos": [
            [
              270,
              13
            ],
            [
              270,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*TIFFErrorHandlerExt)(thandle_t, const char*, const char*, va_list)",
          "fn_dec_pos": [
            [
              271,
              13
            ],
            [
              271,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*TIFFReadWriteProc)(thandle_t, void*, tmsize_t)",
          "fn_dec_pos": [
            [
              272,
              17
            ],
            [
              272,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "(*TIFFSeekProc)(thandle_t, toff_t, int)",
          "fn_dec_pos": [
            [
              273,
              15
            ],
            [
              273,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "toff_t"
          }
        },
        {
          "fn_code": "(*TIFFCloseProc)(thandle_t)",
          "fn_dec_pos": [
            [
              274,
              12
            ],
            [
              274,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*TIFFSizeProc)(thandle_t)",
          "fn_dec_pos": [
            [
              275,
              15
            ],
            [
              275,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "toff_t"
          }
        },
        {
          "fn_code": "(*TIFFMapFileProc)(thandle_t, void** base, toff_t* size)",
          "fn_dec_pos": [
            [
              276,
              12
            ],
            [
              276,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "base": "void",
              "size": "toff_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*TIFFUnmapFileProc)(thandle_t, void* base, toff_t size)",
          "fn_dec_pos": [
            [
              277,
              13
            ],
            [
              277,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "base": "void",
              "size": "toff_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*TIFFExtendProc)(TIFF*)",
          "fn_dec_pos": [
            [
              278,
              13
            ],
            [
              278,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFGetVersion(void)",
          "fn_dec_pos": [
            [
              280,
              19
            ],
            [
              280,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetVersion",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFFindCODEC(uint16)",
          "fn_dec_pos": [
            [
              282,
              24
            ],
            [
              282,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFindCODEC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFRegisterCODEC(uint16, const char*, TIFFInitMethod)",
          "fn_dec_pos": [
            [
              283,
              18
            ],
            [
              283,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRegisterCODEC",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFUnRegisterCODEC(TIFFCodec*)",
          "fn_dec_pos": [
            [
              284,
              12
            ],
            [
              284,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFUnRegisterCODEC",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFIsCODECConfigured(uint16)",
          "fn_dec_pos": [
            [
              285,
              11
            ],
            [
              285,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFIsCODECConfigured",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFGetConfiguredCODECs(void)",
          "fn_dec_pos": [
            [
              286,
              18
            ],
            [
              286,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetConfiguredCODECs",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFmalloc(tmsize_t s)",
          "fn_dec_pos": [
            [
              292,
              13
            ],
            [
              292,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmalloc",
            "parameters": {
              "s": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFcalloc(tmsize_t nmemb, tmsize_t siz)",
          "fn_dec_pos": [
            [
              293,
              13
            ],
            [
              293,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFcalloc",
            "parameters": {
              "nmemb": "tmsize_t",
              "siz": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFrealloc(void* p, tmsize_t s)",
          "fn_dec_pos": [
            [
              294,
              13
            ],
            [
              294,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFrealloc",
            "parameters": {
              "p": "void",
              "s": "tmsize_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFmemset(void* p, int v, tmsize_t c)",
          "fn_dec_pos": [
            [
              295,
              12
            ],
            [
              295,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmemset",
            "parameters": {
              "p": "void",
              "v": "int",
              "c": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFmemcpy(void* d, const void* s, tmsize_t c)",
          "fn_dec_pos": [
            [
              296,
              12
            ],
            [
              296,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmemcpy",
            "parameters": {
              "d": "void",
              "s": "void",
              "c": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFmemcmp(const void* p1, const void* p2, tmsize_t c)",
          "fn_dec_pos": [
            [
              297,
              11
            ],
            [
              297,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFmemcmp",
            "parameters": {
              "p1": "void",
              "p2": "void",
              "c": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFfree(void* p)",
          "fn_dec_pos": [
            [
              298,
              12
            ],
            [
              298,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFfree",
            "parameters": {
              "p": "void"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFGetTagListCount( TIFF * )",
          "fn_dec_pos": [
            [
              303,
              11
            ],
            [
              303,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetTagListCount",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFGetTagListEntry( TIFF *, int tag_index )",
          "fn_dec_pos": [
            [
              304,
              14
            ],
            [
              304,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetTagListEntry",
            "parameters": {
              "tag_index": "int"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "TIFFFindField(TIFF *, uint32, TIFFDataType)",
          "fn_dec_pos": [
            [
              316,
              24
            ],
            [
              316,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFindField",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFFieldWithTag(TIFF*, uint32)",
          "fn_dec_pos": [
            [
              317,
              24
            ],
            [
              317,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldWithTag",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFFieldWithName(TIFF*, const char *)",
          "fn_dec_pos": [
            [
              318,
              24
            ],
            [
              318,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldWithName",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFFieldTag(const TIFFField*)",
          "fn_dec_pos": [
            [
              320,
              14
            ],
            [
              320,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldTag",
            "parameters": {},
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "TIFFFieldName(const TIFFField*)",
          "fn_dec_pos": [
            [
              321,
              19
            ],
            [
              321,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldName",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFFieldDataType(const TIFFField*)",
          "fn_dec_pos": [
            [
              322,
              20
            ],
            [
              322,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldDataType",
            "parameters": {},
            "return_type": "TIFFDataType"
          }
        },
        {
          "fn_code": "TIFFFieldPassCount(const TIFFField*)",
          "fn_dec_pos": [
            [
              323,
              11
            ],
            [
              323,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldPassCount",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFieldReadCount(const TIFFField*)",
          "fn_dec_pos": [
            [
              324,
              11
            ],
            [
              324,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldReadCount",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFieldWriteCount(const TIFFField*)",
          "fn_dec_pos": [
            [
              325,
              11
            ],
            [
              325,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFieldWriteCount",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*TIFFVSetMethod)(TIFF*, uint32, va_list)",
          "fn_dec_pos": [
            [
              327,
              12
            ],
            [
              327,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*TIFFVGetMethod)(TIFF*, uint32, va_list)",
          "fn_dec_pos": [
            [
              328,
              12
            ],
            [
              328,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*TIFFPrintMethod)(TIFF*, FILE*, long)",
          "fn_dec_pos": [
            [
              329,
              13
            ],
            [
              329,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFAccessTagMethods(TIFF *)",
          "fn_dec_pos": [
            [
              337,
              24
            ],
            [
              337,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFAccessTagMethods",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFGetClientInfo(TIFF *, const char *)",
          "fn_dec_pos": [
            [
              338,
              14
            ],
            [
              338,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetClientInfo",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFSetClientInfo(TIFF *, void *, const char *)",
          "fn_dec_pos": [
            [
              339,
              13
            ],
            [
              339,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetClientInfo",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFCleanup(TIFF* tif)",
          "fn_dec_pos": [
            [
              341,
              12
            ],
            [
              341,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCleanup",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFClose(TIFF* tif)",
          "fn_dec_pos": [
            [
              342,
              12
            ],
            [
              342,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFClose",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFFlush(TIFF* tif)",
          "fn_dec_pos": [
            [
              343,
              11
            ],
            [
              343,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFlush",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFlushData(TIFF* tif)",
          "fn_dec_pos": [
            [
              344,
              11
            ],
            [
              344,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFlushData",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFGetField(TIFF* tif, uint32 tag, ...)",
          "fn_dec_pos": [
            [
              345,
              11
            ],
            [
              345,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)",
          "fn_dec_pos": [
            [
              346,
              11
            ],
            [
              346,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFVGetField",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFGetFieldDefaulted(TIFF* tif, uint32 tag, ...)",
          "fn_dec_pos": [
            [
              347,
              11
            ],
            [
              347,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetFieldDefaulted",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFVGetFieldDefaulted(TIFF* tif, uint32 tag, va_list ap)",
          "fn_dec_pos": [
            [
              348,
              11
            ],
            [
              348,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFVGetFieldDefaulted",
            "parameters": {
              "tif": "TIFF",
              "tag": "uint32",
              "ap": "va_list"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFReadDirectory(TIFF* tif)",
          "fn_dec_pos": [
            [
              349,
              11
            ],
            [
              349,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFReadCustomDirectory(TIFF* tif, toff_t diroff, const TIFFFieldArray* infoarray)",
          "fn_dec_pos": [
            [
              350,
              11
            ],
            [
              350,
              93
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadCustomDirectory",
            "parameters": {
              "tif": "TIFF",
              "diroff": "toff_t",
              "infoarray": "TIFFFieldArray"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFReadEXIFDirectory(TIFF* tif, toff_t diroff)",
          "fn_dec_pos": [
            [
              351,
              11
            ],
            [
              351,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadEXIFDirectory",
            "parameters": {
              "tif": "TIFF",
              "diroff": "toff_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFScanlineSize64(TIFF* tif)",
          "fn_dec_pos": [
            [
              352,
              14
            ],
            [
              352,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFScanlineSize64",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "TIFFScanlineSize(TIFF* tif)",
          "fn_dec_pos": [
            [
              353,
              16
            ],
            [
              353,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFScanlineSize",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFRasterScanlineSize64(TIFF* tif)",
          "fn_dec_pos": [
            [
              354,
              14
            ],
            [
              354,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRasterScanlineSize64",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "TIFFRasterScanlineSize(TIFF* tif)",
          "fn_dec_pos": [
            [
              355,
              16
            ],
            [
              355,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRasterScanlineSize",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFStripSize64(TIFF* tif)",
          "fn_dec_pos": [
            [
              356,
              14
            ],
            [
              356,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFStripSize64",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "TIFFStripSize(TIFF* tif)",
          "fn_dec_pos": [
            [
              357,
              16
            ],
            [
              357,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFStripSize",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFRawStripSize64(TIFF* tif, uint32 strip)",
          "fn_dec_pos": [
            [
              358,
              14
            ],
            [
              358,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRawStripSize64",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "TIFFRawStripSize(TIFF* tif, uint32 strip)",
          "fn_dec_pos": [
            [
              359,
              16
            ],
            [
              359,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRawStripSize",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFVStripSize64(TIFF* tif, uint32 nrows)",
          "fn_dec_pos": [
            [
              360,
              14
            ],
            [
              360,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFVStripSize64",
            "parameters": {
              "tif": "TIFF",
              "nrows": "uint32"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "TIFFVStripSize(TIFF* tif, uint32 nrows)",
          "fn_dec_pos": [
            [
              361,
              16
            ],
            [
              361,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFVStripSize",
            "parameters": {
              "tif": "TIFF",
              "nrows": "uint32"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFTileRowSize64(TIFF* tif)",
          "fn_dec_pos": [
            [
              362,
              14
            ],
            [
              362,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFTileRowSize64",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "TIFFTileRowSize(TIFF* tif)",
          "fn_dec_pos": [
            [
              363,
              16
            ],
            [
              363,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFTileRowSize",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFTileSize64(TIFF* tif)",
          "fn_dec_pos": [
            [
              364,
              14
            ],
            [
              364,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFTileSize64",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "TIFFTileSize(TIFF* tif)",
          "fn_dec_pos": [
            [
              365,
              16
            ],
            [
              365,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFTileSize",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFVTileSize64(TIFF* tif, uint32 nrows)",
          "fn_dec_pos": [
            [
              366,
              14
            ],
            [
              366,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFVTileSize64",
            "parameters": {
              "tif": "TIFF",
              "nrows": "uint32"
            },
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "TIFFVTileSize(TIFF* tif, uint32 nrows)",
          "fn_dec_pos": [
            [
              367,
              16
            ],
            [
              367,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFVTileSize",
            "parameters": {
              "tif": "TIFF",
              "nrows": "uint32"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFDefaultStripSize(TIFF* tif, uint32 request)",
          "fn_dec_pos": [
            [
              368,
              14
            ],
            [
              368,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFDefaultStripSize",
            "parameters": {
              "tif": "TIFF",
              "request": "uint32"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "TIFFDefaultTileSize(TIFF*, uint32*, uint32*)",
          "fn_dec_pos": [
            [
              369,
              12
            ],
            [
              369,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFDefaultTileSize",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFFileno(TIFF*)",
          "fn_dec_pos": [
            [
              370,
              11
            ],
            [
              370,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFileno",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFSetFileno(TIFF*, int)",
          "fn_dec_pos": [
            [
              371,
              11
            ],
            [
              371,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetFileno",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFClientdata(TIFF*)",
          "fn_dec_pos": [
            [
              372,
              17
            ],
            [
              372,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFClientdata",
            "parameters": {},
            "return_type": "thandle_t"
          }
        },
        {
          "fn_code": "TIFFSetClientdata(TIFF*, thandle_t)",
          "fn_dec_pos": [
            [
              373,
              17
            ],
            [
              373,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetClientdata",
            "parameters": {},
            "return_type": "thandle_t"
          }
        },
        {
          "fn_code": "TIFFGetMode(TIFF*)",
          "fn_dec_pos": [
            [
              374,
              11
            ],
            [
              374,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetMode",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFSetMode(TIFF*, int)",
          "fn_dec_pos": [
            [
              375,
              11
            ],
            [
              375,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetMode",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFIsTiled(TIFF*)",
          "fn_dec_pos": [
            [
              376,
              11
            ],
            [
              376,
              29
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFIsTiled",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFIsByteSwapped(TIFF*)",
          "fn_dec_pos": [
            [
              377,
              11
            ],
            [
              377,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFIsByteSwapped",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFIsUpSampled(TIFF*)",
          "fn_dec_pos": [
            [
              378,
              11
            ],
            [
              378,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFIsUpSampled",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFIsMSB2LSB(TIFF*)",
          "fn_dec_pos": [
            [
              379,
              11
            ],
            [
              379,
              31
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFIsMSB2LSB",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFIsBigEndian(TIFF*)",
          "fn_dec_pos": [
            [
              380,
              11
            ],
            [
              380,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFIsBigEndian",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFGetReadProc(TIFF*)",
          "fn_dec_pos": [
            [
              381,
              25
            ],
            [
              381,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetReadProc",
            "parameters": {},
            "return_type": "TIFFReadWriteProc"
          }
        },
        {
          "fn_code": "TIFFGetWriteProc(TIFF*)",
          "fn_dec_pos": [
            [
              382,
              25
            ],
            [
              382,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetWriteProc",
            "parameters": {},
            "return_type": "TIFFReadWriteProc"
          }
        },
        {
          "fn_code": "TIFFGetSeekProc(TIFF*)",
          "fn_dec_pos": [
            [
              383,
              20
            ],
            [
              383,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetSeekProc",
            "parameters": {},
            "return_type": "TIFFSeekProc"
          }
        },
        {
          "fn_code": "TIFFGetCloseProc(TIFF*)",
          "fn_dec_pos": [
            [
              384,
              21
            ],
            [
              384,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetCloseProc",
            "parameters": {},
            "return_type": "TIFFCloseProc"
          }
        },
        {
          "fn_code": "TIFFGetSizeProc(TIFF*)",
          "fn_dec_pos": [
            [
              385,
              20
            ],
            [
              385,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetSizeProc",
            "parameters": {},
            "return_type": "TIFFSizeProc"
          }
        },
        {
          "fn_code": "TIFFGetMapFileProc(TIFF*)",
          "fn_dec_pos": [
            [
              386,
              23
            ],
            [
              386,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetMapFileProc",
            "parameters": {},
            "return_type": "TIFFMapFileProc"
          }
        },
        {
          "fn_code": "TIFFGetUnmapFileProc(TIFF*)",
          "fn_dec_pos": [
            [
              387,
              25
            ],
            [
              387,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetUnmapFileProc",
            "parameters": {},
            "return_type": "TIFFUnmapFileProc"
          }
        },
        {
          "fn_code": "TIFFCurrentRow(TIFF*)",
          "fn_dec_pos": [
            [
              388,
              14
            ],
            [
              388,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCurrentRow",
            "parameters": {},
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "TIFFCurrentDirectory(TIFF*)",
          "fn_dec_pos": [
            [
              389,
              14
            ],
            [
              389,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCurrentDirectory",
            "parameters": {},
            "return_type": "uint16"
          }
        },
        {
          "fn_code": "TIFFNumberOfDirectories(TIFF*)",
          "fn_dec_pos": [
            [
              390,
              14
            ],
            [
              390,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFNumberOfDirectories",
            "parameters": {},
            "return_type": "uint16"
          }
        },
        {
          "fn_code": "TIFFCurrentDirOffset(TIFF*)",
          "fn_dec_pos": [
            [
              391,
              14
            ],
            [
              391,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCurrentDirOffset",
            "parameters": {},
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "TIFFCurrentStrip(TIFF*)",
          "fn_dec_pos": [
            [
              392,
              14
            ],
            [
              392,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCurrentStrip",
            "parameters": {},
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "TIFFCurrentTile(TIFF* tif)",
          "fn_dec_pos": [
            [
              393,
              14
            ],
            [
              393,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCurrentTile",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "TIFFReadBufferSetup(TIFF* tif, void* bp, tmsize_t size)",
          "fn_dec_pos": [
            [
              394,
              11
            ],
            [
              394,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadBufferSetup",
            "parameters": {
              "tif": "TIFF",
              "bp": "void",
              "size": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteBufferSetup(TIFF* tif, void* bp, tmsize_t size)",
          "fn_dec_pos": [
            [
              395,
              11
            ],
            [
              395,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteBufferSetup",
            "parameters": {
              "tif": "TIFF",
              "bp": "void",
              "size": "tmsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFSetupStrips(TIFF *)",
          "fn_dec_pos": [
            [
              396,
              11
            ],
            [
              396,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetupStrips",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteCheck(TIFF*, int, const char *)",
          "fn_dec_pos": [
            [
              397,
              11
            ],
            [
              397,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteCheck",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFFreeDirectory(TIFF*)",
          "fn_dec_pos": [
            [
              398,
              12
            ],
            [
              398,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFreeDirectory",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFCreateDirectory(TIFF*)",
          "fn_dec_pos": [
            [
              399,
              11
            ],
            [
              399,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCreateDirectory",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFCreateCustomDirectory(TIFF*,const TIFFFieldArray*)",
          "fn_dec_pos": [
            [
              400,
              11
            ],
            [
              400,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCreateCustomDirectory",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFCreateEXIFDirectory(TIFF*)",
          "fn_dec_pos": [
            [
              401,
              11
            ],
            [
              401,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCreateEXIFDirectory",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFLastDirectory(TIFF*)",
          "fn_dec_pos": [
            [
              402,
              11
            ],
            [
              402,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFLastDirectory",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFSetDirectory(TIFF*, uint16)",
          "fn_dec_pos": [
            [
              403,
              11
            ],
            [
              403,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetDirectory",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFSetSubDirectory(TIFF*, uint64)",
          "fn_dec_pos": [
            [
              404,
              11
            ],
            [
              404,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetSubDirectory",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFUnlinkDirectory(TIFF*, uint16)",
          "fn_dec_pos": [
            [
              405,
              11
            ],
            [
              405,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFUnlinkDirectory",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFSetField(TIFF*, uint32, ...)",
          "fn_dec_pos": [
            [
              406,
              11
            ],
            [
              406,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetField",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFVSetField(TIFF*, uint32, va_list)",
          "fn_dec_pos": [
            [
              407,
              11
            ],
            [
              407,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFVSetField",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFUnsetField(TIFF*, uint32)",
          "fn_dec_pos": [
            [
              408,
              11
            ],
            [
              408,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFUnsetField",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteDirectory(TIFF *)",
          "fn_dec_pos": [
            [
              409,
              11
            ],
            [
              409,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteDirectory",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteCustomDirectory(TIFF *, uint64 *)",
          "fn_dec_pos": [
            [
              410,
              11
            ],
            [
              410,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteCustomDirectory",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFCheckpointDirectory(TIFF *)",
          "fn_dec_pos": [
            [
              411,
              11
            ],
            [
              411,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCheckpointDirectory",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFRewriteDirectory(TIFF *)",
          "fn_dec_pos": [
            [
              412,
              11
            ],
            [
              412,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRewriteDirectory",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFPrintDirectory(TIFF*, FILE*, long = 0)",
          "fn_dec_pos": [
            [
              415,
              12
            ],
            [
              415,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFPrintDirectory",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFReadScanline(TIFF* tif, void* buf, uint32 row, uint16 sample = 0)",
          "fn_dec_pos": [
            [
              416,
              11
            ],
            [
              416,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadScanline",
            "parameters": {
              "tif": "TIFF",
              "buf": "void",
              "row": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteScanline(TIFF* tif, void* buf, uint32 row, uint16 sample = 0)",
          "fn_dec_pos": [
            [
              417,
              11
            ],
            [
              417,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteScanline",
            "parameters": {
              "tif": "TIFF",
              "buf": "void",
              "row": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFReadRGBAImage(TIFF*, uint32, uint32, uint32*, int = 0)",
          "fn_dec_pos": [
            [
              418,
              11
            ],
            [
              418,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRGBAImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFReadRGBAImageOriented(TIFF*, uint32, uint32, uint32*,\n    int = ORIENTATION_BOTLEFT, int = 0)",
          "fn_dec_pos": [
            [
              419,
              11
            ],
            [
              420,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRGBAImageOriented",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFPrintDirectory(TIFF*, FILE*, long)",
          "fn_dec_pos": [
            [
              422,
              12
            ],
            [
              422,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFPrintDirectory",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFReadScanline(TIFF* tif, void* buf, uint32 row, uint16 sample)",
          "fn_dec_pos": [
            [
              423,
              11
            ],
            [
              423,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadScanline",
            "parameters": {
              "tif": "TIFF",
              "buf": "void",
              "row": "uint32",
              "sample": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFWriteScanline(TIFF* tif, void* buf, uint32 row, uint16 sample)",
          "fn_dec_pos": [
            [
              424,
              11
            ],
            [
              424,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteScanline",
            "parameters": {
              "tif": "TIFF",
              "buf": "void",
              "row": "uint32",
              "sample": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFReadRGBAImage(TIFF*, uint32, uint32, uint32*, int)",
          "fn_dec_pos": [
            [
              425,
              11
            ],
            [
              425,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRGBAImage",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFReadRGBAImageOriented(TIFF*, uint32, uint32, uint32*, int, int)",
          "fn_dec_pos": [
            [
              426,
              11
            ],
            [
              426,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRGBAImageOriented",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFReadRGBAStrip(TIFF*, uint32, uint32 * )",
          "fn_dec_pos": [
            [
              429,
              11
            ],
            [
              429,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRGBAStrip",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFReadRGBATile(TIFF*, uint32, uint32, uint32 * )",
          "fn_dec_pos": [
            [
              430,
              11
            ],
            [
              430,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRGBATile",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFReadRGBAStripExt(TIFF*, uint32, uint32 *, int stop_on_error )",
          "fn_dec_pos": [
            [
              431,
              11
            ],
            [
              431,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRGBAStripExt",
            "parameters": {
              "stop_on_error": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFReadRGBATileExt(TIFF*, uint32, uint32, uint32 *, int stop_on_error )",
          "fn_dec_pos": [
            [
              432,
              11
            ],
            [
              432,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRGBATileExt",
            "parameters": {
              "stop_on_error": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFRGBAImageOK(TIFF*, char [1024])",
          "fn_dec_pos": [
            [
              433,
              11
            ],
            [
              433,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRGBAImageOK",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFRGBAImageBegin(TIFFRGBAImage*, TIFF*, int, char [1024])",
          "fn_dec_pos": [
            [
              434,
              11
            ],
            [
              434,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRGBAImageBegin",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFRGBAImageGet(TIFFRGBAImage*, uint32*, uint32, uint32)",
          "fn_dec_pos": [
            [
              435,
              11
            ],
            [
              435,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRGBAImageGet",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFRGBAImageEnd(TIFFRGBAImage*)",
          "fn_dec_pos": [
            [
              436,
              12
            ],
            [
              436,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFRGBAImageEnd",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFOpen(const char*, const char*)",
          "fn_dec_pos": [
            [
              437,
              13
            ],
            [
              437,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFOpen",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFOpenW(const wchar_t*, const char*)",
          "fn_dec_pos": [
            [
              439,
              13
            ],
            [
              439,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFOpenW",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFFdOpen(int, const char*, const char*)",
          "fn_dec_pos": [
            [
              441,
              13
            ],
            [
              441,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFdOpen",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFClientOpen(const char*, const char*,\n\t    thandle_t,\n\t    TIFFReadWriteProc, TIFFReadWriteProc,\n\t    TIFFSeekProc, TIFFCloseProc,\n\t    TIFFSizeProc,\n\t    TIFFMapFileProc, TIFFUnmapFileProc)",
          "fn_dec_pos": [
            [
              442,
              13
            ],
            [
              447,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFClientOpen",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFFileName(TIFF*)",
          "fn_dec_pos": [
            [
              448,
              19
            ],
            [
              448,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFileName",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFSetFileName(TIFF*, const char *)",
          "fn_dec_pos": [
            [
              449,
              19
            ],
            [
              449,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetFileName",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFError(const char*, const char*, ...) __attribute__((__format__ (__printf__,2,3)))",
          "fn_dec_pos": [
            [
              450,
              12
            ],
            [
              450,
              97
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFError",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFErrorExt(thandle_t, const char*, const char*, ...) __attribute__((__format__ (__printf__,3,4)))",
          "fn_dec_pos": [
            [
              451,
              12
            ],
            [
              451,
              111
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFErrorExt",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFWarning(const char*, const char*, ...) __attribute__((__format__ (__printf__,2,3)))",
          "fn_dec_pos": [
            [
              452,
              12
            ],
            [
              452,
              99
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWarning",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFWarningExt(thandle_t, const char*, const char*, ...) __attribute__((__format__ (__printf__,3,4)))",
          "fn_dec_pos": [
            [
              453,
              12
            ],
            [
              453,
              113
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWarningExt",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFSetErrorHandler(TIFFErrorHandler)",
          "fn_dec_pos": [
            [
              454,
              24
            ],
            [
              454,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetErrorHandler",
            "parameters": {},
            "return_type": "TIFFErrorHandler"
          }
        },
        {
          "fn_code": "TIFFSetErrorHandlerExt(TIFFErrorHandlerExt)",
          "fn_dec_pos": [
            [
              455,
              27
            ],
            [
              455,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetErrorHandlerExt",
            "parameters": {},
            "return_type": "TIFFErrorHandlerExt"
          }
        },
        {
          "fn_code": "TIFFSetWarningHandler(TIFFErrorHandler)",
          "fn_dec_pos": [
            [
              456,
              24
            ],
            [
              456,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetWarningHandler",
            "parameters": {},
            "return_type": "TIFFErrorHandler"
          }
        },
        {
          "fn_code": "TIFFSetWarningHandlerExt(TIFFErrorHandlerExt)",
          "fn_dec_pos": [
            [
              457,
              27
            ],
            [
              457,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetWarningHandlerExt",
            "parameters": {},
            "return_type": "TIFFErrorHandlerExt"
          }
        },
        {
          "fn_code": "TIFFSetTagExtender(TIFFExtendProc)",
          "fn_dec_pos": [
            [
              458,
              22
            ],
            [
              458,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetTagExtender",
            "parameters": {},
            "return_type": "TIFFExtendProc"
          }
        },
        {
          "fn_code": "TIFFComputeTile(TIFF* tif, uint32 x, uint32 y, uint32 z, uint16 s)",
          "fn_dec_pos": [
            [
              459,
              14
            ],
            [
              459,
              80
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFComputeTile",
            "parameters": {
              "tif": "TIFF",
              "x": "uint32",
              "y": "uint32",
              "z": "uint32",
              "s": "uint16"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "TIFFCheckTile(TIFF* tif, uint32 x, uint32 y, uint32 z, uint16 s)",
          "fn_dec_pos": [
            [
              460,
              11
            ],
            [
              460,
              75
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCheckTile",
            "parameters": {
              "tif": "TIFF",
              "x": "uint32",
              "y": "uint32",
              "z": "uint32",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFNumberOfTiles(TIFF*)",
          "fn_dec_pos": [
            [
              461,
              14
            ],
            [
              461,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFNumberOfTiles",
            "parameters": {},
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "TIFFReadTile(TIFF* tif, void* buf, uint32 x, uint32 y, uint32 z, uint16 s)",
          "fn_dec_pos": [
            [
              462,
              16
            ],
            [
              462,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadTile",
            "parameters": {
              "tif": "TIFF",
              "buf": "void",
              "x": "uint32",
              "y": "uint32",
              "z": "uint32",
              "s": "uint16"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFWriteTile(TIFF* tif, void* buf, uint32 x, uint32 y, uint32 z, uint16 s)",
          "fn_dec_pos": [
            [
              463,
              16
            ],
            [
              463,
              91
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteTile",
            "parameters": {
              "tif": "TIFF",
              "buf": "void",
              "x": "uint32",
              "y": "uint32",
              "z": "uint32",
              "s": "uint16"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFComputeStrip(TIFF*, uint32, uint16)",
          "fn_dec_pos": [
            [
              464,
              14
            ],
            [
              464,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFComputeStrip",
            "parameters": {},
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "TIFFNumberOfStrips(TIFF*)",
          "fn_dec_pos": [
            [
              465,
              14
            ],
            [
              465,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFNumberOfStrips",
            "parameters": {},
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)",
          "fn_dec_pos": [
            [
              466,
              16
            ],
            [
              466,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadEncodedStrip",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32",
              "buf": "void",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFReadRawStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)",
          "fn_dec_pos": [
            [
              467,
              16
            ],
            [
              467,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRawStrip",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32",
              "buf": "void",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFReadEncodedTile(TIFF* tif, uint32 tile, void* buf, tmsize_t size)",
          "fn_dec_pos": [
            [
              468,
              16
            ],
            [
              468,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadEncodedTile",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32",
              "buf": "void",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFReadRawTile(TIFF* tif, uint32 tile, void* buf, tmsize_t size)",
          "fn_dec_pos": [
            [
              469,
              16
            ],
            [
              469,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReadRawTile",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32",
              "buf": "void",
              "size": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFWriteEncodedStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)",
          "fn_dec_pos": [
            [
              470,
              16
            ],
            [
              470,
              87
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteEncodedStrip",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32",
              "data": "void",
              "cc": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFWriteRawStrip(TIFF* tif, uint32 strip, void* data, tmsize_t cc)",
          "fn_dec_pos": [
            [
              471,
              16
            ],
            [
              471,
              83
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteRawStrip",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32",
              "data": "void",
              "cc": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFWriteEncodedTile(TIFF* tif, uint32 tile, void* data, tmsize_t cc)",
          "fn_dec_pos": [
            [
              472,
              16
            ],
            [
              472,
              85
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteEncodedTile",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32",
              "data": "void",
              "cc": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFWriteRawTile(TIFF* tif, uint32 tile, void* data, tmsize_t cc)",
          "fn_dec_pos": [
            [
              473,
              16
            ],
            [
              473,
              81
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFWriteRawTile",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32",
              "data": "void",
              "cc": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "TIFFDataWidth(TIFFDataType)",
          "fn_dec_pos": [
            [
              474,
              11
            ],
            [
              474,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFDataWidth",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFSetWriteOffset(TIFF* tif, toff_t off)",
          "fn_dec_pos": [
            [
              475,
              12
            ],
            [
              475,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetWriteOffset",
            "parameters": {
              "tif": "TIFF",
              "off": "toff_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFSwabShort(uint16*)",
          "fn_dec_pos": [
            [
              476,
              12
            ],
            [
              476,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabShort",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFSwabLong(uint32*)",
          "fn_dec_pos": [
            [
              477,
              12
            ],
            [
              477,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabLong",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFSwabLong8(uint64*)",
          "fn_dec_pos": [
            [
              478,
              12
            ],
            [
              478,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabLong8",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFSwabFloat(float*)",
          "fn_dec_pos": [
            [
              479,
              12
            ],
            [
              479,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabFloat",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFSwabDouble(double*)",
          "fn_dec_pos": [
            [
              480,
              12
            ],
            [
              480,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabDouble",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFSwabArrayOfShort(uint16* wp, tmsize_t n)",
          "fn_dec_pos": [
            [
              481,
              12
            ],
            [
              481,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabArrayOfShort",
            "parameters": {
              "wp": "uint16",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFSwabArrayOfTriples(uint8* tp, tmsize_t n)",
          "fn_dec_pos": [
            [
              482,
              12
            ],
            [
              482,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabArrayOfTriples",
            "parameters": {
              "tp": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFSwabArrayOfLong(uint32* lp, tmsize_t n)",
          "fn_dec_pos": [
            [
              483,
              12
            ],
            [
              483,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabArrayOfLong",
            "parameters": {
              "lp": "uint32",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFSwabArrayOfLong8(uint64* lp, tmsize_t n)",
          "fn_dec_pos": [
            [
              484,
              12
            ],
            [
              484,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabArrayOfLong8",
            "parameters": {
              "lp": "uint64",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFSwabArrayOfFloat(float* fp, tmsize_t n)",
          "fn_dec_pos": [
            [
              485,
              12
            ],
            [
              485,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabArrayOfFloat",
            "parameters": {
              "fp": "float",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFSwabArrayOfDouble(double* dp, tmsize_t n)",
          "fn_dec_pos": [
            [
              486,
              12
            ],
            [
              486,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSwabArrayOfDouble",
            "parameters": {
              "dp": "double",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFReverseBits(uint8* cp, tmsize_t n)",
          "fn_dec_pos": [
            [
              487,
              12
            ],
            [
              487,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFReverseBits",
            "parameters": {
              "cp": "uint8",
              "n": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFGetBitRevTable(int)",
          "fn_dec_pos": [
            [
              488,
              28
            ],
            [
              488,
              51
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetBitRevTable",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "LogL16toY(int)",
          "fn_dec_pos": [
            [
              494,
              14
            ],
            [
              494,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogL16toY",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "LogL10toY(int)",
          "fn_dec_pos": [
            [
              495,
              14
            ],
            [
              495,
              28
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogL10toY",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "XYZtoRGB24(float*, uint8*)",
          "fn_dec_pos": [
            [
              496,
              12
            ],
            [
              496,
              38
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XYZtoRGB24",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "uv_decode(double*, double*, int)",
          "fn_dec_pos": [
            [
              497,
              11
            ],
            [
              497,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "uv_decode",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "LogLuv24toXYZ(uint32, float*)",
          "fn_dec_pos": [
            [
              498,
              12
            ],
            [
              498,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuv24toXYZ",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "LogLuv32toXYZ(uint32, float*)",
          "fn_dec_pos": [
            [
              499,
              12
            ],
            [
              499,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuv32toXYZ",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "LogL16fromY(double, int = SGILOGENCODE_NODITHER)",
          "fn_dec_pos": [
            [
              501,
              11
            ],
            [
              501,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogL16fromY",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "LogL10fromY(double, int = SGILOGENCODE_NODITHER)",
          "fn_dec_pos": [
            [
              502,
              11
            ],
            [
              502,
              59
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogL10fromY",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "uv_encode(double, double, int = SGILOGENCODE_NODITHER)",
          "fn_dec_pos": [
            [
              503,
              11
            ],
            [
              503,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "uv_encode",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "LogLuv24fromXYZ(float*, int = SGILOGENCODE_NODITHER)",
          "fn_dec_pos": [
            [
              504,
              14
            ],
            [
              504,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuv24fromXYZ",
            "parameters": {},
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "LogLuv32fromXYZ(float*, int = SGILOGENCODE_NODITHER)",
          "fn_dec_pos": [
            [
              505,
              14
            ],
            [
              505,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuv32fromXYZ",
            "parameters": {},
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "LogL16fromY(double, int)",
          "fn_dec_pos": [
            [
              507,
              11
            ],
            [
              507,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogL16fromY",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "LogL10fromY(double, int)",
          "fn_dec_pos": [
            [
              508,
              11
            ],
            [
              508,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogL10fromY",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "uv_encode(double, double, int)",
          "fn_dec_pos": [
            [
              509,
              11
            ],
            [
              509,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "uv_encode",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "LogLuv24fromXYZ(float*, int)",
          "fn_dec_pos": [
            [
              510,
              14
            ],
            [
              510,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuv24fromXYZ",
            "parameters": {},
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "LogLuv32fromXYZ(float*, int)",
          "fn_dec_pos": [
            [
              511,
              14
            ],
            [
              511,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "LogLuv32fromXYZ",
            "parameters": {},
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "TIFFCIELabToRGBInit(TIFFCIELabToRGB*, const TIFFDisplay *, float*)",
          "fn_dec_pos": [
            [
              515,
              11
            ],
            [
              515,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCIELabToRGBInit",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFCIELabToXYZ(TIFFCIELabToRGB *, uint32, int32, int32,\n    float *, float *, float *)",
          "fn_dec_pos": [
            [
              516,
              12
            ],
            [
              517,
              30
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCIELabToXYZ",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFXYZToRGB(TIFFCIELabToRGB *, float, float, float,\n    uint32 *, uint32 *, uint32 *)",
          "fn_dec_pos": [
            [
              518,
              12
            ],
            [
              519,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFXYZToRGB",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFYCbCrToRGBInit(TIFFYCbCrToRGB*, float*, float*)",
          "fn_dec_pos": [
            [
              521,
              11
            ],
            [
              521,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFYCbCrToRGBInit",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFYCbCrtoRGB(TIFFYCbCrToRGB *, uint32, int32, int32,\n    uint32 *, uint32 *, uint32 *)",
          "fn_dec_pos": [
            [
              522,
              12
            ],
            [
              523,
              33
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFYCbCrtoRGB",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFMergeFieldInfo(TIFF*, const TIFFFieldInfo[], uint32)",
          "fn_dec_pos": [
            [
              542,
              11
            ],
            [
              542,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFMergeFieldInfo",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\tfloat d_mat[3][3];                        /* XYZ -> luminance matrix */\n\tfloat d_YCR;                              /* Light o/p for reference white */\n\tfloat d_YCG;\n\tfloat d_YCB;\n\tuint32 d_Vrwr;                            /* Pixel values for ref. white */\n\tuint32 d_Vrwg;\n\tuint32 d_Vrwb;\n\tfloat d_Y0R;                              /* Residual light for black pixel */\n\tfloat d_Y0G;\n\tfloat d_Y0B;\n\tfloat d_gammaR;                           /* Gamma values for the three guns */\n\tfloat d_gammaG;\n\tfloat d_gammaB;\n} TIFFDisplay;",
          {
            "d_mat[3][3]": "float",
            "d_YCR": "float",
            "d_YCG": "float",
            "d_YCB": "float",
            "d_Vrwr": "uint32",
            "d_Vrwg": "uint32",
            "d_Vrwb": "uint32",
            "d_Y0R": "float",
            "d_Y0G": "float",
            "d_Y0B": "float",
            "d_gammaR": "float",
            "d_gammaG": "float",
            "d_gammaB": "float"
          },
          "TIFFDisplay",
          [
            137,
            0
          ],
          [
            151,
            14
          ]
        ],
        [
          "typedef struct {                                  /* YCbCr->RGB support */\n\tTIFFRGBValue* clamptab;                   /* range clamping table */\n\tint* Cr_r_tab;\n\tint* Cb_b_tab;\n\tint32* Cr_g_tab;\n\tint32* Cb_g_tab;\n\tint32* Y_tab;\n} TIFFYCbCrToRGB;",
          {
            "* clamptab": "TIFFRGBValue",
            "* Cr_r_tab": "int",
            "* Cb_b_tab": "int",
            "* Cr_g_tab": "int32",
            "* Cb_g_tab": "int32",
            "* Y_tab": "int32"
          },
          "TIFFYCbCrToRGB",
          [
            153,
            0
          ],
          [
            160,
            17
          ]
        ],
        [
          "typedef struct {                                  /* CIE Lab 1976->RGB support */\n\tint range;                                /* Size of conversion table */\n#define CIELABTORGB_TABLE_RANGE 1500\n\tfloat rstep, gstep, bstep;\n\tfloat X0, Y0, Z0;                         /* Reference white point */\n\tTIFFDisplay display;\n\tfloat Yr2r[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yr to r */\n\tfloat Yg2g[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yg to g */\n\tfloat Yb2b[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yb to b */\n} TIFFCIELabToRGB;",
          {
            "range": "int",
            "rstep": "float",
            "X0": "float",
            "display": "TIFFDisplay",
            "Yr2r[CIELABTORGB_TABLE_RANGE + 1]": "float",
            "Yg2g[CIELABTORGB_TABLE_RANGE + 1]": "float",
            "Yb2b[CIELABTORGB_TABLE_RANGE + 1]": "float"
          },
          "TIFFCIELabToRGB",
          [
            162,
            0
          ],
          [
            171,
            18
          ]
        ],
        [
          "struct _TIFFRGBAImage {\n\tTIFF* tif;                              /* image handle */\n\tint stoponerr;                          /* stop on read error */\n\tint isContig;                           /* data is packed/separate */\n\tint alpha;                              /* type of alpha data present */\n\tuint32 width;                           /* image width */\n\tuint32 height;                          /* image height */\n\tuint16 bitspersample;                   /* image bits/sample */\n\tuint16 samplesperpixel;                 /* image samples/pixel */\n\tuint16 orientation;                     /* image orientation */\n\tuint16 req_orientation;                 /* requested orientation */\n\tuint16 photometric;                     /* image photometric interp */\n\tuint16* redcmap;                        /* colormap palette */\n\tuint16* greencmap;\n\tuint16* bluecmap;\n\t/* get image data routine */\n\tint (*get)(TIFFRGBAImage*, uint32*, uint32, uint32);\n\t/* put decoded strip/tile */\n\tunion {\n\t    void (*any)(TIFFRGBAImage*);\n\t    tileContigRoutine contig;\n\t    tileSeparateRoutine separate;\n\t} put;\n\tTIFFRGBValue* Map;                      /* sample mapping array */\n\tuint32** BWmap;                         /* black&white map */\n\tuint32** PALmap;                        /* palette image map */\n\tTIFFYCbCrToRGB* ycbcr;                  /* YCbCr conversion state */\n\tTIFFCIELabToRGB* cielab;                /* CIE L*a*b conversion state */\n\n\tuint8* UaToAa;                          /* Unassociated alpha to associated alpha conversion LUT */\n\tuint8* Bitdepth16To8;                   /* LUT for conversion from 16bit to 8bit values */\n\n\tint row_offset;\n\tint col_offset;\n}",
          {
            "* tif": "TIFF",
            "stoponerr": "int",
            "isContig": "int",
            "alpha": "int",
            "width": "uint32",
            "height": "uint32",
            "bitspersample": "uint16",
            "samplesperpixel": "uint16",
            "orientation": "uint16",
            "req_orientation": "uint16",
            "photometric": "uint16",
            "* redcmap": "uint16",
            "* greencmap": "uint16",
            "* bluecmap": "uint16",
            "(*get)(TIFFRGBAImage*, uint32*, uint32, uint32)": "int",
            "put": "union {\n\t    void (*any)(TIFFRGBAImage*);\n\t    tileContigRoutine contig;\n\t    tileSeparateRoutine separate;\n\t}",
            "(*any)(TIFFRGBAImage*)": "void",
            "contig": "tileContigRoutine",
            "separate": "tileSeparateRoutine",
            "* Map": "TIFFRGBValue",
            "** BWmap": "uint32",
            "** PALmap": "uint32",
            "* ycbcr": "TIFFYCbCrToRGB",
            "* cielab": "TIFFCIELabToRGB",
            "* UaToAa": "uint8",
            "* Bitdepth16To8": "uint8",
            "row_offset": "int",
            "col_offset": "int"
          },
          "_TIFFRGBAImage",
          [
            196,
            0
          ],
          [
            230,
            1
          ]
        ],
        [
          "typedef struct {\n\tchar* name;\n\tuint16 scheme;\n\tTIFFInitMethod init;\n} TIFFCodec;",
          {
            "* name": "char",
            "scheme": "uint16",
            "init": "TIFFInitMethod"
          },
          "TIFFCodec",
          [
            249,
            0
          ],
          [
            253,
            12
          ]
        ],
        [
          "typedef struct {\n    TIFFVSetMethod vsetfield; /* tag set routine */\n    TIFFVGetMethod vgetfield; /* tag get routine */\n    TIFFPrintMethod printdir; /* directory print routine */\n} TIFFTagMethods;",
          {
            "vsetfield": "TIFFVSetMethod",
            "vgetfield": "TIFFVGetMethod",
            "printdir": "TIFFPrintMethod"
          },
          "TIFFTagMethods",
          [
            331,
            0
          ],
          [
            335,
            17
          ]
        ],
        [
          "typedef\tstruct {\n\tttag_t\tfield_tag;\t\t/* field's tag */\n\tshort\tfield_readcount;\t/* read count/TIFF_VARIABLE/TIFF_SPP */\n\tshort\tfield_writecount;\t/* write count/TIFF_VARIABLE */\n\tTIFFDataType field_type;\t/* type of associated data */\n        unsigned short field_bit;\t/* bit in fieldsset bit vector */\n\tunsigned char field_oktochange;\t/* if true, can change while writing */\n\tunsigned char field_passcount;\t/* if true, pass dir count on set */\n\tchar\t*field_name;\t\t/* ASCII name */\n} TIFFFieldInfo;",
          {
            "field_tag": "ttag_t",
            "field_readcount": "short",
            "field_writecount": "short",
            "field_type": "TIFFDataType",
            "field_bit": "unsigned short",
            "field_oktochange": "unsigned char",
            "field_passcount": "unsigned char",
            "*field_name": "char"
          },
          "TIFFFieldInfo",
          [
            531,
            0
          ],
          [
            540,
            16
          ]
        ],
        [
          "typedef struct tiff TIFF;",
          {},
          "TIFF",
          [
            37,
            0
          ],
          [
            37,
            25
          ]
        ],
        [
          "typedef struct {\n\tfloat d_mat[3][3];                        /* XYZ -> luminance matrix */\n\tfloat d_YCR;                              /* Light o/p for reference white */\n\tfloat d_YCG;\n\tfloat d_YCB;\n\tuint32 d_Vrwr;                            /* Pixel values for ref. white */\n\tuint32 d_Vrwg;\n\tuint32 d_Vrwb;\n\tfloat d_Y0R;                              /* Residual light for black pixel */\n\tfloat d_Y0G;\n\tfloat d_Y0B;\n\tfloat d_gammaR;                           /* Gamma values for the three guns */\n\tfloat d_gammaG;\n\tfloat d_gammaB;\n} TIFFDisplay;",
          {
            "d_mat[3][3]": "float",
            "d_YCR": "float",
            "d_YCG": "float",
            "d_YCB": "float",
            "d_Vrwr": "uint32",
            "d_Vrwg": "uint32",
            "d_Vrwb": "uint32",
            "d_Y0R": "float",
            "d_Y0G": "float",
            "d_Y0B": "float",
            "d_gammaR": "float",
            "d_gammaG": "float",
            "d_gammaB": "float"
          },
          "TIFFDisplay",
          [
            137,
            0
          ],
          [
            151,
            14
          ]
        ],
        [
          "typedef struct {                                  /* YCbCr->RGB support */\n\tTIFFRGBValue* clamptab;                   /* range clamping table */\n\tint* Cr_r_tab;\n\tint* Cb_b_tab;\n\tint32* Cr_g_tab;\n\tint32* Cb_g_tab;\n\tint32* Y_tab;\n} TIFFYCbCrToRGB;",
          {
            "* clamptab": "TIFFRGBValue",
            "* Cr_r_tab": "int",
            "* Cb_b_tab": "int",
            "* Cr_g_tab": "int32",
            "* Cb_g_tab": "int32",
            "* Y_tab": "int32"
          },
          "TIFFYCbCrToRGB",
          [
            153,
            0
          ],
          [
            160,
            17
          ]
        ],
        [
          "typedef struct {                                  /* CIE Lab 1976->RGB support */\n\tint range;                                /* Size of conversion table */\n#define CIELABTORGB_TABLE_RANGE 1500\n\tfloat rstep, gstep, bstep;\n\tfloat X0, Y0, Z0;                         /* Reference white point */\n\tTIFFDisplay display;\n\tfloat Yr2r[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yr to r */\n\tfloat Yg2g[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yg to g */\n\tfloat Yb2b[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yb to b */\n} TIFFCIELabToRGB;",
          {
            "range": "int",
            "rstep": "float",
            "X0": "float",
            "display": "TIFFDisplay",
            "Yr2r[CIELABTORGB_TABLE_RANGE + 1]": "float",
            "Yg2g[CIELABTORGB_TABLE_RANGE + 1]": "float",
            "Yb2b[CIELABTORGB_TABLE_RANGE + 1]": "float"
          },
          "TIFFCIELabToRGB",
          [
            162,
            0
          ],
          [
            171,
            18
          ]
        ],
        [
          "typedef struct _TIFFRGBAImage TIFFRGBAImage;",
          {},
          "TIFFRGBAImage",
          [
            176,
            0
          ],
          [
            176,
            44
          ]
        ],
        [
          "struct _TIFFRGBAImage {\n\tTIFF* tif;                              /* image handle */\n\tint stoponerr;                          /* stop on read error */\n\tint isContig;                           /* data is packed/separate */\n\tint alpha;                              /* type of alpha data present */\n\tuint32 width;                           /* image width */\n\tuint32 height;                          /* image height */\n\tuint16 bitspersample;                   /* image bits/sample */\n\tuint16 samplesperpixel;                 /* image samples/pixel */\n\tuint16 orientation;                     /* image orientation */\n\tuint16 req_orientation;                 /* requested orientation */\n\tuint16 photometric;                     /* image photometric interp */\n\tuint16* redcmap;                        /* colormap palette */\n\tuint16* greencmap;\n\tuint16* bluecmap;\n\t/* get image data routine */\n\tint (*get)(TIFFRGBAImage*, uint32*, uint32, uint32);\n\t/* put decoded strip/tile */\n\tunion {\n\t    void (*any)(TIFFRGBAImage*);\n\t    tileContigRoutine contig;\n\t    tileSeparateRoutine separate;\n\t} put;\n\tTIFFRGBValue* Map;                      /* sample mapping array */\n\tuint32** BWmap;                         /* black&white map */\n\tuint32** PALmap;                        /* palette image map */\n\tTIFFYCbCrToRGB* ycbcr;                  /* YCbCr conversion state */\n\tTIFFCIELabToRGB* cielab;                /* CIE L*a*b conversion state */\n\n\tuint8* UaToAa;                          /* Unassociated alpha to associated alpha conversion LUT */\n\tuint8* Bitdepth16To8;                   /* LUT for conversion from 16bit to 8bit values */\n\n\tint row_offset;\n\tint col_offset;\n}",
          {
            "* tif": "TIFF",
            "stoponerr": "int",
            "isContig": "int",
            "alpha": "int",
            "width": "uint32",
            "height": "uint32",
            "bitspersample": "uint16",
            "samplesperpixel": "uint16",
            "orientation": "uint16",
            "req_orientation": "uint16",
            "photometric": "uint16",
            "* redcmap": "uint16",
            "* greencmap": "uint16",
            "* bluecmap": "uint16",
            "(*get)(TIFFRGBAImage*, uint32*, uint32, uint32)": "int",
            "put": "union {\n\t    void (*any)(TIFFRGBAImage*);\n\t    tileContigRoutine contig;\n\t    tileSeparateRoutine separate;\n\t}",
            "(*any)(TIFFRGBAImage*)": "void",
            "contig": "tileContigRoutine",
            "separate": "tileSeparateRoutine",
            "* Map": "TIFFRGBValue",
            "** BWmap": "uint32",
            "** PALmap": "uint32",
            "* ycbcr": "TIFFYCbCrToRGB",
            "* cielab": "TIFFCIELabToRGB",
            "* UaToAa": "uint8",
            "* Bitdepth16To8": "uint8",
            "row_offset": "int",
            "col_offset": "int"
          },
          "_TIFFRGBAImage",
          [
            196,
            0
          ],
          [
            230,
            1
          ]
        ],
        [
          "typedef struct {\n\tchar* name;\n\tuint16 scheme;\n\tTIFFInitMethod init;\n} TIFFCodec;",
          {
            "* name": "char",
            "scheme": "uint16",
            "init": "TIFFInitMethod"
          },
          "TIFFCodec",
          [
            249,
            0
          ],
          [
            253,
            12
          ]
        ],
        [
          "typedef struct _TIFFField TIFFField;",
          {},
          "TIFFField",
          [
            313,
            0
          ],
          [
            313,
            36
          ]
        ],
        [
          "typedef struct _TIFFFieldArray TIFFFieldArray;",
          {},
          "TIFFFieldArray",
          [
            314,
            0
          ],
          [
            314,
            46
          ]
        ],
        [
          "typedef struct {\n    TIFFVSetMethod vsetfield; /* tag set routine */\n    TIFFVGetMethod vgetfield; /* tag get routine */\n    TIFFPrintMethod printdir; /* directory print routine */\n} TIFFTagMethods;",
          {
            "vsetfield": "TIFFVSetMethod",
            "vgetfield": "TIFFVGetMethod",
            "printdir": "TIFFPrintMethod"
          },
          "TIFFTagMethods",
          [
            331,
            0
          ],
          [
            335,
            17
          ]
        ],
        [
          "typedef\tstruct {\n\tttag_t\tfield_tag;\t\t/* field's tag */\n\tshort\tfield_readcount;\t/* read count/TIFF_VARIABLE/TIFF_SPP */\n\tshort\tfield_writecount;\t/* write count/TIFF_VARIABLE */\n\tTIFFDataType field_type;\t/* type of associated data */\n        unsigned short field_bit;\t/* bit in fieldsset bit vector */\n\tunsigned char field_oktochange;\t/* if true, can change while writing */\n\tunsigned char field_passcount;\t/* if true, pass dir count on set */\n\tchar\t*field_name;\t\t/* ASCII name */\n} TIFFFieldInfo;",
          {
            "field_tag": "ttag_t",
            "field_readcount": "short",
            "field_writecount": "short",
            "field_type": "TIFFDataType",
            "field_bit": "unsigned short",
            "field_oktochange": "unsigned char",
            "field_passcount": "unsigned char",
            "*field_name": "char"
          },
          "TIFFFieldInfo",
          [
            531,
            0
          ],
          [
            540,
            16
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiff.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"tiffvers.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "# include <windows.h>\n",
          [
            96,
            0
          ],
          [
            97,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            255,
            0
          ],
          [
            256,
            0
          ]
        ],
        [
          "#include <stdarg.h>\n",
          [
            256,
            0
          ],
          [
            257,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tiffvers.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tiffiop.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "lfind(const void *, const void *, size_t *, size_t,\n\t\t   int (*)(const void *, const void *))",
          "fn_dec_pos": [
            [
              53,
              13
            ],
            [
              54,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lfind",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "snprintf(char* str, size_t size, const char* format, ...)",
          "fn_dec_pos": [
            [
              60,
              11
            ],
            [
              60,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "snprintf",
            "parameters": {
              "str": "char",
              "size": "size_t",
              "format": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*TIFFVoidMethod)(TIFF*)",
          "fn_dec_pos": [
            [
              92,
              13
            ],
            [
              92,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*TIFFBoolMethod)(TIFF*)",
          "fn_dec_pos": [
            [
              93,
              12
            ],
            [
              93,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*TIFFPreMethod)(TIFF*, uint16)",
          "fn_dec_pos": [
            [
              94,
              12
            ],
            [
              94,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*TIFFCodeMethod)(TIFF* tif, uint8* buf, tmsize_t size, uint16 sample)",
          "fn_dec_pos": [
            [
              95,
              12
            ],
            [
              95,
              82
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "size": "tmsize_t",
              "sample": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*TIFFSeekMethod)(TIFF*, uint32)",
          "fn_dec_pos": [
            [
              96,
              12
            ],
            [
              96,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*TIFFPostMethod)(TIFF* tif, uint8* buf, tmsize_t size)",
          "fn_dec_pos": [
            [
              97,
              13
            ],
            [
              97,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "size": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*TIFFStripMethod)(TIFF*, uint32)",
          "fn_dec_pos": [
            [
              98,
              15
            ],
            [
              98,
              48
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "(*TIFFTileMethod)(TIFF*, uint32*, uint32*)",
          "fn_dec_pos": [
            [
              99,
              13
            ],
            [
              99,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFgetMode(const char* mode, const char* module)",
          "fn_dec_pos": [
            [
              329,
              11
            ],
            [
              329,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFgetMode",
            "parameters": {
              "mode": "char",
              "module": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFNoRowEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              330,
              11
            ],
            [
              330,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoRowEncode",
            "parameters": {
              "tif": "TIFF",
              "pp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFNoStripEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              331,
              11
            ],
            [
              331,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoStripEncode",
            "parameters": {
              "tif": "TIFF",
              "pp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFNoTileEncode(TIFF*, uint8* pp, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              332,
              11
            ],
            [
              332,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoTileEncode",
            "parameters": {
              "pp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFNoRowDecode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              333,
              11
            ],
            [
              333,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoRowDecode",
            "parameters": {
              "tif": "TIFF",
              "pp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFNoStripDecode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              334,
              11
            ],
            [
              334,
              74
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoStripDecode",
            "parameters": {
              "tif": "TIFF",
              "pp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFNoTileDecode(TIFF*, uint8* pp, tmsize_t cc, uint16 s)",
          "fn_dec_pos": [
            [
              335,
              11
            ],
            [
              335,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoTileDecode",
            "parameters": {
              "pp": "uint8",
              "cc": "tmsize_t",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFNoPostDecode(TIFF* tif, uint8* buf, tmsize_t cc)",
          "fn_dec_pos": [
            [
              336,
              12
            ],
            [
              336,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoPostDecode",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFNoPreCode(TIFF* tif, uint16 s)",
          "fn_dec_pos": [
            [
              337,
              11
            ],
            [
              337,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoPreCode",
            "parameters": {
              "tif": "TIFF",
              "s": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFNoSeek(TIFF* tif, uint32 off)",
          "fn_dec_pos": [
            [
              338,
              11
            ],
            [
              338,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFNoSeek",
            "parameters": {
              "tif": "TIFF",
              "off": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFSwab16BitData(TIFF* tif, uint8* buf, tmsize_t cc)",
          "fn_dec_pos": [
            [
              339,
              12
            ],
            [
              339,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFSwab16BitData",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFSwab24BitData(TIFF* tif, uint8* buf, tmsize_t cc)",
          "fn_dec_pos": [
            [
              340,
              12
            ],
            [
              340,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFSwab24BitData",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFSwab32BitData(TIFF* tif, uint8* buf, tmsize_t cc)",
          "fn_dec_pos": [
            [
              341,
              12
            ],
            [
              341,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFSwab32BitData",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFSwab64BitData(TIFF* tif, uint8* buf, tmsize_t cc)",
          "fn_dec_pos": [
            [
              342,
              12
            ],
            [
              342,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFSwab64BitData",
            "parameters": {
              "tif": "TIFF",
              "buf": "uint8",
              "cc": "tmsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFFlushData1(TIFF* tif)",
          "fn_dec_pos": [
            [
              343,
              11
            ],
            [
              343,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFFlushData1",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFDefaultDirectory(TIFF* tif)",
          "fn_dec_pos": [
            [
              344,
              11
            ],
            [
              344,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFDefaultDirectory",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFSetDefaultCompressionState(TIFF* tif)",
          "fn_dec_pos": [
            [
              345,
              12
            ],
            [
              345,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFSetDefaultCompressionState",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFRewriteField(TIFF *, uint16, TIFFDataType, tmsize_t, void *)",
          "fn_dec_pos": [
            [
              346,
              11
            ],
            [
              346,
              76
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFRewriteField",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFSetCompressionScheme(TIFF* tif, int scheme)",
          "fn_dec_pos": [
            [
              347,
              11
            ],
            [
              347,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetCompressionScheme",
            "parameters": {
              "tif": "TIFF",
              "scheme": "int"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFSetDefaultCompressionState(TIFF* tif)",
          "fn_dec_pos": [
            [
              348,
              11
            ],
            [
              348,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFSetDefaultCompressionState",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFDefaultStripSize(TIFF* tif, uint32 s)",
          "fn_dec_pos": [
            [
              349,
              14
            ],
            [
              349,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFDefaultStripSize",
            "parameters": {
              "tif": "TIFF",
              "s": "uint32"
            },
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "_TIFFDefaultTileSize(TIFF* tif, uint32* tw, uint32* th)",
          "fn_dec_pos": [
            [
              350,
              12
            ],
            [
              350,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFDefaultTileSize",
            "parameters": {
              "tif": "TIFF",
              "tw": "uint32",
              "th": "uint32"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFDataSize(TIFFDataType type)",
          "fn_dec_pos": [
            [
              351,
              11
            ],
            [
              351,
              43
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFDataSize",
            "parameters": {
              "type": "TIFFDataType"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFsetByteArray(void**, void*, uint32)",
          "fn_dec_pos": [
            [
              353,
              12
            ],
            [
              353,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFsetByteArray",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFsetString(char**, char*)",
          "fn_dec_pos": [
            [
              354,
              12
            ],
            [
              354,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFsetString",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFsetShortArray(uint16**, uint16*, uint32)",
          "fn_dec_pos": [
            [
              355,
              12
            ],
            [
              355,
              57
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFsetShortArray",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFsetLongArray(uint32**, uint32*, uint32)",
          "fn_dec_pos": [
            [
              356,
              12
            ],
            [
              356,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFsetLongArray",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFsetFloatArray(float**, float*, uint32)",
          "fn_dec_pos": [
            [
              357,
              12
            ],
            [
              357,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFsetFloatArray",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFsetDoubleArray(double**, double*, uint32)",
          "fn_dec_pos": [
            [
              358,
              12
            ],
            [
              358,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFsetDoubleArray",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFprintAscii(FILE*, const char*)",
          "fn_dec_pos": [
            [
              360,
              12
            ],
            [
              360,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFprintAscii",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFprintAsciiTag(FILE*, const char*, const char*)",
          "fn_dec_pos": [
            [
              361,
              12
            ],
            [
              361,
              63
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFprintAsciiTag",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFMultiply32(TIFF*, uint32, uint32, const char*)",
          "fn_dec_pos": [
            [
              368,
              14
            ],
            [
              368,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFMultiply32",
            "parameters": {},
            "return_type": "uint32"
          }
        },
        {
          "fn_code": "_TIFFMultiply64(TIFF*, uint64, uint64, const char*)",
          "fn_dec_pos": [
            [
              369,
              14
            ],
            [
              369,
              65
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFMultiply64",
            "parameters": {},
            "return_type": "uint64"
          }
        },
        {
          "fn_code": "_TIFFCheckMalloc(TIFF*, tmsize_t, tmsize_t, const char*)",
          "fn_dec_pos": [
            [
              370,
              13
            ],
            [
              370,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFCheckMalloc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFCheckRealloc(TIFF*, void*, tmsize_t, tmsize_t, const char*)",
          "fn_dec_pos": [
            [
              371,
              13
            ],
            [
              371,
              77
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFCheckRealloc",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFUInt64ToDouble(uint64)",
          "fn_dec_pos": [
            [
              373,
              14
            ],
            [
              373,
              41
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFUInt64ToDouble",
            "parameters": {},
            "return_type": "double"
          }
        },
        {
          "fn_code": "_TIFFUInt64ToFloat(uint64)",
          "fn_dec_pos": [
            [
              374,
              13
            ],
            [
              374,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFUInt64ToFloat",
            "parameters": {},
            "return_type": "float"
          }
        },
        {
          "fn_code": "_TIFFClampDoubleToFloat(double)",
          "fn_dec_pos": [
            [
              376,
              13
            ],
            [
              376,
              44
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFClampDoubleToFloat",
            "parameters": {},
            "return_type": "float"
          }
        },
        {
          "fn_code": "_TIFFReadEncodedStripAndAllocBuffer(TIFF* tif, uint32 strip,\n                                    void **buf, tmsize_t bufsizetoalloc,\n                                    tmsize_t size_to_read)",
          "fn_dec_pos": [
            [
              379,
              0
            ],
            [
              381,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFReadEncodedStripAndAllocBuffer",
            "parameters": {
              "tif": "TIFF",
              "strip": "uint32",
              "buf": "void",
              "bufsizetoalloc": "tmsize_t",
              "size_to_read": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "_TIFFReadEncodedTileAndAllocBuffer(TIFF* tif, uint32 tile,\n                                    void **buf, tmsize_t bufsizetoalloc,\n                                    tmsize_t size_to_read)",
          "fn_dec_pos": [
            [
              383,
              0
            ],
            [
              385,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFReadEncodedTileAndAllocBuffer",
            "parameters": {
              "tif": "TIFF",
              "tile": "uint32",
              "buf": "void",
              "bufsizetoalloc": "tmsize_t",
              "size_to_read": "tmsize_t"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "_TIFFReadTileAndAllocBuffer(TIFF* tif,\n                            void **buf, tmsize_t bufsizetoalloc,\n                            uint32 x, uint32 y, uint32 z, uint16 s)",
          "fn_dec_pos": [
            [
              387,
              0
            ],
            [
              389,
              67
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFReadTileAndAllocBuffer",
            "parameters": {
              "tif": "TIFF",
              "buf": "void",
              "bufsizetoalloc": "tmsize_t",
              "x": "uint32",
              "y": "uint32",
              "z": "uint32",
              "s": "uint16"
            },
            "return_type": "tmsize_t"
          }
        },
        {
          "fn_code": "_TIFFSeekOK(TIFF* tif, toff_t off)",
          "fn_dec_pos": [
            [
              390,
              11
            ],
            [
              390,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFSeekOK",
            "parameters": {
              "tif": "TIFF",
              "off": "toff_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitDumpMode(TIFF*, int)",
          "fn_dec_pos": [
            [
              392,
              11
            ],
            [
              392,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitDumpMode",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitPackBits(TIFF*, int)",
          "fn_dec_pos": [
            [
              394,
              11
            ],
            [
              394,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitPackBits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitCCITTRLE(TIFF*, int)",
          "fn_dec_pos": [
            [
              397,
              11
            ],
            [
              397,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitCCITTRLEW",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitCCITTRLEW(TIFF*, int)",
          "fn_dec_pos": [
            [
              397,
              41
            ],
            [
              397,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitCCITTRLEW",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitCCITTFax3(TIFF*, int)",
          "fn_dec_pos": [
            [
              398,
              11
            ],
            [
              398,
              40
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitCCITTFax4",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitCCITTFax4(TIFF*, int)",
          "fn_dec_pos": [
            [
              398,
              42
            ],
            [
              398,
              71
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitCCITTFax4",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitThunderScan(TIFF*, int)",
          "fn_dec_pos": [
            [
              401,
              11
            ],
            [
              401,
              42
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitThunderScan",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitNeXT(TIFF*, int)",
          "fn_dec_pos": [
            [
              404,
              11
            ],
            [
              404,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitNeXT",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitLZW(TIFF*, int)",
          "fn_dec_pos": [
            [
              407,
              11
            ],
            [
              407,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitLZW",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitOJPEG(TIFF*, int)",
          "fn_dec_pos": [
            [
              410,
              11
            ],
            [
              410,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitOJPEG",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitJPEG(TIFF*, int)",
          "fn_dec_pos": [
            [
              413,
              11
            ],
            [
              413,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitJPEG",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFJPEGIsFullStripRequired(TIFF*)",
          "fn_dec_pos": [
            [
              414,
              11
            ],
            [
              414,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFJPEGIsFullStripRequired",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitJBIG(TIFF*, int)",
          "fn_dec_pos": [
            [
              417,
              11
            ],
            [
              417,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitJBIG",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitZIP(TIFF*, int)",
          "fn_dec_pos": [
            [
              420,
              11
            ],
            [
              420,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitZIP",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitPixarLog(TIFF*, int)",
          "fn_dec_pos": [
            [
              423,
              11
            ],
            [
              423,
              39
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitPixarLog",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitSGILog(TIFF*, int)",
          "fn_dec_pos": [
            [
              426,
              11
            ],
            [
              426,
              37
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitSGILog",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitLZMA(TIFF*, int)",
          "fn_dec_pos": [
            [
              429,
              11
            ],
            [
              429,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitLZMA",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitZSTD(TIFF*, int)",
          "fn_dec_pos": [
            [
              432,
              11
            ],
            [
              432,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitZSTD",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "TIFFInitWebP(TIFF*, int)",
          "fn_dec_pos": [
            [
              435,
              11
            ],
            [
              435,
              35
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFInitWebP",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct client_info {\n    struct client_info *next;\n    void *data;\n    char *name;\n} TIFFClientInfoLink;",
          {
            "*next": "struct client_info",
            "*data": "void",
            "*name": "char"
          },
          "TIFFClientInfoLink",
          [
            79,
            0
          ],
          [
            83,
            21
          ]
        ],
        [
          "struct tiff {\n\tchar*                tif_name;         /* name of open file */\n\tint                  tif_fd;           /* open file descriptor */\n\tint                  tif_mode;         /* open mode (O_*) */\n\tuint32               tif_flags;\n\t#define TIFF_FILLORDER   0x00003U /* natural bit fill order for machine */\n\t#define TIFF_DIRTYHEADER 0x00004U /* header must be written on close */\n\t#define TIFF_DIRTYDIRECT 0x00008U /* current directory must be written */\n\t#define TIFF_BUFFERSETUP 0x00010U /* data buffers setup */\n\t#define TIFF_CODERSETUP  0x00020U /* encoder/decoder setup done */\n\t#define TIFF_BEENWRITING 0x00040U /* written 1+ scanlines to file */\n\t#define TIFF_SWAB        0x00080U /* byte swap file information */\n\t#define TIFF_NOBITREV    0x00100U /* inhibit bit reversal logic */\n\t#define TIFF_MYBUFFER    0x00200U /* my raw data buffer; free on close */\n\t#define TIFF_ISTILED     0x00400U /* file is tile, not strip- based */\n\t#define TIFF_MAPPED      0x00800U /* file is mapped into memory */\n\t#define TIFF_POSTENCODE  0x01000U /* need call to postencode routine */\n\t#define TIFF_INSUBIFD    0x02000U /* currently writing a subifd */\n\t#define TIFF_UPSAMPLED   0x04000U /* library is doing data up-sampling */\n\t#define TIFF_STRIPCHOP   0x08000U /* enable strip chopping support */\n\t#define TIFF_HEADERONLY  0x10000U /* read header only, do not process the first directory */\n\t#define TIFF_NOREADRAW   0x20000U /* skip reading of raw uncompressed image data */\n\t#define TIFF_INCUSTOMIFD 0x40000U /* currently writing a custom IFD */\n\t#define TIFF_BIGTIFF     0x80000U /* read/write bigtiff */\n        #define TIFF_BUF4WRITE  0x100000U /* rawcc bytes are for writing */\n        #define TIFF_DIRTYSTRIP 0x200000U /* stripoffsets/stripbytecount dirty*/\n        #define TIFF_PERSAMPLE  0x400000U /* get/set per sample tags as arrays */\n        #define TIFF_BUFFERMMAP 0x800000U /* read buffer (tif_rawdata) points into mmap() memory */\n\tuint64               tif_diroff;       /* file offset of current directory */\n\tuint64               tif_nextdiroff;   /* file offset of following directory */\n\tuint64*              tif_dirlist;      /* list of offsets to already seen directories to prevent IFD looping */\n\tuint16               tif_dirlistsize;  /* number of entries in offset list */\n\tuint16               tif_dirnumber;    /* number of already seen directories */\n\tTIFFDirectory        tif_dir;          /* internal rep of current directory */\n\tTIFFDirectory        tif_customdir;    /* custom IFDs are separated from the main ones */\n\tunion {\n\t\tTIFFHeaderCommon common;\n\t\tTIFFHeaderClassic classic;\n\t\tTIFFHeaderBig big;\n\t} tif_header;\n\tuint16               tif_header_size;  /* file's header block and its length */\n\tuint32               tif_row;          /* current scanline */\n\tuint16               tif_curdir;       /* current directory (index) */\n\tuint32               tif_curstrip;     /* current strip for read/write */\n\tuint64               tif_curoff;       /* current offset for read/write */\n\tuint64               tif_dataoff;      /* current offset for writing dir */\n\t/* SubIFD support */\n\tuint16               tif_nsubifd;      /* remaining subifds to write */\n\tuint64               tif_subifdoff;    /* offset for patching SubIFD link */\n\t/* tiling support */\n\tuint32               tif_col;          /* current column (offset by row too) */\n\tuint32               tif_curtile;      /* current tile for read/write */\n\ttmsize_t             tif_tilesize;     /* # of bytes in a tile */\n\t/* compression scheme hooks */\n\tint                  tif_decodestatus;\n\tTIFFBoolMethod       tif_fixuptags;    /* called in TIFFReadDirectory */\n\tTIFFBoolMethod       tif_setupdecode;  /* called once before predecode */\n\tTIFFPreMethod        tif_predecode;    /* pre- row/strip/tile decoding */\n\tTIFFBoolMethod       tif_setupencode;  /* called once before preencode */\n\tint                  tif_encodestatus;\n\tTIFFPreMethod        tif_preencode;    /* pre- row/strip/tile encoding */\n\tTIFFBoolMethod       tif_postencode;   /* post- row/strip/tile encoding */\n\tTIFFCodeMethod       tif_decoderow;    /* scanline decoding routine */\n\tTIFFCodeMethod       tif_encoderow;    /* scanline encoding routine */\n\tTIFFCodeMethod       tif_decodestrip;  /* strip decoding routine */\n\tTIFFCodeMethod       tif_encodestrip;  /* strip encoding routine */\n\tTIFFCodeMethod       tif_decodetile;   /* tile decoding routine */\n\tTIFFCodeMethod       tif_encodetile;   /* tile encoding routine */\n\tTIFFVoidMethod       tif_close;        /* cleanup-on-close routine */\n\tTIFFSeekMethod       tif_seek;         /* position within a strip routine */\n\tTIFFVoidMethod       tif_cleanup;      /* cleanup state routine */\n\tTIFFStripMethod      tif_defstripsize; /* calculate/constrain strip size */\n\tTIFFTileMethod       tif_deftilesize;  /* calculate/constrain tile size */\n\tuint8*               tif_data;         /* compression scheme private data */\n\t/* input/output buffering */\n\ttmsize_t             tif_scanlinesize; /* # of bytes in a scanline */\n\ttmsize_t             tif_scanlineskew; /* scanline skew for reading strips */\n\tuint8*               tif_rawdata;      /* raw data buffer */\n\ttmsize_t             tif_rawdatasize;  /* # of bytes in raw data buffer */\n        tmsize_t             tif_rawdataoff;   /* rawdata offset within strip */\n        tmsize_t             tif_rawdataloaded;/* amount of data in rawdata */\n\tuint8*               tif_rawcp;        /* current spot in raw buffer */\n\ttmsize_t             tif_rawcc;        /* bytes unread from raw buffer */\n\t/* memory-mapped file support */\n\tuint8*               tif_base;         /* base of mapped file */\n\ttmsize_t             tif_size;         /* size of mapped file region (bytes, thus tmsize_t) */\n\tTIFFMapFileProc      tif_mapproc;      /* map file method */\n\tTIFFUnmapFileProc    tif_unmapproc;    /* unmap file method */\n\t/* input/output callback methods */\n\tthandle_t            tif_clientdata;   /* callback parameter */\n\tTIFFReadWriteProc    tif_readproc;     /* read method */\n\tTIFFReadWriteProc    tif_writeproc;    /* write method */\n\tTIFFSeekProc         tif_seekproc;     /* lseek method */\n\tTIFFCloseProc        tif_closeproc;    /* close method */\n\tTIFFSizeProc         tif_sizeproc;     /* filesize method */\n\t/* post-decoding support */\n\tTIFFPostMethod       tif_postdecode;   /* post decoding routine */\n\t/* tag support */\n\tTIFFField**          tif_fields;       /* sorted table of registered tags */\n\tsize_t               tif_nfields;      /* # entries in registered tag table */\n\tconst TIFFField*     tif_foundfield;   /* cached pointer to already found tag */\n\tTIFFTagMethods       tif_tagmethods;   /* tag get/set/print routines */\n\tTIFFClientInfoLink*  tif_clientinfo;   /* extra client information. */\n\t/* Backward compatibility stuff. We need these two fields for\n\t * setting up an old tag extension scheme. */\n\tTIFFFieldArray*      tif_fieldscompat;\n\tsize_t               tif_nfieldscompat;\n}",
          {
            "*                tif_name": "char",
            "tif_fd": "int",
            "tif_mode": "int",
            "tif_flags": "uint32",
            "tif_diroff": "uint64",
            "tif_nextdiroff": "uint64",
            "*              tif_dirlist": "uint64",
            "tif_dirlistsize": "uint16",
            "tif_dirnumber": "uint16",
            "tif_dir": "TIFFDirectory",
            "tif_customdir": "TIFFDirectory",
            "tif_header": "union {\n\t\tTIFFHeaderCommon common;\n\t\tTIFFHeaderClassic classic;\n\t\tTIFFHeaderBig big;\n\t}",
            "common": "TIFFHeaderCommon",
            "classic": "TIFFHeaderClassic",
            "big": "TIFFHeaderBig",
            "tif_header_size": "uint16",
            "tif_row": "uint32",
            "tif_curdir": "uint16",
            "tif_curstrip": "uint32",
            "tif_curoff": "uint64",
            "tif_dataoff": "uint64",
            "tif_nsubifd": "uint16",
            "tif_subifdoff": "uint64",
            "tif_col": "uint32",
            "tif_curtile": "uint32",
            "tif_tilesize": "tmsize_t",
            "tif_decodestatus": "int",
            "tif_fixuptags": "TIFFBoolMethod",
            "tif_setupdecode": "TIFFBoolMethod",
            "tif_predecode": "TIFFPreMethod",
            "tif_setupencode": "TIFFBoolMethod",
            "tif_encodestatus": "int",
            "tif_preencode": "TIFFPreMethod",
            "tif_postencode": "TIFFBoolMethod",
            "tif_decoderow": "TIFFCodeMethod",
            "tif_encoderow": "TIFFCodeMethod",
            "tif_decodestrip": "TIFFCodeMethod",
            "tif_encodestrip": "TIFFCodeMethod",
            "tif_decodetile": "TIFFCodeMethod",
            "tif_encodetile": "TIFFCodeMethod",
            "tif_close": "TIFFVoidMethod",
            "tif_seek": "TIFFSeekMethod",
            "tif_cleanup": "TIFFVoidMethod",
            "tif_defstripsize": "TIFFStripMethod",
            "tif_deftilesize": "TIFFTileMethod",
            "*               tif_data": "uint8",
            "tif_scanlinesize": "tmsize_t",
            "tif_scanlineskew": "tmsize_t",
            "*               tif_rawdata": "uint8",
            "tif_rawdatasize": "tmsize_t",
            "tif_rawdataoff": "tmsize_t",
            "tif_rawdataloaded": "tmsize_t",
            "*               tif_rawcp": "uint8",
            "tif_rawcc": "tmsize_t",
            "*               tif_base": "uint8",
            "tif_size": "tmsize_t",
            "tif_mapproc": "TIFFMapFileProc",
            "tif_unmapproc": "TIFFUnmapFileProc",
            "tif_clientdata": "thandle_t",
            "tif_readproc": "TIFFReadWriteProc",
            "tif_writeproc": "TIFFReadWriteProc",
            "tif_seekproc": "TIFFSeekProc",
            "tif_closeproc": "TIFFCloseProc",
            "tif_sizeproc": "TIFFSizeProc",
            "tif_postdecode": "TIFFPostMethod",
            "**          tif_fields": "TIFFField",
            "tif_nfields": "size_t",
            "TIFFField": "const",
            "tif_tagmethods": "TIFFTagMethods",
            "*  tif_clientinfo": "TIFFClientInfoLink",
            "*      tif_fieldscompat": "TIFFFieldArray",
            "tif_nfieldscompat": "size_t"
          },
          "tiff",
          [
            101,
            0
          ],
          [
            208,
            1
          ]
        ],
        [
          "typedef struct client_info {\n    struct client_info *next;\n    void *data;\n    char *name;\n} TIFFClientInfoLink;",
          {
            "*next": "struct client_info",
            "*data": "void",
            "*name": "char"
          },
          "TIFFClientInfoLink",
          [
            79,
            0
          ],
          [
            83,
            21
          ]
        ],
        [
          "struct client_info",
          {},
          "",
          [
            80,
            4
          ],
          [
            80,
            22
          ]
        ],
        [
          "struct tiff {\n\tchar*                tif_name;         /* name of open file */\n\tint                  tif_fd;           /* open file descriptor */\n\tint                  tif_mode;         /* open mode (O_*) */\n\tuint32               tif_flags;\n\t#define TIFF_FILLORDER   0x00003U /* natural bit fill order for machine */\n\t#define TIFF_DIRTYHEADER 0x00004U /* header must be written on close */\n\t#define TIFF_DIRTYDIRECT 0x00008U /* current directory must be written */\n\t#define TIFF_BUFFERSETUP 0x00010U /* data buffers setup */\n\t#define TIFF_CODERSETUP  0x00020U /* encoder/decoder setup done */\n\t#define TIFF_BEENWRITING 0x00040U /* written 1+ scanlines to file */\n\t#define TIFF_SWAB        0x00080U /* byte swap file information */\n\t#define TIFF_NOBITREV    0x00100U /* inhibit bit reversal logic */\n\t#define TIFF_MYBUFFER    0x00200U /* my raw data buffer; free on close */\n\t#define TIFF_ISTILED     0x00400U /* file is tile, not strip- based */\n\t#define TIFF_MAPPED      0x00800U /* file is mapped into memory */\n\t#define TIFF_POSTENCODE  0x01000U /* need call to postencode routine */\n\t#define TIFF_INSUBIFD    0x02000U /* currently writing a subifd */\n\t#define TIFF_UPSAMPLED   0x04000U /* library is doing data up-sampling */\n\t#define TIFF_STRIPCHOP   0x08000U /* enable strip chopping support */\n\t#define TIFF_HEADERONLY  0x10000U /* read header only, do not process the first directory */\n\t#define TIFF_NOREADRAW   0x20000U /* skip reading of raw uncompressed image data */\n\t#define TIFF_INCUSTOMIFD 0x40000U /* currently writing a custom IFD */\n\t#define TIFF_BIGTIFF     0x80000U /* read/write bigtiff */\n        #define TIFF_BUF4WRITE  0x100000U /* rawcc bytes are for writing */\n        #define TIFF_DIRTYSTRIP 0x200000U /* stripoffsets/stripbytecount dirty*/\n        #define TIFF_PERSAMPLE  0x400000U /* get/set per sample tags as arrays */\n        #define TIFF_BUFFERMMAP 0x800000U /* read buffer (tif_rawdata) points into mmap() memory */\n\tuint64               tif_diroff;       /* file offset of current directory */\n\tuint64               tif_nextdiroff;   /* file offset of following directory */\n\tuint64*              tif_dirlist;      /* list of offsets to already seen directories to prevent IFD looping */\n\tuint16               tif_dirlistsize;  /* number of entries in offset list */\n\tuint16               tif_dirnumber;    /* number of already seen directories */\n\tTIFFDirectory        tif_dir;          /* internal rep of current directory */\n\tTIFFDirectory        tif_customdir;    /* custom IFDs are separated from the main ones */\n\tunion {\n\t\tTIFFHeaderCommon common;\n\t\tTIFFHeaderClassic classic;\n\t\tTIFFHeaderBig big;\n\t} tif_header;\n\tuint16               tif_header_size;  /* file's header block and its length */\n\tuint32               tif_row;          /* current scanline */\n\tuint16               tif_curdir;       /* current directory (index) */\n\tuint32               tif_curstrip;     /* current strip for read/write */\n\tuint64               tif_curoff;       /* current offset for read/write */\n\tuint64               tif_dataoff;      /* current offset for writing dir */\n\t/* SubIFD support */\n\tuint16               tif_nsubifd;      /* remaining subifds to write */\n\tuint64               tif_subifdoff;    /* offset for patching SubIFD link */\n\t/* tiling support */\n\tuint32               tif_col;          /* current column (offset by row too) */\n\tuint32               tif_curtile;      /* current tile for read/write */\n\ttmsize_t             tif_tilesize;     /* # of bytes in a tile */\n\t/* compression scheme hooks */\n\tint                  tif_decodestatus;\n\tTIFFBoolMethod       tif_fixuptags;    /* called in TIFFReadDirectory */\n\tTIFFBoolMethod       tif_setupdecode;  /* called once before predecode */\n\tTIFFPreMethod        tif_predecode;    /* pre- row/strip/tile decoding */\n\tTIFFBoolMethod       tif_setupencode;  /* called once before preencode */\n\tint                  tif_encodestatus;\n\tTIFFPreMethod        tif_preencode;    /* pre- row/strip/tile encoding */\n\tTIFFBoolMethod       tif_postencode;   /* post- row/strip/tile encoding */\n\tTIFFCodeMethod       tif_decoderow;    /* scanline decoding routine */\n\tTIFFCodeMethod       tif_encoderow;    /* scanline encoding routine */\n\tTIFFCodeMethod       tif_decodestrip;  /* strip decoding routine */\n\tTIFFCodeMethod       tif_encodestrip;  /* strip encoding routine */\n\tTIFFCodeMethod       tif_decodetile;   /* tile decoding routine */\n\tTIFFCodeMethod       tif_encodetile;   /* tile encoding routine */\n\tTIFFVoidMethod       tif_close;        /* cleanup-on-close routine */\n\tTIFFSeekMethod       tif_seek;         /* position within a strip routine */\n\tTIFFVoidMethod       tif_cleanup;      /* cleanup state routine */\n\tTIFFStripMethod      tif_defstripsize; /* calculate/constrain strip size */\n\tTIFFTileMethod       tif_deftilesize;  /* calculate/constrain tile size */\n\tuint8*               tif_data;         /* compression scheme private data */\n\t/* input/output buffering */\n\ttmsize_t             tif_scanlinesize; /* # of bytes in a scanline */\n\ttmsize_t             tif_scanlineskew; /* scanline skew for reading strips */\n\tuint8*               tif_rawdata;      /* raw data buffer */\n\ttmsize_t             tif_rawdatasize;  /* # of bytes in raw data buffer */\n        tmsize_t             tif_rawdataoff;   /* rawdata offset within strip */\n        tmsize_t             tif_rawdataloaded;/* amount of data in rawdata */\n\tuint8*               tif_rawcp;        /* current spot in raw buffer */\n\ttmsize_t             tif_rawcc;        /* bytes unread from raw buffer */\n\t/* memory-mapped file support */\n\tuint8*               tif_base;         /* base of mapped file */\n\ttmsize_t             tif_size;         /* size of mapped file region (bytes, thus tmsize_t) */\n\tTIFFMapFileProc      tif_mapproc;      /* map file method */\n\tTIFFUnmapFileProc    tif_unmapproc;    /* unmap file method */\n\t/* input/output callback methods */\n\tthandle_t            tif_clientdata;   /* callback parameter */\n\tTIFFReadWriteProc    tif_readproc;     /* read method */\n\tTIFFReadWriteProc    tif_writeproc;    /* write method */\n\tTIFFSeekProc         tif_seekproc;     /* lseek method */\n\tTIFFCloseProc        tif_closeproc;    /* close method */\n\tTIFFSizeProc         tif_sizeproc;     /* filesize method */\n\t/* post-decoding support */\n\tTIFFPostMethod       tif_postdecode;   /* post decoding routine */\n\t/* tag support */\n\tTIFFField**          tif_fields;       /* sorted table of registered tags */\n\tsize_t               tif_nfields;      /* # entries in registered tag table */\n\tconst TIFFField*     tif_foundfield;   /* cached pointer to already found tag */\n\tTIFFTagMethods       tif_tagmethods;   /* tag get/set/print routines */\n\tTIFFClientInfoLink*  tif_clientinfo;   /* extra client information. */\n\t/* Backward compatibility stuff. We need these two fields for\n\t * setting up an old tag extension scheme. */\n\tTIFFFieldArray*      tif_fieldscompat;\n\tsize_t               tif_nfieldscompat;\n}",
          {
            "*                tif_name": "char",
            "tif_fd": "int",
            "tif_mode": "int",
            "tif_flags": "uint32",
            "tif_diroff": "uint64",
            "tif_nextdiroff": "uint64",
            "*              tif_dirlist": "uint64",
            "tif_dirlistsize": "uint16",
            "tif_dirnumber": "uint16",
            "tif_dir": "TIFFDirectory",
            "tif_customdir": "TIFFDirectory",
            "tif_header": "union {\n\t\tTIFFHeaderCommon common;\n\t\tTIFFHeaderClassic classic;\n\t\tTIFFHeaderBig big;\n\t}",
            "common": "TIFFHeaderCommon",
            "classic": "TIFFHeaderClassic",
            "big": "TIFFHeaderBig",
            "tif_header_size": "uint16",
            "tif_row": "uint32",
            "tif_curdir": "uint16",
            "tif_curstrip": "uint32",
            "tif_curoff": "uint64",
            "tif_dataoff": "uint64",
            "tif_nsubifd": "uint16",
            "tif_subifdoff": "uint64",
            "tif_col": "uint32",
            "tif_curtile": "uint32",
            "tif_tilesize": "tmsize_t",
            "tif_decodestatus": "int",
            "tif_fixuptags": "TIFFBoolMethod",
            "tif_setupdecode": "TIFFBoolMethod",
            "tif_predecode": "TIFFPreMethod",
            "tif_setupencode": "TIFFBoolMethod",
            "tif_encodestatus": "int",
            "tif_preencode": "TIFFPreMethod",
            "tif_postencode": "TIFFBoolMethod",
            "tif_decoderow": "TIFFCodeMethod",
            "tif_encoderow": "TIFFCodeMethod",
            "tif_decodestrip": "TIFFCodeMethod",
            "tif_encodestrip": "TIFFCodeMethod",
            "tif_decodetile": "TIFFCodeMethod",
            "tif_encodetile": "TIFFCodeMethod",
            "tif_close": "TIFFVoidMethod",
            "tif_seek": "TIFFSeekMethod",
            "tif_cleanup": "TIFFVoidMethod",
            "tif_defstripsize": "TIFFStripMethod",
            "tif_deftilesize": "TIFFTileMethod",
            "*               tif_data": "uint8",
            "tif_scanlinesize": "tmsize_t",
            "tif_scanlineskew": "tmsize_t",
            "*               tif_rawdata": "uint8",
            "tif_rawdatasize": "tmsize_t",
            "tif_rawdataoff": "tmsize_t",
            "tif_rawdataloaded": "tmsize_t",
            "*               tif_rawcp": "uint8",
            "tif_rawcc": "tmsize_t",
            "*               tif_base": "uint8",
            "tif_size": "tmsize_t",
            "tif_mapproc": "TIFFMapFileProc",
            "tif_unmapproc": "TIFFUnmapFileProc",
            "tif_clientdata": "thandle_t",
            "tif_readproc": "TIFFReadWriteProc",
            "tif_writeproc": "TIFFReadWriteProc",
            "tif_seekproc": "TIFFSeekProc",
            "tif_closeproc": "TIFFCloseProc",
            "tif_sizeproc": "TIFFSizeProc",
            "tif_postdecode": "TIFFPostMethod",
            "**          tif_fields": "TIFFField",
            "tif_nfields": "size_t",
            "TIFFField": "const",
            "tif_tagmethods": "TIFFTagMethods",
            "*  tif_clientinfo": "TIFFClientInfoLink",
            "*      tif_fieldscompat": "TIFFFieldArray",
            "tif_nfieldscompat": "size_t"
          },
          "tiff",
          [
            101,
            0
          ],
          [
            208,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "# include <fcntl.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "# include <sys/types.h>\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "# include <string.h>\n",
          [
            41,
            0
          ],
          [
            42,
            0
          ]
        ],
        [
          "# include <assert.h>\n",
          [
            45,
            0
          ],
          [
            46,
            0
          ]
        ],
        [
          "# include <search.h>\n",
          [
            51,
            0
          ],
          [
            52,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            63,
            0
          ],
          [
            64,
            0
          ]
        ],
        [
          "#include \"tif_dir.h\"\n",
          [
            65,
            0
          ],
          [
            66,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/libtiff/tif_dir.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "_TIFFGetFields(void)",
          "fn_dec_pos": [
            [
              257,
              29
            ],
            [
              257,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFGetFields",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFGetExifFields(void)",
          "fn_dec_pos": [
            [
              258,
              29
            ],
            [
              258,
              53
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFGetExifFields",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFSetupFields(TIFF* tif, const TIFFFieldArray* infoarray)",
          "fn_dec_pos": [
            [
              259,
              12
            ],
            [
              259,
              72
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFSetupFields",
            "parameters": {
              "tif": "TIFF",
              "infoarray": "TIFFFieldArray"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFPrintFieldInfo(TIFF*, FILE*)",
          "fn_dec_pos": [
            [
              260,
              12
            ],
            [
              260,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFPrintFieldInfo",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "_TIFFFillStriles(TIFF*)",
          "fn_dec_pos": [
            [
              262,
              11
            ],
            [
              262,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFFillStriles",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFMergeFields(TIFF*, const TIFFField[], uint32)",
          "fn_dec_pos": [
            [
              292,
              11
            ],
            [
              292,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFMergeFields",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "_TIFFFindOrRegisterField(TIFF *, uint32, TIFFDataType)",
          "fn_dec_pos": [
            [
              293,
              24
            ],
            [
              293,
              78
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFFindOrRegisterField",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFCreateAnonField(TIFF *, uint32, TIFFDataType)",
          "fn_dec_pos": [
            [
              294,
              19
            ],
            [
              294,
              69
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFCreateAnonField",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "_TIFFCheckFieldIsValidForCodec(TIFF *tif, ttag_t tag)",
          "fn_dec_pos": [
            [
              295,
              11
            ],
            [
              295,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_TIFFCheckFieldIsValidForCodec",
            "parameters": {
              "tif": "TIFF",
              "tag": "ttag_t"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct {\n\tconst TIFFField *info;\n\tint             count;\n\tvoid           *value;\n} TIFFTagValue;",
          {
            "TIFFField": "const",
            "count": "int",
            "*value": "void"
          },
          "TIFFTagValue",
          [
            34,
            0
          ],
          [
            38,
            15
          ]
        ],
        [
          "typedef struct {\n\tuint16 tdir_tag;        /* see below */\n\tuint16 tdir_type;       /* data type; see below */\n\tuint64 tdir_count;      /* number of items; length in spec */\n\tunion {\n\t\tuint16 toff_short;\n\t\tuint32 toff_long;\n\t\tuint64 toff_long8;\n\t} tdir_offset;\t\t/* either offset or the data itself if fits */\n} TIFFDirEntry;",
          {
            "tdir_tag": "uint16",
            "tdir_type": "uint16",
            "tdir_count": "uint64",
            "tdir_offset": "union {\n\t\tuint16 toff_short;\n\t\tuint32 toff_long;\n\t\tuint64 toff_long8;\n\t}",
            "toff_short": "uint16",
            "toff_long": "uint32",
            "toff_long8": "uint64"
          },
          "TIFFDirEntry",
          [
            51,
            0
          ],
          [
            60,
            15
          ]
        ],
        [
          "typedef struct {\n#define FIELD_SETLONGS 4\n\t/* bit vector of fields that are set */\n\tunsigned long td_fieldsset[FIELD_SETLONGS];\n\n\tuint32  td_imagewidth, td_imagelength, td_imagedepth;\n\tuint32  td_tilewidth, td_tilelength, td_tiledepth;\n\tuint32  td_subfiletype;\n\tuint16  td_bitspersample;\n\tuint16  td_sampleformat;\n\tuint16  td_compression;\n\tuint16  td_photometric;\n\tuint16  td_threshholding;\n\tuint16  td_fillorder;\n\tuint16  td_orientation;\n\tuint16  td_samplesperpixel;\n\tuint32  td_rowsperstrip;\n\tuint16  td_minsamplevalue, td_maxsamplevalue;\n\tdouble* td_sminsamplevalue;\n\tdouble* td_smaxsamplevalue;\n\tfloat   td_xresolution, td_yresolution;\n\tuint16  td_resolutionunit;\n\tuint16  td_planarconfig;\n\tfloat   td_xposition, td_yposition;\n\tuint16  td_pagenumber[2];\n\tuint16* td_colormap[3];\n\tuint16  td_halftonehints[2];\n\tuint16  td_extrasamples;\n\tuint16* td_sampleinfo;\n\t/* even though the name is misleading, td_stripsperimage is the number\n\t * of striles (=strips or tiles) per plane, and td_nstrips the total\n\t * number of striles */\n\tuint32  td_stripsperimage;  \n\tuint32  td_nstrips;              /* size of offset & bytecount arrays */\n\tuint64* td_stripoffset;\n\tuint64* td_stripbytecount;\n\tint     td_stripbytecountsorted; /* is the bytecount array sorted ascending? */\n#if defined(DEFER_STRILE_LOAD)\n        TIFFDirEntry td_stripoffset_entry;    /* for deferred loading */\n        TIFFDirEntry td_stripbytecount_entry; /* for deferred loading */\n#endif\n\tuint16  td_nsubifd;\n\tuint64* td_subifd;\n\t/* YCbCr parameters */\n\tuint16  td_ycbcrsubsampling[2];\n\tuint16  td_ycbcrpositioning;\n\t/* Colorimetry parameters */\n\tuint16* td_transferfunction[3];\n\tfloat*\ttd_refblackwhite;\n\t/* CMYK parameters */\n\tint     td_inknameslen;\n\tchar*   td_inknames;\n\n\tint     td_customValueCount;\n        TIFFTagValue *td_customValues;\n} TIFFDirectory;",
          {
            "td_fieldsset[FIELD_SETLONGS]": "unsigned long",
            "td_imagewidth": "uint32",
            "td_tilewidth": "uint32",
            "td_subfiletype": "uint32",
            "td_bitspersample": "uint16",
            "td_sampleformat": "uint16",
            "td_compression": "uint16",
            "td_photometric": "uint16",
            "td_threshholding": "uint16",
            "td_fillorder": "uint16",
            "td_orientation": "uint16",
            "td_samplesperpixel": "uint16",
            "td_rowsperstrip": "uint32",
            "td_minsamplevalue": "uint16",
            "* td_sminsamplevalue": "double",
            "* td_smaxsamplevalue": "double",
            "td_xresolution": "float",
            "td_resolutionunit": "uint16",
            "td_planarconfig": "uint16",
            "td_xposition": "float",
            "td_pagenumber[2]": "uint16",
            "* td_colormap[3]": "uint16",
            "td_halftonehints[2]": "uint16",
            "td_extrasamples": "uint16",
            "* td_sampleinfo": "uint16",
            "td_stripsperimage": "uint32",
            "td_nstrips": "uint32",
            "* td_stripoffset": "uint64",
            "* td_stripbytecount": "uint64",
            "td_stripbytecountsorted": "int",
            "td_stripoffset_entry": "TIFFDirEntry",
            "td_stripbytecount_entry": "TIFFDirEntry",
            "td_nsubifd": "uint16",
            "* td_subifd": "uint64",
            "td_ycbcrsubsampling[2]": "uint16",
            "td_ycbcrpositioning": "uint16",
            "* td_transferfunction[3]": "uint16",
            "*\ttd_refblackwhite": "float",
            "td_inknameslen": "int",
            "*   td_inknames": "char",
            "td_customValueCount": "int",
            "*td_customValues": "TIFFTagValue"
          },
          "TIFFDirectory",
          [
            65,
            0
          ],
          [
            120,
            16
          ]
        ],
        [
          "struct _TIFFFieldArray {\n\tTIFFFieldArrayType type;    /* array type, will be used to determine if IFD is image and such */\n\tuint32 allocated_size;      /* 0 if array is constant, other if modified by future definition extension support */\n\tuint32 count;               /* number of elements in fields array */\n\tTIFFField* fields;          /* actual field info */\n}",
          {
            "type": "TIFFFieldArrayType",
            "allocated_size": "uint32",
            "count": "uint32",
            "* fields": "TIFFField"
          },
          "_TIFFFieldArray",
          [
            270,
            0
          ],
          [
            275,
            1
          ]
        ],
        [
          "struct _TIFFField {\n\tuint32 field_tag;                       /* field's tag */\n\tshort field_readcount;                  /* read count/TIFF_VARIABLE/TIFF_SPP */\n\tshort field_writecount;                 /* write count/TIFF_VARIABLE */\n\tTIFFDataType field_type;                /* type of associated data */\n\tuint32 reserved;                        /* reserved for future extension */\n\tTIFFSetGetFieldType set_field_type;     /* type to be passed to TIFFSetField */\n\tTIFFSetGetFieldType get_field_type;     /* type to be passed to TIFFGetField */\n\tunsigned short field_bit;               /* bit in fieldsset bit vector */\n\tunsigned char field_oktochange;         /* if true, can change while writing */\n\tunsigned char field_passcount;          /* if true, pass dir count on set */\n\tchar* field_name;                       /* ASCII name */\n\tTIFFFieldArray* field_subfields;        /* if field points to child ifds, child ifd field definition array */\n}",
          {
            "field_tag": "uint32",
            "field_readcount": "short",
            "field_writecount": "short",
            "field_type": "TIFFDataType",
            "reserved": "uint32",
            "set_field_type": "TIFFSetGetFieldType",
            "get_field_type": "TIFFSetGetFieldType",
            "field_bit": "unsigned short",
            "field_oktochange": "unsigned char",
            "field_passcount": "unsigned char",
            "* field_name": "char",
            "* field_subfields": "TIFFFieldArray"
          },
          "_TIFFField",
          [
            277,
            0
          ],
          [
            290,
            1
          ]
        ],
        [
          "typedef struct {\n\tconst TIFFField *info;\n\tint             count;\n\tvoid           *value;\n} TIFFTagValue;",
          {
            "TIFFField": "const",
            "count": "int",
            "*value": "void"
          },
          "TIFFTagValue",
          [
            34,
            0
          ],
          [
            38,
            15
          ]
        ],
        [
          "typedef struct {\n\tuint16 tdir_tag;        /* see below */\n\tuint16 tdir_type;       /* data type; see below */\n\tuint64 tdir_count;      /* number of items; length in spec */\n\tunion {\n\t\tuint16 toff_short;\n\t\tuint32 toff_long;\n\t\tuint64 toff_long8;\n\t} tdir_offset;\t\t/* either offset or the data itself if fits */\n} TIFFDirEntry;",
          {
            "tdir_tag": "uint16",
            "tdir_type": "uint16",
            "tdir_count": "uint64",
            "tdir_offset": "union {\n\t\tuint16 toff_short;\n\t\tuint32 toff_long;\n\t\tuint64 toff_long8;\n\t}",
            "toff_short": "uint16",
            "toff_long": "uint32",
            "toff_long8": "uint64"
          },
          "TIFFDirEntry",
          [
            51,
            0
          ],
          [
            60,
            15
          ]
        ],
        [
          "typedef struct {\n#define FIELD_SETLONGS 4\n\t/* bit vector of fields that are set */\n\tunsigned long td_fieldsset[FIELD_SETLONGS];\n\n\tuint32  td_imagewidth, td_imagelength, td_imagedepth;\n\tuint32  td_tilewidth, td_tilelength, td_tiledepth;\n\tuint32  td_subfiletype;\n\tuint16  td_bitspersample;\n\tuint16  td_sampleformat;\n\tuint16  td_compression;\n\tuint16  td_photometric;\n\tuint16  td_threshholding;\n\tuint16  td_fillorder;\n\tuint16  td_orientation;\n\tuint16  td_samplesperpixel;\n\tuint32  td_rowsperstrip;\n\tuint16  td_minsamplevalue, td_maxsamplevalue;\n\tdouble* td_sminsamplevalue;\n\tdouble* td_smaxsamplevalue;\n\tfloat   td_xresolution, td_yresolution;\n\tuint16  td_resolutionunit;\n\tuint16  td_planarconfig;\n\tfloat   td_xposition, td_yposition;\n\tuint16  td_pagenumber[2];\n\tuint16* td_colormap[3];\n\tuint16  td_halftonehints[2];\n\tuint16  td_extrasamples;\n\tuint16* td_sampleinfo;\n\t/* even though the name is misleading, td_stripsperimage is the number\n\t * of striles (=strips or tiles) per plane, and td_nstrips the total\n\t * number of striles */\n\tuint32  td_stripsperimage;  \n\tuint32  td_nstrips;              /* size of offset & bytecount arrays */\n\tuint64* td_stripoffset;\n\tuint64* td_stripbytecount;\n\tint     td_stripbytecountsorted; /* is the bytecount array sorted ascending? */\n#if defined(DEFER_STRILE_LOAD)\n        TIFFDirEntry td_stripoffset_entry;    /* for deferred loading */\n        TIFFDirEntry td_stripbytecount_entry; /* for deferred loading */\n#endif\n\tuint16  td_nsubifd;\n\tuint64* td_subifd;\n\t/* YCbCr parameters */\n\tuint16  td_ycbcrsubsampling[2];\n\tuint16  td_ycbcrpositioning;\n\t/* Colorimetry parameters */\n\tuint16* td_transferfunction[3];\n\tfloat*\ttd_refblackwhite;\n\t/* CMYK parameters */\n\tint     td_inknameslen;\n\tchar*   td_inknames;\n\n\tint     td_customValueCount;\n        TIFFTagValue *td_customValues;\n} TIFFDirectory;",
          {
            "td_fieldsset[FIELD_SETLONGS]": "unsigned long",
            "td_imagewidth": "uint32",
            "td_tilewidth": "uint32",
            "td_subfiletype": "uint32",
            "td_bitspersample": "uint16",
            "td_sampleformat": "uint16",
            "td_compression": "uint16",
            "td_photometric": "uint16",
            "td_threshholding": "uint16",
            "td_fillorder": "uint16",
            "td_orientation": "uint16",
            "td_samplesperpixel": "uint16",
            "td_rowsperstrip": "uint32",
            "td_minsamplevalue": "uint16",
            "* td_sminsamplevalue": "double",
            "* td_smaxsamplevalue": "double",
            "td_xresolution": "float",
            "td_resolutionunit": "uint16",
            "td_planarconfig": "uint16",
            "td_xposition": "float",
            "td_pagenumber[2]": "uint16",
            "* td_colormap[3]": "uint16",
            "td_halftonehints[2]": "uint16",
            "td_extrasamples": "uint16",
            "* td_sampleinfo": "uint16",
            "td_stripsperimage": "uint32",
            "td_nstrips": "uint32",
            "* td_stripoffset": "uint64",
            "* td_stripbytecount": "uint64",
            "td_stripbytecountsorted": "int",
            "td_stripoffset_entry": "TIFFDirEntry",
            "td_stripbytecount_entry": "TIFFDirEntry",
            "td_nsubifd": "uint16",
            "* td_subifd": "uint64",
            "td_ycbcrsubsampling[2]": "uint16",
            "td_ycbcrpositioning": "uint16",
            "* td_transferfunction[3]": "uint16",
            "*\ttd_refblackwhite": "float",
            "td_inknameslen": "int",
            "*   td_inknames": "char",
            "td_customValueCount": "int",
            "*td_customValues": "TIFFTagValue"
          },
          "TIFFDirectory",
          [
            65,
            0
          ],
          [
            120,
            16
          ]
        ],
        [
          "struct _TIFFFieldArray {\n\tTIFFFieldArrayType type;    /* array type, will be used to determine if IFD is image and such */\n\tuint32 allocated_size;      /* 0 if array is constant, other if modified by future definition extension support */\n\tuint32 count;               /* number of elements in fields array */\n\tTIFFField* fields;          /* actual field info */\n}",
          {
            "type": "TIFFFieldArrayType",
            "allocated_size": "uint32",
            "count": "uint32",
            "* fields": "TIFFField"
          },
          "_TIFFFieldArray",
          [
            270,
            0
          ],
          [
            275,
            1
          ]
        ],
        [
          "struct _TIFFField {\n\tuint32 field_tag;                       /* field's tag */\n\tshort field_readcount;                  /* read count/TIFF_VARIABLE/TIFF_SPP */\n\tshort field_writecount;                 /* write count/TIFF_VARIABLE */\n\tTIFFDataType field_type;                /* type of associated data */\n\tuint32 reserved;                        /* reserved for future extension */\n\tTIFFSetGetFieldType set_field_type;     /* type to be passed to TIFFSetField */\n\tTIFFSetGetFieldType get_field_type;     /* type to be passed to TIFFGetField */\n\tunsigned short field_bit;               /* bit in fieldsset bit vector */\n\tunsigned char field_oktochange;         /* if true, can change while writing */\n\tunsigned char field_passcount;          /* if true, pass dir count on set */\n\tchar* field_name;                       /* ASCII name */\n\tTIFFFieldArray* field_subfields;        /* if field points to child ifds, child ifd field definition array */\n}",
          {
            "field_tag": "uint32",
            "field_readcount": "short",
            "field_writecount": "short",
            "field_type": "TIFFDataType",
            "reserved": "uint32",
            "set_field_type": "TIFFSetGetFieldType",
            "get_field_type": "TIFFSetGetFieldType",
            "field_bit": "unsigned short",
            "field_oktochange": "unsigned char",
            "field_passcount": "unsigned char",
            "* field_name": "char",
            "* field_subfields": "TIFFFieldArray"
          },
          "_TIFFField",
          [
            277,
            0
          ],
          [
            290,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiff.h\"\n",
          [
            27,
            0
          ],
          [
            28,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            28,
            0
          ],
          [
            29,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "typedef enum {\n\tTIFF_SETGET_UNDEFINED = 0,\n\tTIFF_SETGET_ASCII = 1,\n\tTIFF_SETGET_UINT8 = 2,\n\tTIFF_SETGET_SINT8 = 3,\n\tTIFF_SETGET_UINT16 = 4,\n\tTIFF_SETGET_SINT16 = 5,\n\tTIFF_SETGET_UINT32 = 6,\n\tTIFF_SETGET_SINT32 = 7,\n\tTIFF_SETGET_UINT64 = 8,\n\tTIFF_SETGET_SINT64 = 9,\n\tTIFF_SETGET_FLOAT = 10,\n\tTIFF_SETGET_DOUBLE = 11,\n\tTIFF_SETGET_IFD8 = 12,\n\tTIFF_SETGET_INT = 13,\n\tTIFF_SETGET_UINT16_PAIR = 14,\n\tTIFF_SETGET_C0_ASCII = 15,\n\tTIFF_SETGET_C0_UINT8 = 16,\n\tTIFF_SETGET_C0_SINT8 = 17,\n\tTIFF_SETGET_C0_UINT16 = 18,\n\tTIFF_SETGET_C0_SINT16 = 19,\n\tTIFF_SETGET_C0_UINT32 = 20,\n\tTIFF_SETGET_C0_SINT32 = 21,\n\tTIFF_SETGET_C0_UINT64 = 22,\n\tTIFF_SETGET_C0_SINT64 = 23,\n\tTIFF_SETGET_C0_FLOAT = 24,\n\tTIFF_SETGET_C0_DOUBLE = 25,\n\tTIFF_SETGET_C0_IFD8 = 26,\n\tTIFF_SETGET_C16_ASCII = 27,\n\tTIFF_SETGET_C16_UINT8 = 28,\n\tTIFF_SETGET_C16_SINT8 = 29,\n\tTIFF_SETGET_C16_UINT16 = 30,\n\tTIFF_SETGET_C16_SINT16 = 31,\n\tTIFF_SETGET_C16_UINT32 = 32,\n\tTIFF_SETGET_C16_SINT32 = 33,\n\tTIFF_SETGET_C16_UINT64 = 34,\n\tTIFF_SETGET_C16_SINT64 = 35,\n\tTIFF_SETGET_C16_FLOAT = 36,\n\tTIFF_SETGET_C16_DOUBLE = 37,\n\tTIFF_SETGET_C16_IFD8 = 38,\n\tTIFF_SETGET_C32_ASCII = 39,\n\tTIFF_SETGET_C32_UINT8 = 40,\n\tTIFF_SETGET_C32_SINT8 = 41,\n\tTIFF_SETGET_C32_UINT16 = 42,\n\tTIFF_SETGET_C32_SINT16 = 43,\n\tTIFF_SETGET_C32_UINT32 = 44,\n\tTIFF_SETGET_C32_SINT32 = 45,\n\tTIFF_SETGET_C32_UINT64 = 46,\n\tTIFF_SETGET_C32_SINT64 = 47,\n\tTIFF_SETGET_C32_FLOAT = 48,\n\tTIFF_SETGET_C32_DOUBLE = 49,\n\tTIFF_SETGET_C32_IFD8 = 50,\n\tTIFF_SETGET_OTHER = 51\n} TIFFSetGetFieldType;",
          {
            "TIFF_SETGET_UNDEFINED": "",
            "TIFF_SETGET_ASCII": "",
            "TIFF_SETGET_UINT8": "",
            "TIFF_SETGET_SINT8": "",
            "TIFF_SETGET_UINT16": "",
            "TIFF_SETGET_SINT16": "",
            "TIFF_SETGET_UINT32": "",
            "TIFF_SETGET_SINT32": "",
            "TIFF_SETGET_UINT64": "",
            "TIFF_SETGET_SINT64": "",
            "TIFF_SETGET_FLOAT": "",
            "TIFF_SETGET_DOUBLE": "",
            "TIFF_SETGET_IFD8": "",
            "TIFF_SETGET_INT": "",
            "TIFF_SETGET_UINT16_PAIR": "",
            "TIFF_SETGET_C0_ASCII": "",
            "TIFF_SETGET_C0_UINT8": "",
            "TIFF_SETGET_C0_SINT8": "",
            "TIFF_SETGET_C0_UINT16": "",
            "TIFF_SETGET_C0_SINT16": "",
            "TIFF_SETGET_C0_UINT32": "",
            "TIFF_SETGET_C0_SINT32": "",
            "TIFF_SETGET_C0_UINT64": "",
            "TIFF_SETGET_C0_SINT64": "",
            "TIFF_SETGET_C0_FLOAT": "",
            "TIFF_SETGET_C0_DOUBLE": "",
            "TIFF_SETGET_C0_IFD8": "",
            "TIFF_SETGET_C16_ASCII": "",
            "TIFF_SETGET_C16_UINT8": "",
            "TIFF_SETGET_C16_SINT8": "",
            "TIFF_SETGET_C16_UINT16": "",
            "TIFF_SETGET_C16_SINT16": "",
            "TIFF_SETGET_C16_UINT32": "",
            "TIFF_SETGET_C16_SINT32": "",
            "TIFF_SETGET_C16_UINT64": "",
            "TIFF_SETGET_C16_SINT64": "",
            "TIFF_SETGET_C16_FLOAT": "",
            "TIFF_SETGET_C16_DOUBLE": "",
            "TIFF_SETGET_C16_IFD8": "",
            "TIFF_SETGET_C32_ASCII": "",
            "TIFF_SETGET_C32_UINT8": "",
            "TIFF_SETGET_C32_SINT8": "",
            "TIFF_SETGET_C32_UINT16": "",
            "TIFF_SETGET_C32_SINT16": "",
            "TIFF_SETGET_C32_UINT32": "",
            "TIFF_SETGET_C32_SINT32": "",
            "TIFF_SETGET_C32_UINT64": "",
            "TIFF_SETGET_C32_SINT64": "",
            "TIFF_SETGET_C32_FLOAT": "",
            "TIFF_SETGET_C32_DOUBLE": "",
            "TIFF_SETGET_C32_IFD8": "",
            "TIFF_SETGET_OTHER": ""
          },
          "TIFFSetGetFieldType",
          [
            198,
            0
          ],
          [
            251,
            22
          ]
        ],
        [
          "typedef enum {\n\ttfiatImage,\n\ttfiatExif,\n\ttfiatOther\n} TIFFFieldArrayType;",
          {
            "tfiatImage": "",
            "tfiatExif": "",
            "tfiatOther": ""
          },
          "TIFFFieldArrayType",
          [
            264,
            0
          ],
          [
            268,
            21
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/archive/tools/rasterfile.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct rasterfile {\n\tchar\tras_magic[4];\t\t/* magic number */\n\tint32\tras_width;\t\t/* width (pixels) of image */\n\tint32\tras_height;\t\t/* height (pixels) of image */\n\tint32\tras_depth;\t\t/* depth (1, 8, or 24 bits) of pixel */\n\tint32\tras_length;\t\t/* length (bytes) of image */\n\tint32\tras_type;\t\t/* type of file; see RT_* below */\n\tint32\tras_maptype;\t\t/* type of colormap; see RMT_* below */\n\tint32\tras_maplength;\t\t/* length (bytes) of following map */\n\t/* color map follows for ras_maplength bytes, followed by image */\n}",
          {
            "ras_magic[4]": "char",
            "ras_width": "int32",
            "ras_height": "int32",
            "ras_depth": "int32",
            "ras_length": "int32",
            "ras_type": "int32",
            "ras_maptype": "int32",
            "ras_maplength": "int32"
          },
          "rasterfile",
          [
            5,
            0
          ],
          [
            15,
            1
          ]
        ],
        [
          "struct rasterfile {\n\tchar\tras_magic[4];\t\t/* magic number */\n\tint32\tras_width;\t\t/* width (pixels) of image */\n\tint32\tras_height;\t\t/* height (pixels) of image */\n\tint32\tras_depth;\t\t/* depth (1, 8, or 24 bits) of pixel */\n\tint32\tras_length;\t\t/* length (bytes) of image */\n\tint32\tras_type;\t\t/* type of file; see RT_* below */\n\tint32\tras_maptype;\t\t/* type of colormap; see RMT_* below */\n\tint32\tras_maplength;\t\t/* length (bytes) of following map */\n\t/* color map follows for ras_maplength bytes, followed by image */\n}",
          {
            "ras_magic[4]": "char",
            "ras_width": "int32",
            "ras_height": "int32",
            "ras_depth": "int32",
            "ras_length": "int32",
            "ras_type": "int32",
            "ras_maptype": "int32",
            "ras_maplength": "int32"
          },
          "rasterfile",
          [
            5,
            0
          ],
          [
            15,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiff.h\"\n",
          [
            0,
            0
          ],
          [
            1,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/pds/tif_imageiter.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "(*ImageIterTileContigRoutine)\n    (TIFFImageIter*, void *, uint32, uint32, uint32, uint32, int32,\n\tunsigned char*)",
          "fn_dec_pos": [
            [
              9,
              13
            ],
            [
              11,
              16
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*ImageIterTileSeparateRoutine)\n    (TIFFImageIter*, void *, uint32, uint32, uint32, uint32, int32,\n\tunsigned char*, unsigned char*, unsigned char*, unsigned char*)",
          "fn_dec_pos": [
            [
              22,
              13
            ],
            [
              24,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "(*get)(TIFFImageIter*, void *udata, uint32, uint32)",
          "fn_dec_pos": [
            [
              50,
              5
            ],
            [
              50,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {
              "udata": "void"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "(*any)(TIFFImageIter*)",
          "fn_dec_pos": [
            [
              52,
              10
            ],
            [
              52,
              32
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct _TIFFImageIter {\n\tTIFF*\ttif;\t\t\t\t/* image handle */\n\tint\tstoponerr;\t\t\t/* stop on read error */\n\tint\tisContig;\t\t\t/* data is packed/separate */\n\tint\talpha;\t\t\t\t/* type of alpha data present */\n\tuint32\twidth;\t\t\t\t/* image width */\n\tuint32\theight;\t\t\t\t/* image height */\n\tuint16\tbitspersample;\t\t\t/* image bits/sample */\n\tuint16\tsamplesperpixel;\t\t/* image samples/pixel */\n\tuint16\torientation;\t\t\t/* image orientation */\n\tuint16\tphotometric;\t\t\t/* image photometric interp */\n\tuint16*\tredcmap;\t\t\t/* colormap palette */\n\tuint16*\tgreencmap;\n\tuint16*\tbluecmap;\n\t\t\t\t\t\t/* get image data routine */\n\tint\t(*get)(TIFFImageIter*, void *udata, uint32, uint32);\n\tunion {\n\t    void (*any)(TIFFImageIter*);\n\t    ImageIterTileContigRoutine\t\tcontig;\n\t    ImageIterTileSeparateRoutine\tseparate;\n\t} callback;\t\t\t\t/* fn to exec for each block */\n}",
          {
            "*\ttif": "TIFF",
            "stoponerr": "int",
            "isContig": "int",
            "alpha": "int",
            "width": "uint32",
            "height": "uint32",
            "bitspersample": "uint16",
            "samplesperpixel": "uint16",
            "orientation": "uint16",
            "photometric": "uint16",
            "*\tredcmap": "uint16",
            "*\tgreencmap": "uint16",
            "*\tbluecmap": "uint16",
            "(*get)(TIFFImageIter*, void *udata, uint32, uint32)": "int",
            "callback": "union {\n\t    void (*any)(TIFFImageIter*);\n\t    ImageIterTileContigRoutine\t\tcontig;\n\t    ImageIterTileSeparateRoutine\tseparate;\n\t}",
            "(*any)(TIFFImageIter*)": "void",
            "contig": "ImageIterTileContigRoutine",
            "separate": "ImageIterTileSeparateRoutine"
          },
          "_TIFFImageIter",
          [
            35,
            0
          ],
          [
            56,
            1
          ]
        ],
        [
          "typedef struct _TIFFImageIter TIFFImageIter;",
          {},
          "TIFFImageIter",
          [
            0,
            0
          ],
          [
            0,
            44
          ]
        ],
        [
          "struct _TIFFImageIter {\n\tTIFF*\ttif;\t\t\t\t/* image handle */\n\tint\tstoponerr;\t\t\t/* stop on read error */\n\tint\tisContig;\t\t\t/* data is packed/separate */\n\tint\talpha;\t\t\t\t/* type of alpha data present */\n\tuint32\twidth;\t\t\t\t/* image width */\n\tuint32\theight;\t\t\t\t/* image height */\n\tuint16\tbitspersample;\t\t\t/* image bits/sample */\n\tuint16\tsamplesperpixel;\t\t/* image samples/pixel */\n\tuint16\torientation;\t\t\t/* image orientation */\n\tuint16\tphotometric;\t\t\t/* image photometric interp */\n\tuint16*\tredcmap;\t\t\t/* colormap palette */\n\tuint16*\tgreencmap;\n\tuint16*\tbluecmap;\n\t\t\t\t\t\t/* get image data routine */\n\tint\t(*get)(TIFFImageIter*, void *udata, uint32, uint32);\n\tunion {\n\t    void (*any)(TIFFImageIter*);\n\t    ImageIterTileContigRoutine\t\tcontig;\n\t    ImageIterTileSeparateRoutine\tseparate;\n\t} callback;\t\t\t\t/* fn to exec for each block */\n}",
          {
            "*\ttif": "TIFF",
            "stoponerr": "int",
            "isContig": "int",
            "alpha": "int",
            "width": "uint32",
            "height": "uint32",
            "bitspersample": "uint16",
            "samplesperpixel": "uint16",
            "orientation": "uint16",
            "photometric": "uint16",
            "*\tredcmap": "uint16",
            "*\tgreencmap": "uint16",
            "*\tbluecmap": "uint16",
            "(*get)(TIFFImageIter*, void *udata, uint32, uint32)": "int",
            "callback": "union {\n\t    void (*any)(TIFFImageIter*);\n\t    ImageIterTileContigRoutine\t\tcontig;\n\t    ImageIterTileSeparateRoutine\tseparate;\n\t}",
            "(*any)(TIFFImageIter*)": "void",
            "contig": "ImageIterTileContigRoutine",
            "separate": "ImageIterTileSeparateRoutine"
          },
          "_TIFFImageIter",
          [
            35,
            0
          ],
          [
            56,
            1
          ]
        ]
      ],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/tags/xtiffiop.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct XTIFFDirectory {\n\tuint16\t xd_num_multi; /* dir-count for the multi tag */\n\tdouble*  xd_example_multi;\n\tuint32   xd_example_single; \n\tchar*    xd_example_ascii;\n}",
          {
            "xd_num_multi": "uint16",
            "*  xd_example_multi": "double",
            "xd_example_single": "uint32",
            "*    xd_example_ascii": "char"
          },
          "XTIFFDirectory",
          [
            33,
            0
          ],
          [
            38,
            1
          ]
        ],
        [
          "struct xtiff {\n\tTIFF \t\t*xtif_tif;\t/* parent TIFF pointer */\n\tuint32\t\txtif_flags;\n#define       XTIFFP_PRINT   0x00000001\n\tXTIFFDirectory\txtif_dir;\t/* internal rep of current directory */\n\tTIFFVSetMethod\txtif_vsetfield;\t/* inherited tag set routine */\n\tTIFFVGetMethod\txtif_vgetfield;\t/* inherited tag get routine */\n\tTIFFPrintMethod\txtif_printdir;  /* inherited dir print method */\n}",
          {
            "*xtif_tif": "TIFF",
            "xtif_flags": "uint32",
            "xtif_dir": "XTIFFDirectory",
            "xtif_vsetfield": "TIFFVSetMethod",
            "xtif_vgetfield": "TIFFVGetMethod",
            "xtif_printdir": "TIFFPrintMethod"
          },
          "xtiff",
          [
            45,
            0
          ],
          [
            53,
            1
          ]
        ],
        [
          "struct XTIFFDirectory {\n\tuint16\t xd_num_multi; /* dir-count for the multi tag */\n\tdouble*  xd_example_multi;\n\tuint32   xd_example_single; \n\tchar*    xd_example_ascii;\n}",
          {
            "xd_num_multi": "uint16",
            "*  xd_example_multi": "double",
            "xd_example_single": "uint32",
            "*    xd_example_ascii": "char"
          },
          "XTIFFDirectory",
          [
            33,
            0
          ],
          [
            38,
            1
          ]
        ],
        [
          "typedef struct XTIFFDirectory XTIFFDirectory;",
          {},
          "XTIFFDirectory",
          [
            39,
            0
          ],
          [
            39,
            45
          ]
        ],
        [
          "struct xtiff {\n\tTIFF \t\t*xtif_tif;\t/* parent TIFF pointer */\n\tuint32\t\txtif_flags;\n#define       XTIFFP_PRINT   0x00000001\n\tXTIFFDirectory\txtif_dir;\t/* internal rep of current directory */\n\tTIFFVSetMethod\txtif_vsetfield;\t/* inherited tag set routine */\n\tTIFFVGetMethod\txtif_vgetfield;\t/* inherited tag get routine */\n\tTIFFPrintMethod\txtif_printdir;  /* inherited dir print method */\n}",
          {
            "*xtif_tif": "TIFF",
            "xtif_flags": "uint32",
            "xtif_dir": "XTIFFDirectory",
            "xtif_vsetfield": "TIFFVSetMethod",
            "xtif_vgetfield": "TIFFVGetMethod",
            "xtif_printdir": "TIFFPrintMethod"
          },
          "xtiff",
          [
            45,
            0
          ],
          [
            53,
            1
          ]
        ],
        [
          "typedef struct xtiff xtiff;",
          {},
          "xtiff",
          [
            54,
            0
          ],
          [
            54,
            27
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffiop.h\"\n",
          [
            15,
            0
          ],
          [
            16,
            0
          ]
        ],
        [
          "#include \"xtiffio.h\"\n",
          [
            16,
            0
          ],
          [
            17,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/tags/xtiffio.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "XTIFFOpen(const char* name, const char* mode)",
          "fn_dec_pos": [
            [
              42,
              13
            ],
            [
              42,
              58
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XTIFFOpen",
            "parameters": {
              "name": "char",
              "mode": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "XTIFFFdOpen(int fd, const char* name, const char* mode)",
          "fn_dec_pos": [
            [
              43,
              13
            ],
            [
              43,
              68
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XTIFFFdOpen",
            "parameters": {
              "fd": "int",
              "name": "char",
              "mode": "char"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "XTIFFClose(TIFF *tif)",
          "fn_dec_pos": [
            [
              44,
              13
            ],
            [
              44,
              34
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "XTIFFClose",
            "parameters": {
              "tif": "TIFF"
            },
            "return_type": "void"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffio.h\"\n",
          [
            14,
            0
          ],
          [
            15,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/addtiffo/tif_ovrcache.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "TIFFCreateOvrCache( TIFF *hTIFF, toff_t nDirOffset )",
          "fn_dec_pos": [
            [
              69,
              14
            ],
            [
              69,
              66
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFCreateOvrCache",
            "parameters": {
              "hTIFF": "TIFF",
              "nDirOffset": "toff_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFGetOvrBlock( TIFFOvrCache *psCache, int iTileX, int iTileY,\n                                int iSample )",
          "fn_dec_pos": [
            [
              70,
              15
            ],
            [
              71,
              45
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetOvrBlock",
            "parameters": {
              "psCache": "TIFFOvrCache",
              "iTileX": "int",
              "iTileY": "int",
              "iSample": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFGetOvrBlock_Subsampled( TIFFOvrCache *psCache, int iTileX, int iTileY )",
          "fn_dec_pos": [
            [
              72,
              15
            ],
            [
              72,
              90
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFGetOvrBlock_Subsampled",
            "parameters": {
              "psCache": "TIFFOvrCache",
              "iTileX": "int",
              "iTileY": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "TIFFDestroyOvrCache( TIFFOvrCache * )",
          "fn_dec_pos": [
            [
              73,
              15
            ],
            [
              73,
              52
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFDestroyOvrCache",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFFBuildOverviews( TIFF *, int, int *, int, const char *,\n                         int (*)(double,void*), void * )",
          "fn_dec_pos": [
            [
              75,
              5
            ],
            [
              76,
              56
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFFBuildOverviews",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFF_ProcessFullResBlock( TIFF *, int, int, int, int, int, int *, int, \n                               int, TIFFOvrCache **, uint32, uint32,\n                               unsigned char *, uint32, uint32,\n                               int, const char * )",
          "fn_dec_pos": [
            [
              78,
              5
            ],
            [
              81,
              50
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFF_ProcessFullResBlock",
            "parameters": {},
            "return_type": "void"
          }
        },
        {
          "fn_code": "TIFF_WriteOverview( TIFF *, uint32, uint32, int, int, int, int, int,\n                           int, int, int, int, unsigned short *,\n                           unsigned short *, unsigned short *, int,\n                           int, int)",
          "fn_dec_pos": [
            [
              83,
              7
            ],
            [
              86,
              36
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "TIFF_WriteOverview",
            "parameters": {},
            "return_type": "uint32"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "typedef struct \n{\n    uint32\tnXSize;\n    uint32\tnYSize;\n\n    uint16\tnBitsPerPixel;\n    uint16\tnSamples;\n    uint16      nPlanarConfig;\n    uint32\tnBlockXSize;\n    uint32\tnBlockYSize;\n    toff_t\tnBytesPerBlock;\n    toff_t      nBytesPerRow;\n\n    int\t\tnBlocksPerRow;\n    int\t\tnBlocksPerColumn;\n\n    int\t        nBlockOffset; /* what block is the first in papabyBlocks? */\n    unsigned char *pabyRow1Blocks;\n    unsigned char *pabyRow2Blocks;\n\n    toff_t\tnDirOffset;\n    TIFF\t*hTIFF;\n    int\t\tbTiled;\n    \n} TIFFOvrCache;",
          {
            "nXSize": "uint32",
            "nYSize": "uint32",
            "nBitsPerPixel": "uint16",
            "nSamples": "uint16",
            "nPlanarConfig": "uint16",
            "nBlockXSize": "uint32",
            "nBlockYSize": "uint32",
            "nBytesPerBlock": "toff_t",
            "nBytesPerRow": "toff_t",
            "nBlocksPerRow": "int",
            "nBlocksPerColumn": "int",
            "nBlockOffset": "int",
            "*pabyRow1Blocks": "unsigned char",
            "*pabyRow2Blocks": "unsigned char",
            "nDirOffset": "toff_t",
            "*hTIFF": "TIFF",
            "bTiled": "int"
          },
          "TIFFOvrCache",
          [
            43,
            0
          ],
          [
            67,
            15
          ]
        ],
        [
          "typedef struct \n{\n    uint32\tnXSize;\n    uint32\tnYSize;\n\n    uint16\tnBitsPerPixel;\n    uint16\tnSamples;\n    uint16      nPlanarConfig;\n    uint32\tnBlockXSize;\n    uint32\tnBlockYSize;\n    toff_t\tnBytesPerBlock;\n    toff_t      nBytesPerRow;\n\n    int\t\tnBlocksPerRow;\n    int\t\tnBlocksPerColumn;\n\n    int\t        nBlockOffset; /* what block is the first in papabyBlocks? */\n    unsigned char *pabyRow1Blocks;\n    unsigned char *pabyRow2Blocks;\n\n    toff_t\tnDirOffset;\n    TIFF\t*hTIFF;\n    int\t\tbTiled;\n    \n} TIFFOvrCache;",
          {
            "nXSize": "uint32",
            "nYSize": "uint32",
            "nBitsPerPixel": "uint16",
            "nSamples": "uint16",
            "nPlanarConfig": "uint16",
            "nBlockXSize": "uint32",
            "nBlockYSize": "uint32",
            "nBytesPerBlock": "toff_t",
            "nBytesPerRow": "toff_t",
            "nBlocksPerRow": "int",
            "nBlocksPerColumn": "int",
            "nBlockOffset": "int",
            "*pabyRow1Blocks": "unsigned char",
            "*pabyRow2Blocks": "unsigned char",
            "nDirOffset": "toff_t",
            "*hTIFF": "TIFF",
            "bTiled": "int"
          },
          "TIFFOvrCache",
          [
            43,
            0
          ],
          [
            67,
            15
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tiffio.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/dbs/xtiff/xtifficon.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/dbs/xtiff/patchlevel.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/contrib/stream/tiffstream.h": {
      "fn_def_list": [
        {
          "fn_code": "TIFF* getTiffHandle() const { return m_tif; }",
          "fn_code_pos": [
            [
              41,
              1
            ],
            [
              41,
              46
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "getTiffHandle",
            "parameters": {},
            "return_type": "TIFF"
          }
        },
        {
          "fn_code": "unsigned int getStreamLength() { return m_streamLength; }",
          "fn_code_pos": [
            [
              42,
              1
            ],
            [
              42,
              58
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "getStreamLength",
            "parameters": {},
            "return_type": null
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "TiffStream()",
          "fn_dec_pos": [
            [
              13,
              4
            ],
            [
              13,
              16
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "TiffStream",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "~TiffStream()",
          "fn_dec_pos": [
            [
              14,
              1
            ],
            [
              14,
              14
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "makeFileStream(iostream* str)",
          "fn_dec_pos": [
            [
              25,
              10
            ],
            [
              25,
              39
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "makeFileStream",
            "parameters": {
              "str": "iostream"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "makeFileStream(istream* str)",
          "fn_dec_pos": [
            [
              26,
              7
            ],
            [
              26,
              35
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "makeFileStream",
            "parameters": {
              "str": "istream"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "makeFileStream(ostream* str)",
          "fn_dec_pos": [
            [
              27,
              7
            ],
            [
              27,
              35
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "makeFileStream",
            "parameters": {
              "str": "ostream"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "read(thandle_t fd, tdata_t buf, tsize_t size)",
          "fn_dec_pos": [
            [
              31,
              16
            ],
            [
              31,
              61
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "read",
            "parameters": {
              "fd": "thandle_t",
              "buf": "tdata_t",
              "size": "tsize_t"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "write(thandle_t fd, tdata_t buf, tsize_t size)",
          "fn_dec_pos": [
            [
              32,
              16
            ],
            [
              32,
              62
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "write",
            "parameters": {
              "fd": "thandle_t",
              "buf": "tdata_t",
              "size": "tsize_t"
            },
            "return_type": "tsize_t"
          }
        },
        {
          "fn_code": "seek(thandle_t fd, toff_t offset, int origin)",
          "fn_dec_pos": [
            [
              33,
              15
            ],
            [
              33,
              60
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "seek",
            "parameters": {
              "fd": "thandle_t",
              "offset": "toff_t",
              "origin": "int"
            },
            "return_type": "toff_t"
          }
        },
        {
          "fn_code": "size(thandle_t fd)",
          "fn_dec_pos": [
            [
              34,
              15
            ],
            [
              34,
              33
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "size",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "toff_t"
          }
        },
        {
          "fn_code": "close(thandle_t fd)",
          "fn_dec_pos": [
            [
              35,
              12
            ],
            [
              35,
              31
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "close",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "map(thandle_t fd, tdata_t* phase, toff_t* psize)",
          "fn_dec_pos": [
            [
              36,
              12
            ],
            [
              36,
              60
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "map",
            "parameters": {
              "fd": "thandle_t",
              "phase": "tdata_t",
              "psize": "toff_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "unmap(thandle_t fd, tdata_t base, tsize_t size)",
          "fn_dec_pos": [
            [
              37,
              13
            ],
            [
              37,
              60
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "unmap",
            "parameters": {
              "fd": "thandle_t",
              "base": "tdata_t",
              "size": "tsize_t"
            },
            "return_type": "void"
          }
        },
        {
          "fn_code": "getTiffHandle() const",
          "fn_dec_pos": [
            [
              41,
              7
            ],
            [
              41,
              28
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "getTiffHandle",
            "parameters": {},
            "return_type": null
          }
        },
        {
          "fn_code": "getSize(thandle_t fd)",
          "fn_dec_pos": [
            [
              46,
              17
            ],
            [
              46,
              38
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "getSize",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "tell(thandle_t fd)",
          "fn_dec_pos": [
            [
              47,
              14
            ],
            [
              47,
              32
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "tell",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "seekInt(thandle_t fd, unsigned int offset, int origin)",
          "fn_dec_pos": [
            [
              48,
              6
            ],
            [
              48,
              60
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "seekInt",
            "parameters": {
              "fd": "thandle_t",
              "offset": "unsigned int",
              "origin": "int"
            },
            "return_type": "bool"
          }
        },
        {
          "fn_code": "isOpen(thandle_t fd)",
          "fn_dec_pos": [
            [
              49,
              6
            ],
            [
              49,
              26
            ]
          ],
          "class_code": "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507",
          "class_node_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ],
          "fn_meta": {
            "identifier": "isOpen",
            "parameters": {
              "fd": "thandle_t"
            },
            "return_type": "bool"
          }
        }
      ],
      "class_node_list": {
        "448053d2062af28df62afd282c8aeaedfe6793e0bd91e1db760c30cbd057e507": {
          "class_code": "class TiffStream {\n\npublic:\n    // ctor/dtor\n    TiffStream();\n\t~TiffStream();\n\npublic:\n    enum SeekDir {\n\t    beg,\n\t\tcur,\n\t\tend,\n    };\n\npublic:\n    // factory methods\n    TIFF* makeFileStream(iostream* str);\n\tTIFF* makeFileStream(istream* str);\n\tTIFF* makeFileStream(ostream* str);\n\npublic:\n    // tiff client methods\n\tstatic tsize_t read(thandle_t fd, tdata_t buf, tsize_t size);\n\tstatic tsize_t write(thandle_t fd, tdata_t buf, tsize_t size);\n\tstatic toff_t seek(thandle_t fd, toff_t offset, int origin);\n\tstatic toff_t size(thandle_t fd);\n\tstatic int close(thandle_t fd);\n\tstatic int map(thandle_t fd, tdata_t* phase, toff_t* psize);\n\tstatic void unmap(thandle_t fd, tdata_t base, tsize_t size);\n\npublic:\n    // query method\n\tTIFF* getTiffHandle() const { return m_tif; }\n\tunsigned int getStreamLength() { return m_streamLength; }\n\nprivate:\n\t// internal methods\n    unsigned int getSize(thandle_t fd);\n\tunsigned int tell(thandle_t fd);\n\tbool seekInt(thandle_t fd, unsigned int offset, int origin);\n\tbool isOpen(thandle_t fd);\n\nprivate:\n\tthandle_t m_this;\n\tTIFF* m_tif;\n\tstatic const char* m_name;\n\tistream* m_inStream;\n\tostream* m_outStream;\n\tiostream* m_ioStream;\n\tint m_streamLength;\n\t\n}",
          "class_name": "TiffStream",
          "class_pos": [
            [
              9,
              0
            ],
            [
              60,
              1
            ]
          ]
        }
      },
      "struct_node_list": [],
      "include_list": [
        [
          "#include <iostream.h>\n",
          [
            5,
            0
          ],
          [
            6,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            7,
            0
          ],
          [
            8,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": [
        [
          "enum SeekDir {\n\t    beg,\n\t\tcur,\n\t\tend,\n    }",
          {
            "beg": "",
            "cur": "",
            "end": ""
          },
          "SeekDir",
          [
            17,
            4
          ],
          [
            21,
            5
          ]
        ]
      ]
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/port/libport.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "getopt(int argc, char * const argv[], const char *optstring)",
          "fn_dec_pos": [
            [
              26,
              4
            ],
            [
              26,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "getopt",
            "parameters": {
              "argc": "int",
              "argv": "char",
              "optstring": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "strcasecmp(const char *s1, const char *s2)",
          "fn_dec_pos": [
            [
              32,
              4
            ],
            [
              32,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strcasecmp",
            "parameters": {
              "s1": "char",
              "s2": "char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "strtol(const char *nptr, char **endptr, int base)",
          "fn_dec_pos": [
            [
              39,
              5
            ],
            [
              39,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strtol",
            "parameters": {
              "nptr": "char",
              "endptr": "char",
              "base": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "strtoll(const char *nptr, char **endptr, int base)",
          "fn_dec_pos": [
            [
              42,
              10
            ],
            [
              42,
              60
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strtoll",
            "parameters": {
              "nptr": "char",
              "endptr": "char",
              "base": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "strtoul(const char *nptr, char **endptr, int base)",
          "fn_dec_pos": [
            [
              45,
              14
            ],
            [
              45,
              64
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strtoul",
            "parameters": {
              "nptr": "char",
              "endptr": "char",
              "base": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "strtoull(const char *nptr, char **endptr, int base)",
          "fn_dec_pos": [
            [
              48,
              19
            ],
            [
              48,
              70
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "strtoull",
            "parameters": {
              "nptr": "char",
              "endptr": "char",
              "base": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "lfind(const void *key, const void *base, size_t *nmemb, size_t size,\n      int(*compar)(const void *, const void *))",
          "fn_dec_pos": [
            [
              53,
              0
            ],
            [
              54,
              47
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "lfind",
            "parameters": {
              "key": "void",
              "base": "void",
              "nmemb": "size_t",
              "size": "size_t",
              "compar": "int"
            },
            "return_type": null
          }
        },
        {
          "fn_code": "(*compar)(const void *, const void *)",
          "fn_dec_pos": [
            [
              54,
              9
            ],
            [
              54,
              46
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "snprintf(char* str, size_t size, const char* format, ...)",
          "fn_dec_pos": [
            [
              63,
              4
            ],
            [
              63,
              61
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "snprintf",
            "parameters": {
              "str": "char",
              "size": "size_t",
              "format": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/port/_strtol.h": {
      "fn_def_list": [
        {
          "fn_code": "__INT\n_FUNCNAME(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\t__INT acc, cutoff;\n\tunsigned char c;\n\tint i, neg, any, cutlim;\n\n\tassert(nptr != NULL);\n\t/* endptr may be NULL */\n\n\t/* check base value */\n\tif (base && (base < 2 || base > 36)) {\n\t\terrno = EINVAL;\n\t\tif (endptr != NULL)\n\t\t\t/* LINTED interface specification */\n\t\t\t*endptr = (char *)(nptr);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X') &&\n\t    ((s[1] >= '0' && s[1] <= '9') ||\n\t     (s[1] >= 'a' && s[1] <= 'f') ||\n\t     (s[1] >= 'A' && s[1] <= 'F'))) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t} else if (base == 0)\n\t\tbase = (c == '0' ? 8 : 10);\n\n\t/*\n\t * Compute the cutoff value between legal numbers and illegal\n\t * numbers.  That is the largest legal value, divided by the\n\t * base.  An input number that is greater than this value, if\n\t * followed by a legal input character, is too big.  One that\n\t * is equal to this value may be valid or not; the limit\n\t * between valid and invalid numbers is then based on the last\n\t * digit.  For instance, if the range for longs is\n\t * [-2147483648..2147483647] and the input base is 10,\n\t * cutoff will be set to 214748364 and cutlim to either\n\t * 7 (neg==0) or 8 (neg==1), meaning that if we have accumulated\n\t * a value > 214748364, or equal but the next digit is > 7 (or 8),\n\t * the number is too big, and we will return a range error.\n\t *\n\t * Set any if any `digits' consumed; make it negative to indicate\n\t * overflow.\n\t */\n\tcutoff = (__INT)(neg ? __INT_MIN : __INT_MAX);\n\tcutlim = (int)(cutoff % base);\n\tcutoff /= base;\n\tif (neg) {\n\t\tif (cutlim > 0) {\n\t\t\tcutlim -= base;\n\t\t\tcutoff += 1;\n\t\t}\n\t\tcutlim = -cutlim;\n\t}\n\tfor (acc = 0, any = 0;; c = *s++) {\n\t\tif (c >= '0' && c <= '9')\n\t\t\ti = c - '0';\n\t\telse if (c >= 'a' && c <= 'z')\n\t\t\ti = (c - 'a') + 10;\n\t\telse if (c >= 'A' && c <= 'Z')\n\t\t\ti = (c - 'A') + 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (i >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (neg) {\n\t\t\tif (acc < cutoff || (acc == cutoff && i > cutlim)) {\n\t\t\t\tacc = __INT_MIN;\n\t\t\t\tany = -1;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc -= i;\n\t\t\t}\n\t\t} else {\n\t\t\tif (acc > cutoff || (acc == cutoff && i > cutlim)) {\n\t\t\t\tacc = __INT_MAX;\n\t\t\t\tany = -1;\n\t\t\t\terrno = ERANGE;\n\t\t\t} else {\n\t\t\t\tany = 1;\n\t\t\t\tacc *= base;\n\t\t\t\tacc += i;\n\t\t\t}\n\t\t}\n\t}\n\tif (endptr != NULL)\n\t\t/* LINTED interface specification */\n\t\t*endptr = (char *)(any ? s - 1 : nptr);\n\treturn(acc);\n}",
          "fn_code_pos": [
            [
              45,
              0
            ],
            [
              159,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_FUNCNAME",
            "parameters": {
              "nptr": "char",
              "endptr": "char",
              "base": "int"
            },
            "return_type": "__INT"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <assert.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/port/_strtoul.h": {
      "fn_def_list": [
        {
          "fn_code": "__UINT\n_FUNCNAME(const char *nptr, char **endptr, int base)\n{\n\tconst char *s;\n\t__UINT acc, cutoff;\n\tunsigned char c;\n\tint i, neg, any, cutlim;\n\n\tassert(nptr != NULL);\n\t/* endptr may be NULL */\n\n\t/* check base value */\n\tif (base && (base < 2 || base > 36)) {\n\t\terrno = EINVAL;\n\t\tif (endptr != NULL)\n\t\t\t/* LINTED interface specification */\n\t\t\t*endptr = (char *)(nptr);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Skip white space and pick up leading +/- sign if any.\n\t * If base is 0, allow 0x for hex and 0 for octal, else\n\t * assume decimal; if base is already 16, allow 0x.\n\t */\n\ts = nptr;\n\tdo {\n\t\tc = *s++;\n\t} while (isspace(c));\n\tif (c == '-') {\n\t\tneg = 1;\n\t\tc = *s++;\n\t} else {\n\t\tneg = 0;\n\t\tif (c == '+')\n\t\t\tc = *s++;\n\t}\n\tif ((base == 0 || base == 16) &&\n\t    c == '0' && (*s == 'x' || *s == 'X') &&\n\t    ((s[1] >= '0' && s[1] <= '9') ||\n\t     (s[1] >= 'a' && s[1] <= 'f') ||\n\t     (s[1] >= 'A' && s[1] <= 'F'))) {\n\t\tc = s[1];\n\t\ts += 2;\n\t\tbase = 16;\n\t} else if (base == 0)\n\t\tbase = (c == '0' ? 8 : 10);\n\n\t/*\n\t * See strtol for comments as to the logic used.\n\t */\n\tcutoff = ((__UINT)__UINT_MAX / (__UINT)base);\n\tcutlim = (int)((__UINT)__UINT_MAX % (__UINT)base);\n\tfor (acc = 0, any = 0;; c = *s++) {\n\t\tif (c >= '0' && c <= '9')\n\t\t\ti = c - '0';\n\t\telse if (c >= 'a' && c <= 'z')\n\t\t\ti = (c - 'a') + 10;\n\t\telse if (c >= 'A' && c <= 'Z')\n\t\t\ti = (c - 'A') + 10;\n\t\telse\n\t\t\tbreak;\n\t\tif (i >= base)\n\t\t\tbreak;\n\t\tif (any < 0)\n\t\t\tcontinue;\n\t\tif (acc > cutoff || (acc == cutoff && i > cutlim)) {\n\t\t\tacc = __UINT_MAX;\n\t\t\tany = -1;\n\t\t\terrno = ERANGE;\n\t\t} else {\n\t\t\tany = 1;\n\t\t\tacc *= (__UINT)base;\n\t\t\tacc += i;\n\t\t}\n\t}\n\tif (neg && any > 0)\n\t\tacc = -acc;\n\tif (endptr != NULL)\n\t\t/* LINTED interface specification */\n\t\t*endptr = (char *)(any ? s - 1 : nptr);\n\treturn(acc);\n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              126,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "_FUNCNAME",
            "parameters": {
              "nptr": "char",
              "endptr": "char",
              "base": "int"
            },
            "return_type": "__UINT"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <assert.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    }
  }
}