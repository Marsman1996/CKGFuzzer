{
  "src": {
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/test/strip_rw.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char **argv)\n{\n\tuint32\t\trowsperstrip;\n\tuint16\t\tcompression;\n\tuint16\t\tspp, bps, photometric, sampleformat, planarconfig;\n        (void) argc;\n        (void) argv;\n\n\t/* \n\t * Test two special cases: image consisting from single line and image\n\t * consisting from single column.\n\t */\n\trowsperstrip = 1;\n\tcompression = COMPRESSION_NONE;\n\tspp = 1;\n\tbps = 8;\n        photometric = PHOTOMETRIC_MINISBLACK;\n\tsampleformat = SAMPLEFORMAT_UINT;\n\tplanarconfig = PLANARCONFIG_CONTIG;\n\n\tif (create_image_striped(filename, XSIZE * YSIZE, 1, rowsperstrip,\n\t\t\t\t  compression, spp, bps, photometric,\n\t\t\t\t  sampleformat, planarconfig,\n\t\t\t\t  (const tdata_t) byte_array1, byte_array1_size) < 0) {\n\t\tfprintf (stderr, \"Can't create TIFF file %s.\\n\", filename);\n\t\tgoto failure;\n\t}\n\tif (read_image_striped(filename, XSIZE * YSIZE, 1, rowsperstrip,\n\t\t\t\tcompression, spp, bps, photometric,\n\t\t\t\tsampleformat, planarconfig,\n\t\t\t\t(const tdata_t) byte_array1, byte_array1_size) < 0) {\n\t\tfprintf (stderr, \"Can't read TIFF file %s.\\n\", filename);\n\t\tgoto failure;\n\t}\n\tunlink(filename);\n\t\t\n\tif (create_image_striped(filename, 1, XSIZE * YSIZE, rowsperstrip,\n\t\t\t\t  compression, spp, bps, photometric,\n\t\t\t\t  sampleformat, planarconfig,\n\t\t\t\t  (const tdata_t) byte_array1, byte_array1_size) < 0) {\n\t\tfprintf (stderr, \"Can't create TIFF file %s.\\n\", filename);\n\t\tgoto failure;\n\t}\n\tif (read_image_striped(filename, 1, XSIZE * YSIZE, rowsperstrip,\n\t\t\t\tcompression, spp, bps, photometric,\n\t\t\t\tsampleformat, planarconfig,\n\t\t\t\t(const tdata_t) byte_array1, byte_array1_size) < 0) {\n\t\tfprintf (stderr, \"Can't read TIFF file %s.\\n\", filename);\n\t\tgoto failure;\n\t}\n\tunlink(filename);\n\t\t\n\t/* \n\t * Test one-channel image with different parameters.\n\t */\n\trowsperstrip = 1;\n\tspp = 1;\n\tbps = 8;\n        photometric = PHOTOMETRIC_MINISBLACK;\n\tsampleformat = SAMPLEFORMAT_UINT;\n\tplanarconfig = PLANARCONFIG_CONTIG;\n\n\tif (create_image_striped(filename, XSIZE, YSIZE, rowsperstrip,\n\t\t\t\t  compression, spp, bps, photometric,\n\t\t\t\t  sampleformat, planarconfig,\n\t\t\t\t  (const tdata_t) byte_array1, byte_array1_size) < 0) {\n\t\tfprintf (stderr, \"Can't create TIFF file %s.\\n\", filename);\n\t\tgoto failure;\n\t}\n\tif (read_image_striped(filename, XSIZE, YSIZE, rowsperstrip,\n\t\t\t\tcompression, spp, bps, photometric,\n\t\t\t\tsampleformat, planarconfig,\n\t\t\t\t(const tdata_t) byte_array1, byte_array1_size) < 0) {\n\t\tfprintf (stderr, \"Can't read TIFF file %s.\\n\", filename);\n\t\tgoto failure;\n\t}\n\tunlink(filename);\n\t\n\trowsperstrip = YSIZE;\n\tif (create_image_striped(filename, XSIZE, YSIZE, rowsperstrip,\n\t\t\t\t  compression, spp, bps, photometric,\n\t\t\t\t  sampleformat, planarconfig,\n\t\t\t\t  (const tdata_t) byte_array1, byte_array1_size) < 0) {\n\t\tfprintf (stderr, \"Can't create TIFF file %s.\\n\", filename);\n\t\tgoto failure;\n\t}\n\tif (read_image_striped(filename, XSIZE, YSIZE, rowsperstrip,\n\t\t\t\tcompression, spp, bps, photometric,\n\t\t\t\tsampleformat, planarconfig,\n\t\t\t\t(const tdata_t) byte_array1, byte_array1_size) < 0) {\n\t\tfprintf (stderr, \"Can't read TIFF file %s.\\n\", filename);\n\t\tgoto failure;\n\t}\n\tunlink(filename);\n\n\treturn 0;\n\nfailure:\n\tunlink(filename);\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              51,
              0
            ],
            [
              152,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "create_image_striped(const char *, uint32, uint32, uint32, uint16, uint16,\n\t\t     uint16, uint16, uint16, uint16, const tdata_t,\n\t\t     const tsize_t)",
          "fn_dec_pos": [
            [
              41,
              0
            ],
            [
              43,
              21
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "create_image_striped",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "read_image_striped(const char *, uint32, uint32, uint32, uint16, uint16,\n\t\t   uint16, uint16, uint16, uint16, const tdata_t,\n\t\t   const tsize_t)",
          "fn_dec_pos": [
            [
              45,
              0
            ],
            [
              47,
              19
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_image_striped",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "# include <unistd.h>",
          [
            34,
            0
          ],
          [
            34,
            20
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"test_arrays.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/test/rewrite_tag.c": {
      "fn_def_list": [
        {
          "fn_code": "int test_packbits()\n\n{\n    TIFF\t    *tif;\n    int             i;\n    unsigned char   buf[10] = {0,0,0,0,0,0,0,0,0,0};\n\n    int  length = 20;\n    const char *filename = \"test_packbits.tif\";\n\n    /* Test whether we can write tags. */\n    tif = TIFFOpen(filename, \"w\");\n\n    if (!tif) {\n        fprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename);\n        return 1;\n    }\n\n    if (!TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS)) {\n        fprintf (stderr, \"Can't set Compression tag.\\n\");\n        goto failure;\n    }\n    if (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) {\n        fprintf (stderr, \"Can't set ImageWidth tag.\\n\");\n        goto failure;\n    }\n    if (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) {\n        fprintf (stderr, \"Can't set ImageLength tag.\\n\");\n        goto failure;\n    }\n    if (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8)) {\n        fprintf (stderr, \"Can't set BitsPerSample tag.\\n\");\n        goto failure;\n    }\n    if (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1)) {\n        fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\n        goto failure;\n    }\n    if (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip)) {\n        fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\n        goto failure;\n    }\n    if (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) {\n        fprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\");\n        goto failure;\n    }\n\n    for (i = 0; i < length; i++ )\n    {\n        if( !TIFFWriteEncodedStrip( tif, i, buf, 10 ) )\n        {\n            fprintf (stderr, \"Can't write image data.\\n\");\n            goto failure;\n        }\n    }\n\n    TIFFClose(tif);\n\n    /* Test whether we can write tags. */\n\n    tif = TIFFOpen(filename, \"r+\");\n\n    if (!tif) {\n        fprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename);\n        return 1;\n    }\n\n    buf[3] = 17;\n    buf[6] = 12;\n\n    if( !TIFFWriteEncodedStrip( tif, 6, buf, 10 ) )\n    {\n        fprintf (stderr, \"Can't write image data.\\n\");\n        goto failure;\n    }\n\n    TIFFClose(tif);\n\n    unlink(filename);\n\n    return 0;\n\n  failure:\n    /* Something goes wrong; close file and return unsuccessful status. */\n    TIFFClose(tif);\n    /*  unlink(filename); */\n\n    return 1;\n    \n}",
          "fn_code_pos": [
            [
              44,
              0
            ],
            [
              133,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "test_packbits",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "int rewrite_test( const char *filename, int length, int bigtiff, \n                  uint64 base_value )\n\n{\n    TIFF\t\t*tif;\n    int\t\t\ti;\n    unsigned char\tbuf[10] = {5,6,7,8,9,10,11,12,13,14};\n    uint64\t\t*rowoffset, *rowbytes;\n    uint64\t\t*upd_rowoffset;\n    uint64\t\t*upd_bytecount;\n\n    /* Test whether we can write tags. */\n    if( bigtiff )\n        tif = TIFFOpen(filename, \"w8\");\n    else\n        tif = TIFFOpen(filename, \"w4\");\n\n    if (!tif) {\n        fprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename);\n        return 1;\n    }\n\n    if (!TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_PACKBITS)) {\n        fprintf (stderr, \"Can't set Compression tag.\\n\");\n        goto failure;\n    }\n    if (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) {\n        fprintf (stderr, \"Can't set ImageWidth tag.\\n\");\n        goto failure;\n    }\n    if (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) {\n        fprintf (stderr, \"Can't set ImageLength tag.\\n\");\n        goto failure;\n    }\n    if (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8)) {\n        fprintf (stderr, \"Can't set BitsPerSample tag.\\n\");\n        goto failure;\n    }\n    if (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1)) {\n        fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\n        goto failure;\n    }\n    if (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip)) {\n        fprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\n        goto failure;\n    }\n    if (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) {\n        fprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\");\n        goto failure;\n    }\n\n    for (i = 0; i < length; i++ )\n    {\n        if( TIFFWriteScanline( tif, buf, i, 0 ) == -1 )\n        {\n            fprintf (stderr, \"Can't write image data.\\n\");\n            goto failure;\n        }\n    }\n\n    TIFFClose(tif);\n\t\n    /* Ok, now test whether we can read written values. */\n    tif = TIFFOpen(filename, \"r+\");\n    if (!tif) {\n        fprintf (stderr, \"Can't open test TIFF file %s.\\n\", filename);\n        return 1;\n    }\n        \n    if( !TIFFGetField( tif, TIFFTAG_STRIPOFFSETS, &rowoffset ) )\n    {\n        fprintf (stderr, \"Can't fetch STRIPOFFSETS.\\n\");\n        goto failure;\n    }\n        \n    if( !TIFFGetField( tif, TIFFTAG_STRIPBYTECOUNTS, &rowbytes ) )\n    {\n        fprintf (stderr, \"Can't fetch STRIPBYTECOUNTS.\\n\");\n        goto failure;\n    }\n\n    upd_rowoffset = (uint64 *) _TIFFmalloc(sizeof(uint64) * length);\n    for( i = 0; i < length; i++ )\n        upd_rowoffset[i] = base_value + i*10;\n\n    if( !_TIFFRewriteField( tif, TIFFTAG_STRIPOFFSETS, TIFF_LONG8, \n                            length, upd_rowoffset ) )\n    {\n        fprintf (stderr, \"Can't rewrite STRIPOFFSETS.\\n\");\n        goto failure;\n    }\n\n    _TIFFfree( upd_rowoffset );\n\n    upd_bytecount = (uint64 *) _TIFFmalloc(sizeof(uint64) * length);\n    for( i = 0; i < length; i++ )\n        upd_bytecount[i] = 100 + i*10;\n\n    if( !_TIFFRewriteField( tif, TIFFTAG_STRIPBYTECOUNTS, TIFF_LONG8, \n                            length, upd_bytecount ) )\n    {\n        fprintf (stderr, \"Can't rewrite STRIPBYTECOUNTS.\\n\");\n        goto failure;\n    }\n\n    _TIFFfree( upd_bytecount );\n\n    TIFFClose(tif);\n\n    /* Reopen file and read back to verify contents */\n\n    tif = TIFFOpen(filename, \"r\");\n    if (!tif) {\n        fprintf (stderr, \"Can't open test TIFF file %s.\\n\", filename);\n        return 1;\n    }\n        \n    if( !TIFFGetField( tif, TIFFTAG_STRIPOFFSETS, &rowoffset ) )\n    {\n        fprintf (stderr, \"Can't fetch STRIPOFFSETS.\\n\");\n        goto failure;\n    }\n        \n    for( i = 0; i < length; i++ )\n    {\n        uint64 expect = base_value + i*10;\n\n        if( rowoffset[i] != expect )\n        {\n            fprintf( stderr, \n                     \"%s:STRIPOFFSETS[%d]: Got %X:%08X instead of %X:%08X.\\n\",\n                     filename, i, \n                     (int) (rowoffset[i] >> 32), \n                     (int) (rowoffset[i]&0xFFFFFFFF), \n                     (int) (expect >> 32), \n                     (int) (expect & 0xFFFFFFFF) );\n            goto failure;\n        }\n    }\n\n    if( !TIFFGetField( tif, TIFFTAG_STRIPBYTECOUNTS, &rowbytes ) )\n    {\n        fprintf (stderr, \"Can't fetch STRIPBYTECOUNTS.\\n\");\n        goto failure;\n    }\n        \n    for( i = 0; i < length; i++ )\n    {\n        uint64 expect = 100 + i*10;\n\n        if( rowbytes[i] != expect )\n        {\n            fprintf( stderr, \n                     \"%s:STRIPBYTECOUNTS[%d]: Got %X:%08X instead of %X:%08X.\\n\",\n                     filename, i, \n                     (int) (rowbytes[i] >> 32), \n                     (int) (rowbytes[i] & 0xFFFFFFFF), \n                     (int) (expect >> 32), \n                     (int) (expect & 0xFFFFFFFF) );\n            goto failure;\n        }\n    }\n\n    TIFFClose( tif );\n\n    /* All tests passed; delete file and exit with success status. */\n    unlink(filename);\n    return 0;\n\n  failure:\n    /* Something goes wrong; close file and return unsuccessful status. */\n    TIFFClose(tif);\n    /*  unlink(filename); */\n\n    return 1;\n    \n}",
          "fn_code_pos": [
            [
              138,
              0
            ],
            [
              314,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "rewrite_test",
            "parameters": {
              "filename": "char",
              "length": "int",
              "bigtiff": "int",
              "base_value": "uint64"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nmain(void)\n{\n    int failure = 0;\n\n    failure |= test_packbits();\n\n    /* test fairly normal use */\n    failure |= rewrite_test( \"rewrite1.tif\", 10, 0, 100 );\n    failure |= rewrite_test( \"rewrite2.tif\", 10, 1, 100 );\n\n    /* test case of fitting all in directory entry */\n    failure |= rewrite_test( \"rewrite3.tif\", 1, 0, 100 );\n    failure |= rewrite_test( \"rewrite4.tif\", 1, 1, 100 );\n\n    /* test with very large values that don't fit in 4bytes (bigtiff only) */\n    failure |= rewrite_test( \"rewrite5.tif\", 1000, 1, 0x6000000000ULL );\n    failure |= rewrite_test( \"rewrite6.tif\", 1, 1, 0x6000000000ULL );\n\n    return failure;\n}",
          "fn_code_pos": [
            [
              319,
              0
            ],
            [
              339,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "# include <unistd.h>",
          [
            34,
            0
          ],
          [
            34,
            20
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"tiffiop.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/test/short_tag.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain()\n{\n\tTIFF\t\t*tif;\n\tsize_t\t\ti;\n\tunsigned char\tbuf[SPP] = { 0, 127, 255 };\n\n\t/* Test whether we can write tags. */\n\ttif = TIFFOpen(filename, \"w\");\n\tif (!tif) {\n\t\tfprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename);\n\t\treturn 1;\n\t}\n\n\tif (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) {\n\t\tfprintf (stderr, \"Can't set ImageWidth tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) {\n\t\tfprintf (stderr, \"Can't set ImageLength tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps)) {\n\t\tfprintf (stderr, \"Can't set BitsPerSample tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, SPP)) {\n\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip)) {\n\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, planarconfig)) {\n\t\tfprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric)) {\n\t\tfprintf (stderr, \"Can't set PhotometricInterpretation tag.\\n\");\n\t\tgoto failure;\n\t}\n\n\tfor (i = 0; i < NSINGLETAGS; i++) {\n\t\tif (!TIFFSetField(tif, short_single_tags[i].tag,\n\t\t\t\t  short_single_tags[i].value)) {\n\t\t\tfprintf(stderr, \"Can't set tag %lu.\\n\",\n\t\t\t\t(unsigned long)short_single_tags[i].tag);\n\t\t\tgoto failure;\n\t\t}\n\t}\n\n\tfor (i = 0; i < NPAIREDTAGS; i++) {\n\t\tif (!TIFFSetField(tif, short_paired_tags[i].tag,\n\t\t\t\t  short_paired_tags[i].values[0],\n\t\t\t\t  short_paired_tags[i].values[1])) {\n\t\t\tfprintf(stderr, \"Can't set tag %lu.\\n\",\n\t\t\t\t(unsigned long)short_paired_tags[i].tag);\n\t\t\tgoto failure;\n\t\t}\n\t}\n\n\t/* Write dummy pixel data. */\n\tif (TIFFWriteScanline(tif, buf, 0, 0) == -1) {\n\t\tfprintf (stderr, \"Can't write image data.\\n\");\n\t\tgoto failure;\n\t}\n\n\tTIFFClose(tif);\n\t\n\t/* Ok, now test whether we can read written values. */\n\ttif = TIFFOpen(filename, \"r\");\n\tif (!tif) {\n\t\tfprintf (stderr, \"Can't open test TIFF file %s.\\n\", filename);\n\t\treturn 1;\n\t}\n\t\n\tif (CheckLongField(tif, TIFFTAG_IMAGEWIDTH, width) < 0)\n\t\tgoto failure;\n\n\tif (CheckLongField(tif, TIFFTAG_IMAGELENGTH, length) < 0)\n\t\tgoto failure;\n\n\tif (CheckShortField(tif, TIFFTAG_BITSPERSAMPLE, bps) < 0)\n\t\tgoto failure;\n\n\tif (CheckShortField(tif, TIFFTAG_PHOTOMETRIC, photometric) < 0)\n\t\tgoto failure;\n\n\tif (CheckShortField(tif, TIFFTAG_SAMPLESPERPIXEL, SPP) < 0)\n\t\tgoto failure;\n\n\tif (CheckLongField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip) < 0)\n\t\tgoto failure;\n\n\tif (CheckShortField(tif, TIFFTAG_PLANARCONFIG, planarconfig) < 0)\n\t\tgoto failure;\n\n\tfor (i = 0; i < NSINGLETAGS; i++) {\n\t\tif (CheckShortField(tif, short_single_tags[i].tag,\n\t\t\t\t    short_single_tags[i].value) < 0)\n\t\t\tgoto failure;\n\t}\n\n\tfor (i = 0; i < NPAIREDTAGS; i++) {\n\t\tif (CheckShortPairedField(tif, short_paired_tags[i].tag,\n\t\t\t\t\t  short_paired_tags[i].values) < 0)\n\t\t\tgoto failure;\n\t}\n\n\tTIFFClose(tif);\n\t\n\t/* All tests passed; delete file and exit with success status. */\n\tunlink(filename);\n\treturn 0;\n\nfailure:\n\t/* \n\t * Something goes wrong; close file and return unsuccessful status.\n\t * Do not remove the file for further manual investigation.\n\t */\n\tTIFFClose(tif);\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              77,
              0
            ],
            [
              200,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct {\n\tconst ttag_t\ttag;\n\tconst uint16\tvalue;\n}",
          {
            "ttag_t": "const",
            "uint16": "const"
          },
          "",
          [
            50,
            13
          ],
          [
            53,
            1
          ]
        ],
        [
          "struct {\n\tconst ttag_t\ttag;\n\tconst uint16\tvalues[2];\n}",
          {
            "ttag_t": "const",
            "uint16": "const"
          },
          "",
          [
            66,
            13
          ],
          [
            69,
            1
          ]
        ],
        [
          "struct {\n\tconst ttag_t\ttag;\n\tconst uint16\tvalue;\n}",
          {
            "ttag_t": "const",
            "uint16": "const"
          },
          "",
          [
            50,
            13
          ],
          [
            53,
            1
          ]
        ],
        [
          "struct {\n\tconst ttag_t\ttag;\n\tconst uint16\tvalues[2];\n}",
          {
            "ttag_t": "const",
            "uint16": "const"
          },
          "",
          [
            66,
            13
          ],
          [
            69,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "# include <unistd.h>",
          [
            34,
            0
          ],
          [
            34,
            20
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"tifftest.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/test/ascii_tag.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain()\n{\n\tTIFF\t\t*tif;\n\tsize_t\t\ti;\n\tunsigned char\tbuf[] = { 0, 127, 255 };\n\tchar\t\t*value;\n\n\t/* Test whether we can write tags. */\n\ttif = TIFFOpen(filename, \"w\");\n\tif (!tif) {\n\t\tfprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename);\n\t\treturn 1;\n\t}\n\n\tif (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, 1)) {\n\t\tfprintf (stderr, \"Can't set ImageWidth tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, 1)) {\n\t\tfprintf (stderr, \"Can't set ImageLength tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8)) {\n\t\tfprintf (stderr, \"Can't set BitsPerSample tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, sizeof(buf))) {\n\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) {\n\t\tfprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)) {\n\t\tfprintf (stderr, \"Can't set PhotometricInterpretation tag.\\n\");\n\t\tgoto failure;\n\t}\n\n\tfor (i = 0; i < NTAGS; i++) {\n\t\tif (!TIFFSetField(tif, ascii_tags[i].tag,\n\t\t\t\t  ascii_tags[i].value)) {\n\t\t\tfprintf(stderr, \"Can't set tag %lu.\\n\",\n\t\t\t\t(unsigned long)ascii_tags[i].tag);\n\t\t\tgoto failure;\n\t\t}\n\t}\n\n\t/* InkNames tag has special form, so we handle it separately. */\n\tif (!TIFFSetField(tif, TIFFTAG_NUMBEROFINKS, 3)) {\n\t\tfprintf (stderr, \"Can't set tag %d (NUMBEROFINKS).\\n\",\n                         TIFFTAG_NUMBEROFINKS);\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_INKNAMES, ink_names_size, ink_names)) {\n\t\tfprintf (stderr, \"Can't set tag %d (INKNAMES).\\n\",\n\t\t\t TIFFTAG_INKNAMES);\n\t\tgoto failure;\n\t}\n\n\t/* Write dummy pixel data. */\n\tif (TIFFWriteScanline(tif, buf, 0, 0) == -1) {\n\t\tfprintf (stderr, \"Can't write image data.\\n\");\n\t\tgoto failure;\n\t}\n\n\tTIFFClose(tif);\n\t\n\t/* Ok, now test whether we can read written values. */\n\ttif = TIFFOpen(filename, \"r\");\n\tif (!tif) {\n\t\tfprintf (stderr, \"Can't open test TIFF file %s.\\n\", filename);\n\t\treturn 1;\n\t}\n\n\tfor (i = 0; i < NTAGS; i++) {\n\t\tif (!TIFFGetField(tif, ascii_tags[i].tag, &value)\n\t\t    || strcmp(value, ascii_tags[i].value)) {\n\t\t\tfprintf(stderr, \"Can't get tag %lu.\\n\",\n\t\t\t\t(unsigned long)ascii_tags[i].tag);\n\t\t\tgoto failure;\n\t\t}\n\t}\n\n\tif (!TIFFGetField(tif, TIFFTAG_INKNAMES, &value)\n\t    || memcmp(value, ink_names, ink_names_size)) {\n\t\tfprintf (stderr, \"Can't get tag %d (INKNAMES).\\n\",\n\t\t\t TIFFTAG_INKNAMES);\n\t\tgoto failure;\n\t}\n\n\tTIFFClose(tif);\n\t\n\t/* All tests passed; delete file and exit with success status. */\n\tunlink(filename);\n\treturn 0;\n\nfailure:\n\t/* \n\t * Something goes wrong; close file and return unsuccessful status.\n\t * Do not remove the file for further manual investigation.\n\t */\n\tTIFFClose(tif);\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              67,
              0
            ],
            [
              172,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct {\n\tttag_t\t\ttag;\n\tconst char\t*value;\n}",
          {
            "tag": "ttag_t",
            "char": "const"
          },
          "",
          [
            42,
            13
          ],
          [
            45,
            1
          ]
        ],
        [
          "struct {\n\tttag_t\t\ttag;\n\tconst char\t*value;\n}",
          {
            "tag": "ttag_t",
            "char": "const"
          },
          "",
          [
            42,
            13
          ],
          [
            45,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ],
        [
          "# include <unistd.h>",
          [
            35,
            0
          ],
          [
            35,
            20
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/test/check_tag.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nCheckShortField(TIFF *tif, const ttag_t field, const uint16 value)\n{\n\tuint16 tmp = 123;\n\n\tif (!TIFFGetField(tif, field, &tmp)) {\n\t\tfprintf (stderr, \"Problem fetching tag %lu.\\n\",\n\t\t\t (unsigned long) field);\n\t\treturn -1;\n\t}\n\tif (tmp != value) {\n\t\tfprintf (stderr, \"Wrong SHORT value fetched for tag %lu.\\n\",\n\t\t\t (unsigned long) field);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              31,
              0
            ],
            [
              48,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckShortField",
            "parameters": {
              "tif": "TIFF",
              "field": "ttag_t",
              "value": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nCheckShortPairedField(TIFF *tif, const ttag_t field, const uint16 *values)\n{\n\tuint16 tmp[2] = { 123, 456 };\n\n\tif (!TIFFGetField(tif, field, tmp, tmp + 1)) {\n\t\tfprintf (stderr, \"Problem fetching tag %lu.\\n\",\n\t\t\t (unsigned long) field);\n\t\treturn -1;\n\t}\n\tif (tmp[0] != values[0] || tmp[1] != values[1]) {\n\t\tfprintf (stderr, \"Wrong SHORT PAIR fetched for tag %lu.\\n\",\n\t\t\t (unsigned long) field);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              50,
              0
            ],
            [
              67,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckShortPairedField",
            "parameters": {
              "tif": "TIFF",
              "field": "ttag_t",
              "values": "uint16"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nCheckLongField(TIFF *tif, const ttag_t field, const uint32 value)\n{\n\tuint32 tmp = 123;\n\n\tif (!TIFFGetField(tif, field, &tmp)) {\n\t\tfprintf (stderr, \"Problem fetching tag %lu.\\n\",\n\t\t\t (unsigned long) field);\n\t\treturn -1;\n\t}\n\tif (tmp != value) {\n\t\tfprintf (stderr, \"Wrong LONG value fetched for tag %lu.\\n\",\n\t\t\t (unsigned long) field);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              69,
              0
            ],
            [
              86,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLongField",
            "parameters": {
              "tif": "TIFF",
              "field": "ttag_t",
              "value": "uint32"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffio.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/test/strip.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nwrite_strips(TIFF *tif, const tdata_t array, const tsize_t size)\n{\n\ttstrip_t\tstrip, nstrips;\n\ttsize_t\t\tstripsize, offset;\n\n\tstripsize = TIFFStripSize(tif);\n\tif (!stripsize) {\n\t\tfprintf (stderr, \"Wrong size of strip.\\n\");\n\t\treturn -1;\n\t}\n\n\tnstrips = TIFFNumberOfStrips(tif);\n\tfor (offset = 0, strip = 0;\n\t     offset < size && strip < nstrips;\n\t     offset+=stripsize, strip++) {\n\t\t/*\n\t\t * Properly write last strip.\n\t\t */\n\t\ttsize_t\tbufsize = size - offset;\n\t\tif (bufsize > stripsize)\n\t\t\tbufsize = stripsize;\n\n\t\tif (TIFFWriteEncodedStrip(tif, strip, (char *)array + offset,\n\t\t\t\t\t  bufsize) != bufsize) {\n\t\t\tfprintf (stderr, \"Can't write strip %lu.\\n\",\n\t\t\t\t (unsigned long)strip);\n\t\t\treturn -1;\n\t\t}\n        }\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              34,
              0
            ],
            [
              66,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "write_strips",
            "parameters": {
              "tif": "TIFF",
              "array": "tdata_t",
              "size": "tsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nread_strips(TIFF *tif, const tdata_t array, const tsize_t size)\n{\n\ttstrip_t\tstrip, nstrips;\n\ttsize_t\t\tstripsize, offset;\n\ttdata_t\t\tbuf = NULL;\n\n\tstripsize = TIFFStripSize(tif);\n\tif (!stripsize) {\n\t\tfprintf (stderr, \"Wrong size of strip.\\n\");\n\t\treturn -1;\n\t}\n\n\tbuf = _TIFFmalloc(stripsize);\n\tif (!buf) {\n\t\tfprintf (stderr, \"Can't allocate space for strip buffer.\\n\");\n\t\treturn -1;\n\t}\n\n\tnstrips = TIFFNumberOfStrips(tif);\n\tfor (offset = 0, strip = 0;\n\t     offset < size && strip < nstrips;\n\t     offset+=stripsize, strip++) {\n\t\t/*\n\t\t * Properly read last strip.\n\t\t */\n\t\ttsize_t\tbufsize = size - offset;\n\t\tif (bufsize > stripsize)\n\t\t\tbufsize = stripsize;\n\n\t\tif (TIFFReadEncodedStrip(tif, strip, buf, -1) != bufsize) {\n\t\t\tfprintf (stderr, \"Can't read strip %lu.\\n\",\n\t\t\t\t (unsigned long)strip);\n\t\t\treturn -1;\n\t\t}\n\t\tif (memcmp(buf, (char *)array + offset, bufsize) != 0) {\n\t\t\tfprintf (stderr, \"Wrong data read for strip %lu.\\n\",\n\t\t\t\t (unsigned long)strip);\n\t\t\t_TIFFfree(buf);\n\t\t\treturn -1;\n\t\t}\n        }\n\n\t_TIFFfree(buf);\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              68,
              0
            ],
            [
              114,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_strips",
            "parameters": {
              "tif": "TIFF",
              "array": "tdata_t",
              "size": "tsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\ncreate_image_striped(const char *name, uint32 width, uint32 length,\n\t\t      uint32 rowsperstrip, uint16 compression,\n\t\t      uint16 spp, uint16 bps, uint16 photometric,\n\t\t      uint16 sampleformat, uint16 planarconfig,\n\t\t      const tdata_t array, const tsize_t size)\n{\n\tTIFF\t\t*tif;\n\n\t/* Test whether we can write tags. */\n\ttif = TIFFOpen(name, \"w\");\n\tif (!tif)\n\t\tgoto openfailure;\n\n\tif (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) {\n\t\tfprintf (stderr, \"Can't set ImageWidth tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) {\n\t\tfprintf (stderr, \"Can't set ImageLength tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps)) {\n\t\tfprintf (stderr, \"Can't set BitsPerSample tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, spp)) {\n\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip)) {\n\t\tfprintf (stderr, \"Can't set RowsPerStrip tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, planarconfig)) {\n\t\tfprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric)) {\n\t\tfprintf (stderr, \"Can't set PhotometricInterpretation tag.\\n\");\n\t\tgoto failure;\n\t}\n\n\tif (write_strips(tif, array, size) < 0) {\n\t\tfprintf (stderr, \"Can't write image data.\\n\");\n\t\tgoto failure;\n\t}\n\n\tTIFFClose(tif);\n\treturn 0;\n\nfailure:\n\tTIFFClose(tif);\nopenfailure:\n\tfprintf (stderr, \"Can't create test TIFF file %s:\\n\"\n\"    ImageWidth=%ld, ImageLength=%ld, RowsPerStrip=%ld, Compression=%d,\\n\"\n\"    BitsPerSample=%d, SamplesPerPixel=%d, SampleFormat=%d,\\n\"\n\"    PlanarConfiguration=%d, PhotometricInterpretation=%d.\\n\",\n\t\t name, (long) width, (long) length, (long) rowsperstrip,\n                 compression, bps, spp, sampleformat, planarconfig,\n\t\t photometric);\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              116,
              0
            ],
            [
              178,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "create_image_striped",
            "parameters": {
              "name": "char",
              "width": "uint32",
              "length": "uint32",
              "rowsperstrip": "uint32",
              "compression": "uint16",
              "spp": "uint16",
              "bps": "uint16",
              "photometric": "uint16",
              "sampleformat": "uint16",
              "planarconfig": "uint16",
              "array": "tdata_t",
              "size": "tsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nread_image_striped(const char *name, uint32 width, uint32 length,\n\t\t    uint32 rowsperstrip, uint16 compression,\n\t\t    uint16 spp, uint16 bps, uint16 photometric,\n\t\t    uint16 sampleformat, uint16 planarconfig,\n\t\t    const tdata_t array, const tsize_t size)\n{\n\tTIFF\t\t*tif;\n\tuint16\t\tvalue_u16;\n\tuint32\t\tvalue_u32;\n\n\t/* Test whether we can read written values. */\n\ttif = TIFFOpen(name, \"r\");\n\tif (!tif)\n\t\tgoto openfailure;\n\t\n\tif (TIFFIsTiled(tif)) {\n\t\tfprintf (stderr, \"Can't read image %s, it is tiled.\\n\",\n\t\t\t name);\n\t\tgoto failure;\n\t}\n\tif (!TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &value_u32)\n\t    || value_u32 != width) {\n\t\tfprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_IMAGEWIDTH);\n\t\tgoto failure;\n\t}\n\tif (!TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &value_u32)\n\t    || value_u32 != length) {\n\t\tfprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_IMAGELENGTH);\n\t\tgoto failure;\n\t}\n\tif (!TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &value_u16)\n\t    || value_u16 != bps) {\n\t\tfprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_BITSPERSAMPLE);\n\t\tgoto failure;\n\t}\n\tif (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &value_u16)\n\t    || value_u16 != photometric) {\n\t\tfprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_PHOTOMETRIC);\n\t\tgoto failure;\n\t}\n\tif (!TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &value_u16)\n\t    || value_u16 != spp) {\n\t\tfprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_SAMPLESPERPIXEL);\n\t\tgoto failure;\n\t}\n\tif (!TIFFGetField(tif, TIFFTAG_ROWSPERSTRIP, &value_u32)\n\t    || value_u32 != rowsperstrip) {\n\t\tfprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_ROWSPERSTRIP);\n\t\tgoto failure;\n\t}\n\tif (!TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &value_u16)\n\t    || value_u16 != planarconfig) {\n\t\tfprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_PLANARCONFIG);\n\t\tgoto failure;\n\t}\n\n\tif (read_strips(tif, array, size) < 0) {\n\t\tfprintf (stderr, \"Can't read image data.\\n\");\n\t\tgoto failure;\n\t}\n\n\tTIFFClose(tif);\n\treturn 0;\n\nfailure:\n\tTIFFClose(tif);\nopenfailure:\n\tfprintf (stderr, \"Can't read test TIFF file %s:\\n\"\n\"    ImageWidth=%ld, ImageLength=%ld, RowsPerStrip=%ld, Compression=%d,\\n\"\n\"    BitsPerSample=%d, SamplesPerPixel=%d, SampleFormat=%d,\\n\"\n\"    PlanarConfiguration=%d, PhotometricInterpretation=%d.\\n\",\n\t\t name, (long) width, (long) length, (long) rowsperstrip,\n                 compression, bps, spp, sampleformat, planarconfig,\n\t\t photometric);\n\treturn -1;\n}",
          "fn_code_pos": [
            [
              180,
              0
            ],
            [
              256,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "read_image_striped",
            "parameters": {
              "name": "char",
              "width": "uint32",
              "length": "uint32",
              "rowsperstrip": "uint32",
              "compression": "uint16",
              "spp": "uint16",
              "bps": "uint16",
              "photometric": "uint16",
              "sampleformat": "uint16",
              "planarconfig": "uint16",
              "array": "tdata_t",
              "size": "tsize_t"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nwrite_scanlines(TIFF *tif, const tdata_t array, const tsize_t size)\n{\n\tuint32\t\tlength, row;\n\ttsize_t\t\tscanlinesize, offset;\n        (void) size;\n\n\tif (!TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &length)) {\n\t\tfprintf (stderr, \"Can't get tag %d.\\n\", TIFFTAG_IMAGELENGTH);\n\t\treturn -1;\n\t}\n\t\n\tscanlinesize = TIFFScanlineSize(tif);\n\tif (!scanlinesize) {\n\t\tfprintf (stderr, \"Wrong size of scanline.\\n\");\n\t\treturn -1;\n\t}\n\n\tfor (offset = 0, row = 0; row < length; offset+=scanlinesize, row++) {\n\t\tif (TIFFWriteScanline(tif, (char *)array + offset, row, 0) == -1) {\n\t\t\tfprintf (stderr,\n\t\t\t\t \"Can't write image data at row %lu.\\n\", (long) row);\n\t\t\treturn -1;\n\t\t}\n        }\n\n\treturn 0;\n}",
          "fn_code_pos": [
            [
              258,
              0
            ],
            [
              285,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "write_scanlines",
            "parameters": {
              "tif": "TIFF",
              "array": "tdata_t",
              "size": "tsize_t"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stdio.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/test/custom_dir.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain()\n{\n\tTIFF\t\t*tif;\n\tunsigned char\tbuf[SPP] = { 0, 127, 255 };\n\tuint64          dir_offset = 0, dir_offset2 = 0;\n\tuint64          read_dir_offset = 0, read_dir_offset2 = 0;\n\tuint64          *dir_offset2_ptr = NULL;\n\tchar           *ascii_value;\n\tuint16          count16 = 0;\n\t\n\n\t/* We write the main directory as a simple image. */\n\ttif = TIFFOpen(filename, \"w+\");\n\tif (!tif) {\n\t\tfprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename);\n\t\treturn 1;\n\t}\n\n\tif (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) {\n\t\tfprintf (stderr, \"Can't set ImageWidth tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) {\n\t\tfprintf (stderr, \"Can't set ImageLength tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps)) {\n\t\tfprintf (stderr, \"Can't set BitsPerSample tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, SPP)) {\n\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip)) {\n\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, planarconfig)) {\n\t\tfprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, photometric)) {\n\t\tfprintf (stderr, \"Can't set PhotometricInterpretation tag.\\n\");\n\t\tgoto failure;\n\t}\n\n\t/* Write dummy pixel data. */\n\tif (TIFFWriteScanline(tif, buf, 0, 0) == -1) {\n\t\tfprintf (stderr, \"Can't write image data.\\n\");\n\t\tgoto failure;\n\t}\n\n        if (!TIFFWriteDirectory( tif )) {\n\t\tfprintf (stderr, \"TIFFWriteDirectory() failed.\\n\");\n\t\tgoto failure;\n\t}\n\n\t/* \n\t * Now create an EXIF directory. \n\t */\n\tif (TIFFCreateEXIFDirectory(tif) != 0) {\n\t\tfprintf (stderr, \"TIFFCreateEXIFDirectory() failed.\\n\" );\n\t\tgoto failure;\n\t}\n\n\tif (!TIFFSetField( tif, EXIFTAG_SPECTRALSENSITIVITY, \"EXIF Spectral Sensitivity\")) {\n\t\tfprintf (stderr, \"Can't write SPECTRALSENSITIVITY\\n\" );\n\t\tgoto failure;\n\t}\t\t\n\t\n        if (!TIFFWriteCustomDirectory( tif, &dir_offset )) {\n\t\tfprintf (stderr, \"TIFFWriteCustomDirectory() with EXIF failed.\\n\");\n\t\tgoto failure;\n\t}\n\n\t/*\n\t * Now create a custom directory with tags that conflict with mainline \n\t * TIFF tags.\n\t */\n\t\n\tTIFFFreeDirectory( tif );\n\tif (TIFFCreateCustomDirectory(tif, &customFieldArray) != 0) {\n\t\tfprintf (stderr, \"TIFFCreateEXIFDirectory() failed.\\n\" );\n\t\tgoto failure;\n\t}\n\n\tif (!TIFFSetField( tif, TIFFTAG_IMAGEWIDTH, \"*Custom1\")) { /* not really IMAGEWIDTH */\n\t\tfprintf (stderr, \"Can't write pseudo-IMAGEWIDTH.\\n\" );\n\t\tgoto failure;\n\t}\t\t\n\t\n\tif (!TIFFSetField( tif, TIFFTAG_DOTRANGE, \"*Custom2\")) { /* not really DOTWIDTH */\n\t\tfprintf (stderr, \"Can't write pseudo-DOTWIDTH.\\n\" );\n\t\tgoto failure;\n\t}\t\t\n\t\n        if (!TIFFWriteCustomDirectory( tif, &dir_offset2 )) {\n\t\tfprintf (stderr, \"TIFFWriteCustomDirectory() with EXIF failed.\\n\");\n\t\tgoto failure;\n\t}\n\n\t/*\n\t * Go back to the first directory, and add the EXIFIFD pointer. \n\t */\n\tTIFFSetDirectory(tif, 0);\n\tTIFFSetField(tif, TIFFTAG_EXIFIFD, dir_offset );\n\tTIFFSetField(tif, TIFFTAG_SUBIFD, 1, &dir_offset2 );\n\n\tTIFFClose(tif);\n\t\n\t/* Ok, now test whether we can read written values in the EXIF directory. */\n\ttif = TIFFOpen(filename, \"r\");\n\t\n\tTIFFGetField(tif, TIFFTAG_EXIFIFD, &read_dir_offset );\n\tif( read_dir_offset != dir_offset ) {\n\t\tfprintf (stderr, \"Did not get expected EXIFIFD.\\n\" );\n\t\tgoto failure;\n\t}\n\n\tTIFFGetField(tif, TIFFTAG_SUBIFD, &count16, &dir_offset2_ptr );\n\tread_dir_offset2 = dir_offset2_ptr[0];\n\tif( read_dir_offset2 != dir_offset2 || count16 != 1) {\n\t\tfprintf (stderr, \"Did not get expected SUBIFD.\\n\" );\n\t\tgoto failure;\n\t}\n\n\tif( !TIFFReadEXIFDirectory(tif, read_dir_offset) ) {\n\t\tfprintf (stderr, \"TIFFReadEXIFDirectory() failed.\\n\" );\n\t\tgoto failure;\n\t}\n\t\n\tif (!TIFFGetField( tif, EXIFTAG_SPECTRALSENSITIVITY, &ascii_value) ) {\n\t\tfprintf (stderr, \"reading SPECTRALSENSITIVITY failed.\\n\" );\n\t\tgoto failure;\n\t}\n\n\tif( strcmp(ascii_value,\"EXIF Spectral Sensitivity\") != 0) {\n\t\tfprintf (stderr, \"got wrong SPECTRALSENSITIVITY value.\\n\" );\n\t\tgoto failure;\n\t}\n\n\t/* Try reading the Custom directory */\n\t\n\tif( !TIFFReadCustomDirectory(tif, read_dir_offset2, &customFieldArray) ) {\n\t\tfprintf (stderr, \"TIFFReadCustomDirectory() failed.\\n\" );\n\t\tgoto failure;\n\t}\n\t\n\tif (!TIFFGetField( tif, TIFFTAG_IMAGEWIDTH, &ascii_value) ) {\n\t\tfprintf (stderr, \"reading pseudo-IMAGEWIDTH failed.\\n\" );\n\t\tgoto failure;\n\t}\n\n\tif( strcmp(ascii_value,\"*Custom1\") != 0) {\n\t\tfprintf (stderr, \"got wrong pseudo-IMAGEWIDTH value.\\n\" );\n\t\tgoto failure;\n\t}\n\n\tif (!TIFFGetField( tif, TIFFTAG_DOTRANGE, &ascii_value) ) {\n\t\tfprintf (stderr, \"reading pseudo-DOTRANGE failed.\\n\" );\n\t\tgoto failure;\n\t}\n\n\tif( strcmp(ascii_value,\"*Custom2\") != 0) {\n\t\tfprintf (stderr, \"got wrong pseudo-DOTRANGE value.\\n\" );\n\t\tgoto failure;\n\t}\n\n\tTIFFClose(tif);\n\t\n\t/* All tests passed; delete file and exit with success status. */\n\tunlink(filename);\n\treturn 0;\n\nfailure:\n\t/* \n\t * Something goes wrong; close file and return unsuccessful status.\n\t * Do not remove the file for further manual investigation.\n\t */\n\tTIFFClose(tif);\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              59,
              0
            ],
            [
              242,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            30,
            0
          ],
          [
            31,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "# include <unistd.h>",
          [
            34,
            0
          ],
          [
            34,
            20
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ],
        [
          "#include \"tif_dir.h\"\n",
          [
            38,
            0
          ],
          [
            39,
            0
          ]
        ],
        [
          "#include \"tifftest.h\"\n",
          [
            39,
            0
          ],
          [
            40,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/test/long_tag.c": {
      "fn_def_list": [
        {
          "fn_code": "int\nmain(int argc, char **argv)\n{\n\tTIFF\t\t*tif;\n\tunsigned int\ti;\n\tunsigned char\tbuf[3] = { 0, 127, 255 };\n        (void) argc;\n        (void) argv;\n\n\t/* Test whether we can write tags. */\n\ttif = TIFFOpen(filename, \"w\");\n\tif (!tif) {\n\t\tfprintf (stderr, \"Can't create test TIFF file %s.\\n\", filename);\n\t\treturn 1;\n\t}\n\n\tif (!TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width)) {\n\t\tfprintf (stderr, \"Can't set ImageWidth tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_IMAGELENGTH, length)) {\n\t\tfprintf (stderr, \"Can't set ImageLength tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, 8)) {\n\t\tfprintf (stderr, \"Can't set BitsPerSample tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3)) {\n\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip)) {\n\t\tfprintf (stderr, \"Can't set SamplesPerPixel tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG)) {\n\t\tfprintf (stderr, \"Can't set PlanarConfiguration tag.\\n\");\n\t\tgoto failure;\n\t}\n\tif (!TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB)) {\n\t\tfprintf (stderr, \"Can't set PhotometricInterpretation tag.\\n\");\n\t\tgoto failure;\n\t}\n\n\tfor (i = 0; i < NTAGS; i++) {\n\t\tif (!TIFFSetField(tif, long_tags[i].tag,\n\t\t\t\t  long_tags[i].value)) {\n\t\t\tfprintf(stderr, \"Can't set tag %d.\\n\",\n\t\t\t\t(int)long_tags[i].tag);\n\t\t\tgoto failure;\n\t\t}\n\t}\n\n\t/* Write dummy pixel data. */\n\tif (TIFFWriteScanline(tif, buf, 0, 0) == -1) {\n\t\tfprintf (stderr, \"Can't write image data.\\n\");\n\t\tgoto failure;\n\t}\n\n\tTIFFClose(tif);\n\t\n\t/* Ok, now test whether we can read written values. */\n\ttif = TIFFOpen(filename, \"r\");\n\tif (!tif) {\n\t\tfprintf (stderr, \"Can't open test TIFF file %s.\\n\", filename);\n\t\treturn 1;\n\t}\n\n\tif (CheckLongField(tif, TIFFTAG_IMAGEWIDTH, width) < 0)\n\t\tgoto failure;\n\n\tif (CheckLongField(tif, TIFFTAG_IMAGELENGTH, length) < 0)\n\t\tgoto failure;\n\n\tif (CheckLongField(tif, TIFFTAG_ROWSPERSTRIP, rows_per_strip) < 0)\n\t\tgoto failure;\n\n\tfor (i = 0; i < NTAGS; i++) {\n\t\tif (CheckLongField(tif, long_tags[i].tag,\n\t\t\t\t   long_tags[i].value) < 0)\n\t\t\tgoto failure;\n\t}\n\n\tTIFFClose(tif);\n\t\n\t/* All tests passed; delete file and exit with success status. */\n\tunlink(filename);\n\treturn 0;\n\nfailure:\n\t/* Something goes wrong; close file and return unsuccessful status. */\n\tTIFFClose(tif);\n\tunlink(filename);\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              56,
              0
            ],
            [
              151,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [
        {
          "fn_code": "CheckLongField(TIFF *, ttag_t, uint32)",
          "fn_dec_pos": [
            [
              39,
              11
            ],
            [
              39,
              49
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLongField",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [
        [
          "struct Tags {\n\tttag_t\t\ttag;\n\tshort\t\tcount;\n\tuint32\t\tvalue;\n}",
          {
            "tag": "ttag_t",
            "count": "short",
            "value": "uint32"
          },
          "Tags",
          [
            43,
            7
          ],
          [
            47,
            1
          ]
        ],
        [
          "struct Tags {\n\tttag_t\t\ttag;\n\tshort\t\tcount;\n\tuint32\t\tvalue;\n}",
          {
            "tag": "ttag_t",
            "count": "short",
            "value": "uint32"
          },
          "Tags",
          [
            43,
            7
          ],
          [
            47,
            1
          ]
        ]
      ],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "# include <unistd.h>",
          [
            34,
            0
          ],
          [
            34,
            20
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            37,
            0
          ],
          [
            38,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/test/test_arrays.c": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stddef.h>\n",
          [
            29,
            0
          ],
          [
            30,
            0
          ]
        ],
        [
          "#include \"test_arrays.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/test/raw_decode.c": {
      "fn_def_list": [
        {
          "fn_code": "static int check_cluster( int cluster, unsigned char *buffer, unsigned char *expected_cluster ) {\n\tunsigned char *target = buffer + cluster*6;\n\n\tif (memcmp(target, expected_cluster, 6) == 0) {\n\t\treturn 0;\n\t}\n\n\tfprintf( stderr, \"Cluster %d did not match expected results.\\n\", cluster );\n\tfprintf( stderr, \n\t\t \"Expect: %3d %3d   %3d   %3d\\n\"\n\t\t \"        %3d %3d\\n\", \n\t\t expected_cluster[0], expected_cluster[1],\n\t\t expected_cluster[4], expected_cluster[5],\n\t\t expected_cluster[2], expected_cluster[3] );\n\tfprintf( stderr, \n\t\t \"   Got: %3d %3d   %3d   %3d\\n\"\n\t\t \"        %3d %3d\\n\", \n\t\t target[0], target[1], \n\t\t target[4], target[5],\n\t\t target[2], target[3] );\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              78,
              0
            ],
            [
              99,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "check_cluster",
            "parameters": {
              "cluster": "int",
              "buffer": "unsigned char",
              "expected_cluster": "unsigned char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int check_rgb_pixel( int pixel,\n\t\t\t    int min_red, int max_red,\n\t\t\t    int min_green, int max_green,\n\t\t\t    int min_blue, int max_blue,\n\t\t\t    unsigned char *buffer ) {\n\tunsigned char *rgb = buffer + 3 * pixel;\n\t\n\tif( rgb[0] >= min_red && rgb[0] <= max_red &&\n\t    rgb[1] >= min_green && rgb[1] <= max_green &&\n\t    rgb[2] >= min_blue && rgb[2] <= max_blue ) {\n\t\treturn 0;\n\t}\n\n\tfprintf( stderr, \"Pixel %d did not match expected results.\\n\", pixel );\n\tfprintf( stderr, \"Got R=%d (expected %d..%d), G=%d (expected %d..%d), B=%d (expected %d..%d)\\n\",\n\t\t rgb[0], min_red, max_red,\n\t\t rgb[1], min_green, max_green,\n\t\t rgb[2], min_blue, max_blue );\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              101,
              0
            ],
            [
              120,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "check_rgb_pixel",
            "parameters": {
              "pixel": "int",
              "min_red": "int",
              "max_red": "int",
              "min_green": "int",
              "max_green": "int",
              "min_blue": "int",
              "max_blue": "int",
              "buffer": "unsigned char"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "static int check_rgba_pixel( int pixel,\n\t\t\t     int min_red, int max_red,\n\t\t\t     int min_green, int max_green,\n\t\t\t     int min_blue, int max_blue,\n\t\t\t     int min_alpha, int max_alpha,\n\t\t\t     uint32 *buffer ) {\n\t/* RGBA images are upside down - adjust for normal ordering */\n\tint adjusted_pixel = pixel % 128 + (127 - (pixel/128)) * 128;\n\tuint32 rgba = buffer[adjusted_pixel];\n\n\tif( TIFFGetR(rgba) >= (uint32) min_red &&\n\t    TIFFGetR(rgba) <= (uint32) max_red &&\n\t    TIFFGetG(rgba) >= (uint32) min_green &&\n\t    TIFFGetG(rgba) <= (uint32) max_green &&\n\t    TIFFGetB(rgba) >= (uint32) min_blue &&\n\t    TIFFGetB(rgba) <= (uint32) max_blue &&\n\t    TIFFGetA(rgba) >= (uint32) min_alpha &&\n\t    TIFFGetA(rgba) <= (uint32) max_alpha ) {\n\t\treturn 0;\n\t}\n\n\tfprintf( stderr, \"Pixel %d did not match expected results.\\n\", pixel );\n\tfprintf( stderr, \"Got R=%d (expected %d..%d), G=%d (expected %d..%d), B=%d (expected %d..%d), A=%d (expected %d..%d)\\n\",\n\t\t TIFFGetR(rgba), min_red, max_red,\n\t\t TIFFGetG(rgba), min_green, max_green,\n\t\t TIFFGetB(rgba), min_blue, max_blue,\n\t\t TIFFGetA(rgba), min_alpha, max_alpha );\n\treturn 1;\n}",
          "fn_code_pos": [
            [
              122,
              0
            ],
            [
              150,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "check_rgba_pixel",
            "parameters": {
              "pixel": "int",
              "min_red": "int",
              "max_red": "int",
              "min_green": "int",
              "max_green": "int",
              "min_blue": "int",
              "max_blue": "int",
              "min_alpha": "int",
              "max_alpha": "int",
              "buffer": "uint32"
            },
            "return_type": "int"
          }
        },
        {
          "fn_code": "int\nmain(int argc, char **argv)\n{\n\tTIFF\t\t*tif;\n\tstatic const char *srcfilerel = \"images/quad-tile.jpg.tiff\";\n\tchar *srcdir = NULL;\n\tchar srcfile[1024];\n\tunsigned short h, v;\n\tint status;\n\tunsigned char *buffer;\n\tuint32 *rgba_buffer;\n\ttsize_t sz, szout;\n\tunsigned int pixel_status = 0;\n\n        (void) argc;\n        (void) argv;\n\n\tif ((srcdir = getenv(\"srcdir\")) == NULL) {\n\t\tsrcdir = \".\";\n\t}\n\tif ((strlen(srcdir) + 1 + strlen(srcfilerel)) >= sizeof(srcfile)) {\n\t\tfprintf( stderr, \"srcdir too long %s\\n\", srcdir);\n\t\texit( 1 );\n\t}\n\tstrcpy(srcfile,srcdir);\n\tstrcat(srcfile,\"/\");\n\tstrcat(srcfile,srcfilerel);\n\n\ttif = TIFFOpen(srcfile,\"r\");\n\tif ( tif == NULL ) {\n\t\tfprintf( stderr, \"Could not open %s\\n\", srcfile);\n\t\texit( 1 );\n\t}\n\n\tstatus = TIFFGetField(tif,TIFFTAG_YCBCRSUBSAMPLING, &h, &v);\n\tif ( status == 0 || h != 2 || v != 2) {\n\t\tfprintf( stderr, \"Could not retrieve subsampling tag.\\n\" );\n\t\texit(1);\n\t}\n\n\t/*\n\t * What is the appropriate size of a YCbCr encoded tile?\n\t */\n\tsz = TIFFTileSize(tif);\n\tif( sz != 24576) {\n\t\tfprintf(stderr, \"tiles are %d bytes\\n\", (int)sz);\n\t\texit(1);\n\t}\n\n\tbuffer = (unsigned char *) malloc(sz);\n\n\t/*\n\t * Read a tile in decompressed form, but still YCbCr subsampled.\n\t */\n\tszout = TIFFReadEncodedTile(tif,9,buffer,sz);\n\tif (szout != sz) {\n\t\tfprintf( stderr, \n\t\t\t \"Did not get expected result code from TIFFReadEncodedTile()(%d instead of %d)\\n\", \n\t\t\t (int) szout, (int) sz );\n\t\treturn 1;\n\t}\n\n\tif( check_cluster( 0, buffer, cluster_0 )\n\t    || check_cluster( 64, buffer, cluster_64 )\n\t    || check_cluster( 128, buffer, cluster_128 ) ) {\n\t\texit(1);\n\t}\n\tfree(buffer);\n\n\t/*\n\t * Read a tile using the built-in conversion to RGB format provided by the JPEG library.\n\t */\n\tTIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\n\tsz = TIFFTileSize(tif);\n\tif( sz != 128*128*3) {\n\t\tfprintf(stderr, \"tiles are %d bytes\\n\", (int)sz);\n\t\texit(1);\n\t}\n\n\tbuffer = (unsigned char *) malloc(sz);\n\n\tszout = TIFFReadEncodedTile(tif,9,buffer,sz);\n\tif (szout != sz) {\n\t\tfprintf( stderr, \n\t\t\t \"Did not get expected result code from TIFFReadEncodedTile()(%d instead of %d)\\n\", \n\t\t\t (int) szout, (int) sz );\n\t\treturn 1;\n\t}\n\n\t/*\n\t * JPEG decoding is inherently inexact, so we can't test for exact\n\t * pixel values.  (Well, if we knew exactly which libjpeg version\n\t * we were using, and with what settings, we could expect specific\n\t * values ... but it's not worth the trouble to keep track of.)\n\t * Hence, use ranges of expected values.  The ranges may need to be\n\t * widened over time as more versions of libjpeg appear.\n\t */\n\tpixel_status |= check_rgb_pixel( 0, 15, 18, 0, 0, 18, 41, buffer );\n\tpixel_status |= check_rgb_pixel( 64, 0, 0, 0, 0, 0, 2, buffer );\n\tpixel_status |= check_rgb_pixel( 512, 5, 6, 34, 36, 182, 196, buffer );\n\n\tfree( buffer );\n\n\tTIFFClose(tif);\n\n\t/*\n\t * Reopen and test reading using the RGBA interface.\n\t */\n\ttif = TIFFOpen(srcfile,\"r\");\n\t\n\tsz = 128 * 128 * sizeof(uint32);\n\trgba_buffer = (uint32 *) malloc(sz);\n\t\n\tif (!TIFFReadRGBATile( tif, 1*128, 2*128, rgba_buffer )) {\n\t\tfprintf( stderr, \"TIFFReadRGBATile() returned failure code.\\n\" );\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Currently TIFFReadRGBATile() just uses JPEGCOLORMODE_RGB so this\n\t * trivally matches the last results.  Eventually we should actually\n\t * accomplish it from the YCbCr subsampled buffer ourselves in which\n\t * case the results may be subtly different but similar.\n\t */\n\tpixel_status |= check_rgba_pixel( 0, 15, 18, 0, 0, 18, 41, 255, 255,\n\t\t\t\t\t  rgba_buffer );\n\tpixel_status |= check_rgba_pixel( 64, 0, 0, 0, 0, 0, 2, 255, 255,\n\t\t\t\t\t  rgba_buffer );\n\tpixel_status |= check_rgba_pixel( 512, 5, 6, 34, 36, 182, 196, 255, 255,\n\t\t\t\t\t  rgba_buffer );\n\n\tfree( rgba_buffer );\n\tTIFFClose(tif);\n\n\tif (pixel_status) {\n\t\texit(1);\n\t}\n\t\n\texit( 0 );\n}",
          "fn_code_pos": [
            [
              152,
              0
            ],
            [
              292,
              1
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "main",
            "parameters": {
              "argc": "int",
              "argv": "char"
            },
            "return_type": "int"
          }
        }
      ],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tif_config.h\"\n",
          [
            31,
            0
          ],
          [
            32,
            0
          ]
        ],
        [
          "#include <stdio.h>\n",
          [
            33,
            0
          ],
          [
            34,
            0
          ]
        ],
        [
          "#include <stdlib.h>\n",
          [
            34,
            0
          ],
          [
            35,
            0
          ]
        ],
        [
          "#include <string.h>\n",
          [
            35,
            0
          ],
          [
            36,
            0
          ]
        ],
        [
          "# include <unistd.h>",
          [
            37,
            0
          ],
          [
            37,
            20
          ]
        ],
        [
          "#include \"tiffio.h\"\n",
          [
            40,
            0
          ],
          [
            41,
            0
          ]
        ],
        [
          "#include \"jpeglib.h\" /* Needed for JPEG_LIB_VERSION */\n",
          [
            72,
            0
          ],
          [
            73,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    }
  },
  "head": {
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/test/test_arrays.h": {
      "fn_def_list": [],
      "fn_declaraion": [],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include <stddef.h>\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    },
    "/home/xuhanxiang/project/Fuzzing/oss-fuzz-modified/docker_shared/source_code/libtiff/test/tifftest.h": {
      "fn_def_list": [],
      "fn_declaraion": [
        {
          "fn_code": "CheckShortField(TIFF *, const ttag_t, const uint16)",
          "fn_dec_pos": [
            [
              34,
              4
            ],
            [
              34,
              55
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckShortField",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "CheckShortPairedField(TIFF *, const ttag_t, const uint16*)",
          "fn_dec_pos": [
            [
              35,
              4
            ],
            [
              35,
              62
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckShortPairedField",
            "parameters": {},
            "return_type": "int"
          }
        },
        {
          "fn_code": "CheckLongField(TIFF *, const ttag_t, const uint32)",
          "fn_dec_pos": [
            [
              36,
              4
            ],
            [
              36,
              54
            ]
          ],
          "class_code": "",
          "class_node_pos": [],
          "fn_meta": {
            "identifier": "CheckLongField",
            "parameters": {},
            "return_type": "int"
          }
        }
      ],
      "class_node_list": {},
      "struct_node_list": [],
      "include_list": [
        [
          "#include \"tiffio.h\"\n",
          [
            32,
            0
          ],
          [
            33,
            0
          ]
        ]
      ],
      "global_variables": [],
      "enumerate_node_list": []
    }
  }
}